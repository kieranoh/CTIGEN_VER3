{
  "FUN_00402e40_1": [
    {
      "ATT&CK ID": "T1106",
      "Indicator": "Contains ability to dynamically determine API calls: Found GetProcAddress() and LoadLibraryA() in an import section (Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin)",
      "Comment": "The function dynamically obtains a handle to the `kernel32.dll` module and retrieves the address of the `IsWow64Process` API using `GetProcAddress`. It then calls `IsWow64Process` on the current process handle to determine whether the process is running under the Windows-on-Windows 64-bit subsystem (WOW64). The result of this check is stored in a local variable, which is set to zero if the API call fails or is unavailable. Finally, the function performs a security cookie check to verify stack integrity before returning. This behavior is typically used to detect the process architecture environment, enabling conditional logic based on whether the process is 32-bit running on a 64-bit system.",
      "Matched Sentence": "The function dynamically obtains a handle to the `kernel32.dll` module and retrieves the address of the `IsWow64Process` API using `GetProcAddress`.",
      "Similarity": 0.851625
    },
    {
      "ATT&CK ID": "T1056.004",
      "Indicator": "Hooks API calls: \"Wow64Transition@NTDLL.DLL\" in \"<Input Sample.exe\"",
      "Comment": "The function dynamically obtains a handle to the `kernel32.dll` module and retrieves the address of the `IsWow64Process` API using `GetProcAddress`. It then calls `IsWow64Process` on the current process handle to determine whether the process is running under the Windows-on-Windows 64-bit subsystem (WOW64). The result of this check is stored in a local variable, which is set to zero if the API call fails or is unavailable. Finally, the function performs a security cookie check to verify stack integrity before returning. This behavior is typically used to detect the process architecture environment, enabling conditional logic based on whether the process is 32-bit running on a 64-bit system.",
      "Matched Sentence": "It then calls `IsWow64Process` on the current process handle to determine whether the process is running under the Windows-on-Windows 64-bit subsystem (WOW64).",
      "Similarity": 0.807953
    },
    {
      "ATT&CK ID": "T1082",
      "Indicator": "Contains ability to retrieve the host's architecture (API string): Observed api string:\"GetEnvironmentVariableW\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function dynamically obtains a handle to the `kernel32.dll` module and retrieves the address of the `IsWow64Process` API using `GetProcAddress`. It then calls `IsWow64Process` on the current process handle to determine whether the process is running under the Windows-on-Windows 64-bit subsystem (WOW64). The result of this check is stored in a local variable, which is set to zero if the API call fails or is unavailable. Finally, the function performs a security cookie check to verify stack integrity before returning. This behavior is typically used to detect the process architecture environment, enabling conditional logic based on whether the process is 32-bit running on a 64-bit system.",
      "Matched Sentence": "This behavior is typically used to detect the process architecture environment, enabling conditional logic based on whether the process is 32-bit running on a 64-bit system.",
      "Similarity": 0.825625
    }
  ],
  "FUN_004025a0_1": [
    {
      "ATT&CK ID": "T1106",
      "Indicator": "Imports GetCommandLine API: Observed import api \"GetCommandLineA\" which can \"Retrieves the command-line string for the current process\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function parses a given ASCII string into an array of tokens, dynamically allocating memory to store both the tokens and pointers to their locations. It uses `GlobalAlloc` to reserve a contiguous memory block sized to hold the token pointers and the token strings themselves. The parsing logic iterates through each character of the input string, splitting tokens based on whitespace characters (space, tab, newline, carriage return) while respecting quoted substrings enclosed in double quotes. Quoted sections are treated as single tokens even if they contain whitespace. Each token is null-terminated within the allocated buffer, and pointers to the start of each token are stored sequentially in the initial portion of the allocated memory. The function finally returns a pointer to this memory block and outputs the total number of tokens parsed via an output parameter. This design enables efficient tokenization of command-line style input strings into an easily accessible array of strings for further processing.",
      "Matched Sentence": "This design enables efficient tokenization of command-line style input strings into an easily accessible array of strings for further processing.",
      "Similarity": 0.776427
    }
  ],
  "FUN_00402a30_1": [
    {
      "ATT&CK ID": "T1106",
      "Indicator": "Contains ability to execute program: ShellExecuteW@SHELL32.DLL at 00000000-00005464-41422-3-010F2A30",
      "Comment": "The function begins by calling an internal check function and, if successful, dynamically loads `kernel32.dll` to obtain the address of the `Wow64DisableWow64FsRedirection` API. It then disables the file system redirection on 64-bit Windows systems to ensure that subsequent commands run in the native system context rather than being redirected to the 32-bit subsystem. Following this, the function executes a system command via `ShellExecuteW` to silently delete all Volume Shadow Copies using `vssadmin.exe` with the parameters `delete shadows /all /quiet`. This action is typically associated with anti-forensic or ransomware behavior aimed at preventing system recovery through shadow copies. After executing the command, the function re-enables the file system redirection by calling `Wow64RevertWow64FsRedirection` if it was previously disabled. Throughout its execution, the function uses stack-based security cookie checks to protect against stack corruption. Overall, the function’s behavior focuses on disabling system protections related to shadow copies by manipulating Windows file system redirection and invoking system utilities to remove backup snapshots silently.",
      "Matched Sentence": "It then disables the file system redirection on 64-bit Windows systems to ensure that subsequent commands run in the native system context rather than being redirected to the 32-bit subsystem.",
      "Similarity": 0.785081
    },
    {
      "ATT&CK ID": "T1490",
      "Indicator": "Deletes volume snapshots (often used by ransomware): Deletes volume snapshots files \"vssadmin.exe\" with commandline \"delete shadows /all /quiet\" (UID: 00000000-00004868)",
      "Comment": "The function begins by calling an internal check function and, if successful, dynamically loads `kernel32.dll` to obtain the address of the `Wow64DisableWow64FsRedirection` API. It then disables the file system redirection on 64-bit Windows systems to ensure that subsequent commands run in the native system context rather than being redirected to the 32-bit subsystem. Following this, the function executes a system command via `ShellExecuteW` to silently delete all Volume Shadow Copies using `vssadmin.exe` with the parameters `delete shadows /all /quiet`. This action is typically associated with anti-forensic or ransomware behavior aimed at preventing system recovery through shadow copies. After executing the command, the function re-enables the file system redirection by calling `Wow64RevertWow64FsRedirection` if it was previously disabled. Throughout its execution, the function uses stack-based security cookie checks to protect against stack corruption. Overall, the function’s behavior focuses on disabling system protections related to shadow copies by manipulating Windows file system redirection and invoking system utilities to remove backup snapshots silently.",
      "Matched Sentence": "Following this, the function executes a system command via `ShellExecuteW` to silently delete all Volume Shadow Copies using `vssadmin.exe` with the parameters `delete shadows /all /quiet`.",
      "Similarity": 0.894457
    }
  ],
  "FUN_00402ae0_1": [],
  "FUN_00402eb0_1": [],
  "FUN_00402770_1": [
    {
      "ATT&CK ID": "T1083",
      "Indicator": "Contains ability to enumerates all mounted drives: GetDriveTypeW@KERNEL32.DLL at 00000000-00005464-41422-1-010F49C0",
      "Comment": "The function enumerates a predefined list of drive paths, checking each drive’s type using the `GetDriveTypeW` API to identify drives of type `DRIVE_NO_ROOT_DIR` (value 1), which typically indicates unmounted or empty drives. It collects these drives into an array for further processing. Subsequently, the function allocates two large memory buffers and uses `FindFirstVolumeW` and `FindNextVolumeW` to iterate over all volume GUID paths present on the system.\n\nFor each enumerated volume, the function calls `GetVolumePathNamesForVolumeNameW` to retrieve the mount points associated with that volume. If the volume has no mount points or the mount point path length is not exactly three characters (indicating a root drive letter like \"C:\\\"), the function attempts to mount the volume to one of the previously identified unmounted drives using `SetVolumeMountPointW`. This effectively assigns a drive letter to volumes that currently lack one, potentially making them accessible via standard drive letters.\n\nThe function carefully manages resources by closing the volume enumeration handle with `FindVolumeClose` and freeing the allocated memory buffers after use. The overall behavior focuses on detecting unmounted volumes and programmatically assigning them drive letters from a predefined set of candidate drives, thereby ensuring these volumes become accessible through standard drive letter paths. This operation interacts primarily with volume and drive management APIs and manipulates system volume mount points.",
      "Matched Sentence": "The function enumerates a predefined list of drive paths, checking each drive’s type using the `GetDriveTypeW` API to identify drives of type `DRIVE_NO_ROOT_DIR` (value 1), which typically indicates unmounted or empty drives.",
      "Similarity": 0.8801
    }
  ],
  "FUN_00402d30_1": [
    {
      "ATT&CK ID": "T1057",
      "Indicator": "Contains ability to enumerate processes (API string): Observed api string:\"CreateToolhelp32Snapshot\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed api string:\"Process32FirstW\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed api string:\"Process32NextW\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function enumerates all running processes by creating a snapshot of the system’s process list using `CreateToolhelp32Snapshot` with the `TH32CS_SNAPPROCESS` flag. It then iterates through each process entry with `Process32FirstW` and `Process32NextW`. For each process, it compares the process name against a predefined list of target process names stored in memory. When a match is found, the function attempts to open the corresponding process with `OpenProcess` requesting termination rights. If successful, it forcibly terminates the matched process using `TerminateProcess` with an exit code of 9, then closes the process handle. This loop continues until all processes have been checked. The function’s behavior is focused on identifying and terminating specific processes, likely to remove or disable competing or unwanted software. It interacts primarily with system process management APIs and uses string comparison to identify target processes by name.",
      "Matched Sentence": "The function enumerates all running processes by creating a snapshot of the system’s process list using `CreateToolhelp32Snapshot` with the `TH32CS_SNAPPROCESS` flag.",
      "Similarity": 0.884126
    }
  ],
  "FUN_00403420_1": [],
  "FUN_00403350_1": [],
  "FUN_00403590_1": [],
  "FUN_004034f0_1": [
    {
      "ATT&CK ID": "T1056.004",
      "Indicator": "Installs hooks/patches the running process: \"<Input Sample.exe\" wrote bytes \"d04c7376d0157076a076707640187076\" to virtual address \"0x7710E190\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"10f2437400b94274f0911c77109d437490924374c0b4437450884374d067437440b24374209c4374108c4374a0a44374507c437450a94374c0b34374805d4374c0e6437490754374c0ee4374a0c4437400c0437410d2427460aa4374\" to virtual address \"0x766B0228\" (part of module \"COMBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"f0767476e077747640767476f07574763078747610157176b05e7476807874769077747690767476605e747640777476\" to virtual address \"0x7710E1D4\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"1036097420360974\" to virtual address \"0x766B01A0\" (part of module \"COMBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"b08a5b74a0615b7460905b74c01b5c74d0445b740059607470a85b74e0a75b7410a35b7460365b7410585b74408b5b7420a95b7430375b7490765b7420365b74c0375b74b0475b74f08c5b74\" to virtual address \"0x76D21140\" (part of module \"WINDOWS.STORAGE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"309ffe73f0660174702afd7320a4fe737023fd73003bfe731060fe73b05bfe7300b0fe73805bfe73d081fe73d00dfc73\" to virtual address \"0x740BE018\" (part of module \"GDI32.DLL\")\n \"<Input Sample.exe\" wrote bytes \"8075717650787176600b7076f0747176b075717610297076e074717610757176500b707600757176\" to virtual address \"0x7710E144\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"50167176c0857076\" to virtual address \"0x7710E184\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"90431074100c1074\" to virtual address \"0x74B8432C\" (part of module \"SHELL32.DLL\")\n \"<Input Sample.exe\" wrote bytes \"40f65276b0075776409e5276d0d8527670f05976b0f0527680045376106e537670b75376b0ff5376e0ac627600ba597600415976608a517600915176603c577660f85876606e53765007567650b8567640f859769041597650da5976\" to virtual address \"0x7604D010\" (part of module \"SHCORE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"409b7176c09b7176\" to virtual address \"0x7710E1C8\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"00eb7076f0ea7076e00f7176e0ea7076900f717630eb7076b0eb7076f0db7076700e717670eb7076d0017176\" to virtual address \"0x7710E208\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"e3ddcef2251b0000\" to virtual address \"0xB74C24D0\" (part of module \"NTDLL.DLL\")\n \"<Input Sample.exe\" wrote bytes \"a092da02b092da02b017010080f00600c0020100b0f0060060b20600e091da02f091da02\" to virtual address \"0x7449AC94\" (part of module \"USER32.DLL\")\n \"<Input Sample.exe\" wrote bytes \"80b9717670c9717600cb717620bb7176\" to virtual address \"0x7710E170\" (part of module \"KERNELBASE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"702bbc754038bd754079bc756009bd75e026bc756016bc75a01abc75801dbc75e01abc75d077bc752022bc75b07bbc75e02abc75406bbd75c03dbc756045bc75206cbc751040bc757044bc75203dbc758063bc75303cbd755026bc75\" to virtual address \"0x74B84158\" (part of module \"SHELL32.DLL\")\n \"<Input Sample.exe\" wrote bytes \"d04f6676f0c2507690c6597600cb5076f0f3587640dd587660ef5876102d517680a6507620be577670425976a0be5776c0ff507640bf5776e0585976\" to virtual address \"0x76D215B0\" (part of module \"WINDOWS.STORAGE.DLL\")\n \"<Input Sample.exe\" wrote bytes \"5007567690415976106e5376606e537660f85876a0f95876b0f05276608a5176b0ff5376603c5776f0ef587670f058760041597680045376b0075776b0ff567600915176\" to virtual address \"0x71EA2048\" (part of module \"PROPSYS.DLL\")\n \"<Input Sample.exe\" wrote bytes \"00709d75\" to virtual address \"0x744A4EEC\" (part of module \"USER32.DLL\")\n \"<Input Sample.exe\" wrote bytes \"c0690076a02f007630690076\" to virtual address \"0x76D216F4\" (part of module \"WINDOWS.STORAGE.DLL\")",
      "Comment": "The function performs a conditional data processing routine based on the result of a comparison involving values retrieved from two separate memory locations. Initially, it calls a helper function to process or transform data at a given input pointer and an offset within that input, using two fixed memory addresses as parameters. It then invokes another function to obtain a numeric value from the second parameter pointer. If this value is less than 285 (0x11d), the function returns 0 immediately, indicating an early exit condition.\n\nIf the value meets or exceeds this threshold, the function retrieves another numeric value from a fixed global memory address and enters a loop starting from one less than this value up to 576 (0x240). Within this loop, it repeatedly calls a third helper function, passing the first parameter and the current loop index, likely performing incremental processing or validation steps on the data referenced by the first parameter.\n\nAfter completing the loop, the function calls a final helper function that appears to combine or finalize the processing of the data at the first parameter and its offset, using the second parameter as additional input. The function then returns 1 to indicate successful completion.\n\nOverall, the function orchestrates a multi-step data validation or transformation process that depends on threshold checks and iterative processing. It interacts primarily with memory buffers and fixed data regions, using helper functions to manipulate or verify data segments. The control flow is driven by conditional branching and a bounded loop that ensures processing occurs only when certain criteria are met.",
      "Matched Sentence": "Initially, it calls a helper function to process or transform data at a given input pointer and an offset within that input, using two fixed memory addresses as parameters.",
      "Similarity": 0.78364
    }
  ],
  "FUN_004034b0_1": [
    {
      "ATT&CK ID": "T1106",
      "Indicator": "Contains ability to dynamically load libraries: LoadLibraryA@KERNEL32.DLL at 00000000-00005464-41422-3-010F2A30",
      "Comment": "The function initializes a critical section object to enable thread synchronization and then dynamically loads the `advapi32.dll` library. It retrieves the address of the `SystemFunction036` API from this library, which is a Windows cryptographic function used for data protection (commonly known as `RtlEncryptMemory` or `RtlDecryptMemory`). The function then calls `SystemFunction036`, passing a specific memory buffer and its size (0x58 bytes) as arguments, effectively performing encryption or decryption on that buffer. This behavior indicates the function’s role in securing sensitive data in memory, likely to protect it from unauthorized access or tampering during runtime. The use of dynamic loading and function pointer invocation suggests an intent to obscure direct API usage, possibly to evade static detection or to maintain flexibility in cryptographic operations.",
      "Matched Sentence": "The function initializes a critical section object to enable thread synchronization and then dynamically loads the `advapi32.dll` library.",
      "Similarity": 0.833209
    }
  ],
  "FUN_004037b0_1": [],
  "FUN_00403a00_1": [],
  "FUN_00403ae0_1": [],
  "FUN_00403cb0_1": [],
  "FUN_00403d90_1": [
    {
      "ATT&CK ID": "T1082",
      "Indicator": "Calls an API typically used to get system version information: \"<Input Sample.exe\" called \"RtlGetVersion\" with parameter  (UID: 00000000-00005464)\n \"<Input Sample.exe\" called \"RtlGetVersion\" with parameter  (UID: 00000000-00005464)\n \"<Input Sample.exe\" called \"RtlGetVersion\" (UID: 00000000-00005464)\n \"<Input Sample.exe\" called \"RtlGetVersion\" with parameter  (UID: 00000000-00005464)\n \"cmd.exe\" called \"RtlGetVersion\" (UID: 00000000-00006112)",
      "Comment": "The function performs a series of conditional checks and transformations on its input parameters, invoking multiple helper functions that appear to manipulate or compare data buffers. It begins by calling a verification or comparison routine twice with different parameter pairs. If both calls fail (return zero), it attempts a third check involving a different pair of parameters. Upon success of this third check, the function executes a complex sequence of data processing steps involving buffer copying and transformation functions, which likely perform cryptographic or encoding operations on the input data. These operations involve multiple intermediate buffers and repeated calls to functions that combine or modify these buffers in a layered manner.\n\nIf the third check fails, the function performs an alternative verification on another parameter pair and, based on the result, either calls a function that likely merges or synchronizes the first two parameters or invokes a fallback routine. If the initial checks do not pass, the function calls a separate handler that processes all four parameters together.\n\nThroughout its execution, the function uses stack-allocated buffers to hold intermediate data and applies a security cookie check at the end to ensure stack integrity. The overall behavior suggests the function is designed to validate and transform input data through a series of conditional cryptographic or encoding steps, possibly as part of a data integrity verification, authentication, or secure data preparation routine.",
      "Matched Sentence": "It begins by calling a verification or comparison routine twice with different parameter pairs.",
      "Similarity": 0.757972
    }
  ],
  "FUN_004048a0_1": [
    {
      "ATT&CK ID": "T1106",
      "Indicator": "Calls an API typically used to execute an application: \"<Input Sample.exe\" called \"ShellExecuteW\" with parameter cmd.exe (UID: 00000000-00005464)",
      "Comment": "The function serves as a simple wrapper that sequentially invokes two other functions, passing the same wide-string parameter to each. It first calls a function responsible for performing an operation with the given string and a zero flag, likely initializing or preparing some resource or state associated with the input. Immediately afterward, it calls a second function with the same string parameter, which presumably continues processing or finalizes an action related to the initial call. The function itself does not perform any additional logic or branching and returns a fixed success code (`0`). Overall, it acts as a coordinator that triggers a two-step process involving the provided wide-character string, potentially related to resource setup and subsequent handling, without directly interacting with system APIs or resources within its own scope.",
      "Matched Sentence": "Immediately afterward, it calls a second function with the same string parameter, which presumably continues processing or finalizes an action related to the initial call.",
      "Similarity": 0.75253
    },
    {
      "ATT&CK ID": "T1135",
      "Indicator": "Contains ability to provide information and utilities for managing network resources (API string): Observed api string:\"WNetGetConnectionW  which can retrieves the name of the network resource associated with a local device\"[Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed api string:\"WNetOpenEnumW  which can Starts an enumeration of network resources or existing connections\"[Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed api string:\"WNetEnumResourceW  which can continues an enumeration of network resources\"[Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed api string:\"WNetCloseEnum  which can ends a network resource enumeration\"[Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function serves as a simple wrapper that sequentially invokes two other functions, passing the same wide-string parameter to each. It first calls a function responsible for performing an operation with the given string and a zero flag, likely initializing or preparing some resource or state associated with the input. Immediately afterward, it calls a second function with the same string parameter, which presumably continues processing or finalizes an action related to the initial call. The function itself does not perform any additional logic or branching and returns a fixed success code (`0`). Overall, it acts as a coordinator that triggers a two-step process involving the provided wide-character string, potentially related to resource setup and subsequent handling, without directly interacting with system APIs or resources within its own scope.",
      "Matched Sentence": "Overall, it acts as a coordinator that triggers a two-step process involving the provided wide-character string, potentially related to resource setup and subsequent handling, without directly interacting with system APIs or resources within its own scope.",
      "Similarity": 0.7876
    }
  ],
  "FUN_00404620_1": [
    {
      "ATT&CK ID": "T1083",
      "Indicator": "Contains ability to enumerate files inside a directory: FindFirstFileW@KERNEL32.DLL at 00000000-00005464-41422-7-010F4620",
      "Comment": "The function recursively enumerates files and directories starting from a specified root path, using `FindFirstFileW` and `FindNextFileW` to iterate through directory contents. It filters out certain filenames and skips files with the extension `.__NIST_K571__` as well as a specific ransom note file named \"How To Restore Your Files.txt\". For each qualifying file (i.e., not filtered or excluded), it calls another function—likely responsible for encrypting or processing the file.\n\nThe recursion depth is limited by a parameter to avoid excessive traversal. After completing the directory scan, the function creates or overwrites the ransom note file \"How To Restore Your Files.txt\" in the root directory using `CreateFileW` with write access. It writes a detailed ransom message into this file via `WriteFile`, warning the user that their files and backups have been encrypted and deleted, and instructing them to purchase a decryption tool from a specified Tor onion site. The message also threatens public exposure of the victim’s data if the ransom is ignored and advises against attempting file recovery independently.\n\nFinally, the function releases allocated memory and performs a security cookie check before returning. Overall, the function’s behavior is consistent with ransomware: it traverses and processes files for encryption, avoids re-encrypting certain files, and drops a ransom note to demand payment and provide instructions for data recovery.",
      "Matched Sentence": "The function recursively enumerates files and directories starting from a specified root path, using `FindFirstFileW` and `FindNextFileW` to iterate through directory contents.",
      "Similarity": 0.871264
    },
    {
      "ATT&CK ID": "T1573",
      "Indicator": "Possibly tries to communicate over SSL connection (HTTPS): \"d contact us.\n\nHow to contact us? \n----------------------------------------------\nUsing TOR Browser ( https://www.torproject.org/download/ ):\nhttp://babukq4e2p4wu4iq.onion/login.php?id=8M60J4vCbbkKgM6QnA07E9qpkn0Qk7\n\n!!! DANGER !!!\nDO NOT MODIFY or try to RECOVER any files yourself. We WILL NOT be able to RESTORE them. \n!!! DANGER !!\" (Indicator: \"https://\")",
      "Comment": "The function recursively enumerates files and directories starting from a specified root path, using `FindFirstFileW` and `FindNextFileW` to iterate through directory contents. It filters out certain filenames and skips files with the extension `.__NIST_K571__` as well as a specific ransom note file named \"How To Restore Your Files.txt\". For each qualifying file (i.e., not filtered or excluded), it calls another function—likely responsible for encrypting or processing the file.\n\nThe recursion depth is limited by a parameter to avoid excessive traversal. After completing the directory scan, the function creates or overwrites the ransom note file \"How To Restore Your Files.txt\" in the root directory using `CreateFileW` with write access. It writes a detailed ransom message into this file via `WriteFile`, warning the user that their files and backups have been encrypted and deleted, and instructing them to purchase a decryption tool from a specified Tor onion site. The message also threatens public exposure of the victim’s data if the ransom is ignored and advises against attempting file recovery independently.\n\nFinally, the function releases allocated memory and performs a security cookie check before returning. Overall, the function’s behavior is consistent with ransomware: it traverses and processes files for encryption, avoids re-encrypting certain files, and drops a ransom note to demand payment and provide instructions for data recovery.",
      "Matched Sentence": "It writes a detailed ransom message into this file via `WriteFile`, warning the user that their files and backups have been encrypted and deleted, and instructing them to purchase a decryption tool from a specified Tor onion site.",
      "Similarity": 0.791844
    }
  ],
  "FUN_004048d0_1": [
    {
      "ATT&CK ID": "T1135",
      "Indicator": "Imports windows networking related APIs: Observed import api \"WNetCloseEnum\" which can \"ends a network resource enumeration\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed import api \"WNetEnumResource\" which can \"continues an enumeration of network resources\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed import api \"WNetGetConnection\" which can \"retrieves the name of the network resource associated with a local device\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed import api \"WNetOpenEnum\" which can \"starts an enumeration of network resources or existing connections.\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function performs a recursive enumeration of network resources using Windows Network (WNet) API calls. It begins by calling `WNetOpenEnumW` to initiate an enumeration of network resources of a specified scope and type, using the input parameter as the starting point. Upon successful enumeration initialization, it allocates a buffer to hold the enumerated resource data.\n\nThe function then enters a loop where it repeatedly calls `WNetEnumResourceW` to retrieve batches of network resource entries into the allocated buffer. For each enumerated resource, it inspects a specific attribute flag to determine the resource type. If the resource is not a container (indicated by the absence of a particular flag), it calls another function (`FUN_00404620`) passing the resource’s remote name, likely to process or handle that individual network resource. If the resource is a container (e.g., a network share or directory), the function recursively calls itself with the resource pointer to enumerate its child resources.\n\nAfter completing the enumeration and processing of all resources at the current level, the function frees the allocated buffer and closes the enumeration handle using `WNetCloseEnum`. The function also includes a security cookie check to protect against stack corruption.\n\nOverall, this function systematically traverses the network resource hierarchy starting from a given root, processing leaf resources directly and recursively exploring container resources. It interacts primarily with the Windows networking subsystem through `WNetOpenEnumW`, `WNetEnumResourceW`, and `WNetCloseEnum`, dynamically allocating memory for resource data and employing recursion to handle nested network shares or directories.",
      "Matched Sentence": "It interacts primarily with the Windows networking subsystem through `WNetOpenEnumW`, `WNetEnumResourceW`, and `WNetCloseEnum`, dynamically allocating memory for resource data and employing recursion to handle nested network shares or directories.",
      "Similarity": 0.890681
    }
  ],
  "entry_1": [
    {
      "ATT&CK ID": "T1070",
      "Indicator": "Contains ability to empty the Recycle Bin on the specified drive: SHEmptyRecycleBinA@SHELL32.DLL at 00000000-00005464-41422-1-010F49C0",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.",
      "Similarity": 0.851162
    },
    {
      "ATT&CK ID": "T1082",
      "Indicator": "Contains ability to retrieve information about the current system: GetSystemInfo@KERNEL32.DLL at 00000000-00005464-41422-1-010F49C0",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "The function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count.",
      "Similarity": 0.827665
    },
    {
      "ATT&CK ID": "T1105",
      "Indicator": "Dropped files: \"ecdh_pub_k.bin\" has type \"data\"- Location: [%APPDATA%\\ecdh_pub_k.bin]- [targetUID: 00000000-00005464]\n \"How To Restore Your Files.txt\" has type \"ASCII text with CRLF line terminators\"- Location: [C:\\share\\How To Restore Your Files.txt]- [targetUID: 00000000-00005464]",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`.",
      "Similarity": 0.825324
    },
    {
      "ATT&CK ID": "T1082",
      "Indicator": "Contains ability to determine disk drive type (API string): Observed api string:\"GetDriveTypeW\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.",
      "Similarity": 0.838456
    },
    {
      "ATT&CK ID": "T1135",
      "Indicator": "Contains ability to discover network shares: WNetOpenEnumW@MPR.DLL at 00000000-00005464-41422-6-010F48D0",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "For network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`.",
      "Similarity": 0.842823
    },
    {
      "ATT&CK ID": "T1083",
      "Indicator": "Contains ability to enumerate files on disk (API string): Observed api string:\"FindFirstFileW\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]\n Observed api string:\"FindNextFileW\" [Source: 8203c2f00ecd3ae960cb3247a7d7bfb35e55c38939607c85dbdb5c92f0495fa9.bin]",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`).",
      "Similarity": 0.859589
    },
    {
      "ATT&CK ID": "T1005",
      "Indicator": "Accesses potentially sensitive information from local browsers: \"<Input Sample.exe\" had access to \"%LOCALAPPDATA%\\Microsoft\\Edge\\User Data\\Default\\Safe Browsing Network\\Safe Browsing Cookies-journal\" (Type: \"FileHandle\")",
      "Comment": "The function begins by parsing command-line arguments to set an internal mode flag based on specific switches (`-lanfirst`, `-lansecond`, `-nolan`). It then sets the process shutdown priority to the highest level to influence system shutdown behavior. Following this, it performs several initialization routines through internal function calls and empties the Recycle Bin using `SHEmptyRecycleBinA`.\n\nThe function retrieves system information, particularly the number of processors, and allocates an array of handles sized proportionally to the processor count. It proceeds to prepare and write a binary data blob to a file named `ecdh_pub_k.bin` located in the current user's `%APPDATA%` directory, using `CreateFileW` and `WriteFile`. This file likely contains cryptographic material or configuration data.\n\nDepending on the earlier mode flag, it conditionally invokes a network-related function, possibly to initialize or modify network resources. The function then enumerates all logical drives on the system using `GetLogicalDrives` and iterates over each drive letter from `A:` to `Z:`. For each active drive, it checks the drive type with `GetDriveTypeW` and handles network shares differently from local drives.\n\nFor network drives, it attempts to resolve the remote network path using `WNetGetConnectionW`. For both network and local drives, it spawns worker threads (`CreateThread`) to process each drive concurrently, managing these threads with a handle array and synchronizing their completion via `WaitForMultipleObjects`. The thread routine likely performs operations such as scanning, copying, or modifying files on the drives.\n\nAfter processing all drives, the function performs a final network resource cleanup if the mode flag indicates so, waits for all threads to finish, closes all thread handles, frees allocated memory, and calls cleanup routines before terminating the process with `ExitProcess`.\n\nOverall, the function’s behavior centers on preparing cryptographic or configuration data, enumerating and processing all accessible drives (local and network), and managing concurrent worker threads to perform drive-specific tasks. It interacts extensively with system APIs related to file I/O (`CreateFileW`, `WriteFile`), drive enumeration (`GetLogicalDrives`, `GetDriveTypeW`), network resource management (`WNetGetConnectionW`), thread creation and synchronization (`CreateThread`, `WaitForMultipleObjects`), and environment variables (`GetEnvironmentVariableW`). The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Matched Sentence": "The use of the `%APPDATA%` path and the naming of the binary file suggest persistence or cryptographic key handling, while the drive enumeration and threaded processing imply a broad system-wide operation, potentially for data collection, propagation, or modification.",
      "Similarity": 0.810526
    }
  ],
  "MPR.DLL::WNetOpenEnumW_1": [
    {
      "ATT&CK ID": "T1112",
      "Indicator": "Modifies proxy settings: \"<Input Sample.exe\" (Access type: \"SETVAL\"; Path: \"HKCU\\SOFTWARE\\MICROSOFT\\WINDOWS\\CURRENTVERSION\\INTERNET SETTINGS\\ZONEMAP\"; Key: \"PROXYBYPASS\"; Value: \"01000000\")",
      "Comment": "The function acts as a straightforward wrapper that directly calls the original `WNetOpenEnumW` API with the provided parameters and returns its result without any additional processing or modification. It takes the same arguments as the Windows Network API function `WNetOpenEnumW`, which enumerates network resources based on scope, type, and usage filters. The function does not interact with any system resources beyond forwarding the call, nor does it implement any control flow beyond this single invocation and return. Essentially, it serves as a pass-through proxy to the underlying system API, preserving the original behavior and output.",
      "Matched Sentence": "Essentially, it serves as a pass-through proxy to the underlying system API, preserving the original behavior and output.",
      "Similarity": 0.76811
    }
  ],
  "MPR.DLL::WNetCloseEnum_1": []
}