[
    {
        "Indicator": "Found email domains (string): file/memory contains long string with (Indicator: \"@gmail.\"; File: \"usbpower\")",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.70370702,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.69253897,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.68402782,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.66654795,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.66686743,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.69040982,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.71292525,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.70943884,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.7181016,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.72651514,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Contains ability to set the socket options (syscall string): Observed string: \"setsockopt\" (Indicator: \"setsockopt\")",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.71553293,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.72785004,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.75660708,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.83202061,
                "Label": 1
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.75742843,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.77803121,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.74673471,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.77054338,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.7044263,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.74927557,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Modifies socket options: /home/ubuntu/usbpower uses: setsockopt",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.7107852,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.72953095,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.73124806,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.79444447,
                "Label": 1
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.71781749,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.74495466,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.73339227,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.76165437,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.68752088,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.73162422,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Creates a daemon out of the process (syscall): /home/ubuntu/usbpower daemonizes itself into background with: setsid",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.75420087,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.78478039,
                "Label": 1
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.71548564,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.68600155,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.69539139,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.7162937,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.70434302,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.72551422,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.69981567,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.74337317,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Modifies socket options: /tmp/usbpower.elf uses: setsockopt",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.72377645,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.71881268,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.74219115,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.80145082,
                "Label": 1
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.72689954,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.73576814,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.73136141,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.7454696,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.68224885,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.72496247,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Contains CRYPTO related strings: Found string \"ECDHE-RSA-CHACHA20-POLY1305-SHA256\" (Indicator: \"chacha\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-CHACHA20-POLY1305-SHA256\" (Indicator: \"chacha\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-CHACHA20-POLY1305-SHA256\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"ECDHE-DHE-CHACHA20-POLY1305-SHA256\" (Indicator: \"chacha\"; File: \"usbpower\")\n Found string \"ECDSA_SIGN_SHA512\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"DHE-RSA-AES256CBC-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"DHE-RSA-AES256CBC-SHA256\" (Indicator: \"aes256\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES128CBC-SHA\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES128CBC-SHA\" (Indicator: \"aes128\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES256CBC-SHA\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES256CBC-SHA\" (Indicator: \"aes256\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES128CBC-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES128CBC-SHA256\" (Indicator: \"aes128\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES128GCM-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES128GCM-SHA256\" (Indicator: \"aes128\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES256GCM-SHA384\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-RSA-AES256GCM-SHA384\" (Indicator: \"aes256\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128CBC-SHA\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128CBC-SHA\" (Indicator: \"aes128\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128CBC-SHA\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256CBC-SHA\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256CBC-SHA\" (Indicator: \"aes256\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256CBC-SHA\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128CBC-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128CBC-SHA256\" (Indicator: \"aes128\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128CBC-SHA256\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256CBC-SHA384\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256CBC-SHA384\" (Indicator: \"aes256\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256CBC-SHA384\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128GCM-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128GCM-SHA256\" (Indicator: \"aes128\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES128GCM-SHA256\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256GCM-SHA384\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256GCM-SHA384\" (Indicator: \"aes256\"; File: \"usbpower\")\n Found string \"ECDHE-ECDSA-AES256GCM-SHA384\" (Indicator: \"ecdsa\"; File: \"usbpower\")\n Found string \"TLS-AES-128-GCM-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"TLS-AES-256-GCM-SHA384\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"TLS-CHACHA20-POLY1305-SHA256\" (Indicator: \"chacha\"; File: \"usbpower\")\n Found string \"TLS-AES-128-CCM-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"TLS-AES-128-CCM-8-SHA256\" (Indicator: \"aes\"; File: \"usbpower\")\n Found string \"rijndael\" (Indicator: \"rijndael\"; File: \"usbpower\")",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.68316792,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.67932346,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.64309511,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.66595691,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.63771316,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.67280563,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.70873808,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.71147832,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.70082115,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.69491509,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Shows ability to use encryption for command and control traffic: The analysis shows use of encryption\n use of http/https that can be used to send encrypted data on command and control server. Matched sigs: YARA signature match - AES encryption\n Matched sigs: Found potential URL in binary/memory",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.67424944,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.70482213,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.66830902,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.67728574,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.67590592,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.71709109,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.721384,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.74385453,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.72451661,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.74745062,
                "Label": 1
            }
        ]
    },
    {
        "Indicator": "Queries DNS server: \"api.snapcraft.io\"",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.68904897,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.6825969,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.6920823,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.69322397,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.66845495,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.72089154,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.70944667,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.74095714,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.69829733,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.7255061,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Found a cryptographic related string in Linux binary: Observed cryptographic string -(Indicator: \"prime192v1\")\n Observed cryptographic string -(Indicator: \"prime192v2\")\n Observed cryptographic string -(Indicator: \"prime192v3\")\n Observed cryptographic string -(Indicator: \"prime239v2\")",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.72146815,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.71596691,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.68779927,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.69765352,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.66561458,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.68836669,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.74026989,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.72696103,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.72233513,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.69114106,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Monitors network traffic via raw socket: /home/ubuntu/usbpower executed: socket with AF_PACKET and SOCK_RAW",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.74320322,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.7581421,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.75650778,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.72246112,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.75195796,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.83404114,
                "Label": 1
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.80848989,
                "Label": 1
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.80254684,
                "Label": 1
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.76723986,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.80466226,
                "Label": 1
            }
        ]
    },
    {
        "Indicator": "Shows ability to obfuscate file or information: The analysis contains indicators for cyrpto or data obfuscation(base64/decrypt) which can hide information. Matched sigs: Contains CRYPTO related strings\n Matched sigs: Found a cryptographic related string in Linux binary\n Matched sigs: YARA signature match - AES encryption",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.68191779,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.69638769,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.62747344,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.66410884,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.64516954,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.67329277,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.70011925,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.69847878,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.70200828,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.68158492,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Binary is stripped: usbpower is stripped",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.70854141,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.73213111,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.67587175,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.67579712,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.66424858,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.72341968,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.73006419,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.75511024,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.73538517,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.72823556,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Calls native functions (syscalls): Calls a syscall: \"execve\"\n Calls a syscall: \"brk\"\n Calls a syscall: \"arch_prctl\"\n Calls a syscall: \"access\"\n Calls a syscall: \"openat\"\n Calls a syscall: \"fstat\"\n Calls a syscall: \"mmap\"\n Calls a syscall: \"close\"\n Calls a syscall: \"read\"\n Calls a syscall: \"pread\"\n Calls a syscall: \"mprotect\"\n Calls a syscall: \"munmap\"\n Calls a syscall: \"flock\"\n Calls a syscall: \"clone\"\n Calls a syscall: \"exit_group\"\n Calls a syscall: \"procexit\"\n Calls a syscall: \"open\"\n Calls a syscall: \"create\"\n Calls a syscall: \"recvfrom\"\n Calls a syscall: \"setsid\"\n Calls a syscall: \"rt_sigaction\"\n Calls a syscall: \"clock_nanosleep\"\n Calls a syscall: \"socket\"\n Calls a syscall: \"setsockopt\"",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.69690812,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.72299119,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.75233499,
                "Label": 1
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.75038934,
                "Label": 1
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.7362361,
                "Label": 1
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.68665556,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.70179067,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.72190687,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.67202952,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.67599529,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "JA3 SSL client fingerprint: Observed JA3 fingerprint: 473cd7cb9faa642487833865d516e578",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.69601007,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.70452364,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.69441705,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.68394179,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.69758864,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.72321035,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.73426142,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.7407906,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.72768916,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.72844868,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Contains native function calls (syscalls strings): Found reference to API \"socket\" (Indicator: \"socket\"; File: \"usbpower\")\n Found reference to API \"fopen\" (Indicator: \"open\"; File: \"usbpower\")\n Found reference to API \"connect\" (Indicator: \"connect\"; File: \"usbpower\")\n Found reference to API \"nanosleep\" (Indicator: \"nanosleep\"; File: \"usbpower\")\n Found reference to API \"popen\" (Indicator: \"open\"; File: \"usbpower\")\n Found reference to API \"flock\" (Indicator: \"flock\"; File: \"usbpower\")\n Found reference to API \"gmtime\" (Indicator: \"time\"; File: \"usbpower\")\n Found reference to API \"chdir\" (Indicator: \"chdir\"; File: \"usbpower\")\n Found reference to API \"fclose\" (Indicator: \"close\"; File: \"usbpower\")\n Found reference to API \"setsockopt\" (Indicator: \"setsockopt\"; File: \"usbpower\")\n Found reference to API \"recvfrom\" (Indicator: \"recvfrom\"; File: \"usbpower\")\n Found reference to API \"fread\" (Indicator: \"read\"; File: \"usbpower\")\n Found reference to API \"setsid\" (Indicator: \"setsid\"; File: \"usbpower\")\n Found reference to API \"Duplicate PK key found on keyring.\" (Indicator: \"dup\"; File: \"usbpower\")\n Found reference to API \"utctime != NULL\" (Indicator: \"time\"; File: \"usbpower\")\n Found reference to API \"stat != NULL\" (Indicator: \"stat\"; File: \"usbpower\")\n Found reference to API \"Error reading the PRNG.\" (Indicator: \"read\"; File: \"usbpower\")",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.71249567,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.72661861,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.72290861,
                "Label": 1
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.73068111,
                "Label": 1
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.70717163,
                "Label": 1
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.69489529,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.71623239,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.74392806,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.68577629,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.70818095,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Found potential URL in binary/memory: Heuristic match: \"api.snapcraft.io\"",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.70647333,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.69917065,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.69770625,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.68431547,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.67164883,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.71128958,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.72610418,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.74032297,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.71771804,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.72153049,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Reads files: /home/ubuntu/usbpower reads file <f>/lib/x86_64-linux-gnu/libc.so.6",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.76856993,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.74370083,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.72124467,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.71606956,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.73747563,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.71804752,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.72318657,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.73219721,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.686725,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.7098825,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Shows ability to deobfuscate/decode files or information: The analysis shows use of encryption and can be used to decode file or information. Matched sigs: YARA signature match - AES encryption",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.70523188,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.70379655,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.65287476,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.66786661,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.68166701,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.73062189,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.72918308,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.71868158,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.73287087,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.7071401,
                "Label": 0
            }
        ]
    },
    {
        "Indicator": "Binary is stripped: afa8a32ec29a31f152ba20a30eb483520fe50f2dce6c9aa9135d88f7c9c511d7.bin is stripped",
        "Threshold": 0.0,
        "Matched_Reports": [
            {
                "Report": "When executed, the BPFdoor sample will attempt to create and get a lock on a runtime file at “/var/run/initd.lock” and will exit if it fails using that file as a makeshift mutex.",
                "Score": 0.73281267,
                "Label": 0
            },
            {
                "Report": "If successful, BPFdoor will fork itself and continue to run as a child process and in this context will close its stdin, stdout, and stderr streams, and set itself to ignore the following operating system signals: SIGHUP, SIGINT, SIGQUIT, SIGPIPE, SIGCHLD, SIGTTIN, SIGTTOU",
                "Score": 0.74380266,
                "Label": 0
            },
            {
                "Report": "Having set up the above, BPFdoor then allocates a memory buffer and creates a socket as follows: int32_t socket(enum __socket_domain domain, enum __socket_type type, int32_t protocol) 00401370  return socket(domain: domain, type: type, protocol: protocol) __tailcall call    malloc // protocol mov     edx, 0x300 // type mov     esi, 0x3 // domain mov     edi, 0x11 mov     rbx, rax call    socket",
                "Score": 0.70631611,
                "Label": 0
            },
            {
                "Report": "It will proceed to specify the following socket options using setsockopt: int32_t setsockopt(int32_t sockfd, int32_t level, int32_t optname, void const* optval, socklen_t optlen) 004010a0  return setsockopt(sockfd: sockfd, level: level, optname: optname, optval: optval, optlen: optlen) __tailcall mov     ecx, 0x1e        // optlen mov     r8d, 0x10 rep movsq qword [rdi], [rsi]   {0x0} // optname mov     edx, 0x1a mov     rcx, rsp {var_108}     // optval // level mov     esi, 0x1 mov     edi, r9d              // fd mov     qword [rsp+0x8 {var_100}], rax {var_f8} call    setsockopt",
                "Score": 0.708511,
                "Label": 0
            },
            {
                "Report": "And will read from it in a loop (further described below) using recvfrom: ssize_t recvfrom(int32_t fd, void* buf, size_t len, int32_t flags, union __SOCKADDR_ARG addr, socklen_t* addrlen) 00401250  return recvfrom(fd: fd, buf: buf, len: len, flags: flags, addr: addr, addrlen: addrlen) __tailcall",
                "Score": 0.70726837,
                "Label": 0
            },
            {
                "Report": "This creates the socket as a special packet sniffing socket which is able to read every packet that is sent to the machine from the ethernet layer and above without being bound to any specific protocol.",
                "Score": 0.7244827,
                "Label": 0
            },
            {
                "Report": "BPFdoor employs this type of packet sniffing socket to read data with recvfrom, even without an “addr” parameter, by using the loop below to search for a specific “magic” byte sequence: “Magic” byte sequence: \\x44\\x30\\xCD\\x9F\\x5E\\x14\\x27\\x66",
                "Score": 0.75558546,
                "Label": 0
            },
            {
                "Report": "BPFdoor guides the kernel to set up its socket to only read UDP, TCP, and SCTP traffic coming through ports 22 (ssh), 80 (http), and 443 (https).",
                "Score": 0.75374726,
                "Label": 0
            },
            {
                "Report": "When BPFdoor finds a packet containing its “magic” bytes in the filtered traffic it will treat it as a message from its operator and will parse out two fields and will again fork itself.",
                "Score": 0.76359225,
                "Label": 0
            },
            {
                "Report": "The parent process will continue and monitor the filtered traffic coming through the socket while the child will treat the previously parsed fields as a Command & Control IP-Port combination and will attempt to contact it.",
                "Score": 0.73391009,
                "Label": 0
            }
        ]
    }
]