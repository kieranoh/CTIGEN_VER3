{"Function Name": "FUN_10001000", "Address": "10001000", "Source Code": "\nundefined4 handleRequest(void) // Function declaration with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnBeginRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001020", "Address": "10001020", "Source Code": "\nundefined4 handlePostBeginRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostBeginRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001040", "Address": "10001040", "Source Code": "\nundefined4 authenticateRequestHandler(void) // Function declaration with return type undefined4\n{\n    // Output a debug message indicating that the OnAuthenticateRequest method was not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnAuthenticateRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001060", "Address": "10001060", "Source Code": "\nundefined4 handlePostAuthenticateRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostAuthenticateRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001080", "Address": "10001080", "Source Code": "\nundefined4 handleAuthorizationRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnAuthorizeRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100010a0", "Address": "100010a0", "Source Code": "\nundefined4 handlePostAuthorizeRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostAuthorizeRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100010c0", "Address": "100010c0", "Source Code": "\nundefined4 resolveRequestCacheHandler(void) // Function declaration returning an undefined 4-byte value\n{\n    // Output a debug string to the debug output window\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnResolveRequestCache but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerDebuggerBreakpoint();\n    \n    // Return 0 indicating no error or a default value\n    return 0;\n}\n"}
{"Function Name": "FUN_100010e0", "Address": "100010e0", "Source Code": "\nundefined4 handlePostResolveRequestCache(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debug output window\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostResolveRequestCache but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerDebuggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001100", "Address": "10001100", "Source Code": "\nundefined4 handleEventSubscription(void) // Function definition with return type undefined4\n{\n    // Output a debug message indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnMapRequestHandler but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001120", "Address": "10001120", "Source Code": "\nundefined4 handleEventSubscription(void) // Function definition with return type undefined4\n{\n    // Output a debug string to indicate that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostMapRequestHandler but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n\n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n\n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001140", "Address": "10001140", "Source Code": "\nundefined4 handleRequestState(void) // Function declaration with return type undefined4\n{\n    // Output a debug string to indicate that the event was not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnAcquireRequestState but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n\n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n\n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001160", "Address": "10001160", "Source Code": "\nundefined4 handleEventSubscription(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostAcquireRequestState but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001180", "Address": "10001180", "Source Code": "\nundefined4 executeRequestHandler(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPreExecuteRequestHandler but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100011a0", "Address": "100011a0", "Source Code": "\nundefined4 handlePostPreExecuteRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostPreExecuteRequestHandler but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100011c0", "Address": "100011c0", "Source Code": "\nundefined4 executeRequestHandler(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnExecuteRequestHandler but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100011e0", "Address": "100011e0", "Source Code": "\nundefined4 executeRequestHandler(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostExecuteRequestHandler but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001200", "Address": "10001200", "Source Code": "\nundefined4 handleReleaseRequestState(void) // Function declaration returning an undefined 4-byte integer\n{\n    // Output a debug string to indicate that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnReleaseRequestState but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001220", "Address": "10001220", "Source Code": "\nundefined4 handlePostReleaseRequestState(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostReleaseRequestState but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001240", "Address": "10001240", "Source Code": "\nundefined4 handleUpdateRequestCache(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debug output window\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnUpdateRequestCache but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerDebuggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001260", "Address": "10001260", "Source Code": "\nundefined4 handlePostUpdateRequestCache(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostUpdateRequestCache but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001280", "Address": "10001280", "Source Code": "\nundefined4 logRequestHandler(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logWarning(\n        \"This module subscribed to event CHttpModule::OnLogRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100012a0", "Address": "100012a0", "Source Code": "\nundefined4 handlePostLogRequest(void) // Function declaration with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostLogRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100012c0", "Address": "100012c0", "Source Code": "\nundefined4 handleEndRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug message indicating that the OnEndRequest method was not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnEndRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100012e0", "Address": "100012e0", "Source Code": "\nundefined4 handlePostEndRequest(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnPostEndRequest but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001300", "Address": "10001300", "Source Code": "\nundefined4 handleOnSendResponse(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event OnSendResponse was not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnSendResponse but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001320", "Address": "10001320", "Source Code": "\nundefined4 handleEvent(void) // Function definition with return type undefined4\n{\n    // Output a debug string to the debugger with a warning message\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnMapPath but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint in the debugger\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001340", "Address": "10001340", "Source Code": "\nundefined4 handleEventSubscription(void) // Function definition with return type undefined4\n{\n    // Output a debug string to indicate that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnReadEntity but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function's completion\n    return 0;\n}\n"}
{"Function Name": "FUN_10001360", "Address": "10001360", "Source Code": "\nundefined4 handleCustomRequestNotification(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnCustomRequestNotification but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_10001380", "Address": "10001380", "Source Code": "\nundefined4 handleAsyncCompletion(void) // Function definition with return type undefined4\n{\n    // Output a debug string indicating that the event was subscribed but not overridden\n    logDebugMessage(\n        \"This module subscribed to event CHttpModule::OnAsyncCompletion but did not override the method in its CHttpModule implementation.  Please check the method signature to make sure it matches the corresponding method.\\n\"\n    );\n    \n    // Trigger a breakpoint for debugging purposes\n    triggerBreakpoint();\n    \n    // Return 0 indicating the function has completed\n    return 0;\n}\n"}
{"Function Name": "FUN_100013a0", "Address": "100013a0", "Source Code": "\nvoid __fastcall FUN_100013a0(int *input_pointer) // Function definition with fast call convention\n{\n    if (input_pointer) { // Check if the input pointer is not null\n        (**(code **)(*input_pointer + 0x78))(1); // Dereference the pointer, access the function at offset 0x78, and call it with argument 1\n    }\n}\n"}
{"Function Name": "FUN_100013b0", "Address": "100013b0", "Source Code": "\nvoid __fastcall FUN_100013b0(undefined4 *httpModulePointer) // Function definition with fastcall calling convention\n{\n    *httpModulePointer = CHttpModule::vftable; // Assign the vftable of CHttpModule to the location pointed by param_1\n}\n"}
{"Function Name": "FUN_100013c0", "Address": "100013c0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100013c0(void *object, byte flag)\n{\n    // Set the virtual function table for the object pointed to by 'this'\n    *(undefined ***)object = CHttpModule::vftable;\n\n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n\n    // Return the pointer to 'this' cast to undefined4*\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_100013c0(void *object, byte flag)\n{\n    *(undefined ***)object = CHttpModule::vftable;\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_100013e0", "Address": "100013e0", "Source Code": "\n// Function declaration with __fastcall calling convention\nvoid __fastcall FUN_100013e0(void *memory_pointer)\n{\n    // Free the memory allocated to the pointer 'param_1'\n    _free(memory_pointer);\n}\n"}
{"Function Name": "RegisterModule", "Address": "10001560", "Source Code": "\nint RegisterModule(undefined4 module_id, int *function_ptr, int flag)\n{\n    int return_value; // Variable to store return value of function calls\n    __time64_t current_time; // Variable to hold the current time\n\n    current_time = __time64((__time64_t *)0x0); // Get the current time\n    FUN_10010914((ulong)current_time); // Call a function with the current time as argument\n\n    // Check if param_2 is not null and param_3 is not zero\n    if (function_ptr != (int *)0x0 && flag != 0) {\n        _DAT_10035a44 = (**(code **)(*function_ptr + 4))(); // Call a function pointer from param_2 and store the result\n        _DAT_10035a40 = flag; // Store param_3 in a global variable\n\n        undefined4 *allocated_memory = (undefined4 *)operator_new(4); // Allocate memory for an array of 4 bytes\n        if (allocated_memory != (undefined4 *)0x0) { // Check if memory allocation was successful\n            *allocated_memory = SecurityHttpModuleFactory::vftable; // Assign the vtable of SecurityHttpModuleFactory to allocated memory\n            return_value = (**(code **)(*function_ptr + 8))(allocated_memory, 0x20000811, 0); // Call another function pointer from param_2 with the allocated memory and other parameters\n            if (return_value < 0) { // Check if the function call was unsuccessful\n                _free(allocated_memory); // Free the allocated memory if the call failed\n            }\n            return return_value; // Return the result of the function call\n        }\n        return -0x7ff8fff8; // Return an error code if memory allocation failed\n    }\n    return -0x7ff8ffa9; // Return an error code if param_2 is null or param_3 is zero\n}\n"}
{"Function Name": "FUN_10001710", "Address": "10001710", "Source Code": "\nundefined4 __cdecl FUN_10001710(int *first_array, int *second_array, uint byte_count)\n{\n    undefined4 return_value; // Variable to hold the return value\n    int byte_difference; // Variable to hold the difference between bytes\n\n    // Check if the number of bytes to compare is greater than 3\n    if (byte_count > 3) {\n        do {\n            // If the current integers pointed by param_1 and param_2 are not equal, jump to label LAB_1000173b\n            if (*first_array != *second_array) goto LAB_1000173b;\n            byte_count -= 4; // Decrease the count of bytes to compare by 4\n            second_array++; // Move to the next integer in param_2\n            first_array++; // Move to the next integer in param_1\n        } while (byte_count > 3); // Continue while there are more than 3 bytes left to compare\n    }\n\n    // If there are no bytes left to compare, return 0\n    if (byte_count == 0) {\n        return 0;\n    }\n\nLAB_1000173b:\n    // Compare the first byte of the current integers pointed by param_1 and param_2\n    byte_difference = (uint)*(byte *)first_array - (uint)*(byte *)second_array;\n    // If the first byte is equal\n    if (byte_difference == 0) {\n        // If only 1 byte is to be compared, return 0\n        if (byte_count == 1) return 0;\n        // Compare the second byte\n        byte_difference = (uint)*(byte *)((int)first_array + 1) - (uint)*(byte *)((int)second_array + 1);\n        // If the second byte is equal\n        if (byte_difference == 0) {\n            // If only 2 bytes are to be compared, return 0\n            if (byte_count == 2) return 0;\n            // Compare the third byte\n            byte_difference = (uint)*(byte *)((int)first_array + 2) - (uint)*(byte *)((int)second_array + 2);\n            // If the third byte is equal and only 3 bytes are to be compared, return 0\n            if (byte_difference == 0 && byte_count == 3) return 0;\n        }\n    }\n\n    return_value = 1; // Set return value to 1 indicating the values are different\n    // Return 0xffffffff if the difference is less than 1, otherwise return uVar1\n    return (byte_difference < 1) ? 0xffffffff : return_value;\n}\n"}
{"Function Name": "FUN_10001910", "Address": "10001910", "Source Code": "\nvoid __fastcall FUN_10001910(undefined4 *locale_facet_vftable_pointer) // Function definition with fastcall calling convention\n{\n    *locale_facet_vftable_pointer = std::locale::facet::vftable; // Assign the vftable of std::locale::facet to the location pointed by param_1\n}\n"}
{"Function Name": "FUN_10001920", "Address": "10001920", "Source Code": "\nvoid __fastcall FUN_10001920(uint *input_pointer)\n{\n    // Check if the value pointed to by param_1 is not zero\n    if (*input_pointer != 0) {\n        // Call another function FUN_10001890 with the value of *param_1 and store the result in puVar1\n        undefined4 *function_pointer = (undefined4 *)FUN_10001890(*input_pointer);\n        \n        // Check if puVar1 is not a null pointer\n        if (function_pointer != (undefined4 *)0x0) {\n            // Dereference puVar1 and call the function it points to with the argument 1\n            (**(code **)*function_pointer)(1);\n        }\n    }\n}\n"}
{"Function Name": "FUN_10001940", "Address": "10001940", "Source Code": "\\*\nundefined4 * method FUN_10001940(void *object, byte flag)\n{\n    // Set the vftable pointer of the current object to the locale facet vftable\n    *(undefined ***)object = std::locale::facet::vftable;\n\n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for the current object if the condition is true\n        _free(object);\n    }\n\n    // Return the pointer to the current object\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * method FUN_10001940(void *object, byte flag)\n{\n    *(undefined ***)object = std::locale::facet::vftable;\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10001af0", "Address": "10001af0", "Source Code": "\\*\nundefined4 * methodCall FUN_10001af0(void *object, byte flag)\n{\n    // Set the virtual table pointer for the object to the ios_base vftable\n    *(undefined ***)object = std::ios_base::vftable;\n\n    // Call the destructor for the ios_base object\n    std::ios_base::_Ios_base_dtor((ios_base *)object);\n\n    // If the first bit of param_1 is set, free the memory allocated for this object\n    if (flag & 1) {\n        _free(object);\n    }\n\n    // Return a pointer to the current object\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * methodCall FUN_10001af0(void *object, byte flag)\n{\n    *(undefined ***)object = std::ios_base::vftable;\n    std::ios_base::_Ios_base_dtor((ios_base *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10001b20", "Address": "10001b20", "Source Code": "\nuint FUN_10001b20(char *input_string) // Function definition with a char pointer parameter\n{\n    uint result = 0x25; // Initialize uVar2 with a constant value\n    char current_char; // Declare a character variable to hold the current character\n\n    // Loop through each character in the input string until the null terminator is reached\n    while ((current_char = *input_string++) != '\\0') {\n        // Update uVar2 using a combination of multiplication and bitwise XOR with the current character\n        result = result * 0x338e30d ^ current_char * 0x4965e80;\n    }\n    \n    // Return the result of uVar2 modulo a constant value\n    return result % 0x52f0b23;\n}\n"}
{"Function Name": "FUN_10001be0", "Address": "10001be0", "Source Code": "\nvoid __fastcall FUN_10001be0(int input_param)\n{\n    // Dereference the pointer located at (param_1 - 8) to get an integer\n    // and add (param_1 - 4) to it, then store the vtable pointer of\n    // std::basic_istream<char, struct std::char_traits<char>> at that address.\n    *(undefined ***)(*(int *)(input_param - 8) + input_param - 4) =\n    std::basic_istream<char,struct_std::char_traits<char>_>::vtable_pointer;\n}\n"}
{"Function Name": "FUN_10001bf0", "Address": "10001bf0", "Source Code": "\\*\nundefined4 * __thiscall FUN_10001bf0(void *object, byte flag)\n{\n    // Call the function FUN_10001b80 with 'this' cast to undefined4 pointer\n    FUN_10001b80((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_10001bf0(void *object, byte flag)\n{\n    FUN_10001b80((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10001c70", "Address": "10001c70", "Source Code": "\nundefined4 __fastcall check_value_and_return(int input_address)\n{\n    // Check if the value at the address (param_1 + 0x20) is not zero\n    if (**(int **)(input_address + 0x20) != 0) {\n        // If not zero, return the value at the address (param_1 + 0x30)\n        return **(undefined4 **)(input_address + 0x30);\n    }\n    // If zero, return 0\n    return 0;\n}\n"}
{"Function Name": "FUN_10001cf0", "Address": "10001cf0", "Source Code": "\nvoid __thiscall FUN_10001cf0(void *object, int offset, size_t size, char character)\n{\n    // Check if the size parameter is not equal to 1\n    if (size != 1) {\n        // Determine the address to write to based on a condition\n        int destinationAddress = (*(uint *)((int)object + 0x18) < 0x10) ? (int)object + 4 : *(int *)((int)object + 4);\n        // Fill memory with the specified character for the given size\n        _memset((void *)(destinationAddress + offset), (int)character, size);\n        return; // Exit the function after memory operation\n    }\n    // Check if the value at offset 0x18 is greater than 15\n    if (0xf < *(uint *)((int)object + 0x18)) {\n        // Write the character directly to the calculated address\n        *(char *)(*(int *)((int)object + 4) + offset) = character;\n        return; // Exit the function after writing the character\n    }\n    // Write the character to the address calculated from 'this' and param_1\n    *(char *)((int)object + offset + 4) = character;\n}\n"}
{"Function Name": "FUN_10001d50", "Address": "10001d50", "Source Code": "\nvoid __cdecl FUN_10001d50(int input_param)\n{\n    char character_value; // Variable to store a character value\n    int current_node = *(int *)(input_param + 8); // Retrieve an integer from the address (param_1 + 8)\n    character_value = *(char *)(current_node + 0x189); // Get the character at the offset 0x189 from iVar2\n\n    // Loop until cVar1 is not a null character\n    while (character_value == '\\0') {\n        current_node = *(int *)(current_node + 8); // Update iVar2 to the next integer in the linked structure\n        character_value = *(char *)(current_node + 0x189); // Retrieve the character at the new iVar2 offset\n    }\n}\n"}
{"Function Name": "FUN_10001d70", "Address": "10001d70", "Source Code": "\nvoid __cdecl FUN_10001d70(int **int_pointer_array)\n{\n    // Dereference the pointer to get the first integer pointer\n    int *current_integer_pointer = *int_pointer_array;\n\n    // Loop until the character at offset 0x189 from piVar2 is not null\n    while (*(char *)((int)current_integer_pointer + 0x189) == '\\0') {\n        // Update piVar2 to point to the next integer pointer\n        current_integer_pointer = (int *)*current_integer_pointer;\n    }\n\n    // Exit the function\n    return;\n}\n"}
{"Function Name": "FUN_10001d90", "Address": "10001d90", "Source Code": "\nvoid __fastcall FUN_10001d90(int base_address)\n{\n    // Set the value at offset 0x20 from param_1 to param_1 + 0x18\n    *(int *)(base_address + 0x20) = base_address + 0x18;\n    \n    // Set the value at offset 0x24 from param_1 to param_1 + 0x1c\n    *(int *)(base_address + 0x24) = base_address + 0x1c;\n    \n    // Set the value at offset 0x10 from param_1 to param_1 + 8\n    *(int *)(base_address + 0x10) = base_address + 8;\n    \n    // Set the value at offset 0x30 from param_1 to param_1 + 0x28\n    *(int *)(base_address + 0x30) = base_address + 0x28;\n    \n    // Set the value at offset 0x34 from param_1 to param_1 + 0x2c\n    *(int *)(base_address + 0x34) = base_address + 0x2c;\n    \n    // Initialize the value at offset 0xc from param_1 to 0\n    *(undefined4 *)(base_address + 0xc) = 0;\n    \n    // Set the value at the address pointed by the value at offset 0x24 to 0\n    **(undefined4 **)(base_address + 0x24) = 0;\n    \n    // Set the value at the address pointed by the value at offset 0x34 to 0\n    **(undefined4 **)(base_address + 0x34) = 0;\n    \n    // Set the value at the address pointed by the value at offset 0x10 to 0\n    **(undefined4 **)(base_address + 0x10) = 0;\n    \n    // Set the value at the address pointed by the value at offset 0x20 to 0\n    **(undefined4 **)(base_address + 0x20) = 0;\n    \n    // Set the value at the address pointed by the value at offset 0x30 to 0\n    **(undefined4 **)(base_address + 0x30) = 0;\n}\n"}
{"Function Name": "FUN_10001f10", "Address": "10001f10", "Source Code": "\nvoid __cdecl FUN_10001f10(int input_pointer)\n{\n    // Retrieve the integer value located at the offset of 8 bytes from param_1\n    int current_pointer = *(int *)(input_pointer + 8);\n    \n    // Loop until the character at the offset of 0x2d from iVar2 is not null\n    while (*(char *)(current_pointer + 0x2d) == '\\0') {\n        // Update iVar2 to the integer value located at the offset of 8 bytes from the current iVar2\n        current_pointer = *(int *)(current_pointer + 8);\n    }\n    \n    // Exit the function\n    return;\n}\n"}
{"Function Name": "FUN_10001f30", "Address": "10001f30", "Source Code": "\nvoid __cdecl FUN_10001f30(int **int_pointer_ptr)\n{\n    // Dereference the pointer to get the integer pointer\n    int *current_int_ptr = *int_pointer_ptr;\n\n    // Loop until the character at offset 0x2d from piVar2 is not null\n    while (*(char *)((int)current_int_ptr + 0x2d) == '\\0') {\n        // Update piVar2 to point to the next integer in the linked structure\n        current_int_ptr = (int *)*current_int_ptr;\n    }\n\n    // Exit the function\n    return;\n}\n"}
{"Function Name": "FUN_10001fb0", "Address": "10001fb0", "Source Code": "\nvoid FUN_10001fb0(int *input_param)\n{\n    // XOR the value at DAT_100345e0 with the address of local_4 and store it in local_4\n    uint xor_result = DAT_100345e0 ^ (uint)&xor_result;\n\n    // Call a function pointed to by the value at param_1 + 0xc and store the result in piVar1\n    int *function_pointer = (int *)(**(code **)(*input_param + 0xc))();\n\n    // Call a function pointed to by the value at piVar1 + 0x3c and store the result in psVar2\n    short *result_pointer = (short *)(**(code **)(*function_pointer + 0x3c))();\n\n    // Check if psVar2 is NULL or if the first element is neither 2 nor 23 (0x17)\n    if (result_pointer == (short *)0x0 || (*result_pointer != 2 && *result_pointer != 0x17)) {\n        // Perform a security check using the local_4 value\n        ___security_check_cookie_4(xor_result ^ (uint)&xor_result);\n        return; // Exit the function if the condition is met\n    }\n    \n    // Convert the address in psVar2 + 2 to a string representation of an IP address\n    inet_ntoa((in_addr)((_union_1226 *)(result_pointer + 2))->S_un_b);\n\n    // Perform a final security check using the local_4 value\n    ___security_check_cookie_4(xor_result ^ (uint)&xor_result);\n}\n"}
{"Function Name": "FUN_10002020", "Address": "10002020", "Source Code": "\nvoid __fastcall FUN_10002020(int **inputPointer)\n{\n    // Retrieve an integer value from a specific memory location\n    int retrievedValue = *(int *)(*(int *)(**inputPointer + 4) + 0x28 + (int)*inputPointer);\n    \n    // Check if the retrieved integer is not zero\n    if (retrievedValue != 0) {\n        // Call FUN_100101fa with a pointer to a critical section structure\n        FUN_100101fa((LPCRITICAL_SECTION *)(retrievedValue + 4));\n    }\n}\n"}
{"Function Name": "FUN_100020f0", "Address": "100020f0", "Source Code": "\nvoid __thiscall FUN_100020f0(void *objectPointer, undefined4 firstParam, undefined4 secondParam)\n{\n    // Call the function pointed to by the pointer located at offset 0x1c from 'this'\n    // Pass 'param_1', a constant value of 0xffffffff, and 'param_2' as arguments\n    ((code *)(*(void **)(objectPointer + 0x1c)))(firstParam, 0xffffffff, secondParam);\n}\n"}
{"Function Name": "FUN_10002110", "Address": "10002110", "Source Code": "\n// Function declaration with a return type of undefined4 and a parameter of type undefined4\nundefined4 __fastcall FUN_10002110(undefined4 input_value)\n{\n    // Return the value of the input parameter param_1\n    return input_value;\n}\n"}
{"Function Name": "FUN_10002130", "Address": "10002130", "Source Code": "\nundefined4 __fastcall check_pointer_value(int input_param)\n{\n    // Check if the value pointed to by the pointer at (param_1 + 0x24) is not zero\n    if (**(int **)(input_param + 0x24) != 0) {\n        // If not zero, return the value pointed to by the pointer at (param_1 + 0x34)\n        return **(undefined4 **)(input_param + 0x34);\n    }\n    // If the value is zero, return 0\n    return 0;\n}\n"}
{"Function Name": "FUN_10002150", "Address": "10002150", "Source Code": "\nuint __fastcall FUN_10002150(int *inputArray)\n{\n    // Check if the pointer at param_1[8] is not null and the value at param_1[0xc] is greater than 0\n    if ((*(byte **)inputArray[8] != (byte *)0x0) && (0 < *(int *)inputArray[0xc])) {\n        // Dereference the pointer at param_1[8] and return the first byte as an unsigned integer\n        return (uint)**(byte **)inputArray[8];\n    }\n    // Call the function pointed to by the value at param_1 plus an offset of 0x10 and return its result\n    return (**(code **)(*inputArray + 0x10))();\n}\n"}
{"Function Name": "FUN_10002170", "Address": "10002170", "Source Code": "\nuint __fastcall FUN_10002170(int *input_params)\n{\n    // Call a function pointed to by the value at param_1 + 0x10 and store the result in iVar2\n    int function_result = (**(code **)(*input_params + 0x10))();\n    \n    // Check if the result is -1, indicating an error\n    if (function_result == -1) {\n        // Return 0xffffffff to indicate failure\n        return 0xffffffff;\n    }\n    \n    // Decrement the value at the address stored in param_1[0xc]\n    *(int *)input_params[0xc] -= 1;\n    \n    // Get the byte pointer from param_1[8]\n    byte *byte_pointer = *(byte **)input_params[8];\n    \n    // Increment the byte pointer to point to the next byte\n    *(byte **)input_params[8] = byte_pointer + 1;\n    \n    // Return the value of the byte pointed to by the original pbVar1\n    return (uint)*byte_pointer;\n}\n"}
{"Function Name": "FUN_100021a0", "Address": "100021a0", "Source Code": "\nvoid FUN_100021a0(undefined4 *array_pointer)\n{\n    // Assign the value of DAT_1002d090 to the first element of the array pointed to by param_1\n    *array_pointer = data_value;\n    \n    // Set the third element of the array to 0\n    array_pointer[2] = 0;\n    \n    // Set the fourth element of the array to 0\n    array_pointer[3] = 0;\n}\n"}
{"Function Name": "FUN_100021c0", "Address": "100021c0", "Source Code": "\nvoid FUN_100021c0(undefined4 *array_pointer)\n{\n    // Assign the value of DAT_1002d090 to the first element of the array pointed to by param_1\n    *array_pointer = data_value;\n    \n    // Set the third element of the array to 0\n    array_pointer[2] = 0;\n    \n    // Set the fourth element of the array to 0\n    array_pointer[3] = 0;\n}\n"}
{"Function Name": "FUN_10002290", "Address": "10002290", "Source Code": "\nuint __fastcall FUN_10002290(int input_param)\n{\n    // Dereference a pointer to get a byte pointer from the structure at param_1 + 0x20\n    byte *byte_ptr_1 = **(byte ***)(input_param + 0x20);\n    \n    // Check if pbVar1 is null; if so, return 0xffffffff\n    if (byte_ptr_1 == (byte *)0x0) {\n        return 0xffffffff;\n    }\n    \n    // Check if pbVar1 is within a certain range defined by the value at param_1 + 0x30\n    if (byte_ptr_1 < byte_ptr_1 + **(int **)(input_param + 0x30)) {\n        // Return the value pointed to by pbVar1 as an unsigned integer\n        return (uint)*byte_ptr_1;\n    }\n    \n    // Check if the 3rd bit of the byte at param_1 + 0x40 is not set\n    if ((*(byte *)(input_param + 0x40) & 4) == 0) {\n        // Dereference another pointer to get a second byte pointer from the structure at param_1 + 0x24\n        byte *byte_ptr_2 = **(byte ***)(input_param + 0x24);\n        \n        // Check if pbVar2 is not null and if pbVar1 is less than pbVar2 or another pointer at param_1 + 0x3c\n        if (byte_ptr_2 != (byte *)0x0 && (byte_ptr_1 < byte_ptr_2 || byte_ptr_1 < *(byte **)(input_param + 0x3c))) {\n            // Update the pointer at param_1 + 0x3c if it is less than pbVar2\n            if (*(byte **)(input_param + 0x3c) < byte_ptr_2) {\n                *(byte **)(input_param + 0x3c) = byte_ptr_2;\n            }\n            // Calculate the difference between the pointer at param_1 + 0x3c and pbVar1, and store it at param_1 + 0x30\n            **(int **)(input_param + 0x30) = *(int *)(input_param + 0x3c) - (int)byte_ptr_1;\n            // Return the value pointed to by pbVar1 as an unsigned integer\n            return (uint)*byte_ptr_1;\n        }\n    }\n    \n    // If none of the conditions are met, return 0xffffffff\n    return 0xffffffff;\n}\n"}
{"Function Name": "FUN_10002530", "Address": "10002530", "Source Code": "\nint * this_call_function FUN_10002530(void *this, byte flag)\n{\n    // Calculate the memory address by subtracting 8 from the current 'this' pointer\n    int *memory_address = (int *)((int)this - 8);\n    \n    // Set the vtable pointer for the object at the calculated memory address\n    *(undefined ***)(*(int *)(*memory_address + 4) - 8 + (int)this) =\n        std::basic_istream<char, struct_std::char_traits<char>>::vftable;\n    \n    // Call another function with 'this' as an argument\n    FUN_10001b80((undefined4 *)this);\n    \n    // If the least significant bit of param_1 is set, free the allocated memory\n    if ((flag & 1) != 0) {\n        _free(memory_address);\n    }\n    \n    // Return the pointer to the allocated memory\n    return memory_address;\n}\n"}
{"Function Name": "FUN_10002560", "Address": "10002560", "Source Code": "\\*\nundefined4 * __thiscall FUN_10002560(void *object, byte flag)\n{\n    // Call the function FUN_10002040 with 'this' cast to undefined4 pointer\n    FUN_10002040((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_10002560(void *object, byte flag)\n{\n    FUN_10002040((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10002580", "Address": "10002580", "Source Code": "\\*\nundefined4 * __thiscall FUN_10002580(void *object, byte flag)\n{\n    // Call the function FUN_100021e0 with 'this' cast to undefined4 pointer\n    FUN_100021e0((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this'\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_10002580(void *object, byte flag)\n{\n    FUN_100021e0((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_100026d0", "Address": "100026d0", "Source Code": "\nvoid FUN_100026d0(uint input_parameter) // Function definition with a single parameter\n{\n    code *function_pointer; // Pointer to a function (code type)\n    undefined4 local_data[3]; // Array to hold local data (undefined4 type)\n\n    // Check if param_1 is not zero and if division by param_1 does not result in zero\n    if (input_parameter != 0 && (int)(0xffffffff / (ulonglong)input_parameter) != 0) {\n        operator_new(input_parameter); // Allocate memory of size param_1\n        return; // Exit the function after allocation\n    }\n\n    // Call FUN_100015f0 with local_c, the remainder of division by param_1, and zero\n    FUN_100015f0(local_data, (char)(0xffffffff % (ulonglong)input_parameter), 0);\n    \n    // Throw an exception using the local_c array and a specific data reference\n    __CxxThrowException_8(local_data, &DAT_100306cc);\n    \n    // Call a system interrupt (swi) with code 3 and store the function pointer in pcVar1\n    function_pointer = (code *)swi(3);\n    \n    // Execute the function pointed to by pcVar1\n    (*function_pointer)();\n}\n"}
{"Function Name": "FUN_10002720", "Address": "10002720", "Source Code": "\nuint __fastcall FUN_10002720(int *inputArray)\n{\n    byte *bytePointer; // Pointer to a byte variable\n    uint returnValue;   // Variable to store the return value\n\n    // Check if the value at param_1[8] is not null and if the value at param_1[0xc] is greater than 0\n    if ((*(int *)inputArray[8] != 0) && (0 < *inputArray[0xc])) {\n        (*inputArray[0xc])--; // Decrement the value at param_1[0xc]\n        bytePointer = *(byte **)inputArray[8]; // Get the byte pointer from param_1[8]\n        *(byte **)inputArray[8] = bytePointer + 1; // Increment the byte pointer\n        return (uint)*bytePointer; // Return the byte value pointed to by pbVar2 as an unsigned integer\n    }\n\n    // Call the function pointed to by the value at param_1 and return its result\n    returnValue = (**(code **)(*inputArray + 0x14))();\n    return returnValue; // Return the result of the function call\n}\n"}
{"Function Name": "FUN_10002ab0", "Address": "10002ab0", "Source Code": "\nint __thiscall FUN_10002ab0(void *object, undefined4 *input_pointer, uint max_difference)\n{\n    uint difference; // Variable to hold the difference between the pointer and the value at offset 0x14\n    int updated_value;  // Variable to hold the updated value at offset 0x14\n    undefined4 *memory_pointer; // Pointer to manipulate memory based on conditions\n\n    // Check if the pointer at offset 0x14 is less than param_1\n    if (*(undefined4 **)((int)object + 0x14) < input_pointer) {\n        FUN_10010242(); // Call a function if the condition is true\n    }\n    \n    // Calculate the difference between the value at offset 0x14 and param_1\n    difference = *(int *)((int)object + 0x14) - (int)input_pointer;\n    \n    // If the difference is less than param_2, update param_2 to be the difference\n    if (difference < max_difference) {\n        max_difference = difference;\n    }\n    \n    // Proceed only if param_2 is not zero\n    if (max_difference != 0) {\n        memory_pointer = (undefined4 *)((int)object + 4); // Initialize puVar5 to point to offset 4\n        // Check if the value at offset 0x18 is greater than 15\n        if (0xf < *(uint *)((int)object + 0x18)) {\n            memory_pointer = (undefined4 *)*memory_pointer; // Dereference puVar5 if the condition is true\n        }\n        // Move memory from the source to the destination\n        _memmove_s((void *)((int)memory_pointer + (int)input_pointer), *(uint *)((int)object + 0x18) - (int)input_pointer,\n                    (void *)((int)input_pointer + (int)memory_pointer + max_difference), difference - max_difference);\n        \n        // Update the value at offset 0x14 by subtracting param_2\n        updated_value = *(int *)((int)object + 0x14) - max_difference;\n        *(int *)((int)object + 0x14) = updated_value; // Store the updated value back\n        \n        // Check again if the value at offset 0x18 is greater than 15\n        if (0xf < *(uint *)((int)object + 0x18)) {\n            memory_pointer = (undefined4 *)*memory_pointer; // Dereference puVar5 again if the condition is true\n        }\n        // Set the byte at the new position to zero\n        *(undefined *)(updated_value + (int)memory_pointer) = 0;\n    }\n    \n    return (int)object; // Return the original 'this' pointer as an integer\n}\n"}
{"Function Name": "FUN_10002b40", "Address": "10002b40", "Source Code": "\nvoid __thiscall FUN_10002b40(void *object, int input_structure, undefined4 *output_pointer)\n{\n    // Check if the value at offset 0x18 of the structure pointed by param_1 is greater than 15\n    if (0xf < *(uint *)(input_structure + 0x18)) {\n        // Call FUN_100025a0 with the current object, the integer pointer from param_1, param_2, and the value at offset 0x14\n        process_data(object, *(int **)(input_structure + 4), output_pointer, *(uint *)(input_structure + 0x14));\n    } else {\n        // Call FUN_100025a0 with the current object, the address of param_1 + 4 cast to an integer pointer, param_2, and the value at offset 0x14\n        process_data(object, (int *)(input_structure + 4), output_pointer, *(uint *)(input_structure + 0x14));\n    }\n}\n"}
{"Function Name": "FUN_10002b80", "Address": "10002b80", "Source Code": "\nvoid __thiscall FUN_10002b80(void *this, int *input_string, undefined4 *output_value)\n{\n    int *current_char_pointer = input_string; // Initialize pointer to the start of param_1\n    while (*(char *)current_char_pointer != '\\0') { // Loop until a null character is found\n        current_char_pointer = (int *)((int)current_char_pointer + 1); // Move to the next character\n    }\n    // Call FUN_100025a0 with the current object, param_1, param_2, and the length of the string\n    FUN_100025a0(this, input_string, output_value, (int)current_char_pointer - ((int)input_string + 1));\n}\n"}
{"Function Name": "FUN_10002bb0", "Address": "10002bb0", "Source Code": "\nuint __fastcall FUN_10002bb0(int *int_array) // Function definition with a pointer to an integer array\n{\n    uint return_value; // Variable to store a return value or intermediate result\n    if (*(int *)int_array[8] != 0) { // Check if the value at index 8 of param_1 is not zero\n        if (1 < *(int *)int_array[0xc]) { // Check if the value at index 0xc of param_1 is greater than 1\n            *(int *)int_array[0xc] = *(int *)int_array[0xc] - 1; // Decrement the value at index 0xc\n            *(int *)int_array[8] = *(int *)int_array[8] + 1; // Increment the value at index 8\n            return (uint)**(byte **)int_array[8]; // Return the value pointed to by the incremented value at index 8\n        }\n        if ((*(int *)int_array[8] != 0) && (0 < *(int *)int_array[0xc])) { // Check if value at index 8 is not zero and value at index 0xc is greater than 0\n            *(int *)int_array[0xc] = *(int *)int_array[0xc] - 1; // Decrement the value at index 0xc\n            return_value = (uint)*(*(byte **)int_array[8]++); // Get the byte value at the current pointer of index 8 and increment the pointer\n            goto LAB_10002c05; // Jump to the label for further processing\n        }\n    }\n    return_value = (**(code **)(*int_array + 0x14))(); // Call a function pointer located at index 0x14 of param_1\nLAB_10002c05: // Label for continuing execution\n    if (return_value == 0xffffffff) { // Check if uVar3 indicates an error (0xffffffff)\n        return 0xffffffff; // Return error code\n    }\n    if ((*(byte **)int_array[8] != (byte *)0x0) && (0 < *(int *)int_array[0xc])) { // Check if the pointer at index 8 is not null and value at index 0xc is greater than 0\n        return (uint)**(byte **)int_array[8]; // Return the value pointed to by the pointer at index 8\n    }\n    return (**(code **)(*int_array + 0x10))(); // Call another function pointer located at index 0x10 of param_1 and return its result\n}\n"}
{"Function Name": "FUN_10002de0", "Address": "10002de0", "Source Code": "\nint __thiscall FUN_10002de0(void *this, int inputParam)\n{\n    uint tempUnsignedInt1; // Variable to hold a temporary unsigned integer value\n    uint tempUnsignedInt2; // Variable to hold another temporary unsigned integer value\n    void *destinationPointer; // Pointer to hold destination memory address\n\n    // Check if the 3rd bit of the byte at offset 0x40 is set\n    if ((*(byte *)((int)this + 0x40) & 8) != 0) {\n        tempUnsignedInt2 = **(uint **)((int)this + 0x24); // Get value from a pointer at offset 0x24\n        // If uVar8 is not zero and less than the value at offset 0x3c\n        if ((tempUnsignedInt2 != 0) && (tempUnsignedInt1 = *(uint *)((int)this + 0x3c), tempUnsignedInt2 < tempUnsignedInt1)) {\n            **(uint **)((int)this + 0x24) = tempUnsignedInt1; // Update the value at offset 0x24\n            // Adjust the value at offset 0x34\n            **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) + tempUnsignedInt2 - tempUnsignedInt1;\n        }\n    }\n\n    // If param_1 is -1, return 0\n    if (inputParam == -1) {\n        return 0;\n    }\n\n    tempUnsignedInt2 = **(uint **)((int)this + 0x24); // Get value from pointer at offset 0x24\n    // If uVar8 is not zero and less than the sum of value at offset 0x34 and uVar8\n    if ((tempUnsignedInt2 != 0) && (int *pointerIntVar = *(int **)((int)this + 0x34), tempUnsignedInt2 < *pointerIntVar + tempUnsignedInt2)) {\n        *pointerIntVar = *pointerIntVar - 1; // Decrement the value at offset 0x34\n        undefined *pointerUndefinedVar = (undefined *)**(int **)((int)this + 0x24); // Get pointer from offset 0x24\n        **(int **)((int)this + 0x24) = (int)(pointerUndefinedVar + 1); // Increment the pointer at offset 0x24\n        *pointerUndefinedVar = (char)inputParam; // Store param_1 at the pointed location\n        return inputParam; // Return param_1\n    }\n\n    // Check if the 2nd bit of the byte at offset 0x40 is set\n    if ((*(byte *)((int)this + 0x40) & 2) != 0) {\n        return -1; // Return -1 if the condition is met\n    }\n\n    // If uVar8 is zero, set it to zero (redundant)\n    if (tempUnsignedInt2 == 0) {\n        tempUnsignedInt2 = 0;\n    } else {\n        // Calculate new uVar8 based on values at offsets 0x34 and 0x10\n        tempUnsignedInt2 = (**(int **)((int)this + 0x34) - **(int **)((int)this + 0x10)) + tempUnsignedInt2;\n    }\n\n    tempUnsignedInt1 = tempUnsignedInt2 >> 1; // Right shift uVar8 by 1\n    // Ensure uVar4 is at least 0x20\n    if (tempUnsignedInt1 < 0x20) {\n        tempUnsignedInt1 = 0x20;\n    }\n\n    uint destinationSize = tempUnsignedInt2; // Initialize _DstSize with uVar8\n    destinationPointer = (void *)0x0; // Initialize _Dst to NULL\n\n    // Loop to find a suitable size for _Dst\n    for (; tempUnsignedInt1 != 0; tempUnsignedInt1 = tempUnsignedInt1 >> 1) {\n        // Check if uVar8 plus uVar4 does not exceed maximum integer value\n        if (tempUnsignedInt2 <= 0x7fffffff - tempUnsignedInt1) {\n            if (tempUnsignedInt1 != 0) {\n                destinationSize = tempUnsignedInt1 + tempUnsignedInt2; // Update _DstSize\n                destinationPointer = (void *)FUN_100026d0(destinationSize); // Allocate memory\n            }\n            break; // Exit the loop\n        }\n    }\n\n    // If uVar8 is not zero, copy memory from the source to _Dst\n    if (tempUnsignedInt2 != 0) {\n        _memcpy_s(destinationPointer, destinationSize, **(void ***)((int)this + 0x10), tempUnsignedInt2);\n    }\n\n    // Check if the 1st bit of the byte at offset 0x40 is set\n    if ((*(byte *)((int)this + 0x40) & 1) != 0) {\n        _free(**(void ***)((int)this + 0x10)); // Free the memory at offset 0x10\n    }\n\n    *(uint *)((int)this + 0x40) |= 1; // Set the 1st bit of the byte at offset 0x40\n\n    // If uVar8 is zero, initialize pointers and sizes\n    if (tempUnsignedInt2 == 0) {\n        *(void **)((int)this + 0x3c) = destinationPointer; // Set pointer at offset 0x3c\n        **(void ***)((int)this + 0x14) = destinationPointer; // Set pointer at offset 0x14\n        **(void ***)((int)this + 0x24) = destinationPointer; // Set pointer at offset 0x24\n        **(rsize_t **)((int)this + 0x34) = destinationSize; // Set size at offset 0x34\n        *(void ***)((int)this + 0x10) = destinationPointer; // Set pointer at offset 0x10\n        void **pointerVar = *(void ***)((int)this + 0x20); // Get pointer at offset 0x20\n        // Check if the 3rd bit of the byte at offset 0x40 is not set\n        if ((*(byte *)((int)this + 0x40) & 4) == 0) {\n            *pointerVar = destinationPointer; // Set the pointer at offset 0x20\n            **(undefined4 **)((int)this + 0x30) = 1; // Set value at offset 0x30\n            goto LAB_10002f6f; // Jump to label\n        }\n    } else {\n        // Update pointers and sizes based on _Dst\n        *(int *)((int)this + 0x3c) = (int)destinationPointer + (*(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10));\n        int iVar5 = **(int **)((int)this + 0x10); // Get value from offset 0x10\n        int iVar6 = **(int **)((int)this + 0x24); // Get value from offset 0x24\n        **(int **)((int)this + 0x14) = (int)destinationPointer + (**(int **)((int)this + 0x14) - iVar5); // Update pointer at offset 0x14\n        iVar5 = (iVar6 - iVar5) + (int)destinationPointer; // Calculate new value for iVar5\n        **(int **)((int)this + 0x24) = iVar5; // Update pointer at offset 0x24\n        **(int **)((int)this + 0x34) = (int)destinationPointer + (destinationSize - iVar5); // Update size at offset 0x34\n\n        // Check if the 3rd bit of the byte at offset 0x40 is not set\n        if ((*(byte *)((int)this + 0x40) & 4) == 0) {\n            iVar5 = **(int **)((int)this + 0x24); // Get value from offset 0x24\n            iVar6 = (**(int **)((int)this + 0x20) - (int)**(void ***)((int)this + 0x10)) + (int)destinationPointer; // Calculate new iVar6\n            **(void ***)((int)this + 0x10) = destinationPointer; // Update pointer at offset 0x10\n            **(int **)((int)this + 0x20) = iVar6; // Update pointer at offset 0x20\n            **(int **)((int)this + 0x30) = (iVar5 - iVar6) + 1; // Update value at offset 0x30\n            goto LAB_10002f6f; // Jump to label\n        }\n        **(void ***)((int)this + 0x10) = destinationPointer; // Update pointer at offset 0x10\n        pointerVar = *(void ***)((int)this + 0x20); // Get pointer at offset 0x20\n    }\n\n    *pointerVar = (void *)0x0; // Set the pointer at offset 0x20 to NULL\n    **(void ***)((int)this + 0x30) = destinationPointer; // Update value at offset 0x30\n\nLAB_10002f6f: // Label for jumping\n    **(int **)((int)this + 0x34) = **(int **)((int)this + 0x34) - 1; // Decrement value at offset 0x34\n    undefined *pointerUndefinedVar = (undefined *)**(int **)((int)this + 0x24); // Get pointer from offset 0x24\n    **(int **)((int)this + 0x24) = (int)(pointerUndefinedVar + 1); // Increment the pointer at offset 0x24\n    *pointerUndefinedVar = (char)inputParam; // Store param_1 at the pointed location\n    return inputParam; // Return param_1\n}\n"}
{"Function Name": "FUN_10002f90", "Address": "10002f90", "Source Code": "\nvoid __thiscall FUN_10002f90(void *object, char inputChar, rsize_t dataSize)\n{\n    // Check if param_1 is not null and the value at offset 0x18 is greater than 15\n    if ((inputChar != '\\0') && (0xf < *(uint *)((int)object + 0x18))) {\n        // Retrieve the pointer stored at offset 4\n        void *sourcePointer = *(void **)((int)object + 4);\n        // If param_2 is not zero, copy data from _Src to the location at offset 4\n        if (dataSize != 0) {\n            _memcpy_s((void **)((int)object + 4), 0x10, sourcePointer, dataSize);\n        }\n        // Free the memory pointed to by _Src\n        _free(sourcePointer);\n    }\n    // Store param_2 at offset 0x14\n    *(rsize_t *)((int)object + 0x14) = dataSize;\n    // Set the value at offset 0x18 to 15\n    *(undefined4 *)((int)object + 0x18) = 0xf;\n    // Null-terminate the memory at offset 4 + param_2\n    *(undefined *)((int)object + dataSize + 4) = 0;\n}\n"}
{"Function Name": "Catch@10003063", "Address": "10003063", "Source Code": "\nundefined * catchFunction(void) // Function declaration\n{\n    int integerValue; // Variable to hold an integer value\n    *(BADSPACEBASE **)(stackFrame + -0x10) = pointerValue; // Store a pointer in the stack frame\n    integerValue = *(int *)(stackFrame + 8); // Retrieve an integer from the stack frame\n    *(undefined *)(stackFrame + -4) = 2; // Set a value in the stack frame\n    FUN_100026d0(integerValue + 1); // Call a function with incremented value\n    *(undefined4 *)(stackFrame + -4) = 1; // Update the value in the stack frame\n    return &dataPointer; // Return a pointer to a specific data location\n}\n"}
{"Function Name": "FUN_10003095", "Address": "10003095", "Source Code": "\nvoid FUN_10003095(void)\n{\n    void *sourcePointer;  // Pointer to the source data\n    rsize_t maxCount = *(rsize_t *)(basePointer + 0xc);  // Retrieve maximum count from stack\n\n    if (maxCount != 0) {  // Check if maximum count is not zero\n        if (*(uint *)(dataPointer + 0x18) < 0x10) {  // Check if a certain value is less than 16\n            sourcePointer = (void *)(dataPointer + 4);  // Set source pointer to a specific offset if condition is true\n        } else {\n            sourcePointer = *(void **)(dataPointer + 4);  // Otherwise, dereference to get the source pointer\n        }\n        _memcpy_s(destinationPointer, valueToCheck + 1, sourcePointer, maxCount);  // Safely copy data from source to destination\n    }\n\n    if (0xf < *(uint *)(dataPointer + 0x18)) {  // Check if the value is greater than 15\n        _free(*(void **)(dataPointer + 4));  // Free the memory pointed to by the source pointer if condition is true\n    }\n\n    *(undefined4 *)(dataPointer + 4) = destinationPointer;  // Store the destination pointer in a specific location\n    *(uint *)(dataPointer + 0x18) = valueToCheck;  // Update a value at a specific offset\n    *(rsize_t *)(dataPointer + 0x14) = maxCount;  // Store the maximum count at a specific offset\n\n    if (0xf < valueToCheck) {  // Check if the value is greater than 15\n        *(undefined *)((int)destinationPointer + maxCount) = 0;  // Null-terminate the destination if condition is true\n    }\n    \n    *(undefined *)((int)destinationPointer + maxCount) = 0;  // Null-terminate the destination\n    exceptionList = *(void **)(basePointer + -0xc);  // Restore the exception list from the stack\n    return;  // Exit the function\n}\n"}
{"Function Name": "Catch@100030fe", "Address": "100030fe", "Source Code": "\nvoid Catch_100030fe(void)\n{\n    // Retrieve an integer value from a specific memory location\n    int memoryValue = *(int *)(basePointer - 0x14);\n    \n    // Check if the value at offset 0x18 of iVar1 is greater than 15\n    if (0xf < *(uint *)(memoryValue + 0x18)) {\n        // Free the memory pointed to by the pointer at offset 4 of iVar1\n        _free(*(void **)(memoryValue + 4));\n    }\n    \n    // Set the value at offset 0x18 of iVar1 to 15\n    *(undefined4 *)(memoryValue + 0x18) = 0xf;\n    \n    // Set the value at offset 0x14 of iVar1 to 0\n    *(undefined4 *)(memoryValue + 0x14) = 0;\n    \n    // Set the byte at offset 4 of iVar1 to 0\n    *(undefined *)(memoryValue + 4) = 0;\n    \n    // Throw an exception with a null pointer as the argument\n    throwException(0, (byte *)0x0);\n    \n    // Call a function via a software interrupt with the number 3\n    ((code *)softwareInterrupt(3))();\n}\n"}
{"Function Name": "Catch@100031cb", "Address": "100031cb", "Source Code": "\nvoid Catch_100031cb(void)\n{\n    // Free the memory pointed to by the pointer located at (unaff_EBP - 0x18)\n    free_memory(*(void **)(base_pointer - 0x18));\n    \n    // Throw an exception with a null pointer as the argument\n    throw_exception(0, (byte *)0x0);\n    \n    // Call a software interrupt with the identifier 3\n    ((code *)software_interrupt(3))();\n}\n"}
{"Function Name": "Catch@10003332", "Address": "10003332", "Source Code": "\nvoid Catch_10003332(void)\n{\n    // Free the memory pointed to by the pointer located at (unaff_EBP - 0x18)\n    free_memory(*(void **)(base_pointer + -0x18));\n    \n    // Throw an exception with a null pointer as the argument\n    throw_exception(0, (byte *)0x0);\n    \n    // Call a system interrupt with the identifier 3\n    ((code *)system_interrupt(3))();\n}\n"}
{"Function Name": "FUN_10003350", "Address": "10003350", "Source Code": "\nbool __cdecl FUN_10003350(void *param_1, int *param_2)\n{\n    char currentChar; // Variable to hold the current character from the array\n    uint result; // Variable to hold the result from the function call\n    int *intArrayPointer = param_2; // Pointer to iterate through the integer array\n\n    do {\n        currentChar = *(char *)intArrayPointer; // Dereference the pointer to get the current character\n        intArrayPointer++; // Move to the next integer in the array\n    } while (currentChar != '\\0'); // Continue until a null character is found\n\n    // Call another function with the parameters and store the result\n    result = FUN_10002660(param_1, 0, *(uint *)((int)param_1 + 0x14), param_2, (int)intArrayPointer - ((int)param_2 + 1));\n    \n    // Return true if uVar3 is zero, otherwise return false\n    return (bool)('\\x01' - (result != 0));\n}\n"}
{"Function Name": "FUN_100033d0", "Address": "100033d0", "Source Code": "\nvoid __fastcall FUN_100033d0(int context)\n{\n    // Check if the value at offset 0x18 from param_1 is greater than 15\n    if (0xf < *(uint *)(context + 0x18)) {\n        // Free the memory pointed to by the pointer at offset 4 from param_1\n        free_memory(*(void **)(context + 4));\n    }\n    // Set the value at offset 0x18 from param_1 to 15\n    *(uint *)(context + 0x18) = 0xf;\n    // Set the value at offset 0x14 from param_1 to 0\n    *(undefined4 *)(context + 0x14) = 0;\n    // Set the pointer at offset 4 from param_1 to NULL\n    *(void **)(context + 4) = 0;\n}\n"}
{"Function Name": "FUN_10003400", "Address": "10003400", "Source Code": "\\*\nundefined4 * __thiscall FUN_10003400(void *object, byte flag)\n{\n    // Call a function with 'this' cast to an integer\n    FUN_10002d70((int)object);\n    \n    // Call another function with 'this' cast to undefined4 pointer\n    FUN_10001b80((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free memory located at 'this - 0x50'\n        _free((undefined4 *)((int)object - 0x50));\n    }\n    \n    // Return a pointer to the memory located at 'this - 0x50'\n    return (undefined4 *)((int)object - 0x50);\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_10003400(void *object, byte flag)\n{\n    FUN_10002d70((int)object);\n    FUN_10001b80((undefined4 *)object);\n    if (flag & 1) {\n        _free((undefined4 *)((int)object - 0x50));\n    }\n    return (undefined4 *)((int)object - 0x50);\n}\n"}
{"Function Name": "FUN_10003590", "Address": "10003590", "Source Code": "\nbool __cdecl FUN_10003590(void *inputPointer, int *integerArray)\n{\n    char currentCharacter; // Variable to hold the current character\n    int *integerPointer = integerArray; // Pointer to iterate through the integer array\n\n    // Loop until a null character is found in the integer array\n    while ((currentCharacter = *(char *)integerPointer) != '\\0') {\n        integerPointer++; // Move to the next integer in the array\n    }\n\n    // Call another function with parameters and return the boolean result\n    return FUN_10002660(inputPointer, 0, *(uint *)((int)inputPointer + 0x14), integerArray, (int)integerPointer - ((int)integerArray + 1)) != 0;\n}\n"}
{"Function Name": "FUN_10003650", "Address": "10003650", "Source Code": "\nint __fastcall FUN_10003650(int input_pointer)\n{\n    // Check if the value at offset 0x24 from param_1 is greater than 15 (0xf)\n    return (0xf < *(uint *)(input_pointer + 0x24)) \n        // If true, return the value at offset 0x10 from param_1\n        ? *(int *)(input_pointer + 0x10) \n        // If false, return param_1 plus 0x10\n        : input_pointer + 0x10;\n}\n"}
{"Function Name": "FUN_10003660", "Address": "10003660", "Source Code": "\\*\nundefined4 * __thiscall FUN_10003660(void *object, byte flag)\n{\n    // Call the function FUN_100035d0 with 'this' cast to undefined4 pointer\n    FUN_100035d0((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_10003660(void *object, byte flag)\n{\n    FUN_100035d0((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10003700", "Address": "10003700", "Source Code": "\\*\nundefined4 * method FUN_10003700(void *object, byte flag)\n{\n    // Call FUN_10003680 with 'this' cast to undefined4 pointer\n    FUN_10003680((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this'\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * method FUN_10003700(void *object, byte flag)\n{\n    FUN_10003680((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10003d00", "Address": "10003d00", "Source Code": "\nvoid * __thiscall FUN_10003d00(void *object, uint input_param) // Function definition with 'this' pointer and parameter 'param_1'\n{\n    uint intermediate_result; // Variable to hold intermediate calculation result\n    // Check if the negative value of an integer at offset 0x14 from 'this' minus 1 is less than or equal to param_1\n    if (-*(int *)((int)object + 0x14) - 1U <= input_param) {\n        FUN_10010203(); // Call another function if the condition is met\n    }\n    // Proceed only if param_1 is not zero\n    if (input_param != 0) {\n        intermediate_result = *(int *)((int)object + 0x14) + input_param; // Calculate new value for uVar1\n        // Check if uVar1 equals to 0xffffffff\n        if (intermediate_result == 0xffffffff) {\n            FUN_10010203(); // Call another function if the condition is met\n        }\n        // Check if the value at offset 0x18 from 'this' is less than uVar1\n        if (*(uint *)((int)object + 0x18) < intermediate_result) {\n            FUN_10002fe0(object, intermediate_result); // Call another function with 'this' and uVar1 if the condition is met\n        } else if (intermediate_result == 0) { // Check if uVar1 is zero\n            *(undefined4 *)((int)object + 0x14) = 0; // Set the value at offset 0x14 to zero\n            // Check if the value at offset 0x18 from 'this' is less than 0x10\n            if (*(uint *)((int)object + 0x18) < 0x10) {\n                *(undefined *)((int)object + 4) = 0; // Set the value at offset 4 to zero\n                return object; // Return 'this'\n            }\n            *(undefined **)((int)object + 4) = 0; // Set the pointer at offset 4 to null\n            return object; // Return 'this'\n        }\n        FUN_10001cf0(object, *(int *)((int)object + 0x14), input_param, (char)input_param); // Call another function with parameters\n        *(uint *)((int)object + 0x14) = intermediate_result; // Update the value at offset 0x14 with uVar1\n        // Check if the value at offset 0x18 from 'this' is greater than 0xf\n        if (0xf < *(uint *)((int)object + 0x18)) {\n            *(undefined *)(*(int *)((int)object + 4) + intermediate_result) = 0; // Set the value at calculated address to zero\n            return object; // Return 'this'\n        }\n        *(undefined *)((int)object + intermediate_result + 4) = 0; // Set the value at offset uVar1 + 4 to zero\n    }\n    return object; // Return 'this'\n}\n"}
{"Function Name": "FUN_10003db0", "Address": "10003db0", "Source Code": "\nvoid * __thiscall FUN_10003db0(void *currentObject, void *inputParam, uint elementCount, uint maxAllowedCount)\n{\n    undefined4 *destinationPointer; // Pointer to destination for memory operations\n    undefined4 *tempPointer; // Temporary pointer for accessing data\n    uint maxElementCount; // Variable to hold the maximum count of elements to process\n\n    // Check if the value at offset 0x14 of param_1 is less than param_2\n    if (*(uint *)((int)inputParam + 0x14) < elementCount) {\n        FUN_10010242(); // Call a function if the condition is met\n    }\n\n    // Calculate the maximum count by subtracting param_2 from the value at offset 0x14 of param_1\n    maxElementCount = *(int *)((int)inputParam + 0x14) - elementCount;\n\n    // Adjust _MaxCount if param_3 is less than the calculated maximum count\n    if (maxAllowedCount < maxElementCount) {\n        maxElementCount = maxAllowedCount;\n    }\n\n    // Check if 'this' is not the same as param_1\n    if (currentObject != inputParam) {\n        // If _MaxCount is equal to 0xffffffff, call another function\n        if (maxElementCount == 0xffffffff) {\n            FUN_10010203();\n        }\n\n        // Check if the value at offset 0x18 of 'this' is less than _MaxCount\n        if (*(uint *)((int)currentObject + 0x18) < maxElementCount) {\n            FUN_10002fe0(currentObject, maxElementCount); // Call a function to handle the case\n        } else if (maxElementCount == 0) { // If _MaxCount is zero\n            *(undefined4 *)((int)currentObject + 0x14) = 0; // Set the value at offset 0x14 of 'this' to zero\n            // Check if the value at offset 0x18 of 'this' is less than 0x10\n            if (*(uint *)((int)currentObject + 0x18) < 0x10) {\n                *(undefined *)((int)currentObject + 4) = 0; // Set the value at offset 4 of 'this' to zero\n                return currentObject; // Return 'this'\n            }\n            **(undefined **)((int)currentObject + 4) = 0; // Set the first element pointed by the pointer at offset 4 of 'this' to zero\n            return currentObject; // Return 'this'\n        }\n\n        // If _MaxCount is not zero\n        if (maxElementCount != 0) {\n            // Determine the starting address based on the value at offset 0x18 of param_1\n            int startAddress = (*(uint *)((int)inputParam + 0x18) < 0x10) ? (int)inputParam + 4 : *(int *)((int)inputParam + 4);\n            tempPointer = (undefined4 *)((int)currentObject + 4); // Set puVar2 to point to the address at offset 4 of 'this'\n            // Determine the destination pointer based on the value at offset 0x18 of 'this'\n            destinationPointer = (0xf < *(uint *)((int)currentObject + 0x18)) ? (undefined4 *)*tempPointer : tempPointer;\n            // Perform a secure memory copy from param_1 to the destination\n            _memcpy_s(destinationPointer, *(uint *)((int)currentObject + 0x18), (void *)(startAddress + elementCount), maxElementCount);\n            *(uint *)((int)currentObject + 0x14) = maxElementCount; // Update the value at offset 0x14 of 'this' with _MaxCount\n            // Check if the value at offset 0x18 of 'this' is greater than 0xf\n            if (0xf < *(uint *)((int)currentObject + 0x18)) {\n                tempPointer = (undefined4 *)*tempPointer; // Update puVar2 to point to the next element\n            }\n            *(undefined *)((int)tempPointer + maxElementCount) = 0; // Null-terminate the destination\n        }\n    }\n\n    // Call FUN_10002ab0 twice with different parameters\n    FUN_10002ab0(currentObject, (undefined4 *)(maxElementCount + elementCount), 0xffffffff);\n    FUN_10002ab0(currentObject, (undefined4 *)0x0, elementCount);\n    \n    return currentObject; // Return 'this'\n}\n"}
{"Function Name": "FUN_10003e90", "Address": "10003e90", "Source Code": "\nvoid * __thiscall FUN_10003e90(void *object, undefined4 *input_ptr, uint input_size)\n{\n    // Retrieve the value at offset 0x18 from the 'this' pointer\n    uint data_size = *(uint *)((int)object + 0x18);\n    \n    // Get a pointer to the data at offset 4 from the 'this' pointer\n    undefined4 *data_ptr = (undefined4 *)((int)object + 4);\n    \n    // Determine the appropriate pointer based on the value of uVar1\n    undefined4 *target_ptr = (data_size > 0xf) ? (undefined4 *)*data_ptr : data_ptr;\n\n    // Check if param_1 is within the valid range\n    if (target_ptr <= input_ptr && input_ptr < (undefined4 *)(*(int *)((int)object + 0x14) + (int)target_ptr)) {\n        // Call another function with adjusted parameters\n        return FUN_10003db0(object, object, (int)input_ptr - (int)data_ptr, input_size);\n    }\n\n    // Check if param_2 is equal to -1\n    if (input_size == 0xffffffff) {\n        // Call a specific function if param_2 is -1\n        FUN_10010203();\n    }\n\n    // If uVar1 is less than param_2, call another function\n    if (data_size < input_size) {\n        FUN_10002fe0(object, input_size);\n    } else if (input_size == 0) {\n        // If param_2 is 0, reset a value at offset 0x14\n        *(undefined4 *)((int)object + 0x14) = 0;\n        \n        // Adjust puVar4 if uVar1 is greater than 0xf\n        if (data_size > 0xf) {\n            data_ptr = (undefined4 *)*data_ptr;\n        }\n        \n        // Set the first byte of the memory pointed by puVar4 to 0\n        *(undefined *)data_ptr = 0;\n        return object; // Return the 'this' pointer\n    }\n\n    // If param_2 is not 0\n    if (input_size != 0) {\n        // Re-evaluate puVar3 based on uVar1\n        target_ptr = (data_size > 0xf) ? (undefined4 *)*data_ptr : data_ptr;\n        \n        // Copy memory from param_1 to puVar3\n        _memcpy_s(target_ptr, data_size, input_ptr, input_size);\n        \n        // Update the value at offset 0x14 with param_2\n        *(uint *)((int)object + 0x14) = input_size;\n        \n        // Adjust puVar4 if uVar1 is greater than 0xf\n        if (data_size > 0xf) {\n            data_ptr = (undefined4 *)*data_ptr;\n        }\n        \n        // Set the byte at offset param_2 in puVar4 to 0\n        *(undefined *)((int)data_ptr + input_size) = 0;\n    }\n    \n    return object; // Return the 'this' pointer\n}\n"}
{"Function Name": "FUN_10003f60", "Address": "10003f60", "Source Code": "\nvoid __thiscall FUN_10003f60(void *this, int startParam, int endParam)\n{\n    uint valueFromObject; // Variable to hold a value from the object\n    uint difference; // Variable to hold the difference between param_2 and param_1\n    int indexOrPointerOffset;  // Variable to hold an index or pointer offset\n    void *currentExceptionList; // Local variable to store the current ExceptionList\n\n    currentExceptionList = exceptionListPointer; // Save the current ExceptionList\n    exceptionListPointer = &currentExceptionList; // Update ExceptionList to point to local_10\n\n    difference = endParam - startParam; // Calculate the difference between param_2 and param_1\n    valueFromObject = *(uint *)((int)this + 0x14); // Retrieve a value from the object at offset 0x14\n\n    // Check if uVar1 is less than or equal to uVar3 and if the value at offset 0x18 is not equal to uVar3\n    if ((valueFromObject <= difference) && (*(uint *)((int)this + 0x18) != difference)) {\n        // Call FUN_10003430 with this, uVar3, and a character\n        if (FUN_10003430(this, difference, '\\x01')) {\n            *(uint *)((int)this + 0x14) = valueFromObject; // Update the value at offset 0x14\n            // Determine the next index or pointer based on the value at offset 0x18\n            indexOrPointerOffset = (*(uint *)((int)this + 0x18) < 0x10) ? (int)this + 4 : *(int *)((int)this + 4);\n            *(undefined *)(indexOrPointerOffset + valueFromObject) = 0; // Set the value at the calculated index to 0\n        }\n    }\n\n    // Loop from param_1 to param_2, calling FUN_10003d00 for each value\n    for (; startParam != endParam; startParam++) {\n        FUN_10003d00(this, 1); // Call FUN_10003d00 with this and a constant value\n    }\n\n    exceptionListPointer = currentExceptionList; // Restore the original ExceptionList\n    return; // Exit the function\n}\n"}
{"Function Name": "Catch@10004005", "Address": "10004005", "Source Code": "\nvoid Catch_10004005(void)\n{\n    // Retrieve the value from the stack at the offset of -0x14 from the base pointer\n    int retrievedStructPtr = *(int *)(basePointer - 0x14);\n    \n    // Check if the value at offset 0x18 of the retrieved structure is greater than 15\n    if (0xf < *(uint *)(retrievedStructPtr + 0x18)) {\n        // Free the memory pointed to by the pointer at offset 4 of the retrieved structure\n        freeMemory(*(void **)(retrievedStructPtr + 4));\n    }\n    \n    // Set the value at offset 0x18 of the retrieved structure to 15\n    *(undefined4 *)(retrievedStructPtr + 0x18) = 0xf;\n    \n    // Set the value at offset 0x14 of the retrieved structure to 0\n    *(undefined4 *)(retrievedStructPtr + 0x14) = 0;\n    \n    // Set the pointer at offset 4 of the retrieved structure to NULL\n    *(undefined *)(retrievedStructPtr + 4) = 0;\n    \n    // Throw an exception with a null pointer as the argument\n    throwException(0, (byte *)0x0);\n    \n    // Call a function via a software interrupt with the number 3\n    ((code *)softwareInterrupt(3))();\n}\n"}
{"Function Name": "FUN_10004070", "Address": "10004070", "Source Code": "\nvoid * __thiscall FUN_10004070(void *context, undefined4 *inputPointer, uint incrementValue)\n{\n    void *returnValue; // Pointer to hold the return value\n    undefined4 *offsetPointer; // Pointer to an undefined4 type\n    uint currentValue; // Variable to hold a uint value\n\n    currentValue = *(uint *)((int)context + 0x18); // Get the value at offset 0x18 from 'this'\n    offsetPointer = (undefined4 *)((int)context + 4); // Set puVar2 to point to offset 4 from 'this'\n    \n    if (0xf < currentValue) { // Check if uVar4 is greater than 15\n        offsetPointer = (undefined4 *)*offsetPointer; // Dereference puVar2 if condition is true\n    }\n    \n    if (offsetPointer <= inputPointer) { // Check if puVar2 is less than or equal to param_1\n        if (inputPointer < (undefined4 *)(*(int *)((int)context + 0x14) + (int)offsetPointer)) { // Check if param_1 is within a certain range\n            returnValue = FUN_10003c00(context, (int)context, (int)inputPointer - (int)offsetPointer, incrementValue); // Call another function and store the result\n            return returnValue; // Return the result\n        }\n    }\n\n    currentValue = *(uint *)((int)context + 0x14); // Get the value at offset 0x14 from 'this'\n    \n    if ((-currentValue - 1 <= incrementValue) || (currentValue + incrementValue < currentValue)) { // Check for overflow or underflow conditions\n        FUN_10010203(); // Call error handling function\n    }\n    \n    if (incrementValue != 0) { // Check if param_2 is not zero\n        currentValue += incrementValue; // Increment uVar4 by param_2\n        if (currentValue == 0xffffffff) { // Check for overflow condition\n            FUN_10010203(); // Call error handling function\n        }\n        \n        if (*(uint *)((int)context + 0x18) < currentValue) { // Check if the value at offset 0x18 is less than uVar4\n            FUN_10002fe0(context, currentValue); // Call function to handle resizing\n        } else if (currentValue == 0) { // Check if uVar4 is zero\n            *(undefined4 *)((int)context + 0x14) = 0; // Set the value at offset 0x14 to zero\n            if (0xf < *(uint *)((int)context + 0x18)) { // Check if the value at offset 0x18 is greater than 15\n                offsetPointer = (undefined4 *)*offsetPointer; // Dereference puVar2\n            }\n            *(undefined *)offsetPointer = 0; // Set the value pointed by puVar2 to zero\n            return context; // Return 'this'\n        }\n        \n        if (currentValue != 0) { // Check if uVar4 is not zero\n            if (0xf < *(uint *)((int)context + 0x18)) { // Check if the value at offset 0x18 is greater than 15\n                offsetPointer = (undefined4 *)*offsetPointer; // Dereference puVar2\n            }\n            // Copy memory from one location to another\n            _memcpy_s((void *)(*(int *)((int)context + 0x14) + (int)offsetPointer),\n                      *(uint *)((int)context + 0x18) - *(int *)((int)context + 0x14), \n                      sourceAddress, incrementValue);\n            *(uint *)((int)context + 0x14) = currentValue; // Update the value at offset 0x14 with uVar4\n            \n            if (0xf < *(uint *)((int)context + 0x18)) { // Check if the value at offset 0x18 is greater than 15\n                offsetPointer = (undefined4 *)*offsetPointer; // Dereference puVar2\n            }\n            *(undefined *)((int)offsetPointer + currentValue) = 0; // Null-terminate the memory at the new position\n        }\n    }\n    return context; // Return 'this'\n}\n"}
{"Function Name": "FUN_10004160", "Address": "10004160", "Source Code": "\nvoid __thiscall FUN_10004160(void *context, undefined4 *inputParameter)\n{\n    undefined4 *inputPointer = inputParameter; // Initialize pointer to the input parameter\n    while (*(char *)inputPointer != '\\0') { // Loop until a null character is found\n        inputPointer = (undefined4 *)((int)inputPointer + 1); // Move to the next character\n    }\n    // Call another function with 'this', the original parameter, and the length of the string\n    processString(context, inputParameter, (int)inputPointer - ((int)inputParameter + 1));\n}\n"}
{"Function Name": "FUN_10004710", "Address": "10004710", "Source Code": "\nvoid FUN_10004710(void *input_pointer, undefined4 input_value)\n{\n    char string_buffer[12]; // Buffer to hold the string representation of param_2\n    uint security_cookie; // Variable to store a security cookie\n    void *original_exception_list; // Pointer to store the original ExceptionList\n\n    original_exception_list = ExceptionList; // Save the current ExceptionList\n    security_cookie = DAT_100345e0 ^ (uint)&original_exception_list; // Calculate a security cookie using a predefined value and the address of local_c\n    ExceptionList = &original_exception_list; // Update ExceptionList to point to local_c\n\n    _sprintf(string_buffer, \"%d\", input_value); // Convert param_2 to a string and store it in local_1c\n\n    *(undefined4 *)((int)input_pointer + 0x18) = 0xf; // Set a specific offset in param_1 to 0xf\n    *(undefined4 *)((int)input_pointer + 0x14) = 0; // Set another offset in param_1 to 0\n    *(undefined *)((int)input_pointer + 4) = 0; // Clear a byte at a specific offset in param_1\n\n    FUN_10003f60(input_pointer, (int)string_buffer, (int)(string_buffer + strlen(string_buffer))); // Call another function with param_1 and the string representation of param_2\n\n    ExceptionList = original_exception_list; // Restore the original ExceptionList\n\n    ___security_check_cookie_4(security_cookie ^ (uint)&original_exception_list); // Perform a security check using the calculated cookie\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10004a60", "Address": "10004a60", "Source Code": "\nvoid __thiscall FUN_10004a60(void *current_object, void *input_param)\n{\n    // Call the function FUN_10003db0 with the current object, param_1, and additional parameters 0 and -1\n    FUN_10003db0(current_object, input_param, 0, -1);\n}\n"}
{"Function Name": "FUN_10004bf0", "Address": "10004bf0", "Source Code": "\nvoid * __cdecl FUN_10004bf0(void *input_pointer, void *data_pointer, int flag)\n{\n    void *return_value; // Variable to hold the return value from a function call\n    undefined temp_buffer[4]; // Local buffer for temporary data\n    void *previous_exception_list; // Pointer to store the previous ExceptionList\n\n    previous_exception_list = current_exception_list; // Save the current ExceptionList\n    current_exception_list = &previous_exception_list; // Set ExceptionList to point to local_c\n\n    FUN_10003db0(temp_buffer, data_pointer, 0, 0xffffffff); // Call FUN_10003db0 with local_28 and param_2\n\n    return_value = FUN_10003c00(temp_buffer, flag, 0, 0xffffffff); // Call FUN_10003c00 and store the result in pvVar1\n\n    *(undefined4 *)((int)input_pointer + 0x18) = 0xf; // Set a value at offset 0x18 of param_1 to 0xf\n    *(undefined4 *)((int)input_pointer + 0x14) = 0; // Set a value at offset 0x14 of param_1 to 0\n    *(undefined *)((int)input_pointer + 4) = 0; // Set a byte at offset 4 of param_1 to 0\n\n    FUN_10003db0(input_pointer, return_value, 0, 0xffffffff); // Call FUN_10003db0 with param_1 and pvVar1\n\n    if (0xf < 0xf) { // Check if 0xf is less than 0xf (this condition is always false)\n        _free(previous_exception_list); // Free the memory allocated for local_c (this block will never execute)\n    }\n\n    current_exception_list = previous_exception_list; // Restore the previous ExceptionList\n\n    return input_pointer; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_10004cc0", "Address": "10004cc0", "Source Code": "\nvoid * __cdecl FUN_10004cc0(void *input_pointer, undefined4 *data_pointer, int status_code)\n{\n    char current_char; // Variable to store character value\n    undefined4 *data_iterator; // Pointer to iterate through param_2\n    void *result_pointer; // Pointer to store the result from FUN_10003c00\n    undefined temp_storage[4]; // Local storage for data\n    void *previous_exception_list; // Local variable to hold the previous ExceptionList\n    previous_exception_list = current_exception_list; // Save the current ExceptionList\n    current_exception_list = &previous_exception_list; // Set ExceptionList to point to local_c\n\n    data_iterator = data_pointer; // Initialize puVar2 to point to param_2\n    do {\n        current_char = *(char *)data_iterator; // Dereference puVar2 to get the character\n        data_iterator = (undefined4 *)((int)data_iterator + 1); // Move to the next character\n    } while (current_char != '\\0'); // Continue until a null character is found\n\n    FUN_10003e90(temp_storage, data_pointer, (int)data_iterator - ((int)data_pointer + 1)); // Call FUN_10003e90 with local_28, param_2, and length\n    result_pointer = FUN_10003c00(temp_storage, status_code, 0, 0xffffffff); // Call FUN_10003c00 and store the result in pvVar3\n    *(undefined4 *)((int)input_pointer + 0x18) = 0xf; // Set a value at offset 0x18 of param_1\n    *(undefined4 *)((int)input_pointer + 0x14) = 0; // Set a value at offset 0x14 of param_1 to 0\n    *(undefined *)((int)input_pointer + 4) = 0; // Set a value at offset 4 of param_1 to 0\n    FUN_10003db0(input_pointer, result_pointer, 0, 0xffffffff); // Call FUN_10003db0 with param_1, pvVar3, and additional parameters\n\n    if (0xf < 0xf) { // Check if 0xf is greater than 0xf (always false)\n        _free(previous_exception_list); // Free local_c if the condition were true (this block will never execute)\n    }\n    current_exception_list = previous_exception_list; // Restore the previous ExceptionList\n    return input_pointer; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_10004e20", "Address": "10004e20", "Source Code": "\nvoid * __cdecl FUN_10004e20(void *input_pointer, undefined4 value_1, undefined4 value_2, void *memory_pointer)\n{\n    void *current_exception_list; // Declare a local variable to store the current ExceptionList\n    current_exception_list = exception_list; // Save the current ExceptionList\n    exception_list = &current_exception_list; // Update ExceptionList to point to the local variable\n    FUN_10004270(input_pointer, &value_1, &value_2); // Call another function with param_1 and addresses of param_2 and param_3\n    if (0xf < *(uint *)((char *)&value_1 + 4)) { // Check if the value at param_2 + 4 is greater than 15\n        _free(memory_pointer); // Free the memory pointed to by param_4 if the condition is met\n    }\n    exception_list = current_exception_list; // Restore the original ExceptionList\n    return input_pointer; // Return the original param_1\n}\n"}
{"Function Name": "FUN_10004f30", "Address": "10004f30", "Source Code": "\\*\n_Lockit * __thiscall FUN_10004f30(void *this, char *locale_name)\n{\n    undefined error_message_buffer[4]; // Buffer for error message\n    undefined locale_info; // Variable for locale information\n    undefined4 error_code_1; // Variable for error code\n    undefined4 error_code_2; // Variable for error code\n    undefined exception_handling_buffer[40]; // Buffer for exception handling\n    void *previous_exception_list; // Pointer to store previous exception list\n    undefined *stack_pointer; // Pointer for stack manipulation\n    undefined4 local_variable = 0xffffffff; // Initialization of local variable\n\n    stack_pointer = &LAB_100277fc; // Set up stack pointer\n    previous_exception_list = ExceptionList; // Save current exception list\n    ExceptionList = &previous_exception_list; // Update exception list to current context\n    std::_Lockit::_Lockit((_Lockit *)this, 0); // Lock the current context\n\n    // Initialize various fields in the object pointed to by 'this'\n    *(undefined4 *)((int)this + 0x1c) = 0xf; // Set field at offset 0x1c\n    *(undefined4 *)((int)this + 0x18) = 0; // Set field at offset 0x18 to 0\n    *(undefined *)((int)this + 8) = 0; // Set field at offset 8 to 0\n    *(undefined4 *)((int)this + 0x38) = 0xf; // Set field at offset 0x38\n    *(undefined4 *)((int)this + 0x34) = 0; // Set field at offset 0x34 to 0\n    *(undefined *)((int)this + 0x24) = 0; // Set field at offset 0x24 to 0\n    *(undefined4 *)((int)this + 0x54) = 0xf; // Set field at offset 0x54\n    *(undefined4 *)((int)this + 0x50) = 0; // Set field at offset 0x50 to 0\n    *(undefined *)((int)this + 0x40) = 0; // Set field at offset 0x40 to 0\n    *(undefined4 *)((int)this + 0x70) = 0xf; // Set field at offset 0x70\n    *(undefined4 *)((int)this + 0x6c) = 0; // Set field at offset 0x6c to 0\n    *(undefined *)((int)this + 0x5c) = 0; // Set field at offset 0x5c to 0\n    local_variable._0_1_ = 4; // Set local variable to 4\n\n    // Check if the provided locale name is null\n    if (locale_name == (char *)0x0) {\n        error_code_2 = 0xf; // Set error code\n        error_code_1 = 0; // Reset error variable\n        locale_info = 0; // Reset locale variable\n        FUN_10003e90(error_message_buffer, (undefined4 *)\"bad locale name\", 0xf); // Log error message\n        local_variable._0_1_ = 5; // Update local variable to indicate error\n        FUN_10004580(exception_handling_buffer, error_message_buffer); // Handle the error\n        __CxxThrowException_8(exception_handling_buffer, &DAT_10031090); // Throw an exception\n    }\n\n    std::_Locinfo::_Locinfo_ctor((_Locinfo *)this, locale_name); // Construct locale info with provided name\n    ExceptionList = previous_exception_list; // Restore previous exception list\n    return (_Lockit *)this; // Return the current object\n}\n*\\ \n \n\n_Lockit * __thiscall FUN_10004f30(void *this, char *locale_name)\n{\n    undefined error_message_buffer[4];\n    undefined locale_info;\n    undefined4 error_code_1;\n    undefined4 error_code_2;\n    undefined exception_handling_buffer[40];\n    void *previous_exception_list;\n    undefined *stack_pointer;\n    undefined4 local_variable = 0xffffffff;\n\n    stack_pointer = &LAB_100277fc;\n    previous_exception_list = ExceptionList;\n    ExceptionList = &previous_exception_list;\n    std::_Lockit::_Lockit((_Lockit *)this, 0);\n\n    *(undefined4 *)((int)this + 0x1c) = 0xf;\n    *(undefined4 *)((int)this + 0x18) = 0;\n    *(undefined *)((int)this + 8) = 0;\n    *(undefined4 *)((int)this + 0x38) = 0xf;\n    *(undefined4 *)((int)this + 0x34) = 0;\n    *(undefined *)((int)this + 0x24) = 0;\n    *(undefined4 *)((int)this + 0x54) = 0xf;\n    *(undefined4 *)((int)this + 0x50) = 0;\n    *(undefined *)((int)this + 0x40) = 0;\n    *(undefined4 *)((int)this + 0x70) = 0xf;\n    *(undefined4 *)((int)this + 0x6c) = 0;\n    *(undefined *)((int)this + 0x5c) = 0;\n    local_variable._0_1_ = 4;\n\n    if (locale_name == (char *)0x0) {\n        error_code_2 = 0xf;\n        error_code_1 = 0;\n        locale_info = 0;\n        FUN_10003e90(error_message_buffer, (undefined4 *)\"bad locale name\", 0xf);\n        local_variable._0_1_ = 5;\n        FUN_10004580(exception_handling_buffer, error_message_buffer);\n        __CxxThrowException_8(exception_handling_buffer, &DAT_10031090);\n    }\n\n    std::_Locinfo::_Locinfo_ctor((_Locinfo *)this, locale_name);\n    ExceptionList = previous_exception_list;\n    return (_Lockit *)this;\n}\n"}
{"Function Name": "FUN_100050a0", "Address": "100050a0", "Source Code": "\nvoid __thiscall FUN_100050a0(void *this, int inputParam, char charParam, undefined4 undefinedParam)\n{\n    _Ctypevec *ctypePointer; // Pointer to a _Ctypevec structure\n    void *thisPointer; // Local variable to store a pointer\n    _Ctypevec ctypeLocal; // Local variable to store a _Ctypevec structure\n    int tempStorage[29]; // Local array for temporary storage\n    uint securityCookie; // Local variable for security cookie\n    void *originalExceptionList; // Local variable to store the original ExceptionList\n    undefined4 localVariable = 0xffffffff; // Local variable initialized to -1\n\n    originalExceptionList = ExceptionList; // Save the current ExceptionList\n    securityCookie = DAT_100345e0 ^ (uint)&thisPointer; // Calculate security cookie\n    ExceptionList = &originalExceptionList; // Set ExceptionList to point to local_c\n    thisPointer = this; // Store 'this' pointer in local_98\n    FUN_10001960(this, undefinedParam); // Call function with 'this' and param_3\n    *(undefined ***)this = std::ctype<char>::vftable; // Set virtual table for 'this'\n    FUN_10004f30(tempStorage, \"C\"); // Call function with local_84 and \"C\"\n    localVariable._0_1_ = 1; // Set the first byte of local_4 to 1\n    ctypePointer = __Getctype(&ctypeLocal); // Get ctype information and store in p_Var1\n    *(uint *)((int)this + 8) = ctypePointer->_Page; // Store _Page in the object\n    *(short **)((int)this + 0xc) = ctypePointer->_Table; // Store _Table in the object\n    *(int *)((int)this + 0x10) = ctypePointer->_Delfl; // Store _Delfl in the object\n    *(wchar_t **)((int)this + 0x14) = ctypePointer->_LocaleName; // Store _LocaleName in the object\n    localVariable = (uint)localVariable._1_3_ << 8; // Shift local_4 for further use\n    FUN_10003720(tempStorage); // Call function with local_84\n\n    if (inputParam != 0) { // Check if param_1 is not zero\n        if (*(int *)((int)this + 0x14) < 1) { // Check if _LocaleName is less than 1\n            if (*(int *)((int)this + 0x14) < 0) { // Check if _LocaleName is negative\n                _free(*(void **)((int)this + 0x10)); // Free memory pointed by _Delfl\n            }\n        } else {\n            _free(*(void **)((int)this + 0x10)); // Free memory pointed by _Delfl\n        }\n        *(int *)((int)this + 0x10) = inputParam; // Set _Delfl to param_1\n        *(uint *)((int)this + 0x14) = -(uint)(charParam != '\\0'); // Set _LocaleName based on param_2\n    }\n\n    ExceptionList = originalExceptionList; // Restore the original ExceptionList\n    ___security_check_cookie_4(securityCookie ^ (uint)&thisPointer); // Check the security cookie\n    return; // Return from the function\n}\n"}
{"Function Name": "FUN_100051c0", "Address": "100051c0", "Source Code": "\nvoid __thiscall FUN_100051c0(void *object, byte inputByte)\n{\n    // Call the __Tolower function, passing the unsigned integer value of param_1\n    // and a pointer to a _Ctypevec structure located at an offset of 8 bytes from 'this'\n    __Tolower((uint)inputByte, (_Ctypevec *)((int)object + 8));\n}\n"}
{"Function Name": "FUN_100051e0", "Address": "100051e0", "Source Code": "\\*\nbyte * __thiscall FUN_100051e0(void *context, byte *source_pointer, byte *destination_pointer)\n{\n    // Check if the two pointers are not equal\n    if (source_pointer != destination_pointer) {\n        // Loop until param_1 equals param_2\n        do {\n            // Convert the character at param_1 to lowercase and store it back\n            *source_pointer = (byte)__Tolower((uint)*source_pointer, (_Ctypevec *)((int)context + 8));\n            // Move to the next byte\n            source_pointer++;\n        } while (source_pointer != destination_pointer); // Continue looping\n    }\n    // Return the updated pointer param_1\n    return source_pointer;\n}\n*\\ \n \n\nbyte * __thiscall FUN_100051e0(void *context, byte *source_pointer, byte *destination_pointer)\n{\n    if (source_pointer != destination_pointer) {\n        do {\n            *source_pointer = (byte)__Tolower((uint)*source_pointer, (_Ctypevec *)((int)context + 8));\n            source_pointer++;\n        } while (source_pointer != destination_pointer);\n    }\n    return source_pointer;\n}\n"}
{"Function Name": "FUN_10005210", "Address": "10005210", "Source Code": "\nvoid __thiscall FUN_10005210(void *context, byte inputByte)\n{\n    // Call the __Toupper function with the parameters:\n    // - Cast param_1 to uint\n    // - Pointer to the _Ctypevec structure located at an offset of 8 bytes from 'this'\n    __Toupper((uint)inputByte, (_Ctypevec *)((int)context + 8));\n}\n"}
{"Function Name": "FUN_10005230", "Address": "10005230", "Source Code": "\\*\nbyte * __thiscall convert_to_uppercase(void *context, byte *start_ptr, byte *end_ptr)\n{\n    // Check if the two pointers are not equal\n    if (start_ptr != end_ptr) {\n        // Loop until param_1 equals param_2\n        do {\n            // Convert the character at param_1 to uppercase and store it back\n            *start_ptr = (byte)__Toupper((uint)*start_ptr, (_Ctypevec *)((int)context + 8));\n            // Move to the next character\n            start_ptr++;\n        } while (start_ptr != end_ptr); // Continue looping until the end pointer is reached\n    }\n    // Return the updated pointer param_1\n    return start_ptr;\n}\n*\\ \n \n\nbyte * __thiscall convert_to_uppercase(void *context, byte *start_ptr, byte *end_ptr)\n{\n    if (start_ptr != end_ptr) {\n        do {\n            *start_ptr = (byte)__Toupper((uint)*start_ptr, (_Ctypevec *)((int)context + 8));\n            start_ptr++;\n        } while (start_ptr != end_ptr);\n    }\n    return start_ptr;\n}\n"}
{"Function Name": "FUN_10005260", "Address": "10005260", "Source Code": "\n// Function declaration with an undefined return type and parameter type\nundefined returnInputParameter(undefined inputParameter)\n{\n    // Return the input parameter without modification\n    return inputParameter;\n}\n"}
{"Function Name": "FUN_100052a0", "Address": "100052a0", "Source Code": "\nint FUN_100052a0(void *source, int size, void *destination, uint max_size)\n{\n    // Check if the size of param_4 is less than the difference between param_2 and param_1\n    if (max_size < (uint)(size - (int)source)) {\n        // Call an error handling function if the condition is true\n        FUN_10011202();\n    }\n    // Copy memory from param_1 to param_3 with the size of (param_2 - param_1)\n    _memcpy_s(destination, max_size, source, size - (int)source);\n    // Return the value of param_2\n    return size;\n}\n"}
{"Function Name": "FUN_100052e0", "Address": "100052e0", "Source Code": "\n// Function definition for FUN_100052e0\n// Takes a parameter of type 'undefined' and returns a value of the same type\nundefined FUN_100052e0(undefined input_value)\n{\n    // Return the input parameter without modification\n    return input_value;\n}\n"}
{"Function Name": "FUN_10005320", "Address": "10005320", "Source Code": "\nint FUN_10005320(void *source, int size, undefined4 flag, void *destination, uint buffer_size)\n{\n    // Check if the size of param_5 is less than the difference between param_2 and param_1\n    if (buffer_size < (uint)(size - (int)source)) {\n        // Call the function FUN_10011202 if the condition is true\n        FUN_10011202();\n    }\n    // Copy memory from param_1 to param_4 with the size of (param_2 - param_1)\n    _memcpy_s(destination, buffer_size, source, size - (int)source);\n    // Return the value of param_2\n    return size;\n}\n"}
{"Function Name": "FUN_100053e0", "Address": "100053e0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100053e0(void *object, byte flag)\n{\n    // Call the function FUN_10005360 with 'this' cast to undefined4 pointer\n    FUN_10005360((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_100053e0(void *object, byte flag)\n{\n    FUN_10005360((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10005480", "Address": "10005480", "Source Code": "\nvoid __thiscall FUN_10005480(void *this, uint inputMask, char shouldThrowException)\n{\n    uint intermediateResult; // Variable to store intermediate results\n    undefined *errorMessages[7]; // Array to hold error messages\n    undefined exceptionBuffer[40]; // Buffer for exception data\n    void *previousExceptionList; // Pointer to store the previous ExceptionList\n    undefined4 errorState = 0xffffffff; // Variable to hold error state, initialized to -1\n    previousExceptionList = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &previousExceptionList; // Set ExceptionList to point to local_c\n\n    *(uint *)((int)this + 8) = inputMask & 0x17; // Store masked param_1 in the object's memory\n    intermediateResult = *(uint *)((int)this + 0xc) & inputMask & 0x17; // Retrieve and mask another value from the object\n\n    if (intermediateResult != 0) { // Check if any error bits are set\n        if (shouldThrowException != '\\0') { // Check if param_2 indicates an exception should be thrown\n            __CxxThrowException_8(0, (byte *)0x0); // Throw a generic exception\n        }\n        if ((intermediateResult & 4) != 0) { // Check if badbit is set\n            FUN_10004a20(errorMessages, \"ios_base::badbit set\"); // Log the badbit error\n            errorState = 0; // Set local_4 to indicate badbit error\n            FUN_10004600(exceptionBuffer, errorMessages); // Prepare exception data\n            __CxxThrowException_8(exceptionBuffer, &DAT_100311e4); // Throw exception for badbit\n        }\n        if ((intermediateResult & 2) != 0) { // Check if failbit is set\n            FUN_10004a20(errorMessages, \"ios_base::failbit set\"); // Log the failbit error\n            errorState = 1; // Set local_4 to indicate failbit error\n            FUN_10004600(exceptionBuffer, errorMessages); // Prepare exception data\n            __CxxThrowException_8(exceptionBuffer, &DAT_100311e4); // Throw exception for failbit\n        }\n        FUN_10004a20(errorMessages, \"ios_base::eofbit set\"); // Log the eofbit error\n        errorState = 2; // Set local_4 to indicate eofbit error\n        FUN_10004600(exceptionBuffer, errorMessages); // Prepare exception data\n        __CxxThrowException_8(exceptionBuffer, &DAT_100311e4); // Throw exception for eofbit\n    }\n    ExceptionList = previousExceptionList; // Restore the previous ExceptionList\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10005640", "Address": "10005640", "Source Code": "\nvoid __cdecl FUN_10005640(void *paramPointer,int count)\n{\n    int loopIndex; // Variable to store loop index\n    undefined4 *charPointer; // Pointer to hold the address of the string\n    undefined4 charArray[10]; // Local array to store characters\n    uint securityCookie; // Variable to store a security cookie\n    void *originalExceptionList; // Variable to store the original ExceptionList\n\n    originalExceptionList = ExceptionList; // Save the current ExceptionList\n    securityCookie = DAT_100345e0 ^ (uint)&charArray; // Calculate a security cookie\n    ExceptionList = &originalExceptionList; // Update ExceptionList to point to local_c\n\n    charPointer = (undefined4 *)\"abcdefghijklmnopqrstuvwxyz1234567890\"; // Pointer to the string of characters\n    for (loopIndex = 9; loopIndex != 0; loopIndex--) { // Loop to fill local_38 with characters\n        charArray[loopIndex] = *charPointer++; // Assign character from string to local_38\n    }\n    charArray[0] = *charPointer; // Assign the last character to local_38[0]\n\n    *(undefined4 *)((int)paramPointer + 0x18) = 0xf; // Set a value at offset 0x18 in param_1\n    *(undefined4 *)((int)paramPointer + 0x14) = 0; // Set a value at offset 0x14 in param_1 to 0\n    *(undefined *)((int)paramPointer + 4) = 0; // Set a byte at offset 4 in param_1 to 0\n    FUN_10003e90(paramPointer, &PTR_1002bc68, 0); // Call another function with param_1 and a pointer\n\n    if (0 < count) { // Check if param_2 is greater than 0\n        do {\n            loopIndex = _rand() % 0x25; // Generate a random number between 0 and 24\n            if (loopIndex > 0x23) { // Ensure iVar1 does not exceed 23\n                loopIndex = 0x23; // Cap iVar1 at 23\n            }\n            FUN_10003d00(paramPointer, 1); // Call another function with param_1\n            count--; // Decrement param_2\n        } while (count != 0); // Repeat until param_2 is 0\n    }\n    ExceptionList = originalExceptionList; // Restore the original ExceptionList\n    ___security_check_cookie_4(securityCookie ^ (uint)&charArray); // Perform a security check\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10005720", "Address": "10005720", "Source Code": "\nbool FUN_10005720(int *input_param) // Function definition with a boolean return type\n{\n    int *int_pointer; // Pointer to an integer variable\n    int return_value; // Integer variable to hold a return value\n    undefined4 *undefined_pointer; // Pointer to an undefined 4-byte type\n    undefined stack_data[4]; // Stack space for undefined data\n    uint stack_variable = 0xf; // Initialize a stack variable with a value of 15\n    void *exception_list_backup = exception_list; // Store the current ExceptionList in local_c\n    exception_list = &exception_list_backup; // Update ExceptionList to point to local_c\n\n    // Call a function pointed to by param_1 and store the result in piVar2\n    int_pointer = (int *)(**(code **)(*input_param + 0xc))(DAT_100345e0 ^ (uint)&stack0xffffffd0);\n    \n    // Call another function and store the result in iVar3\n    return_value = (**(code **)(*int_pointer + 4))();\n    \n    // Get a pointer to an undefined4 type from the result of the previous function\n    undefined_pointer = *(undefined4 **)(return_value + 0x30);\n\n    // Loop to find the end of a string (null terminator)\n    do {\n        undefined_pointer++; // Increment the pointer\n    } while (*(char *)(undefined_pointer - 1) != '\\0'); // Continue until a null character is found\n\n    // Call FUN_10003e90 with the stack data, pointer, and size of the string\n    FUN_10003e90(stack_data, undefined_pointer, (int)undefined_pointer - ((int)undefined_pointer - 1));\n    \n    // Conditional assignment based on the value of DAT_100340b0\n    int_pointer = (threshold_value < 0x10) ? (int *)&data_pointer : data_pointer;\n    \n    // Call FUN_100025a0 with the stack data, piVar2, and other parameters\n    undefined_pointer = FUN_100025a0(stack_data, int_pointer, (undefined4 *)0x0, additional_param);\n\n    // Check if uStack_10 exceeds 15\n    if (0xf < stack_variable) {\n        _free((void *)((uint)stack_pointer & 0xffffff00)); // Free memory if condition is met\n    }\n    \n    exception_list = exception_list_backup; // Restore the original ExceptionList\n    return undefined_pointer != (undefined4 *)0xffffffff; // Return true if puVar5 is not equal to -1\n}\n"}
{"Function Name": "FUN_10005810", "Address": "10005810", "Source Code": "\nbool processIntegerPointer(int *inputPointer) // Function definition with a boolean return type\n{\n    int *resultPointer; // Pointer to an integer\n    int functionResult; // Integer variable to hold a return value\n    undefined4 *dataPointer; // Pointer to an undefined 4-byte type\n    undefined stackBuffer[4]; // Stack space for undefined data\n    void *exceptionHandler; // Local variable for exception handling\n    exceptionList = &exceptionHandler; // Set the ExceptionList to point to local_c\n    resultPointer = (int *)(**(code **)(*inputPointer + 0xc))(constantValue ^ (uint)&offsetValue); // Call a function pointer from param_1 and store the result in piVar2\n    functionResult = (**(code **)(*resultPointer + 4))(); // Call another function pointer from piVar2 and store the result in iVar3\n    dataPointer = *(undefined4 **)(functionResult + 0x30); // Dereference to get a pointer from the result at offset 0x30\n    do {\n        if (*(char *)dataPointer == '\\0') break; // Check if the current character is null\n        dataPointer = (undefined4 *)((int)dataPointer + 1); // Move to the next character\n    } while (true); // Continue looping until a null character is found\n    processStackData(stackBuffer, dataPointer, (int)dataPointer - ((int)dataPointer + 1)); // Call FUN_10003e90 with the stack data and the pointer\n    resultPointer = dataReference; // Assign DAT_100340b8 to piVar2\n    if (thresholdValue < 0x10) { // Check if DAT_100340cc is less than 16\n        resultPointer = (int *)&dataReference; // If true, set piVar2 to point to DAT_100340b8\n    }\n    dataPointer = retrieveData(stackBuffer, resultPointer, (undefined4 *)0x0, anotherConstant); // Call FUN_100025a0 with the stack data and piVar2\n    if (0xf < 0xf) { // This condition is always false\n        freeMemory((void *)((uint)0 & 0xffffff00)); // Free memory (this block will never execute)\n    }\n    exceptionList = exceptionHandler; // Restore the ExceptionList to its original value\n    return dataPointer != (undefined4 *)0xffffffff; // Return true if puVar5 is not equal to -1\n}\n"}
{"Function Name": "FUN_10005900", "Address": "10005900", "Source Code": "\nvoid * __thiscall FUN_10005900(void *object, void *source)\n{\n    // Call another function with 'this', 'param_1', and additional parameters\n    FUN_10003db0(object, source, 0, 0xffffffff);\n    \n    // Copy bytes from 'param_1' to 'this' at specific offsets\n    *(undefined *)((int)object + 0x1c) = *(undefined *)((int)source + 0x1c);\n    *(undefined *)((int)object + 0x1d) = *(undefined *)((int)source + 0x1d);\n    *(undefined *)((int)object + 0x1e) = *(undefined *)((int)source + 0x1e);\n    *(undefined *)((int)object + 0x1f) = *(undefined *)((int)source + 0x1f);\n    \n    // Call the function again for different memory regions\n    FUN_10003db0((void *)((int)object + 0x20), (void *)((int)source + 0x20), 0, 0xffffffff);\n    FUN_10003db0((void *)((int)object + 0x3c), (void *)((int)source + 0x3c), 0, 0xffffffff);\n    FUN_10003db0((void *)((int)object + 0x58), (void *)((int)source + 0x58), 0, 0xffffffff);\n    \n    // Copy a 4-byte value from 'param_1' to 'this'\n    *(undefined4 *)((int)object + 0x74) = *(undefined4 *)((int)source + 0x74);\n    \n    // Continue copying memory regions\n    FUN_10003db0((void *)((int)object + 0x78), (void *)((int)source + 0x78), 0, 0xffffffff);\n    FUN_10003db0((void *)((int)object + 0x94), (void *)((int)source + 0x94), 0, 0xffffffff);\n    FUN_10003db0((void *)((int)object + 0xb0), (void *)((int)source + 0xb0), 0, 0xffffffff);\n    FUN_10003db0((void *)((int)object + 0xcc), (void *)((int)source + 0xcc), 0, 0xffffffff);\n    \n    // Copy another 4-byte value\n    *(undefined4 *)((int)object + 0xe8) = *(undefined4 *)((int)source + 0xe8);\n    \n    // More memory copying\n    FUN_10003db0((void *)((int)object + 0xec), (void *)((int)source + 0xec), 0, 0xffffffff);\n    *(undefined *)((int)object + 0x108) = *(undefined *)((int)source + 0x108);\n    *(undefined4 *)((int)object + 0x110) = *(undefined4 *)((int)source + 0x110);\n    *(undefined4 *)((int)object + 0x114) = *(undefined4 *)((int)source + 0x114);\n    *(undefined *)((int)object + 0x118) = *(undefined *)((int)source + 0x118);\n    \n    // Final memory copying operations\n    FUN_10003db0((void *)((int)object + 0x11c), (void *)((int)source + 0x11c), 0, 0xffffffff);\n    FUN_10003db0((void *)((int)object + 0x138), (void *)((int)source + 0x138), 0, 0xffffffff);\n    \n    // Copy individual bytes\n    *(undefined *)((int)object + 0x154) = *(undefined *)((int)source + 0x154);\n    *(undefined *)((int)object + 0x155) = *(undefined *)((int)source + 0x155);\n    \n    // Return the modified 'this' pointer\n    return object;\n}\n"}
{"Function Name": "Catch@10005ae8", "Address": "10005ae8", "Source Code": "\nvoid Catch_10005ae8(void)\n{\n    // Free the memory pointed to by the pointer located at (unaff_EBP - 0x14)\n    free_memory(*(void **)(base_pointer + -0x14));\n    \n    // Throw an exception with a null pointer as the argument\n    throw_exception(0, (byte *)0x0);\n    \n    // Call a system interrupt with the identifier 3\n    ((code *)system_interrupt(3))();\n}\n"}
{"Function Name": "FUN_10005b80", "Address": "10005b80", "Source Code": "\\*\nfacet * __cdecl FUN_10005b80(int *input_param) // Function declaration with parameter\n{\n    facet *facet_pointer; // Pointer to a facet object\n    uint index; // Unsigned integer variable\n    int input_value; // Integer variable\n    facet *new_facet; // Local pointer to a facet object\n    int lock_variable; // Local integer variable for locking\n    undefined4 exception_data[3]; // Array for exception handling\n    void *exception_list; // Local pointer for exception list\n    undefined *unused_stack_pointer; // Stack pointer (unused)\n    \n    exception_list = ExceptionList; // Save current exception list\n    ExceptionList = &exception_list; // Set new exception list\n    \n    std::_Lockit::_Lockit((_Lockit *)&lock_variable, 0); // Lock for thread safety\n    facet_pointer = DAT_10035a48; // Initialize pfVar4 with a global facet pointer\n    index = FUN_100017a0((int *)&DAT_10035adc); // Call function to get an index\n    input_value = *input_param; // Dereference param_1 to get an integer\n\n    // Check if the index is within bounds of the first facet\n    if (index < *(uint *)(input_value + 0xc)) {\n        facet_pointer = *(facet **)(*(int *)(input_value + 8) + index * 4); // Get facet pointer\n        if (facet_pointer != (facet *)0x0) goto LAB_10005c56; // If valid, go to label\n    } else {\n        // Check if a secondary condition is met\n        if (*(char *)(input_value + 0x14) != '\\0') {\n            input_value = FUN_1000fe6e(); // Call another function\n            // Check if the index is within bounds of the second facet\n            if (index < *(uint *)(input_value + 0xc)) {\n                facet_pointer = *(facet **)(*(int *)(input_value + 8) + index * 4); // Get facet pointer\n                if (facet_pointer != (facet *)0x0) goto LAB_10005c56; // If valid, go to label\n            }\n        }\n        facet_pointer = (facet *)0x0; // Set pfVar4 to null if no valid facet found\n    }\n\n    // If no facet was found, create a new one\n    if (facet_pointer == (facet *)0x0) {\n        input_value = FUN_10005400((int *)&new_facet); // Attempt to allocate a new facet\n        if (input_value == -1) { // Check for allocation failure\n            FUN_10010a35(exception_data, 0, 0xe0); // Prepare exception data\n            __CxxThrowException_8(exception_data, &DAT_10031398); // Throw an exception\n        }\n        facet_pointer = new_facet; // Assign the newly created facet\n        DAT_10035a48 = new_facet; // Update global facet pointer\n        FUN_10001820((int)new_facet); // Initialize the new facet\n        std::locale::facet::facet_Register(facet_pointer); // Register the new facet\n    }\n\nLAB_10005c56: // Label for successful facet retrieval\n    FUN_1000fe01(&lock_variable); // Unlock the previously locked resource\n    ExceptionList = exception_list; // Restore the original exception list\n    return facet_pointer; // Return the facet pointer\n}\n*\\ \n \n\nfacet * __cdecl FUN_10005b80(int *input_param)\n{\n    facet *facet_pointer;\n    uint index;\n    int input_value;\n    facet *new_facet;\n    int lock_variable;\n    undefined4 exception_data[3];\n    void *exception_list;\n    undefined *unused_stack_pointer;\n    exception_list = ExceptionList;\n    ExceptionList = &exception_list;\n    std::_Lockit::_Lockit((_Lockit *)&lock_variable, 0);\n    facet_pointer = DAT_10035a48;\n    index = FUN_100017a0((int *)&DAT_10035adc);\n    input_value = *input_param;\n\n    if (index < *(uint *)(input_value + 0xc)) {\n        facet_pointer = *(facet **)(*(int *)(input_value + 8) + index * 4);\n        if (facet_pointer != (facet *)0x0) goto LAB_10005c56;\n    } else {\n        if (*(char *)(input_value + 0x14) != '\\0') {\n            input_value = FUN_1000fe6e();\n            if (index < *(uint *)(input_value + 0xc)) {\n                facet_pointer = *(facet **)(*(int *)(input_value + 8) + index * 4);\n                if (facet_pointer != (facet *)0x0) goto LAB_10005c56;\n            }\n        }\n        facet_pointer = (facet *)0x0;\n    }\n\n    if (facet_pointer == (facet *)0x0) {\n        input_value = FUN_10005400((int *)&new_facet);\n        if (input_value == -1) {\n            FUN_10010a35(exception_data, 0, 0xe0);\n            __CxxThrowException_8(exception_data, &DAT_10031398);\n        }\n        facet_pointer = new_facet;\n        DAT_10035a48 = new_facet;\n        FUN_10001820((int)new_facet);\n        std::locale::facet::facet_Register(facet_pointer);\n    }\n\nLAB_10005c56:\n    FUN_1000fe01(&lock_variable);\n    ExceptionList = exception_list;\n    return facet_pointer;\n}\n"}
{"Function Name": "FUN_10005c80", "Address": "10005c80", "Source Code": "\nvoid * __cdecl FUN_10005c80(void *param_1, void *param_2, undefined4 *param_3)\n{\n    char currentChar; // Variable to hold character value during iteration\n    undefined4 *param3Pointer; // Pointer for traversing param_3\n    void *resultPointer; // Pointer to hold the result from FUN_10004070\n    undefined tempBuffer[4]; // Local buffer for temporary storage\n    uint localCounter = 0xf; // Local variable initialized to 15\n\n    exceptionList = &localMemory; // Set the ExceptionList to point to local_24\n    FUN_10003db0(tempBuffer, param_2, 0, 0xffffffff); // Call FUN_10003db0 with local_28 and param_2\n    \n    param3Pointer = param_3; // Initialize puVar2 to point to param_3\n    while ((currentChar = *(char *)param3Pointer) != '\\0') { // Loop until a null character is found in param_3\n        param3Pointer = (undefined4 *)((int)param3Pointer + 1); // Move to the next character in param_3\n    }\n    \n    resultPointer = FUN_10004070(tempBuffer, param_3, (int)param3Pointer - ((int)param_3 + 1)); // Call FUN_10004070 with local_28, param_3, and length of param_3\n    *(undefined4 *)((int)param_1 + 0x18) = 0xf; // Set a value in param_1 at offset 0x18 to 15\n    *(undefined4 *)((int)param_1 + 0x14) = 0; // Set a value in param_1 at offset 0x14 to 0\n    *(undefined *)((int)param_1 + 4) = 0; // Set a value in param_1 at offset 4 to 0\n    FUN_10003db0(param_1, resultPointer, 0, 0xffffffff); // Call FUN_10003db0 with param_1 and pvVar3\n    \n    if (0xf < localCounter) { // Check if local_10 is greater than 15\n        _free(localMemory); // Free the memory pointed to by local_24\n    }\n    \n    return param_1; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_10005d60", "Address": "10005d60", "Source Code": "\nvoid * __cdecl FUN_10005d60(void *param_1, undefined4 param_2, void *memory_pointer_param)\n{\n    uint stack_value; // Variable to hold a value from the stack\n    void *current_exception_list;         // Local variable to store the current ExceptionList\n    undefined *memory_pointer; // Pointer to a specific location in memory\n    undefined4 local_value;   // Local variable to hold a value, initialized later\n\n    memory_pointer = &LAB_10027b19; // Set puStack_8 to point to a specific label\n    current_exception_list = ExceptionList;    // Store the current ExceptionList in local_c\n    ExceptionList = &current_exception_list;   // Update ExceptionList to point to local_c\n    local_value = 2;                // Initialize local_4 with the value 2\n\n    FUN_10004eb0(param_1, &param_2, &stack0x00000024); // Call another function with parameters\n    local_value._0_1_ = 1;          // Set the first byte of local_4 to 1\n\n    if (0xf < stack_value) { // Check if in_stack_00000020 is greater than 15\n        _free(memory_pointer_param);           // Free the memory pointed to by param_3\n    }\n\n    stack_value = 0xf;     // Set in_stack_00000020 to 15\n    memory_pointer_param = (void *)((uint)memory_pointer_param & 0xffffff00); // Mask param_3 to clear the lower 8 bits\n    local_value = (uint)local_value._1_3_ << 8; // Shift the upper 3 bytes of local_4 to the left by 8 bits\n\n    FUN_10003810((int)&stack0x00000024); // Call another function with the address of stack0x00000024\n    ExceptionList = current_exception_list;    // Restore the original ExceptionList\n\n    return param_1;             // Return the original param_1\n}\n"}
{"Function Name": "FUN_10005e00", "Address": "10005e00", "Source Code": "\nvoid * __fastcall FUN_10005e00(void *input_param) // Function definition with fastcall calling convention\n{\n    void *return_value; // Pointer variable to hold a return value\n    __time64_t current_time; // Variable to store the current time\n    void *local_pointer; // Local pointer variable\n    uint local_value; // Local variable to hold a value\n\n    local_value = 0xf; // Initialize local_10 to 15\n    *(undefined4 *)((int)input_param + 0x18) = 0xf; // Set a value at offset 0x18 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x14) = 0; // Set a value at offset 0x14 in param_1 to 0\n    *(undefined *)((int)input_param + 4) = 0; // Set a byte at offset 4 in param_1 to 0\n    *(undefined4 *)((int)input_param + 0x38) = 0xf; // Set a value at offset 0x38 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x34) = 0; // Set a value at offset 0x34 in param_1 to 0\n    *(undefined *)((int)input_param + 0x24) = 0; // Set a byte at offset 0x24 in param_1 to 0\n    *(undefined4 *)((int)input_param + 0x54) = 0xf; // Set a value at offset 0x54 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x50) = 0; // Set a value at offset 0x50 in param_1 to 0\n    *(undefined *)((int)input_param + 0x40) = 0; // Set a byte at offset 0x40 in param_1 to 0\n    *(undefined4 *)((int)input_param + 0x70) = 0xf; // Set a value at offset 0x70 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x6c) = 0; // Set a value at offset 0x6c in param_1 to 0\n    *(undefined *)((int)input_param + 0x5c) = 0; // Set a byte at offset 0x5c in param_1 to 0\n    *(undefined4 *)((int)input_param + 0x90) = 0xf; // Set a value at offset 0x90 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x8c) = 0; // Set a value at offset 0x8c in param_1 to 0\n    *(undefined *)((int)input_param + 0x7c) = 0; // Set a byte at offset 0x7c in param_1 to 0\n    *(undefined4 *)((int)input_param + 0xac) = 0xf; // Set a value at offset 0xac in param_1 to 15\n    *(undefined4 *)((int)input_param + 0xa8) = 0; // Set a value at offset 0xa8 in param_1 to 0\n    *(undefined *)((int)input_param + 0x98) = 0; // Set a byte at offset 0x98 in param_1 to 0\n    *(undefined4 *)((int)input_param + 200) = 0xf; // Set a value at offset 200 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0xc4) = 0; // Set a value at offset 0xc4 in param_1 to 0\n    *(undefined *)((int)input_param + 0xb4) = 0; // Set a byte at offset 0xb4 in param_1 to 0\n    *(undefined4 *)((int)input_param + 0xe4) = 0xf; // Set a value at offset 0xe4 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0xe0) = 0; // Set a value at offset 0xe0 in param_1 to 0\n    *(undefined *)((int)input_param + 0xd0) = 0; // Set a byte at offset 0xd0 in param_1 to 0\n    *(undefined4 *)((int)input_param + 0x104) = 0xf; // Set a value at offset 0x104 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x100) = 0; // Set a value at offset 0x100 in param_1 to 0\n    *(undefined *)((int)input_param + 0xf0) = 0; // Set a byte at offset 0xf0 in param_1 to 0\n    *(undefined4 *)((int)input_param + 0x134) = 0xf; // Set a value at offset 0x134 in param_1 to 15\n    *(undefined4 *)((int)input_param + 0x130) = 0; // Set a value at offset 0x130 in param_1 to 0\n    *(undefined *)((int)input_param + 0x120) = 0; // Set a byte at offset 0x120 in param_1 to 0\n    *(undefined *)((int)input_param + 0x1c) = 0; // Set a byte at offset 0x1c in param_1 to 0\n    *(undefined *)((int)input_param + 0x1d) = 0; // Set a byte at offset 0x1d in param_1 to 0\n    *(undefined *)((int)input_param + 0x1f) = 0; // Set a byte at offset 0x1f in param_1 to 0\n    *(undefined *)((int)input_param + 0x1e) = 0; // Set a byte at offset 0x1e in param_1 to 0\n\n    FUN_10003e90(input_param,(undefined4 *)\"http:\"); // Call function with param_1 and \"http:\"\n    FUN_10003e90((void *)((int)input_param + 0x20),&PTR_1002bc68,0); // Call function with offset 0x20 and pointer\n    FUN_10003e90((void *)((int)input_param + 0x3c),&PTR_1002bc68,0); // Call function with offset 0x3c and pointer\n\n    return_value = FUN_10005c80(NULL,input_param,(undefined4 *)\"/mconfig/lunlian.txt\"); // Call function and store result in pvVar1\n    FUN_10003db0((void *)((int)input_param + 0x58),return_value,0,0xffffffff); // Call function with offset 0x58 and pvVar1\n\n    if (0xf < local_value) { // Check if local_10 is greater than 15\n        _free(local_pointer); // Free memory pointed by local_24\n    }\n\n    local_pointer = (void *)((uint)local_pointer & 0xffffff00); // Mask local_24 to clear lower 8 bits\n    *(undefined4 *)((int)input_param + 0x74) = 0x1e; // Set a value at offset 0x74 in param_1 to 30\n    FUN_10003e90((void *)((int)input_param + 0x94),&PTR_1002bc68,0); // Call function with offset 0x94 and pointer\n    FUN_10003e90((void *)((int)input_param + 0xb0),&PTR_1002bc68,0); // Call function with offset 0xb0 and pointer\n    FUN_10003e90((void *)((int)input_param + 0xcc),(undefined4 *)\".html\",5); // Call function with offset 0xcc and \".html\"\n\n    *(undefined4 *)((int)input_param + 0xe8) = 0x1e; // Set a value at offset 0xe8 in param_1 to 30\n    FUN_10003e90((void *)((int)input_param + 0xec),(undefined4 *)&DAT_1002bdf0,3); // Call function with offset 0xec and pointer\n\n    *(undefined *)((int)input_param + 0x108) = 0; // Set a byte at offset 0x108 in param_1 to 0\n    current_time = __time64((__time64_t *)((int)input_param + 0x110)); // Get current time and store in _Var2\n    *(__time64_t *)((int)input_param + 0x110) = current_time; // Store current time at offset 0x110 in param_1\n    *(undefined *)((int)input_param + 0x118) = 0; // Set a byte at offset 0x118 in param_1 to 0\n    FUN_10003e90((void *)((int)input_param + 0x11c),&PTR_1002bc68,0); // Call function with offset 0x11c and pointer\n    FUN_10003e90((void *)((int)input_param + 0x138),(undefined4 *)&DAT_1002bdec,3); // Call function with offset 0x138 and pointer\n\n    *(undefined *)((int)input_param + 0x154) = 1; // Set a byte at offset 0x154 in param_1 to 1\n    *(undefined *)((int)input_param + 0x155) = 0; // Set a byte at offset 0x155 in param_1 to 0\n\n    return input_param; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_10006050", "Address": "10006050", "Source Code": "\nvoid FUN_10006050(int *param_1, void *param_2)\n{\n    char characterRead; // Variable to store character read from puVar3\n    int *intPointer; // Pointer to an integer\n    undefined4 *undefinedPointer; // Pointer to an undefined4 type\n    void *voidPointer; // Pointer to a void type\n    undefined4 curlInitResult; // Variable to store return value from curl_easy_init\n    undefined4 ***pointerToPointerToPointer; // Pointer to a pointer to a pointer to an undefined4 type\n    long temporaryLong; // Long variable for temporary storage\n    undefined4 *allocatedMemoryPointer; // Local pointer to undefined4 type\n    int httpStatusCode; // Local variable to store HTTP status code\n    char *localCharacterPointer; // Local pointer to a character\n    void *localVoidPointer; // Local pointer to a void type\n    uint *localUintPointer; // Pointer to a uint type\n    uint localUintValue; // Local variable of type uint\n    undefined4 localUndefinedValue; // Local variable of type undefined4\n    uint localCounter; // Local variable of type uint\n    localCounter = 0xf; // Initialize local_c to 15\n    allocatedMemoryPointer = (undefined4 *)0x0; // Initialize local_d4 to NULL\n    localUintPointer = &localCounter; // Set local_c0 to point to local_c\n    localVoidPointer = param_2; // Assign param_2 to local_c4\n    intPointer = (int *)(**(code **)(*param_1 + 0xc))(); // Call function pointer from param_1\n    undefinedPointer = (undefined4 *)(**(code **)(*intPointer + 0xc))(&DAT_1002bf84, 0); // Call another function pointer\n    do {\n        characterRead = *(char *)undefinedPointer; // Read character from puVar3\n        undefinedPointer = (undefined4 *)((int)undefinedPointer + 1); // Increment puVar3 to point to the next character\n    } while (characterRead != '\\0'); // Continue until null terminator is found\n    FUN_10003e90(localBuffer, undefinedPointer, (int)undefinedPointer - ((int)undefinedPointer + 1)); // Call FUN_10003e90 with parameters\n    voidPointer = FUN_10005c80(localYetAnotherPointer, param_2, (undefined4 *)\"/mconfig/\"); // Call FUN_10005c80\n    voidPointer = FUN_10004bf0(local_24, voidPointer, (int)localBuffer); // Call FUN_10004bf0\n    if (0xf < localCounter) { // Check if local_c is greater than 15\n        _free(localMemoryPointer[0]); // Free memory if condition is met\n    }\n    localCounter = 0xf; // Reset local_c to 15\n    localUndefinedValue = 0; // Initialize local_10 to 0\n    localMemoryPointer[0] = (undefined4 ***)((uint)localMemoryPointer[0] & 0xffffff00); // Mask local_20[0]\n    if (0xf < localAnotherCounter) { // Check if local_44 is greater than 15\n        _free(localAnotherPointer); // Free memory if condition is met\n    }\n    localAnotherCounter = 0xf; // Reset local_44 to 15\n    localAnotherPointer = (void *)((uint)localAnotherPointer & 0xffffff00); // Mask local_58\n    FUN_10004160((void *)((int)param_2 + 0x94), &PTR_1002bc68); // Call FUN_10004160\n    *(undefined *)((int)param_2 + 0x118) = 1; // Set a byte in param_2\n    *(__time64_t *)((int)param_2 + 0x110) = __time64((__time64_t *)0x0); // Set current time in param_2\n    curlInitResult = curl_easy_init(); // Initialize CURL\n    curl_easy_setopt(curlInitResult, 0x2734, &DAT_1002bf6c); // Set CURL option\n    pointerToPointerToPointer = localArray[0]; // Assign local_3c[0] to pppuVar6\n    if (localUintValue < 0x10) { // Check if local_28 is less than 16\n        pointerToPointerToPointer = localArray; // Assign local_3c to pppuVar6\n    }\n    curl_easy_setopt(curlInitResult, 0x2712, pointerToPointerToPointer); // Set another CURL option\n    curl_easy_setopt(curlInitResult, 0x2711, local_24); // Set another CURL option\n    curl_easy_perform(curlInitResult); // Perform CURL operation\n    httpStatusCode = 0; // Initialize local_cc to 0\n    curl_easy_getinfo(curlInitResult, 0x200002, &httpStatusCode); // Get CURL info\n    curl_easy_cleanup(curlInitResult); // Clean up CURL resources\n    if (httpStatusCode == 200) { // Check if HTTP status code is 200 (OK)\n        allocatedMemoryPointer = (undefined4 *)operator_new(0x48); // Allocate memory\n        if (allocatedMemoryPointer != (undefined4 *)0x0) { // Check if allocation was successful\n            intPointer = FUN_1000c980(allocatedMemoryPointer); // Call FUN_1000c980\n        }\n        pointerToPointerToPointer = localMemoryPointer[0]; // Assign local_20[0] to pppuVar6\n        if (localCounter < 0x10) { // Check if local_c is less than 16\n            pointerToPointerToPointer = localMemoryPointer; // Assign local_20 to pppuVar6\n        }\n        (**(code **)(*intPointer + 8))(pointerToPointerToPointer, 0, 0); // Call function pointer with parameters\n        int loopCounter = FUN_1000be60((int)intPointer); // Call FUN_1000be60\n        if (loopCounter == 0) { // Check if return value is 0\n            int innerLoopCounter = 8; // Initialize loop counter\n            bool comparisonFlag = true; // Initialize boolean flag\n            char *comparisonStringPointer = (char *)(_DAT_00000020 + 8); // Pointer to comparison string\n            char *comparisonString = \"mconfig\"; // Comparison string\n            do {\n                if (innerLoopCounter == 0) break; // Break if loop counter reaches 0\n                innerLoopCounter--; // Decrement loop counter\n                comparisonFlag = *comparisonStringPointer == *comparisonString; // Compare characters\n                comparisonStringPointer++; // Move to next character in pcVar13\n                comparisonString++; // Move to next character in pcVar14\n            } while (comparisonFlag); // Continue while characters match\n            if (!comparisonFlag) goto LAB_10006929; // Go to label if characters do not match\n        }\n        for (allocatedMemoryPointer = (undefined4 *)FUN_1000be60(loopCounter); allocatedMemoryPointer != (undefined4 *)0x0; allocatedMemoryPointer = (undefined4 *)FUN_1000be90((int)allocatedMemoryPointer)) { // Loop through local_d4\n            int loopCounter = allocatedMemoryPointer[8]; // Get value from local_d4\n            localCharacterPointer = (char *)(loopCounter + 8); // Set local_c8 to point to a specific location\n            undefinedPointer = (undefined4 *)FUN_1000bf50((int)allocatedMemoryPointer); // Call FUN_1000bf50\n            if (undefinedPointer != (undefined4 *)0x0) { // Check if puVar3 is not NULL\n                int innerLoopCounter = 9; // Initialize loop counter\n                bool comparisonFlag = true; // Initialize boolean flag\n                char *comparisonStringPointer = (char *)(loopCounter + 8); // Pointer to comparison string\n                char *comparisonString = \"redirect\"; // Comparison string\n                do {\n                    if (innerLoopCounter == 0) break; // Break if loop counter reaches 0\n                    innerLoopCounter--; // Decrement loop counter\n                    comparisonFlag = *comparisonStringPointer == *comparisonString; // Compare characters\n                    comparisonStringPointer++; // Move to next character in pcVar13\n                    comparisonString++; // Move to next character in pcVar14\n                } while (comparisonFlag); // Continue while characters match\n                if (comparisonFlag) { // If characters match\n                    loopCounter = 2; // Set iVar12 to 2\n                    comparisonFlag = true; // Initialize boolean flag\n                    char *comparisonStringPointer = \"1\"; // Pointer to comparison string\n                    do {\n                        if (loopCounter == 0) break; // Break if loop counter reaches 0\n                        loopCounter--; // Decrement loop counter\n                        comparisonFlag = *(char *)undefinedPointer == *comparisonStringPointer; // Compare characters\n                        undefinedPointer = (undefined4 *)((int)undefinedPointer + 1); // Increment puVar3\n                        comparisonStringPointer++; // Move to next character in pcVar13\n                    } while (comparisonFlag); // Continue while characters match\n                    *(bool *)((int)localVoidPointer + 0x1c) = comparisonFlag; // Set value in local_c4\n                }\n            }\n            // ... (rest of the code remains unchanged)\n        }\n    }\n    // ... (rest of the function remains unchanged)\n}\n"}
{"Function Name": "Catch@100077f5", "Address": "100077f5", "Source Code": "\nundefined * Catch_100077f5(void)\n{\n    // Retrieve a pointer to an integer from a specific offset of the base pointer\n    int *pointerToInt = *(int **)(unaff_EBP + -0x14);\n    \n    // Get an integer value from the memory location pointed to by piVar1, offset by 4\n    int intValue = *(int *)(*pointerToInt + 4);\n    \n    // Calculate a new value by reading a uint from a specific memory location, applying a bitwise AND and OR operation\n    uint calculatedValue = *(uint *)((int)pointerToInt + intValue + 8) & 0x17 | 4;\n    \n    // Store the new value back to the same memory location\n    *(uint *)((int)pointerToInt + intValue + 8) = calculatedValue;\n\n    // Check if a specific condition is met using a bitwise AND operation\n    if ((*(uint *)((int)pointerToInt + intValue + 0xc) & calculatedValue) == 0) {\n        // If condition is met, return a specific address\n        return &DAT_1000781f;\n    }\n\n    // Call a function to throw an exception\n    __CxxThrowException_8(0, (byte *)0x0);\n    \n    // Modify uVar3 by reading a uint from a specific memory location and applying a bitwise OR operation\n    calculatedValue = *(uint *)((int)context + 8) | 2;\n\n    // Check if a specific integer value is zero and modify uVar3 accordingly\n    if (*(int *)((int)context + 0x28) == 0) {\n        calculatedValue |= 6;\n    }\n\n    // Return the result of a function call, masking the lower byte\n    return (undefined *)(FUN_10005480(context, calculatedValue, '\\0') & 0xffffff00);\n}\n"}
{"Function Name": "FUN_10007860", "Address": "10007860", "Source Code": "\nvoid __thiscall FUN_10007860(void *this, void **param_1, char param_2, int **param_3, void *param_4)\n{\n    char characterValue; // Variable to store a character value\n    int **intPointerPointer5; // Pointer to pointer for integer\n    int **intPointerPointer8; // Pointer to pointer for integer\n    int *intPointer7; // Pointer for integer\n    undefined localUndefinedArray50[4]; // Local variable array of undefined type\n    undefined localUndefinedVariable4C; // Local variable of undefined type\n    undefined4 localUndefined4Variable38; // Local variable of type undefined4\n    undefined localUndefinedArray34[40]; // Local variable array of undefined type\n    void *localPointerC; // Local pointer variable\n    undefined *stackPointer8; // Pointer to undefined type for stack\n    undefined4 localVariable4 = 0xffffffff; // Local variable initialized to -1\n    stackPointer8 = &LAB_10027ee8; // Assigning address to stack pointer\n    localPointerC = ExceptionList; // Storing current ExceptionList\n    ExceptionList = &localPointerC; // Updating ExceptionList to point to local_c\n    \n    // Check if a certain condition is met based on the value at this + 8\n    if (0xae4c3f < *(uint *)((int)this + 8)) {\n        localUndefined4Variable38 = 0xf; // Set local variable\n        localUndefinedVariable4C = 0; // Initialize local variable\n        FUN_10003e90(localUndefinedArray50, (undefined4 *)\"map/set<T> too long\", 0x13); // Call function with parameters\n        localVariable4 = 0; // Reset local variable\n        FUN_10004360(localUndefinedArray34, localUndefinedArray50); // Call function with parameters\n        __CxxThrowException_8(localUndefinedArray34, &DAT_100315e8); // Throw an exception\n    }\n    \n    // Call function and assign result to ppiVar5\n    intPointerPointer5 = (int **)FUN_10006ce0(*(undefined4 *)((int)this + 4), param_3, *(undefined4 *)((int)this + 4), param_4, 0);\n    *(int *)((int)this + 8) += 1; // Increment the value at this + 8\n\n    // Check if param_3 is equal to the value at this + 4\n    if (param_3 == *(int ***)((int)this + 4)) {\n        (*(int ***)((int)this + 4))[1] = (int *)intPointerPointer5; // Assign ppiVar5 to the second element\n        **(int ***)((int)this + 4) = (int *)intPointerPointer5; // Assign ppiVar5 to the first element\n        *(int ***)(*(int *)((int)this + 4) + 8) = intPointerPointer5; // Assign ppiVar5 to the element at offset 8\n    } else if (param_2 == '\\0') { // Check if param_2 is zero\n        param_3[2] = (int *)intPointerPointer5; // Assign ppiVar5 to the third element of param_3\n        // Check if param_3 is equal to the value at this + 4 + 8\n        if (param_3 == *(int ***)(*(int *)((int)this + 4) + 8)) {\n            *(int ***)(*(int *)((int)this + 4) + 8) = intPointerPointer5; // Assign ppiVar5 to the element at offset 8\n        }\n    } else { // If param_2 is not zero\n        *param_3 = (int *)intPointerPointer5; // Assign ppiVar5 to the first element of param_3\n        // Check if param_3 is equal to the first element of the value at this + 4\n        if (param_3 == (int **)**(int ***)((int)this + 4)) {\n            **(int ***)((int)this + 4) = (int *)intPointerPointer5; // Assign ppiVar5 to the first element\n        }\n    }\n\n    characterValue = *(char *)(intPointerPointer5[1] + 0x62); // Get character from ppiVar5\n    intPointerPointer8 = intPointerPointer5; // Initialize ppiVar8 with ppiVar5\n\n    do {\n        // Check if cVar1 is not zero\n        if (characterValue != '\\0') {\n            *(undefined *)(*(int *)(*(int *)((int)this + 4) + 4) + 0x188) = 1; // Set a value in memory\n            param_1[1] = intPointerPointer5; // Assign ppiVar5 to the second element of param_1\n            *param_1 = this; // Assign this to the first element of param_1\n            ExceptionList = localPointerC; // Restore ExceptionList\n            return; // Exit the function\n        }\n\n        int **intPointerPointer2 = (int **)*++intPointerPointer8; // Increment ppiVar8 and assign to ppiVar2\n        int **intPointerPointer3 = (int **)intPointerPointer2[1]; // Get the second element of ppiVar2\n\n        // Check if ppiVar2 is equal to the first element of ppiVar3\n        if (intPointerPointer2 == (int **)*intPointerPointer3) {\n            int *intPointer4 = intPointerPointer3[2]; // Get the third element of ppiVar3\n            // Check if a certain character is zero\n            if (*(char *)(intPointer4 + 0x62) == '\\0') {\n                *(undefined *)(intPointerPointer2 + 0x62) = 1; // Set a value in memory\n                *(undefined *)(intPointer4 + 0x62) = 1; // Set a value in memory\n                *(undefined *)((*intPointerPointer8)[1] + 0x188) = 0; // Set a value in memory\n                intPointerPointer8 = (int **)(*intPointerPointer8)[1]; // Update ppiVar8\n            } else {\n                // Check if ppiVar8 is equal to the second element of ppiVar2\n                if (intPointerPointer8 == (int **)intPointerPointer2[2]) {\n                    FUN_100027e0(this, (int *)intPointerPointer2); // Call function with parameters\n                    intPointerPointer8 = intPointerPointer2; // Update ppiVar8\n                }\n                *(undefined *)(intPointerPointer8[1] + 0x62) = 1; // Set a value in memory\n                *(undefined *)(intPointerPointer8[1][1] + 0x188) = 0; // Set a value in memory\n                FUN_10002840(this, (int *)intPointerPointer8[1][1]); // Call function with parameters\n            }\n        } else { // If ppiVar2 is not equal to the first element of ppiVar3\n            intPointer7 = *intPointerPointer3; // Get the first element of ppiVar3\n            // Check if a certain character is zero\n            if (*(char *)(intPointer7 + 0x62) == '\\0') {\n                *(undefined *)(intPointerPointer2 + 0x62) = 1; // Set a value in memory\n                *(undefined *)(intPointer7 + 0x62) = 1; // Set a value in memory\n                *(undefined *)((*intPointerPointer8)[1] + 0x188) = 0; // Set a value in memory\n                intPointerPointer8 = (int **)(*intPointerPointer8)[1]; // Update ppiVar8\n            } else {\n                // Check if ppiVar8 is equal to the first element of ppiVar2\n                if (intPointerPointer8 == (int **)*intPointerPointer2) {\n                    FUN_10002840(this, (int *)intPointerPointer2); // Call function with parameters\n                    intPointerPointer8 = intPointerPointer2; // Update ppiVar8\n                }\n                *(undefined *)(intPointerPointer8[1] + 0x62) = 1; // Set a value in memory\n                *(undefined *)(intPointerPointer8[1][1] + 0x188) = 0; // Set a value in memory\n                intPointer7 = (int *)intPointerPointer8[1][1]; // Get the second element of ppiVar8\n                int *intPointer4 = (int *)intPointer7[2]; // Get the third element of piVar7\n                intPointer7[2] = *intPointer4; // Assign the value of piVar4 to the third element of piVar7\n                // Check if a certain character is zero\n                if (*(char *)(*intPointer4 + 0x189) == '\\0') {\n                    *(int **)(*intPointer4 + 4) = intPointer7; // Set a value in memory\n                }\n                intPointer4[1] = intPointer7[1]; // Assign the second element of piVar7 to piVar4\n                // Check if piVar7 is equal to the first element of the value at this + 4 + 4\n                if (intPointer7 == (int *)*(int *)(*(int *)((int)this + 4) + 4)) {\n                    *(int **)(*(int *)((int)this + 4) + 4) = intPointer4; // Set a value in memory\n                } else {\n                    int **intPointerPointer2 = (int **)intPointer7[1]; // Get the second element of piVar7\n                    // Check if piVar7 is equal to the first element of ppiVar2\n                    if (intPointer7 == *intPointerPointer2) {\n                        *intPointerPointer2 = intPointer4; // Assign piVar4 to ppiVar2\n                    } else {\n                        intPointerPointer2[2] = intPointer4; // Assign piVar4 to the third element of ppiVar2\n                    }\n                }\n                *intPointer4 = (int)intPointer7; // Assign piVar7 to piVar4\n                intPointer7[1] = (int)intPointer4; // Assign piVar4 to the second element of piVar7\n            }\n        }\n        characterValue = *(char *)(intPointerPointer8[1] + 0x62); // Update cVar1\n    } while (true); // Infinite loop\n}\n"}
{"Function Name": "FUN_10007ae0", "Address": "10007ae0", "Source Code": "\nvoid __thiscall FUN_10007ae0(void *this, void **param_1, void *param_2)\n{\n    // Retrieve the pointer to an array of integer pointers from the object\n    int **intPointerArray = (int **)(*(int ***)((int)this + 4))[1];\n    \n    // Get a character value from a specific offset in the integer pointer array\n    char characterValue = *(char *)((int)intPointerArray + 0x189);\n    \n    // Initialize a boolean variable to true\n    bool isConditionMet = true;\n    \n    int **selectedPointerArray; // Declare a pointer to integer pointers\n    void *currentObjectPointer = this; // Store the current object pointer\n\n    // Loop until the character value is not null\n    while (characterValue == '\\0') {\n        // Get the 9th integer pointer from the array\n        int *ninthIntegerPointer = intPointerArray[9];\n        \n        // Determine which pointer to use based on a condition\n        selectedPointerArray = (intPointerArray[10] < (int *)0x10) ? intPointerArray + 5 : (int **)intPointerArray[5];\n        \n        // Retrieve the 14th integer pointer from the parameter\n        int *fourteenthIntegerPointer = *(int **)((int)param_2 + 0x14);\n        \n        // Determine the minimum of the two integer pointers\n        int *minimumPointer = (ninthIntegerPointer <= fourteenthIntegerPointer) ? ninthIntegerPointer : fourteenthIntegerPointer;\n        \n        // Get the appropriate integer pointer based on a condition\n        int *appropriateIntegerPointer = (*(uint *)((int)param_2 + 0x18) < 0x10) ? (int *)((int)param_2 + 4) : *(int **)((int)param_2 + 4);\n        \n        // Call a function with the determined pointers and store the result\n        uint functionResult = FUN_10001710(appropriateIntegerPointer, (int *)selectedPointerArray, (uint)minimumPointer);\n\n        // Update uVar6 based on a condition\n        if (functionResult == 0) {\n            functionResult = (fourteenthIntegerPointer < ninthIntegerPointer) ? 0xffffffff : (uint)(fourteenthIntegerPointer != ninthIntegerPointer);\n        }\n        \n        // Update the boolean variable based on the value of uVar6\n        isConditionMet = (int)functionResult < 0;\n        \n        // Update ppiVar2 based on the boolean condition\n        intPointerArray = isConditionMet ? (int **)*intPointerArray : (int **)intPointerArray[2];\n        \n        // Retrieve the character value again from the updated pointer\n        characterValue = *(char *)((int)intPointerArray + 0x189);\n    }\n\n    // If local_c is true, perform additional checks\n    if (isConditionMet) {\n        // Check if ppiVar10 matches a specific value\n        if (selectedPointerArray == (int **)**(int **)((int)this + 4)) {\n            isConditionMet = true; // Set local_c to true\n            goto LAB_10007ba1; // Jump to the label\n        }\n        \n        // Call a function with the current object pointer\n        FUN_10001df0((int *)&currentObjectPointer);\n    }\n\n    // Call another function and store the result\n    uint functionResult = FUN_10002660(selectedPointerArray + 4, 0, (uint)selectedPointerArray[9], (*(uint *)((int)param_2 + 0x18) < 0x10) ? (int *)((int)param_2 + 4) : *(int **)((int)param_2 + 4), *(uint *)((int)param_2 + 0x14));\n    \n    // Check if the result is non-negative\n    if (-1 < (int)functionResult) {\n        // Update the output parameters with the results\n        param_1[1] = intPointerArray;\n        *(undefined *)(param_1 + 2) = 0; // Set a specific output value\n        *param_1 = currentObjectPointer; // Set the first output parameter\n        return; // Exit the function\n    }\n    \nLAB_10007ba1:\n    // Call a function to get additional results and update output parameters\n    void **resultPointerArray = (void **)FUN_10007860(this, &currentObjectPointer, isConditionMet, selectedPointerArray, param_2);\n    param_1[1] = resultPointerArray[1]; // Set the second output parameter\n    *(undefined *)(param_1 + 2) = 1; // Set a specific output value\n    *param_1 = *resultPointerArray; // Set the first output parameter\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10007c20", "Address": "10007c20", "Source Code": "\nvoid __thiscall\nFUN_10007c20(void *this, void **param_1, void *param_2, int **param_3, void *param_4, int **param_5)\n{\n    // Retrieve the pointer to the first element of the structure associated with 'this'\n    int **ppiVar1 = (int **)**(int **)((int)this + 4);\n    void *pvVar3 = param_2; // Initialize pvVar3 with param_2\n\n    // Check if param_2 is null or does not point to 'this'\n    if ((param_2 == (void *)0x0) || (param_2 != this)) {\n        FUN_10011202(); // Call error handling function\n    }\n\n    // Check if param_3 is equal to the structure pointer\n    if (param_3 == ppiVar1) {\n        // Check if param_4 is null or does not point to 'this'\n        if ((param_4 == (void *)0x0) || (param_4 != this)) {\n            FUN_10011202(); // Call error handling function\n        }\n        // Check if param_5 is equal to the structure pointer\n        if (param_5 == ppiVar1) {\n            // Call a function with a specific argument from the structure\n            FUN_100071e0(*(int **)(*(int *)((int)this + 4) + 4));\n            // Update the structure with new values\n            *(int *)(*(int *)((int)this + 4) + 4) = *(int *)((int)this + 4);\n            *(undefined4 *)((int)this + 8) = 0; // Set a specific field to zero\n            *(undefined4 *)*(undefined4 *)((int)this + 4) = *(undefined4 *)((int)this + 4);\n            *(int *)(*(int *)((int)this + 4) + 8) = *(int *)((int)this + 4);\n            pvVar3 = **(void ***)((int)this + 4); // Update pvVar3 with a new value\n            *param_1 = this; // Assign 'this' to the first element of param_1\n            param_1[1] = pvVar3; // Assign pvVar3 to the second element of param_1\n            return; // Exit the function\n        }\n    }\n\n    // Loop until a break condition is met\n    while (true) {\n        // Check if pvVar3 is null or does not point to param_4\n        if ((pvVar3 == (void *)0x0) || (pvVar3 != param_4)) {\n            FUN_10011202(); // Call error handling function\n        }\n        // Break the loop if param_3 is equal to param_5\n        if (param_3 == param_5) break;\n        // Call a function with the address of param_2\n        FUN_10001e90((int *)&param_2);\n        // Call another function with specific parameters\n        FUN_10006e20(this, (int[2]){0}, (int)pvVar3, param_3);\n        pvVar3 = param_2; // Update pvVar3 with the new value of param_2\n    }\n\n    // Assign the final values to param_1\n    *param_1 = pvVar3; // Set the first element of param_1 to pvVar3\n    param_1[1] = param_3; // Set the second element of param_1 to param_3\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10007cf0", "Address": "10007cf0", "Source Code": "\nvoid __thiscall\nFUN_10007cf0(void *this, void **param_1, void *param_2, int **param_3, void *param_4, int **param_5)\n{\n    // Retrieve a pointer to an integer pointer from the object\n    int **ppiVar1 = (int **)**(int **)((int)this + 4);\n    void *pvVar3 = param_2; // Initialize pvVar3 with param_2\n\n    // Check if param_2 is null or not equal to 'this'\n    if ((param_2 == (void *)0x0) || (param_2 != this)) {\n        FUN_10011202(); // Call error handling function\n    }\n\n    // Check if param_3 is equal to ppiVar1\n    if (param_3 == ppiVar1) {\n        // Check if param_4 is null or not equal to 'this'\n        if ((param_4 == (void *)0x0) || (param_4 != this)) {\n            FUN_10011202(); // Call error handling function\n        }\n        // Check if param_5 is equal to ppiVar1\n        if (param_5 == ppiVar1) {\n            // Call another function with a specific argument\n            FUN_10007530(*(int **)(*(int *)((int)this + 4) + 4));\n            // Update the value at a specific memory location\n            *(int *)(*(int *)((int)this + 4) + 4) = *(int *)((int)this + 4);\n            *(undefined4 *)((int)this + 8) = 0; // Set a specific memory location to zero\n            *(undefined4 *)*(undefined4 *)((int)this + 4) = *(undefined4 *)((int)this + 4);\n            *(int *)(*(int *)((int)this + 4) + 8) = *(int *)((int)this + 4);\n            pvVar3 = **(void ***)((int)this + 4); // Update pvVar3 with a new value\n            *param_1 = this; // Set the first element of param_1 to 'this'\n            param_1[1] = pvVar3; // Set the second element of param_1 to pvVar3\n            return; // Exit the function\n        }\n    }\n\n    // Infinite loop to process until a break condition is met\n    while (true) {\n        // Check if pvVar3 is null or not equal to param_4\n        if ((pvVar3 == (void *)0x0) || (pvVar3 != param_4)) {\n            FUN_10011202(); // Call error handling function\n        }\n        // Break the loop if param_3 is equal to param_5\n        if (param_3 == param_5) break;\n        FUN_100029e0((int *)&param_2); // Call another function with param_2\n        FUN_10007260(this, (int[2]){0}, (int)pvVar3, param_3); // Call a function with specific arguments\n    }\n\n    *param_1 = pvVar3; // Set the first element of param_1 to pvVar3\n    param_1[1] = param_3; // Set the second element of param_1 to param_3\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10007dc0", "Address": "10007dc0", "Source Code": "\nint * __cdecl FUN_10007dc0(int *input_pointer, void *data_pointer, byte match_value)\n{\n    uint status_flags; // Variable to store a status or flag\n    uint accumulated_flags = 0; // Local variable to accumulate flags\n    char condition_met = '\\0'; // Local variable to track a condition\n    int *local_address; // Pointer to hold a local address\n\n    // Call a function to initialize local_28 based on param_1\n    FUN_10007a60(&local_address, input_pointer, 1);\n    status_flags = 0; // Initialize uVar2\n\n    // Check if local_24 is not zero (not shown in the snippet)\n    if (check_value != '\\0') {\n        // Call a function with param_2 and specific parameters\n        FUN_10002ab0(data_pointer, (undefined4 *)0x0, 0xffffffff);\n        \n        // Retrieve a value based on param_1\n        uint current_value = FUN_10002150(*(int **)(*(int *)(*input_pointer + 4) + 0x28 + (int)input_pointer));\n        \n        // Loop while local_20 is not equal to 0xffffffff\n        while (current_value != 0xffffffff) {\n            // Check if local_20 matches param_3\n            if (current_value == match_value) {\n                condition_met = '\\x01'; // Set local_15 to indicate a match\n                // Call a function with a specific pointer\n                FUN_10002720(*(int **)(*(int *)(*input_pointer + 4) + 0x28 + (int)input_pointer));\n                goto LAB_10007e5e; // Jump to the end of the function\n            }\n            // Check if a condition on param_2 is met\n            if (0xfffffffd < *(uint *)((int)data_pointer + 0x14)) {\n                accumulated_flags |= 2; // Set a flag in local_1c\n                goto LAB_10007e5e; // Jump to the end of the function\n            }\n            // Call a function with param_2 and a specific value\n            FUN_10003d00(data_pointer, 1);\n            condition_met = '\\x01'; // Set local_15 to indicate a condition\n            // Retrieve the next value based on param_1\n            current_value = FUN_10002bb0(*(int **)(*(int *)(*input_pointer + 4) + 0x28 + (int)input_pointer));\n        }\n        accumulated_flags |= 1; // Set another flag in local_1c\n    }\n\nLAB_10007e5e:\n    status_flags = accumulated_flags; // Assign local_1c to uVar2\n    // Check if local_15 indicates a condition was met\n    if (condition_met != '\\0') goto LAB_10007e71;\n\n    status_flags |= 2; // Set another flag in uVar2 if local_15 is not set\n\nLAB_10007e71:\n    void *calculated_pointer = (void *)(*(int *)(*input_pointer + 4) + (int)input_pointer); // Calculate a pointer based on param_1\n    // Check if uVar2 has any flags set\n    if (status_flags != 0) {\n        status_flags = *(uint *)((int)calculated_pointer + 8) | status_flags; // Combine flags\n        // Check if a specific condition is met\n        if (*(int *)((int)calculated_pointer + 0x28) == 0) {\n            status_flags |= 4; // Set another flag if the condition is met\n        }\n        // Call a function with this pointer and the combined flags\n        FUN_10005480(calculated_pointer, status_flags, '\\0');\n    }\n\n    // Retrieve a value based on local_28\n    int retrieved_value = *(int *)(*(int *)(*local_address + 4) + 0x28 + (int)local_address);\n    // Check if iVar1 is not zero\n    if (retrieved_value != 0) {\n        // Call a function with a pointer derived from iVar1\n        FUN_100101fa((LPCRITICAL_SECTION *)(retrieved_value + 4));\n    }\n\n    return input_pointer; // Return the original parameter\n}\n"}
{"Function Name": "Catch@10007ee6", "Address": "10007ee6", "Source Code": "\nundefined * Catch_10007ee6(void)\n{\n    // Retrieve a pointer to an integer from the stack frame\n    int *intPointer = *(int **)(unaff_EBP + 8);\n    \n    // Get the value at the offset of 4 from the integer pointer\n    int offsetValue = *(int *)(*intPointer + 4);\n    \n    // Calculate a new value by reading from memory, modifying it, and setting specific bits\n    uint modifiedValue = *(uint *)((int)intPointer + offsetValue + 8) & 0x17 | 4;\n    \n    // Store the modified value back into memory\n    *(uint *)((int)intPointer + offsetValue + 8) = modifiedValue;\n    \n    // Check if a specific condition is met using the modified value\n    if ((*(uint *)((int)intPointer + offsetValue + 0xc) & modifiedValue) == 0) {\n        // If the condition is met, return a specific address\n        return &DAT_10007f10;\n    }\n    \n    // If the condition is not met, throw an exception\n    __CxxThrowException_8(0, (byte *)0x0);\n    \n    // Call a function via a software interrupt and return its result\n    return (undefined *)(*(code *)swi(3))();\n}\n"}
{"Function Name": "FUN_10007f30", "Address": "10007f30", "Source Code": "\nvoid FUN_10007f30(int *input_pointer) // Function definition with an integer pointer parameter\n{\n    char character; // Variable to hold a character\n    uint unsigned_int_1; // Variable to hold an unsigned integer\n    uint unsigned_int_2; // Variable to hold another unsigned integer\n    int *int_pointer; // Pointer to an integer\n    undefined4 *undefined_pointer_1; // Pointer to an undefined 4-byte type\n    int int_variable; // Variable to hold an integer\n    void *void_pointer; // Pointer to a void type\n    undefined4 *undefined_pointer_2; // Pointer to an undefined 4-byte type\n    uint unsigned_int_3; // Variable to hold another unsigned integer\n    int ***int_pointer_pointer_pointer; // Pointer to a pointer to a pointer to an integer\n    undefined4 local_variable; // Local variable of undefined 4-byte type\n    undefined *stack_pointer; // Pointer to an undefined type for stack usage\n    local_variable = 0xffffffff; // Initialize local_c to -1\n    stack_pointer = &LAB_10027fb2; // Set stack pointer to a specific address\n    ExceptionList = &local_variable; // Set the exception list to local_c\n    FUN_10005e00(local_168); // Call a function with local_168 as an argument\n    local_variable = 0; // Reset local_c to 0\n    undefined_pointer_1 = (undefined4 *)(**(code **)(*input_pointer + 0xc))(); // Call a function pointer from param_1\n    unsigned_stack_1 = 0xf; // Initialize uStack_174 to 15\n    unsigned_stack_2 = 0; // Initialize uStack_178 to 0\n    int_pointer_pointer_array[0] = (int ***)((uint)int_pointer_pointer_array[0] & 0xffffff00); // Mask apppiStack_188[0]\n    undefined_pointer_2 = undefined_pointer_1; // Set puVar8 to puVar5\n    do {\n        character = *(char *)undefined_pointer_2; // Dereference puVar8 to get a character\n        undefined_pointer_2 = (undefined4 *)((int)undefined_pointer_2 + 1); // Increment puVar8\n    } while (character != '\\0'); // Continue until a null character is found\n    FUN_10003e90(array_stack_1, undefined_pointer_1, (int)undefined_pointer_2 - ((int)undefined_pointer_1 + 1)); // Call a function with specific arguments\n    local_variable._0_1_ = 1; // Set the first byte of local_c to 1\n    undefined_pointer_3 = (undefined4 *)*data_table; // Set puStack_494 to a value from a data table\n    while (undefined_pointer_2 != data_table) { // Loop until puVar8 equals a specific value\n        unsigned_int_2 = unsigned_stack_2; // Store uStack_178 in uVar3\n        int_pointer_pointer_pointer = int_pointer_pointer_array[0]; // Get the first element of apppiStack_188\n        if (unsigned_stack_1 < 0x10) { // Check if uStack_174 is less than 16\n            int_pointer_pointer_pointer = (int ***)int_pointer_pointer_array; // Set pppiVar10 to apppiStack_188\n        }\n        unsigned_int_1 = undefined_pointer_2[9]; // Get the 10th element from puVar8\n        unsigned_int_3 = unsigned_int_1; // Set uVar9 to uVar2\n        if (unsigned_stack_2 <= unsigned_int_1) { // Check if uStack_178 is less than or equal to uVar2\n            unsigned_int_3 = unsigned_stack_2; // Set uVar9 to uStack_178\n        }\n        int_pointer = (uint)undefined_pointer_2[10] < 0x10 ? undefined_pointer_2 + 5 : (int *)undefined_pointer_2[5]; // Conditional assignment based on the 11th element\n        int_variable = FUN_10001710(int_pointer, (int *)int_pointer_pointer_pointer, unsigned_int_3); // Call a function with specific arguments\n        if (((int_variable == 0) && (unsigned_int_2 <= unsigned_int_1)) && (unsigned_int_1 == unsigned_int_2)) { // Check conditions\n            FUN_10005900(array_stack_2, undefined_pointer_2 + 0xc); // Call a function with specific arguments\n            unaff_base_pointer = 0x1000000; // Set unaff_EBP to a specific value\n        }\n        FUN_10001e90((int *)&stack_variable); // Call another function\n        undefined_pointer_2 = (undefined4 *)*data_table; // Update puVar8\n    }\n    if ((char)((uint)unaff_base_pointer >> 0x18) == '\\0') { // Check if the upper byte of unaff_EBP is zero\n        puStack_490 = array_stack_3; // Set puStack_490 to auStack_608\n        FUN_100047f0(array_stack_3, array_stack_2); // Call a function with specific arguments\n        local_variable._0_1_ = 2; // Set the first byte of local_c to 2\n        void_pointer = (void *)(input_stack & 0xffffff00); // Mask in_stack_fffff9e0\n        FUN_10003db0(&stack0xfffff9dc, array_stack_1, 0, 0xffffffff); // Call a function with specific arguments\n        local_variable._0_1_ = 1; // Set the first byte of local_c to 1\n        void_pointer = FUN_10005d60(array_stack_4, in_stack_fffff9dc, void_pointer); // Call a function and update pvVar7\n        local_variable._0_1_ = 4; // Set the first byte of local_c to 4\n        FUN_10004da0(array_stack_5, void_pointer); // Call a function with specific arguments\n        local_variable._0_1_ = 5; // Set the first byte of local_c to 5\n        FUN_10007ae0(&DAT_10035a4c, array_pointer_stack, array_stack_5); // Call a function with specific arguments\n        local_variable._0_1_ = 4; // Set the first byte of local_c to 4\n        FUN_10003aa0((int)array_stack_5); // Call a function with specific arguments\n        local_variable._0_1_ = 1; // Set the first byte of local_c to 1\n        FUN_10003a20((int)array_stack_4); // Call a function with specific arguments\n    }\n    undefined_pointer_3 = (undefined4 *)*data_table; // Update puStack_494\n    while (undefined_pointer_3 != data_table) { // Loop until puStack_494 equals a specific value\n        unsigned_int_2 = unsigned_stack_2; // Store uStack_178 in uVar3\n        int_pointer_pointer_pointer = int_pointer_pointer_array[0]; // Get the first element of apppiStack_188\n        if (unsigned_stack_1 < 0x10) { // Check if uStack_174 is less than 16\n            int_pointer_pointer_pointer = (int ***)int_pointer_pointer_array; // Set pppiVar10 to apppiStack_188\n        }\n        unsigned_int_1 = undefined_pointer_3[9]; // Get the 10th element from puStack_494\n        unsigned_int_3 = unsigned_int_1; // Set uVar9 to uVar2\n        if (unsigned_stack_2 <= unsigned_int_1) { // Check if uStack_178 is less than or equal to uVar2\n            unsigned_int_3 = unsigned_stack_2; // Set uVar9 to uStack_178\n        }\n        int_pointer = (uint)undefined_pointer_3[10] < 0x10 ? undefined_pointer_3 + 5 : (int *)undefined_pointer_3[5]; // Conditional assignment based on the 11th element\n        int_variable = FUN_10001710(int_pointer, (int *)int_pointer_pointer_pointer, unsigned_int_3); // Call a function with specific arguments\n        if (((int_variable == 0) && (unsigned_int_2 <= unsigned_int_1)) && (unsigned_int_1 == unsigned_int_2)) { // Check conditions\n            local_variable._0_1_ = 0; // Set the first byte of local_c to 0\n            if (0xf < unsigned_stack_1) { // Check if uStack_174 is greater than 15\n                _free(int_pointer_pointer_array[0]); // Free memory allocated for apppiStack_188[0]\n            }\n            unsigned_stack_1 = 0xf; // Reset uStack_174 to 15\n            unsigned_stack_2 = 0; // Reset uStack_178 to 0\n            int_pointer_pointer_array[0] = (int ***)((uint)int_pointer_pointer_array[0] & 0xffffff00); // Mask apppiStack_188[0]\n            local_variable = (void *)0xffffffff; // Set local_c to -1\n            FUN_10003810((int)array_stack_2); // Call a function with specific arguments\n            break; // Exit the loop\n        }\n        FUN_10001e90((int *)&stack_variable); // Call another function\n    }\n    ExceptionList = previous_stack_pointer; // Restore the exception list\n    ___security_check_cookie_4(uStack_18 ^ (uint)&stack0xfffffb64); // Perform a security check\n}\n"}
{"Function Name": "FUN_10008340", "Address": "10008340", "Source Code": "\nvoid FUN_10008340(int *param_1)\n{\n    bool isSuccess; // Variable to store boolean result\n    char *charPointer; // Pointer for character data\n    uint resultCode; // Variable to store unsigned integer result\n    void *dataPointer; // Pointer for void data\n    int operationResult; // Variable to store integer result\n    uint xorResult; // Local variable for XOR operation\n    undefined buffer1[28]; // Local buffer for data\n    undefined buffer2[20]; // Local buffer for data\n    int integerData; // Local variable for integer data\n    undefined buffer3[4]; // Local buffer for data\n    undefined4 undefinedData; // Local variable for undefined data\n    uint xorCookie; // Local variable for unsigned integer\n\n    undefinedData = 0; // Initialize local_2c to 0\n    xorResult = securityKey ^ (uint)buffer1; // XOR operation for security\n    xorCookie = xorResult; // Store result of XOR in local_8\n    processInput(param_1); // Call function with param_1\n    handleData(inputData, (void *)(local_90 + 0x11c)); // Call function with local_24 and pointer\n    isSuccess = checkCondition(inputData, (int *)&PTR_1002bc68); // Call function and store boolean result\n    if (isSuccess) { // Check if bVar1 is true\n        processBuffer(buffer2, \",\"); // Call function to process local_5c with delimiter\n        maxValue = 0xf; // Set local_28 to 15\n        status._0_1_ = 3; // Set first byte of local_7c to 3\n        charPointer = (char *)getCharPointer(param_1); // Get character pointer from param_1\n        processBuffer(buffer1, charPointer); // Call function to process local_78 with pcVar2\n        status._0_1_ = 4; // Set first byte of local_7c to 4\n        while (true) { // Infinite loop\n            resultCode = executeOperation(inputData, (int)buffer2, (undefined4 *)0x0); // Call function and store result\n            if (resultCode == 0xffffffff) { // Check for error condition\n                handleError(buffer3, inputData, 0, 0xffffffff); // Handle error case\n            } else {\n                dataPointer = allocateMemory(inputData, tempData, 0, resultCode); // Call function and store pointer\n                handleError(buffer3, dataPointer, 0, 0xffffffff); // Process data with function\n                cleanupResources((int)tempData); // Call cleanup function\n            }\n            operationResult = executeOperation(buffer1, (int)buffer3, (undefined4 *)0x0); // Call function and store result\n            if (operationResult != -1) break; // Exit loop if result is valid\n            if (resultCode == 0xffffffff) goto LAB_10008464; // Jump to error handling if needed\n            updateParameters(inputData, (undefined4 *)0x0, integerData + resultCode); // Call function with updated parameters\n        }\n        isProcessed = 1; // Set local_89 to 1 indicating success\nLAB_10008464: // Label for error handling\n        cleanupResources((int)buffer1); // Cleanup local_78\n        cleanupResources((int)buffer3); // Cleanup local_40\n        cleanupResources((int)buffer2); // Cleanup local_5c\n    }\n    status = (uint)status._1_3_ << 8; // Shift local_7c value\n    cleanupResources((int)inputData); // Cleanup local_24\n    exceptionList = local_84; // Restore exception list\n    securityCheck(xorCookie ^ (uint)buffer1); // Security check with cookie\n    return; // Exit function\n}\n"}
{"Function Name": "Catch@100084d4", "Address": "100084d4", "Source Code": "\nundefined4 catch_function(void) // Function definition for Catch_100084d4\n{\n    // Call FUN_10004160 with a pointer to a specific memory location and a pointer to DAT_1002bfbc\n    function_call((void *)(*(int *)(base_pointer + -0x18) + 0x94), (undefined4 *)&data_pointer);\n    \n    // Return a specific value (0x1000849b)\n    return 0x1000849b;\n}\n"}
{"Function Name": "FUN_100084f0", "Address": "100084f0", "Source Code": "\nint * __thiscall FUN_100084f0(void *object,int input_param_1,byte input_param_2,int input_param_3)\n{\n    void *temp_pointer; // Pointer to hold a temporary reference\n    undefined *local_stack_pointer; // Stack pointer for local storage\n    local_stack_pointer = &LAB_10028062; // Assigning a label address to the stack pointer\n    void *exception_list_backup = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &exception_list_backup; // Set ExceptionList to point to local_c\n\n    if (input_param_3 != 0) { // Check if param_3 is not zero\n        *(undefined **)object = &DAT_1002bfd4; // Set a value in the 'this' object\n        FUN_10001c10((undefined4 *)((int)object + 0x50)); // Call a function with a specific offset\n    }\n    \n    // Set the vtable pointer for the 'this' object to a specific vtable\n    *(undefined ***)((int)object + *(int *)(*object + 4)) =\n    std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n    \n    *(undefined4 *)((int)object + 4) = 0; // Initialize a member variable to zero\n    temp_pointer = (void *)(*(int *)(*object + 4) + (int)object); // Calculate a new pointer based on 'this'\n    FUN_100055e0(temp_pointer); // Call a function with the new pointer\n    *(void **)((int)temp_pointer + 0x28) = (void *)((int)object + 8); // Set a member variable in this_00\n    *(undefined4 *)((int)temp_pointer + 0x2c) = 0; // Initialize another member variable to zero\n    *(undefined *)((int)temp_pointer + 0x30) = FUN_10006d90(temp_pointer,0x20); // Call a function and store the result\n\n    if (*(int *)((int)temp_pointer + 0x28) == 0) { // Check if a member variable is zero\n        FUN_10005480(temp_pointer,*(uint *)((int)temp_pointer + 8) | 4,'\\0'); // Call a function with specific parameters\n    }\n    \n    *(undefined4 *)((int)temp_pointer + 4) = 0; // Reset another member variable to zero\n    // Set the vtable pointer for the 'this' object to a different vtable\n    *(undefined ***)((int)object + *(int *)(*object + 4)) =\n    std::basic_istringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n    \n    FUN_100034f0((void *)((int)object + 8),input_param_1,input_param_2 | 1); // Call a function with parameters\n    ExceptionList = exception_list_backup; // Restore the original ExceptionList\n    return (int *)object; // Return the 'this' pointer as an integer pointer\n}\n"}
{"Function Name": "FUN_100085e0", "Address": "100085e0", "Source Code": "\nvoid FUN_100085e0(int *inputPointer) // Function definition with an integer pointer parameter\n{\n    void *voidPointer; // Declare a pointer to void\n    uint stackVariable; // Declare a variable for stack usage\n    exceptionList = &exceptionList; // Initialize ExceptionList to point to itself\n    stackVariable = dataValue ^ (uint)&stackBase; // Perform a bitwise XOR operation for stack protection\n    voidPointer = (void *)functionCall(inputPointer); // Call FUN_10007f30 with param_1 and store the result in pvVar2\n    if (!checkFunction(inputPointer) && ((bool)*(char *)((int)voidPointer + 0x118) != 0)) { // Check conditions based on FUN_10005720 and a value at offset 0x118\n        if ((bool)*(char *)((int)voidPointer + 0x108) != 0) { // Check if the value at offset 0x108 is non-zero\n            return; // Exit the function if the condition is met\n        }\n        if (timeDifference(currentTime(NULL), *(__time64_t *)((int)voidPointer + 0x110)) <= timeThreshold) { // Compare current time with a value at offset 0x110\n            return; // Exit the function if the time difference is within the limit\n        }\n    }\n    finalFunction(inputPointer, voidPointer); // Call FUN_10006050 with param_1 and pvVar2\n}\n"}
{"Function Name": "FUN_100086b0", "Address": "100086b0", "Source Code": "\nvoid FUN_100086b0(int *input_param) // Function definition with parameter param_1\n{\n    int *int_pointer; // Pointer to an integer variable\n    int return_value; // Integer variable for storing return value\n    void *temp_pointer; // Pointer for temporary storage\n    undefined4 ***pointer_to_pointer_to_pointer; // Pointer to a pointer to a pointer of undefined4\n    char *stack_char_pointer; // Pointer to a character for stack storage\n    undefined4 stack_var_4c; // Undefined4 variable for stack storage\n    uint stack_var_40; // Unsigned integer for stack storage\n    uint stack_var_3c; // Unsigned integer for stack storage\n    void *stack_pointer_50; // Pointer for stack storage\n    uint stack_var_58; // Unsigned integer for stack storage\n    uint stack_var_74; // Unsigned integer for stack storage\n    uint stack_var_98; // Unsigned integer for stack storage\n    uint stack_var_b4; // Unsigned integer for stack storage\n    uint stack_var_b8; // Unsigned integer for stack storage\n    uint stack_var_9c; // Unsigned integer for stack storage\n    uint local_var_10; // Local unsigned integer variable\n    void *local_pointer; // Local pointer variable\n    local_pointer = ExceptionList; // Store current ExceptionList\n    local_var_10 = DAT_100345e0 ^ 0xffffffff; // XOR operation for local variable\n    ExceptionList = &local_pointer; // Update ExceptionList to point to local_c\n    int_pointer = (int *)(**(code **)(*input_param + 0x10))(); // Call function pointer from param_1\n    stack_var_40 = 0; // Initialize uStack_40\n    stack_var_3c = 0xf; // Initialize uStack_3c\n    stack_var_58 = 0xf; // Initialize uStack_58\n    stack_var_74 = 0xf; // Initialize uStack_74\n    stack_var_98 = 0xf; // Initialize uStack_98\n    stack_var_b4 = 0xf; // Initialize uStack_b4\n    stack_var_b8 = 0; // Initialize uStack_b8\n    stack_var_9c = 0; // Initialize uStack_9c\n    return_value = FUN_10007f30(input_param); // Call function and store result in iVar3\n    temp_pointer = FUN_10005c80(&stack_var_4c, &stack_var_2c, (undefined4 *)\"configUrl : \"); // Create configUrl string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value); // Process the string with additional parameters\n    stack_char_pointer = (*(char *)(return_value + 0x1c) == '\\0') ? \"false\" : &DAT_1002c140; // Check condition for pcStack_94\n    temp_pointer = FUN_10005c80(array_stack_b0, temp_pointer, (undefined4 *)stack_char_pointer); // Append pcStack_94 to pvVar4\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    stack_char_pointer = (*(char *)(return_value + 0x1d) == '\\0') ? \"false\" : &DAT_1002c140; // Check condition for pcStack_94\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"proxy : \"); // Create proxy string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, (int)stack_char_pointer); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    stack_char_pointer = (*(char *)(return_value + 0x1e) == '\\0') ? \"false\" : &DAT_1002c140; // Check condition for pcStack_94\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"folderLink : \"); // Create folderLink string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, (int)stack_char_pointer); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    stack_char_pointer = (*(char *)(return_value + 0x1f) == '\\0') ? \"false\" : &DAT_1002c140; // Check condition for pcStack_94\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"localLink : \"); // Create localLink string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, (int)stack_char_pointer); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"redirectUrl : \"); // Create redirectUrl string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x20); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"proxyFolder : \"); // Create proxyFolder string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x3c); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"folderLinkPath : \"); // Create folderLinkPath string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x58); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"folderLinkCount : \"); // Create folderLinkCount string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, *(undefined4 *)(return_value + 0x74)); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"folderLinks : \"); // Create folderLinks string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x78); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"proxyUrl : \"); // Create proxyUrl string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0xb0); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"localLinkExt : \"); // Create localLinkExt string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0xcc); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"localLinkCount : \"); // Create localLinkCount string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, *(undefined4 *)(return_value + 0xe8)); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"localLinkFolder : \"); // Create localLinkFolder string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0xec); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"loadSuccessfull : \"); // Create loadSuccessfull string\n    temp_pointer = FUN_10005c80(array_stack_b0, temp_pointer, (*(char *)(return_value + 0x108) == '\\0') ? \"false\" : &DAT_1002c140); // Append success status\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"loadConfigMessage : \"); // Create loadConfigMessage string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x94); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"banIP : \"); // Create banIP string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x11c); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"proxyMode : \"); // Create proxyMode string\n    temp_pointer = FUN_10004bf0(array_stack_b0, temp_pointer, return_value + 0x138); // Process the string with additional parameters\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"redirectReferer : \"); // Create redirectReferer string\n    temp_pointer = FUN_10005c80(array_stack_b0, temp_pointer, (*(char *)(return_value + 0x154) == '\\0') ? \"false\" : &DAT_1002c140); // Append referer status\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    temp_pointer = FUN_10005c80(array_stack_b0, &stack_var_2c, (undefined4 *)\"onlyMobileSpider : \"); // Create onlyMobileSpider string\n    temp_pointer = FUN_10005c80(array_stack_b0, temp_pointer, (*(char *)(return_value + 0x155) == '\\0') ? \"false\" : &DAT_1002c140); // Append spider status\n    FUN_10003db0(&stack_var_2c, temp_pointer, 0, 0xffffffff); // Call function to handle uStack_2c\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    int_pointer = (int *)(**(code **)(*input_param + 0x10))(); // Call function pointer from param_1 again\n    stack_var_98 = 0xf; // Initialize uStack_98\n    stack_var_9c = 0; // Initialize uStack_9c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    pointer_to_pointer_to_pointer = apppuStack_28[0]; // Assign pointer from apppuStack_28\n    if (stack_var_14 < 0x10) { // Check if uStack_14 is less than 0x10\n        pointer_to_pointer_to_pointer = apppuStack_28; // Assign apppuStack_28 to pppuVar5\n    }\n    stack_var_4c = 0; // Initialize uStack_4c\n    do { // Loop to find the end of a string\n        char_var = *(char *)pointer_to_pointer_to_pointer; // Get character from pppuVar5\n        pointer_to_pointer_to_pointer = (undefined4 ***)((int)pointer_to_pointer_to_pointer + 1); // Move to the next character\n    } while (char_var != '\\0'); // Continue until null terminator is found\n    stack_var_40 = (int)pointer_to_pointer_to_pointer - (int)((int)pointer_to_pointer_stack_44 + 1) & 0xffff; // Calculate length of the string\n    (**(code **)(*int_pointer + 0x10))(); // Call another function from piVar2\n    (**(code **)(*int_pointer + 0x54))(&stack_var_5c, 1, 0, 1, auStack_60); // Call function with parameters\n    stack_var_2c = 0xffffffff; // Set uStack_2c to -1\n    if (stack_var_3c > 0xf) { // Check if uStack_3c exceeds 0xf\n        _free(stack_pointer_50); // Free allocated memory\n    }\n    stack_var_3c = 0xf; // Reset uStack_3c\n    stack_pointer_50 = (void *)((uint)stack_pointer_50 & 0xffffff00); // Mask pvStack_50\n    ExceptionList = previous_stack_pointer; // Restore ExceptionList to previous value\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10009a60", "Address": "10009a60", "Source Code": "\nvoid FUN_10009a60(int *param_1)\n{\n    int resultFromFunctionCall; // Variable to store the result of a function call\n    int *intPointer; // Pointer to an integer, used for function calls\n    char *charPointer; // Pointer to a character, used for string manipulation\n    int resultFromStringSearch; // Variable to store the result of string search\n    undefined4 ***pointerToPointerToPointer; // Pointer to a pointer to a pointer, used for location storage\n    uint stackValue; // Variable to store a stack value\n    undefined localBufferData[28]; // Local buffer for storing data\n    undefined localBufferUserAgent[28]; // Local buffer for storing User-Agent data\n    undefined localBufferTempStorage[4]; // Local buffer for temporary storage\n    undefined4 ***arrayOfPointers[5]; // Array of pointers for storing locations\n    uint securityCheckValue; // Variable to store a value for security check\n    void *previousExceptionList; // Pointer to store the previous ExceptionList\n\n    previousExceptionList = ExceptionList; // Save the current ExceptionList\n    stackValue = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Calculate a stack value\n    ExceptionList = &previousExceptionList; // Update ExceptionList to point to local_10\n    securityCheckValue = stackValue; // Store the stack value for later use\n    resultFromFunctionCall = FUN_10007f30(param_1); // Call a function and store the result\n    FUN_100085e0(param_1); // Call another function with param_1\n\n    // Check if the conditions for processing are met\n    if (!FUN_10005810(param_1) && !FUN_10005720(param_1)) {\n        if ((bool)*(char *)(resultFromFunctionCall + 0x1c) != 0) { // Check a specific condition\n            if (FUN_10003590((void *)(resultFromFunctionCall + 0x20), (int *)&PTR_1002bc68)) { // Validate User-Agent\n                intPointer = (int *)(**(code **)(*param_1 + 0xc))(); // Call a function to get a pointer\n                charPointer = (char *)(**(code **)(*intPointer + 0xc))(\"User-Agent\", 0); // Get User-Agent string\n                FUN_10004a20(localBufferUserAgent, charPointer); // Store User-Agent in local_50\n                resultFromStringSearch = FUN_10002b80(localBufferUserAgent, (int *)\"spider\", (undefined4 *)0x0); // Search for \"spider\"\n                \n                // Check if \"spider\" was not found\n                if (resultFromStringSearch == -1) {\n                    resultFromStringSearch = FUN_10002b80(localBufferUserAgent, (int *)&DAT_1002c1a4, (undefined4 *)0x0); // Search for another term\n                    if (resultFromStringSearch == -1) { // If not found\n                        FUN_100033d0((int)localBufferUserAgent); // Clean up local_50\n                        return; // Exit the function\n                    }\n                }\n                resultFromStringSearch = (**(code **)(*intPointer + 4))(); // Call another function\n                charPointer = *(char **)(resultFromStringSearch + 0x30); // Get a specific value from the result\n                intPointer = (int *)(**(code **)(*param_1 + 0x10))(); // Call another function to get a pointer\n                resultFromStringSearch = FUN_10004a20(localBufferData, charPointer); // Store the value in local_70\n                FUN_10004bf0(localBufferTempStorage, (void *)(resultFromFunctionCall + 0x20), resultFromStringSearch); // Process the data\n                \n                // Check if local_1c is less than 16\n                if (local_1c < 0x10) {\n                    arrayOfPointers[0] = arrayOfPointers; // Initialize local_30\n                }\n                pointerToPointerToPointer = arrayOfPointers[0]; // Point to the first element of local_30\n                while (*(char *)pointerToPointerToPointer != '\\0') { // Loop until a null character is found\n                    pointerToPointerToPointer = (undefined4 ***)((int)pointerToPointerToPointer + 1); // Move to the next element\n                }\n                // Call a function to set the Location header\n                (**(code **)(*intPointer + 0x14))(\"Location\", arrayOfPointers[0], (int)pointerToPointerToPointer - (int)((int)arrayOfPointers[0] + 1), 1);\n                // Call a function to send a response\n                (**(code **)(*intPointer + 0xc))(0x12d, \"Moved Permanently\", 0, 0, 0, 0);\n                FUN_100033d0((int)localBufferTempStorage); // Clean up local_34\n                FUN_100033d0((int)localBufferUserAgent); // Clean up local_50\n                return; // Exit the function\n            }\n        }\n    }\n    FUN_100086b0(param_1); // Call a function for cleanup\n    ExceptionList = previousExceptionList; // Restore the previous ExceptionList\n    ___security_check_cookie_4(securityCheckValue ^ (uint)&stack0xfffffffc); // Perform a security check\n}\n"}
{"Function Name": "Catch@10009c2c", "Address": "10009c2c", "Source Code": "\nundefined4 Catch_10009c2c(void)\n{\n    // Call FUN_10004160 with a pointer to a specific memory location and an error message\n    call_function((void *)(*(int *)(base_pointer + -0x50) + 0x94),\n                 (undefined4 *)\"Unhandled exception in OnBeginRequest\");\n    \n    // Return a specific constant value\n    return 0x10009b4a;\n}\n"}
{"Function Name": "FUN_10009cd0", "Address": "10009cd0", "Source Code": "\nvoid __fastcall FUN_10009cd0(void *input_param) // Function definition with fastcall calling convention\n{\n    void *prev_exception_list; // Local variable to store the previous ExceptionList\n    undefined *label_pointer; // Stack variable for storing a pointer to a label\n    undefined4 status_flag; // Local variable initialized to 0xffffffff\n    label_pointer = &LAB_100283b8; // Assign address of a label to puStack_8\n    prev_exception_list = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &prev_exception_list; // Set ExceptionList to point to local_c\n    status_flag = 0xffffffff; // Initialize local_4 to -1 (0xffffffff)\n\n    // Call FUN_10007c20 with various parameters including param_1 and dereferenced values\n    FUN_10007c20(input_param, &input_param, input_param, (int **)**(int ***)((int)input_param + 4), input_param,\n                 *(int ***)((int)input_param + 4));\n\n    // Free the memory pointed to by the pointer at offset 4 from param_1\n    _free(*(void **)((int)input_param + 4));\n\n    // Set the values at offsets 4 and 8 from param_1 to 0\n    *(undefined4 *)((int)input_param + 4) = 0; \n    *(undefined4 *)((int)input_param + 8) = 0;\n\n    ExceptionList = prev_exception_list; // Restore the previous ExceptionList\n    return; // Return from the function\n}\n"}
{"Function Name": "FUN_10009d40", "Address": "10009d40", "Source Code": "\nvoid __fastcall FUN_10009d40(void *input_param) // Function definition with fastcall calling convention\n{\n    void *previous_exception_list; // Local variable to store the previous ExceptionList\n    undefined *unused_stack_pointer; // Stack variable for storing a pointer (not used in this snippet)\n    unused_stack_pointer = &LAB_100283e8; // Assigning the address of LAB_100283e8 to puStack_8\n    previous_exception_list = exception_list_pointer; // Save the current ExceptionList\n    exception_list_pointer = &previous_exception_list; // Update ExceptionList to point to local_c\n    FUN_10007cf0(input_param, &input_param, input_param, (int **)**(int ***)((int)input_param + 4), input_param, // Call to FUN_10007cf0 with various parameters\n                  *(int ***)((int)input_param + 4)); // Passing a dereferenced pointer from param_1\n    _free(*(void **)((int)input_param + 4)); // Free the memory pointed to by the pointer at offset 4 of param_1\n    *(undefined4 *)((int)input_param + 4) = 0; // Set the pointer at offset 4 of param_1 to NULL\n    *(undefined4 *)((int)input_param + 8) = 0; // Set the pointer at offset 8 of param_1 to NULL\n    exception_list_pointer = previous_exception_list; // Restore the previous ExceptionList\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10009ef0", "Address": "10009ef0", "Source Code": "\nvoid __thiscall FUN_10009ef0(void *this, int param_1, int *param_2) // Function declaration with thiscall calling convention\n{\n    char charValue; // Variable to hold a character value\n    undefined4 *undefinedPtr; // Pointer to an undefined 4-byte type\n    tm *timeStructPtr; // Pointer to a tm structure (time structure)\n    int *intPtr; // Pointer to an integer\n    int *******multiLevelIntPtr; // Pointer to a pointer to a pointer to a pointer to a pointer to a pointer to a pointer to an integer\n    void *voidPtr; // Pointer to a void type\n    int intValue; // Variable to hold an integer value\n    uint unsignedIntValue1; // Variable to hold an unsigned integer\n    uint unsignedIntValue2; // Variable to hold another unsigned integer\n    uint *unsignedIntPtr; // Pointer to an unsigned integer\n    __time64_t time64Value; // Variable to hold a 64-bit time value\n    char *stackCharPtr; // Pointer to a character on the stack\n    undefined *stackUndefinedPtr; // Pointer to an undefined type on the stack\n    undefined undefinedArray[3]; // Array of 3 undefined bytes on the stack\n    int localIntValue; // Local integer variable\n    void *localVoidPtr; // Local pointer to void\n    undefined4 stackUndefinedValue; // Stack variable of undefined 4-byte type\n    uint stackUnsignedIntValue1; // Stack variable for unsigned integer\n    uint stackUnsignedIntValue2; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue3; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue4; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue5; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue6; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue7; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue8; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue9; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue10; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue11; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue12; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue13; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue14; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue15; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue16; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue17; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue18; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue19; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue20; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue21; // Stack variable for another unsigned integer\n    uint stackUnsignedIntValue22; // Stack variable for another unsigned integer\n    // Additional stack variables (uStack_2d0 repeated multiple times)\n    // ...\n}\n"}
{"Function Name": "FUN_1000b190", "Address": "1000b190", "Source Code": "\nvoid FUN_1000b190(int *request_params)\n{\n    int *int_pointer_1; // Pointer to an integer variable\n    undefined4 *header_pointer; // Pointer to an undefined 4-byte variable\n    int return_value_1; // Integer variable for storing a return value\n    uint return_value_2; // Unsigned integer variable for storing a return value\n    int *int_pointer_2; // Pointer to an integer variable\n    int return_value_3; // Integer variable for storing a return value\n    void *void_pointer; // Pointer to a void variable\n    undefined4 curl_handle; // Undefined 4-byte variable\n    undefined4 ***local_pointer_array_1[4]; // Local array of pointers to pointers\n    undefined4 local_value_1; // Local variable for storing an undefined 4-byte value\n    uint local_value_2; // Local unsigned integer variable\n    uint local_value_3; // Local unsigned integer variable\n    undefined4 ***local_pointer_array_2[5]; // Local array of pointers to pointers\n    uint local_value_4; // Local unsigned integer variable\n\n    local_value_1 = 0xffffffff; // Initialize local_15c to maximum unsigned value\n    local_pointer_array_1[0] = (undefined4 ***)((uint)local_pointer_array_1[0] & 0xffffff00); // Clear lower byte of local_20[0]\n    int_pointer_1 = (int *)(**(code **)(*request_params + 0xc))(); // Call a function and store the result in piVar5\n    header_pointer = (undefined4 *)(**(code **)(*int_pointer_1 + 0xc))(\"User-Agent\", 0); // Get User-Agent header\n    local_value_2 = 0xf; // Initialize local_c\n    do {\n        header_pointer++; // Increment pointer to puVar6\n    } while (*(char *)header_pointer != '\\0'); // Loop until null terminator is found\n    FUN_10003e90(user_agent_buffer, header_pointer, (int)header_pointer - ((int)header_pointer + 1)); // Call function with parameters\n    local_value_1 = 0; // Reset local_15c\n    header_pointer = (undefined4 *)(**(code **)(*int_pointer_1 + 0xc))(\"Referer\", 0); // Get Referer header\n    if (header_pointer != (undefined4 *)0x0) { // Check if puVar6 is not null\n        local_value_2 = 0xf; // Reset local_c\n        local_pointer_array_1[0] = (undefined4 ***)((uint)local_pointer_array_1[0] & 0xffffff00); // Clear lower byte of local_20[0]\n        do {\n            header_pointer++; // Increment pointer to puVar6\n        } while (*(char *)header_pointer != '\\0'); // Loop until null terminator is found\n        FUN_10003e90(referer_buffer, header_pointer, (int)header_pointer - ((int)header_pointer + 1)); // Call function with parameters\n        FUN_10003db0(referer_length, referer_buffer, 0, 0xffffffff); // Call function with parameters\n        if (0xf < local_value_2) { // Check if local_c is greater than 15\n            _free(local_pointer_array_1[0]); // Free allocated memory for local_20[0]\n        }\n    }\n    header_pointer = FUN_100025a0(user_agent_buffer, (int *)\"spider\", (undefined4 *)0x0, 6); // Check for \"spider\"\n    if ((((header_pointer != (undefined4 *)0xffffffff) || // Check if puVar6 is not an error value\n        (header_pointer = FUN_100025a0(user_agent_buffer, (int *)&DAT_1002c1a4, (undefined4 *)0x0, 3),\n        header_pointer != (undefined4 *)0xffffffff)) || // Check for another condition\n        (header_pointer = FUN_100025a0(referer_length, (int *)\"baidu.com/\", (undefined4 *)0x0, 10),\n        header_pointer != (undefined4 *)0xffffffff)) && // Check for another condition\n        (int_pointer_1 = (int *)(**(code **)(*request_params + 0x10))(), int_pointer_1 != (int *)0x0)) { // Get another pointer\n        (**(code **)(*int_pointer_1 + 0x5c))(data_buffer_1, data_buffer_2, data_buffer_3, data_buffer_4, data_buffer_5, data_buffer_6, data_buffer_7, 0, 0); // Call function with parameters\n        return_value_1 = FUN_10007f30(request_params); // Call function and store result in iVar7\n        return_value_2 = FUN_10002660((void *)(return_value_1 + 0x138), 0, *(uint *)(return_value_1 + 0x14c), (int *)&DAT_1002c270, 3); // Call function and store result in uVar8\n        if (((return_value_2 == 0) || (data_buffer_1[0] == 0x194)) && (FUN_10008340(request_params) == '\\0')) { // Check conditions\n            local_value_1._0_1_ = 3; // Set part of local_15c\n            if (*(char *)(return_value_1 + 0x1d) != '\\0') { // Check if a specific character is not null\n                int_pointer_2 = (int *)(**(code **)(*request_params + 0xc))(); // Call function and store result in piVar9\n                return_value_3 = (**(code **)(*int_pointer_2 + 4))(); // Call another function and store result in iVar10\n                FUN_10004a20(local_buffer_1, *(char **)(return_value_3 + 0x30)); // Call function with parameters\n                local_value_1._0_1_ = 4; // Set part of local_15c\n                FUN_10004040(local_buffer_2, (void *)(return_value_1 + 0x3c)); // Call function with parameters\n                local_value_1._0_1_ = 5; // Set part of local_15c\n                FUN_10004a20(local_buffer_3, \",\"); // Call function with parameters\n                local_value_1._0_1_ = 6; // Set part of local_15c\n                FUN_10004040(local_buffer_4, (void *)(return_value_1 + 0xb0)); // Call function with parameters\n                local_value_5 = 0xf; // Initialize local_b4\n                local_value_6 = 0; // Initialize local_b8\n                local_value_1._0_1_ = 8; // Set part of local_15c\n                if (FUN_10003590(local_buffer_1, (int *)&DAT_1002c26c)) { // Check condition\n                    FUN_10004cc0(local_b0, (undefined4 *)\"User-Agent: \", (int)user_agent_buffer); // Call function with parameters\n                    local_value_1._0_1_ = 9; // Set part of local_15c\n                    FUN_10004a20(local_78, (char *)&PTR_1002bc68); // Call function with parameters\n                    if (local_pointer_3 != (undefined4 *)0x0) { // Check if local_170 is not null\n                        void_pointer = FUN_10004cc0(local_buffer_5, (undefined4 *)\"Referer: \", (int)referer_length); // Call function with parameters\n                        FUN_10003db0(local_78, void_pointer, 0, 0xffffffff); // Call function with parameters\n                    }\n                    FUN_10001b20(*(char **)(return_value_3 + 0x30)); // Call function with parameters\n                    void_pointer = FUN_10005c80(local_buffer_5, local_buffer_4, (undefined4 *)&DAT_1002c24c); // Call function and store result in pvVar11\n                    FUN_10004bf0(local_buffer_6, void_pointer, (int)local_value_7); // Call function with parameters\n                    FUN_100033d0((int)local_buffer_5); // Call function with parameters\n                    curl_handle = curl_easy_init(); // Initialize CURL and store handle in uVar12\n                    local_value_2 = 0xf; // Reset local_c\n                    local_pointer_array_1[0] = (undefined4 ***)((uint)local_pointer_array_1[0] & 0xffffff00); // Clear lower byte of local_20[0]\n                    curl_easy_setopt(curl_handle, 0x2734, &DAT_1002bf6c); // Set CURL option\n                    if (local_value_4 < 0x10) { // Check if local_7c is less than 16\n                        local_pointer_array_2[0] = local_pointer_array_2; // Assign local_90[0] to itself\n                    }\n                    curl_easy_setopt(curl_handle, 0x2712, local_pointer_array_2[0]); // Set another CURL option\n                    curl_slist_append(0, \"accept: text/html,*\"); // Append to CURL list\n                }\n            }\n        }\n    }\n}\n"}
{"Function Name": "FUN_1000bc00", "Address": "1000bc00", "Source Code": "\nvoid __fastcall FUN_1000bc00(undefined4 *input_pointer) // Function definition with fastcall calling convention\n{\n    if (*(undefined4 **)input_pointer != &specific_address) { // Check if the pointer at param_1 is not equal to a specific address\n        free_memory(*(undefined4 **)input_pointer); // Free the memory pointed to by the pointer at param_1\n    }\n}\n"}
{"Function Name": "FUN_1000be00", "Address": "1000be00", "Source Code": "\nvoid __thiscall FUN_1000be00(void *object, char *input_string)\n{\n    char *current_char = input_string; // Initialize pointer to the start of param_1\n    while (*current_char != '\\0') { // Loop until the end of the string is reached\n        current_char++; // Move the pointer to the next character\n    }\n    // Call FUN_1000bcc0 with 'this', the original string, and the length of the string\n    FUN_1000bcc0(object, input_string, (int)current_char - (int)(input_string)); \n}\n"}
{"Function Name": "FUN_1000be30", "Address": "1000be30", "Source Code": "\nvoid __fastcall FUN_1000be30(undefined4 *vftable_pointer) // Function definition with fastcall calling convention\n{\n    *vftable_pointer = TiXmlBase::vftable; // Assign the vftable of TiXmlBase to the location pointed by param_1\n}\n"}
{"Function Name": "FUN_1000be40", "Address": "1000be40", "Source Code": "\\*\nundefined4 * method FUN_1000be40(void *object, byte flag)\n{\n    // Set the virtual function table pointer for the object\n    *(undefined ***)object = TiXmlBase::vftable;\n\n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for the object if the condition is true\n        _free(object);\n    }\n\n    // Return the pointer to the object\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * method FUN_1000be40(void *object, byte flag)\n{\n    *(undefined ***)object = TiXmlBase::vftable;\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_1000c0a0", "Address": "1000c0a0", "Source Code": "\nvoid __thiscall FUN_1000c0a0(void *object, int destination)\n{\n    char *stringPointer; // Pointer to traverse a character string\n    stringPointer = (char *)(*(int *)((int)object + 0x20) + 8); // Get the address of the string starting at offset 0x20 + 8 from 'this'\n    \n    while (*stringPointer != '\\0') { // Loop until the end of the string is reached\n        stringPointer++; // Move to the next character in the string\n    }\n    \n    // Call FUN_1000bcc0 with the destination address, source string, and length of the string\n    FUN_1000bcc0((void *)(destination + 0x20), (char *)(*(int *)((int)object + 0x20) + 8), (int)stringPointer - (*(int *)((int)object + 0x20) + 9));\n    \n    // Copy values from 'this' to the corresponding offsets in 'param_1'\n    *(undefined4 *)(destination + 0xc) = *(undefined4 *)((int)object + 0xc); // Copy value at offset 0xc\n    *(undefined4 *)(destination + 4) = *(undefined4 *)((int)object + 4); // Copy value at offset 4\n    *(undefined4 *)(destination + 8) = *(undefined4 *)((int)object + 8); // Copy value at offset 8\n    *(undefined *)(destination + 0x2c) = *(undefined *)((int)object + 0x2c); // Copy value at offset 0x2c\n}\n"}
{"Function Name": "FUN_1000c1e0", "Address": "1000c1e0", "Source Code": "\nvoid __cdecl FUN_1000c1e0(char *destination_buffer, size_t buffer_size, char *source_string)\n{\n    // Call __vsnprintf_s to format a string safely\n    // param_1: destination buffer where the formatted string will be stored\n    // param_2: size of the destination buffer (maximum number of characters to write)\n    // param_3: source string to be formatted\n    // NULL: indicates no additional arguments for formatting\n    __vsnprintf_s(destination_buffer, buffer_size, buffer_size, source_string, NULL);\n}\n"}
{"Function Name": "FUN_1000c300", "Address": "1000c300", "Source Code": "\nvoid __cdecl FUN_1000c300(uint **param_1, void *param_2)\n{\n    byte byteValue; // Variable to hold a byte value from the data\n    uint *uintArrayPtr; // Pointer to hold the address of the uint array\n    byte *byteArrayPtr; // Pointer to hold the address of a byte array\n    uint index = 0; // Index variable initialized to 0\n    bool loopCondition; // Boolean variable to control the loop\n\n    // Check if the first element of the array pointed by param_1 is greater than 0\n    if (0 < (int)**param_1) {\n        loopCondition = **param_1 != 0; // Set bVar6 to true if the first element is not zero\n        do {\n            // Assert that the index is less than the length\n            if (!loopCondition) {\n                __wassert(L\"index < length()\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinystr.h\", 0x9c);\n            }\n            byteValue = *(byte *)((int)*param_1 + index + 8); // Get the byte at the current index + offset\n\n            // Check if the byte is equal to '&'\n            if (byteValue == 0x26) {\n                uint arrayLength = **param_1; // Get the length of the array\n                // Assert that the index is within valid bounds\n                if ((int)(arrayLength - 2) <= (int)index || arrayLength <= index + 1) {\n                    __wassert(L\"index < length()\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinystr.h\", 0x9c);\n                }\n                // Check if the next byte is '#'\n                if (*(char *)((int)*param_1 + index + 9) != '#') goto LAB_1000c4ae;\n                // Assert that the index is within valid bounds\n                if (**param_1 <= index + 2) {\n                    __wassert(L\"index < length()\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinystr.h\", 0x9c);\n                }\n                uintArrayPtr = *param_1; // Assign the pointer to the uint array\n                // Check if the next byte is 'x'\n                if (*(char *)((int)uintArrayPtr + index + 10) != 'x') goto LAB_1000c4ae;\n                // If the index is valid, process the hex value\n                if ((int)index < (int)(*uintArrayPtr - 1)) {\n                    do {\n                        // Call the function to process the byte\n                        FUN_1000bdb0(param_2, (void *)((int)uintArrayPtr + index + 8), 1);\n                        index++; // Increment the index\n                        // Assert that the index is within valid bounds\n                        if (**param_1 <= index) {\n                            __wassert(L\"index < length()\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinystr.h\", 0x9c);\n                        }\n                    } while (*(char *)((int)uintArrayPtr + index + 9) != ';' && (int)index < (int)(*uintArrayPtr - 1)); // Continue until ';' or end of array\n                }\n            } else {\n                byte *formattedBytePtr; // Pointer for the byte array to be processed\n                size_t formattedSize; // Size variable for the data to be processed\n                // If the byte is less than 0x20, format it\n                if (byteValue < 0x20) {\n                    FUN_1000c1e0((char *)local_24, 0x20, \"&#x%02X;\"); // Format the byte into a string\n                    byteArrayPtr = local_24; // Point to the formatted string\n                    while (*byteArrayPtr) { // Find the end of the string\n                        byteArrayPtr++;\n                    }\n                    formattedBytePtr = local_24; // Set pbVar7 to the start of the formatted string\n                    formattedSize = (int)byteArrayPtr - (int)(local_24 + 1); // Calculate the size of the formatted string\n                } else {\n                    formattedSize = 1; // Set size to 1 for single byte\n                    formattedBytePtr = local_28; // Set pbVar7 to local array\n                    local_28[0] = byteValue; // Store the byte in local array\n                }\n                LAB_1000c4ae:\n                // Call the function to process the byte or formatted string\n                FUN_1000bdb0(param_2, formattedBytePtr, formattedSize);\n                index++; // Increment the index\n            }\n            loopCondition = index < **param_1; // Update the loop condition\n        } while (loopCondition); // Continue looping while bVar6 is true\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1000ca20", "Address": "1000ca20", "Source Code": "\n// Function declaration with a return type of undefined4 and a parameter of undefined4\nundefined4 __fastcall FUN_1000ca20(undefined4 input_value)\n{\n    // Return the value of the input parameter param_1\n    return input_value;\n}\n"}
{"Function Name": "FUN_1000ca30", "Address": "1000ca30", "Source Code": "\nvoid __thiscall FUN_1000ca30(void *this, int param_1)\n{\n    char *stringPtr; // Pointer to traverse a string\n    undefined4 functionResult; // Variable to hold a value from a function call\n    int *listIterator; // Pointer to iterate through a list of integers\n\n    // Get the address of the string starting from an offset of 8 bytes from a member at offset 0x20\n    stringPtr = (char *)(*(int *)((int)this + 0x20) + 8);\n    \n    // Traverse the string until the null terminator is found\n    while (*stringPtr != '\\0') {\n        stringPtr++; // Move to the next character in the string\n    }\n    \n    // Call FUN_1000bcc0 with parameters: destination, source string, and length of the string\n    FUN_1000bcc0((void *)(param_1 + 0x20), (char *)(*(int *)((int)this + 0x20) + 8), (int)stringPtr - (*(int *)((int)this + 0x20) + 9));\n    \n    // Copy specific fields from the current object to the destination object\n    *(undefined4 *)(param_1 + 0xc) = *(undefined4 *)((int)this + 0xc); // Copy field at offset 0xc\n    *(undefined4 *)(param_1 + 4) = *(undefined4 *)((int)this + 4); // Copy field at offset 4\n    *(undefined4 *)(param_1 + 8) = *(undefined4 *)((int)this + 8); // Copy field at offset 8\n    *(undefined *)(param_1 + 0x2c) = *(undefined *)((int)this + 0x2c); // Copy field at offset 0x2c\n    *(undefined4 *)(param_1 + 0x30) = *(undefined4 *)((int)this + 0x30); // Copy field at offset 0x30\n    \n    // Call FUN_1000bcc0 with parameters: destination, source pointer, and value from the source pointer\n    FUN_1000bcc0((void *)(param_1 + 0x34), *(uint **)((int)this + 0x34) + 2, **(uint **)((int)this + 0x34));\n    \n    // Copy additional fields from the current object to the destination object\n    *(undefined4 *)(param_1 + 0x38) = *(undefined4 *)((int)this + 0x38); // Copy field at offset 0x38\n    *(undefined4 *)(param_1 + 0x3c) = *(undefined4 *)((int)this + 0x3c); // Copy field at offset 0x3c\n    *(undefined4 *)(param_1 + 0x40) = *(undefined4 *)((int)this + 0x40); // Copy field at offset 0x40\n    *(undefined *)(param_1 + 0x44) = *(undefined *)((int)this + 0x44); // Copy field at offset 0x44\n    \n    // Iterate through a linked list starting from the pointer at offset 0x18\n    for (listIterator = *(int **)((int)this + 0x18); listIterator != (int *)0x0; listIterator = (int *)listIterator[10]) {\n        // Call a function pointed to by the member at offset 0x3c of the current node\n        functionResult = (**(code **)(*listIterator + 0x3c))();\n        \n        // Call FUN_1000c600 with the result of the previous function call\n        FUN_1000c600(functionResult);\n    }\n}\n"}
{"Function Name": "FUN_1000cb60", "Address": "1000cb60", "Source Code": "\nvoid __thiscall FUN_1000cb60(void *this, FILE *filePointer, undefined4 undefinedParam, void *voidPointer)\n{\n    uint *secondMemberPointer; // Pointer to a uint\n    uint *thirdElementPointer; // Pointer to a uint for iteration\n    undefined *specificAddressPointer; // Pointer to an undefined type\n    uint localVariable; // Local variable initialized to 1\n    localVariable = 1;\n\n    // Call FUN_1000c300 with the first member of 'this' and a reference to DAT_10035a58\n    FUN_1000c300((uint **)((int)this + 0x14), &DAT_10035a58);\n    // Call FUN_1000c300 with the second member of 'this' and a reference to DAT_10035a58\n    FUN_1000c300((uint **)((int)this + 0x18), &DAT_10035a58);\n    secondMemberPointer = *(uint **)((int)this + 0x18); // Dereference the second member of 'this'\n\n    // Check if the value pointed to by puVar3 is not zero\n    if (*secondMemberPointer != 0) {\n        thirdElementPointer = secondMemberPointer + 2; // Set puVar5 to point to the third element of puVar3\n        // Loop until a null character is found\n        while (*(char *)thirdElementPointer != '\\0') {\n            // Check for a double quote character\n            if (*(char *)thirdElementPointer == '\\\"') {\n                // Check if the current position is not equal to DAT_1002c2dc\n                if ((int)thirdElementPointer + (-8 - (int)secondMemberPointer) != DAT_1002c2dc) {\n                    // If param_1 is not null, print formatted output to the file\n                    if (filePointer != (FILE *)0x0) {\n                        _fprintf(filePointer, \"%s=\\'%s\\'\", &DAT_10035a58 + 2, &DAT_10035a58 + 2, (uint)&stack0xffffffe8);\n                    }\n                    // If param_3 is not null, call FUN_1000bdb0 with various parameters\n                    if (voidPointer != (void *)0x0) {\n                        FUN_1000bdb0(voidPointer, &DAT_10035a58 + 2, *(&DAT_10035a58));\n                        FUN_1000bdb0(voidPointer, &DAT_1002c57c, 2);\n                        FUN_1000bdb0(voidPointer, &DAT_10035a58 + 2, *(&DAT_10035a58));\n                        specificAddressPointer = &DAT_1002c578; // Set puVar6 to a specific address\n                        goto LAB_1000ccc5; // Jump to the cleanup section\n                    }\n                    break; // Exit the loop if param_3 is null\n                }\n            }\n            thirdElementPointer = (uint *)((int)thirdElementPointer + 1); // Move to the next character\n        }\n    }\n    \n    // If param_1 is not null, print formatted output to the file\n    if (filePointer != (FILE *)0x0) {\n        _fprintf(filePointer, \"%s=\\\"%s\\\"\", &DAT_10035a58 + 2, &DAT_10035a58 + 2, (uint)&stack0xffffffe8);\n    }\n    \n    // If param_3 is not null, call FUN_1000bdb0 with various parameters\n    if (voidPointer != (void *)0x0) {\n        FUN_1000bdb0(voidPointer, &DAT_10035a58 + 2, *(&DAT_10035a58));\n        FUN_1000bdb0(voidPointer, &DAT_1002c58c, 2);\n        FUN_1000bdb0(voidPointer, &DAT_10035a58 + 2, *(&DAT_10035a58));\n        specificAddressPointer = &DAT_1002c588; // Set puVar6 to another specific address\nLAB_1000ccc5:\n        FUN_1000bdb0(voidPointer, specificAddressPointer, 1); // Call FUN_1000bdb0 with puVar6\n    }\n    \n    // If local_4 is not equal to 1, free the memory at DAT_10035a58\n    if (localVariable != 1) {\n        _free(&DAT_10035a58);\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1000ce30", "Address": "1000ce30", "Source Code": "\nvoid __thiscall FUN_1000ce30(void *objectPointer, undefined4 firstParam, undefined4 secondParam)\n{\n    // Cast the 'this' pointer to a function pointer type that takes two undefined4 parameters and an int\n    // and is located at an offset of 0x44 from the 'this' pointer.\n    // Then, call the function with param_1, param_2, and 0 as arguments.\n    ((void (**)(undefined4, undefined4, int))(objectPointer + 0x44))(firstParam, secondParam, 0);\n}\n"}
{"Function Name": "FUN_1000cfa0", "Address": "1000cfa0", "Source Code": "\nvoid __thiscall FUN_1000cfa0(void *object, int destinationAddress)\n{\n    // Retrieve a pointer to a character string from a specific offset in the 'this' object\n    char *stringPointer = (char *)(*(int *)((int)object + 0x20) + 8);\n    \n    // Iterate through the string until the null terminator is found\n    while (*stringPointer != '\\0') {\n        stringPointer++; // Move to the next character in the string\n    }\n    \n    // Call FUN_1000bcc0 with parameters: destination address, source string, and length of the string\n    copyFunction((void *)(destinationAddress + 0x20), (char *)(*(int *)((int)object + 0x20) + 8), (int)stringPointer - (*(int *)((int)object + 0x20) + 9));\n    \n    // Copy specific 4-byte values from the 'this' object to the destination address\n    *(undefined4 *)(destinationAddress + 0xc) = *(undefined4 *)((int)object + 0xc);\n    *(undefined4 *)(destinationAddress + 4) = *(undefined4 *)((int)object + 4);\n    *(undefined4 *)(destinationAddress + 8) = *(undefined4 *)((int)object + 8);\n    \n    // Call FUN_1000bcc0 for additional data copying from the 'this' object to the destination address\n    copyFunction((void *)(destinationAddress + 0x2c), *(uint **)((int)object + 0x2c) + 2, **(uint **)((int)object + 0x2c));\n    copyFunction((void *)(destinationAddress + 0x30), *(uint **)((int)object + 0x30) + 2, **(uint **)((int)object + 0x30));\n    copyFunction((void *)(destinationAddress + 0x34), *(uint **)((int)object + 0x34) + 2, **(uint **)((int)object + 0x34));\n}\n"}
{"Function Name": "FUN_1000d110", "Address": "1000d110", "Source Code": "\nvoid __thiscall FUN_1000d110(void *objectPointer, int inputParam)\n{\n    // Check if the result of FUN_1000c190 is not zero when passing 'this' and a specific byte pointer\n    if (checkFunction(objectPointer, (byte *)(*(int *)(inputParam + 0x14) + 8)) != 0) {\n        // Assert that the condition is true; if not, trigger an assertion failure\n        __wassert(L\"!Find( addMe->Name() )\", L\".\\\\tinyxml.cpp\", 0x5ef);\n    }\n    \n    // Store the pointer 'this' in the memory location at offset 0x20 of 'param_1'\n    *(void **)(inputParam + 0x20) = objectPointer;\n    \n    // Copy the value from the memory location at offset 0x1c of 'this' to the memory location at offset 0x1c of 'param_1'\n    *(undefined4 *)(inputParam + 0x1c) = *(undefined4 *)((int)objectPointer + 0x1c);\n    \n    // Set the memory location at offset 0x20 of the object pointed to by the value at offset 0x1c of 'this' to 'param_1'\n    *(int *)(*(int *)((int)objectPointer + 0x1c) + 0x20) = inputParam;\n    \n    // Update the memory location at offset 0x1c of 'this' to point to 'param_1'\n    *(int *)((int)objectPointer + 0x1c) = inputParam;\n}\n"}
{"Function Name": "FUN_1000d280", "Address": "1000d280", "Source Code": "\nvoid __thiscall FUN_1000d280(void *object, FILE *file_pointer, undefined4 additional_param)\n{\n    // Call the function FUN_1000cb60 with the current object, file pointer, and additional parameter\n    FUN_1000cb60(object, file_pointer, additional_param, NULL);\n}\n"}
{"Function Name": "FUN_1000d2a0", "Address": "1000d2a0", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d2a0(void *object, byte flag)\n{\n    // Call FUN_1000c280 with 'this' cast to undefined4 pointer\n    FUN_1000c280((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_1000d2a0(void *object, byte flag)\n{\n    FUN_1000c280((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_1000d570", "Address": "1000d570", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d570(void *object, byte flag)\n{\n    // Call the function FUN_1000d4d0 with 'this' cast to undefined4 pointer\n    FUN_1000d4d0((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_1000d570(void *object, byte flag)\n{\n    FUN_1000d4d0((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_1000d6c0", "Address": "1000d6c0", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d6c0(void *object, byte flag)\n{\n    // Call the function FUN_1000d650 with 'this' cast to undefined4 pointer\n    FUN_1000d650((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_1000d6c0(void *object, byte flag)\n{\n    FUN_1000d650((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_1000d6e0", "Address": "1000d6e0", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d6e0(void *object, byte flag)\n{\n    // Call the function FUN_1000c570 with 'this' cast to undefined4 pointer\n    FUN_1000c570((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_1000d6e0(void *object, byte flag)\n{\n    FUN_1000c570((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_1000d810", "Address": "1000d810", "Source Code": "\nvoid __thiscall FUN_1000d810(void *this, int param_1)\n{\n    char currentChar; // Variable to hold a character\n    int valueFromThis;  // Variable to hold an integer\n    int nextValue;  // Variable to hold another integer\n    int *intPointer; // Pointer to an integer\n    char *charPointer; // Pointer to a character\n    char *stringPointer; // Pointer to a character\n\n    // Get the address of a specific member from the 'this' object and offset it by 8\n    stringPointer = (char *)(*(int *)((int)this + 0x20) + 8);\n    charPointer = stringPointer;\n\n    // Loop to find the null terminator in the string\n    do {\n        currentChar = *charPointer; // Get the current character\n        charPointer++; // Move to the next character\n    } while (currentChar != '\\0'); // Continue until null terminator is found\n\n    // Call a function with specific parameters\n    FUN_1000bcc0((void *)(param_1 + 0x20), stringPointer, (int)charPointer - (*(int *)((int)this + 0x20) + 9));\n\n    // Copy specific values from 'this' object to the new parameter\n    *(undefined4 *)(param_1 + 0xc) = *(undefined4 *)((int)this + 0xc);\n    *(undefined4 *)(param_1 + 4) = *(undefined4 *)((int)this + 4);\n    *(undefined4 *)(param_1 + 8) = *(undefined4 *)((int)this + 8);\n\n    // Get a value from the 'this' object\n    valueFromThis = *(int *)((int)this + 0x4c);\n\n    // Check if the value is not equal to a specific offset\n    if (valueFromThis != (int)this + 0x2c) {\n        // Loop while iVar2 is not zero\n        do {\n            if (valueFromThis == 0) break; // Break if iVar2 is zero\n            nextValue = *(int *)(valueFromThis + 0x18); // Get another integer from the current iVar2\n            charPointer = (char *)(nextValue + 8); // Set pcVar5 to point to a specific location\n\n            // Call a function and check its return value\n            if (FUN_1000d160((void *)(param_1 + 0x2c), (byte *)(*(int *)(valueFromThis + 0x14) + 8)) != 0) {\n                stringPointer = charPointer;\n\n                // Loop to find the null terminator in the string\n                do {\n                    currentChar = *stringPointer; // Get the current character\n                    stringPointer++; // Move to the next character\n                } while (currentChar != '\\0'); // Continue until null terminator is found\n\n                // Call a function with specific parameters\n                FUN_1000bcc0((void *)(nextValue + 0x18), charPointer, (int)stringPointer - (nextValue + 9));\n            }\n            valueFromThis = *(int *)(valueFromThis + 0x20); // Move to the next element in the linked structure\n        } while ((**(int **)(valueFromThis + 0x18) != 0) || (**(int **)(valueFromThis + 0x14) != 0)); // Continue while there are valid entries\n    }\n\n    // Iterate through a linked list of integers\n    for (intPointer = *(int **)((int)this + 0x18); intPointer != (int *)0x0; intPointer = (int *)intPointer[10]) {\n        // Call a function using a function pointer\n        FUN_1000c600((**(code **)(*intPointer + 0x3c))());\n    }\n    return; // End of function\n}\n"}
{"Function Name": "FUN_1000dc10", "Address": "1000dc10", "Source Code": "\\*\nundefined4 * method FUN_1000dc10(void *object, byte flag)\n{\n    // Call the function FUN_1000d7a0 with 'this' cast to undefined4 pointer\n    FUN_1000d7a0((undefined4 *)object);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for 'this' if the condition is true\n        _free(object);\n    }\n    \n    // Return 'this' cast to undefined4 pointer\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * method FUN_1000dc10(void *object, byte flag)\n{\n    FUN_1000d7a0((undefined4 *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_1000dc30", "Address": "1000dc30", "Source Code": "\nundefined4 check_whitespace(byte input_byte)\n{\n    // Check if the input byte is not a whitespace character\n    // and is not a newline (10) or carriage return (13)\n    if ((is_whitespace((uint)input_byte) == 0) && (input_byte != 10) && (input_byte != 0xd)) {\n        // Return 0 if the conditions are met (not a whitespace, newline, or carriage return)\n        return 0;\n    }\n    // Return 1 if the input byte is a whitespace, newline, or carriage return\n    return 1;\n}\n"}
{"Function Name": "FUN_1000dc60", "Address": "1000dc60", "Source Code": "\nvoid __cdecl FUN_1000dc60(uint value, int offset, int *byte_count)\n{\n    byte *encoded_pointer; // Pointer to a byte for storing encoded data\n\n    // Determine the number of bytes needed for encoding based on param_1\n    if (value < 0x80) {\n        *byte_count = 1; // 1 byte needed\n    }\n    else if (value < 0x800) {\n        *byte_count = 2; // 2 bytes needed\n    }\n    else if (value < 0x10000) {\n        *byte_count = 3; // 3 bytes needed\n    }\n    else {\n        // Check if param_1 exceeds the maximum allowed value\n        if (0x1fffff < value) {\n            *byte_count = 0; // Invalid value\n            return; // Exit the function\n        }\n        *byte_count = 4; // 4 bytes needed\n    }\n\n    // Set pbVar1 to point to the location where the encoded bytes will be stored\n    encoded_pointer = (byte *)(offset + *byte_count);\n\n    // Encode the value of param_1 based on the number of bytes determined\n    switch(*byte_count) {\n    case 4:\n        encoded_pointer--; // Move pointer back for the next byte\n        *encoded_pointer = (byte)value & 0x3f | 0x80; // Set the first byte\n        value >>= 6; // Shift param_1 right by 6 bits\n    case 3:\n        encoded_pointer--; // Move pointer back for the next byte\n        *encoded_pointer = (byte)value & 0x3f | 0x80; // Set the second byte\n        value >>= 6; // Shift param_1 right by 6 bits\n    case 2:\n        encoded_pointer--; // Move pointer back for the next byte\n        *encoded_pointer = (byte)value & 0x3f | 0x80; // Set the third byte\n        value >>= 6; // Shift param_1 right by 6 bits\n    case 1:\n        encoded_pointer[-1] = (byte)value | 0xC0; // Set the final byte with the prefix\n        return; // Exit the function\n    default:\n        return; // Exit the function for unexpected cases\n    }\n}\n"}
{"Function Name": "FUN_1000dd60", "Address": "1000dd60", "Source Code": "\nint __cdecl FUN_1000dd60(byte inputByte)\n{\n    // Check if the input parameter 'param_1' is less than 127 (0x7f)\n    return (inputByte < 0x7f) ? \n        // If true, check if 'param_1' is an alphabetic character using _isalpha\n        _isalpha((uint)inputByte) : \n        // If false, return 1 (indicating a true condition)\n        1;\n}\n"}
{"Function Name": "FUN_1000dd80", "Address": "1000dd80", "Source Code": "\nvoid __thiscall FUN_1000dd80(void *context, byte *inputBuffer, int flag)\n{\n    byte *bytePointer; // Pointer to a byte variable\n    int cursorRow;    // Variable to hold cursor row\n    int cursorColumn;    // Variable to hold cursor column\n\n    // Check if param_1 is null, assert if true\n    if (inputBuffer == (byte *)0x0) {\n        __wassert(L\"now\", L\".\\\\tinyxmlparser.cpp\", 0xc6);\n    }\n    \n    // Check if the value at offset 0xc from 'this' is greater than 0\n    if (0 < *(int *)((int)context + 0xc)) {\n        cursorRow = *context; // Get the current cursor row\n        bytePointer = *(byte **)((int)context + 8); // Get the pointer to the current byte\n        cursorColumn = *(int *)((int)context + 4); // Get the current cursor column\n        \n        // Assert if pbVar3 is null\n        if (bytePointer == (byte *)0x0) {\n            __wassert(L\"p\", L\".\\\\tinyxmlparser.cpp\", 0xd2);\n        }\n    joined_r0x1000dddf: // Label for continuing processing\n\n        // Check if pbVar3 is less than param_1\n        if (bytePointer < inputBuffer) {\n            switch ((uint)*bytePointer) { // Switch based on the value pointed by pbVar3\n                case 0: // Case for null character\n                    goto LAB_1000df12; // Go to end of function\n                default: // Default case\n                    if (flag == 1) { // If param_2 is 1\n                        int value = *(int *)(&DAT_1002ca50 + (uint)*bytePointer * 4); // Get corresponding value\n                        if (value == 0) {\n                            value = 1; // Default to 1 if iVar4 is 0\n                        }\n                        bytePointer += value; // Move pbVar3 forward by iVar4\n                    } else {\n                        bytePointer++; // Move pbVar3 forward by 1\n                    }\n                    goto LAB_1000dea6; // Continue processing\n                case 9: // Case for horizontal tab\n                    cursorColumn = (cursorColumn / *(int *)((int)context + 0xc) + 1) * *(int *)((int)context + 0xc); // Update column\n                    bytePointer++; // Move pbVar3 forward\n                    goto joined_r0x1000dddf; // Continue processing\n                case 10: // Case for newline\n                    cursorRow++; // Increment row\n                    cursorColumn = 0; // Reset column\n                    bytePointer++; // Move pbVar3 forward\n                    if (bytePointer[1] == 0xd) { // Check for carriage return\n                        bytePointer++; // Move pbVar3 forward\n                    }\n                    goto joined_r0x1000dddf; // Continue processing\n                case 0xd: // Case for carriage return\n                    cursorRow++; // Increment row\n                    cursorColumn = 0; // Reset column\n                    bytePointer++; // Move pbVar3 forward\n                    if (bytePointer[1] == 10) { // Check for newline\n                        bytePointer++; // Move pbVar3 forward\n                    }\n                    goto joined_r0x1000dddf; // Continue processing\n                case 0xef: // Case for specific byte value\n                    goto switchD_1000de05_caseD_ef; // Handle special case\n            }\n        }\n        \n        // Update the cursor row and column in 'this'\n        *(int *)context = cursorRow; \n        *(int *)((int)context + 4) = cursorColumn; \n        \n        // Assert if cursor row is less than -1\n        if (cursorRow < -1) {\n            __wassert(L\"cursor.row >= -1\", L\".\\\\tinyxmlparser.cpp\", 0x133);\n        }\n        \n        // Assert if cursor column is less than -1\n        if (*(int *)((int)context + 4) < -1) {\n            __wassert(L\"cursor.col >= -1\", L\".\\\\tinyxmlparser.cpp\", 0x134);\n        }\n        \n        *(byte **)((int)context + 8) = bytePointer; // Update the pointer in 'this'\n        \n        // Assert if pbVar3 is null\n        if (bytePointer == (byte *)0x0) {\n            __wassert(L\"stamp\", L\".\\\\tinyxmlparser.cpp\", 0x136);\n        }\n    }\nLAB_1000df12: // End of function label\n    return; // Return from function\nswitchD_1000de05_caseD_ef: // Label for special case handling\n    if (flag != 1) goto LAB_1000dea4; // Check if param_2 is not 1\n    byte nextByte = bytePointer[1]; // Get the next byte\n    // Check for specific byte patterns\n    if (nextByte != 0 && bytePointer[2] != 0) {\n        if ((nextByte == 0xbb && bytePointer[2] == 0xbf) || \n            (nextByte == 0xbf && (bytePointer[2] == 0xbe || bytePointer[2] == 0xbf))) {\n            bytePointer += 3; // Move pbVar3 forward by 3\n            goto joined_r0x1000dddf; // Continue processing\n        }\n    }\n    bytePointer += 3; // Move pbVar3 forward by 3\nLAB_1000dea6: // Continue processing label\n    cursorColumn++; // Increment column\n    goto joined_r0x1000dddf; // Continue processing\n}\n"}
{"Function Name": "FUN_1000e020", "Address": "1000e020", "Source Code": "\\*\nbyte * __cdecl FUN_1000e020(byte *input_pointer, int mode)\n{\n    byte current_byte; // Variable to hold the current byte value\n\n    // Check if the input pointer is null or if the first byte is zero\n    if ((input_pointer == (byte *)0x0) || (current_byte = *input_pointer, current_byte == 0)) {\n        return (byte *)0x0; // Return null if input is invalid\n    }\n\n    // If param_2 is not equal to 1, process the input differently\n    if (mode != 1) {\n        // Loop to skip whitespace characters and new line characters\n        while (_isspace((uint)current_byte) || (current_byte == 10) || (current_byte == 0xd)) {\n            current_byte = input_pointer[1]; // Get the next byte\n            input_pointer++; // Move to the next byte\n            if (current_byte == 0) {\n                return input_pointer; // Return if end of string is reached\n            }\n        }\n        return input_pointer; // Return the current position\n    }\n\n    // Loop to process the input when param_2 is equal to 1\n    do {\n        // Check for the UTF-8 BOM (Byte Order Mark)\n        if (current_byte == 0xef) {\n            // Check for specific BOM sequences\n            if ((input_pointer[1] == 0xbb && input_pointer[2] == 0xbf) || \n                (input_pointer[1] == 0xbf && input_pointer[2] == 0xbe) || \n                (input_pointer[1] == 0xbf)) {\n                input_pointer += 3; // Skip the BOM\n            }\n        } else {\n            // Check if the current byte is not a whitespace or newline\n            if (!_isspace((uint)current_byte) && current_byte != 10 && current_byte != 0xd) {\n                return input_pointer; // Return current position if a non-whitespace character is found\n            }\n            input_pointer++; // Move to the next byte\n        }\n        current_byte = *input_pointer; // Update bVar2 with the next byte\n        if (current_byte == 0) {\n            return input_pointer; // Return if end of string is reached\n        }\n    } while (true); // Continue looping until a return condition is met\n}\n*\\ \n \n\nbyte * __cdecl FUN_1000e020(byte *input_pointer,int mode)\n{\n    byte current_byte;\n    if ((input_pointer == (byte *)0x0) || (current_byte = *input_pointer, current_byte == 0)) {\n        return (byte *)0x0;\n    }\n    if (mode != 1) {\n        while (_isspace((uint)current_byte) || (current_byte == 10) || (current_byte == 0xd)) {\n            current_byte = input_pointer[1];\n            input_pointer++;\n            if (current_byte == 0) {\n                return input_pointer;\n            }\n        }\n        return input_pointer;\n    }\n    do {\n        if (current_byte == 0xef) {\n            if ((input_pointer[1] == 0xbb && input_pointer[2] == 0xbf) || \n                (input_pointer[1] == 0xbf && input_pointer[2] == 0xbe) || \n                (input_pointer[1] == 0xbf)) {\n                input_pointer += 3;\n            }\n        } else {\n            if (!_isspace((uint)current_byte) && current_byte != 10 && current_byte != 0xd) {\n                return input_pointer;\n            }\n            input_pointer++;\n        }\n        current_byte = *input_pointer;\n        if (current_byte == 0) {\n            return input_pointer;\n        }\n    } while (true);\n}\n"}
{"Function Name": "FUN_1000e0d0", "Address": "1000e0d0", "Source Code": "\\*\nbyte * __cdecl FUN_1000e0d0(byte *inputByteArray, void *operationContext)\n{\n    byte currentByte; // Variable to hold the current byte value\n    byte *traversePointer; // Pointer to traverse the input byte array\n\n    // Call a function to perform some operation with param_2 and a pointer\n    FUN_1000bcc0(operationContext, &PTR_1002bc68, 0);\n    \n    // Check if the input parameter is null\n    if (inputByteArray == (byte *)0x0) {\n        // Assert failure if param_1 is null\n        __wassert(L\"p\", L\".\\\\tinyxmlparser.cpp\", 0x197);\n    } else {\n        // Get the first byte from the input parameter\n        currentByte = *inputByteArray;\n        \n        // Check if the byte is valid (not null and within valid range or is an alphabetic character or underscore)\n        if ((currentByte != 0) && (0x7e < currentByte || _isalpha((uint)currentByte) || (*inputByteArray == 0x5f))) {\n            traversePointer = inputByteArray; // Initialize pointer to the start of param_1\n            \n            // Loop to traverse the byte array until an invalid character is found\n            do {\n                currentByte = *traversePointer; // Get the current byte value\n                \n                // Check if the current byte is null or not alphanumeric (and not specific valid characters)\n                if ((currentByte == 0) || (_isalnum((uint)currentByte) == 0 && (currentByte != 0x5f && currentByte != 0x2d && currentByte != 0x2e && currentByte != 0x3a))) {\n                    break; // Exit the loop if an invalid character is found\n                }\n                traversePointer++; // Move to the next byte\n            } while (traversePointer != (byte *)0x0); // Continue until the end of the byte array\n            \n            // If there are valid characters found, call the function with the valid range\n            if (0 < (int)traversePointer - (int)inputByteArray) {\n                FUN_1000bcc0(operationContext, inputByteArray, (int)traversePointer - (int)inputByteArray);\n            }\n            return traversePointer; // Return the pointer to the next invalid character\n        }\n    }\n    return (byte *)0x0; // Return null if no valid characters were found\n}\n*\\ \n \n\nbyte * __cdecl FUN_1000e0d0(byte *inputByteArray, void *operationContext)\n{\n    byte currentByte;\n    byte *traversePointer;\n\n    FUN_1000bcc0(operationContext, &PTR_1002bc68, 0);\n    if (inputByteArray == (byte *)0x0) {\n        __wassert(L\"p\", L\".\\\\tinyxmlparser.cpp\", 0x197);\n    } else {\n        currentByte = *inputByteArray;\n        if ((currentByte != 0) && (0x7e < currentByte || _isalpha((uint)currentByte) || (*inputByteArray == 0x5f))) {\n            traversePointer = inputByteArray;\n            do {\n                currentByte = *traversePointer;\n                if ((currentByte == 0) || (_isalnum((uint)currentByte) == 0 && (currentByte != 0x5f && currentByte != 0x2d && currentByte != 0x2e && currentByte != 0x3a))) {\n                    break;\n                }\n                traversePointer++;\n            } while (traversePointer != (byte *)0x0);\n            if (0 < (int)traversePointer - (int)inputByteArray) {\n                FUN_1000bcc0(operationContext, inputByteArray, (int)traversePointer - (int)inputByteArray);\n            }\n            return traversePointer;\n        }\n    }\n    return (byte *)0x0;\n}\n"}
{"Function Name": "FUN_1000e180", "Address": "1000e180", "Source Code": "\nundefined4 __cdecl FUN_1000e180(char *inputString, char *comparisonString, char caseSensitiveFlag, int caseSensitivity)\n{\n    char currentChar; // Variable to hold the current character from param_2\n    uint resultAccumulator = 0; // Variable to accumulate results\n\n    // Check if param_1 is NULL, assert if true\n    if (inputString == (char *)0x0) {\n        __wassert(L\"p\", L\".\\\\tinyxmlparser.cpp\", 0x21b);\n    }\n    // Check if param_2 is NULL, assert if true\n    if (comparisonString == (char *)0x0) {\n        __wassert(L\"tag\", L\".\\\\tinyxmlparser.cpp\", 0x21c);\n    }\n    // Check if param_1 is NULL or empty, assert if true and return 0\n    if ((inputString == (char *)0x0) || (*inputString == '\\0')) {\n        __wassert(L\"0\", L\".\\\\tinyxmlparser.cpp\", 0x21f);\n        return resultAccumulator & 0xffffff00; // Return 0 if param_1 is invalid\n    }\n    // If param_3 is null character, perform case-sensitive comparison\n    if (caseSensitiveFlag == '\\0') {\n        do {\n            currentChar = *comparisonString; // Get current character from param_2\n            resultAccumulator = CONCAT31((int3)(resultAccumulator >> 8), currentChar); // Accumulate character\n            if (currentChar == '\\0') goto LAB_1000e22b; // Exit if end of string\n            if (*inputString != currentChar) break; // Break if characters do not match\n            inputString++; // Move to next character in param_1\n            comparisonString++; // Move to next character in param_2\n        } while (*inputString != '\\0'); // Continue until end of param_1\n    } else {\n        // Perform case-insensitive comparison\n        do {\n            if (*comparisonString == '\\0') goto LAB_1000e22b; // Exit if end of string\n            uint currentInputChar = (uint)*inputString; // Get current character from param_1\n            // Convert to lowercase if case-insensitive comparison is required\n            if ((caseSensitivity != 1) || ((int)currentInputChar < 0x80)) {\n                currentInputChar = _tolower(currentInputChar);\n            }\n            resultAccumulator = (uint)*comparisonString; // Get current character from param_2\n            // Convert to lowercase if case-insensitive comparison is required\n            if ((caseSensitivity != 1) || ((int)resultAccumulator < 0x80)) {\n                resultAccumulator = _tolower(resultAccumulator);\n            }\n            if (currentInputChar != resultAccumulator) break; // Break if characters do not match\n            inputString++; // Move to next character in param_1\n            comparisonString++; // Move to next character in param_2\n        } while (*inputString != '\\0'); // Continue until end of param_1\n    }\n    // If there are remaining characters in param_2, return 0\n    if (*comparisonString != '\\0') {\n        return resultAccumulator & 0xffffff00; // Return 0 if param_2 is not fully matched\n    }\nLAB_1000e22b:\n    return CONCAT31((int3)(resultAccumulator >> 8), 1); // Return success indicator\n}\n"}
{"Function Name": "FUN_1000e270", "Address": "1000e270", "Source Code": "\nvoid __thiscall FUN_1000e270(void *object, int error_code, byte *data_buffer, undefined4 *error_message, int buffer_size)\n{\n    char char_value; // Variable to hold a character value\n    char *error_string; // Pointer to a character string\n\n    // Check if the value at offset 0x2c of 'this' is zero\n    if (*(char *)((int)object + 0x2c) == '\\0') {\n        // Validate that param_1 is within the acceptable range (1 to 15)\n        if ((error_code < 1) || (0xf < error_code)) {\n            // Assert failure if param_1 is out of range\n            __wassert(L\"err > 0 && err < TIXML_ERROR_STRING_COUNT\", L\".\\\\tinyxmlparser.cpp\", 0x324);\n        }\n        \n        // Store param_1 at offset 0x30 of 'this'\n        *(int *)((int)object + 0x30) = error_code;\n        // Set the value at offset 0x2c of 'this' to 1\n        *(undefined *)((int)object + 0x2c) = 1;\n        \n        // Get the error message corresponding to param_1\n        error_string = (&PTR_s_No_error_100344a8)[error_code];\n        \n        // Call a function to process the error message and store it at offset 0x34 of 'this'\n        FUN_1000bcc0((void *)((int)object + 0x34), error_string, (int)(error_string + strlen(error_string) + 1));\n        \n        // Initialize values at offsets 0x3c and 0x40 of 'this' to -1\n        *(undefined4 *)((int)object + 0x3c) = 0xffffffff;\n        *(undefined4 *)((int)object + 0x40) = 0xffffffff;\n        \n        // If param_2 and param_3 are not null, process them\n        if ((data_buffer != (byte *)0x0) && (error_message != (undefined4 *)0x0)) {\n            // Call a function to handle param_2 and param_3\n            FUN_1000dd80(error_message, data_buffer, buffer_size);\n            // Store the processed values from param_3 into offsets 0x3c and 0x40 of 'this'\n            *(undefined4 *)((int)object + 0x3c) = *error_message;\n            *(undefined4 *)((int)object + 0x40) = error_message[1];\n        }\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1000eb50", "Address": "1000eb50", "Source Code": "\\*\nbyte * __thiscall FUN_1000eb50(int *inputArray, byte *bytePointer, undefined4 functionParam, int integerParam)\n{\n    int resultValue; // Variable to store the result of FUN_1000bec0\n    byte *byteDataPointer; // Pointer to byte data\n    void *objectPointer; // Pointer for object instantiation\n    undefined4 functionReturnValue; // Variable to store return value from functions\n    int *intPointer; // Pointer to an integer\n    void *exceptionListBackup = ExceptionList; // Store the current ExceptionList\n    ExceptionList = &exceptionListBackup; // Set ExceptionList to local_c\n\n    resultValue = FUN_1000bec0(inputArray); // Call function to get some integer value\n    byteDataPointer = FUN_1000e020(bytePointer, integerParam); // Call function to get a byte pointer\n\n    do {\n        if (byteDataPointer == (byte *)0x0) { // Check if pbVar3 is null\n            if ((resultValue != 0) && (*(char *)(resultValue + 0x2c) == '\\0')) { // Check conditions for error handling\n                *(undefined *)(resultValue + 0x2c) = 1; // Set error flag\n                *(undefined4 *)(resultValue + 0x30) = 5; // Set error code\n                FUN_1000bcc0((void *)(resultValue + 0x34), PTR_s_Error_reading_Element_value__100344bc,\n                             (int)PTR_s_Error_reading_Element_value__100344bc + 1); // Log error\n                *(undefined4 *)(resultValue + 0x40) = 0xffffffff; // Set additional error information\n                *(undefined4 *)(resultValue + 0x3c) = 0xffffffff; // Set additional error information\n            }\n            ExceptionList = exceptionListBackup; // Restore ExceptionList\n            return (byte *)0x0; // Return null pointer\n        }\n        if (*byteDataPointer == 0) { // Check if the byte pointed by pbVar3 is zero\n            ExceptionList = exceptionListBackup; // Restore ExceptionList\n            return byteDataPointer; // Return pbVar3\n        }\n        if (*byteDataPointer == 0x3c) { // Check if the byte is '<'\n            functionReturnValue = FUN_1000e180((char *)byteDataPointer, \"</\", '\\0', integerParam); // Call function to process closing tag\n            if ((char)functionReturnValue != '\\0') { // Check if the function indicates an error\n                ExceptionList = exceptionListBackup; // Restore ExceptionList\n                return byteDataPointer; // Return pbVar3\n            }\n            intPointer = FUN_1000e920(inputArray, byteDataPointer, integerParam); // Call function to get an integer pointer\n            if (intPointer == (int *)0x0) { // Check if the pointer is null\n                ExceptionList = exceptionListBackup; // Restore ExceptionList\n                return (byte *)0x0; // Return null pointer\n            }\n            bytePointer = (byte *)(**(code **)(*intPointer + 8))(byteDataPointer, functionParam, integerParam); // Call function to process data\n            FUN_1000c600(intPointer); // Free the integer pointer\n        } else { // Handle other cases\n            objectPointer = operator_new(0x30); // Allocate memory for an object\n            intPointer = (int *)0x0; // Initialize integer pointer to null\n            if (objectPointer != (void *)0x0) { // Check if memory allocation was successful\n                intPointer = FUN_1000d380(objectPointer, (char *)&PTR_1002bc68); // Initialize the object\n            }\n            if (intPointer == (int *)0x0) { // Check if the pointer is null\n                ExceptionList = exceptionListBackup; // Restore ExceptionList\n                return (byte *)0x0; // Return null pointer\n            }\n            if (s___AVbad_cast_std___1003439c[0x13] != '\\0') { // Check for a specific condition\n                bytePointer = byteDataPointer; // Assign pbVar3 to param_1\n            }\n            bytePointer = (byte *)(**(code **)(*intPointer + 8))(bytePointer, functionParam, integerParam); // Call function to process data\n            functionReturnValue = FUN_1000e5c0((int)intPointer); // Call function to check the result\n            if ((char)functionReturnValue == '\\0') { // Check if the function indicates success\n                FUN_1000c600(intPointer); // Free the integer pointer\n            }\n        }\n        byteDataPointer = FUN_1000e020(bytePointer, integerParam); // Get the next byte pointer\n    } while (true); // Continue the loop indefinitely\n}\n*\\ \n \n\nbyte * __thiscall FUN_1000eb50(int *inputArray, byte *bytePointer, undefined4 functionParam, int integerParam)\n{\n    int resultValue;\n    byte *byteDataPointer;\n    void *objectPointer;\n    undefined4 functionReturnValue;\n    int *intPointer;\n    void *exceptionListBackup = ExceptionList;\n    ExceptionList = &exceptionListBackup;\n    resultValue = FUN_1000bec0(inputArray);\n    byteDataPointer = FUN_1000e020(bytePointer, integerParam);\n    \n    do {\n        if (byteDataPointer == (byte *)0x0) {\n            if ((resultValue != 0) && (*(char *)(resultValue + 0x2c) == '\\0')) {\n                *(undefined *)(resultValue + 0x2c) = 1;\n                *(undefined4 *)(resultValue + 0x30) = 5;\n                FUN_1000bcc0((void *)(resultValue + 0x34), PTR_s_Error_reading_Element_value__100344bc,\n                             (int)PTR_s_Error_reading_Element_value__100344bc + 1);\n                *(undefined4 *)(resultValue + 0x40) = 0xffffffff;\n                *(undefined4 *)(resultValue + 0x3c) = 0xffffffff;\n            }\n            ExceptionList = exceptionListBackup;\n            return (byte *)0x0;\n        }\n        if (*byteDataPointer == 0) {\n            ExceptionList = exceptionListBackup;\n            return byteDataPointer;\n        }\n        if (*byteDataPointer == 0x3c) {\n            functionReturnValue = FUN_1000e180((char *)byteDataPointer, \"</\", '\\0', integerParam);\n            if ((char)functionReturnValue != '\\0') {\n                ExceptionList = exceptionListBackup;\n                return byteDataPointer;\n            }\n            intPointer = FUN_1000e920(inputArray, byteDataPointer, integerParam);\n            if (intPointer == (int *)0x0) {\n                ExceptionList = exceptionListBackup;\n                return (byte *)0x0;\n            }\n            bytePointer = (byte *)(**(code **)(*intPointer + 8))(byteDataPointer, functionParam, integerParam);\n            FUN_1000c600(intPointer);\n        } else {\n            objectPointer = operator_new(0x30);\n            intPointer = (int *)0x0;\n            if (objectPointer != (void *)0x0) {\n                intPointer = FUN_1000d380(objectPointer, (char *)&PTR_1002bc68);\n            }\n            if (intPointer == (int *)0x0) {\n                ExceptionList = exceptionListBackup;\n                return (byte *)0x0;\n            }\n            if (s___AVbad_cast_std___1003439c[0x13] != '\\0') {\n                bytePointer = byteDataPointer;\n            }\n            bytePointer = (byte *)(**(code **)(*intPointer + 8))(bytePointer, functionParam, integerParam);\n            functionReturnValue = FUN_1000e5c0((int)intPointer);\n            if ((char)functionReturnValue == '\\0') {\n                FUN_1000c600(intPointer);\n            }\n        }\n        byteDataPointer = FUN_1000e020(bytePointer, integerParam);\n    } while (true);\n}\n"}
{"Function Name": "FUN_1000edb0", "Address": "1000edb0", "Source Code": "\\*\nbyte * __cdecl\nFUN_1000edb0(byte *param_1, void *param_2, uint param_3, char *param_4, undefined4 param_5, int param_6)\n{\n    void *this = param_2; // Store the second parameter in 'this'\n    int iVar4 = param_6; // Store the sixth parameter in 'iVar4'\n    byte *pbVar5; // Pointer for byte manipulation\n    uint uVar8; // Variable to hold return value from function calls\n    byte local_8; // Local byte variable\n    size_t local_4; // Local size variable\n\n    FUN_1000bcc0(param_2, &PTR_1002bc68, 0); // Call a function with 'param_2' and a pointer\n\n    // Check if param_3 is zero or a specific condition is met\n    if (((char)param_3 == '\\0') || (s___AVbad_cast_std___1003439c[0x13] == '\\0')) {\n        pbVar5 = param_1; // Initialize pbVar5 with param_1\n        if (param_1 == (byte *)0x0) { // Check if param_1 is null\n            return (byte *)0x0; // Return null if param_1 is null\n        }\n        // Loop through the bytes until a null terminator is found\n        while (*pbVar5 != 0) {\n            uVar8 = FUN_1000e180((char *)pbVar5, param_4, (char)param_5, iVar4); // Call a function to process bytes\n            if ((char)uVar8 != '\\0') goto LAB_1000ef5e; // If the result is not zero, jump to label\n            param_3 = uVar8 & 0xff; // Update param_3 with the lower byte of uVar8\n            pbVar5 = FUN_1000ece0(pbVar5, (byte *)&param_3, (int *)&param_1, iVar4); // Call a function to modify pbVar5\n            FUN_1000bdb0(this, &param_3, (size_t)param_1); // Call a function with 'this', param_3, and size\n            if (pbVar5 == (byte *)0x0) { // Check if pbVar5 is null\n                return (byte *)0x0; // Return null if pbVar5 is null\n            }\n        }\n    } else {\n        param_3 = param_3 & 0xffffff00; // Mask param_3 to retain only certain bits\n        pbVar5 = FUN_1000e020(param_1, param_6); // Call a function to initialize pbVar5\n        while (true) {\n            if (pbVar5 == (byte *)0x0) { // Check if pbVar5 is null\n                return (byte *)0x0; // Return null if pbVar5 is null\n            }\n            if (*pbVar5 == 0) break; // Break the loop if a null terminator is found\n            if (FUN_1000e180((char *)pbVar5, param_4, (char)param_5, iVar4) != 0) goto LAB_1000ef5e; // Process bytes and check result\n            // Check for carriage return, newline, or whitespace\n            if ((*pbVar5 == 0xd) || (*pbVar5 == 10) || _isspace((uint)*pbVar5)) {\n                pbVar5++; // Move to the next byte\n                param_3 = CONCAT31(param_3._1_3_, 1); // Increment param_3\n            } else {\n                if ((char)param_3 != '\\0') { // Check if param_3 is not zero\n                    param_3._0_1_ = 0x20; // Set the first byte of param_3\n                    FUN_1000bdb0(this, &param_3, 1); // Call a function with 'this', param_3, and size 1\n                    param_3 = (uint)param_3._1_3_ << 8; // Shift param_3 left by 8 bits\n                }\n                local_8 = 0; // Initialize local_8 to zero\n                pbVar5 = FUN_1000ece0(pbVar5, &local_8, (int *)&local_4, iVar4); // Call a function to modify pbVar5\n                if (local_4 == 1) { // Check if only one byte was processed\n                    param_1 = (byte *)CONCAT31(param_1._1_3_, local_8); // Concatenate local_8 to param_1\n                    FUN_1000bdb0(this, &param_1, 1); // Call a function with 'this', param_1, and size 1\n                } else {\n                    FUN_1000bdb0(this, &local_8, local_4); // Call a function with 'this', local_8, and size local_4\n                }\n            }\n        }\n    }\nLAB_1000ef7d: // Label for returning from the function\n    if ((pbVar5 != (byte *)0x0) && (*pbVar5 != 0)) { // Check if pbVar5 is not null and not a null terminator\n        return pbVar5; // Return pbVar5\n    }\n    return (byte *)0x0; // Return null if conditions are not met\nLAB_1000ef5e: // Label for processing when a specific condition is met\n    if (*pbVar5 != 0) { // Check if the current byte is not a null terminator\n        char *pcVar1 = param_4 + 1; // Initialize pcVar1 to point to the next character in param_4\n        while (*param_4 != '\\0') { // Loop until the end of param_4\n            param_4++; // Move to the next character in param_4\n        }\n        pbVar5 += ((int)param_4 - (int)pcVar1); // Adjust pbVar5 based on the difference in pointers\n    }\n    goto LAB_1000ef7d; // Go to the return label\n}\n*\\ \n \n\nbyte * __cdecl\nFUN_1000edb0(byte *param_1, void *param_2, uint param_3, char *param_4, undefined4 param_5, int param_6)\n{\n    void *this = param_2;\n    int iVar4 = param_6;\n    byte *pbVar5;\n    uint uVar8;\n    byte local_8;\n    size_t local_4;\n\n    FUN_1000bcc0(param_2, &PTR_1002bc68, 0);\n    \n    if (((char)param_3 == '\\0') || (s___AVbad_cast_std___1003439c[0x13] == '\\0')) {\n        pbVar5 = param_1;\n        if (param_1 == (byte *)0x0) {\n            return (byte *)0x0;\n        }\n        while (*pbVar5 != 0) {\n            uVar8 = FUN_1000e180((char *)pbVar5, param_4, (char)param_5, iVar4);\n            if ((char)uVar8 != '\\0') goto LAB_1000ef5e;\n            param_3 = uVar8 & 0xff;\n            pbVar5 = FUN_1000ece0(pbVar5, (byte *)&param_3, (int *)&param_1, iVar4);\n            FUN_1000bdb0(this, &param_3, (size_t)param_1);\n            if (pbVar5 == (byte *)0x0) {\n                return (byte *)0x0;\n            }\n        }\n    } else {\n        param_3 = param_3 & 0xffffff00;\n        pbVar5 = FUN_1000e020(param_1, param_6);\n        while (true) {\n            if (pbVar5 == (byte *)0x0) {\n                return (byte *)0x0;\n            }\n            if (*pbVar5 == 0) break;\n            if (FUN_1000e180((char *)pbVar5, param_4, (char)param_5, iVar4) != 0) goto LAB_1000ef5e;\n            if ((*pbVar5 == 0xd) || (*pbVar5 == 10) || _isspace((uint)*pbVar5)) {\n                pbVar5++;\n                param_3 = CONCAT31(param_3._1_3_, 1);\n            } else {\n                if ((char)param_3 != '\\0') {\n                    param_3._0_1_ = 0x20;\n                    FUN_1000bdb0(this, &param_3, 1);\n                    param_3 = (uint)param_3._1_3_ << 8;\n                }\n                local_8 = 0;\n                pbVar5 = FUN_1000ece0(pbVar5, &local_8, (int *)&local_4, iVar4);\n                if (local_4 == 1) {\n                    param_1 = (byte *)CONCAT31(param_1._1_3_, local_8);\n                    FUN_1000bdb0(this, &param_1, 1);\n                } else {\n                    FUN_1000bdb0(this, &local_8, local_4);\n                }\n            }\n        }\n    }\nLAB_1000ef7d:\n    if ((pbVar5 != (byte *)0x0) && (*pbVar5 != 0)) {\n        return pbVar5;\n    }\n    return (byte *)0x0;\nLAB_1000ef5e:\n    if (*pbVar5 != 0) {\n        char *pcVar1 = param_4 + 1;\n        while (*param_4 != '\\0') {\n            param_4++;\n        }\n        pbVar5 += ((int)param_4 - (int)pcVar1);\n    }\n    goto LAB_1000ef7d;\n}\n"}
{"Function Name": "FUN_1000efa0", "Address": "1000efa0", "Source Code": "\\*\nbyte * __thiscall FUN_1000efa0(void *this, byte *param_1, undefined4 *param_2, int param_3)\n{\n    char tempChar; // Temporary character variable\n    byte *bytePointer; // Pointer to byte variable\n    char *charPointer; // Pointer to character variable\n    int *intPointer; // Pointer to integer variable\n    int tempInt; // Temporary integer variable\n    undefined4 undefinedVar; // Undefined 4-byte variable\n    undefined4 localData1; // Local variable for storing data\n    undefined4 localData2; // Local variable for storing data\n\n    // Initialize some fields in the current object\n    *(undefined *)((int)this + 0x2c) = 0; // Set a flag to 0\n    *(undefined4 *)((int)this + 0x30) = 0; // Initialize a field to 0\n    FUN_1000bcc0((void *)((int)this + 0x34), &PTR_1002bc68, 0); // Call a function with specific parameters\n    *(undefined4 *)((int)this + 0x40) = 0; // Initialize another field to 0\n    *(undefined4 *)((int)this + 0x3c) = 0; // Initialize another field to 0\n\n    // Check if the input parameter is null or empty\n    if ((param_1 == (byte *)0x0) || (*param_1 == 0)) {\n        // If a specific flag is not set\n        if (*(char *)((int)this + 0x2c) == '\\0') {\n            *(undefined *)((int)this + 0x2c) = 1; // Set the flag\n            *(undefined4 *)((int)this + 0x30) = 0xc; // Set an error code\n            charPointer = PTR_s_Error_document_empty__100344d8; // Pointer to error message\n            while (*charPointer != '\\0') { // Calculate the length of the error message\n                charPointer++;\n            }\n            // Call a function to handle the error message\n            FUN_1000bcc0((void *)((int)this + 0x34), PTR_s_Error_document_empty__100344d8,\n                         (int)charPointer - (int)(PTR_s_Error_document_empty__100344d8 + 1));\n            *(undefined4 *)((int)this + 0x40) = 0xffffffff; // Set an error field\n            *(undefined4 *)((int)this + 0x3c) = 0xffffffff; // Set another error field\n        }\n        return (byte *)0x0; // Return null if input is invalid\n    }\n\n    // Set fields based on the input parameters\n    *(undefined4 *)((int)this + 8) = 0xffffffff; // Initialize a field to -1\n    *(undefined4 *)((int)this + 4) = (param_2 == (undefined4 *)0x0) ? 0 : *param_2; // Set based on param_2\n    *(undefined4 *)((int)this + 8) = (param_2 == (undefined4 *)0x0) ? 0 : param_2[1]; // Set another field based on param_2\n\n    // Call a function to process the input data\n    FUN_1000e630(&localData1, (int)param_1, *(undefined4 *)((int)this + 0x38),\n                 *(undefined4 *)((int)this + 4), *(undefined4 *)((int)this + 8));\n    *(undefined4 *)((int)this + 4) = localData1; // Store the result\n    *(undefined4 *)((int)this + 8) = localData2; // Store another result\n\n    // Check for a specific byte order mark (BOM) in the input\n    if (((((param_3 == 0) && (*param_1 != 0)) && (*param_1 == 0xef)) &&\n         ((param_1[1] != 0 && (param_1[1] == 0xbb)))) && ((param_1[2] != 0 && (param_1[2] == 0xbf)))) {\n        param_3 = 1; // Set param_3 to indicate BOM found\n        *(undefined *)((int)this + 0x44) = 1; // Set a flag indicating BOM presence\n    }\n\n    // Call a function to further process the input data\n    bytePointer = FUN_1000e020(param_1, param_3);\n    if (bytePointer == (byte *)0x0) { // Check if processing failed\n        if (*(char *)((int)this + 0x2c) != '\\0') {\n            return (byte *)0x0; // Return null if an error flag is set\n        }\n        *(undefined *)((int)this + 0x2c) = 1; // Set the error flag\n        *(undefined4 *)((int)this + 0x30) = 0xc; // Set an error code\n        charPointer = PTR_s_Error_document_empty__100344d8; // Pointer to error message\n        while (*charPointer != '\\0') { // Calculate the length of the error message\n            charPointer++;\n        }\n    } else {\n        do {\n            // Check for termination conditions\n            if ((*bytePointer == 0) || (intPointer = FUN_1000e920(this, bytePointer, param_3), intPointer == (int *)0x0))\n                break; // Exit loop if no more data or processing fails\n            bytePointer = (byte *)(**(code **)(*intPointer + 8))(bytePointer, &localData1, param_3); // Process the data\n            FUN_1000c600(intPointer); // Clean up\n            // Check for additional processing based on conditions\n            if ((param_3 == 0) && (tempInt = (**(code **)(*intPointer + 0x34))(), tempInt != 0)) {\n                charPointer = (char *)(*(int *)(tempInt + 0x30) + 8); // Get a pointer to additional data\n                if (charPointer == (char *)0x0) {\n                    __wassert(L\"enc\", L\".\\\\tinyxmlparser.cpp\", 0x305); // Assertion failure if null\n                }\n                // Determine the encoding based on the data\n                param_3 = (*charPointer == '\\0') ? 1 : (FUN_1000e180(charPointer, \"UTF-8\", '\\x01', 0) == 0) ? 2 : 1;\n            }\n        } while ((bytePointer = FUN_1000e020(bytePointer, param_3)) != (byte *)0x0); // Continue processing\n\n        // Check if a specific field is set\n        if (*(int *)((int)this + 0x18) != 0) {\n            return bytePointer; // Return processed data if successful\n        }\n        if (*(char *)((int)this + 0x2c) != '\\0') {\n            return (byte *)0x0; // Return null if an error flag is set\n        }\n        *(undefined *)((int)this + 0x2c) = 1; // Set the error flag\n        *(undefined4 *)((int)this + 0x30) = 0xc; // Set an error code\n        charPointer = PTR_s_Error_document_empty__100344d8; // Pointer to error message\n        while (*charPointer != '\\0') { // Calculate the length of the error message\n            charPointer++;\n        }\n    }\n    \n    // Handle the error case by calling a function with the error message\n    FUN_1000bcc0((void *)((int)this + 0x34), PTR_s_Error_document_empty__100344d8,\n                 (int)charPointer - (int)(PTR_s_Error_document_empty__100344d8 + 1));\n    *(undefined4 *)((int)this + 0x40) = 0xffffffff; // Set an error field\n    *(undefined4 *)((int)this + 0x3c) = 0xffffffff; // Set another error field\n    return (byte *)0x0; // Return null at the end\n}\n*\\ \n \n\nbyte * __thiscall FUN_1000efa0(void *this, byte *param_1, undefined4 *param_2, int param_3)\n{\n    char tempChar;\n    byte *bytePointer;\n    char *charPointer;\n    int *intPointer;\n    int tempInt;\n    undefined4 undefinedVar;\n    undefined4 localData1;\n    undefined4 localData2;\n\n    *(undefined *)((int)this + 0x2c) = 0;\n    *(undefined4 *)((int)this + 0x30) = 0;\n    FUN_1000bcc0((void *)((int)this + 0x34), &PTR_1002bc68, 0);\n    *(undefined4 *)((int)this + 0x40) = 0;\n    *(undefined4 *)((int)this + 0x3c) = 0;\n\n    if ((param_1 == (byte *)0x0) || (*param_1 == 0)) {\n        if (*(char *)((int)this + 0x2c) == '\\0') {\n            *(undefined *)((int)this + 0x2c) = 1;\n            *(undefined4 *)((int)this + 0x30) = 0xc;\n            charPointer = PTR_s_Error_document_empty__100344d8;\n            while (*charPointer != '\\0') {\n                charPointer++;\n            }\n            FUN_1000bcc0((void *)((int)this + 0x34), PTR_s_Error_document_empty__100344d8,\n                         (int)charPointer - (int)(PTR_s_Error_document_empty__100344d8 + 1));\n            *(undefined4 *)((int)this + 0x40) = 0xffffffff;\n            *(undefined4 *)((int)this + 0x3c) = 0xffffffff;\n        }\n        return (byte *)0x0;\n    }\n\n    *(undefined4 *)((int)this + 8) = 0xffffffff;\n    *(undefined4 *)((int)this + 4) = (param_2 == (undefined4 *)0x0) ? 0 : *param_2;\n    *(undefined4 *)((int)this + 8) = (param_2 == (undefined4 *)0x0) ? 0 : param_2[1];\n\n    FUN_1000e630(&localData1, (int)param_1, *(undefined4 *)((int)this + 0x38),\n                 *(undefined4 *)((int)this + 4), *(undefined4 *)((int)this + 8));\n    *(undefined4 *)((int)this + 4) = localData1;\n    *(undefined4 *)((int)this + 8) = localData2;\n\n    if (((((param_3 == 0) && (*param_1 != 0)) && (*param_1 == 0xef)) &&\n         ((param_1[1] != 0 && (param_1[1] == 0xbb)))) && ((param_1[2] != 0 && (param_1[2] == 0xbf)))) {\n        param_3 = 1;\n        *(undefined *)((int)this + 0x44) = 1;\n    }\n\n    bytePointer = FUN_1000e020(param_1, param_3);\n    if (bytePointer == (byte *)0x0) {\n        if (*(char *)((int)this + 0x2c) != '\\0') {\n            return (byte *)0x0;\n        }\n        *(undefined *)((int)this + 0x2c) = 1;\n        *(undefined4 *)((int)this + 0x30) = 0xc;\n        charPointer = PTR_s_Error_document_empty__100344d8;\n        while (*charPointer != '\\0') {\n            charPointer++;\n        }\n    } else {\n        do {\n            if ((*bytePointer == 0) || (intPointer = FUN_1000e920(this, bytePointer, param_3), intPointer == (int *)0x0))\n                break;\n            bytePointer = (byte *)(**(code **)(*intPointer + 8))(bytePointer, &localData1, param_3);\n            FUN_1000c600(intPointer);\n            if ((param_3 == 0) && (tempInt = (**(code **)(*intPointer + 0x34))(), tempInt != 0)) {\n                charPointer = (char *)(*(int *)(tempInt + 0x30) + 8);\n                if (charPointer == (char *)0x0) {\n                    __wassert(L\"enc\", L\".\\\\tinyxmlparser.cpp\", 0x305);\n                }\n                param_3 = (*charPointer == '\\0') ? 1 : (FUN_1000e180(charPointer, \"UTF-8\", '\\x01', 0) == 0) ? 2 : 1;\n            }\n        } while ((bytePointer = FUN_1000e020(bytePointer, param_3)) != (byte *)0x0);\n        \n        if (*(int *)((int)this + 0x18) != 0) {\n            return bytePointer;\n        }\n        if (*(char *)((int)this + 0x2c) != '\\0') {\n            return (byte *)0x0;\n        }\n        *(undefined *)((int)this + 0x2c) = 1;\n        *(undefined4 *)((int)this + 0x30) = 0xc;\n        charPointer = PTR_s_Error_document_empty__100344d8;\n        while (*charPointer != '\\0') {\n            charPointer++;\n        }\n    }\n    \n    FUN_1000bcc0((void *)((int)this + 0x34), PTR_s_Error_document_empty__100344d8,\n                 (int)charPointer - (int)(PTR_s_Error_document_empty__100344d8 + 1));\n    *(undefined4 *)((int)this + 0x40) = 0xffffffff;\n    *(undefined4 *)((int)this + 0x3c) = 0xffffffff;\n    return (byte *)0x0;\n}\n"}
{"Function Name": "FUN_1000f590", "Address": "1000f590", "Source Code": "\\*\nbyte * __thiscall FUN_1000f590(void *this, byte *inputPointer, undefined4 *outputPointer, int count)\n{\n    byte *resultPointer1; // Pointer to hold the result of FUN_1000e020\n    byte *resultPointer2; // Pointer to hold the result of FUN_1000e0d0\n\n    resultPointer1 = FUN_1000e020(inputPointer, count); // Call FUN_1000e020 with param_1 and param_3\n    if ((resultPointer1 == (byte *)0x0) || (*resultPointer1 == 0)) { // Check if pbVar4 is null or points to zero\n        return (byte *)0x0; // Return null if the check fails\n    }\n    if (outputPointer != (undefined4 *)0x0) { // Check if param_2 is not null\n        FUN_1000dd80(outputPointer, resultPointer1, count); // Call FUN_1000dd80 with param_2, pbVar4, and param_3\n        *(undefined4 *)((int)this + 4) = *outputPointer; // Store the first value of param_2 in the object's memory\n        *(undefined4 *)((int)this + 8) = outputPointer[1]; // Store the second value of param_2 in the object's memory\n    }\n    resultPointer2 = FUN_1000e0d0(resultPointer1, (void *)((int)this + 0x14)); // Call FUN_1000e0d0 with pbVar4 and an offset of this\n    if ((resultPointer2 != (byte *)0x0) && (*resultPointer2 != 0)) { // Check if pbVar5 is not null and does not point to zero\n        resultPointer1 = FUN_1000e020(resultPointer2, count); // Call FUN_1000e020 with pbVar5 and param_3\n        if ((resultPointer1 == (byte *)0x0) || ((*resultPointer1 == 0 || (*resultPointer1 != 0x3d)))) { // Check if pbVar4 is null or does not equal '='\n            if (*(void **)((int)this + 0x10) == (void *)0x0) { // Check if the pointer at offset 0x10 is null\n                return (byte *)0x0; // Return null if the check fails\n            }\n            FUN_1000e270(*(void **)((int)this + 0x10), 6, resultPointer1, outputPointer, count); // Call FUN_1000e270 with the pointer at offset 0x10 and other parameters\n            return (byte *)0x0; // Return null after the call\n        }\n        resultPointer1 = FUN_1000e020(resultPointer1 + 1, count); // Call FUN_1000e020 with the next byte after pbVar4\n        if ((resultPointer1 != (byte *)0x0) && (*resultPointer1 != 0)) { // Check if pbVar4 is not null and does not point to zero\n            if (*resultPointer1 == 0x27) { // Check if the byte pointed by pbVar4 is a single quote\n                return FUN_1000edb0(resultPointer1 + 1, (void *)((int)this + 0x18), 0, \"\\'\", 0, count); // Call FUN_1000edb0 for single quote\n            } else if (*resultPointer1 == 0x22) { // Check if the byte pointed by pbVar4 is a double quote\n                return FUN_1000edb0(resultPointer1 + 1, (void *)((int)this + 0x18), 0, \"\\\"\", 0, count); // Call FUN_1000edb0 for double quote\n            }\n            FUN_1000be00((void *)((int)this + 0x18), (char *)&PTR_1002bc68); // Call FUN_1000be00 with an offset of this\n            while (true) { // Start an infinite loop\n                if (*resultPointer1 == 0) { // Check if the byte pointed by pbVar4 is zero\n                    return resultPointer1; // Return pbVar4 if it is zero\n                }\n                if (FUN_1000dc30(*resultPointer1) != '\\0') { // Check if FUN_1000dc30 returns non-zero for the byte pointed by pbVar4\n                    return resultPointer1; // Return pbVar4 if the check passes\n                }\n                if ((*resultPointer1 == 0x2f) || (*resultPointer1 == 0x3e)) { // Check if the byte is '/' or '>'\n                    break; // Break the loop if the check passes\n                }\n                if ((*resultPointer1 == 0x27) || (*resultPointer1 == 0x22)) { // Check if the byte is a single or double quote\n                    if (*(void **)((int)this + 0x10) == (void *)0x0) { // Check if the pointer at offset 0x10 is null\n                        return (byte *)0x0; // Return null if the check fails\n                    }\n                    FUN_1000e270(*(void **)((int)this + 0x10), 6, resultPointer1, outputPointer, count); // Call FUN_1000e270 with the pointer at offset 0x10 and other parameters\n                    return (byte *)0x0; // Return null after the call\n                }\n                count = CONCAT31(count._1_3_, *resultPointer1); // Concatenate the byte to param_3\n                FUN_1000bdb0((void *)((int)this + 0x18), &count, 1); // Call FUN_1000bdb0 with an offset of this and param_3\n                resultPointer1++; // Move to the next byte\n            }\n            return resultPointer1; // Return pbVar4 after exiting the loop\n        }\n    }\n    if (*(void **)((int)this + 0x10) == (void *)0x0) { // Check if the pointer at offset 0x10 is null\n        return (byte *)0x0; // Return null if the check fails\n    }\n    FUN_1000e270(*(void **)((int)this + 0x10), 6, resultPointer1, outputPointer, count); // Call FUN_1000e270 with the pointer at offset 0x10 and other parameters\n    return (byte *)0x0; // Return null after the call\n}\n*\\ \n \n\nbyte * __thiscall FUN_1000f590(void *this, byte *inputPointer, undefined4 *outputPointer, int count)\n{\n    byte *resultPointer1;\n    byte *resultPointer2;\n\n    resultPointer1 = FUN_1000e020(inputPointer, count);\n    if ((resultPointer1 == (byte *)0x0) || (*resultPointer1 == 0)) {\n        return (byte *)0x0;\n    }\n    if (outputPointer != (undefined4 *)0x0) {\n        FUN_1000dd80(outputPointer, resultPointer1, count);\n        *(undefined4 *)((int)this + 4) = *outputPointer;\n        *(undefined4 *)((int)this + 8) = outputPointer[1];\n    }\n    resultPointer2 = FUN_1000e0d0(resultPointer1, (void *)((int)this + 0x14));\n    if ((resultPointer2 != (byte *)0x0) && (*resultPointer2 != 0)) {\n        resultPointer1 = FUN_1000e020(resultPointer2, count);\n        if ((resultPointer1 == (byte *)0x0) || ((*resultPointer1 == 0 || (*resultPointer1 != 0x3d)))) {\n            if (*(void **)((int)this + 0x10) == (void *)0x0) {\n                return (byte *)0x0;\n            }\n            FUN_1000e270(*(void **)((int)this + 0x10), 6, resultPointer1, outputPointer, count);\n            return (byte *)0x0;\n        }\n        resultPointer1 = FUN_1000e020(resultPointer1 + 1, count);\n        if ((resultPointer1 != (byte *)0x0) && (*resultPointer1 != 0)) {\n            if (*resultPointer1 == 0x27) {\n                return FUN_1000edb0(resultPointer1 + 1, (void *)((int)this + 0x18), 0, \"\\'\", 0, count);\n            } else if (*resultPointer1 == 0x22) {\n                return FUN_1000edb0(resultPointer1 + 1, (void *)((int)this + 0x18), 0, \"\\\"\", 0, count);\n            }\n            FUN_1000be00((void *)((int)this + 0x18), (char *)&PTR_1002bc68);\n            while (true) {\n                if (*resultPointer1 == 0) {\n                    return resultPointer1;\n                }\n                if (FUN_1000dc30(*resultPointer1) != '\\0') {\n                    return resultPointer1;\n                }\n                if ((*resultPointer1 == 0x2f) || (*resultPointer1 == 0x3e)) {\n                    break;\n                }\n                if ((*resultPointer1 == 0x27) || (*resultPointer1 == 0x22)) {\n                    if (*(void **)((int)this + 0x10) == (void *)0x0) {\n                        return (byte *)0x0;\n                    }\n                    FUN_1000e270(*(void **)((int)this + 0x10), 6, resultPointer1, outputPointer, count);\n                    return (byte *)0x0;\n                }\n                count = CONCAT31(count._1_3_, *resultPointer1);\n                FUN_1000bdb0((void *)((int)this + 0x18), &count, 1);\n                resultPointer1++;\n            }\n            return resultPointer1;\n        }\n    }\n    if (*(void **)((int)this + 0x10) == (void *)0x0) {\n        return (byte *)0x0;\n    }\n    FUN_1000e270(*(void **)((int)this + 0x10), 6, resultPointer1, outputPointer, count);\n    return (byte *)0x0;\n}\n"}
{"Function Name": "FUN_1000f920", "Address": "1000f920", "Source Code": "\\*\nbyte * __thiscall FUN_1000f920(void *this, byte *param_1, int *param_2, int param_3)\n{\n    byte *bytePointer; // Pointer to byte variable for processing\n    int returnValue; // Integer variable for storing function return value\n    undefined4 checkResult; // Undefined 4-byte variable for storing function return value\n    char *errorMessagePointer; // Pointer to character for string manipulation\n    void *originalExceptionList; // Local variable to store the current ExceptionList\n\n    originalExceptionList = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &originalExceptionList; // Update ExceptionList to point to local_c\n    bytePointer = FUN_1000e020(param_1, param_3); // Call function to process param_1 with param_3\n    returnValue = FUN_1000bec0((int *)this); // Call function to get some integer value based on 'this'\n    \n    // Check if pbVar3 is null, points to zero, or fails XML declaration check\n    if ((bytePointer == (byte *)0x0) || (*bytePointer == 0) || (checkResult = FUN_1000e180((char *)bytePointer, \"<?xml\", '\\x01', param_3), (char)checkResult == '\\0')) {\n        // If iVar4 is non-zero and a specific condition is met\n        if ((returnValue != 0) && (*(char *)(returnValue + 0x2c) == '\\0')) {\n            *(undefined *)(returnValue + 0x2c) = 1; // Set a flag in the structure\n            *(undefined4 *)(returnValue + 0x30) = 0xb; // Set an error code\n            errorMessagePointer = PTR_s_Error_parsing_Declaration__100344d4; // Pointer to error message\n            while (*errorMessagePointer != '\\0') { // Find the end of the error message\n                errorMessagePointer++;\n            }\n            // Store the error message in the structure\n            FUN_1000bcc0((void *)(returnValue + 0x34), PTR_s_Error_parsing_Declaration__100344d4, (int)errorMessagePointer - (int)(PTR_s_Error_parsing_Declaration__100344d4 + 1));\n            *(undefined4 *)(returnValue + 0x40) = 0xffffffff; // Set additional error flags\n            *(undefined4 *)(returnValue + 0x3c) = 0xffffffff; // Set additional error flags\n        }\n    } else {\n        // If param_2 is not null, process the data\n        if (param_2 != (int *)0x0) {\n            FUN_1000dd80(param_2, bytePointer, param_3); // Call function to fill param_2 with data\n            *(int *)((int)this + 4) = *param_2; // Store first value in 'this'\n            *(int *)((int)this + 8) = param_2[1]; // Store second value in 'this'\n        }\n        bytePointer += 5; // Move the pointer past the initial bytes\n        // Initialize some structures in 'this'\n        FUN_1000bcc0((void *)((int)this + 0x2c), &PTR_1002bc68, 0);\n        FUN_1000bcc0((void *)((int)this + 0x30), &PTR_1002bc68, 0);\n        FUN_1000bcc0((void *)((int)this + 0x34), &PTR_1002bc68, 0);\n        \n        // Loop to process the XML declaration\n        while ((bytePointer != (byte *)0x0) && (*bytePointer != 0)) {\n            if (*bytePointer == 0x3e) { // Check for closing angle bracket\n                ExceptionList = originalExceptionList; // Restore the original ExceptionList\n                return bytePointer + 1; // Return the pointer to the next byte\n            }\n            bytePointer = FUN_1000e020(bytePointer, param_3); // Process the next part of pbVar3\n            checkResult = FUN_1000e180((char *)bytePointer, \"version\", '\\x01', param_3); // Check for 'version'\n            if ((char)checkResult == '\\0') { // If 'version' not found\n                checkResult = FUN_1000e180((char *)bytePointer, \"encoding\", '\\x01', param_3); // Check for 'encoding'\n                if ((char)checkResult == '\\0') { // If 'encoding' not found\n                    checkResult = FUN_1000e180((char *)bytePointer, \"standalone\", '\\x01', param_3); // Check for 'standalone'\n                    if ((char)checkResult == '\\0') { // If 'standalone' not found\n                        while (true) { // Loop to skip whitespace and other characters\n                            if (bytePointer == (byte *)0x0) { // If pbVar3 is null\n                                ExceptionList = originalExceptionList; // Restore the original ExceptionList\n                                return (byte *)0x0; // Return null\n                            }\n                            byte bVar2 = *bytePointer; // Get the current byte\n                            // Break if we hit end of string, closing bracket, or whitespace\n                            if ((bVar2 == 0) || (bVar2 == 0x3e) || (_isspace((uint)bVar2) != 0) || (bVar2 == 10 || (bVar2 == 0xd)))) break;\n                            bytePointer++; // Move to the next byte\n                        }\n                    } else {\n                        FUN_1000c200(local_30); // Prepare local storage for 'encoding'\n                        bytePointer = FUN_1000f590(local_30, bytePointer, param_2, param_3); // Process 'encoding'\n                        errorMessagePointer = (char *)(local_18 + 8); // Pointer to the processed encoding\n                        while (*errorMessagePointer != '\\0') { // Find the end of the encoding string\n                            errorMessagePointer++;\n                        }\n                        // Store the encoding in the structure\n                        FUN_1000bcc0((void *)((int)this + 0x34), (char *)(local_18 + 8), (int)errorMessagePointer - (local_18 + 9));\n                        FUN_1000c280(local_30); // Clean up local storage\n                    }\n                } else {\n                    FUN_1000c200(local_54); // Prepare local storage for 'version'\n                    bytePointer = FUN_1000f590(local_54, bytePointer, param_2, param_3); // Process 'version'\n                    errorMessagePointer = (char *)(local_3c + 8); // Pointer to the processed version\n                    while (*errorMessagePointer != '\\0') { // Find the end of the version string\n                        errorMessagePointer++;\n                    }\n                    // Store the version in the structure\n                    FUN_1000bcc0((void *)((int)this + 0x30), (char *)(local_3c + 8), (int)errorMessagePointer - (local_3c + 9));\n                    FUN_1000c280(local_54); // Clean up local storage\n                }\n            } else {\n                FUN_1000c200(local_78); // Prepare local storage for 'standalone'\n                bytePointer = FUN_1000f590(local_78, bytePointer, param_2, param_3); // Process 'standalone'\n                errorMessagePointer = (char *)(local_60 + 8); // Pointer to the processed standalone\n                while (*errorMessagePointer != '\\0') { // Find the end of the standalone string\n                    errorMessagePointer++;\n                }\n                // Store the standalone in the structure\n                FUN_1000bcc0((void *)((int)this + 0x2c), (char *)(local_60 + 8), (int)errorMessagePointer - (local_60 + 9));\n                FUN_1000c280(local_78); // Clean up local storage\n            }\n        }\n    }\n    ExceptionList = originalExceptionList; // Restore the original ExceptionList\n    return (byte *)0x0; // Return null if no valid data found\n}\n*\\ \n \n\nbyte * __thiscall FUN_1000f920(void *this, byte *param_1, int *param_2, int param_3)\n{\n    byte *bytePointer;\n    int returnValue;\n    undefined4 checkResult;\n    char *errorMessagePointer;\n    void *originalExceptionList;\n\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    bytePointer = FUN_1000e020(param_1, param_3);\n    returnValue = FUN_1000bec0((int *)this);\n    \n    if ((bytePointer == (byte *)0x0) || (*bytePointer == 0) || (checkResult = FUN_1000e180((char *)bytePointer, \"<?xml\", '\\x01', param_3), (char)checkResult == '\\0')) {\n        if ((returnValue != 0) && (*(char *)(returnValue + 0x2c) == '\\0')) {\n            *(undefined *)(returnValue + 0x2c) = 1;\n            *(undefined4 *)(returnValue + 0x30) = 0xb;\n            errorMessagePointer = PTR_s_Error_parsing_Declaration__100344d4;\n            while (*errorMessagePointer != '\\0') {\n                errorMessagePointer++;\n            }\n            FUN_1000bcc0((void *)(returnValue + 0x34), PTR_s_Error_parsing_Declaration__100344d4, (int)errorMessagePointer - (int)(PTR_s_Error_parsing_Declaration__100344d4 + 1));\n            *(undefined4 *)(returnValue + 0x40) = 0xffffffff;\n            *(undefined4 *)(returnValue + 0x3c) = 0xffffffff;\n        }\n    } else {\n        if (param_2 != (int *)0x0) {\n            FUN_1000dd80(param_2, bytePointer, param_3);\n            *(int *)((int)this + 4) = *param_2;\n            *(int *)((int)this + 8) = param_2[1];\n        }\n        bytePointer += 5;\n        FUN_1000bcc0((void *)((int)this + 0x2c), &PTR_1002bc68, 0);\n        FUN_1000bcc0((void *)((int)this + 0x30), &PTR_1002bc68, 0);\n        FUN_1000bcc0((void *)((int)this + 0x34), &PTR_1002bc68, 0);\n        \n        while ((bytePointer != (byte *)0x0) && (*bytePointer != 0)) {\n            if (*bytePointer == 0x3e) {\n                ExceptionList = originalExceptionList;\n                return bytePointer + 1;\n            }\n            bytePointer = FUN_1000e020(bytePointer, param_3);\n            checkResult = FUN_1000e180((char *)bytePointer, \"version\", '\\x01', param_3);\n            if ((char)checkResult == '\\0') {\n                checkResult = FUN_1000e180((char *)bytePointer, \"encoding\", '\\x01', param_3);\n                if ((char)checkResult == '\\0') {\n                    checkResult = FUN_1000e180((char *)bytePointer, \"standalone\", '\\x01', param_3);\n                    if ((char)checkResult == '\\0') {\n                        while (true) {\n                            if (bytePointer == (byte *)0x0) {\n                                ExceptionList = originalExceptionList;\n                                return (byte *)0x0;\n                            }\n                            byte bVar2 = *bytePointer;\n                            if ((bVar2 == 0) || (bVar2 == 0x3e) || (_isspace((uint)bVar2) != 0) || (bVar2 == 10 || (bVar2 == 0xd)))) break;\n                            bytePointer++;\n                        }\n                    } else {\n                        FUN_1000c200(local_30);\n                        bytePointer = FUN_1000f590(local_30, bytePointer, param_2, param_3);\n                        errorMessagePointer = (char *)(local_18 + 8);\n                        while (*errorMessagePointer != '\\0') {\n                            errorMessagePointer++;\n                        }\n                        FUN_1000bcc0((void *)((int)this + 0x34), (char *)(local_18 + 8), (int)errorMessagePointer - (local_18 + 9));\n                        FUN_1000c280(local_30);\n                    }\n                } else {\n                    FUN_1000c200(local_54);\n                    bytePointer = FUN_1000f590(local_54, bytePointer, param_2, param_3);\n                    errorMessagePointer = (char *)(local_3c + 8);\n                    while (*errorMessagePointer != '\\0') {\n                        errorMessagePointer++;\n                    }\n                    FUN_1000bcc0((void *)((int)this + 0x30), (char *)(local_3c + 8), (int)errorMessagePointer - (local_3c + 9));\n                    FUN_1000c280(local_54);\n                }\n            } else {\n                FUN_1000c200(local_78);\n                bytePointer = FUN_1000f590(local_78, bytePointer, param_2, param_3);\n                errorMessagePointer = (char *)(local_60 + 8);\n                while (*errorMessagePointer != '\\0') {\n                    errorMessagePointer++;\n                }\n                FUN_1000bcc0((void *)((int)this + 0x2c), (char *)(local_60 + 8), (int)errorMessagePointer - (local_60 + 9));\n                FUN_1000c280(local_78);\n            }\n        }\n    }\n    ExceptionList = originalExceptionList;\n    return (byte *)0x0;\n}\n"}
{"Function Name": "__Tolower", "Address": "1000fc1e", "Source Code": "\nint __cdecl __Tolower(int input_char, _Ctypevec *ctype_vector)\n{\n    ushort conversion_flag; // Variable to hold a ushort value\n    uint *locale_handle_ptr; // Pointer to a uint\n    short *code_page_ptr; // Pointer to the code page\n    int return_value; // Variable to hold an integer return value\n    ushort *char_type_ptr; // Pointer to a ushort\n    LPCWSTR wide_char_string; // Local variable for wide character string\n    byte byte_value; // Local variable for byte\n\n    // Check if param_2 is null\n    if (ctype_vector == (_Ctypevec *)0x0) {\n        locale_handle_ptr = ____lc_handle_func(); // Get locale handle\n        wide_char_string = (LPCWSTR)locale_handle_ptr[2]; // Get the wide character string from locale handle\n        code_page_ptr = (short *)____lc_codepage_func(); // Get the code page\n    } else {\n        wide_char_string = (LPCWSTR)ctype_vector->_Page; // Use the page from param_2\n        code_page_ptr = ctype_vector->_Table; // Use the table from param_2\n    }\n\n    // Check if local_10 is null\n    if (wide_char_string == (LPCWSTR)0x0) {\n        // If param_1 is outside the range for uppercase letters, return it as is\n        return (0x19 < input_char - 0x41U) ? input_char : input_char + 0x20; // Convert to lowercase if applicable\n    }\n\n    // Check if param_1 is less than 256 (single byte character)\n    if ((uint)input_char < 0x100) {\n        // If param_2 is not null\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            // Check if the character is not a letter that needs to be converted\n            if ((*(byte *)(ctype_vector->_Delfl + input_char * 2) & 1) == 0) {\n                return input_char; // Return the character as is\n            }\n        } else if (_isupper(input_char) == 0) {\n            return input_char; // Return the character as is if it's not uppercase\n        }\n    } else {\n        // For characters outside the single byte range\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            // Get the conversion flag from param_2\n            conversion_flag = *(ushort *)(ctype_vector->_Delfl + (input_char >> 8 & 0xffU) * 2) >> 0xf;\n        } else {\n            char_type_ptr = ___pctype_func(); // Get the character type function\n            conversion_flag = char_type_ptr[input_char >> 8 & 0xff] & 0x8000; // Check the conversion flag\n        }\n    }\n\n    // Check if the conversion flag indicates that conversion is needed\n    if (conversion_flag == 0) {\n        ctype_vector->_0_2_ = (ushort)(byte)input_char; // Store the character in param_2\n        return_value = 1; // Set return value for single character\n    } else {\n        ctype_vector->_0_2_ = (ushort)input_char; // Store the character in param_2\n        ctype_vector->_0_3_ = (uint3)(ushort)ctype_vector; // Store additional information in param_2\n        return_value = 2; // Set return value for multiple characters\n    }\n\n    // Call the locale-specific string mapping function\n    return_value = ___crtLCMapStringA((_locale_t)0x0, wide_char_string, 0x100, (LPCSTR)&ctype_vector, return_value, (LPSTR)&byte_value, 3, (int)code_page_ptr, 1);\n    // Check if the mapping function succeeded\n    if (return_value != 0) {\n        // Update param_1 based on the result of the mapping\n        input_char = (return_value == 1) ? (int)byte_value : (int)CONCAT11(byte_value, local_7);\n    }\n    \n    return input_char; // Return the converted character\n}\n"}
{"Function Name": "__Getctype", "Address": "1000fd2d", "Source Code": "\\*\n_Ctypevec * __cdecl __Getctype(_Ctypevec *returnStorage)\n{\n    // Get the locale handle using a function\n    uint *localeHandle = ____lc_handle_func();\n    \n    // Get the code page using a function\n    short *codePage = (short *)____lc_codepage_func();\n    \n    // Allocate memory for the character type table (256 entries, 2 bytes each)\n    void *charTypeTable = __calloc_crt(0x100, 2);\n    \n    // Set the page in the return storage structure\n    returnStorage->_Page = localeHandle[1];\n    \n    // Set the character type table in the return storage structure\n    returnStorage->_Table = codePage;\n    \n    // Set the deletion flag pointer in the return storage structure\n    returnStorage->_Delfl = (int)charTypeTable;\n\n    // Check if memory allocation was successful\n    if (charTypeTable == (void *)0x0) {\n        // If allocation failed, set locale name to null\n        returnStorage->_LocaleName = (wchar_t *)0x0;\n        \n        // Set deletion flag to the default character type function\n        returnStorage->_Delfl = (int)___pctype_func();\n    } else {\n        // If allocation succeeded, copy the character type data to the allocated memory\n        _memcpy((void *)returnStorage->_Delfl, ___pctype_func(), 0x200);\n        \n        // Set locale name to a valid pointer\n        returnStorage->_LocaleName = (wchar_t *)0x1;\n    }\n    \n    // Return the populated _Ctypevec structure\n    return returnStorage;\n}\n*\\ \n \n\n_Ctypevec * __cdecl __Getctype(_Ctypevec *returnStorage)\n{\n    uint *localeHandle = ____lc_handle_func();\n    short *codePage = (short *)____lc_codepage_func();\n    void *charTypeTable = __calloc_crt(0x100, 2);\n    \n    returnStorage->_Page = localeHandle[1];\n    returnStorage->_Table = codePage;\n    returnStorage->_Delfl = (int)charTypeTable;\n\n    if (charTypeTable == (void *)0x0) {\n        returnStorage->_LocaleName = (wchar_t *)0x0;\n        returnStorage->_Delfl = (int)___pctype_func();\n    } else {\n        _memcpy((void *)returnStorage->_Delfl, ___pctype_func(), 0x200);\n        returnStorage->_LocaleName = (wchar_t *)0x1;\n    }\n    \n    return returnStorage;\n}\n"}
{"Function Name": "FUN_1000fdb7", "Address": "1000fdb7", "Source Code": "\nvoid FUN_1000fdb7(void)\n{\n    // Decrement the value at DAT_10034524 atomically and check if it is less than 0\n    if (InterlockedDecrement((LONG *)&shared_counter) < 0) {\n        // Define a pointer to a CRITICAL_SECTION structure\n        LPCRITICAL_SECTION current_section = (LPCRITICAL_SECTION)&critical_section_array;\n        // Loop through the critical sections until reaching the end address\n        do {\n            // Call the function FUN_100103a5 with the current critical section\n            FUN_100103a5(current_section);\n            // Move to the next critical section\n            current_section++;\n        } while ((int)current_section < 0x10035ac8); // Continue until the end address is reached\n    }\n}\n"}
{"Function Name": "std::_Lockit::_Lockit", "Address": "1000fde0", "Source Code": "\\*\nLockGuard * __thiscall std::LockGuard::LockGuard(LockGuard *instance, int inputValue)\n{\n    // Store the lower 2 bits of param_1 in the current instance\n    *(uint *)instance = inputValue & 3U;\n\n    // Call a function with a pointer to a critical section based on the stored value\n    callCriticalSectionFunction((LPCRITICAL_SECTION)(&criticalSectionBase + (*(uint *)instance) * 0x18));\n\n    // Return the current instance\n    return instance;\n}\n*\\ \n \n\nLockGuard * __thiscall std::LockGuard::LockGuard(LockGuard *instance, int inputValue)\n{\n    *(uint *)instance = inputValue & 3U;\n    callCriticalSectionFunction((LPCRITICAL_SECTION)(&criticalSectionBase + (*(uint *)instance) * 0x18));\n    return instance;\n}\n"}
{"Function Name": "FUN_1000fe01", "Address": "1000fe01", "Source Code": "\nvoid __fastcall FUN_1000fe01(int *critical_section_offset)\n{\n    // Call the function FUN_100103bb with a pointer to a CRITICAL_SECTION\n    // The pointer is calculated by adding the base address DAT_10035a68\n    // to the offset determined by the value pointed to by param_1 multiplied by 0x18.\n    FUN_100103bb((LPCRITICAL_SECTION)(&DAT_10035a68 + *critical_section_offset * 0x18));\n}\n"}
{"Function Name": "std::_Fac_node::~_Fac_node", "Address": "1000fe13", "Source Code": "\nvoid __thiscall std::_Fac_node::~_Fac_node(_Fac_node *currentNode)\n{\n    // Retrieve a pointer to an undefined4 type using a value from the current object\n    undefined4 *undefinedPointer = (undefined4 *)FUN_10001890(*(uint *)(currentNode + 4));\n    \n    // Check if the retrieved pointer is not null\n    if (undefinedPointer != (undefined4 *)0x0) {\n        // Call a function pointed to by the first element of puVar1 with an argument of 1\n        (**(code **)*undefinedPointer)(1);\n    }\n}\n"}
{"Function Name": "_tidy_global", "Address": "1000fe44", "Source Code": "\nvoid tidyGlobal(void)\n{\n    // Acquire a lock to ensure thread safety while modifying global data\n    std::_Lockit::LockGuard((_Lockit *)&globalData, 0);\n    \n    // Delete the global locale associated with the specified data\n    deleteGlobalLocale(&globalData);\n    \n    // Reset the global data to zero\n    globalData = 0;\n    \n    // Call a function to perform additional cleanup or operations on the global data\n    performCleanup(&globalData);\n}\n"}
{"Function Name": "FUN_1000fe6e", "Address": "1000fe6e", "Source Code": "\nundefined4 getGlobalValue(void) // Function definition with return type undefined4\n{\n    return globalVariable; // Return the value of the global variable DAT_10035ad0\n}\n"}
{"Function Name": "std::locale::_Setgloballocale", "Address": "1000fe74", "Source Code": "\nvoid __cdecl std::locale::_Setgloballocale(void *locale_param)\n{\n    // Check if the global flag DAT_10035af4 is not set\n    if (is_initialized == '\\0') {\n        // Set the global flag DAT_10035af4 to indicate initialization\n        is_initialized = '\\x01';\n        // Register the cleanup function _tidy_global to be called at program exit\n        _Atexit(_tidy_global);\n    }\n    // Set the global variable DAT_10035ad0 to the provided parameter\n    global_locale = locale_param;\n}\n"}
{"Function Name": "std::locale::_Locimp::_Locimp_dtor", "Address": "1000fe99", "Source Code": "\nvoid __cdecl std::locale::_Locimp::_Locimp_dtor(_Locimp *localeImplementation)\n{\n    uint *itemPointer; // Pointer to an unsigned integer\n    undefined4 *functionPointer; // Pointer to an undefined 4-byte type\n    int itemCount; // Integer variable for loop control\n    int lockArray[3]; // Local array for locking mechanism\n    _Lockit::_Lockit((_Lockit *)lockArray, 0); // Initialize lock for thread safety\n    itemCount = *(int *)(localeImplementation + 0xc); // Get the count of items to process from the structure\n    while (itemCount != 0) { // Loop until all items are processed\n        itemCount--; // Decrement the item count\n        itemPointer = (uint *)(*(int *)(localeImplementation + 8) + itemCount * 4); // Calculate the address of the current item\n        if (*itemPointer != 0) { // Check if the current item is not null\n            functionPointer = (undefined4 *)FUN_10001890(*itemPointer); // Call a function to get a pointer based on the item\n            if (functionPointer != (undefined4 *)0x0) { // Check if the function returned a valid pointer\n                (**(code **)*functionPointer)(1); // Call the function pointed to by puVar2 with argument 1\n            }\n        }\n    }\n    _free(*(void **)(localeImplementation + 8)); // Free the memory allocated for the items\n    FUN_1000fe01(lockArray); // Release the lock and perform cleanup\n}\n"}
{"Function Name": "__Fac_tidy", "Address": "1000fef9", "Source Code": "\nvoid __Fac_tidy(void)\n{\n    undefined4 *currentNode = headPointer; // Initialize 'this' pointer to the head of the linked list\n    int lockVariable; // Local variable for locking mechanism\n    std::_Lockit::_Lockit((_Lockit *)&lockVariable, 0); // Acquire lock to ensure thread safety\n    while (currentNode != (undefined4 *)0x0) { // Loop until 'this' pointer is null\n        headPointer = (undefined4 *)*currentNode; // Update head pointer to the next node\n        std::_Fac_node::~_Fac_node((_Fac_node *)currentNode); // Call destructor for the current node\n        freeMemory(currentNode); // Free memory allocated for the current node\n        currentNode = headPointer; // Move to the next node in the list\n    }\n    releaseLock(&lockVariable); // Release the lock\n    return; // Exit the function\n}\n"}
{"Function Name": "std::locale::facet::facet_Register", "Address": "1000ff3c", "Source Code": "\nvoid __cdecl std::locale::facet::facet_Register(facet *facet_param)\n{\n    // Check if the global pointer DAT_10035acc is null\n    if (global_facet_pointer == (int *)0x0) {\n        // Register the cleanup function __Fac_tidy to be called at program exit\n        _Atexit(__Fac_tidy);\n    }\n    \n    // Allocate memory for an integer array of size 2 (8 bytes)\n    global_facet_pointer = (int *)operator_new(8);\n    \n    // Check if memory allocation was successful\n    if (global_facet_pointer != (int *)0x0) {\n        // Store the address of DAT_10035acc in the first element\n        global_facet_pointer[0] = (int)global_facet_pointer;\n        // Store the passed parameter param_1 in the second element\n        global_facet_pointer[1] = (int)facet_param;\n    }\n    \n    // Exit the function\n    return;\n}\n"}
{"Function Name": "std::_Locinfo::_Locinfo_dtor", "Address": "1000ff75", "Source Code": "\nvoid __cdecl std::_Locinfo::_Locinfo_dtor(_Locinfo *locinfo)\n{\n    // Check if the integer at offset 0x50 of param_1 is not zero\n    if (*(int *)(locinfo + 0x50) != 0) {\n        // Determine the locale based on the value at offset 0x54\n        _Locinfo *locale = (*(uint *)(locinfo + 0x54) < 0x10) ? (locinfo + 0x40) : *(_Locinfo **)(locinfo + 0x40);\n        // Set the locale to the determined value\n        _setlocale(0, (char *)locale);\n    }\n}\n"}
{"Function Name": "std::locale::_Locimp::_Locimp", "Address": "1000ff98", "Source Code": "\\*\nLocaleImplementation * __thiscall std::locale::LocaleImplementation::LocaleImplementation(LocaleImplementation *instance, bool isEnabled)\n{\n    // Set the first member of the _Locimp structure to 1\n    *(undefined4 *)(instance + 4) = 1;\n\n    // Initialize the second member of the _Locimp structure to 0\n    *(undefined4 *)(instance + 8) = 0;\n\n    // Initialize the third member of the _Locimp structure to 0\n    *(undefined4 *)(instance + 0xc) = 0;\n\n    // Set the virtual function table pointer for the _Locimp instance\n    *(undefined ***)instance = vftable;\n\n    // Store the boolean parameter in the 0x14 offset of the _Locimp structure\n    instance[0x14] = (_Locimp)isEnabled;\n\n    // Call a function with the address of the next member and a string literal\n    FUN_10004a20(instance + 0x18, \"*\");\n\n    // Return the initialized _Locimp instance\n    return instance;\n}\n*\\ \n \n\nLocaleImplementation * __thiscall std::locale::LocaleImplementation::LocaleImplementation(LocaleImplementation *instance, bool isEnabled)\n{\n    *(undefined4 *)(instance + 4) = 1;\n    *(undefined4 *)(instance + 8) = 0;\n    *(undefined4 *)(instance + 0xc) = 0;\n    *(undefined ***)instance = vftable;\n    instance[0x14] = (_Locimp)isEnabled;\n    FUN_10004a20(instance + 0x18, \"*\");\n    return instance;\n}\n"}
{"Function Name": "std::locale::_Locimp::~_Locimp", "Address": "1000ffe1", "Source Code": "\nvoid __thiscall std::locale::Locimp_instance::~Locimp_instance(_Locimp *current_object)\n{\n    // Set the vtable pointer for the current object to the base class vtable\n    *(undefined ***)current_object = base_class_vtable;\n\n    // Call the destructor for the _Locimp class\n    Locimp_destructor(current_object);\n\n    // Call a function with the current object pointer, a flag, and a value\n    function_call(current_object + 0x18, '\\x01', 0);\n\n    // Restore the vtable pointer for the current object to the facet class vtable\n    *(undefined ***)current_object = facet::base_class_vtable;\n}\n"}
{"Function Name": "std::locale::_Locimp::`scalar_deleting_destructor'", "Address": "1001001e", "Source Code": "\nvoid * __thiscall std::locale::locale_impl::_scalar_deleting_destructor_(_Locimp *this, uint flag)\n{\n    // Call the destructor for the _Locimp object\n    ~locale_impl(this);\n    \n    // Check if the first bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for the _Locimp object\n        _free(this);\n    }\n    \n    // Return the pointer to the _Locimp object\n    return this;\n}\n"}
{"Function Name": "std::locale::_Init", "Address": "1001003a", "Source Code": "\\*\n_Locimp * __cdecl std::locale::_Init(void)\n{\n    // Declare a pointer to _Locimp and initialize it with a global variable\n    _Locimp *localePointer = globalLocalePointer;\n\n    // Check if the pointer is null (not initialized)\n    if (localePointer == (_Locimp *)0x0) {\n        // Lock the current thread to prevent concurrent access\n        _Lockit::_Lockit((_Lockit *)0, 0);\n\n        // Allocate memory for a new _Locimp object\n        localePointer = (_Locimp *)operator_new(0x34);\n\n        // Check if memory allocation was successful\n        if (localePointer != (_Locimp *)0x0) {\n            // Initialize the _Locimp object\n            _Locimp::_Locimp(localePointer, false);\n\n            // Set the global locale to the newly created _Locimp object\n            _Setgloballocale(localePointer);\n\n            // Set a specific value in the _Locimp object\n            *(undefined4 *)(localePointer + 0x10) = 0x3f;\n\n            // Call a function to initialize additional data in the _Locimp object\n            FUN_10004160(localePointer + 0x18, (undefined4 *)&DAT_1002bd6c);\n\n            // Store the pointer to the newly created _Locimp object in a global variable\n            newLocalePointer = localePointer;\n\n            // Call a function to perform additional setup with the _Locimp object\n            FUN_10001820((int)localePointer);\n\n            // Update another global variable with the new locale\n            currentLocale = newLocalePointer;\n        }\n    }\n\n    // Return the pointer to the _Locimp object (either newly created or existing)\n    return localePointer;\n}\n*\\ \n \n\n_Locimp * __cdecl std::locale::_Init(void)\n{\n    _Locimp *localePointer = globalLocalePointer;\n    if (localePointer == (_Locimp *)0x0) {\n        _Lockit::_Lockit((_Lockit *)0, 0);\n        localePointer = (_Locimp *)operator_new(0x34);\n        if (localePointer != (_Locimp *)0x0) {\n            _Locimp::_Locimp(localePointer, false);\n            _Setgloballocale(localePointer);\n            *(undefined4 *)(localePointer + 0x10) = 0x3f;\n            FUN_10004160(localePointer + 0x18, (undefined4 *)&DAT_1002bd6c);\n            newLocalePointer = localePointer;\n            FUN_10001820((int)localePointer);\n            currentLocale = newLocalePointer;\n        }\n    }\n    return localePointer;\n}\n"}
{"Function Name": "std::_Locinfo::_Locinfo_ctor", "Address": "100100d4", "Source Code": "\nvoid __cdecl std::_Locinfo::_Locinfo_ctor(_Locinfo *locinfo, char *locale_string)\n{\n    // Retrieve the current locale setting; if it fails, use a default pointer\n    undefined **current_locale = (undefined **)_setlocale(0, (char *)0x0);\n    if (current_locale == (undefined **)0x0) {\n        current_locale = &PTR_1002bc68; // Assign default locale pointer if retrieval failed\n    }\n    // Call a function to initialize part of the _Locinfo structure with the locale\n    FUN_10004160(locinfo + 0x3c, current_locale);\n\n    // Retrieve the locale specified by param_2; if it fails, use a default value\n    undefined4 *specified_locale = (undefined4 *)_setlocale(0, locale_string);\n    if (specified_locale == (undefined4 *)0x0) {\n        specified_locale = (undefined4 *)&DAT_1002d08c; // Assign default locale value if retrieval failed\n    }\n    // Call a function to initialize another part of the _Locinfo structure with the specified locale\n    FUN_10004160(locinfo + 0x58, specified_locale);\n    return; // Exit the constructor function\n}\n"}
{"Function Name": "std::ios_base::_Callfns", "Address": "1001011e", "Source Code": "\nvoid __thiscall std::ios_base::_Callfns(ios_base *iosBase, event eventParam)\n{\n    // Retrieve the pointer to the first function in the list of functions\n    undefined4 *functionPtr = *(undefined4 **)(iosBase + 0x20);\n    \n    // Loop through the list of functions until a null pointer is encountered\n    while (functionPtr != (undefined4 *)0x0) {\n        // Call the function pointed to by puVar1[2] with parameters param_1, this, and puVar1[1]\n        (*(code *)functionPtr[2])(eventParam, iosBase, functionPtr[1]);\n        \n        // Move to the next function in the list\n        functionPtr = (undefined4 *)*functionPtr;\n    }\n}\n"}
{"Function Name": "std::ios_base::_Tidy", "Address": "10010140", "Source Code": "\nvoid __thiscall std::ios_base::_Tidy(ios_base *this)\n{\n    undefined4 *nextElement; // Pointer to hold the next element in the linked list\n    undefined4 *currentElement; // Pointer to traverse the linked list\n\n    _Callfns(this, 0); // Call cleanup functions for the ios_base object\n    \n    currentElement = *(undefined4 **)(this + 0x1c); // Get the first element of the first linked list\n    while (currentElement != (undefined4 *)0x0) { // Loop until the end of the linked list\n        nextElement = (undefined4 *)*currentElement; // Store the next element\n        _free(currentElement); // Free the current element\n        currentElement = nextElement; // Move to the next element\n    }\n    *(undefined4 *)(this + 0x1c) = 0; // Set the head of the first linked list to null\n\n    currentElement = *(undefined4 **)(this + 0x20); // Get the first element of the second linked list\n    while (currentElement != (undefined4 *)0x0) { // Loop until the end of the linked list\n        nextElement = (undefined4 *)*currentElement; // Store the next element\n        _free(currentElement); // Free the current element\n        currentElement = nextElement; // Move to the next element\n    }\n    *(undefined4 *)(this + 0x20) = 0; // Set the head of the second linked list to null\n}\n"}
{"Function Name": "std::ios_base::_Ios_base_dtor", "Address": "10010186", "Source Code": "\nvoid __cdecl std::ios_base::_Ios_base_dtor(ios_base *iosBasePtr)\n{\n    // Check if the reference count is zero or if it decrements below one\n    if ((*(int *)(iosBasePtr + 4) == 0) ||\n        ((&referenceCountArray)[*(int *)(iosBasePtr + 4)]-- < 1)) {\n        \n        // Call the cleanup function for the ios_base object\n        _Tidy(iosBasePtr);\n        \n        // Retrieve the memory pointer associated with the ios_base object\n        uint *memoryPointer = *(uint **)(iosBasePtr + 0x24);\n        \n        // If the memory pointer is not null, proceed to free the memory\n        if (memoryPointer != (uint *)0x0) {\n            // Call a function to handle specific memory cleanup\n            memoryCleanupFunction(memoryPointer);\n            // Free the allocated memory\n            freeMemoryFunction(memoryPointer);\n        }\n    }\n}\n"}
{"Function Name": "FUN_100101c4", "Address": "100101c4", "Source Code": "\\*\nLPCRITICAL_SECTION * __fastcall FUN_100101c4(LPCRITICAL_SECTION *critical_section_ptr)\n{\n    // Allocate memory for a CRITICAL_SECTION structure (24 bytes)\n    *critical_section_ptr = (LPCRITICAL_SECTION)operator_new(0x18);\n    \n    // Initialize the newly allocated CRITICAL_SECTION\n    FUN_1001039a(*critical_section_ptr);\n    \n    // Return the pointer to the allocated CRITICAL_SECTION\n    return critical_section_ptr;\n}\n*\\ \n \n\nLPCRITICAL_SECTION * __fastcall FUN_100101c4(LPCRITICAL_SECTION *critical_section_ptr)\n{\n    *critical_section_ptr = (LPCRITICAL_SECTION)operator_new(0x18);\n    FUN_1001039a(*critical_section_ptr);\n    return critical_section_ptr;\n}\n"}
{"Function Name": "FUN_100101dc", "Address": "100101dc", "Source Code": "\nvoid __fastcall FUN_100101dc(LPCRITICAL_SECTION *criticalSectionPtr)\n{\n    // Call the function FUN_100103a5 with the dereferenced pointer param_1\n    FUN_100103a5(*criticalSectionPtr);\n    \n    // Free the memory allocated for the critical section pointed to by param_1\n    _free(*criticalSectionPtr);\n}\n"}
{"Function Name": "FUN_100101f1", "Address": "100101f1", "Source Code": "\n// Function declaration with fastcall calling convention\nvoid __fastcall FUN_100101f1(LPCRITICAL_SECTION *criticalSectionPtr)\n{\n    // Call FUN_100103b0 with the dereferenced value of param_1\n    FUN_100103b0(**criticalSectionPtr);\n}\n"}
{"Function Name": "FUN_100101fa", "Address": "100101fa", "Source Code": "\n// Function declaration with fastcall calling convention\nvoid __fastcall FUN_100101fa(LPCRITICAL_SECTION *critical_section_ptr)\n{\n    // Call another function (FUN_100103bb) with the dereferenced parameter\n    FUN_100103bb(*critical_section_ptr);\n}\n"}
{"Function Name": "FUN_10010203", "Address": "10010203", "Source Code": "\nvoid FUN_10010203(void)\n{\n    undefined **pointerArray[10]; // Array of pointers to undefined type, size 10\n    undefined buffer[36];   // Array of undefined type, size 36\n    undefined4 initialValue = 0x44; // Stack variable initialized to 0x44\n\n    FUN_10004a20(buffer, \"string too long\"); // Call function with local_2c and error message\n    FUN_100042e0(pointerArray, buffer); // Call function to process local_54 with local_2c\n    pointerArray[0] = std::length_error::vftable; // Set the first element of local_54 to the vftable of std::length_error\n    __CxxThrowException_8(pointerArray, &DAT_100315e8); // Throw an exception using local_54 and a data reference\n    ((code *)swi(3))(); // Call a function via software interrupt 3\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10010242", "Address": "10010242", "Source Code": "\nvoid FUN_10010242(void) // Function definition\n{\n    undefined **pointerArray[10]; // Array of pointers to undefined type\n    undefined undefinedArray[36]; // Array of undefined type with size 36\n    stackValue = 0x44; // Set uStack_4 to hexadecimal value 0x44\n    FUN_10004a20(undefinedArray, \"invalid string position\"); // Call function with local_2c and error message\n    FUN_100042e0(pointerArray, undefinedArray); // Call function with local_54 and local_2c\n    pointerArray[0] = std::out_of_range::vftable; // Assign vftable of out_of_range to first element of local_54\n    __CxxThrowException_8(pointerArray, &DAT_10031758); // Throw an exception with local_54 and a data reference\n    ((code *)swi(3))(); // Call a function via software interrupt 3\n    return; // Return from the function\n}\n"}
{"Function Name": "__Toupper", "Address": "10010281", "Source Code": "\nint __cdecl __Toupper(int input_char, _Ctypevec *ctype_vector)\n{\n    ushort conversion_flag; // Variable to hold a ushort value\n    uint *locale_handle; // Pointer to a uint\n    short *code_page; // Pointer to the code page\n    int return_value; // Variable to hold an integer return value\n    ushort *char_type; // Pointer to a ushort\n    LPCWSTR wide_char_string; // Local variable for wide character string\n\n    // Check if param_2 is NULL\n    if (ctype_vector == (_Ctypevec *)0x0) {\n        locale_handle = ____lc_handle_func(); // Get locale handle\n        wide_char_string = (LPCWSTR)locale_handle[2]; // Get the code page from the locale handle\n        code_page = (short *)____lc_codepage_func(); // Get the code page\n    } else {\n        wide_char_string = (LPCWSTR)ctype_vector->_Page; // Use the page from param_2\n        code_page = ctype_vector->_Table; // Use the table from param_2\n    }\n\n    // Check if local_10 is NULL\n    if (wide_char_string == (LPCWSTR)0x0) {\n        // Check if param_1 is a lowercase letter\n        if (0x19 < input_char - 0x61U) {\n            return input_char; // Return param_1 if it's not a lowercase letter\n        }\n        return input_char + -0x20; // Convert to uppercase by adjusting ASCII value\n    }\n\n    // Check if param_1 is a valid character\n    if ((uint)input_char < 0x100) {\n        // Check if param_2 is not NULL\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            // Check if the character can be converted to uppercase\n            if ((*(byte *)(ctype_vector->_Delfl + input_char * 2) & 2) == 0) {\n                return input_char; // Return param_1 if it cannot be converted\n            }\n        } else if (_islower(input_char) == 0) {\n            return input_char; // Return param_1 if it's not lowercase\n        }\n    }\n\n    // Determine if the character can be converted based on param_2\n    if (ctype_vector != (_Ctypevec *)0x0) {\n        conversion_flag = *(ushort *)(ctype_vector->_Delfl + (input_char >> 8 & 0xffU) * 2) >> 0xf; // Get conversion flag\n    } else {\n        char_type = ___pctype_func(); // Get the character type function\n        conversion_flag = char_type[input_char >> 8 & 0xff] & 0x8000; // Get conversion flag from character type\n    }\n\n    // Set the appropriate values based on the conversion flag\n    if (conversion_flag == 0) {\n        ctype_vector->_0_2_ = (ushort)(byte)input_char; // Set the character as is\n        return_value = 1; // Set return value indicator\n    } else {\n        ctype_vector->_0_2_ = (ushort)input_char; // Set the character for conversion\n        ctype_vector->_0_3_ = (uint3)(ushort)ctype_vector; // Set additional parameter for conversion\n        return_value = 2; // Set return value indicator for conversion\n    }\n\n    // Call the locale-specific string mapping function\n    return_value = ___crtLCMapStringA((_locale_t)0x0, wide_char_string, 0x200, (LPCSTR)&ctype_vector, return_value, (LPSTR)&local_8, 3, (int)code_page, 1);\n    // Check if the mapping was successful\n    if (return_value != 0) {\n        input_char = (return_value == 1) ? (int)local_8 : (int)CONCAT11(local_8, local_7); // Update param_1 based on mapping result\n    }\n    return input_char; // Return the final result\n}\n"}
{"Function Name": "operator_new", "Address": "10010395", "Source Code": "\nvoid * __cdecl operator_new(uint size) // Function to allocate memory using custom new operator\n{\n    void *allocated_memory; // Pointer to hold the allocated memory\n    do {\n        allocated_memory = _malloc(size); // Attempt to allocate memory of size param_1\n        if (allocated_memory != (void *)0x0) { // Check if allocation was successful\n            return allocated_memory; // Return the allocated memory pointer\n        }\n    } while (__callnewh(size) != 0); // Call custom handler if allocation failed and retry\n\n    if ((bad_alloc_flag & 1) == 0) { // Check if the bad_alloc flag is not set\n        bad_alloc_flag |= 1; // Set the bad_alloc flag\n        std::bad_alloc::bad_alloc((bad_alloc *)&DAT_10035b84); // Construct bad_alloc exception\n        _atexit((_func_4879 *)&cleanup_label); // Register cleanup function at exit\n    }\n    \n    std::exception::exception((exception *)&DAT_10035b84); // Construct a generic exception\n    __CxxThrowException_8((undefined **)exception_stack, &exception_info); // Throw the exception\n    return ((code *)swi(3))(); // Call a system interrupt (swi) and return its result\n}\n"}
{"Function Name": "FUN_1001039a", "Address": "1001039a", "Source Code": "\n// Function to initialize a critical section\nvoid __cdecl FUN_1001039a(LPCRITICAL_SECTION critical_section)\n{\n    // Call the Windows API function to initialize the critical section object\n    InitializeCriticalSection(critical_section);\n}\n"}
{"Function Name": "FUN_100103a5", "Address": "100103a5", "Source Code": "\n// Function to delete a critical section\nvoid __cdecl FUN_100103a5(LPCRITICAL_SECTION critical_section)\n{\n    // Call the DeleteCriticalSection function to release the critical section\n    DeleteCriticalSection(critical_section);\n}\n"}
{"Function Name": "FUN_100103b0", "Address": "100103b0", "Source Code": "\n// Function declaration with a calling convention\nvoid __cdecl FUN_100103b0(LPCRITICAL_SECTION critical_section)\n{\n    // Enter the critical section specified by param_1\n    EnterCriticalSection(critical_section);\n}\n"}
{"Function Name": "FUN_100103bb", "Address": "100103bb", "Source Code": "\n// Function declaration with __cdecl calling convention\nvoid __cdecl FUN_100103bb(LPCRITICAL_SECTION critical_section)\n{\n    // Leave the critical section specified by param_1\n    LeaveCriticalSection(critical_section);\n}\n"}
{"Function Name": "thunk_FUN_10010400", "Address": "100103e6", "Source Code": "\nvoid thunk_FUN_10010400(void)\n{\n    // Loop until DAT_10034564 is less than 10\n    while (index < 10) {\n        // Check if the value at the calculated address is not zero\n        if (*(int *)(index * 4 + 0x10035b58) != 0) {\n            // Call the function pointer located at the calculated address\n            (**(code **)(index * 4 + 0x10035b54))();\n        }\n        // Increment DAT_10034564\n        index++;\n    }\n}\n"}
{"Function Name": "type_info::~type_info", "Address": "10010447", "Source Code": "\nvoid __thiscall type_info::~type_info(type_info *instance) // Destructor for type_info class\n{\n    *(undefined ***)instance = virtual_table; // Set the virtual function table pointer for the object\n    base_destructor(instance); // Call the base class destructor for cleanup\n}\n"}
{"Function Name": "type_info::`scalar_deleting_destructor'", "Address": "10010455", "Source Code": "\nvoid * __thiscall type_info::_scalar_deleting_destructor_(type_info *typeInfoPtr, uint shouldFree)\n{\n    // Call the destructor for the type_info object\n    ~type_info(typeInfoPtr);\n    \n    // Check if the parameter indicates that memory should be freed\n    if (shouldFree & 1) {\n        // Free the memory allocated for the type_info object\n        _free(typeInfoPtr);\n    }\n    \n    // Return the pointer to the type_info object\n    return typeInfoPtr;\n}\n"}
{"Function Name": "type_info::operator==", "Address": "10010471", "Source Code": "\\*\n// Define a method for comparing two type_info objects for equality\nbool method_call TypeInfo::operator==(TypeInfo *this, TypeInfo *otherTypeInfo)\n{\n    // Return true if the strings starting from the 10th byte of both objects are equal\n    // The _strcmp function returns 0 if the strings are equal, so we subtract from 1 to get a boolean result\n    return (bool)('\\x01' - (_strcmp((char *)(otherTypeInfo + 9), (char *)(this + 9)) != 0));\n}\n*\\ \n \n\nbool method_call TypeInfo::operator==(TypeInfo *this, TypeInfo *otherTypeInfo)\n{\n    return (bool)('\\x01' - (_strcmp((char *)(otherTypeInfo + 9), (char *)(this + 9)) != 0));\n}\n"}
{"Function Name": "__purecall", "Address": "1001048c", "Source Code": "\nvoid __purecall(void)\n{\n    // Decode the pointer stored in DAT_10035ef4 and cast it to a function pointer\n    code *functionPointer = (code *)__decode_pointer(encodedPointer);\n    \n    // Check if the decoded function pointer is not null\n    if (functionPointer != (code *)0x0) {\n        // Call the function pointed to by pcVar1\n        (*functionPointer)();\n    }\n    \n    // Write a message with a specific identifier (0x19)\n    __NMSG_WRITE(0x19);\n    \n    // Set the abort behavior for the program\n    __set_abort_behavior(0, 1);\n    \n    // Terminate the program execution\n    _abort();\n}\n"}
{"Function Name": "_JumpToContinuation", "Address": "100104bb", "Source Code": "\nvoid _JumpToContinuation(void *functionPointer, EHRegistrationNode *ehRegistrationNode)\n{\n    // Call the function pointed to by param_1\n    (*(code *)functionPointer)();\n}\n"}
{"Function Name": "FID_conflict:_CallMemberFunction1", "Address": "100104eb", "Source Code": "\nvoid FID_conflict__CallMemberFunction1(undefined4 function_param, undefined *function_pointer)\n{\n    LOCK();  // Acquire a lock to ensure thread safety\n    UNLOCK(); // Release the lock after acquiring it (this seems incorrect, should be after function call)\n    (*(code *)function_pointer)(); // Call the function pointed to by UNRECOVERED_JUMPTABLE\n}\n"}
{"Function Name": "_CallSETranslator", "Address": "100105aa", "Source Code": "\nint __cdecl\n_CallSETranslator(EHExceptionRecord *param_1, EHRegistrationNode *param_2, void *param_3, void *param_4,\n                  _s_FuncInfo *param_5, int param_6, EHRegistrationNode *param_7)\n{\n    int local_3c; // Variable to store the return status\n    EHExceptionRecord *local_38; // Local variable to hold the exception record\n    void *local_34; // Local variable to hold a pointer to some data\n    code *local_30; // Local variable to hold a pointer to the translator function\n    undefined4 *local_2c; // Local variable to hold a pointer to the exception list\n    code *local_28; // Local variable to hold the guard handler function\n    uint local_24; // Local variable for a masked value\n    _s_FuncInfo *local_20; // Local variable to hold function information\n    EHRegistrationNode *local_1c; // Local variable to hold the registration node\n    int local_18; // Local variable to hold the integer parameter\n    EHRegistrationNode *local_14; // Local variable to hold another registration node\n    int local_8 = 0; // Local variable initialized to 0\n\n    // Check if the exception record is a specific value\n    if (param_1 == (EHExceptionRecord *)0x123) {\n        *(undefined4 *)param_2 = 0x10010653; // Set a specific value in the registration node\n        local_3c = 1; // Set return status to indicate an error\n    } else {\n        local_28 = TranslatorGuardHandler; // Assign the guard handler function\n        local_24 = DAT_100345e0 ^ (uint)&local_2c; // Calculate a masked value\n        local_20 = param_5; // Store function information\n        local_1c = param_2; // Store the registration node\n        local_18 = param_6; // Store the integer parameter\n        local_14 = param_7; // Store another registration node\n        local_2c = (undefined4 *)ExceptionList; // Store the current exception list\n        ExceptionList = &local_2c; // Update the exception list to point to the local variable\n        local_38 = param_1; // Store the exception record\n        local_34 = param_3; // Store the pointer to some data\n        local_30 = (code *)__getptd()->_translator; // Get the translator function pointer\n        (*local_30)(*(undefined4 *)param_1, &local_38); // Call the translator function with the exception record\n        local_3c = 0; // Set return status to indicate success\n        if (local_8 != 0) { // Check if local_8 is not zero\n            *local_2c = *ExceptionList; // Update the exception list if needed\n        }\n        ExceptionList = local_2c; // Restore the previous exception list\n    }\n    return local_3c; // Return the status\n}\n"}
{"Function Name": "__FindAndUnlinkFrame", "Address": "100107d8", "Source Code": "\nvoid __cdecl __FindAndUnlinkFrame(void *frame_to_unlink)\n{\n    _ptiddata thread_data; // Declare a pointer to thread-local data structure\n    void *current_frame; // Declare a pointer for traversing the frame info chain\n\n    thread_data = __getptd(); // Get the current thread's data structure\n\n    // Check if the provided parameter is the head of the frame info chain\n    if (frame_to_unlink == thread_data->_pFrameInfoChain) {\n        // Update the head of the frame info chain to the next frame\n        thread_data->_pFrameInfoChain = *(void **)((int)frame_to_unlink + 4);\n        return; // Exit the function\n    }\n\n    current_frame = thread_data->_pFrameInfoChain; // Start traversing from the head of the chain\n\n    do {\n        // Check if the next frame in the chain is null\n        if (*(int *)((int)current_frame + 4) == 0) {\n            _inconsistency(); // Handle inconsistency error\n            return; // Exit the function\n        }\n        \n        // Move to the next frame in the chain\n        current_frame = *(void **)((int)current_frame + 4);\n    } while (frame_to_unlink != *(void **)((int)current_frame + 4)); // Continue until the target frame is found\n\n    // Link the previous frame to the next frame, effectively unlinking the target frame\n    *(undefined4 *)((int)current_frame + 4) = *(undefined4 *)((int)frame_to_unlink + 4);\n    return; // Exit the function\n}\n"}
{"Function Name": "_CallCatchBlock2", "Address": "10010824", "Source Code": "\nvoid * __cdecl\n_CallCatchBlock2(EHRegistrationNode *param_1, _s_FuncInfo *param_2, void *param_3, int param_4, ulong param_5)\n{\n    void *local_1c; // Declare a local variable to store the previous ExceptionList\n    local_1c = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &local_1c; // Update ExceptionList to point to the local variable\n\n    void *pvVar1 = (void *)__CallSettingFrame_12(param_3, param_1, param_5); // Call __CallSettingFrame_12 with parameters and store the result\n\n    ExceptionList = local_1c; // Restore the original ExceptionList\n    return pvVar1; // Return the result from __CallSettingFrame_12\n}\n"}
{"Function Name": "@__security_check_cookie@4", "Address": "10010882", "Source Code": "\nvoid __fastcall ___security_check_cookie_4(int input_value)\n{\n    // Check if the provided parameter 'param_1' matches the expected cookie value\n    if (input_value != expected_cookie_value) {\n        // If the values do not match, report a security failure\n        report_security_failure();\n    }\n}\n"}
{"Function Name": "std::bad_alloc::bad_alloc", "Address": "10010891", "Source Code": "\\*\n// Constructor for the bad_alloc class\nMemoryAllocationError * callingConvention std::MemoryAllocationError::MemoryAllocationError(MemoryAllocationError *instance)\n{\n    // Call the base class constructor (exception) with parameters\n    // - Cast 'this' to 'exception*'\n    // - Pass a pointer to the string literal for the error message\n    // - Pass '1' as the error code\n    exception::BaseException((exception *)instance, &errorMessagePointer, 1);\n    \n    // Return the current instance of bad_alloc\n    return instance;\n}\n*\\ \n \n\nMemoryAllocationError * callingConvention std::MemoryAllocationError::MemoryAllocationError(MemoryAllocationError *instance)\n{\n    exception::BaseException((exception *)instance, &errorMessagePointer, 1);\n    return instance;\n}\n"}
{"Function Name": "operator_new", "Address": "100108aa", "Source Code": "\nvoid * __cdecl operator_new(uint requestedSize) // Function to allocate memory using custom new operator\n{\n    void *allocatedMemoryPointer; // Pointer to hold the allocated memory\n    undefined **exceptionInfoArray[3]; // Array to hold exception information\n    do {\n        allocatedMemoryPointer = _malloc(requestedSize); // Attempt to allocate memory\n        if (allocatedMemoryPointer != (void *)0x0) { // Check if allocation was successful\n            return allocatedMemoryPointer; // Return the allocated memory pointer\n        }\n    } while (__callnewh(requestedSize) != 0); // Call the new handler if allocation failed\n    \n    if ((badAllocFlag & 1) == 0) { // Check if bad_alloc has been initialized\n        badAllocFlag |= 1; // Set the flag to indicate bad_alloc is initialized\n        std::bad_alloc::bad_alloc((bad_alloc *)&badAllocExceptionData); // Construct a bad_alloc exception\n        _atexit((_func_4879 *)&cleanupFunctionAddress); // Register a cleanup function at exit\n    }\n    \n    std::exception::genericException((exception *)exceptionInfoArray, (exception *)&badAllocExceptionData); // Construct a generic exception\n    exceptionInfoArray[0] = std::bad_alloc::vftable; // Set the virtual table for bad_alloc\n    __CxxThrowException_8(exceptionInfoArray, &DAT_100306cc); // Throw the bad_alloc exception\n    \n    return (void *)(*(code *)systemCall(3))(); // Fallback to system call for memory allocation\n}\n"}
{"Function Name": "FUN_10010914", "Address": "10010914", "Source Code": "\nvoid __cdecl FUN_10010914(ulong inputValue) // Function definition with a parameter of type ulong\n{\n    __getptd()->_holdrand = inputValue; // Set the _holdrand member of the thread data structure to the value of param_1\n}\n"}
{"Function Name": "FUN_10010943", "Address": "10010943", "Source Code": "\nvoid __fastcall FUN_10010943(undefined4 *exception_pointer)\n{\n    // Assign the vtable pointer of std::exception to the first element of param_1\n    *exception_pointer = std::exception::vftable;\n    \n    // Set the second element of param_1 to 0\n    exception_pointer[1] = 0;\n    \n    // Set the third element of param_1 to 0\n    exception_pointer[2] = 0;\n}\n"}
{"Function Name": "std::exception::exception", "Address": "10010954", "Source Code": "\\*\nexception * __thiscall std::exception::exception(exception *exceptionObject, char **inputParameter)\n{\n    char *destinationString; // Pointer for the destination string\n\n    *(undefined ***)exceptionObject = vftable; // Initialize the virtual function table pointer for the exception object\n\n    if (*inputParameter == (char *)0x0) { // Check if the input parameter is a null pointer\n        *(undefined4 *)(exceptionObject + 4) = 0; // Set the exception message to null\n    } else {\n        destinationString = (char *)_malloc(_strlen(*inputParameter) + 1); // Allocate memory for the exception message\n        *(char **)(exceptionObject + 4) = destinationString; // Store the allocated memory address in the exception object\n        if (destinationString != (char *)0x0) { // Check if memory allocation was successful\n            _strcpy_s(destinationString, _strlen(*inputParameter) + 1, *inputParameter); // Copy the exception message to the allocated memory\n        }\n    }\n\n    *(undefined4 *)(exceptionObject + 8) = 1; // Set a flag indicating the exception has been initialized\n    return exceptionObject; // Return the initialized exception object\n}\n*\\ \n \n\nexception * __thiscall std::exception::exception(exception *exceptionObject, char **inputParameter)\n{\n    char *destinationString;\n    *(undefined ***)exceptionObject = vftable;\n    if (*inputParameter == (char *)0x0) {\n        *(undefined4 *)(exceptionObject + 4) = 0;\n    } else {\n        destinationString = (char *)_malloc(_strlen(*inputParameter) + 1);\n        *(char **)(exceptionObject + 4) = destinationString;\n        if (destinationString != (char *)0x0) {\n            _strcpy_s(destinationString, _strlen(*inputParameter) + 1, *inputParameter);\n        }\n    }\n    *(undefined4 *)(exceptionObject + 8) = 1;\n    return exceptionObject;\n}\n"}
{"Function Name": "std::exception::exception", "Address": "100109a2", "Source Code": "\nvoid __thiscall std::exception::exception(exception *exception_object, char **error_message, int error_code)\n{\n    // Set the virtual function table pointer for the exception object\n    *(undefined ***)exception_object = vftable;\n    \n    // Assign the first parameter to the exception object's member\n    *(char **)(exception_object + 4) = *error_message;\n    \n    // Initialize the third member of the exception object to zero\n    *(undefined4 *)(exception_object + 8) = 0;\n}\n"}
{"Function Name": "std::exception::exception", "Address": "100109ba", "Source Code": "\\*\nexception * __thiscall std::exception::exception(exception *currentException, exception *sourceException)\n{\n    size_t errorMessageLength; // Variable to hold the length of the string\n    char *errorMessagePointer; // Pointer to hold the string from the source exception\n\n    *(undefined ***)currentException = vftable; // Set the virtual function table for the current exception object\n    *(int *)(currentException + 8) = *(int *)(sourceException + 8); // Copy the error code from the source exception\n\n    errorMessagePointer = *(char **)(sourceException + 4); // Retrieve the error message string from the source exception\n\n    if (*(int *)(currentException + 8) == 0) { // Check if the error code is zero\n        *(char **)(currentException + 4) = errorMessagePointer; // If zero, directly assign the error message pointer\n    } else if (errorMessagePointer == (char *)0x0) { // Check if the error message is null\n        *(undefined4 *)(currentException + 4) = 0; // If null, set the error message pointer to null\n    } else {\n        errorMessageLength = _strlen(errorMessagePointer); // Get the length of the error message string\n        errorMessagePointer = (char *)_malloc(errorMessageLength + 1); // Allocate memory for the new error message\n        *(char **)(currentException + 4) = errorMessagePointer; // Assign the newly allocated memory to the current exception\n\n        if (errorMessagePointer != (char *)0x0) { // Check if memory allocation was successful\n            _strcpy_s(errorMessagePointer, errorMessageLength + 1, *(char **)(sourceException + 4)); // Copy the error message to the new memory\n        }\n    }\n    return currentException; // Return the current exception object\n}\n*\\ \n \n\nexception * __thiscall std::exception::exception(exception *currentException, exception *sourceException)\n{\n    size_t errorMessageLength;\n    char *errorMessagePointer;\n    *(undefined ***)currentException = vftable;\n    *(int *)(currentException + 8) = *(int *)(sourceException + 8);\n    errorMessagePointer = *(char **)(sourceException + 4);\n    if (*(int *)(currentException + 8) == 0) {\n        *(char **)(currentException + 4) = errorMessagePointer;\n    } else if (errorMessagePointer == (char *)0x0) {\n        *(undefined4 *)(currentException + 4) = 0;\n    } else {\n        errorMessageLength = _strlen(errorMessagePointer);\n        errorMessagePointer = (char *)_malloc(errorMessageLength + 1);\n        *(char **)(currentException + 4) = errorMessagePointer;\n        if (errorMessagePointer != (char *)0x0) {\n            _strcpy_s(errorMessagePointer, errorMessageLength + 1, *(char **)(sourceException + 4));\n        }\n    }\n    return currentException;\n}\n"}
{"Function Name": "exception::~exception", "Address": "10010a12", "Source Code": "\nvoid __thiscall Exception::~Exception(exception *self) // Destructor for the 'exception' class\n{\n    *(undefined ***)self = std::exception::virtualTable; // Set the virtual function table pointer to the base class\n    if (*(int *)(self + 8) != 0) { // Check if the member at offset 8 is not null\n        freeMemory(*(void **)(self + 4)); // Free the memory pointed to by the member at offset 4\n    }\n}\n"}
{"Function Name": "FUN_10010a28", "Address": "10010a28", "Source Code": "\nchar * __fastcall FUN_10010a28(int input_param)\n{\n    // Retrieve a pointer to a character from the memory address offset by 4 from param_1\n    char *char_pointer = *(char **)(input_param + 4);\n    \n    // Return the character pointer if it is not NULL, otherwise return the string \"Unknown exception\"\n    return char_pointer ? char_pointer : \"Unknown exception\";\n}\n"}
{"Function Name": "FUN_10010a71", "Address": "10010a71", "Source Code": "\\*\nexception * __thiscall destructorExceptionHandler(void *exceptionInstance, byte flag)\n{\n    // Call the destructor for the exception object\n    exception::~exception((exception *)exceptionInstance);\n    \n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for the object if the condition is met\n        _free(exceptionInstance);\n    }\n    \n    // Return the pointer to the exception object\n    return (exception *)exceptionInstance;\n}\n*\\ \n \n\nexception * __thiscall destructorExceptionHandler(void *exceptionInstance, byte flag)\n{\n    exception::~exception((exception *)exceptionInstance);\n    if (flag & 1) {\n        _free(exceptionInstance);\n    }\n    return (exception *)exceptionInstance;\n}\n"}
{"Function Name": "FUN_10010a8d", "Address": "10010a8d", "Source Code": "\\*\nundefined4 * __thiscall FUN_10010a8d(void *object, byte flag)\n{\n    // Set the vtable pointer of the current object to the vtable of std::bad_cast\n    *(undefined ***)object = std::bad_cast::vftable;\n    \n    // Call the destructor of the exception class on the current object\n    exception::~exception((exception *)object);\n    \n    // If the least significant bit of param_1 is set, free the memory allocated for this object\n    if (flag & 1) {\n        _free(object);\n    }\n    \n    // Return the current object as a pointer to undefined4\n    return (undefined4 *)object;\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_10010a8d(void *object, byte flag)\n{\n    *(undefined ***)object = std::bad_cast::vftable;\n    exception::~exception((exception *)object);\n    if (flag & 1) {\n        _free(object);\n    }\n    return (undefined4 *)object;\n}\n"}
{"Function Name": "FUN_10010d15", "Address": "10010d15", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10010d15\n{\n    callAnotherFunction(4); // Call the function FUN_10016973 with an argument of 4\n}\n"}
{"Function Name": "__cfltcvt_init", "Address": "10010d8e", "Source Code": "\nvoid __cfltcvt_init(void)\n{\n    // Initialize pointer to the __cfltcvt function\n    ptrCfltcvt = __cfltcvt;\n    \n    // Initialize pointer to the __cfltcvt_l function\n    ptrCfltcvtL = __cfltcvt_l;\n    \n    // Initialize pointer to the __fassign_l function\n    ptrFassignL = __fassign_l;\n    \n    // Initialize pointer to the __cropzeros_l function\n    ptrCropzerosL = __cropzeros_l;\n    \n    // Initialize pointer to the __forcdecpt_l function\n    ptrForcdecptL = __forcdecpt_l;\n    \n    // Set pointer to LAB_100178ff label\n    ptrLab178ff = &LAB_100178ff;\n    \n    // Set pointer to LAB_100178bd label\n    ptrLab178bd = &LAB_100178bd;\n    \n    // Set pointer to LAB_100178f1 label\n    ptrLab178f1 = &LAB_100178f1;\n    \n    // Set pointer to LAB_10017867 label\n    ptrLab17867 = &LAB_10017867;\n}\n"}
{"Function Name": "__fpmath", "Address": "10010dee", "Source Code": "\nvoid __cdecl __fpmath(int input_param)\n{\n    // Initialize floating-point conversion settings\n    init_float_conversion();\n    \n    // Perform a test for floating-point division and store the result\n    fdiv_result = test_float_division();\n    \n    // Check if the input parameter is not zero\n    if (input_param != 0) {\n        // Set the default precision for floating-point operations\n        set_default_precision();\n    }\n}\n"}
{"Function Name": "__localtime64_s", "Address": "10010e0c", "Source Code": "\nerrno_t __cdecl __localtime64_s(tm *_Tm, __time64_t *_Time) // Function to convert time to local time\n{\n    errno_t errorCode; // Variable to store error codes\n    int timeField; // Variable to hold integer values\n    uint dstAdjustment, adjustedSeconds, timeValue, dstBias = 0, timezoneOffset = 0; // Variables for time calculations\n    bool isAdjustmentNeeded; // Boolean variable for conditions\n    longlong calculatedValue; // Variable for long long calculations\n    uint daylightSavingStatus = 0, carryValue; // Local variables for calculations\n\n    if (_Tm == (tm *)0x0) { // Check if the tm structure pointer is null\n        *__errno() = 0x16; // Set error code for invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        return 0x16; // Return error code\n    }\n    _memset(_Tm, 0xff, 0x24); // Initialize tm structure with 0xFF\n\n    if (_Time != (__time64_t *)0x0) { // Check if the time pointer is not null\n        timeField = *(int *)((int)_Time + 4); // Retrieve the time structure's field\n        if (timeField < 1) { // Check if the field value is less than 1\n            *__errno() = 0x16; // Set error code for invalid parameter\n            return 0x16; // Return error code\n        }\n        if (timeField < 7 || (timeField < 8 && (*(uint *)_Time < 0x93407000))) { // Check for specific conditions\n            ___tzset(); // Set timezone information\n            if ((errorCode = __get_daylight(&daylightSavingStatus)) != 0 || // Get daylight saving information\n                (errorCode = __get_dstbias((long *)&dstBias)) != 0 || // Get DST bias\n                (errorCode = __get_timezone((long *)&timezoneOffset)) != 0) { // Get timezone offset\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle errors\n            }\n            timeValue = *(uint *)_Time; // Get the time value\n            if (timeField < 0 || (timeField < 1 && (timeValue < 0x3f481))) { // Check for invalid time\n                errorCode = __gmtime64_s(_Tm, _Time); // Convert to GMT\n                if (errorCode != 0) { // Check for errors\n                    return errorCode; // Return error code\n                }\n                if (daylightSavingStatus == 0 || __isindst(_Tm) == 0) { // Check if DST is not in effect\n                    timeValue = _Tm->tm_sec; // Get seconds from tm structure\n                    adjustedSeconds = timeValue - timezoneOffset; // Adjust seconds by timezone offset\n                    carryValue = (((int)timeValue >> 0x1f) - ((int)timezoneOffset >> 0x1f)) - (uint)(timeValue < timezoneOffset); // Calculate carry\n                } else { // If DST is in effect\n                    dstAdjustment = timezoneOffset + dstBias; // Adjust for DST\n                    timeValue = _Tm->tm_sec; // Get seconds from tm structure\n                    adjustedSeconds = timeValue - dstAdjustment; // Adjust seconds\n                    carryValue = (((int)timeValue >> 0x1f) - ((int)dstAdjustment >> 0x1f)) - (uint)(timeValue < dstAdjustment); // Calculate carry\n                    _Tm->tm_isdst = 1; // Set DST flag\n                }\n                longlong uVar8 = __allrem(adjustedSeconds, carryValue, 0x3c, 0); // Calculate remainder for seconds\n                timeField = (int)uVar8; // Convert result to integer\n                _Tm->tm_sec = timeField; // Update seconds in tm structure\n                if (timeField < 0) { // Check for negative seconds\n                    isAdjustmentNeeded = 0x3b < adjustedSeconds; // Check if seconds need adjustment\n                    adjustedSeconds -= 0x3c; // Adjust seconds\n                    carryValue = (carryValue - 1) + (uint)isAdjustmentNeeded; // Adjust carry\n                    _Tm->tm_sec += 0x3c; // Update seconds\n                }\n                calculatedValue = __alldiv(adjustedSeconds, carryValue, 0x3c, 0) + _Tm->tm_min; // Calculate minutes\n                timeValue = (uint)calculatedValue; // Convert to unsigned integer\n                carryValue = (uint)((ulonglong)calculatedValue >> 0x20); // Get carry for minutes\n                uVar8 = __allrem(timeValue, carryValue, 0x3c, 0); // Calculate remainder for minutes\n                timeField = (int)uVar8; // Convert result to integer\n                _Tm->tm_min = timeField; // Update minutes in tm structure\n                if (timeField < 0) { // Check for negative minutes\n                    isAdjustmentNeeded = 0x3b < timeValue; // Check if minutes need adjustment\n                    timeValue -= 0x3c; // Adjust minutes\n                    carryValue = (carryValue - 1) + (uint)isAdjustmentNeeded; // Adjust carry\n                    _Tm->tm_min += 0x3c; // Update minutes\n                }\n                calculatedValue = __alldiv(timeValue, carryValue, 0x18, 0) + _Tm->tm_hour; // Calculate hours\n                timeValue = (uint)calculatedValue; // Convert to unsigned integer\n                carryValue = (uint)((ulonglong)calculatedValue >> 0x20); // Get carry for hours\n                uVar8 = __allrem(timeValue, carryValue, 0x18, 0); // Calculate remainder for hours\n                timeField = (int)uVar8; // Convert result to integer\n                _Tm->tm_hour = timeField; // Update hours in tm structure\n                if (timeField < 0) { // Check for negative hours\n                    isAdjustmentNeeded = 0x17 < timeValue; // Check if hours need adjustment\n                    timeValue -= 0x18; // Adjust hours\n                    carryValue = (carryValue - 1) + (uint)isAdjustmentNeeded; // Adjust carry\n                    _Tm->tm_hour += 0x18; // Update hours\n                }\n                calculatedValue = __alldiv(timeValue, carryValue, 0x18, 0); // Calculate days\n                timeField = (int)calculatedValue; // Convert result to integer\n                if ((calculatedValue < 0x100000000) && (calculatedValue < 0)) { // Check for valid day range\n                    _Tm->tm_mday += timeField; // Update day of the month\n                    _Tm->tm_wday = (_Tm->tm_wday + 7 + timeField) % 7; // Update day of the week\n                    if (_Tm->tm_mday < 1) { // Check if day is less than 1\n                        _Tm->tm_year -= 1; // Adjust year\n                        _Tm->tm_mday += 0x1f; // Set day to end of previous month\n                        _Tm->tm_yday = 0x16c; // Set day of the year\n                        _Tm->tm_mon = 0xb; // Set month to December\n                    } else {\n                        _Tm->tm_yday += timeField; // Update day of the year\n                    }\n                }\n            }\n        }\n    } else { // If _Time is null\n        uint adjustedSecondsForTimezone = timeValue - timezoneOffset; // Adjust seconds for timezone\n        carryValue = (timeField - ((int)timezoneOffset >> 0x1f)) - (uint)(timeValue < timezoneOffset); // Calculate carry\n        errorCode = __gmtime64_s(_Tm, (__time64_t *)&adjustedSecondsForTimezone); // Convert adjusted time to GMT\n        if (errorCode != 0) { // Check for errors\n            return errorCode; // Return error code\n        }\n        if (daylightSavingStatus != 0 && __isindst(_Tm) != 0) { // Check if DST is in effect\n            isAdjustmentNeeded = adjustedSecondsForTimezone < dstBias; // Check if adjustment is needed\n            adjustedSecondsForTimezone -= dstBias; // Adjust time for DST\n            carryValue = (carryValue - ((int)dstBias >> 0x1f)) - (uint)isAdjustmentNeeded; // Adjust carry\n            errorCode = __gmtime64_s(_Tm, (__time64_t *)&adjustedSecondsForTimezone); // Convert adjusted time to GMT\n            if (errorCode != 0) { // Check for errors\n                return errorCode; // Return error code\n            }\n            _Tm->tm_isdst = 1; // Set DST flag\n        }\n    }\n    return 0; // Return success\n}\n"}
{"Function Name": "FUN_100110d8", "Address": "100110d8", "Source Code": "\nvoid __cdecl FUN_100110d8(undefined4 inputValue) // Function definition with a calling convention\n{\n    globalValue = inputValue; // Assign the value of param_1 to the global variable DAT_10035b9c\n}\n"}
{"Function Name": "__invoke_watson", "Address": "100110e2", "Source Code": "\nvoid __cdecl\n__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)\n{\n    BOOL BVar2; // Variable to store the debugger presence status\n    LONG LVar3; // Variable to store the result of the UnhandledExceptionFilter\n    HANDLE hProcess; // Handle for the current process\n    UINT uExitCode; // Variable to store the exit code for the process termination\n    EXCEPTION_RECORD local_32c; // Local exception record structure\n    _EXCEPTION_POINTERS local_2dc; // Local exception pointers structure\n\n    _memset(&local_32c, 0, sizeof(local_32c)); // Initialize the exception record to zero\n    local_2dc.ExceptionRecord = &local_32c; // Set the exception record in the exception pointers structure\n    local_2dc.ContextRecord = (PCONTEXT)&(uint32_t){0x10001}; // Set the context record with a specific value\n    local_32c.ExceptionCode = 0xc000000d; // Set the exception code to STATUS_INVALID_PARAMETER\n    BVar2 = IsDebuggerPresent(); // Check if a debugger is present\n    SetUnhandledExceptionFilter(NULL); // Remove any existing unhandled exception filter\n    LVar3 = UnhandledExceptionFilter(&local_2dc); // Call the unhandled exception filter with the local exception pointers\n    if (LVar3 == 0 && BVar2 == 0) { // If no exception was handled and no debugger is present\n        FUN_10018eea(); // Call a specific function (presumably for logging or handling)\n    }\n    uExitCode = 0xc000000d; // Set the exit code to STATUS_INVALID_PARAMETER\n    hProcess = GetCurrentProcess(); // Get the handle of the current process\n    TerminateProcess(hProcess, uExitCode); // Terminate the current process with the specified exit code\n    ___security_check_cookie_4(DAT_100345e0); // Perform a security check (likely for stack protection)\n}\n"}
{"Function Name": "__invalid_parameter", "Address": "100111de", "Source Code": "\nvoid __cdecl\n__invalid_parameter(wchar_t *param_1, wchar_t *param_2, wchar_t *param_3, uint param_4, uintptr_t param_5)\n{\n    // Decode the pointer to the jump table\n    code *UNRECOVERED_JUMPTABLE = (code *)__decode_pointer(DAT_10035b9c);\n    \n    // Check if the jump table is valid\n    if (UNRECOVERED_JUMPTABLE) {\n        // Call the function pointed to by the jump table\n        (*UNRECOVERED_JUMPTABLE)();\n        return; // Exit the function after the jump table call\n    }\n    \n    // Call a fallback function if the jump table is not valid\n    FUN_10018eea();\n    \n    // Invoke the Watson error reporting with the provided parameters\n    __invoke_watson(param_1, param_2, param_3, param_4, param_5);\n}\n"}
{"Function Name": "FUN_10011202", "Address": "10011202", "Source Code": "\nvoid validateParameters(void) // Function definition for FUN_10011202\n{\n    checkInvalidParameters(NULL, NULL, NULL, 0, 0); // Call to __invalid_parameter with all parameters set to NULL or 0\n}\n"}
{"Function Name": "__CxxThrowException@8", "Address": "10011212", "Source Code": "\nvoid __CxxThrowException_8(undefined4 exception_code, byte *exception_flags)\n{\n    DWORD exception_info[4]; // Array to store exception information\n    ULONG_PTR additional_data; // Variable to hold additional exception data\n    \n    // Copy data from DAT_1002d0fc to local_24\n    for (int index = 0; index < 8; index++) {\n        exception_info[index] = DAT_1002d0fc[index]; // Initialize local_24 with predefined values\n    }\n    \n    // Check if param_2 is not NULL and if the 3rd bit is set\n    if (exception_flags != NULL && (*exception_flags & 8) != 0) {\n        additional_data = 0x1994000; // Set local_10 to a specific value if condition is met\n    }\n    \n    // Raise an exception with the information in local_24 and local_10\n    RaiseException(exception_info[0], exception_info[1], 0, &additional_data); // Trigger the exception\n}\n"}
{"Function Name": "_sprintf", "Address": "1001131d", "Source Code": "\nint __cdecl _sprintf(char *destination, char *formatString, ...)\n{\n    int returnValue; // Variable to store the return value\n    FILE outputFile; // Local FILE structure for output handling\n\n    // Check if the format string or destination pointer is null\n    if ((formatString == (char *)0x0) || (destination == (char *)0x0)) {\n        *__errno() = 0x16; // Set errno to indicate an error\n        handleInvalidParameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to handle invalid parameters\n        returnValue = -1; // Set return value to -1 to indicate failure\n    } else {\n        // Initialize the local FILE structure for output\n        outputFile._base = destination; // Set base pointer to destination\n        outputFile._ptr = destination; // Set pointer to current position in destination\n        outputFile._cnt = 0x7fffffff; // Set count to maximum value\n        outputFile._flag = 0x42; // Set flags for the FILE structure\n\n        // Call output function to format the string\n        returnValue = outputFunction(&outputFile, formatString, (_locale_t)0x0, &locale);\n        \n        outputFile._cnt--; // Decrement the count after output\n\n        // Check if the count has gone below zero\n        if (outputFile._cnt < 0) {\n            flushBuffer(0, &outputFile); // Flush the buffer if count is negative\n        } else {\n            *outputFile._ptr = '\\0'; // Null-terminate the string\n        }\n    }\n    return returnValue; // Return the result of the formatting operation\n}\n"}
{"Function Name": "__onexit", "Address": "100114ef", "Source Code": "\n_onexit_t calling_convention register_exit_function(_onexit_t exit_function)\n{\n    // Call a function that may perform necessary setup or logging before registering the exit function\n    setup_logging_function();\n    \n    // Register the exit function _Func in a thread-safe manner and return the previous exit function\n    return (_onexit_t)register_exit_function_thread_safe(exit_function);\n}\n"}
{"Function Name": "FUN_10011525", "Address": "10011525", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10011525\n{\n    helperFunction(); // Call the function FUN_10019e44\n}\n"}
{"Function Name": "_swprintf", "Address": "10011c15", "Source Code": "\nint __cdecl _swprintf(wchar_t *destinationBuffer, wchar_t *formatString, ...) // Function declaration for _swprintf\n{\n    // Call to FID_conflict___vswprintf_p_l with the destination buffer, format string, and other parameters\n    return vswprintf_p_l(destinationBuffer, (size_t)formatString, NULL, (_locale_t)0x0, &stackPointer);\n}\n"}
{"Function Name": "FUN_100125bb", "Address": "100125bb", "Source Code": "\nvoid unlockFileFunction(void)\n{\n    // Unlock the file associated with the pointer retrieved from memory\n    unlockFile(*(FILE **)(*(int *)0 + 8));\n}\n"}
{"Function Name": "_LocaleUpdate::_LocaleUpdate", "Address": "100125c5", "Source Code": "\\*\n_LocaleUpdate * __thiscall\n_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, localeinfo_struct *param_1)\n{\n    _ptiddata p_Var2; // Pointer to thread-specific data\n    pthreadlocinfo ptVar3; // Thread-local locale information\n    pthreadmbcinfo ptVar4; // Thread-local multi-byte character information\n    this[0xc] = (_LocaleUpdate)0x0; // Initialize the status field to 0\n\n    if (param_1 == (localeinfo_struct *)0x0) { // Check if param_1 is null\n        p_Var2 = __getptd(); // Get the thread-specific data\n        *(_ptiddata *)(this + 8) = p_Var2; // Store thread-specific data pointer\n        *(pthreadlocinfo *)this = p_Var2->ptlocinfo; // Set locale info from thread data\n        *(pthreadmbcinfo *)(this + 4) = p_Var2->ptmbcinfo; // Set multi-byte info from thread data\n\n        // Check if the locale info is not the default and if the thread does not own the locale\n        if ((*(undefined **)this != PTR_DAT_100354e8) && ((p_Var2->_ownlocale & DAT_10035400) == 0)) {\n            ptVar3 = ___updatetlocinfo(); // Update thread-local locale info\n            *(pthreadlocinfo *)this = ptVar3; // Store updated locale info\n        }\n        // Check if the multi-byte info is not the default and if the thread does not own the locale\n        if ((*(undefined **)(this + 4) != PTR_DAT_10035308) && ((*(uint *)(*(int *)(this + 8) + 0x70) & DAT_10035400) == 0)) {\n            ptVar4 = ___updatetmbcinfo(); // Update thread-local multi-byte info\n            *(pthreadmbcinfo *)(this + 4) = ptVar4; // Store updated multi-byte info\n        }\n        // Check if the flag in thread data is not set\n        if ((*(byte *)(*(int *)(this + 8) + 0x70) & 2) == 0) {\n            *(uint *)(*(int *)(this + 8) + 0x70) |= 2; // Set the flag in thread data\n            this[0xc] = (_LocaleUpdate)0x1; // Update the status field to indicate success\n        }\n    } else {\n        *(pthreadlocinfo *)this = param_1->locinfo; // Set locale info from provided parameter\n        *(pthreadmbcinfo *)(this + 4) = param_1->mbcinfo; // Set multi-byte info from provided parameter\n    }\n    return this; // Return the updated _LocaleUpdate object\n}\n*\\ \n \n\n_LocaleUpdate * __thiscall\n_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, localeinfo_struct *param_1)\n{\n    _ptiddata p_Var2;\n    pthreadlocinfo ptVar3;\n    pthreadmbcinfo ptVar4;\n    this[0xc] = (_LocaleUpdate)0x0;\n\n    if (param_1 == (localeinfo_struct *)0x0) {\n        p_Var2 = __getptd();\n        *(_ptiddata *)(this + 8) = p_Var2;\n        *(pthreadlocinfo *)this = p_Var2->ptlocinfo;\n        *(pthreadmbcinfo *)(this + 4) = p_Var2->ptmbcinfo;\n\n        if ((*(undefined **)this != PTR_DAT_100354e8) && ((p_Var2->_ownlocale & DAT_10035400) == 0)) {\n            ptVar3 = ___updatetlocinfo();\n            *(pthreadlocinfo *)this = ptVar3;\n        }\n        if ((*(undefined **)(this + 4) != PTR_DAT_10035308) && ((*(uint *)(*(int *)(this + 8) + 0x70) & DAT_10035400) == 0)) {\n            ptVar4 = ___updatetmbcinfo();\n            *(pthreadmbcinfo *)(this + 4) = ptVar4;\n        }\n        if ((*(byte *)(*(int *)(this + 8) + 0x70) & 2) == 0) {\n            *(uint *)(*(int *)(this + 8) + 0x70) |= 2;\n            this[0xc] = (_LocaleUpdate)0x1;\n        }\n    } else {\n        *(pthreadlocinfo *)this = param_1->locinfo;\n        *(pthreadmbcinfo *)(this + 4) = param_1->mbcinfo;\n    }\n    return this;\n}\n"}
{"Function Name": "__vsnprintf_helper", "Address": "10012647", "Source Code": "\nint __cdecl\n__vsnprintf_helper(undefined *param_1, char *param_2, uint param_3, int param_4, undefined4 param_5, undefined4 param_6)\n{\n    int *piVar1; // Pointer to store the address of the errno variable\n    int iVar2;   // Variable to store the return value of the function call\n    FILE local_24; // Local FILE structure to manage output\n\n    // Check if param_4 is zero, indicating an invalid parameter\n    if (param_4 == 0) {\n        piVar1 = __errno(); // Get the address of errno\n        *piVar1 = 0x16; // Set errno to a specific error code\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return -1; // Return error code\n    }\n\n    // Check if param_3 is zero or param_2 is NULL, indicating invalid input\n    if (param_3 == 0 || param_2 == (char *)0x0) {\n        piVar1 = __errno(); // Get the address of errno\n        *piVar1 = 0x16; // Set errno to a specific error code\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return -1; // Return error code\n    }\n\n    // Initialize local_24 structure with the provided parameters\n    local_24._cnt = (param_3 < 0x80000000) ? param_3 : 0x7fffffff; // Set count to the minimum of param_3 or max int\n    local_24._flag = 0x42; // Set flags for the FILE structure\n    local_24._base = param_2; // Set base pointer to param_2\n    local_24._ptr = param_2; // Set pointer to param_2\n\n    // Call the function pointed to by param_1 with the local FILE structure and other parameters\n    iVar2 = (*(code *)param_1)(&local_24, param_4, param_5, param_6);\n    if (iVar2 >= 0) { // Check if the function call was successful\n        local_24._cnt--; // Decrement the count\n        if (local_24._cnt >= 0) { // Check if there is still space in the buffer\n            *local_24._ptr = '\\0'; // Null-terminate the string\n            return iVar2; // Return the result of the function call\n        }\n        // Attempt to flush the buffer if there is no space left\n        if (__flsbuf(0, &local_24) != -1) {\n            return iVar2; // Return the result of the function call if flush was successful\n        }\n    }\n\n    // If we reach here, it means there was an error or buffer overflow\n    param_2[param_3 - 1] = '\\0'; // Ensure the last character is null-terminated\n    return -2 - (local_24._cnt < 0); // Return error code based on the count\n}\n"}
{"Function Name": "__vsnprintf_s", "Address": "10012816", "Source Code": "\nint __cdecl\n__vsnprintf_s(char *_DstBuf, size_t _SizeInBytes, size_t _MaxCount, char *_Format, va_list _ArgList)\n{\n    // Call the internal function __vsnprintf_s_l with the provided parameters\n    // _DstBuf: pointer to the destination buffer where the formatted string will be stored\n    // _SizeInBytes: size of the destination buffer in bytes\n    // _MaxCount: maximum number of characters to be written to the buffer\n    // _Format: format string for the output\n    // (_locale_t)0x0: passing null locale (default locale)\n    // _ArgList: variable argument list for the format string\n    return __vsnprintf_s_l(_DstBuf, _SizeInBytes, _MaxCount, _Format, (_locale_t)0x0, _ArgList);\n}\n"}
{"Function Name": "__tolower_l", "Address": "10012c01", "Source Code": "\nint __cdecl __tolower_l(int inputChar, _locale_t _Locale)\n{\n    int originalChar = inputChar; // Store the original character value\n    uint resultChar; // Variable to hold the result\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    CHAR processedChar; // Variable to hold the character value for processing\n    CHAR lowercaseChar; // Variable to hold the processed character\n    CHAR additionalChar; // Variable to hold an additional character\n    byte byteValue; // Variable to hold a byte value\n\n    // Update the locale information based on the provided locale\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, _Locale);\n    \n    // Check if the character is within the ASCII range\n    if ((uint)inputChar < 0x100) {\n        // Check if the locale supports the character conversion\n        if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n            // Get the character type for the given character\n            resultChar = (byte)localeInfo.locinfo[1].lc_category[0].locale[inputChar * 2] & 1;\n        } else {\n            // Check if the character is of type 'lowercase' in the current locale\n            resultChar = __isctype_l(inputChar, 1, &localeInfo);\n        }\n        // If the character is not a lowercase letter, return the original character\n        if (resultChar == 0) {\n            return originalChar;\n        }\n        // Get the lowercase equivalent character from the locale data\n        resultChar = (uint)*(byte *)((int)localeInfo.locinfo[1].lc_category[0].wlocale + inputChar);\n    } else {\n        // If the character is outside the ASCII range, process it differently\n        processedChar = (CHAR)inputChar; // Cast the character to CHAR type\n        // Check if the locale supports lead byte checking or if the character is a lead byte\n        if (((int)(localeInfo.locinfo)->locale_name[3] < 2) ||\n            (__isleadbyte_l(inputChar >> 8 & 0xff, &localeInfo) == 0)) {\n            // Set errno to indicate an error\n            *__errno() = 0x2a;\n            additionalChar = '\\0'; // Initialize local_7 to null\n            lowercaseChar = processedChar; // Assign the character to local_8\n            originalChar = 1; // Set iVar1 to indicate a single character\n        } else {\n            lowercaseChar = (CHAR)inputChar; // Assign the character to local_8\n            additionalChar = processedChar; // Assign the character to local_7\n            originalChar = 2; // Set iVar1 to indicate two characters\n        }\n        // Call the locale-specific function to map the character to lowercase\n        originalChar = ___crtLCMapStringA(&localeInfo, (localeInfo.locinfo)->lc_category[0].wlocale, 0x100, &lowercaseChar,\n                                   originalChar, (LPSTR)&byteValue, 3, (localeInfo.locinfo)->lc_codepage, 1);\n        // If the mapping fails, return the error code\n        if (originalChar == 0) {\n            return originalChar;\n        }\n        // Determine the result based on the mapping outcome\n        resultChar = (originalChar == 1) ? (uint)byteValue : (uint)CONCAT11(byteValue, additionalChar);\n    }\n    return resultChar; // Return the lowercase character or the original character\n}\n"}
{"Function Name": "_tolower", "Address": "10012d18", "Source Code": "\nint __cdecl _tolower(int character)\n{\n    // Check if the global variable DAT_10035bbc is 0 and if _C is an uppercase letter\n    if (isGlobalZero == 0 && character - 0x41U < 0x1a) {\n        // Convert uppercase letter to lowercase by adding 0x20\n        return character + 0x20;\n    }\n    // Call the locale-specific version of tolower if the conditions are not met\n    return localeToLower(character, (_locale_t)0x0);\n}\n"}
{"Function Name": "___DllMainCRTStartup", "Address": "100130a7", "Source Code": "\nint __fastcall ___DllMainCRTStartup(int dllParam1, int dllParam2, undefined4 dllParam3)\n{\n    int returnValue; // Variable to store return value from function calls\n    int initStatus = 1; // Local variable to track initialization status\n\n    // Check if the DLL is being loaded for the first time\n    if ((dllParam2 == 0) && (isFirstLoad == 0)) {\n        initStatus = 0; // Set local_20 to 0 if conditions are met\n    } else {\n        // Check if the DLL is being loaded or unloaded\n        if ((dllParam2 == 1) || (dllParam2 == 2)) {\n            // Call the user-defined initialization function if it exists\n            if (userInitFunction != (code *)0x0) {\n                initStatus = (*userInitFunction)(dllParam3, dllParam2, dllParam1);\n            }\n            // Check if initialization was successful\n            if ((initStatus == 0) || (returnValue = crtInitFunction(dllParam3, dllParam2, dllParam1), returnValue == 0)) {\n                initStatus = 0; // Set local_20 to 0 if initialization failed\n            }\n        }\n        // If initialization was successful, call another function\n        if (initStatus != 0) {\n            initStatus = cleanupFunction();\n        }\n        // Special handling for DLL_PROCESS_ATTACH case\n        if ((dllParam2 == 1) && (initStatus == 0)) {\n            cleanupFunction(); // Call cleanup function\n            crtInitFunction(dllParam3, 0, dllParam1); // Call CRT initialization with param_2 = 0\n            // Call user-defined function if it exists\n            if (userInitFunction != (code *)0x0) {\n                (*userInitFunction)(dllParam3, 0, dllParam1);\n            }\n        }\n        // Handle DLL_PROCESS_DETACH and DLL_THREAD_DETACH cases\n        if ((dllParam2 == 0) || (dllParam2 == 3)) {\n            returnValue = crtInitFunction(dllParam3, dllParam2, dllParam1); // Call CRT initialization\n            if (returnValue == 0) {\n                initStatus = 0; // Set local_20 to 0 if initialization failed\n            } else if (userInitFunction != (code *)0x0) {\n                initStatus = (*userInitFunction)(dllParam3, dllParam2, dllParam1); // Call user-defined function if it exists\n            }\n        }\n    }\n    return initStatus; // Return the initialization status\n}\n"}
{"Function Name": "__freea", "Address": "100131be", "Source Code": "\nvoid __cdecl __freea(void *memoryPointer) // Function to free allocated memory\n{\n    // Check if _Memory is not NULL and the value at the offset -8 is 0xdddd\n    if (memoryPointer && (*(int *)((int)memoryPointer - 8) == 0xdddd)) {\n        // Call _free to deallocate the memory at the adjusted pointer\n        freeMemory((int *)((int)memoryPointer - 8));\n    }\n}\n"}
{"Function Name": "__crtLCMapStringA_stat", "Address": "100131d9", "Source Code": "\nint __cdecl\n__crtLCMapStringA_stat\n(localeinfo_struct *param_1, ulong param_2, ulong param_3, char *param_4, int param_5,\nchar *param_6, int param_7, int param_8, int param_9)\n{\n    int iVar3; // Variable to store return value\n    DWORD DVar4; // Variable to store error code\n    char *pcVar5; // Pointer for character manipulation\n    uint cchWideChar; // Variable to store the count of wide characters\n    uint local_c; // Variable for local character count\n    undefined4 *local_10 = (undefined4 *)0x0; // Pointer for local data\n    void *local_14 = (void *)0x0; // Pointer for memory allocation\n\n    // Check if the global variable is uninitialized\n    if (DAT_10035bb4 == 0) {\n        // Attempt to get the wide character string length\n        iVar3 = LCMapStringW(0, 0x100, L\"\", 1, (LPWSTR)0x0, 0);\n        if (iVar3 == 0) { // If the call fails\n            DVar4 = GetLastError(); // Retrieve the last error code\n            if (DVar4 == 0x78) { // Check if the error code indicates a specific condition\n                DAT_10035bb4 = 2; // Set the global variable to indicate a specific state\n            }\n        } else {\n            DAT_10035bb4 = 1; // Set the global variable to indicate success\n        }\n    }\n\n    pcVar5 = (char *)param_3; // Initialize character pointer\n    if (param_4 > 0) { // Check if the parameter is valid\n        char *pcVar8 = param_4; // Temporary pointer for iteration\n        while (pcVar8-- > 0) { // Iterate backwards through the string\n            if (*pcVar5 == '\\0') { // Check for null terminator\n                pcVar5 = param_4 - (pcVar8 + 1); // Adjust pointer based on position\n                break; // Exit loop\n            }\n            pcVar5++; // Move to the next character\n        }\n    }\n\n    // Check the state of the global variable\n    if ((DAT_10035bb4 == 2) || (DAT_10035bb4 == 0)) {\n        // If locale info is not provided, retrieve it from a global structure\n        if (param_1 == (localeinfo_struct *)0x0) {\n            param_1 = *(localeinfo_struct **)(*in_ECX + 0x14);\n        }\n        // If the code page is not provided, retrieve it from a global structure\n        if (param_7 == 0) {\n            param_7 = *(int *)(*in_ECX + 4);\n        }\n        UINT UVar7 = ___ansicp((LCID)param_1); // Get the ANSI code page\n        if (UVar7 == 0xffffffff) goto LAB_10013569; // Check for error\n        if (UVar7 == param_7) { // If code pages match\n            // Call LCMapStringA directly\n            LCMapStringA((LCID)param_1, param_2, (LPCSTR)param_3, (int)param_4, (LPSTR)param_5, (int)param_6);\n        } else {\n            // Convert the string to the target code page\n            local_10 = (undefined4 *)___convertcp(param_7, UVar7, (char *)param_3, &local_c, (LPSTR)0x0, 0);\n            if (local_10 == (undefined4 *)0x0) goto LAB_10013569; // Check for conversion failure\n            local_c = LCMapStringA((LCID)param_1, param_2, (LPCSTR)local_10, (int)param_4, (LPSTR)0x0, 0); // Map the string\n            if (local_c != 0) { // If mapping succeeded\n                void *puVar6 = (local_c + 8 < 0x401) ? (undefined4 *)&stack0xffffffe4 : _malloc(local_c + 8); // Allocate memory\n                if (puVar6 != (undefined4 *)0x0) { // Check for successful allocation\n                    _memset(puVar6, 0, local_c); // Initialize allocated memory\n                    local_c = LCMapStringA((LCID)param_1, param_2, (LPCSTR)local_10, (int)param_4, (LPSTR)puVar6, local_c); // Map the string again\n                    if (local_c != 0) { // If mapping succeeded\n                        // Convert back to the original code page\n                        local_14 = (void *)___convertcp(UVar7, param_7, (char *)puVar6, &local_c, (LPSTR)param_5, (int)param_6);\n                    }\n                    __freea(puVar6); // Free allocated memory\n                }\n            }\n        }\n    } else if (DAT_10035bb4 == 1) { // Handle the case where wide character mapping is needed\n        if (param_7 == 0) { // If the code page is not provided\n            param_7 = *(int *)(*in_ECX + 4); // Retrieve it from a global structure\n        }\n        // Get the number of wide characters needed\n        cchWideChar = MultiByteToWideChar(param_7, (uint)(param_8 != 0) * 8 + 1, (LPCSTR)param_3, (int)param_4, (LPWSTR)0x0, 0);\n        if (cchWideChar == 0) goto LAB_10013569; // Check for error\n        if (cchWideChar < 1 || 0xffffffe0 / cchWideChar < 2) { // Check for overflow\n            local_10 = (undefined4 *)0x0; // Set to null if overflow\n        } else {\n            uint uVar1 = cchWideChar * 2 + 8; // Calculate required memory size\n            local_10 = (uVar1 < 0x401) ? (undefined4 *)&stack0xffffffdc : _malloc(uVar1); // Allocate memory\n            if (local_10 != (undefined4 *)0x0) {\n                *local_10 = 0xdddd; // Initialize memory\n            }\n        }\n        if (local_10 == (undefined4 *)0x0) goto LAB_10013569; // Check for allocation failure\n        iVar3 = MultiByteToWideChar(param_7, 1, (LPCSTR)param_3, (int)param_4, (LPWSTR)local_10, cchWideChar); // Convert to wide characters\n        if (iVar3 != 0) { // If conversion succeeded\n            local_c = LCMapStringW((LCID)param_1, param_2, (LPCWSTR)local_10, cchWideChar, (LPWSTR)0x0, 0); // Map the wide string\n            if (local_c != 0) { // If mapping succeeded\n                if ((param_2 & 0x400) == 0) { // Check if a specific flag is not set\n                    void *puVar6 = (local_c < 1 || 0xffffffe0 / local_c < 2) ? (undefined4 *)0x0 : (local_c * 2 + 8 < 0x401) ? (undefined4 *)&stack0xffffffe4 : _malloc(local_c * 2 + 8); // Allocate memory for the result\n                    if (puVar6 != (undefined4 *)0x0) { // Check for successful allocation\n                        iVar3 = LCMapStringW((LCID)param_1, param_2, (LPCWSTR)local_10, cchWideChar, (LPWSTR)puVar6, local_c); // Map the string\n                        if (iVar3 != 0) { // If mapping succeeded\n                            LPSTR lpMultiByteStr = (LPSTR)param_5; // Initialize multi-byte string pointer\n                            char *pcVar5 = param_6; // Initialize character pointer\n                            if (param_6 == (char *)0x0) { // If no output buffer is provided\n                                lpMultiByteStr = (LPSTR)0x0; // Set to null\n                                pcVar5 = (char *)0x0; // Set to null\n                            }\n                            local_c = WideCharToMultiByte(param_7, 0, (LPCWSTR)puVar6, local_c, lpMultiByteStr, (int)pcVar5, (LPCSTR)0x0, (LPBOOL)0x0); // Convert back to multi-byte\n                        }\n                        __freea(puVar6); // Free allocated memory\n                    }\n                } else if ((param_6 != (char *)0x0) && (local_c <= (uint)param_6)) { // If output buffer is provided and is large enough\n                    LCMapStringW((LCID)param_1, param_2, (LPCWSTR)local_10, cchWideChar, (LPWSTR)param_5, (int)param_6); // Directly map the wide string to the provided buffer\n                }\n            }\n        }\n    }\nLAB_10013569:\n    iVar3 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); // Security check\n    return iVar3; // Return the result\n}\n"}
{"Function Name": "___pctype_func", "Address": "100135be", "Source Code": "\n___pctype_func(void) // Function declaration for ___pctype_func\n{\n    pthreadlocinfo threadLocaleInfo = __getptd()->ptlocinfo; // Retrieve the thread-local locale information\n\n    // Check if ptVar2 is not equal to a specific pointer and if the current locale is not owned\n    if (threadLocaleInfo != (pthreadlocinfo)specificPointer && (__getptd()->_ownlocale & localeOwnershipFlag) == 0) {\n        threadLocaleInfo = ___updatetlocinfo(); // Update the locale information if conditions are met\n    }\n\n    // Return the locale category for the current thread as a ushort pointer\n    return (ushort *)threadLocaleInfo[1].lc_category[0].locale; \n}\n"}
{"Function Name": "___init_ctype", "Address": "100135e7", "Source Code": "\nint __cdecl ___init_ctype(threadlocinfo *_LocInfo)\n{\n    BYTE *bytePointer1; // Pointer to a BYTE variable\n    byte byteVar2; // BYTE variable\n    LONG *longPointerAddend; // Pointer to a LONG variable\n    int returnValue; // Integer variable for return values\n    BOOL booleanVar4; // Boolean variable for function results\n    BYTE *bytePointer5; // Pointer to a BYTE variable\n    uint unsignedVar8; // Unsigned integer variable\n    localeinfo_struct localeInfoStruct; // Local structure for locale information\n    wchar_t *wideCharPointer; // Pointer to wide character string\n    LPWORD wordPointer; // Pointer to WORD variable\n    undefined2 *undefined2Pointer; // Pointer to undefined 2-byte variable\n    int *intPointer; // Pointer to integer variable\n    wchar_t *wideCharPointer2; // Pointer to wide character string\n    undefined4 *undefined4Pointer; // Pointer to undefined 4-byte variable\n    void *voidPointer; // Pointer to void\n    undefined2 *undefined2Pointer2; // Pointer to undefined 2-byte variable\n    LPCSTR constantStringPointer; // Pointer to constant string\n    BYTE *bytePointer20; // Pointer to BYTE variable\n    _cpinfo codePageInfoStruct; // Structure for code page information\n    uint stackProtectionVar; // Unsigned integer variable for stack protection\n\n    stackProtectionVar = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Initialize stack protection variable\n    undefined4Pointer = (undefined4 *)0x0; // Initialize pointer to undefined 4-byte variable\n    undefined2Pointer2 = (undefined2 *)0x0; // Initialize pointer to undefined 2-byte variable\n    bytePointer20 = (BYTE *)0x0; // Initialize pointer to BYTE variable\n    voidPointer = (void *)0x0; // Initialize pointer to void\n    constantStringPointer = (LPCSTR)0x0; // Initialize pointer to constant string\n    localeInfoStruct.locinfo = _LocInfo; // Set locale info in local structure\n    localeInfoStruct.mbcinfo = (pthreadmbcinfo)0x0; // Initialize multi-byte character info\n\n    if (_LocInfo->lc_category[0].wlocale == (wchar_t *)0x0) { // Check if wide locale is null\n        longPointerAddend = (LONG *)_LocInfo[1].lc_collate_cp; // Get pointer to collate code page\n        if (longPointerAddend != (LONG *)0x0) { // If collate code page is not null\n            InterlockedDecrement(longPointerAddend); // Decrement reference count\n        }\n        _LocInfo[1].lc_collate_cp = 0; // Reset collate code page\n        _LocInfo[1].lc_time_cp = 0; // Reset time code page\n        _LocInfo[1].lc_category[0].locale = \" \"; // Set default locale\n        _LocInfo[1].lc_category[0].wlocale = (wchar_t *)&DAT_1002d968; // Set wide locale\n        _LocInfo[1].lc_category[0].refcount = (int *)&DAT_1002dae8; // Set reference count\n        _LocInfo->locale_name[3] = (wchar_t *)0x1; // Set locale name\n        goto LAB_1001396d; // Jump to cleanup\n    }\n\n    if ((_LocInfo->lc_codepage == 0) && // Check if code page is zero\n        (returnValue = ___getlocaleinfo(&localeInfoStruct, 0, (LPCWSTR)(uint)*(ushort *)&_LocInfo->lc_category[2].locale, 0x1004, &_LocInfo->lc_codepage), returnValue != 0)) { // Get locale info\n        goto LAB_10013900; // Jump to error handling\n    } else {\n        undefined4Pointer = (undefined4 *)__malloc_crt(4); // Allocate memory for undefined 4-byte variable\n        undefined2Pointer2 = (undefined2 *)__calloc_crt(0x180, 2); // Allocate memory for undefined 2-byte variable\n        bytePointer20 = (BYTE *)__calloc_crt(0x180, 1); // Allocate memory for BYTE variable\n        voidPointer = __calloc_crt(0x180, 1); // Allocate memory for void pointer\n        constantStringPointer = (LPCSTR)__calloc_crt(0x101, 1); // Allocate memory for constant string\n        if ((undefined4Pointer == (undefined4 *)0x0) || (undefined2Pointer2 == (undefined2 *)0x0) || (constantStringPointer == (LPCSTR)0x0) || (bytePointer20 == (BYTE *)0x0) || (voidPointer == (void *)0x0))) { // Check for allocation failure\n            goto LAB_10013900; // Jump to error handling\n        }\n        *undefined4Pointer = 0; // Initialize allocated memory\n        for (returnValue = 0; returnValue < 0x100; returnValue++) { // Loop to initialize local_24\n            constantStringPointer[returnValue] = (CHAR)returnValue; // Set each character\n        }\n        booleanVar4 = GetCPInfo(_LocInfo->lc_codepage, &codePageInfoStruct); // Get code page info\n        if ((booleanVar4 == 0) || (5 < codePageInfoStruct.MaxCharSize)) { // Check for errors in code page info\n            goto LAB_10013900; // Jump to error handling\n        }\n        wideCharPointer2 = (wchar_t *)(codePageInfoStruct.MaxCharSize & 0xffff); // Set max character size\n        if (((wchar_t *)0x1 < wideCharPointer2) && (codePageInfoStruct.LeadByte[0] != '\\0')) { // Check for lead bytes\n            bytePointer5 = codePageInfoStruct.LeadByte + 1; // Get pointer to lead bytes\n            do {\n                byteVar2 = *bytePointer5; // Get current lead byte\n                if (byteVar2 == 0) break; // Break if lead byte is zero\n                for (unsignedVar8 = (uint)bytePointer5[-1]; (int)unsignedVar8 <= (int)(uint)byteVar2; unsignedVar8++) { // Loop through lead byte range\n                    constantStringPointer[unsignedVar8] = ' '; // Set corresponding characters to space\n                }\n                bytePointer5 += 2; // Move to next lead byte\n            } while (*bytePointer5 != 0); // Continue until zero is found\n        }\n        wordPointer = undefined2Pointer2 + 0x80; // Set pointer for character types\n        booleanVar4 = ___crtGetStringTypeA((_locale_t)0x0, 1, constantStringPointer, 0x100, wordPointer, _LocInfo->lc_codepage, 0); // Get string type info\n        if ((booleanVar4 == 0) || (returnValue = ___crtLCMapStringA((_locale_t)0x0, _LocInfo->lc_category[0].wlocale, 0x100, constantStringPointer + 1, 0xff, (LPSTR)(bytePointer20 + 0x81), 0xff, _LocInfo->lc_codepage, 0), returnValue == 0) || (returnValue = ___crtLCMapStringA((_locale_t)0x0, _LocInfo->lc_category[0].wlocale, 0x200, constantStringPointer + 1, 0xff, (LPSTR)((int)voidPointer + 0x81), 0xff, _LocInfo->lc_codepage, 0), returnValue == 0)) { // Check for string mapping errors\n            goto LAB_10013900; // Jump to error handling\n        }\n        undefined2Pointer = undefined2Pointer2 + 0x7f; // Set pointer for reference count\n        *undefined2Pointer = 0; // Initialize reference count\n        wideCharPointer = (wchar_t *)(bytePointer20 + 0x80); // Set pointer for wide character string\n        bytePointer20[0x7f] = 0; // Null-terminate BYTE array\n        *(undefined *)((int)voidPointer + 0x7f) = 0; // Null-terminate void pointer\n        *(byte *)wideCharPointer = 0; // Null-terminate wide character string\n        intPointer = (int *)((int)voidPointer + 0x80); // Set pointer for integer reference count\n        *(undefined *)intPointer = 0; // Null-terminate integer reference count\n        if ((1 < (int)wideCharPointer2) && (codePageInfoStruct.LeadByte[0] != '\\0')) { // Check for lead bytes\n            bytePointer5 = codePageInfoStruct.LeadByte + 1; // Get pointer to lead bytes\n            do {\n                if (*bytePointer5 == 0) break; // Break if lead byte is zero\n                unsignedVar8 = (uint)bytePointer5[-1]; // Get previous lead byte\n                if (unsignedVar8 <= *bytePointer5) { // Check if within range\n                    undefined2Pointer2 = undefined2Pointer2 + unsignedVar8 + 0x80; // Adjust pointer for character types\n                    do {\n                        *undefined2Pointer2 = 0x8000; // Set character type\n                        unsignedVar8++; // Increment\n                        undefined2Pointer2++; // Move to next\n                    } while ((int)unsignedVar8 <= (int)(uint)*bytePointer5); // Continue until range is exhausted\n                }\n                bytePointer5 += 2; // Move to next lead byte\n            } while (*bytePointer5 != 0); // Continue until zero is found\n        }\n        _memcpy(undefined2Pointer2, undefined2Pointer2 + 0x100, 0xfe); // Copy character types\n        _memcpy(bytePointer5, bytePointer5 + 0x100, 0x7f); // Copy wide character string\n        if (((LONG *)_LocInfo[1].lc_collate_cp != (LONG *)0x0) && (InterlockedDecrement((LONG *)_LocInfo[1].lc_collate_cp) == 0)) { // Check if collate code page exists and decrement reference count\n            _free((void *)(_LocInfo[1].lc_time_cp - 0xfe)); // Free time code page memory\n            _free(_LocInfo[1].lc_category[0].wlocale + -0x40); // Free wide locale memory\n            _free(_LocInfo[1].lc_category[0].refcount + -0x20); // Free reference count memory\n            _free((void *)_LocInfo[1].lc_collate_cp); // Free collate code page memory\n        }\n        *undefined4Pointer = 1; // Set initialization flag\n        _LocInfo[1].lc_collate_cp = (uint)undefined4Pointer; // Set collate code page\n        _LocInfo[1].lc_category[0].locale = (char *)wordPointer; // Set locale\n        _LocInfo[1].lc_time_cp = (uint)undefined2Pointer; // Set time code page\n        _LocInfo[1].lc_category[0].wlocale = wideCharPointer; // Set wide locale\n        _LocInfo[1].lc_category[0].refcount = intPointer; // Set reference count\n        _LocInfo->locale_name[3] = wideCharPointer2; // Set locale name\n    }\n    _free(constantStringPointer); // Free allocated memory for constant string\nLAB_1001396d:\n    return ___security_check_cookie_4(stackProtectionVar ^ (uint)&stack0xfffffffc); // Return security check result\n}\n"}
{"Function Name": "____lc_codepage_func", "Address": "1001397c", "Source Code": "\nUINT __cdecl ____lc_codepage_func(void)\n{\n    // Retrieve the thread-local locale information\n    pthreadlocinfo localeInfo = getThreadData()->ptlocinfo;\n\n    // Check if the locale information is not a specific pointer and if the own locale flag is not set\n    if ((localeInfo != (pthreadlocinfo)specificPointer) && \n        ((getThreadData()->_ownlocale & localeFlag) == 0)) {\n        // Update the locale information if the conditions are met\n        localeInfo = updateLocaleInfo();\n    }\n\n    // Return the code page from the locale information\n    return localeInfo->lc_codepage;\n}\n"}
{"Function Name": "____lc_handle_func", "Address": "100139a2", "Source Code": "\nuint * get_locale_time_code_page(void) // Function declaration returning a pointer to uint\n{\n    _ptiddata thread_data; // Declare a variable of type _ptiddata\n    thread_data = __getptd(); // Get the thread-local data pointer\n\n    // Check if the thread's locale information is not equal to a specific pointer\n    // and if the thread does not own the locale\n    if ((thread_data->ptlocinfo != (pthreadlocinfo)PTR_DAT_100354e8) && \n        ((thread_data->_ownlocale & DAT_10035400) == 0)) {\n        \n        thread_data->ptlocinfo = ___updatetlocinfo(); // Update the thread's locale information\n    }\n\n    return &thread_data->ptlocinfo->lc_time_cp; // Return the pointer to the locale's time code page\n}\n"}
{"Function Name": "__calloc_crt", "Address": "10013a08", "Source Code": "\nvoid * __cdecl __calloc_crt(size_t count, size_t size)\n{\n    int *allocatedMemoryPointer; // Pointer to hold the allocated memory address\n    uint waitTime = 0; // Variable to track the wait time in milliseconds\n\n    while (true) { // Infinite loop to attempt memory allocation\n        allocatedMemoryPointer = __calloc_impl(count, size, (undefined4 *)0x0); // Call the memory allocation implementation\n        if (allocatedMemoryPointer != (int *)0x0) { // Check if allocation was successful\n            return allocatedMemoryPointer; // Return the allocated memory pointer\n        }\n        if (exitCondition == 0) break; // Exit loop if a certain condition is met (DAT_10035bb8 is 0)\n        Sleep(waitTime); // Sleep for the current wait time\n        waitTime += 1000; // Increment wait time by 1000 milliseconds (1 second)\n        if (exitCondition < waitTime) { // Check if the wait time exceeds a threshold\n            waitTime = 0xffffffff; // Set wait time to maximum value if exceeded\n        }\n        if (waitTime == 0xffffffff) { // Check if wait time is at maximum\n            return (void *)0x0; // Return null pointer if allocation fails after retries\n        }\n    }\n    return (void *)0x0; // Return null pointer if loop exits without successful allocation\n}\n"}
{"Function Name": "___updatetlocinfo", "Address": "10013eac", "Source Code": "\npthreadlocinfo __cdecl ___updatetlocinfo(void)\n{\n    // Retrieve the thread-local data structure for the current thread\n    _ptiddata threadData = getThreadData();\n    \n    // Check if the current thread does not own the locale or if the thread's locale info is null\n    if (((threadData->_ownlocale & DAT_10035400) == 0) || (threadData->ptlocinfo == (pthreadlocinfo)0x0)) {\n        // Acquire a lock to ensure thread safety\n        acquireLock(0xc);\n        \n        // Update the thread-local locale information without holding the lock\n        updateLocaleInfoWithoutLock();\n        \n        // Call another function, possibly for additional setup or initialization\n        additionalSetup();\n    }\n    \n    // Retrieve the thread's locale information\n    threadData = (_ptiddata)threadData->ptlocinfo;\n    \n    // Check if the locale information is null and exit if it is\n    if (threadData == (_ptiddata)0x0) {\n        exitWithMessage(0x20);\n    }\n    \n    // Return the thread-local locale information\n    return (pthreadlocinfo)threadData;\n}\n"}
{"Function Name": "FUN_10013f16", "Address": "10013f16", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_10013f16\n{\n    callAnotherFunction(0xc); // Call the function FUN_10016973 with the argument 0xc (12 in decimal)\n}\n"}
{"Function Name": "__setlocale_get_all", "Address": "10014147", "Source Code": "\nundefined4 * __setlocale_get_all(void)\n{\n    undefined4 *allocatedMemory; // Pointer to allocated memory\n    undefined4 *destinationMemory;    // Pointer to destination memory\n    errno_t errorCode;      // Variable to store error codes\n    int comparisonResult;          // Variable for comparison results\n    LONG longOperationResult;         // Variable for long integer operations\n    char **characterPointerArray;     // Pointer to an array of character pointers\n    int unusedRegister;      // Unused variable (possibly a register)\n    undefined **localDataPointer; // Pointer to local data\n    int counter;        // Counter variable\n\n    allocatedMemory = (undefined4 *)__malloc_crt(0x355); // Allocate memory\n    destinationMemory = allocatedMemory; // Initialize destination pointer\n    if (allocatedMemory != (undefined4 *)0x0) { // Check if memory allocation was successful\n        destinationMemory = allocatedMemory + 1; // Set destination pointer to the next memory location\n        *(undefined *)destinationMemory = 0; // Initialize the first byte of destination memory\n        *allocatedMemory = 1; // Set the first element of allocated memory to 1\n        counter = 1; // Initialize counter\n        characterPointerArray = (char **)(unusedRegister + 0x58); // Set pointer to character array\n        __strcats((char *)destinationMemory, 0x351, (char *)0x3); // Concatenate strings\n\n        localDataPointer = &PTR_s_LC_COLLATE_1002dc34; // Initialize local pointer\n\n        do {\n            errorCode = _strcat_s((char *)destinationMemory, 0x351, \";\"); // Safely concatenate a semicolon\n            if (errorCode != 0) { // Check for errors in string concatenation\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n            }\n            comparisonResult = _strcmp(*characterPointerArray, *(char **)(unusedRegister + counter * 0x10 + 0x58)); // Compare strings\n            if (comparisonResult != 0) { // If strings are not equal\n                _free(allocatedMemory); // Free allocated memory\n                if (*(LONG **)(unusedRegister + 0x50) != (LONG *)0x0) { // Check if pointer is not null\n                    longOperationResult = InterlockedDecrement(*(LONG **)(unusedRegister + 0x50)); // Decrement reference count\n                    if (longOperationResult == 0) { // If reference count reaches zero\n                        _free(*(void **)(unusedRegister + 0x50)); // Free memory\n                    }\n                }\n                if (*(LONG **)(unusedRegister + 0x54) != (LONG *)0x0) { // Check another pointer\n                    longOperationResult = InterlockedDecrement(*(LONG **)(unusedRegister + 0x54)); // Decrement reference count\n                    if (longOperationResult == 0) { // If reference count reaches zero\n                        _free(*(void **)(unusedRegister + 0x54)); // Free memory\n                    }\n                }\n                *(undefined4 **)(unusedRegister + 0x50) = allocatedMemory; // Update pointer in global state\n                *(undefined4 **)(unusedRegister + 0x48) = destinationMemory; // Update destination pointer in global state\n                *(undefined4 *)(unusedRegister + 0x4c) = 0; // Reset some state\n                *(undefined4 *)(unusedRegister + 0x54) = 0; // Reset another state\n                return destinationMemory; // Return the destination pointer\n            }\n            counter++; // Increment counter\n            localDataPointer += 3; // Move to the next locale entry\n            __strcats((char *)destinationMemory, 0x351, (char *)0x3); // Concatenate strings again\n        } while ((int)localDataPointer < 0x1002dc64); // Loop until a certain condition is met\n        \n        _free(allocatedMemory); // Free allocated memory\n        if (*(LONG **)(unusedRegister + 0x50) != (LONG *)0x0) { // Check if pointer is not null\n            longOperationResult = InterlockedDecrement(*(LONG **)(unusedRegister + 0x50)); // Decrement reference count\n            if (longOperationResult == 0) { // If reference count reaches zero\n                _free(*(void **)(unusedRegister + 0x50)); // Free memory\n            }\n        }\n        if (*(LONG **)(unusedRegister + 0x54) != (LONG *)0x0) { // Check another pointer\n            longOperationResult = InterlockedDecrement(*(LONG **)(unusedRegister + 0x54)); // Decrement reference count\n            if (longOperationResult == 0) { // If reference count reaches zero\n                _free(*(void **)(unusedRegister + 0x54)); // Free memory\n            }\n        }\n        destinationMemory = *(undefined4 **)(unusedRegister + 0x68); // Retrieve destination pointer from global state\n        *(undefined4 *)(unusedRegister + 0x50) = 0; // Reset pointer in global state\n        *(undefined4 *)(unusedRegister + 0x48) = 0; // Reset another pointer in global state\n    }\n    return destinationMemory; // Return the destination pointer\n}\n"}
{"Function Name": "__expandlocale", "Address": "100142b8", "Source Code": "\nvoid __cdecl\n__expandlocale(undefined **param_1, char *param_2, rsize_t param_3, undefined2 *param_4,\nundefined4 *param_5)\n{\n    wchar_t *_Src; // Pointer to source locale data\n    wchar_t *_Str1; // Pointer to string for locale representation\n    wchar_t *_LpCodePage; // Pointer to code page data\n    _ptiddata p_Var1; // Thread-local data structure\n    char *local_98 = (char[52]){0}; // Local buffer for locale string\n    uint local_8 = DAT_100345e0 ^ (uint)local_98; // Security cookie for stack protection\n\n    p_Var1 = __getptd(); // Get thread-local data\n    _Src = (p_Var1->_setloc_data)._cachein + 6; // Set source pointer to cachein offset\n    _Str1 = (p_Var1->_setloc_data)._cachein + 8; // Set string pointer to cachein offset\n    _LpCodePage = (p_Var1->_setloc_data)._cachein + 2; // Set code page pointer to cachein offset\n\n    // Check if parameters are valid\n    if (param_1 != (undefined **)0x0 && param_2 != (char *)0x0 && param_3 != 0) {\n        // Check if locale is \"C\"\n        if (*(char *)param_1 == 'C' && *(char *)((int)param_1 + 1) == '\\0') {\n            // Copy \"C\" to param_2\n            if (_strcpy_s(param_2, param_3, \"C\") != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Error handling\n            }\n            // Initialize param_4 if not null\n            if (param_4 != (undefined2 *)0x0) {\n                *param_4 = 0; // Set first element to 0\n                param_4[1] = 0; // Set second element to 0\n                param_4[2] = 0; // Set third element to 0\n            }\n            // Initialize param_5 if not null\n            if (param_5 != (undefined4 *)0x0) {\n                *param_5 = 0; // Set to 0\n            }\n        } else {\n            size_t sVar3 = _strlen((char *)param_1); // Get length of the locale string\n            // Check if length exceeds limit or if locale does not match\n            if (sVar3 > 0x82 || (_strcmp((char *)param_1, (char *)_Str1) != 0 && _strcmp((char *)param_1, (char *)_Str1) != 0)) {\n                // Attempt to convert locale string\n                if (___lc_strtolc(local_98, (char *)param_1) != 0 || ___get_qualified_locale((LPLC_STRINGS)local_98, (UINT *)_LpCodePage, (LPLC_STRINGS)local_98) == 0) {\n                    goto LAB_1001447a; // Jump to cleanup if conversion fails\n                }\n                *(uint *)_Src = (uint)(ushort)(p_Var1->_setloc_data)._cachein[4]; // Set source data\n                ___lc_lctostr((char *)_Str1, 0x83, local_98); // Convert locale to string\n                // Check if locale string is empty or too long\n                if (*(char *)param_1 == '\\0' || sVar3 > 0x82) {\n                    sVar3 = 0; // Reset length\n                    param_1 = &PTR_1002bc68; // Set to default locale\n                }\n                // Copy locale string to _Str1\n                if (_strncpy_s((char *)_Str1, 0x83, (char *)param_1, sVar3 + 1) != 0) {\n                    __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Error handling\n                }\n            }\n            // Copy code page data to param_4 if not null\n            if (param_4 != (undefined2 *)0x0) {\n                _memcpy(param_4, _LpCodePage, 6); // Copy code page data\n            }\n            // Copy source data to param_5 if not null\n            if (param_5 != (undefined4 *)0x0) {\n                _memcpy(param_5, _Src, 4); // Copy source data\n            }\n            // Copy locale string to param_2\n            if (_strcpy_s(param_2, param_3, (char *)_Str1) != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Error handling\n            }\n        }\n    }\nLAB_1001447a:\n    ___security_check_cookie_4(local_8 ^ (uint)local_98); // Check security cookie\n    return; // Exit function\n}\n"}
{"Function Name": "__setlocale_set_cat", "Address": "1001448c", "Source Code": "\nvoid __thiscall __setlocale_set_cat(void *this, int param_1)\n{\n    _ptiddata threadLocalData; // Pointer to thread-local data\n    int returnValue; // Variable for storing return values\n    int comparisonResult; // Variable for comparison results\n    errno_t errorCode; // Variable for error codes\n    wchar_t *wideCharDataPointer; // Pointer to wide character data\n    uint unsignedInteger; // Variable for unsigned integer\n    LONG longInteger; // Variable for long integer\n    uint modifiedValue; // Local variable for storing a modified value\n    modifiedValue = DAT_100345e0 ^ (uint)local_78; // XOR operation for security check\n    threadLocalData = __getptd(); // Get pointer to thread-local data\n    wchar_t *pwVar11 = (threadLocalData->_setloc_data)._cacheout + 9; // Pointer to cache output\n    returnValue = __expandlocale((undefined **)this, local_8c, 0x83, local_1b4, &storedValue2); // Expand locale\n    if (returnValue != 0) { // Check if expansion was successful\n        returnValue = param_1 * 0x10 + unaff_ESI; // Calculate index based on param_1\n        comparisonResult = _strcmp(local_8c, *(char **)(returnValue + 0x48)); // Compare locale strings\n        if (comparisonResult != 0) { // If strings are not equal\n            size_t lengthForAllocation = _strlen(local_8c) + 5; // Calculate length for allocation\n            undefined4 *allocatedMemory = (undefined4 *)__malloc_crt(lengthForAllocation); // Allocate memory\n            if (allocatedMemory != (undefined4 *)0x0) { // Check if allocation was successful\n                undefined *currentLocalePointer = *(undefined **)(returnValue + 0x48); // Get current locale\n                uint *specificLocationPointer = (uint *)(unaff_ESI + 0xc + param_1 * 4); // Pointer to a specific location\n                *specificLocationPointer = *specificLocationPointer; // Redundant operation\n                void *calculatedPointer = (void *)((param_1 + 6) * 6 + unaff_ESI); // Calculate another pointer\n                _memcpy(local_1c8, calculatedPointer, 6); // Copy memory\n                undefined4 storedValue = *(undefined4 *)(unaff_ESI + 4); // Store a value\n                errorCode = _strcpy_s((char *)(allocatedMemory + 1), lengthForAllocation - 4, local_8c); // Copy locale string safely\n                if (errorCode != 0) { // Check for errors in string copy\n                    __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Error handling\n                }\n                *(undefined4 **)(returnValue + 0x48) = allocatedMemory + 1; // Update locale pointer\n                *specificLocationPointer = (uint)local_1b4[0]; // Update another value\n                _memcpy(calculatedPointer, local_1b4, 6); // Copy more memory\n                if (param_1 == 2) { // Check if param_1 is 2\n                    *(undefined4 *)(unaff_ESI + 4) = storedValue2; // Store a value\n                    wideCharDataPointer = pwVar11; // Initialize pointer\n                    int lengthForAllocation = 0; // Local counter\n                    int comparisonResult = *(int *)((threadLocalData->_setloc_data)._cacheout + 0x19); // Get a value from cache\n                    void *calculatedPointer = *(void **)((threadLocalData->_setloc_data)._cacheout + 0x1b); // Get another pointer\n                    do {\n                        if (*(int *)(unaff_ESI + 4) == *(int *)wideCharDataPointer) { // Check for a match\n                            if (lengthForAllocation != 0) { // If not the first iteration\n                                wideCharDataPointer = pwVar11 + lengthForAllocation * 4; // Update pointer\n                                *(int *)pwVar11 = *(int *)wideCharDataPointer; // Update cache\n                                *(int *)((threadLocalData->_setloc_data)._cacheout + 0xb) = *(int *)(wideCharDataPointer + 2); // Update another cache value\n                                *(int *)wideCharDataPointer = comparisonResult; // Set value in cache\n                                *(void **)(wideCharDataPointer + 2) = calculatedPointer; // Update pointer in cache\n                            }\n                            break; // Exit loop\n                        }\n                        int currentValue = *(int *)wideCharDataPointer; // Store current value\n                        lengthForAllocation++; // Increment counter\n                        *(int *)wideCharDataPointer = comparisonResult; // Update cache\n                        void *nextPointer = *(void **)(wideCharDataPointer + 2); // Get next pointer\n                        *(void **)(wideCharDataPointer + 2) = calculatedPointer; // Update pointer in cache\n                        wideCharDataPointer += 4; // Move to next entry\n                        comparisonResult = currentValue; // Update value for next iteration\n                        calculatedPointer = nextPointer; // Update pointer for next iteration\n                    } while (lengthForAllocation < 5); // Limit to 5 iterations\n                    if (lengthForAllocation == 5) { // If limit reached\n                        BOOL stringTypeCheck = ___crtGetStringTypeA((_locale_t)0x0, 1, \"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\t\\n\\v\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\", 0x7f, stringTypeInfo, *(int *)(unaff_ESI + 4), *(BOOL *)(unaff_ESI + 0x14)); // Get string type information\n                        if (stringTypeCheck == 0) { // Check if the operation failed\n                            *(undefined4 *)((threadLocalData->_setloc_data)._cacheout + 0xb) = 0; // Set cache value to 0\n                        } else {\n                            unsignedInteger = 0; // Initialize counter\n                            do {\n                                stringTypeInfo[unsignedInteger] &= 0x1ff; // Mask values\n                                unsignedInteger++; // Increment counter\n                            } while (unsignedInteger < 0x7f); // Limit to 127 iterations\n                            comparisonResult = _memcmp(stringTypeInfo, PTR_DAT_10034670, 0xfe); // Compare memory\n                            *(uint *)((threadLocalData->_setloc_data)._cacheout + 0xb) = (uint)(comparisonResult == 0); // Update cache based on comparison\n                        }\n                        *(int *)pwVar11 = *(int *)(unaff_ESI + 4); // Update cache with current value\n                    }\n                    *(undefined4 *)(unaff_ESI + 0xa8) = *(undefined4 *)((threadLocalData->_setloc_data)._cacheout + 0xb); // Store cache value\n                }\n                if (param_1 == 1) { // Check if param_1 is 1\n                    *(undefined4 *)(unaff_ESI + 8) = storedValue2; // Store a value\n                }\n                comparisonResult = (**(code **)(&DAT_1002dc30 + param_1 * 0xc))(); // Call a function based on param_1\n                if (comparisonResult == 0) { // Check if function call was successful\n                    if (currentLocalePointer != &DAT_10035408) { // Check if not a specific value\n                        LONG **pointerToLong = (LONG **)((param_1 + 5) * 0x10 + unaff_ESI); // Calculate pointer\n                        longInteger = InterlockedDecrement(*pointerToLong); // Decrement reference count\n                        if (longInteger == 0) { // If reference count reaches zero\n                            _free(*pointerToLong); // Free memory\n                            _free(*(void **)(returnValue + 0x54)); // Free another memory block\n                            *(undefined4 *)(returnValue + 0x4c) = 0; // Reset value\n                        }\n                    }\n                    *allocatedMemory = 1; // Set success flag\n                    *(undefined4 **)((param_1 + 5) * 0x10 + unaff_ESI) = allocatedMemory; // Update pointer in storage\n                } else {\n                    *(undefined **)(returnValue + 0x48) = currentLocalePointer; // Restore previous locale pointer\n                    _free(allocatedMemory); // Free allocated memory\n                    *specificLocationPointer = *specificLocationPointer; // Redundant operation\n                    *(undefined4 *)(unaff_ESI + 4) = storedValue; // Restore previous value\n                }\n            }\n        }\n    }\n    ___security_check_cookie_4(modifiedValue ^ (uint)local_78); // Security check\n    return; // Exit function\n}\n"}
{"Function Name": "__setlocale_nolock", "Address": "10014782", "Source Code": "\nvoid __fastcall __setlocale_nolock(undefined **locale_ptr, int locale_param, int locale_flag)\n{\n    char *locale_char_ptr; // Pointer for string manipulation\n    size_t length_until_delimiter; // Size variable for string length calculations\n    size_t length_of_category; // Size variable for string length comparisons\n    errno_t error_status; // Error variable for function return status\n    int category_index = 0; // Index variable for loop iterations\n    int successful_settings_count = 0; // Counter for successful locale settings\n    char locale_category_buffer[20]; // Buffer for locale category string\n    undefined security_buffer[112]; // Buffer for security checks\n    uint security_cookie = DAT_100345e0 ^ (uint)security_buffer; // Security cookie for stack protection\n\n    if (locale_flag != 0) { // Check if the third parameter is not zero\n        if (locale_ptr != (undefined **)0x0) { // Check if param_1 is not null\n            __setlocale_set_cat(locale_ptr, locale_flag); // Set locale category\n        }\n        goto LAB_1001493e; // Jump to cleanup and exit\n    }\n\n    if (locale_ptr != (undefined **)0x0) { // Check if param_1 is not null\n        if (((*(char *)locale_ptr == 'L') && (*(char *)((int)locale_ptr + 1) == 'C')) && // Check for 'LC' prefix\n            (*(char *)((int)locale_ptr + 2) == '_')) { // Check for '_' following 'LC'\n            do {\n                locale_char_ptr = _strpbrk((char *)locale_ptr, \"=;\"); // Find '=' or ';' in the locale string\n                if (((locale_char_ptr == (char *)0x0) || (length_until_delimiter = (int)locale_char_ptr - (int)locale_ptr, length_until_delimiter == 0)) || // Check for invalid conditions\n                    (*locale_char_ptr == ';')) goto LAB_1001493e; // If conditions are met, exit\n\n                int category_index_temp = 1; // Initialize category index\n                undefined **locale_category_ptr = &PTR_s_LC_COLLATE_1002dc34; // Pointer to locale category strings\n                do {\n                    category_index = _strncmp(*locale_category_ptr, (char *)locale_ptr, length_until_delimiter); // Compare category strings\n                    if ((category_index == 0) && (length_of_category = _strlen(*locale_category_ptr), length_until_delimiter == length_of_category)) break; // Check for match\n                    category_index_temp++; // Increment category index\n                    locale_category_ptr += 3; // Move to the next category\n                } while ((int)locale_category_ptr < 0x1002dc65); // Continue until end of categories\n\n                locale_char_ptr++; // Move to the next character in the string\n                length_until_delimiter = _strcspn(locale_char_ptr, \";\"); // Get length until ';'\n                if ((length_until_delimiter == 0) && (*locale_char_ptr != ';')) goto LAB_1001493e; // Check for invalid conditions\n\n                if (category_index_temp < 6) { // If category index is valid\n                    error_status = _strncpy_s(locale_category_buffer, 0x83, locale_char_ptr, length_until_delimiter); // Copy category string to buffer\n                    if (error_status != 0) { // Check for copy error\n                        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    }\n                    locale_category_buffer[length_until_delimiter] = '\\0'; // Null-terminate the string\n                    category_index = __setlocale_set_cat(locale_category_buffer, category_index_temp); // Set the locale category\n                    if (category_index != 0) { // Check for success\n                        successful_settings_count++; // Increment success counter\n                    }\n                }\n            } while ((locale_char_ptr[length_until_delimiter] != '\\0') && (locale_ptr = (undefined **)(locale_char_ptr + length_until_delimiter + 1), *(char *)locale_ptr != '\\0')); // Continue until end of string\n        } else {\n            int expansion_status = __expandlocale(locale_ptr, locale_category_buffer, 0x83, (undefined2 *)0x0, (undefined4 *)0x0); // Expand locale\n            if (expansion_status == 0) goto LAB_1001493e; // If expansion fails, exit\n\n            char **locale_categories_ptr = (char **)(locale_param + 0x48); // Pointer to locale categories\n            do {\n                if (category_index != 0) { // If category index is valid\n                    expansion_status = _strcmp(locale_category_buffer, *locale_categories_ptr); // Compare with existing categories\n                    if ((expansion_status == 0) || (expansion_status = __setlocale_set_cat(locale_category_buffer, category_index), expansion_status != 0)) { // Check for match or set category\n                        successful_settings_count++; // Increment success counter\n                    }\n                }\n                category_index++; // Increment category index\n                locale_categories_ptr += 4; // Move to the next category\n            } while (category_index < 6); // Continue until all categories checked\n        }\n    }\n\n    if (successful_settings_count == 0) goto LAB_1001493e; // If no successful settings, exit\n\nLAB_10014939:\n    __setlocale_get_all(); // Retrieve all locale settings\n\nLAB_1001493e:\n    ___security_check_cookie_4(security_cookie ^ (uint)security_buffer); // Security check for stack integrity\n    return; // Exit function\n}\n"}
{"Function Name": "FUN_10014a7e", "Address": "10014a7e", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_10014a7e with no parameters\n{\n    processValue(0xc); // Call to FUN_10016973 with the argument 0xc (12 in decimal)\n}\n"}
{"Function Name": "FUN_10014a8a", "Address": "10014a8a", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_10014a8a\n{\n    processData(0xc); // Call to FUN_10016973 with argument 0xc (12 in decimal)\n}\n"}
{"Function Name": "FUN_10014abb", "Address": "10014abb", "Source Code": "\nvoid FUN_10014abb(void)\n{\n    // Clear the 5th bit (bitmask 0x10) of the value at the memory address \n    // calculated by adding 0x70 to the pointer stored in unaff_ESI.\n    *(uint *)(pointer_ESI + 0x70) &= 0xffffffef;\n}\n"}
{"Function Name": "_abort", "Address": "10014ac0", "Source Code": "\nvoid __cdecl _abort(void)\n{\n    _PHNDLR signalHandler; // Pointer to a signal handler\n    EXCEPTION_RECORD exceptionRecord; // Local variable to hold exception record\n    _EXCEPTION_POINTERS exceptionPointers; // Local variable to hold exception pointers\n\n    // Check if the first bit of DAT_10034674 is set\n    if (((byte)statusFlags & 1) != 0) {\n        __NMSG_WRITE(10); // Write a message if the condition is met\n    }\n    \n    signalHandler = ___get_sigabrt(); // Get the signal handler for SIGABRT\n    // If a signal handler is set, raise the SIGABRT signal\n    if (signalHandler != (_PHNDLR)0x0) {\n        _raise(0x16); // Raise the SIGABRT signal\n    }\n    \n    // Check if the second bit of DAT_10034674 is set\n    if (((byte)statusFlags & 2) != 0) {\n        _memset(&exceptionRecord, 0, sizeof(exceptionRecord)); // Zero out the exception record\n        exceptionPointers.ExceptionRecord = &exceptionRecord; // Set the exception record pointer\n        exceptionRecord.ExceptionCode = 0x40000015; // Set the exception code\n        SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0); // Clear the exception filter\n        UnhandledExceptionFilter(&exceptionPointers); // Call the unhandled exception filter\n    }\n    \n    __exit(3); // Exit the program with status code 3\n}\n"}
{"Function Name": "__set_abort_behavior", "Address": "10014bb3", "Source Code": "\nuint __cdecl __set_abort_behavior(uint flags, uint mask)\n{\n    // Store the current value of the global variable DAT_10034674 in uVar1\n    uint previousValue = globalVariable;\n\n    // Update DAT_10034674 by applying the _Flags and _Mask\n    // The new value is a combination of the flags that are set and the existing flags that are not masked\n    globalVariable = (flags & mask) | (~mask & previousValue);\n\n    // Return the previous value of DAT_10034674 before the update\n    return previousValue;\n}\n"}
{"Function Name": "type_info::_Type_info_dtor", "Address": "10014c48", "Source Code": "\nvoid __cdecl type_info::_Type_info_dtor(type_info *typeInfo)\n{\n    // Declare a pointer to an integer, initialized to a specific memory location\n    int *memoryPointer = DAT_10035bc4;\n\n    // Check if the value at the offset of param_1 is not zero\n    if (*(int *)(typeInfo + 4) != 0) {\n        // Declare a pointer to an integer, initialized to another specific memory location\n        int *varPointer = (int *)&DAT_10035bc0;\n\n        // Loop while _Memory is not null and the value at _Memory does not match the value at param_1 + 4\n        while (memoryPointer != (int *)0x0 && *DAT_10035bc4 != *(int *)(typeInfo + 4)) {\n            // Update piVar1 to point to the current value of DAT_10035bc4\n            varPointer = DAT_10035bc4;\n        }\n\n        // If _Memory is not null\n        if (memoryPointer != (int *)0x0) {\n            // Set the second element of piVar1 to the second element of _Memory\n            varPointer[1] = memoryPointer[1];\n        }\n\n        // Free the memory pointed to by _Memory\n        _free(memoryPointer);\n    }\n\n    // Free the memory pointed to by the value at param_1 + 4\n    _free(*(void **)(typeInfo + 4));\n\n    // Set the value at param_1 + 4 to zero\n    *(undefined4 *)(typeInfo + 4) = 0;\n\n    // Call a function, possibly for cleanup or finalization\n    FUN_10014caf();\n}\n"}
{"Function Name": "FUN_10014caf", "Address": "10014caf", "Source Code": "\nvoid processFunction(void) // Function declaration for FUN_10014caf\n{\n    executeTask(0xe); // Call to FUN_10016973 with argument 0xe (14 in decimal)\n}\n"}
{"Function Name": "__FF_MSGBANNER", "Address": "10014ee8", "Source Code": "\nvoid __cdecl displayMessageBanner(void)\n{\n    // Set the error mode to 3 and check if it was successful (returns 0)\n    if (setErrorMode(3) == 0 && errorFlag == 1) {\n        // Write a message with code 0xfc\n        writeMessage(0xfc);\n        // Write a message with code 0xff\n        writeMessage(0xff);\n    }\n}\n"}
{"Function Name": "__encode_pointer", "Address": "10014f21", "Source Code": "\nint __cdecl __encode_pointer(int input_value)\n{\n    code *function_pointer; // Pointer to a function\n    int integer_value; // Variable to hold an integer value\n    HMODULE module_handle; // Handle to a module\n    FARPROC function_address; // Pointer to a function\n\n    // Check if the thread-local storage value is not null and a specific value is not -1\n    if ((TlsGetValue(DAT_1003474c) != (LPVOID)0x0) && (DAT_10034748 != -1)) {\n        integer_value = DAT_10034748; // Get the value from a global variable\n        function_pointer = (code *)TlsGetValue(DAT_1003474c); // Retrieve the function pointer from thread-local storage\n        integer_value = (*function_pointer)(integer_value); // Call the function with the retrieved value\n        if (integer_value != 0) { // Check if the result is not zero\n            function_address = *(FARPROC *)(integer_value + 0x1f8); // Get the function pointer from a specific offset\n            goto LAB_10014f70; // Jump to the label to continue processing\n        }\n    }\n    \n    module_handle = GetModuleHandleA(\"KERNEL32.DLL\"); // Get the handle for KERNEL32.DLL\n    if (module_handle == (HMODULE)0x0) { // Check if the module handle is null\n        return input_value; // Return the original parameter if the module is not found\n    }\n    \n    function_address = GetProcAddress(module_handle,\"EncodePointer\"); // Get the address of the EncodePointer function\nLAB_10014f70:\n    if (function_address != (FARPROC)0x0) { // Check if the function pointer is not null\n        input_value = (*function_address)(input_value); // Call the EncodePointer function with the parameter\n    }\n    \n    return input_value; // Return the potentially modified parameter\n}\n"}
{"Function Name": "__encoded_null", "Address": "10014f84", "Source Code": "\n// Function declaration for __encoded_null\nvoid encodedNull(void)\n{\n    // Call the function __encode_pointer with NULL as an argument\n    encodePointer(NULL);\n}\n"}
{"Function Name": "__decode_pointer", "Address": "10014f8d", "Source Code": "\nint __cdecl __decode_pointer(int input_pointer)\n{\n    code *function_pointer; // Pointer to a function\n    int intermediate_result; // Variable to store intermediate results\n    FARPROC function_address; // Pointer to a function or procedure\n\n    // Check if the thread-local storage value is not null and DAT_10034748 is not -1\n    if (TlsGetValue(DAT_1003474c) != (LPVOID)0x0 && DAT_10034748 != -1) {\n        intermediate_result = DAT_10034748; // Get the value of DAT_10034748\n        function_pointer = (code *)TlsGetValue(DAT_1003474c); // Retrieve the function pointer from thread-local storage\n        intermediate_result = (*function_pointer)(intermediate_result); // Call the function with iVar3 as argument\n        if (intermediate_result != 0) { // Check if the result is not zero\n            function_address = *(FARPROC *)(intermediate_result + 0x1fc); // Get the function pointer from the calculated address\n            goto LAB_10014fdc; // Jump to the label to continue processing\n        }\n    }\n\n    // Get a handle to the KERNEL32.DLL module\n    HMODULE module_handle = GetModuleHandleA(\"KERNEL32.DLL\");\n    if (module_handle == (HMODULE)0x0) { // Check if the module handle is null\n        return input_pointer; // Return the original parameter if the module is not found\n    }\n\n    // Get the address of the DecodePointer function from KERNEL32.DLL\n    function_address = GetProcAddress(module_handle, \"DecodePointer\");\nLAB_10014fdc:\n    // If the function pointer is valid, call the DecodePointer function\n    if (function_address != (FARPROC)0x0) {\n        input_pointer = (*function_address)(input_pointer); // Decode the pointer\n    }\n    return input_pointer; // Return the potentially modified pointer\n}\n"}
{"Function Name": "___set_flsgetvalue", "Address": "10014ff9", "Source Code": "\nvoid ___set_flsgetvalue(void)\n{\n    // Retrieve the value associated with the thread-local storage index DAT_1003474c\n    LPVOID threadLocalValue = TlsGetValue(tlsIndex);\n    \n    // Check if the retrieved value is NULL\n    if (threadLocalValue == (LPVOID)0x0) {\n        // Decode the pointer stored at DAT_10035ee0\n        threadLocalValue = (LPVOID)__decode_pointer(encodedPointer);\n        \n        // Set the decoded pointer as the value for the thread-local storage index DAT_1003474c\n        TlsSetValue(tlsIndex, threadLocalValue);\n    }\n}\n"}
{"Function Name": "__initptd", "Address": "10015060", "Source Code": "\nvoid __cdecl __initptd(_ptiddata threadData, pthreadlocinfo localeInfo)\n{\n    // Get a handle to the KERNEL32.DLL module\n    HMODULE kernelModule = GetModuleHandleA(\"KERNEL32.DLL\");\n    \n    // Initialize the exception action table pointer\n    threadData->_pxcptacttab = &DAT_100354f8;\n    \n    // Set the random number generator hold flag\n    threadData->_holdrand = 1;\n\n    // If the KERNEL32.DLL module is successfully loaded\n    if (kernelModule) {\n        // Get the address of the EncodePointer function and store it in the cacheout\n        *(FARPROC *)((threadData->_setloc_data)._cacheout + 0x1d) = GetProcAddress(kernelModule, \"EncodePointer\");\n        \n        // Get the address of the DecodePointer function and store it in the cacheout\n        *(FARPROC *)((threadData->_setloc_data)._cacheout + 0x1f) = GetProcAddress(kernelModule, \"DecodePointer\");\n    }\n\n    // Set the own locale flag\n    threadData->_ownlocale = 1;\n    \n    // Initialize the cachein data\n    *(undefined *)((threadData->_setloc_data)._cachein + 8) = 0x43;\n    *(undefined *)((int)(threadData->_setloc_data)._cachein + 0x93) = 0x43;\n    \n    // Set the multi-byte character information pointer\n    threadData->ptmbcinfo = (pthreadmbcinfo)&DAT_10034ee0;\n    \n    // Increment the reference count for the multi-byte character information\n    InterlockedIncrement((LONG *)&DAT_10034ee0);\n    \n    // Acquire a lock\n    __lock(0xc);\n    \n    // Set the locale information pointer, defaulting if _Locale is NULL\n    threadData->ptlocinfo = localeInfo ? localeInfo : (pthreadlocinfo)PTR_DAT_100354e8;\n    \n    // Increment the reference count for the locale information\n    ___addlocaleref(&threadData->ptlocinfo->refcount);\n    \n    // Call an initialization function\n    FUN_1001510b();\n}\n"}
{"Function Name": "FUN_1001510b", "Address": "1001510b", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_1001510b\n{\n    callAnotherFunction(0xc); // Call to FUN_10016973 with argument 0xc (12 in decimal)\n}\n"}
{"Function Name": "__getptd_noexit", "Address": "10015114", "Source Code": "\n_ptiddata __cdecl __getptd_noexit(void)\n{\n    // Store the current thread's last error code\n    DWORD lastErrorCode = GetLastError();\n    \n    // Retrieve the pointer to the thread-local storage (TLS) value\n    code *tlsFunctionPointer = (code *)TlsGetValue(DAT_1003474c);\n    \n    // Call the function pointed to by pcVar1 with DAT_10034748 and cast the result to _ptiddata\n    _ptiddata threadLocalData = (_ptiddata)(*tlsFunctionPointer)(DAT_10034748);\n    \n    // Check if _Ptd is null\n    if (threadLocalData == (_ptiddata)0x0) {\n        // Allocate memory for _Ptd using __calloc_crt\n        threadLocalData = (_ptiddata)__calloc_crt(1, 0x214);\n        \n        // Check if memory allocation was successful\n        if (threadLocalData != (_ptiddata)0x0) {\n            // Decode the pointer to the function using __decode_pointer\n            tlsFunctionPointer = (code *)__decode_pointer(DAT_10035ee4);\n            \n            // Call the function pointed to by pcVar1 with DAT_10034748 and _Ptd\n            if ((*tlsFunctionPointer)(DAT_10034748, threadLocalData) == 0) {\n                // If the function call failed, free the allocated memory\n                _free(threadLocalData);\n                threadLocalData = (_ptiddata)0x0; // Set _Ptd to null\n            } else {\n                // Initialize the _Ptd structure\n                __initptd(threadLocalData, (pthreadlocinfo)0x0);\n                \n                // Set the thread handle to an invalid value\n                threadLocalData->_thandle = 0xffffffff;\n                \n                // Store the current thread ID in _Ptd\n                threadLocalData->_tid = GetCurrentThreadId();\n            }\n        }\n    }\n    \n    // Restore the last error code to its original value\n    SetLastError(lastErrorCode);\n    \n    // Return the pointer to the thread-local data\n    return threadLocalData;\n}\n"}
{"Function Name": "__getptd", "Address": "10015197", "Source Code": "\n_ptiddata __cdecl __getptd(void)\n{\n    // Call the function to get the thread-local data without exiting\n    _ptiddata threadLocalData = __getptd_noexit();\n    \n    // Check if the returned pointer is null (indicating failure)\n    if (threadLocalData == (_ptiddata)0x0) {\n        // Exit the program with error code 0x10 if the pointer is null\n        __amsg_exit(0x10);\n    }\n    \n    // Return the thread-local data pointer\n    return threadLocalData;\n}\n"}
{"Function Name": "FUN_100152bb", "Address": "100152bb", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_100152bb\n{\n    processData(0xd); // Call to FUN_10016973 with argument 0xd (13 in decimal)\n}\n"}
{"Function Name": "FUN_100152c7", "Address": "100152c7", "Source Code": "\nvoid function_main(void) // Function declaration for FUN_100152c7\n{\n    function_helper(0xc); // Call to FUN_10016973 with argument 0xc (12 in decimal)\n}\n"}
{"Function Name": "__mtinit", "Address": "10015339", "Source Code": "\nint __cdecl __mtinit(void) // Function to initialize multi-threading\n{\n    HMODULE kernel32Handle = GetModuleHandleA(\"KERNEL32.DLL\"); // Get handle to KERNEL32.DLL\n    if (kernel32Handle == (HMODULE)0x0) { // Check if the module handle is null\n        __mtterm(); // Terminate if the module is not found\n        return 0; // Return 0 indicating failure\n    }\n    // Retrieve addresses of fiber-local storage functions\n    flsAllocAddress = GetProcAddress(kernel32Handle, \"FlsAlloc\");\n    flsGetValueAddress = GetProcAddress(kernel32Handle, \"FlsGetValue\");\n    flsSetValueAddress = GetProcAddress(kernel32Handle, \"FlsSetValue\");\n    flsFreeAddress = GetProcAddress(kernel32Handle, \"FlsFree\");\n    \n    // Check if any of the function addresses are null\n    if ((((flsAllocAddress == (FARPROC)0x0) || (flsGetValueAddress == (FARPROC)0x0)) ||\n        (flsSetValueAddress == (FARPROC)0x0)) || (flsFreeAddress == (FARPROC)0x0)) {\n        // Fallback to TLS functions if FLs functions are not available\n        flsGetValueAddress = TlsGetValue_exref;\n        flsAllocAddress = (FARPROC)&LAB_10014ff0; // Set to a fallback function\n        flsSetValueAddress = TlsSetValue_exref;\n        flsFreeAddress = TlsFree_exref;\n    }\n    \n    DWORD tlsIndex = TlsAlloc(); // Allocate a TLS index\n    // Check if allocation was successful and set the value\n    if ((tlsIndex != 0xffffffff) && TlsSetValue(tlsIndex, flsGetValueAddress)) {\n        __init_pointers(); // Initialize pointers for the thread\n        // Encode pointers for security\n        flsAllocAddress = (FARPROC)__encode_pointer((int)flsAllocAddress);\n        flsGetValueAddress = (FARPROC)__encode_pointer((int)flsGetValueAddress);\n        flsSetValueAddress = (FARPROC)__encode_pointer((int)flsSetValueAddress);\n        flsFreeAddress = (FARPROC)__encode_pointer((int)flsFreeAddress);\n        \n        int lockInitResult = __mtinitlocks(); // Initialize locks for multi-threading\n        if (lockInitResult != 0) { // Check if locks were initialized successfully\n            code *functionPointer = (code *)__decode_pointer((int)flsAllocAddress); // Decode the function pointer\n            fiberLocalStorageResult = (*functionPointer)(__freefls_4); // Call the function to free fiber-local storage\n            // Check if the function call was successful and allocate memory for thread data\n            if ((fiberLocalStorageResult != -1) && (_ptiddata threadData = (_ptiddata)__calloc_crt(1, 0x214), threadData != (_ptiddata)0x0)) {\n                lockInitResult = fiberLocalStorageResult; // Store the result of the function call\n                functionPointer = (code *)__decode_pointer((int)flsSetValueAddress); // Decode the set value function pointer\n                // Set the value for the thread data\n                if ((*functionPointer)(lockInitResult, threadData) != 0) {\n                    __initptd(threadData, (pthreadlocinfo)0x0); // Initialize thread-local data\n                    threadData->_thandle = 0xffffffff; // Set thread handle\n                    threadData->_tid = GetCurrentThreadId(); // Store the current thread ID\n                    return 1; // Return 1 indicating success\n                }\n            }\n        }\n    }\n    __mtterm(); // Terminate if initialization failed\n    return 0; // Return 0 indicating failure\n}\n"}
{"Function Name": "___getlocaleinfo", "Address": "100154bd", "Source Code": "\nint __cdecl\n___getlocaleinfo(_locale_t _Locale, int _Lc_type, LPCWSTR _LocaleName, LCTYPE _FieldType, void *_Address)\n{\n    byte bVar1; // Variable to hold a byte value\n    size_t sVar3; // Variable to hold size information\n    DWORD DVar4; // Variable to hold a DWORD value for error checking\n    LPSTR _LpLCData; // Pointer to locale data\n    char *_Dst; // Pointer for destination string\n    int iVar5; // Variable to hold return value\n    errno_t eVar6; // Variable to hold error code from string operations\n    byte *pbVar7; // Pointer for byte operations\n    CHAR local_88[32]; // Local buffer for locale information\n    undefined local_68[96]; // Undefined buffer for security checks\n    uint local_8 = DAT_100345e0 ^ (uint)local_68; // Security cookie for stack protection\n\n    if (_Lc_type == 1) { // Check if locale type is 1\n        goto get_locale_info; // Jump to get_locale_info section\n    }\n\n    if (_Lc_type == 0) { // Check if locale type is 0\n        pbVar7 = &DAT_10035eec; // Initialize pointer to a specific data location\n        iVar5 = ___crtGetLocaleInfoW(_Locale, (ulong)_LocaleName, _FieldType, (wchar_t *)&DAT_10035eec, 4, 0); // Get locale info in wide char format\n        if (iVar5 != 0) { // Check if locale info retrieval was successful\n            *(undefined *)_Address = 0; // Initialize address to zero\n            do {\n                bVar1 = *pbVar7; // Get the current byte value\n                if (!_isdigit((uint)bVar1)) break; // Break if the byte is not a digit\n                pbVar7 += 2; // Move to the next byte\n                *(byte *)_Address = *_Address * '\\n' + bVar1 - 0x30; // Update the address value with the digit\n            } while ((int)pbVar7 < 0x10035ef4); // Continue until the pointer exceeds a certain limit\n        }\n    }\n\nget_locale_info: // Label for getting locale information\n    _LpLCData = local_88; // Set the locale data pointer to the local buffer\n    sVar3 = ___crtGetLocaleInfoA(_Locale, _LocaleName, _FieldType, _LpLCData, 0x80); // Get locale info in ANSI format\n    if (sVar3 == 0) { // Check if the retrieval was unsuccessful\n        DVar4 = GetLastError(); // Get the last error code\n        // Check for specific error conditions\n        if (DVar4 != 0x7a || (sVar3 = ___crtGetLocaleInfoA(_Locale, _LocaleName, _FieldType, (LPSTR)0x0, 0), sVar3 == 0) || (_LpLCData = (LPSTR)__calloc_crt(sVar3, 1), _LpLCData == (LPSTR)0x0)) {\n            goto cleanup; // Jump to cleanup if any error condition is met\n        }\n        sVar3 = ___crtGetLocaleInfoA(_Locale, _LocaleName, _FieldType, _LpLCData, sVar3); // Retry getting locale info with allocated buffer\n    }\n\n    _Dst = (char *)__calloc_crt(sVar3, 1); // Allocate memory for the destination string\n    *(char **)_Address = _Dst; // Store the destination pointer in the provided address\n    if (_Dst != (char *)0x0) { // Check if memory allocation was successful\n        eVar6 = _strncpy_s(_Dst, sVar3, _LpLCData, sVar3 - 1); // Copy the locale data to the destination\n        if (eVar6 != 0) { // Check for errors during string copy\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n        }\n        if (sVar3 == 0) { // If size is zero, free the locale data\n            _free(_LpLCData);\n        }\n        goto cleanup; // Jump to cleanup\n    }\n\ncleanup: // Cleanup section\n    _free(_LpLCData); // Free the allocated locale data\n    iVar5 = ___security_check_cookie_4(local_8 ^ (uint)local_68); // Check security cookie\n    return iVar5; // Return the result of the security check\n}\n"}
{"Function Name": "FUN_10015617", "Address": "10015617", "Source Code": "\nvoid __cdecl FUN_10015617(undefined4 input_value) // Function definition with a calling convention\n{\n    global_variable = input_value; // Assign the value of param_1 to the global variable DAT_10035ef4\n}\n"}
{"Function Name": "FUN_1001562c", "Address": "1001562c", "Source Code": "\\*\nundefined4 * method_call FUN_1001562c(void *object_instance, byte flag)\n{\n    // Set the virtual table pointer for the current object to the bad_exception vftable\n    *(undefined ***)object_instance = std::bad_exception::vftable;\n\n    // Call the destructor for the exception class on the current object\n    exception::~exception((exception *)object_instance);\n\n    // Check if the least significant bit of param_1 is set\n    if (flag & 1) {\n        // Free the memory allocated for the current object if the condition is true\n        _free(object_instance);\n    }\n\n    // Return a pointer to the current object as an undefined4 type\n    return (undefined4 *)object_instance;\n}\n*\\ \n \n\nundefined4 * method_call FUN_1001562c(void *object_instance, byte flag)\n{\n    *(undefined ***)object_instance = std::bad_exception::vftable;\n    exception::~exception((exception *)object_instance);\n    if (flag & 1) {\n        _free(object_instance);\n    }\n    return (undefined4 *)object_instance;\n}\n"}
{"Function Name": "___TypeMatch", "Address": "1001564e", "Source Code": "\nundefined4 __cdecl ___TypeMatch(byte *inputBuffer, byte *comparisonBuffer, uint *flags)\n{\n    // Retrieve the integer value from the memory location pointed by param_1 + 4\n    int value = *(int *)(inputBuffer + 4);\n    \n    // Check if iVar1 is zero or if the character at iVar1 + 8 is null\n    if ((value == 0) || (*(char *)(value + 8) == '\\0')) {\n        return 1; // Return 1 if the condition is met\n    }\n    \n    // Compare iVar1 with the integer value at param_2 + 4\n    if (value == *(int *)(comparisonBuffer + 4)) {\n        // Check multiple conditions based on bitwise operations on param_1, param_2, and param_3\n        if (((((*comparisonBuffer & 2) == 0) || ((*inputBuffer & 8) != 0)) &&\n            (((*flags & 1) == 0 || ((*inputBuffer & 1) != 0))) &&\n            (((*flags & 2) == 0 || ((*inputBuffer & 2) != 0))))) {\n            return 1; // Return 1 if all conditions are satisfied\n        }\n    } else {\n        // Compare the strings at iVar1 + 8 and the string at param_2 + 4 + 8\n        if (stringCompare((char *)(value + 8), (char *)(*(int *)(comparisonBuffer + 4) + 8)) == 0) {\n            // Check multiple conditions based on bitwise operations on param_1, param_2, and param_3\n            if (((((*comparisonBuffer & 2) == 0) || ((*inputBuffer & 8) != 0)) &&\n                (((*flags & 1) == 0 || ((*inputBuffer & 1) != 0))) &&\n                (((*flags & 2) == 0 || ((*inputBuffer & 2) != 0))))) {\n                return 1; // Return 1 if all conditions are satisfied\n            }\n        }\n    }\n    \n    // Return 0 if none of the conditions are met\n    return 0;\n}\n"}
{"Function Name": "___FrameUnwindToState", "Address": "100156ee", "Source Code": "\nvoid __cdecl ___FrameUnwindToState(int frame_pointer, undefined4 undefined_value, int state_data, int target_state)\n{\n    _ptiddata thread_local_data; // Pointer to thread-local data\n    int current_state; // Variable to hold the current state\n\n    // Check if the value at param_3 + 4 is less than 0x81\n    if (*(int *)(state_data + 4) < 0x81) {\n        // If true, get the state as a char and cast to int\n        current_state = (int)*(char *)(frame_pointer + 8);\n    } else {\n        // Otherwise, get the state directly as an int\n        current_state = *(int *)(frame_pointer + 8);\n    }\n\n    thread_local_data = __getptd(); // Get the pointer to thread-local data\n    thread_local_data->_ProcessingThrow++; // Increment the processing throw counter\n\n    // Loop until the current state matches the target state\n    while (current_state != target_state) {\n        // Check for inconsistency in state\n        if ((current_state < 0) || (*(int *)(state_data + 4) <= current_state)) {\n            _inconsistency(); // Handle inconsistency\n        }\n\n        // Get the pointer to the next state based on the current state\n        int *next_state_pointer = (int *)(*(int *)(state_data + 8) + current_state * 8);\n        current_state = *next_state_pointer; // Update the current state to the next state\n\n        // Check if the next state is valid\n        if (next_state_pointer[1] != 0) {\n            *(int *)(frame_pointer + 8) = current_state; // Update the state in param_1\n            // Call the setting frame function with the new state\n            __CallSettingFrame_12(*(undefined4 *)(*(int *)(state_data + 8) + 4 + current_state * 8), frame_pointer, 0x103);\n        }\n    }\n\n    FUN_100157b4(); // Call a function to finalize the unwind process\n\n    // Check if the final state matches the target state\n    if (current_state != target_state) {\n        _inconsistency(); // Handle inconsistency if states do not match\n    }\n\n    *(int *)(frame_pointer + 8) = current_state; // Update the final state in param_1\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_100157b4", "Address": "100157b4", "Source Code": "\nvoid FUN_100157b4(void) // Function definition\n{\n    _ptiddata threadLocalData = __getptd(); // Retrieve the thread-local data pointer\n    if (0 < threadLocalData->_ProcessingThrow) { // Check if _ProcessingThrow is greater than 0\n        threadLocalData->_ProcessingThrow--; // Decrement _ProcessingThrow\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "IsInExceptionSpec", "Address": "1001588d", "Source Code": "\nuchar __cdecl IsInExceptionSpec(EHExceptionRecord *exceptionRecord, _s_ESTypeList *typeList)\n{\n    int *typeCount; // Pointer to an integer, possibly representing a list of types\n    int counter = 0; // Local counter for iteration\n    uchar isMatchFound = '\\0'; // Local variable to store the result (default is false)\n\n    // Check if the pointer to the list of types is null\n    if (typeCount == (int *)0x0) {\n        _inconsistency(); // Handle inconsistency\n        terminate(); // Terminate the program\n        return isMatchFound; // Return the default result\n    }\n\n    // Check if the count of types is greater than zero\n    if (0 < *typeCount) {\n        do {\n            // Retrieve the pointer to the list of types from the exception record\n            byte **typePointerList = *(byte ***)(*(int *)(exceptionRecord + 0x1c) + 0xc);\n            byte *remainingTypes = *typePointerList; // Get the first type in the list\n\n            // Check if the number of types to match is greater than zero\n            if (0 < (int)remainingTypes) {\n                do {\n                    typePointerList++; // Move to the next type in the list\n                    // Check if the current type matches the type at the current index\n                    if (___TypeMatch((byte *)(typeCount[1] + counter * 0x10), *typePointerList, *(uint **)(exceptionRecord + 0x1c))) {\n                        isMatchFound = '\\x01'; // Set result to true if a match is found\n                        break; // Exit the inner loop\n                    }\n                    remainingTypes--; // Decrement the count of types to check\n                } while (0 < (int)remainingTypes); // Continue while there are types left to check\n            }\n            counter++; // Increment the local counter\n        } while (counter < *typeCount); // Continue until all types have been checked\n    }\n    return isMatchFound; // Return the result indicating if a match was found\n}\n"}
{"Function Name": "CallUnexpected", "Address": "10015906", "Source Code": "\nvoid __cdecl CallUnexpected(_s_ESTypeList *exceptionList)\n{\n    // Check if the current exception specification is not null\n    if (getThreadData()->_curexcspec != (void *)0x0) {\n        // Call the inconsistency handler if the exception specification is set\n        handleInconsistency();\n    }\n    // Call the unexpected function to handle unexpected situations\n    handleUnexpected();\n    // Terminate the program\n    terminateProgram();\n}\n"}
{"Function Name": "Catch_All@10015937", "Address": "10015937", "Source Code": "\nvoid Catch_All_10015937(void)\n{\n    code *functionPointer; // Pointer to a function code\n    _ptiddata threadLocalData; // Pointer to thread-local data structure\n\n    threadLocalData = __getptd(); // Retrieve the thread-local data for the current thread\n    threadLocalData->_curexcspec = *(void **)(unaff_EBP + 8); // Set the current exception specification\n\n    __CxxThrowException_8(0, (byte *)0x0); // Throw an exception with a specific code and no additional data\n\n    functionPointer = (code *)swi(3); // Call a software interrupt and get the function pointer\n    (*functionPointer)(); // Execute the function pointed to by pcVar1\n}\n"}
{"Function Name": "FUN_10015a75", "Address": "10015a75", "Source Code": "\nvoid FUN_10015a75(void)\n{\n    _ptiddata threadLocalData; // Pointer to thread-local data structure\n    int *unspecifiedIntArray;   // Pointer to an unspecified integer array or structure\n\n    // Store a value from the stack frame into a specific location in memory\n    *(undefined4 *)(ediPointer + -4) = *(undefined4 *)(ebpPointer + -0x24);\n    \n    // Unlink the current frame from the exception handling chain\n    __FindAndUnlinkFrame(*(void **)(ebpPointer + -0x28));\n    \n    // Retrieve the current thread-local data\n    threadLocalData = __getptd();\n    \n    // Set the current exception and context in the thread-local data\n    threadLocalData->_curexception = *(void **)(ebpPointer + -0x2c);\n    threadLocalData->_curcontext = *(void **)(ebpPointer + -0x30);\n    \n    // Check specific conditions related to the exception state\n    if (((*unspecifiedIntArray == -0x1f928c9d) && (unspecifiedIntArray[4] == 3)) &&\n        ((*(int *)(ebpPointer + -0x34) == 0 && (*(int *)(ebpPointer + -0x1c) != 0)))) {\n        \n        // If the exception object is marked for destruction, destruct it\n        if (__IsExceptionObjectToBeDestroyed(unspecifiedIntArray[6]) != 0) {\n            ___DestructExceptionObject(unspecifiedIntArray);\n        }\n    }\n    \n    return; // Exit the function\n}\n"}
{"Function Name": "___BuildCatchObject", "Address": "10015c6a", "Source Code": "\nvoid __cdecl ___BuildCatchObject(int inputParam, int *dataPointer, uint *flags, byte *buffer)\n{\n    char result; // Variable to store the result from the helper function\n    int *adjustedPointer = dataPointer; // Initialize pointer to param_2\n\n    // Check if the high bit of param_3 is not set\n    if ((*flags & 0x80000000) == 0) {\n        // Adjust piVar2 based on the values in param_3 and param_2\n        adjustedPointer = (int *)(flags[2] + 0xc + (int)dataPointer);\n    }\n\n    // Call the helper function and store the result in cVar1\n    result = ___BuildCatchObjectHelper(inputParam, dataPointer, flags, buffer);\n\n    // Check if the result indicates a specific condition\n    if (result == 1 || result == 2) {\n        // Adjust the pointer based on the value at param_1 + 0x18 and param_4 + 8\n        ___AdjustPointer(*(int *)(inputParam + 0x18), (int *)(buffer + 8));\n        // Call a member function with the adjusted pointer and a value from param_4\n        FID_conflict__CallMemberFunction1(adjustedPointer, *(undefined **)(buffer + 0x18));\n    }\n}\n"}
{"Function Name": "CatchIt", "Address": "10015cfb", "Source Code": "\nvoid __cdecl\nCatchIt(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, _s_HandlerType *param_6, _s_CatchableType *param_7,\n_s_TryBlockMapEntry *param_8, int param_9, EHRegistrationNode *param_10, uchar param_11)\n{\n    void *pvVar1; // Variable to hold the result of the catch block call\n    int *unaff_ESI; // Pointer to an unspecified integer (used for state management)\n    int *unaff_EDI; // Pointer to another unspecified integer (used for state management)\n\n    // Check if the function info structure is not null\n    if (param_5 != (_s_FuncInfo *)0x0) {\n        // Build the catch object using the provided parameters\n        ___BuildCatchObject((int)param_1, unaff_ESI, (uint *)unaff_ESI, (byte *)param_5);\n    }\n    \n    // If the catchable type is null, assign it from the unaff_ESI\n    if (param_7 == (_s_CatchableType *)0x0) {\n        param_7 = (_s_CatchableType *)unaff_ESI;\n    }\n    \n    // Unwind nested frames for exception handling\n    _UnwindNestedFrames((EHRegistrationNode *)param_7, param_1);\n    \n    // Unwind the frame to a specific state\n    ___FrameUnwindToState((int)unaff_ESI, param_3, (int)param_4, *unaff_EDI);\n    \n    // Update the state in the unaff_ESI structure\n    unaff_ESI[2] = unaff_EDI[1] + 1;\n    \n    // Call the catch block and store the result\n    pvVar1 = CallCatchBlock(param_1, (EHRegistrationNode *)unaff_ESI, (EHRegistrationNode *)param_2,\n                             (_s_FuncInfo *)param_4, param_6, 0x100, (ulong)unaff_ESI);\n    \n    // If the catch block returned a valid pointer, jump to the continuation\n    if (pvVar1 != (void *)0x0) {\n        _JumpToContinuation(pvVar1, (EHRegistrationNode *)unaff_ESI);\n    }\n    \n    return; // Exit the function\n}\n"}
{"Function Name": "FindHandler", "Address": "10015e59", "Source Code": "\nvoid __cdecl\nFindHandler(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, uchar param_6, int param_7, EHRegistrationNode *param_8)\n{\n    int local_c; // Local variable to store the current state\n    bool bVar4; // Boolean variable for comparison\n    _ptiddata p_Var5; // Pointer to thread-local data\n    int iVar6; // Variable for storing return values from functions\n    _s_FuncInfo *p_Var11; // Pointer to function information structure\n    uint uVar8; // Variable for storing unsigned integer values\n    HandlerType *local_10; // Pointer to handler type\n    char local_5 = '\\0'; // Local variable to indicate if a catch was found\n\n    // Check if the maximum state is less than a threshold\n    if (param_5->maxState < 0x81) {\n        local_c = (int)(char)param_2[8]; // Get state from param_2 if maxState is low\n    } else {\n        local_c = *(int *)(param_2 + 8); // Get state from param_2 otherwise\n    }\n\n    // Validate the local_c state\n    if ((local_c < -1) || (param_5->maxState <= local_c)) {\n        _inconsistency(); // Trigger inconsistency if state is invalid\n    }\n\n    p_Var11 = (_s_FuncInfo *)param_1; // Cast param_1 to function info pointer\n    // Check for a specific magic number in the exception record\n    if (*(int *)param_1 == -0x1f928c9d) {\n        uVar8 = 0x19930520; // Set a specific value for uVar8\n        // Validate several conditions related to the exception record\n        if (((*(int *)(param_1 + 0x10) == 3) &&\n            (((iVar6 = *(int *)(param_1 + 0x14), iVar6 == 0x19930520 || (iVar6 == 0x19930521)) ||\n            (iVar6 == 0x19930522)))) && (*(int *)(param_1 + 0x1c) == 0)) {\n            p_Var5 = __getptd(); // Get thread-local data\n            // Check if there is a current exception\n            if (p_Var5->_curexception == (void *)0x0) {\n                return; // Exit if no current exception\n            }\n            p_Var11 = (_s_FuncInfo *)p_Var5->_curexception; // Update function info pointer\n            param_1 = (EHExceptionRecord *)p_Var11; // Update exception record pointer\n            param_3 = (_CONTEXT *)__getptd()->_curcontext; // Update context pointer\n            iVar6 = _ValidateRead(p_Var11, 1); // Validate read access to function info\n            if (iVar6 == 0) {\n                _inconsistency(); // Trigger inconsistency if validation fails\n            }\n            // Validate magic number and try block map\n            if ((((p_Var11->magicNumber_and_bbtFlags == 0xe06d7363) &&\n                (p_Var11->pTryBlockMap == (TryBlockMapEntry *)0x3)) &&\n                ((uVar8 = p_Var11->nIPMapEntries, uVar8 == 0x19930520 ||\n                ((uVar8 == 0x19930521 || (uVar8 == 0x19930522)))))) &&\n                (p_Var11->pESTypeList == (ESTypeList *)0x0)) {\n                _inconsistency(); // Trigger inconsistency if validation fails\n            }\n            // Check if there is a current exception specification\n            if (p_Var5->_curexcspec != (void *)0x0) {\n                int *piVar2 = (int *)p_Var5->_curexcspec; // Get current exception specification\n                p_Var5->_curexcspec = (void *)0x0; // Reset current exception specification\n                uchar uVar3 = IsInExceptionSpec(param_1, (_s_ESTypeList *)unaff_EDI); // Check if in exception spec\n                if (uVar3 == '\\0') {\n                    uVar8 = 0; // Reset uVar8\n                    // Iterate through exception specifications\n                    if (0 < *piVar2) {\n                        for (int i = 0; i < *piVar2; i++) {\n                            bVar4 = type_info::operator==(*(type_info **)(uVar8 + 4 + piVar2[1]),\n                                                           (type_info *)&std::bad_exception::RTTI_Type_Descriptor); // Compare type info\n                            if (bVar4) {\n                                ___DestructExceptionObject((int *)param_1); // Destruct exception object\n                                param_1 = (EHExceptionRecord *)s_bad_exception_1002e31c; // Set to bad exception\n                                std::exception::exception((exception *)&stack0xffffffd0, (char **)&param_1); // Create exception\n                                in_stack_ffffffd0 = std::bad_exception::vftable; // Set vtable for bad exception\n                                __CxxThrowException_8(&stack0xffffffd0, &DAT_10032c9c); // Throw exception\n                                goto LAB_10015fd8; // Jump to label\n                            }\n                            uVar8 += 0x10; // Increment uVar8\n                        }\n                    }\n                    goto LAB_10015f97; // Jump to label\n                }\n            }\n        }\n    }\nLAB_10015fd8:\n    // Validate magic number and try block map again\n    if (((p_Var11->magicNumber_and_bbtFlags == 0xe06d7363) &&\n        (p_Var11->pTryBlockMap == (TryBlockMapEntry *)0x3)) &&\n        ((uVar8 = p_Var11->nIPMapEntries, uVar8 == uVar8 ||\n        ((uVar8 == 0x19930521 || (uVar8 == 0x19930522)))))) {\n        // Check if there are any try blocks\n        if (param_5->nTryBlocks != 0) {\n            _s_TryBlockMapEntry *p_Var7 = _GetRangeOfTrysToCheck(param_5, param_7, local_c, &local_14, &local_20); // Get range of try blocks\n            for (; local_14 < local_20; local_14++) {\n                // Check if the current state is within the try block range\n                if ((p_Var7->tryLow <= local_c) && (local_c <= p_Var7->tryHigh)) {\n                    local_10 = p_Var7->pHandlerArray; // Get handler array\n                    for (int local_1c = p_Var7->nCatches; 0 < local_1c; local_1c--) {\n                        HandlerType *pHVar9 = p_Var11->pESTypeList[1].pTypeArray; // Get type array\n                        for (uint local_18 = pHVar9->adjectives; 0 < (int)local_18; local_18--) {\n                            pHVar9 = (HandlerType *)&pHVar9->pType; // Move to next type\n                            _s_FuncInfo *p_Var10 = *(_s_FuncInfo **)pHVar9; // Get function info from type\n                            iVar6 = ___TypeMatch((byte *)local_10, (byte *)p_Var10, (uint *)p_Var11->pESTypeList); // Check type match\n                            if (iVar6 != 0) {\n                                local_5 = '\\x01'; // Set local_5 to indicate a catch was found\n                                // Call the catch handler\n                                CatchIt((EHExceptionRecord *)p_Var11, (EHRegistrationNode *)param_3,\n                                        (_CONTEXT *)param_4, param_5, p_Var10, (_s_HandlerType *)param_7,\n                                        (_s_CatchableType *)param_8, unaff_EDI, unaff_ESI, unaff_EBX,\n                                        (uchar)SUB41(in_stack_ffffffd0, 0));\n                                goto LAB_100160c1; // Jump to label\n                            }\n                        }\n                        local_10++; // Move to next handler\n                    }\n                }\n                p_Var7++; // Move to next try block entry\n            }\n        }\n    }\nLAB_100160c1:\n    // Check if exception object needs to be destructed\n    if (param_6 != '\\0') {\n        ___DestructExceptionObject((int *)p_Var11); // Destruct exception object\n    }\n    // Validate if a catch was found or if other conditions are met\n    if (((local_5 != '\\0') || ((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930521)) ||\n        (param_5->pESTypeList == (ESTypeList *)0x0) ||\n        (IsInExceptionSpec((EHExceptionRecord *)p_Var11, (_s_ESTypeList *)unaff_EDI) != '\\0')) {\n        goto LAB_10016197; // Jump to label\n    }\n    __getptd(); // Get thread-local data\n    p_Var5 = __getptd(); // Get thread-local data again\n    p_Var5->_curexception = p_Var11; // Set current exception\n    p_Var5 = __getptd(); // Get thread-local data again\n    p_Var5->_curcontext = param_3; // Set current context\n    EHRegistrationNode *pEVar12 = param_8 ? param_8 : param_2; // Determine registration node\n    _UnwindNestedFrames(pEVar12, (EHExceptionRecord *)p_Var11); // Unwind nested frames\n    ___FrameUnwindToState((int)param_2, param_4, (int)param_5, -1); // Unwind to a specific state\n    CallUnexpected(param_5); // Call unexpected handler\nLAB_10016197:\n    // Check if there is a current exception specification\n    if (__getptd()->_curexcspec != (void *)0x0) {\n        _inconsistency(); // Trigger inconsistency if there is an exception spec\n    }\n    return; // Exit function\n}\n"}
{"Function Name": "terminate", "Address": "100162ab", "Source Code": "\nvoid __cdecl terminate(void)\n{\n    // Check if the terminate function pointer is not null\n    if (__getptd()->_terminate != (code *)0x0) {\n        // Call the terminate function if it is set\n        (*(code *)__getptd()->_terminate)();\n    }\n    // Call the abort function to terminate the program\n    abortProgram();\n}\n"}
{"Function Name": "unexpected", "Address": "100162e4", "Source Code": "\nvoid cdecl_handler unexpected(void)\n{\n    // Check if there is a user-defined unexpected handler set\n    if (get_thread_data()->_unexpected) {\n        // Call the user-defined unexpected handler if it exists\n        (*(code *)get_thread_data()->_unexpected)();\n    }\n    // Terminate the program if no handler is defined or after the handler is called\n    exit_program();\n}\n"}
{"Function Name": "_inconsistency", "Address": "100162f7", "Source Code": "\nvoid __cdecl _inconsistency(void)\n{\n    // Decode the pointer stored in DAT_10035ef8 and cast it to a function pointer type\n    code *decodedFunctionPointer = (code *)__decode_pointer(encodedPointer);\n    \n    // Check if the decoded pointer is not NULL\n    if (decodedFunctionPointer != NULL) {\n        // Call the function pointed to by pcVar1\n        (*decodedFunctionPointer)();\n    }\n    \n    // Terminate the program\n    terminate();\n}\n"}
{"Function Name": "__initp_eh_hooks", "Address": "1001632e", "Source Code": "\nvoid __initp_eh_hooks(void) // Function to initialize exception handling hooks\n{\n    encoded_pointer = __encode_pointer(0x100162ab); // Encode the pointer 0x100162ab and store it in DAT_10035ef8\n}\n"}
{"Function Name": "FUN_100164d6", "Address": "100164d6", "Source Code": "\nvoid initializeFunction(void) // Function definition for FUN_100164d6\n{\n    callAnotherFunction(4); // Call the function FUN_10016973 with an argument of 4\n}\n"}
{"Function Name": "FUN_100165a2", "Address": "100165a2", "Source Code": "\n// Function declaration with a calling convention\nvoid __cdecl FUN_100165a2(undefined4 input_value)\n{\n    // Assign the value of param_1 to the global variable DAT_10036224\n    global_variable = input_value;\n}\n"}
{"Function Name": "__callnewh", "Address": "100165ac", "Source Code": "\nint __cdecl __callnewh(size_t size) // Function definition with calling convention and parameter\n{\n    code *decodedFunctionPointer = (code *)__decode_pointer(globalPointer); // Decode pointer from global variable DAT_10036224\n    if (decodedFunctionPointer != (code *)0x0 && (*decodedFunctionPointer)(size) != 0) { // Check if the decoded pointer is not null and call the function it points to with _Size\n        return 1; // Return 1 if the function call is successful\n    }\n    return 0; // Return 0 if the pointer is null or the function call fails\n}\n"}
{"Function Name": "__get_errno_from_oserr", "Address": "10016633", "Source Code": "\nint __cdecl __get_errno_from_oserr(ulong error_code)\n{\n    int index = 0; // Initialize index variable to 0\n    while (index < 0x2d) { // Loop through the first 45 elements\n        if (error_code == (&error_codes)[index * 2]) { // Check if param_1 matches the current error code\n            return (&errno_values)[index * 2]; // Return the corresponding errno value\n        }\n        index++; // Increment index variable\n    }\n    if (error_code - 0x13 < 0x12) { // Check if param_1 is within a specific range\n        return 0xd; // Return a specific errno value for this range\n    }\n    return (-(uint)(0xe < error_code - 0xbc) & 0xe) + 8; // Return a calculated errno value based on param_1\n}\n"}
{"Function Name": "__errno", "Address": "1001666e", "Source Code": "\nint * __cdecl getThreadErrno(void) // Function to retrieve a pointer to the thread-specific errno variable\n{\n    _ptiddata threadLocalData = __getptd_noexit(); // Get the thread-local data structure without exiting if it fails\n    if (threadLocalData == (_ptiddata)0x0) { // Check if the thread-local data structure is null\n        return (int *)&globalErrno; // Return a pointer to a global errno variable if thread-local data is null\n    }\n    return &threadLocalData->_terrno; // Return a pointer to the thread-specific errno variable\n}\n"}
{"Function Name": "___doserrno", "Address": "10016681", "Source Code": "\n___doserrno(void)  // Function declaration for ___doserrno\n{\n    _ptiddata threadLocalData = __getptd_noexit();  // Retrieve thread-local data without exiting\n\n    // Return the address of the DOS error number based on the validity of p_Var1\n    return (threadLocalData == (_ptiddata)0x0) ? (ulong *)&dosErrorAddress : &threadLocalData->_tdoserrno;  \n}\n"}
{"Function Name": "__dosmaperr", "Address": "10016694", "Source Code": "\nvoid __cdecl __dosmaperr(ulong dos_error_number)\n{\n    // Set the DOS error number using the provided parameter\n    *___doserrno() = dos_error_number;\n    \n    // Map the DOS error to a standard errno value and set it\n    *__errno() = __get_errno_from_oserr(dos_error_number);\n}\n"}
{"Function Name": "___heap_select", "Address": "100167ac", "Source Code": "\nundefined4 ___heap_select(void) // Function definition for ___heap_select\n{\n    uint windows_major_version = 0; // Variable to store Windows major version\n    int os_platform = 0;  // Variable to store OS platform\n\n    // Check the OS platform and invoke Watson if it fails\n    if (__get_osplatform(&os_platform) != 0) {\n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    \n    // Check the Windows major version and invoke Watson if it fails\n    if (__get_winmajor(&windows_major_version) != 0) {\n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    \n    // Check if the OS platform is Windows 8 and the major version is greater than 4\n    if (os_platform == 2 && windows_major_version > 4) {\n        return 1; // Return 1 if conditions are met\n    }\n    \n    return 3; // Return 3 if conditions are not met\n}\n"}
{"Function Name": "__heap_init", "Address": "10016807", "Source Code": "\nint __cdecl __heap_init(void)\n{\n    // Create a new heap with initial size of 0x1000 bytes and no maximum size\n    heap_handle = HeapCreate(0, 0x1000, 0);\n    \n    // Check if heap creation was unsuccessful\n    if (heap_handle == (HANDLE)0x0) {\n        return 0; // Return 0 to indicate failure\n    }\n    \n    // Check if the selected heap is 3 and initialize the small block heap\n    if ((___heap_select() == 3) && (___sbh_heap_init(0x3f8) == 0)) {\n        // If small block heap initialization fails, destroy the created heap\n        HeapDestroy(heap_handle);\n        heap_handle = (HANDLE)0x0; // Set the heap handle to null\n        return 0; // Return 0 to indicate failure\n    }\n    \n    return 1; // Return 1 to indicate successful heap initialization\n}\n"}
{"Function Name": "__heap_term", "Address": "10016861", "Source Code": "\nvoid __cdecl __heap_term(void)\n{\n    // Check if the heap state is in a specific condition (3)\n    if (heap_condition == 3) {\n        // Ensure there are allocated blocks to free\n        if (0 < allocated_blocks_count) {\n            // Set pointer to the first allocated block in the heap\n            LPVOID *block_pointer = (LPVOID *)((int)first_allocated_block + 0x10);\n            // Loop through each allocated block\n            for (int block_index = 0; block_index < allocated_blocks_count; block_index++) {\n                // Free the memory block using VirtualFree\n                VirtualFree(block_pointer[-1], 0, 0x8000);\n                // Free the heap memory using HeapFree\n                HeapFree(heap_handle, 0, *block_pointer);\n                // Move to the next allocated block (5 pointers ahead)\n                block_pointer += 5;\n            }\n        }\n        // Free the main heap memory\n        HeapFree(heap_handle, 0, first_allocated_block);\n    }\n    // Destroy the heap\n    HeapDestroy(heap_handle);\n    // Reset the heap handle to null\n    heap_handle = (HANDLE)0x0;\n    return; // Exit the function\n}\n"}
{"Function Name": "__mtinitlocks", "Address": "100168d5", "Source Code": "\nint __cdecl __mtinitlocks(void)\n{\n    int lockIndex = 0; // Initialize loop counter\n    undefined *lockAddress = &initialLockAddress; // Pointer to the initial lock address\n    \n    do {\n        // Check if the current lock should be initialized\n        if ((&lockInitializationFlags)[lockIndex * 2] == 1) {\n            // Assign the lock address to the corresponding entry\n            (&lockEntries)[lockIndex * 2] = lockAddress;\n            lockAddress += 0x18; // Move to the next lock address\n            \n            // Initialize the critical section with a spin count of 4000\n            if (initializeCriticalSection((&lockEntries)[lockIndex * 2], 4000) == 0) {\n                // If initialization fails, reset the lock entry to 0\n                (&lockEntries)[lockIndex * 2] = 0;\n                return 0; // Return failure\n            }\n        }\n        lockIndex++; // Increment loop counter\n    } while (lockIndex < 0x24); // Continue until all locks are processed\n    \n    return 1; // Return success\n}\n"}
{"Function Name": "__mtinitlocknum", "Address": "10016988", "Source Code": "\nint __cdecl __mtinitlocknum(int lockNumber)\n{\n    void **lockPointer; // Pointer to a pointer for the lock variable\n    void *allocatedMemory;  // Pointer to hold allocated memory for the lock\n    int *errnoPointer;    // Pointer to hold the address of errno\n    int statusCode = 1;  // Variable to indicate success or failure\n\n    // Check if the global variable is zero\n    if (globalLockCheck == 0) {\n        displayMessageBanner(); // Display a message banner\n        logErrorMessage(0x1e); // Write a message to the error log\n        exitProcessWithError(0xff); // Exit the process with an error code\n    }\n    \n    // Calculate the address of the lock variable based on _LockNum\n    lockPointer = (void **)(&lockAddressBase + lockNumber * 2);\n    \n    // Check if the lock variable is already initialized\n    if (*lockPointer == (void *)0x0) {\n        allocatedMemory = allocateMemory(0x18); // Allocate memory for the lock\n        if (allocatedMemory == (void *)0x0) { // Check if memory allocation failed\n            errnoPointer = __errno(); // Get the address of errno\n            *errnoPointer = 0xc; // Set errno to indicate memory allocation error\n            statusCode = 0; // Set return value to indicate failure\n        } else {\n            acquireLock(10); // Acquire a lock to ensure thread safety\n            // Check again if the lock variable is still uninitialized\n            if (*lockPointer == (void *)0x0) {\n                statusCode = initializeCriticalSection(allocatedMemory, 4000); // Initialize the critical section\n                if (statusCode == 0) { // Check if initialization failed\n                    freeMemory(allocatedMemory); // Free the allocated memory\n                    errnoPointer = __errno(); // Get the address of errno\n                    *errnoPointer = 0xc; // Set errno to indicate initialization error\n                    statusCode = 0; // Set return value to indicate failure\n                } else {\n                    *lockPointer = allocatedMemory; // Store the initialized lock in the pointer\n                }\n            } else {\n                freeMemory(allocatedMemory); // Free the allocated memory if lock was initialized by another thread\n            }\n        }\n        cleanupFunction(); // Call a function (possibly for cleanup or logging)\n    }\n    \n    return statusCode; // Return success or failure status\n}\n"}
{"Function Name": "FUN_10016a42", "Address": "10016a42", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10016a42\n{\n    callAnotherFunction(10); // Call the function FUN_10016973 with an argument of 10\n}\n"}
{"Function Name": "__lock", "Address": "10016a4b", "Source Code": "\nvoid __cdecl __lock(int fileIndex)\n{\n    // Check if the critical section for the given file index is uninitialized\n    if ((LPCRITICAL_SECTION)(&criticalSectionsArray)[fileIndex * 2] == (LPCRITICAL_SECTION)0x0) {\n        // Initialize the lock for the file if it is not already initialized\n        if (initializeLock(fileIndex) == 0) {\n            // Exit the program with an error code if initialization fails\n            exitWithError(0x11);\n        }\n    }\n    // Enter the critical section for the specified file index to acquire the lock\n    enterCriticalSection((LPCRITICAL_SECTION)(&criticalSectionsArray)[fileIndex * 2]);\n}\n"}
{"Function Name": "___sbh_heap_init", "Address": "10016a7c", "Source Code": "\nundefined4 initialize_heap(undefined4 input_param)\n{\n    // Allocate memory from the heap with a size of 0x140 bytes\n    allocated_memory = HeapAlloc(heap_handle, 0, 0x140);\n    \n    // Check if memory allocation was successful\n    if (allocated_memory == (LPVOID)0x0) {\n        return 0; // Return 0 if allocation failed\n    }\n    \n    // Store the allocated memory pointer in DAT_100377e8\n    memory_pointer = allocated_memory;\n    \n    // Store the parameter value in DAT_100377e4\n    parameter_value = input_param;\n    \n    // Initialize a value (possibly a size or flag) in DAT_100377ec\n    initialization_flag = 0x10;\n    \n    // Return 1 to indicate successful initialization\n    return 1;\n}\n"}
{"Function Name": "thunk_FUN_10016ae8", "Address": "10016ac4", "Source Code": "\nvoid __thiscall thunk_FUN_10016ae8(void *instance, int input_param)\n{\n    // Call the function FUN_10016ae8 with a calculated pointer and the provided parameter\n    FUN_10016ae8((void *)(offset_multiplier * 0x14 + base_address), input_param);\n}\n"}
{"Function Name": "___sbh_resize_block", "Address": "10016fb9", "Source Code": "\nundefined4 __cdecl ___sbh_resize_block(uint *param_1, int param_2, int param_3)\n{\n    char *charPointer; // Pointer to a character\n    uint *unsignedIntPointer; // Pointer to an unsigned integer\n    int integerVar1; // Integer variable\n    int *intPointer; // Pointer to an integer\n    int integerVar2; // Integer variable for calculations\n    char characterVar; // Character variable\n    uint unsignedIntVar1; // Unsigned integer variable\n    uint *unsignedIntPointer2; // Pointer to an unsigned integer\n    int integerVar3; // Integer variable for calculations\n    uint unsignedIntVar2; // Unsigned integer variable\n    uint unsignedIntVar3; // Unsigned integer variable\n    uint unsignedIntVar4; // Unsigned integer variable\n    uint unsignedIntVar5; // Unsigned integer variable\n    uint localVar; // Local variable for calculations\n\n    unsignedIntVar1 = param_1[4]; // Get the value at index 4 of param_1\n    unsignedIntVar2 = param_2 - param_1[3] >> 0xf; // Calculate uVar10 based on param_2 and param_1[3]\n    integerVar2 = unsignedIntVar2 * 0x204 + 0x144 + unsignedIntVar1; // Calculate iVar5 based on uVar10 and uVar7\n    unsignedIntVar4 = param_3 + 0x17U & 0xfffffff0; // Align param_3 to the nearest multiple of 16\n    integerVar3 = *(int *)(param_2 + -4) + -1; // Get the value at param_2 - 4 and decrement it\n    unsignedIntPointer2 = (uint *)(*(int *)(param_2 + -4) + -5 + param_2); // Pointer to a block of memory based on param_2\n    unsignedIntVar5 = *unsignedIntPointer2; // Get the value pointed to by puVar8\n\n    if (integerVar3 < (int)unsignedIntVar4) { // Check if iVar9 is less than uVar12\n        if (((unsignedIntVar5 & 1) != 0) || ((int)(unsignedIntVar5 + integerVar3) < (int)unsignedIntVar4)) { // Check conditions on uVar13\n            return 0; // Return 0 if conditions are met\n        }\n        localVar = ((int)unsignedIntVar5 >> 4) - 1; // Calculate local_c based on uVar13\n        if (localVar > 0x3f) { // Cap local_c at 63\n            localVar = 0x3f;\n        }\n        charPointer = (char *)(localVar + 4 + unsignedIntVar1); // Pointer to a character based on local_c and uVar7\n        unsignedIntVar3 = ~(0x80000000U >> ((byte)localVar & 0x1f)); // Calculate uVar11 for bit manipulation\n        unsignedIntPointer = (uint *)(unsignedIntVar1 + (localVar < 0x20 ? 0x44 : 0xc4) + unsignedIntVar2 * 4); // Pointer based on local_c and uVar10\n        *unsignedIntPointer &= unsignedIntVar3; // Update the value pointed to by puVar2\n        *charPointer += -1; // Decrement the value pointed to by pcVar1\n        if (*charPointer == '\\0') { // Check if the value pointed to by pcVar1 is zero\n            if (localVar < 0x20) {\n                *param_1 &= unsignedIntVar3; // Update param_1 if local_c is less than 32\n            } else {\n                param_1[1] &= unsignedIntVar3; // Update param_1[1] if local_c is 32 or more\n            }\n        }\n    }\n\n    *(uint *)(unsignedIntPointer2[2] + 4) = unsignedIntPointer2[1]; // Update memory based on puVar8\n    *(uint *)(unsignedIntPointer2[1] + 8) = unsignedIntPointer2[2]; // Update memory based on puVar8\n    integerVar3 = unsignedIntVar5 + (integerVar3 - unsignedIntVar4); // Calculate new iVar9\n    if (0 < integerVar3) { // Check if iVar9 is positive\n        unsignedIntVar5 = (integerVar3 >> 4) - 1; // Calculate uVar13 based on iVar9\n        if (unsignedIntVar5 > 0x3f) { // Cap uVar13 at 63\n            unsignedIntVar5 = 0x3f;\n        }\n        integerVar2 += unsignedIntVar5 * 8; // Update iVar5 based on uVar13\n        *(undefined4 *)(param_2 + -4 + unsignedIntVar4 + 4) = *(undefined4 *)(integerVar2 + 4); // Update memory\n        *(int *)(param_2 + -4 + unsignedIntVar4 + 8) = integerVar2; // Update memory\n        *(int *)(integerVar2 + 4) = param_2 + -4 + unsignedIntVar4; // Update memory\n        *(int *)(*(int *)(param_2 + -4 + unsignedIntVar4 + 4) + 8) = param_2 + -4 + unsignedIntVar4; // Update memory\n        \n        characterVar = *(char *)(unsignedIntVar5 + 4 + unsignedIntVar1); // Get the character at calculated position\n        *(char *)(unsignedIntVar5 + 4 + unsignedIntVar1) = characterVar + '\\x01'; // Increment the character\n        if (unsignedIntVar5 < 0x20) { // Check if uVar13 is less than 32\n            if (characterVar == '\\0') { // Check if the character is zero\n                *param_1 |= 0x80000000U >> ((byte)unsignedIntVar5 & 0x1f); // Update param_1\n            }\n        } else {\n            if (characterVar == '\\0') { // Check if the character is zero\n                param_1[1] |= 0x80000000U >> ((byte)unsignedIntVar5 - 0x20 & 0x1f); // Update param_1[1]\n            }\n            unsignedIntVar5 -= 0x20; // Adjust uVar13\n        }\n        unsignedIntPointer2 = (uint *)(unsignedIntVar1 + (unsignedIntVar5 < 0x20 ? 0x44 : 0xc4) + unsignedIntVar2 * 4); // Update pointer based on uVar13\n        *unsignedIntPointer2 |= 0x80000000U >> ((byte)unsignedIntVar5 & 0x1f); // Update memory pointed by puVar8\n    }\n\n    intPointer = (int *)(param_2 + -4 + unsignedIntVar4); // Pointer to an integer based on param_2 and uVar12\n    *intPointer = integerVar3; // Set the value at piVar4 to iVar9\n    *(int *)(integerVar3 + -4 + (int)intPointer) = integerVar3; // Update memory based on iVar9\n    *(uint *)(param_2 + -4) = unsignedIntVar4 + 1; // Update memory at param_2 - 4\n    *(uint *)(param_2 + -8 + unsignedIntVar4) = unsignedIntVar4 + 1; // Update memory at param_2 - 8\n\n    return 1; // Return 1 to indicate success\n}\n"}
{"Function Name": "___sbh_alloc_block", "Address": "10017298", "Source Code": "\nint * __cdecl ___sbh_alloc_block(uint *memoryBlockPointer) // Function to allocate a block of memory\n{\n    int *returnValuePointer; // Pointer variable for return value\n    int *specificMemoryPointer; // Pointer to a specific memory location\n    uint alignedAddress; // Variable to hold aligned address\n    int indexCount; // Variable for index or count\n    uint *specificMemoryLocationPointer; // Pointer to a specific memory location\n    uint bitmaskValue; // Variable for bitmask\n    int sizeCalculation; // Variable for size calculation\n    int *specificMemoryBlockPointer; // Pointer to a specific memory location\n    uint *iterationPointer1; // Pointer for iteration\n    uint *iterationPointer2; // Pointer for iteration\n    int localGroupSize; // Local variable for storing a value\n    uint localBitmask; // Local variable for bitmask\n\n    specificMemoryLocationPointer = memoryBlockStart + memoryBlockOffset * 5; // Calculate the end of the memory block\n    alignedAddress = (int)memoryBlockPointer + 0x17U & 0xfffffff0; // Align the address to a 16-byte boundary\n    indexCount = ((int)((int)memoryBlockPointer + 0x17U) >> 4) + -1; // Calculate index based on alignment\n\n    if (indexCount < 0x20) { // Check if index is less than 32\n        bitmaskValue = 0xffffffff >> (indexCount & 0x1f); // Create bitmask for the current index\n        localBitmask = 0xffffffff; // Set local_c to all bits set\n    } else {\n        bitmaskValue = 0; // No bits set for uVar15\n        localBitmask = 0xffffffff >> (indexCount - 0x20 & 0x1f); // Create bitmask for higher indices\n    }\n\n    // Loop to find a suitable memory block\n    for (; (memoryBlockPointer < specificMemoryLocationPointer && ((memoryBlockPointer[1] & localBitmask | *memoryBlockPointer & bitmaskValue) == 0)); memoryBlockPointer = memoryBlockPointer + 5) {}\n\n    if (memoryBlockPointer == specificMemoryLocationPointer) { // If no suitable block found in the current region\n        iterationPointer1 = memoryBlockStart; // Start searching in the new region\n        // Loop to find a suitable memory block in the new region\n        for (; (iterationPointer1 < memoryBlockEnd && ((iterationPointer1[1] & localBitmask | *iterationPointer1 & bitmaskValue) == 0)); iterationPointer1 = iterationPointer1 + 5) {}\n        memoryBlockPointer = iterationPointer1; // Update param_1 to the found block\n\n        if (iterationPointer1 == memoryBlockEnd) { // If still no suitable block found\n            // Loop to find a free block in the current region\n            for (; (iterationPointer1 < specificMemoryLocationPointer && (iterationPointer1[2] == 0)); iterationPointer1 = iterationPointer1 + 5) {}\n            memoryBlockPointer = iterationPointer1; // Update param_1 to the found block\n\n            if (iterationPointer1 == specificMemoryLocationPointer) { // If no free block found\n                iterationPointer2 = memoryBlockStart; // Start searching in the new region again\n                // Loop to find a free block in the new region\n                for (; (iterationPointer2 < memoryBlockEnd && (iterationPointer2[2] == 0)); iterationPointer2 = iterationPointer2 + 5) {}\n                memoryBlockPointer = iterationPointer2; // Update param_1 to the found block\n\n                if ((iterationPointer2 == memoryBlockEnd) && (memoryBlockPointer = ___sbh_alloc_new_region(), memoryBlockPointer == (uint *)0x0)) {\n                    return (int *)0x0; // Return null if no new region could be allocated\n                }\n            }\n            indexCount = ___sbh_alloc_new_group((int)memoryBlockPointer); // Allocate a new group\n            *(int *)memoryBlockPointer[4] = indexCount; // Store the group index\n            if (*(int *)memoryBlockPointer[4] == -1) {\n                return (int *)0x0; // Return null if allocation failed\n            }\n        }\n    }\n\n    specificMemoryPointer = (int *)memoryBlockPointer[4]; // Get the pointer to the group\n    localGroupSize = *specificMemoryPointer; // Get the current size of the group\n\n    // Check if the group is empty or if there is space available\n    if ((localGroupSize == -1) || ((specificMemoryPointer[localGroupSize + 0x31] & localBitmask | specificMemoryPointer[localGroupSize + 0x11] & bitmaskValue) == 0)) {\n        localGroupSize = 0; // Reset local_8\n        uint *specificMemoryLocationPointer = (uint *)(specificMemoryPointer + 0x11); // Pointer to the start of the group\n        uint currentSize = specificMemoryPointer[0x31]; // Get the current size\n        // Loop to find the first available block\n        while ((currentSize & localBitmask | *specificMemoryLocationPointer & bitmaskValue) == 0) {\n            localGroupSize++; // Increment the index\n            specificMemoryLocationPointer++; // Move to the next block\n            currentSize = *specificMemoryLocationPointer; // Update the current size\n        }\n    }\n\n    int *specificBlockPointer = specificMemoryPointer + localGroupSize * 0x81 + 0x51; // Calculate the pointer to the specific block\n    indexCount = 0; // Initialize index\n    bitmaskValue = specificMemoryPointer[localGroupSize + 0x11] & bitmaskValue; // Get the bitmask for the current block\n\n    if (bitmaskValue == 0) { // If no bits are set\n        bitmaskValue = specificMemoryPointer[localGroupSize + 0x31] & localBitmask; // Get the bitmask for the higher indices\n        indexCount = 0x20; // Set index to 32\n    }\n\n    // Loop to count the number of bits set\n    for (; -1 < (int)bitmaskValue; bitmaskValue = bitmaskValue * 2) {\n        indexCount++; // Increment index\n    }\n\n    specificMemoryBlockPointer = (int *)specificBlockPointer[indexCount * 2 + 1]; // Get the pointer to the block\n    sizeCalculation = *specificMemoryBlockPointer - alignedAddress; // Calculate the size of the block\n    int sizeIndex = (sizeCalculation >> 4) + -1; // Calculate the index based on size\n\n    if (0x3f < sizeIndex) { // Limit the index to 63\n        sizeIndex = 0x3f; // Set to maximum index\n    }\n\n    memoryBlockEnd = memoryBlockPointer; // Update the global variable to the current block\n\n    if (sizeIndex != indexCount) { // If the index has changed\n        if (specificMemoryBlockPointer[1] == specificMemoryBlockPointer[2]) { // If the block is empty\n            char *sizePointer = (char *)((int)specificMemoryPointer + indexCount + 4); // Get the pointer to the size\n            bitmaskValue = ~(0x80000000U >> ((byte)indexCount & 0x1f)); // Create bitmask for the current index\n            if (indexCount < 0x20) { // If index is less than 32\n                specificMemoryPointer[localGroupSize + 0x11] &= bitmaskValue; // Clear the bit in the lower half\n                (*sizePointer)--; // Decrement the size\n                if (*sizePointer == '\\0') { // If size is zero\n                    *memoryBlockPointer &= bitmaskValue; // Clear the bit in param_1\n                }\n            } else { // If index is 32 or higher\n                specificMemoryPointer[localGroupSize + 0x31] &= bitmaskValue; // Clear the bit in the upper half\n                (*sizePointer)--; // Decrement the size\n                if (*sizePointer == '\\0') { // If size is zero\n                    memoryBlockPointer[1] &= bitmaskValue; // Clear the bit in param_1\n                }\n            }\n        }\n\n        *(int *)(specificMemoryBlockPointer[2] + 4) = specificMemoryBlockPointer[1]; // Update the pointers in the block\n        *(int *)(specificMemoryBlockPointer[1] + 8) = specificMemoryBlockPointer[2]; // Update the pointers in the block\n\n        if (sizeCalculation == 0) goto LAB_10017538; // If size is zero, jump to cleanup\n\n        returnValuePointer = specificBlockPointer + sizeIndex * 2; // Get the pointer to the block\n        int indexCount = returnValuePointer[1]; // Get the next pointer\n        specificMemoryBlockPointer[2] = (int)returnValuePointer; // Update the pointer in the block\n        specificMemoryBlockPointer[1] = indexCount; // Update the next pointer\n        returnValuePointer[1] = (int)specificMemoryBlockPointer; // Link the new block\n        *(int **)(specificMemoryBlockPointer[1] + 8) = specificMemoryBlockPointer; // Update the next block's pointer\n\n        if (specificMemoryBlockPointer[1] == specificMemoryBlockPointer[2]) { // If the block is now empty\n            char cVar4 = *(char *)(sizeIndex + 4 + (int)specificMemoryPointer); // Get the current size\n            *(char *)(sizeIndex + 4 + (int)specificMemoryPointer) = cVar4 + '\\x01'; // Increment the size\n            if (sizeIndex < 0x20) { // If index is less than 32\n                if (cVar4 == '\\0') { // If size was zero\n                    *memoryBlockPointer |= 0x80000000U >> (sizeIndex & 0x1f); // Set the bit in param_1\n                }\n                specificMemoryPointer[localGroupSize + 0x11] |= 0x80000000U >> (sizeIndex & 0x1f); // Set the bit in the lower half\n            } else { // If index is 32 or higher\n                if (cVar4 == '\\0') { // If size was zero\n                    memoryBlockPointer[1] |= 0x80000000U >> (sizeIndex - 0x20 & 0x1f); // Set the bit in param_1\n                }\n                specificMemoryPointer[localGroupSize + 0x31] |= 0x80000000U >> (sizeIndex - 0x20 & 0x1f); // Set the bit in the upper half\n            }\n        }\n    }\n\n    if (sizeCalculation != 0) { // If there is a size to allocate\n        *specificMemoryBlockPointer = sizeCalculation; // Set the size in the block\n        *(int *)(sizeCalculation + -4 + (int)specificMemoryBlockPointer) = sizeCalculation; // Link the size to the previous block\n    }\n\nLAB_10017538: // Cleanup label\n    specificMemoryBlockPointer = (int *)((int)specificMemoryBlockPointer + sizeCalculation); // Move the pointer forward by the size\n    *specificMemoryBlockPointer = alignedAddress + 1; // Set the size in the block\n    *(uint *)((int)specificMemoryBlockPointer + (alignedAddress - 4)) = alignedAddress + 1; // Link the size to the previous block\n    int indexCount = *specificBlockPointer; // Get the current count\n    *specificBlockPointer = indexCount + 1; // Increment the count\n\n    if (((indexCount == 0) && (memoryBlockPointer == globalMemoryPointer)) && (localGroupSize == globalGroupSize)) { // Check for specific conditions\n        globalMemoryPointer = (uint *)0x0; // Reset the global variable\n    }\n\n    *specificMemoryPointer = localGroupSize; // Update the group size\n    return specificMemoryBlockPointer + 1; // Return the pointer to the allocated block\n}\n"}
{"Function Name": "__forcdecpt_l", "Address": "10017776", "Source Code": "\nvoid __cdecl __forcdecpt_l(char *buffer, _locale_t locale)\n{\n    int charCheckResult; // Variable to store the result of character checks\n    char flag; // Local variable for a flag or state\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)localeData, locale); // Update locale settings\n\n    charCheckResult = _tolower((int)*buffer); // Convert the first character of _Buf to lowercase\n    while (charCheckResult != 0x65) { // Loop until the character is 'e' (0x65)\n        buffer++; // Move to the next character in the buffer\n        charCheckResult = _isdigit((uint)(byte)*buffer); // Check if the current character is a digit\n        if (charCheckResult == 0) break; // Exit loop if the character is not a digit\n    }\n    \n    if (_tolower((int)*buffer) == 0x78) { // Check if the current character is 'x'\n        buffer += 2; // Skip the next two characters if it is 'x'\n    }\n    \n    byte currentChar = *buffer; // Store the current character in bVar2\n    *buffer = ***(byte ***)(localeData[0] + 0xbc); // Replace the current character with a value from locale data\n    \n    do {\n        buffer++; // Move to the next character in the buffer\n        byte nextChar = *buffer; // Store the current character in bVar1\n        *buffer = currentChar; // Replace the current character with the value stored in bVar2\n        currentChar = nextChar; // Update bVar2 to the current character\n    } while (*buffer != 0); // Continue until the null terminator is reached\n    \n    if (flag != '\\0') { // Check if local_8 is not zero\n        *(uint *)(localData + 0x70) &= 0xfffffffd; // Modify a specific bit in local_c based on local_8\n    }\n    \n    return; // Exit the function\n}\n"}
{"Function Name": "__cropzeros_l", "Address": "100177e7", "Source Code": "\nvoid __cdecl __cropzeros_l(char *buffer, _locale_t locale)\n{\n    char currentChar; // Variable to hold the current character being processed\n    char *traversePtr; // Pointer to traverse the buffer\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)localeUpdate, locale); // Update locale settings\n    currentChar = *buffer; // Get the first character from the buffer\n    if (currentChar != '\\0') { // Check if the buffer is not empty\n        do {\n            // Check if the current character matches a specific locale character\n            if (currentChar == ***(char ***)(localeUpdate[0] + 0xbc)) break; // Break if a match is found\n            buffer++; // Move to the next character in the buffer\n            currentChar = *buffer; // Update cVar3 with the new character\n        } while (currentChar != '\\0'); // Continue until a null terminator is found\n    }\n    if (*buffer != '\\0') { // Check if the buffer is not empty after the first loop\n        do {\n            buffer++; // Move to the next character\n            currentChar = *buffer; // Update cVar3 with the new character\n            traversePtr = buffer; // Set pcVar1 to the current position in the buffer\n            // Break if we reach a null terminator or the character 'e'\n            if ((currentChar == '\\0') || (currentChar == 'e')) break; \n        } while (currentChar != 'E'); // Continue until we find 'E'\n        \n        do {\n            traversePtr--; // Move pcVar1 back one character\n        } while (*traversePtr == '0'); // Continue moving back while we encounter '0'\n        \n        // Check if the character before the last non-zero character matches a specific locale character\n        if (*traversePtr == ***(char ***)(localeUpdate[0] + 0xbc)) {\n            traversePtr--; // Move back if a match is found\n        }\n        \n        do {\n            currentChar = *buffer; // Get the current character\n            *traversePtr++ = currentChar; // Copy the character to the new position\n            buffer++; // Move to the next character in the buffer\n        } while (currentChar != '\\0'); // Continue until a null terminator is found\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "__cftoe_l", "Address": "10017a7a", "Source Code": "\nvoid __cdecl\n__cftoe_l(double *param_1, undefined *param_2, uint param_3, int param_4, int param_5,\nlocaleinfo_struct *param_6)\n{\n    size_t _SizeInBytes; // Variable to hold the size in bytes for the output\n    errno_t eVar2; // Variable to hold the error code from function calls\n    _strflt local_30; // Local structure to hold floating-point representation\n    char local_20[24]; // Buffer to hold the string representation of the float\n    uint local_8 = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Security cookie for stack protection\n\n    // Convert the double value to a string representation\n    __fltout2((_CRT_DOUBLE)*param_1, &local_30, local_20, 0x16);\n    \n    // Check if the output buffer is null or size is zero\n    if (param_2 == (undefined *)0x0 || param_3 == 0) {\n        *__errno() = 0x16; // Set errno to indicate an error\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n    } else {\n        // Calculate the size in bytes for the output string\n        _SizeInBytes = (param_3 == 0xffffffff) ? 0xffffffff : (param_3 - (local_30.sign == 0x2d)) - (uint)(0 < param_4);\n        \n        // Convert the floating-point representation to a string\n        eVar2 = __fptostr(param_2 + (uint)(0 < param_4) + (uint)(local_30.sign == 0x2d), _SizeInBytes, param_4 + 1, &local_30);\n        \n        // Check for conversion errors\n        if (eVar2 != 0) {\n            *param_2 = 0; // Set output to zero on error\n        } else {\n            // Call another function to finalize the conversion with locale info\n            __cftoe2_l(param_3, param_4, param_5, &local_30.sign, '\\0', param_6);\n        }\n    }\n    \n    // Security check to ensure stack integrity\n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n    return; // Exit the function\n}\n"}
{"Function Name": "__cftoa_l", "Address": "10017b66", "Source Code": "\nint __cdecl\n__cftoa_l(double *param_1, undefined *param_2, uint param_3, size_t param_4, int param_5,\nlocaleinfo_struct *param_6)\n{\n    int *piVar2; // Pointer to store the address of errno\n    size_t _SizeInBytes; // Variable to hold size in bytes\n    errno_t eVar3; // Variable to hold error codes\n    char *pcVar4; // Pointer for character operations\n    char *pcVar5; // Another pointer for character operations\n    uint uVar6; // Variable for unsigned integer operations\n    uint uVar7; // Variable for unsigned integer operations\n    uint uVar8; // Variable for unsigned integer operations\n    short sVar9; // Variable for short integer operations\n    char local_1c; // Local character variable\n    uint local_18; // Local variable for unsigned integer\n    uint local_c; // Local variable for unsigned integer\n    int local_20; // Local integer variable\n    local_18 = 0x3ff; // Initialize local_18 to 1023\n    local_20 = 0; // Initialize local_20 to 0\n\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)0, param_6); // Update locale information\n    if ((int)param_4 < 0) { // Check if param_4 is negative\n        param_4 = 0; // Set param_4 to 0 if negative\n    }\n    if ((param_2 == (undefined *)0x0) || (param_3 == 0)) { // Check for null pointer or zero size\n        piVar2 = __errno(); // Get the address of errno\n        *piVar2 = 0x16; // Set errno to 22 (invalid argument)\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        return 0; // Return 0 on error\n    }\n    *param_2 = 0; // Initialize output buffer\n    if (param_3 <= param_4 + 0xb) { // Check if buffer size is insufficient\n        piVar2 = __errno(); // Get the address of errno\n        *piVar2 = 0x22; // Set errno to 34 (buffer too small)\n        return 0; // Return 0 on error\n    }\n    if ((*(uint *)((int)param_1 + 4) >> 0x14 & 0x7ff) == 0x7ff) { // Check for special case (infinity or NaN)\n        _SizeInBytes = (param_3 == 0xffffffff) ? 0xffffffff : param_3 - 2; // Set size for conversion\n        eVar3 = __cftoe(param_1, param_2 + 2, _SizeInBytes, param_4, 0); // Convert float to string\n        if (eVar3 != 0) { // Check for conversion error\n            *param_2 = 0; // Clear output buffer\n            return 0; // Return 0 on error\n        }\n        if (param_2[2] == '-') { // Check if the number is negative\n            *param_2 = 0x2d; // Set negative sign\n            param_2++; // Move to next character\n        }\n        *param_2 = 0x30; // Set leading zero\n        param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78; // Set exponent character based on param_5\n        pcVar4 = _strrchr(param_2 + 2, 0x65); // Find 'e' in the string\n        if (pcVar4 != (char *)0x0) { // If 'e' is found\n            *pcVar4 = ((param_5 == 0) - 1U & 0xe0) + 0x70; // Set 'E' or 'e' based on param_5\n            pcVar4[3] = '\\0'; // Null-terminate the string\n        }\n        goto LAB_10017ec3; // Jump to end\n    }\n    if ((*(uint *)((int)param_1 + 4) & 0x80000000) != 0) { // Check if the number is negative\n        *param_2 = 0x2d; // Set negative sign\n        param_2++; // Move to next character\n    }\n    *param_2 = 0x30; // Set leading zero\n    param_2[1] = ((param_5 == 0) - 1U & 0xe0) + 0x78; // Set exponent character based on param_5\n    sVar9 = (-(ushort)(param_5 != 0) & 0xffe0) + 0x27; // Calculate adjustment for exponent\n    if ((*(uint *)((int)param_1 + 4) & 0x7ff00000) == 0) { // Check for zero value\n        param_2[2] = 0x30; // Set next character to '0'\n        local_18 = (*(uint *)param_1 | *(uint *)((int)param_1 + 4) & 0xfffff) == 0 ? 0 : 0x3fe; // Set local_18 based on value\n    } else {\n        param_2[2] = 0x31; // Set next character to '1'\n    }\n    char *pcVar11 = param_2 + 3; // Pointer to the next character position\n    if (param_4 == 0) { // Check if there is no space for additional characters\n        *pcVar11 = '\\0'; // Null-terminate the string\n    } else {\n        *pcVar11 = ***(char ***)(0 + 0xbc); // Set character based on locale\n    }\n    if ((*(uint *)((int)param_1 + 4) & 0xfffff) != 0 || *(int *)param_1 != 0) { // Check if there are significant digits\n        uint local_10 = 0; // Local variable for digit processing\n        local_c = 0xf0000; // Local variable for bit manipulation\n        do {\n            if ((int)param_4 < 1) break; // Break if no space left\n            ulonglong uVar13 = __aullshr((byte)0x30, *(uint *)((int)param_1 + 4) & local_c & 0xfffff); // Shift and mask to get digit\n            ushort uVar1 = (short)uVar13 + 0x30; // Convert to character\n            if (0x39 < uVar1) { // Check if character is greater than '9'\n                uVar1 += sVar9; // Adjust character for exponent\n            }\n            *param_2++ = (char)uVar1; // Store character in output\n            local_10 = local_10 >> 4 | local_c << 0x1c; // Update local_10 for next iteration\n            local_c = local_c >> 4; // Shift local_c for next digit\n            param_4--; // Decrease remaining space\n        } while (-1 < (short)0x30); // Continue until no more digits\n        if ((-1 < (short)0x30) && (uVar13 = __aullshr((byte)0x30, *(uint *)((int)param_1 + 4) & local_c & 0xfffff), 8 < (ushort)uVar13)) { // Check for rounding\n            while (true) {\n                pcVar5 = pcVar11 - 1; // Pointer to the last character\n                if ((*pcVar5 != 'f') && (*pcVar5 != 'F')) break; // Break if not 'f' or 'F'\n                *pcVar5 = '0'; // Set to '0'\n                pcVar11 = pcVar5; // Update pointer\n            }\n            if (pcVar5 == pcVar11) { // If no change occurred\n                pcVar11[-2] += '\\x01'; // Increment the second last character\n            } else if (*pcVar5 == '9') { // If last character is '9'\n                *pcVar5 = (char)sVar9 + ':'; // Set to '0'\n            } else {\n                *pcVar5 += '\\x01'; // Increment last character\n            }\n        }\n    }\n    if (0 < (int)param_4) { // If there is space left\n        _memset(param_2, 0x30, param_4); // Fill remaining space with '0'\n        param_2 += param_4; // Move pointer forward\n    }\n    if (*pcVar11 == '\\0') { // If last character is null\n        param_2 = pcVar11; // Set output pointer to last character\n    }\n    *param_2 = ((param_5 == 0) - 1U & 0xe0) + 0x70; // Set final character based on param_5\n    ulonglong uVar13 = __aullshr(0x34, *(uint *)((int)param_1 + 4)); // Shift to get exponent\n    uVar6 = (uint)(uVar13 & 0x7ff); // Mask to get exponent value\n    uVar7 = uVar6 - local_18; // Calculate adjusted exponent\n    uVar6 = (uint)(uVar6 < local_18); // Check if exponent is negative\n    uVar8 = -uVar6; // Set uVar8 based on sign\n    if (uVar6 == 0) { // If exponent is positive\n        param_2[1] = '+'; // Set '+' sign\n    } else {\n        param_2[1] = '-'; // Set '-' sign\n        uVar7 = -uVar7; // Negate exponent\n        uVar8 = -(uVar8 + (uVar7 != 0)); // Adjust uVar8\n    }\n    char *pcVar10 = param_2 + 2; // Pointer to the next character position\n    *pcVar10 = '0'; // Initialize character\n    pcVar11 = pcVar10; // Set pcVar11 to current position\n    if (((int)uVar8 < 0) || (((int)uVar8 < 1 && (uVar7 < 1000)))) { // Check for small exponent\n    LAB_10017e72:\n        if ((-1 < (int)uVar8) && ((0 < (int)uVar8 || (99 < uVar7)))) goto LAB_10017e7d; // Check for further processing\n    } else {\n        ulonglong uVar14 = __alldvrm(uVar7, uVar8, 1000, 0); // Divide for thousands\n        *pcVar10 = (char)uVar14 + '0'; // Set character\n        pcVar11 = param_2 + 3; // Move to next position\n        uVar8 = 0; // Reset uVar8\n        uVar7 = 0; // Reset uVar7\n        if (pcVar11 == pcVar10) goto LAB_10017e72; // Check for further processing\n    LAB_10017e7d:\n        uVar14 = __alldvrm(uVar7, uVar8, 100, 0); // Divide for hundreds\n        *pcVar11 = (char)uVar14 + '0'; // Set character\n        pcVar11++; // Move to next position\n        uVar8 = 0; // Reset uVar8\n        uVar7 = 0; // Reset uVar7\n    }\n    if ((pcVar11 != pcVar10) || ((-1 < (int)uVar8 && ((0 < (int)uVar8 || (9 < uVar7)))))) { // Check for tens\n        uVar14 = __alldvrm(uVar7, uVar8, 10, 0); // Divide for tens\n        *pcVar11 = (char)uVar14 + '0'; // Set character\n        pcVar11++; // Move to next position\n        uVar7 = 0; // Reset uVar7\n    }\n    *pcVar11 = (char)uVar7 + '0'; // Set last character\n    pcVar11[1] = '\\0'; // Null-terminate the string\nLAB_10017ec3:\n    return 0; // Return 0 to indicate success\n}\n"}
{"Function Name": "__cftof_l", "Address": "10017fcc", "Source Code": "\nvoid __cdecl\n__cftof_l(double *param_1, undefined *param_2, int param_3, size_t param_4, localeinfo_struct *param_5)\n{\n    size_t _SizeInBytes; // Variable to hold the size in bytes for the output\n    errno_t eVar2; // Variable to store the error code from function calls\n    _strflt local_30; // Structure to hold floating-point representation\n    char local_20[24]; // Buffer to hold the string representation of the float\n    uint local_8 = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Security cookie for stack protection\n\n    // Convert double to floating-point representation\n    __fltout2((_CRT_DOUBLE)*param_1, &local_30, local_20, 0x16);\n    \n    // Check if output pointer is null or size is zero\n    if (param_2 == (undefined *)0x0 || param_3 == 0) {\n        *__errno() = 0x16; // Set errno to indicate an error\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n    } else {\n        // Calculate size in bytes based on the sign of the number\n        _SizeInBytes = (param_3 == -1) ? 0xffffffff : param_3 - (uint)(local_30.sign == 0x2d);\n        \n        // Convert floating-point representation to string\n        eVar2 = __fptostr(param_2 + (local_30.sign == 0x2d), _SizeInBytes, local_30.decpt + param_4, &local_30);\n        \n        // Check if conversion was successful\n        if (eVar2 == 0) {\n            __cftof2_l(param_2, param_3, param_4, '\\0', param_5); // Call function to finalize conversion\n        } else {\n            *param_2 = 0; // Set output to zero if conversion failed\n        }\n    }\n    \n    // Security check to ensure stack integrity\n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n    return; // Exit the function\n}\n"}
{"Function Name": "__cftog_l", "Address": "10018085", "Source Code": "\nvoid __cdecl\n__cftog_l(double *param_1, undefined *param_2, uint param_3, size_t param_4, int param_5,\nlocaleinfo_struct *param_6)\n{\n    errno_t eVar3; // Variable to store error codes\n    size_t _SizeInBytes; // Variable to hold the size in bytes for output\n    _strflt local_34; // Local structure to hold floating-point representation\n    int local_24; // Local variable to hold adjusted decimal point position\n\n    local_8 = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Security cookie for stack protection\n    __fltout2((_CRT_DOUBLE)*param_1, &local_34, local_20, 0x16); // Convert double to floating-point representation\n    \n    // Check for invalid parameters\n    if (param_2 == (undefined *)0x0 || param_3 == 0) {\n        *__errno() = 0x16; // Set errno to indicate an error\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n    } else {\n        local_24 = local_34.decpt - 1; // Adjust decimal point position\n        // Determine the size in bytes for output\n        _SizeInBytes = (param_3 == 0xffffffff) ? 0xffffffff : param_3 - (local_34.sign == 0x2d);\n        \n        // Convert floating-point to string representation\n        eVar3 = __fptostr(param_2 + (local_34.sign == 0x2d), _SizeInBytes, param_4, &local_34);\n        if (eVar3 == 0) { // Check if conversion was successful\n            local_34.decpt--; // Adjust decimal point after conversion\n            // Check if decimal point is out of bounds\n            if (local_34.decpt < -4 || (int)param_4 <= local_34.decpt) {\n                __cftoe2_l(param_3, param_4, param_5, &local_34.sign, '\\x01', param_6); // Handle out-of-bounds case\n            } else {\n                char *pcVar1 = param_2 + (local_34.sign == 0x2d); // Pointer to output buffer\n                // Adjust output buffer if necessary\n                if (local_24 < local_34.decpt) {\n                    while (*pcVar1 != '\\0') { // Find end of string\n                        pcVar1++;\n                    }\n                    pcVar1[-1] = '\\0'; // Null-terminate the string\n                }\n                __cftof2_l(param_2, param_3, param_4, '\\x01', param_6); // Finalize conversion to string\n            }\n        }\n    }\n    *param_2 = 0; // Null-terminate output buffer\n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); // Check security cookie\n    return; // Exit function\n}\n"}
{"Function Name": "__cfltcvt_l", "Address": "1001817d", "Source Code": "\nerrno_t __cdecl\n__cfltcvt_l(double *arg, char *buffer, size_t sizeInBytes, int format, int precision, int caps, _locale_t plocinfo)\n{\n    // Check if the format is for scientific (0x65) or exponential (0x45) notation\n    if ((format == 0x65) || (format == 0x45)) {\n        // Convert the double to string in scientific/exponential format\n        format = __cftoe_l(arg, buffer, sizeInBytes, precision, caps, plocinfo);\n    } \n    // Check if the format is for fixed-point (0x66) notation\n    else if (format == 0x66) {\n        // Convert the double to string in fixed-point format\n        return __cftof_l(arg, buffer, sizeInBytes, precision, plocinfo);\n    } \n    // Check if the format is for ASCII (0x61) or uppercase ASCII (0x41) notation\n    else if ((format == 0x61) || (format == 0x41)) {\n        // Convert the double to string in ASCII format\n        __cftoa_l(arg, buffer, sizeInBytes, precision, caps, plocinfo);\n    } \n    // Default case for general format\n    else {\n        // Convert the double to string in general format\n        format = __cftog_l(arg, buffer, sizeInBytes, precision, caps, plocinfo);\n    }\n    // Return the format used for conversion\n    return format;\n}\n"}
{"Function Name": "__initp_misc_cfltcvt_tab", "Address": "10018224", "Source Code": "\nvoid __initp_misc_cfltcvt_tab(void) // Function to initialize the conversion table\n{\n    int *intPointer; // Pointer to an integer\n    uint offset = 0; // Initialize a variable to track the offset\n    do {\n        intPointer = (int *)((int)&PTR_LAB_10034a18 + offset); // Calculate the address of the current table entry\n        *intPointer = __encode_pointer(*intPointer); // Encode the pointer and store it in the table entry\n        offset += 4; // Increment the offset by the size of an integer (4 bytes)\n    } while (offset < 0x28); // Continue until the offset reaches 40 bytes (0x28 in hexadecimal)\n}\n"}
{"Function Name": "__ms_p5_test_fdiv", "Address": "1001826c", "Source Code": "\nundefined4 calculate_fdiv_result(void)\n{\n    // Calculate the result of the expression (_DAT_1002e340 - (_DAT_1002e340 / _DAT_1002e348) * _DAT_1002e348)\n    // and check if it is greater than 1.0 and not NaN.\n    return (1.0 < (value_a - (value_a / value_b) * value_b) != NAN(value_a - (value_a / value_b) * value_b)) ? \n        // If the condition is true, return 1\n        1 : \n        // If the condition is false, return 0\n        0;\n}\n"}
{"Function Name": "FUN_10018580", "Address": "10018580", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10018580\n{\n    callAnotherFunction(7); // Call the function FUN_10016973 with the argument 7\n}\n"}
{"Function Name": "_cvtdate", "Address": "10018610", "Source Code": "\nint __thiscall\n_cvtdate(void *this,int param_1,int param_2,uint param_3,int param_4,int param_5,int param_6,\nint param_7,int param_8,int param_9)\n{\n    uint uVar1; // Variable to hold intermediate calculation results\n    int iVar2;  // Variable to store final result\n    int iVar4;  // Variable to hold year-related calculations\n    int iVar5;  // Variable for day calculations\n    int iVar6;  // Variable for month calculations\n    int local_8 = 0; // Local variable to store timezone bias\n\n    // Check if param_2 indicates a specific condition (e.g., a certain date format)\n    if (param_2 == 1) {\n        uVar1 = param_3 & 0x80000003; // Extract specific bits from param_3\n        if ((int)uVar1 < 0) {\n            uVar1 = (uVar1 - 1 | 0xfffffffc) + 1; // Adjust uVar1 if negative\n        }\n        // Determine if the year is a leap year or not\n        if (((uVar1 == 0) && ((int)param_3 % 100 != 0)) || ((int)(param_3 + 0x76c) % 400 == 0)) {\n            iVar4 = (&DAT_1003568c)[0]; // Get leap year data\n        } else {\n            iVar4 = *(int *)(&DAT_100356c0); // Get non-leap year data\n        }\n        iVar6 = iVar4 + 1; // Increment month calculation\n        // Calculate the day of the week based on the year and month\n        iVar5 = (int)(param_3 * 0x16d - 0x63db + ((int)((param_3 - 1) + ((int)(param_3 - 1) >> 0x1f & 3U)) >> 2) + iVar6 + ((int)(param_3 + 299) / 400 - (int)(param_3 - 1) / 100)) % 7);\n        iVar2 = (param_4 * 7 - iVar5) + param_5; // Calculate final day value\n        if (iVar5 <= param_5) {\n            iVar6 = iVar4 - 6; // Adjust month if day exceeds\n        }\n        iVar6 += iVar2; // Update month with final day value\n        // Check if the month is June (5)\n        if (param_4 == 5) {\n            // Determine if June is in a leap year\n            if (((uVar1 == 0) && ((int)param_3 % 100 != 0)) || ((int)(param_3 + 0x76c) % 400 == 0)) {\n                iVar2 = *(int *)(&DAT_10035690); // Get leap year data for June\n            } else {\n                iVar2 = (&DAT_100356c4)[0]; // Get non-leap year data for June\n            }\n            // Adjust month if the calculated day exceeds the limit for June\n            if (iVar2 < iVar6) {\n                iVar6 -= 7; // Decrement month if necessary\n            }\n        }\n    } else {\n        // Handle the case when param_2 is not equal to 1\n        uVar1 = param_3 & 0x80000003; // Extract specific bits from param_3\n        if ((int)uVar1 < 0) {\n            uVar1 = (uVar1 - 1 | 0xfffffffc) + 1; // Adjust uVar1 if negative\n        }\n        // Determine if the year is a leap year or not\n        if (((uVar1 == 0) && ((int)param_3 % 100 != 0)) || ((int)(param_3 + 0x76c) % 400 == 0)) {\n            iVar6 = (&DAT_1003568c)[0]; // Get leap year data\n        } else {\n            iVar6 = *(int *)(&DAT_100356c0); // Get non-leap year data\n        }\n        iVar6 += param_6; // Add additional parameter to month calculation\n    }\n\n    // Calculate final timestamp based on input parameters\n    iVar4 = (((int)this * 0x3c + param_7) * 0x3c + param_8) * 1000 + param_9;\n    // Check if param_1 indicates a specific condition (e.g., a certain operation)\n    if (param_1 == 1) {\n        DAT_10034a40 = param_3; // Store year information\n        DAT_10034a44 = iVar6;   // Store month information\n        DAT_10034a48 = iVar4;   // Store timestamp information\n    } else {\n        DAT_10034a50 = iVar6;   // Store month information\n        DAT_10034a54 = iVar4;   // Store timestamp information\n        errno_t eVar3 = __get_dstbias(&local_8); // Get timezone bias\n        if (eVar3 != 0) {\n            __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0); // Handle error if bias retrieval fails\n        }\n        iVar2 = local_8 * 1000; // Convert timezone bias to milliseconds\n        DAT_10034a54 += iVar2; // Adjust timestamp with timezone bias\n        // Adjust for overflow or underflow in timestamp\n        if (DAT_10034a54 < 0) {\n            DAT_10034a54 += 86400000; // Wrap around if negative\n            DAT_10034a50--; // Decrement day\n        } else if (DAT_10034a54 > 86399999) {\n            DAT_10034a54 -= 86400000; // Wrap around if exceeds max\n            DAT_10034a50++; // Increment day\n        }\n        DAT_10034a4c = param_3; // Store year information\n    }\n    return iVar2; // Return final result\n}\n"}
{"Function Name": "___tzset", "Address": "100189b3", "Source Code": "\nvoid __cdecl ___tzset(void)\n{\n    // Check if the timezone data has not been initialized\n    if (timezone_initialized == 0) {\n        // Acquire a lock to ensure thread safety\n        acquire_lock(6);\n        // Check again if the timezone data is still not initialized\n        if (timezone_initialized == 0) {\n            // Initialize the timezone data without locking\n            initialize_timezone_data();\n            // Increment the initialization counter\n            timezone_initialized++;\n        }\n        // Call another function, possibly for further processing\n        process_timezone_data();\n    }\n}\n"}
{"Function Name": "FUN_100189f9", "Address": "100189f9", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_100189f9\n{\n    callAnotherFunction(6); // Call the function FUN_10016973 with an argument of 6\n}\n"}
{"Function Name": "__isindst", "Address": "10018a02", "Source Code": "\nint __cdecl checkDST(tm *timeStruct) // Function to check if the given time is in daylight saving time\n{\n    acquireLock(6); // Acquire a lock to ensure thread safety\n    return checkDSTWithoutLock(); // Call the function that checks DST without locking\n}\n"}
{"Function Name": "FUN_10018a3a", "Address": "10018a3a", "Source Code": "\nvoid executeFunctionA(void) // Function declaration for FUN_10018a3a\n{\n    callFunctionB(6); // Call the function FUN_10016973 with the argument 6\n}\n"}
{"Function Name": "__gmtime64_s", "Address": "10018a43", "Source Code": "\nerrno_t __cdecl __gmtime64_s(tm *timeStruct, __time64_t *timePtr)\n{\n    // Check if the provided tm structure or time pointer is null\n    if ((timeStruct == (tm *)0x0) || (_memset(timeStruct, 0xff, 0x24), timePtr == (__time64_t *)0x0)) {\n        // Set errno to an error code and handle invalid parameter\n        *__errno() = 0x16;\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        return 0x16; // Return error code\n    }\n\n    // Extract the second part of the time value\n    uint secondsPart = *(uint *)((int)timePtr + 4);\n    longlong timeValue = *timePtr;\n\n    // Validate the time value\n    if (((int)secondsPart < 1) || ((6 < (int)secondsPart) && ((7 < (int)secondsPart || (0x93406fff < *(uint *)timePtr))))) {\n        // Set errno to an error code and return\n        *__errno() = 0x16;\n        return 0x16; // Return error code\n    }\n\n    // Calculate the year based on the time value\n    longlong yearCalculation = __alldiv(*(uint *)timePtr, secondsPart, 0x1e13380, 0);\n    uint yearValue = (uint)yearCalculation + 0x46;\n    yearCalculation = __allmul(yearValue, (int)yearValue >> 0x1f, 0xfffffe93, 0xffffffff);\n    yearCalculation -= (((int)(yearValue + 0x171) / 400 - (int)(yearValue + 0x45) / 100) + -0x11 + ((int)((int)&timeStruct->tm_sec + ((int)(yearValue + 0x45) >> 0x1f & 3U)) >> 2));\n    yearCalculation = __allmul((uint)yearCalculation, (uint)((ulonglong)yearCalculation >> 0x20), 0x15180, 0);\n    yearCalculation += timeValue;\n\n    // Adjust the year based on leap year rules\n    if ((yearCalculation < 0x100000000) && (yearCalculation < 0)) {\n        yearCalculation += 0x1e13380;\n        yearValue = (uint)(yearValue + 0x45) & 0x80000003;\n        if ((yearValue != 0) && ((int)(yearValue + 0x45) % 100 != 0) && ((int)(secondsPart + 0x7b1) % 400 != 0)) {\n            goto LAB_10018bc0; // Jump to label for further processing\n        }\n        yearCalculation = CONCAT44((int)((ulonglong)yearCalculation >> 0x20) + (uint)(0xfffeae7f < (uint)yearCalculation), (int)yearCalculation + 0x1e28500);\n    } else {\n        yearValue = (uint)timeStruct & 0x80000003;\n        if ((yearValue != 0) && ((int)(timeStruct) % 100 != 0) && ((int)(secondsPart + 0x7b2) % 400 != 0)) {\n            goto LAB_10018bc0; // Jump to label for further processing\n        }\n    }\n\nLAB_10018bc0:\n    // Calculate the day of the year and month\n    uint dayOfYear = (uint)((ulonglong)yearCalculation >> 0x20);\n    timeStruct->tm_year = (int)yearValue; // Set year in tm structure\n    secondsPart = (uint)__alldiv((uint)yearCalculation, dayOfYear, 0x15180, 0);\n    timeStruct->tm_yday = secondsPart; // Set day of the year\n    timeValue = __allmul(secondsPart, (int)secondsPart >> 0x1f, 0xfffeae80, 0xffffffff);\n    timeValue += yearCalculation;\n\n    // Determine the month and day from the day of the year\n    undefined4 *monthLengths = (undefined4 *)&DAT_10035690; // Pointer to month lengths\n    int monthIndex = 1;\n    int currentMonthLength = monthLengths[1];\n\n    // Loop to find the month based on the day of the year\n    while (currentMonthLength < timeStruct->tm_yday) {\n        monthIndex++;\n        currentMonthLength = monthLengths[monthIndex];\n    }\n\n    timeStruct->tm_mon = monthIndex - 1; // Set month in tm structure\n    timeStruct->tm_mday = timeStruct->tm_yday - monthLengths[monthIndex - 1]; // Set day of the month\n    timeStruct->tm_wday = ((int)__alldiv(*(uint *)timePtr, *(uint *)((int)timePtr + 4), 0x15180, 0) + 4) % 7; // Set day of the week\n    secondsPart = (uint)__alldiv((uint)timeValue, (uint)((ulonglong)timeValue >> 0x20), 0xe10, 0);\n    timeStruct->tm_hour = secondsPart; // Set hour in tm structure\n    timeStruct->tm_min = (int)__alldiv((uint)(timeValue + __allmul(secondsPart, (int)secondsPart >> 0x1f, 0xfffff1f0, 0xffffffff)), (uint)((ulonglong)(timeValue + __allmul(secondsPart, (int)secondsPart >> 0x1f, 0xfffff1f0, 0xffffffff)) >> 0x20), 0x3c, 0);\n    timeStruct->tm_isdst = 0; // Set daylight saving time flag\n    timeStruct->tm_sec = (uint)(timeValue + __allmul(secondsPart, (int)secondsPart >> 0x1f, 0xfffff1f0, 0xffffffff)) + (int)__alldiv((uint)(timeValue + __allmul(secondsPart, (int)secondsPart >> 0x1f, 0xfffff1f0, 0xffffffff)), (uint)((ulonglong)(timeValue + __allmul(secondsPart, (int)secondsPart >> 0x1f, 0xfffff1f0, 0xffffffff)) >> 0x20), 0x3c, 0);\n    \n    return 0; // Return success\n}\n"}
{"Function Name": "FUN_10018d1b", "Address": "10018d1b", "Source Code": "\nundefined4 * getUndefined4Pointer(void) // Function declaration returning a pointer to undefined4\n{\n    return &globalUndefined4; // Return the address of the global variable DAT_10034a5c\n}\n"}
{"Function Name": "FUN_10018d21", "Address": "10018d21", "Source Code": "\nundefined4 * getUndefinedPointer(void) // Function declaration returning a pointer to undefined4\n{\n    return &globalUndefinedVar; // Return the address of the global variable DAT_10034a60\n}\n"}
{"Function Name": "FUN_10018d27", "Address": "10018d27", "Source Code": "\nundefined4 * getUndefinedPointer(void) // Function declaration returning a pointer to undefined4\n{\n    return &globalVariable; // Return the address of the global variable DAT_10034a58\n}\n"}
{"Function Name": "FUN_10018d2d", "Address": "10018d2d", "Source Code": "\n// Function declaration: FUN_10018d2d returns a pointer to an undefined type (double pointer)\nundefined ** getPointerToUndefinedType(void)\n{\n    // Return the value of the global pointer PTR_DAT_10034ae8\n    return globalPointer;\n}\n"}
{"Function Name": "FUN_10018eea", "Address": "10018eea", "Source Code": "\nvoid FUN_10018eea(void) // Function definition for FUN_10018eea\n{\n    data_value = 0; // Set the value of _DAT_100377d8 to 0\n}\n"}
{"Function Name": "_write_string", "Address": "10019103", "Source Code": "\nvoid __cdecl _write_string(int char_count)\n{\n    FILE *file_pointer; // Declare a file pointer variable\n\n    // Check if the file is not in a specific state or if the buffer is not null\n    if (((*(byte *)&file_pointer->_flag & 0x40) == 0) || (file_pointer->_base != (char *)0x0)) {\n        // Loop until param_1 is decremented to zero\n        while (char_count > 0) {\n            char_count--; // Decrement the count of characters to write\n            _write_char(file_pointer); // Write a character to the file\n\n            // Check if the last write operation failed\n            if (*error_indicator == -1) {\n                // If the error is not a specific error code (0x2a), exit the function\n                if (*__errno() != 0x2a) {\n                    return;\n                }\n                _write_char(file_pointer); // Attempt to write the character again\n            }\n        }\n    } else {\n        // If the file is in a specific state, increment the error count\n        *error_indicator += char_count;\n    }\n}\n"}
{"Function Name": "__output_l", "Address": "1001914d", "Source Code": "\nint __cdecl __output_l(FILE *filePointer, char *formatString, _locale_t locale, va_list argList)\n{\n    byte byteValue; // Variable to hold a byte value\n    wchar_t wideChar; // Variable to hold a wide character\n    FILE *filePointerVar; // Pointer to a FILE structure\n    int *intPointer; // Pointer to an integer\n    uint unsignedIntVar; // Unsigned integer variable\n    undefined *undefinedPointer; // Pointer to undefined type\n    code *codePointer; // Pointer to a code type\n    int *intPointer2; // Pointer to an integer\n    errno_t errorVar; // Error variable for error handling\n    int integerVar; // Integer variable for various purposes\n    byte *bytePointer; // Pointer to a byte\n    char *charPointer; // Pointer to a character\n    bool booleanVar; // Boolean variable\n    undefined8 undefined8Var; // 8-byte undefined variable\n    int **intPointerPointer; // Pointer to a pointer to an integer\n    int *intPointer3; // Pointer to an integer\n    int *intPointer4; // Pointer to an integer\n    undefined4 undefined4Var; // 4-byte undefined variable\n    localeinfo_struct *localeInfoPointer; // Pointer to locale information structure\n    int *localIntPointer1; // Local pointer to an integer\n    int *localIntPointer2; // Local pointer to an integer\n    int localFlagVar2; // Local integer variable\n    int localInteger2; // Local integer variable\n    int localIntArray[5]; // Array of 5 integers\n    undefined localUndefinedArray[491]; // Array of undefined type\n    uint localUnsignedIntVar; // Local unsigned integer variable\n\n    // Initialize local variables\n    localUnsignedIntVar = DAT_100345e0 ^ (uint)localUndefinedArray; // XOR operation for security\n    localIntPointer2 = (int *)0x0; // Initialize local pointer to null\n    localFlagVar2 = 0; // Initialize local integer\n    localInteger2 = 0; // Initialize local integer\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localUpdate, locale); // Update locale\n\n    // Check if the file pointer is not null\n    if (filePointer != (FILE *)0x0) {\n        // Check if the file is not in a specific mode\n        if ((*(byte *)&filePointer->_flag & 0x40) == 0) {\n            integerVar = __fileno(filePointer); // Get the file number\n            // Check for invalid file number\n            if ((integerVar == -1) || (integerVar == -2)) {\n                undefinedPointer = &DAT_10034eb8; // Set pointer to error data\n            } else {\n                unsignedIntVar = __fileno(filePointer); // Get the file number again\n                undefinedPointer = (undefined *)((unsignedIntVar & 0x1f) * 0x28 + (&DAT_100366a0)[integerVar >> 5]); // Calculate pointer\n            }\n            // Check if a specific flag is set\n            if ((undefinedPointer[0x24] & 0x7f) == 0) {\n                integerVar = __fileno(filePointer); // Get the file number\n                // Check for invalid file number\n                if ((integerVar == -1) || (integerVar == -2)) {\n                    undefinedPointer = &DAT_10034eb8; // Set pointer to error data\n                } else {\n                    unsignedIntVar = __fileno(filePointer); // Get the file number again\n                    undefinedPointer = (undefined *)((unsignedIntVar & 0x1f) * 0x28 + (&DAT_100366a0)[integerVar >> 5]); // Calculate pointer\n                }\n                // Check if another specific flag is set\n                if ((undefinedPointer[0x24] & 0x80) == 0) goto LAB_1001928b; // Go to label if condition is met\n            }\n        } else {\n        LAB_1001928b:\n            // Check if the format string is not null\n            if (formatString != (char *)0x0) {\n                localCharValue = *formatString; // Get the first character of the format\n                localVariable1 = 0; // Initialize local variable\n                intPointer2 = (int *)0x0; // Initialize pointer to null\n                integerVar = 0; // Initialize index variable\n                // Loop through the format string\n                while ((localCharValue != 0 && (bytePointer = (byte *)formatString + 1, localPointer = bytePointer, -1 < localVariable1))) {\n                    // Check if the character is a valid month abbreviation\n                    if ((byte)(localCharValue - 0x20) < 0x59) {\n                        unsignedIntVar = (byte)\"JanFebMarAprMayJunJulAugSepOctNovDec\"[(char)localCharValue + 0x24] & 0xf; // Get month index\n                    } else {\n                        unsignedIntVar = 0; // Set to zero if not valid\n                    }\n                    localVariable6 = (int)(char)(&DAT_1002e3d8)[unsignedIntVar * 8 + integerVar] >> 4; // Get local variable based on month index\n                    switch (localVariable6) {\n                    case 0:\n                        localFlagVar2 = 0; // Reset local variable\n                        integerVar = __isleadbyte_l((uint)localCharValue, &localUpdate); // Check for lead byte\n                        if (integerVar != 0) {\n                            _write_char(filePointer); // Write character to file\n                            localPointer = (byte *)formatString + 2; // Update format pointer\n                            // Check if the next character is null\n                            if (*bytePointer == 0) {\n                                intPointer = __errno(); // Get error number pointer\n                                *intPointer = 0x16; // Set error number\n                                goto LAB_100191bd; // Go to error handling\n                            }\n                        }\n                        _write_char(filePointer); // Write character to file\n                        break;\n                    case 1:\n                        localIntPointer1000 = (int *)0xffffffff; // Set local variable to max value\n                        localVariable3 = 0; // Reset local variable\n                        localFlagVar = 0; // Reset local variable\n                        localInteger2 = 0; // Reset local variable\n                        localFlagVar2 = 0; // Reset local variable\n                        break;\n                    case 2:\n                        // Update flags based on specific characters\n                        if (localCharValue == 0x20) {\n                            localInteger2 |= 2; // Set flag for space\n                        } else if (localCharValue == 0x23) {\n                            localInteger2 |= 0x80; // Set flag for hash\n                        } else if (localCharValue == 0x2b) {\n                            localInteger2 |= 1; // Set flag for plus\n                        } else if (localCharValue == 0x2d) {\n                            localInteger2 |= 4; // Set flag for minus\n                        } else if (localCharValue == 0x30) {\n                            localInteger2 |= 8; // Set flag for zero\n                        }\n                        break;\n                    case 3:\n                        // Handle specific character for argument list\n                        if (localCharValue == 0x2a) {\n                            local_228 = (int **)((int)argList + 4); // Update argument list pointer\n                            local_23c = *(int **)argList; // Get first argument\n                            if ((int)local_23c < 0) {\n                                localInteger2 |= 4; // Set flag for negative\n                                local_23c = (int *)-(int)local_23c; // Make positive\n                            }\n                        } else {\n                            local_23c = (int *)((int)local_23c * 10 + -0x30 + (int)(char)localCharValue); // Update argument value\n                        }\n                        break;\n                    case 4:\n                        localIntPointer1000 = (int *)0x0; // Reset local variable\n                        break;\n                    case 5:\n                        // Handle specific character for argument list\n                        if (localCharValue == 0x2a) {\n                            local_228 = (int **)((int)argList + 4); // Update argument list pointer\n                            localIntPointer1000 = *(int **)argList; // Get first argument\n                            if ((int)localIntPointer1000 < 0) {\n                                localIntPointer1000 = (int *)0xffffffff; // Set to max value\n                            }\n                        } else {\n                            localIntPointer1000 = (int *)((int)localIntPointer1000 * 10 + -0x30 + (int)(char)localCharValue); // Update argument value\n                        }\n                        break;\n                    case 6:\n                        // Handle specific characters for formatting\n                        if (localCharValue == 0x49) {\n                            byteValue = *bytePointer; // Get next character\n                            // Check for specific formatting patterns\n                            if ((byteValue == 0x36) && (((byte *)formatString)[2] == 0x34)) {\n                                localInteger2 |= 0x8000; // Set flag for specific pattern\n                                localPointer = (byte *)formatString + 3; // Update format pointer\n                            } else if ((byteValue == 0x33) && (((byte *)formatString)[2] == 0x32)) {\n                                localInteger2 &= 0xffff7fff; // Clear specific flag\n                                localPointer = (byte *)formatString + 3; // Update format pointer\n                            } else if (((((byteValue != 100) && (byteValue != 0x69)) && (byteValue != 0x6f)) &&\n                                        ((byteValue != 0x75 && (byteValue != 0x78)))) && (byteValue != 0x58)) {\n                                localVariable6 = 0; // Reset local variable\n                                goto switchD_100192ef_caseD_0; // Go to default case\n                            }\n                        } else if (localCharValue == 0x68) {\n                            localInteger2 |= 0x20; // Set flag for 'h'\n                        } else if (localCharValue == 0x6c) {\n                            // Check for specific character patterns\n                            if (*bytePointer == 0x6c) {\n                                localInteger2 |= 0x1000; // Set flag for double 'l'\n                                localPointer = (byte *)formatString + 2; // Update format pointer\n                            } else {\n                                localInteger2 |= 0x10; // Set flag for single 'l'\n                            }\n                        } else if (localCharValue == 0x77) {\n                            localInteger2 |= 0x800; // Set flag for 'w'\n                        }\n                        break;\n                    case 7:\n                        // Handle specific characters for formatting\n                        if ((char)localCharValue < 'e') {\n                            if (localCharValue == 100) {\n                                localInteger2 |= 0x40; // Set flag for 'd'\n                                goto LAB_100196d2; // Go to specific label\n                            }\n                            if (localInteger2 & 0x9000) {\n                                intPointer2 = (int *)0x0; // Reset pointer\n                            }\n                            if ((int)localIntPointer1000 < 0) {\n                                localIntPointer1000 = (int *)0x1; // Set to minimum value\n                            } else {\n                                localInteger2 &= 0xfffffff7; // Clear specific flag\n                                if (0x200 < (int)localIntPointer1000) {\n                                    localIntPointer1000 = (int *)0x200; // Cap value\n                                }\n                            }\n                            if (((uint)intPointer | (uint)intPointer2) == 0) {\n                                localFlagVar = 0; // Reset local variable\n                            }\n                            intPointer = (int *)local_11; // Set pointer to local variable\n                            while (true) {\n                                intPointer3 = intPointer2; // Store current pointer\n                                intPointer2 = (int *)((int)localIntPointer1000 + -1); // Decrement local value\n                                if (((int)localIntPointer1000 < 1) && (((uint)undefined8Var | (uint)intPointer3) == 0)) break; // Exit loop if conditions met\n                                localIntPointer1000 = intPointer2; // Update local value\n                                undefined8Var = __aulldvrm((uint)undefined8Var, (uint)intPointer3, (uint)localVariable5,\n                                                    (int)localVariable5 >> 0x1f); // Perform division\n                                integerVar = extraout_ECX + 0x30; // Update index\n                                if (0x39 < integerVar) {\n                                    integerVar = integerVar + local_248; // Adjust index\n                                }\n                                *(char *)intPointer = (char)integerVar; // Store character\n                                intPointer = (int *)((int)intPointer + -1); // Decrement pointer\n                                intPointer2 = (int *)((ulonglong)undefined8Var >> 0x20); // Update pointer\n                                localPointer5 = intPointer3; // Store current pointer\n                            }\n                            localVariable5 = (int *)(local_11 + -(int)intPointer); // Calculate length\n                            localPointer2 = (int *)((int)intPointer + 1); // Update pointer\n                            localIntPointer1000 = intPointer2; // Update local value\n                            if (((localInteger2 & 0x200) != 0) &&\n                                ((localVariable5 == (int *)0x0 || (*(char *)localPointer2 != '0')))) {\n                                *(char *)intPointer = '0'; // Prepend zero if necessary\n                                localVariable5 = (int *)(local_11 + -(int)intPointer + 1); // Update length\n                                localPointer2 = intPointer; // Update pointer\n                            }\n                        } else if ((char)localCharValue < 'T') {\n                            // Handle specific characters for formatting\n                            if (localCharValue == 0x53) {\n                                if ((localInteger2 & 0x830) == 0) {\n                                    localInteger2 |= 0x800; // Set flag for 'S'\n                                }\n                                goto LAB_10019557; // Go to specific label\n                            }\n                            if (localCharValue == 0x41) {\n                                localCharValue = localCharValue + 0x20; // Convert to lowercase\n                                localVariable3 = 1; // Set flag\n                                localInteger2 |= 0x40; // Set flag for 'A'\n                                localPointer5 = (int *)0x200; // Set length\n                                intPointer2 = localIntArray; // Set pointer to local array\n                                intPointer = localPointer5; // Set pointer to length\n                                intPointer3 = localIntArray; // Set pointer to local array\n                                if ((int)localIntPointer1000 < 0) {\n                                    localIntPointer1000 = (int *)0x6; // Set to minimum value\n                                } else if (localIntPointer1000 == (int *)0x0) {\n                                    if (localCharValue == 0x67) {\n                                        localIntPointer1000 = (int *)0x1; // Set to minimum value for 'g'\n                                    }\n                                } else {\n                                    if (0x200 < (int)localIntPointer1000) {\n                                        localIntPointer1000 = (int *)0x200; // Cap value\n                                    }\n                                    if (0xa3 < (int)localIntPointer1000) {\n                                        intPointer = (int *)((int)localIntPointer1000 + 0x15d); // Adjust pointer\n                                        localPointer2 = localIntArray; // Set pointer to local array\n                                        localIntPointer2 = (int *)__malloc_crt((size_t)intPointer); // Allocate memory\n                                        intPointer2 = localIntPointer2; // Set pointer to allocated memory\n                                        intPointer3 = localIntPointer2; // Set pointer to allocated memory\n                                        if (localIntPointer2 == (int *)0x0) {\n                                            localIntPointer1000 = (int *)0xa3; // Set to max value if allocation fails\n                                            intPointer2 = localIntArray; // Reset pointer\n                                            intPointer = localPointer5; // Reset pointer\n                                            intPointer3 = localPointer2; // Reset pointer\n                                        }\n                                    }\n                                }\n                                localPointer2 = intPointer3; // Update pointer\n                                localPointer5 = intPointer; // Update pointer\n                                localIntPointer1 = *(int **)argList; // Get argument list\n                                local_228 = (int **)((int)argList + 8); // Update argument list pointer\n                                localPointer4 = *(int **)((int)argList + 4); // Get second argument\n                                localeInfoPointer = &localUpdate; // Set pointer to locale info\n                                integerVar = (int)(char)localCharValue; // Get character value\n                                intPointerPointer = &localIntPointer1; // Set pointer to argument list\n                                intPointer = intPointer2; // Set pointer to allocated memory\n                                intPointer3 = localPointer5; // Set pointer to length\n                                intPointer4 = localIntPointer1000; // Set pointer to local value\n                                undefined4Var = localVariable3; // Store flag\n                                codePointer = (code *)__decode_pointer((int)PTR_LAB_10034a30); // Decode pointer\n                                (*codePointer)(intPointerPointer, intPointer, intPointer3, integerVar, intPointer4, undefined4Var, localeInfoPointer); // Call function\n                                unsignedIntVar = localInteger2 & 0x80; // Check specific flag\n                                // Handle specific conditions\n                                if ((unsignedIntVar != 0) && (localIntPointer1000 == (int *)0x0)) {\n                                    localeInfoPointer = &localUpdate; // Set pointer to locale info\n                                    intPointer = intPointer2; // Set pointer to allocated memory\n                                    codePointer = (code *)__decode_pointer((int)PTR_LAB_10034a3c); // Decode pointer\n                                    (*codePointer)(intPointer, localeInfoPointer); // Call function\n                                }\n                                if ((localCharValue == 0x67) && (unsignedIntVar == 0)) {\n                                    localeInfoPointer = &localUpdate; // Set pointer to locale info\n                                    intPointer = intPointer2; // Set pointer to allocated memory\n                                    codePointer = (code *)__decode_pointer((int)PTR_LAB_10034a38); // Decode pointer\n                                    (*codePointer)(intPointer, localeInfoPointer); // Call function\n                                }\n                                if (*(char *)intPointer2 == '-') {\n                                    localInteger2 |= 0x100; // Set flag for negative\n                                    localPointer2 = (int *)((int)intPointer2 + 1); // Update pointer\n                                    intPointer2 = localPointer2; // Update pointer\n                                }\n                            LAB_10019644:\n                                localVariable5 = (int *)_strlen((char *)intPointer2); // Get string length\n                            } else if (localCharValue == 0x43) {\n                                if ((localInteger2 & 0x830) == 0) {\n                                    localInteger2 |= 0x800; // Set flag for 'C'\n                                }\n                            LAB_100195b4:\n                                local_228 = (int **)((int)argList + 4); // Update argument list pointer\n                                // Check for specific flags\n                                if ((localInteger2 & 0x810) == 0) {\n                                    localIntArray[0]._0_1_ = *argList; // Get first argument\n                                    localVariable5 = (int *)0x1; // Set length to 1\n                                } else {\n                                    errorVar = _wctomb_s((int *)&localVariable5, (char *)localIntArray, 0x200, *(wchar_t *)argList); // Convert wide char to multibyte\n                                    if (errorVar != 0) {\n                                        local_24c = 1; // Set error flag\n                                    }\n                                }\n                                localPointer2 = localIntArray; // Update pointer to local array\n                            } else if ((localCharValue == 0x45) || (localCharValue == 0x47)) {\n                                goto LAB_10019503; // Go to specific label\n                            }\n                        } else {\n                            // Handle specific characters for formatting\n                            if (localCharValue == 0x58) goto LAB_100197d9; // Go to specific label\n                            if (localCharValue == 0x5a) {\n                                intPointer = *(int **)argList; // Get first argument\n                                local_228 = (int **)((int)argList + 4); // Update argument list pointer\n                                intPointer2 = (int *)PTR_DAT_10034af0; // Set pointer to data\n                                localPointer2 = (int *)PTR_DAT_10034af0; // Set pointer to data\n                                // Check for null arguments\n                                if ((intPointer == (int *)0x0) || (intPointer3 = (int *)intPointer[1], intPointer3 == (int *)0x0))\n                                    goto LAB_10019644; // Go to specific label\n                                localVariable5 = (int *)(int)*(wchar_t *)intPointer; // Get wide char value\n                                localPointer2 = intPointer3; // Update pointer\n                                // Check for specific flags\n                                if ((localInteger2 & 0x800) == 0) {\n                                    localFlagVar2 = 0; // Reset local variable\n                                } else {\n                                    localVariable5 = (int *)((int)localVariable5 / 2); // Halve value\n                                    localFlagVar2 = 1; // Set flag for wide char\n                                }\n                            } else {\n                                // Handle specific characters for formatting\n                                if (localCharValue == 0x61) goto LAB_10019510; // Go to specific label\n                                if (localCharValue == 99) goto LAB_100195b4; // Go to specific label\n                            }\n                        }\n                    LAB_10019952:\n                        // Check for errors and handle formatting\n                        if (local_24c == 0) {\n                            // Check for specific flags\n                            if ((localInteger2 & 0x40) != 0) {\n                                if ((localInteger2 & 0x100) == 0) {\n                                    if ((localInteger2 & 1) == 0) {\n                                        if ((localInteger2 & 2) == 0) goto LAB_10019988; // Go to specific label\n                                        localCharValue2 = 0x20; // Set space character\n                                    } else {\n                                        localCharValue2 = 0x2b; // Set plus character\n                                    }\n                                } else {\n                                    localCharValue2 = 0x2d; // Set minus character\n                                }\n                                localFlagVar = 1; // Set flag for formatting\n                            }\n                        LAB_10019988:\n                            charPointer = (char *)((int)local_23c + (-localFlagVar - (int)localVariable5)); // Calculate pointer for output\n                            // Check for specific flags\n                            if ((localInteger2 & 0xc) == 0) {\n                                _write_multi_char(0x20, (int)charPointer, filePointer); // Write spaces to file\n                            }\n                            filePointerVar = filePointer; // Set file pointer\n                            _write_string(localFlagVar); // Write string to file\n                            // Check for specific flags\n                            if (((localInteger2 & 8) != 0) && ((localInteger2 & 4) == 0)) {\n                                _write_multi_char(0x30, (int)charPointer, filePointerVar); // Write zeros to file\n                            }\n                            // Check if there are characters to write\n                            if ((localFlagVar2 == 0) || ((int)localVariable5 < 1)) {\n                                _write_string((int)localVariable5); // Write string to file\n                            } else {\n                                localPointer5 = localVariable5; // Set length\n                                intPointer = localPointer2; // Set pointer to local array\n                                do {\n                                    wideChar = *(wchar_t *)intPointer; // Get wide character\n                                    localPointer5 = (int *)((int)localPointer5 + -1); // Decrement length\n                                    intPointer = (int *)((int)intPointer + 2); // Move to next character\n                                    errorVar = _wctomb_s(localCharArray, local_11 + 1, 6, wideChar); // Convert wide char to multibyte\n                                    // Check for conversion errors\n                                    if ((errorVar != 0) || (localCharArray[0] == 0)) {\n                                        localVariable1 = -1; // Set error flag\n                                        break; // Exit loop\n                                    }\n                                    _write_string(localCharArray[0]); // Write converted string to file\n                                } while (localPointer5 != (int *)0x0); // Continue until all characters are written\n                            }\n                            // Check for specific flags\n                            if ((-1 < localVariable1) && ((localInteger2 & 4) != 0)) {\n                                _write_multi_char(0x20, (int)charPointer, filePointerVar); // Write spaces to file\n                            }\n                        }\n                    }\n                    localCharValue = *localPointer; // Get next character from format\n                    integerVar = localVariable6; // Store current state\n                    formatString = (char *)localPointer; // Update format pointer\n                    argList = (va_list)local_228; // Update argument list pointer\n                }\n                // Check for specific flags\n                if (localFlag != '\\0') {\n                    *(uint *)(localPointer3 + 0x70) = *(uint *)(localPointer3 + 0x70) & 0xfffffffd; // Clear specific flag\n                }\n                goto LAB_10019aaa; // Go to end\n            }\n        }\n    }\n    intPointer = __errno(); // Get error number pointer\n    *intPointer = 0x16; // Set error number\nLAB_100191bd:\n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n    // Check for specific flags\n    if (localFlag != '\\0') {\n        *(uint *)(localPointer3 + 0x70) = *(uint *)(localPointer3 + 0x70) & 0xfffffffd; // Clear specific flag\n    }\nLAB_10019aaa:\n    integerVar = ___security_check_cookie_4(localUnsignedIntVar ^ (uint)localUndefinedArray); // Security check\n    return integerVar; // Return result\n}\n"}
{"Function Name": "strtoxl", "Address": "10019ae5", "Source Code": "\nulong __cdecl\nstrtoxl(localeinfo_struct *param_1,char *param_2,char **param_3,int param_4,int param_5)\n{\n    byte bVar8; // Variable to store the current character being processed\n    byte *pbVar2; // Pointer to traverse the input string\n    uint uVar4; // Variable to store a computed value based on the base\n    pthreadlocinfo ptVar5; // Pointer to locale information structure\n    ulong local_8; // Variable to store the resulting converted value\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18,param_1); // Update locale information\n\n    if (param_3 != (char **)0x0) { // Check if output pointer is provided\n        *param_3 = param_2; // Set output pointer to the start of the input string\n    }\n    if ((param_2 == (char *)0x0) || ((param_4 != 0 && ((param_4 < 2 || (0x24 < param_4)))))) { // Validate input parameters\n        *(__errno()) = 0x16; // Set error number for invalid parameter\n        __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0); // Call invalid parameter handler\n        return 0; // Return 0 for error case\n    }\n    \n    bVar8 = *param_2; // Get the first character of the input string\n    local_8 = 0; // Initialize the result variable to 0\n    ptVar5 = local_18.locinfo; // Get the locale information\n    pbVar2 = (byte *)param_2; // Initialize pointer to the input string\n    \n    while (true) { // Loop to skip whitespace characters\n        if ((int)ptVar5->locale_name[3] < 2) { // Check locale settings\n            uVar4 = (byte)ptVar5[1].lc_category[0].locale[(uint)bVar8 * 2] & 8; // Determine if character is valid based on locale\n        } else {\n            uVar4 = __isctype_l((uint)bVar8,8,&local_18); // Check character type for locale\n            ptVar5 = local_18.locinfo; // Update locale information\n        }\n        if (uVar4 == 0) break; // Exit loop if character is not valid\n        bVar8 = *(++pbVar2); // Move to the next character\n    }\n    \n    if (bVar8 == 0x2d) { // Check for negative sign\n        param_5 |= 2; // Set the negative flag\n        bVar8 = *(++pbVar2); // Move to the next character\n    } else if (bVar8 == 0x2b) { // Check for positive sign\n        bVar8 = *(++pbVar2); // Move to the next character\n    }\n    \n    if (((param_4 < 0) || (param_4 == 1)) || (0x24 < param_4)) { // Validate base parameter\n        if (param_3 != (char **)0x0) { // Check if output pointer is provided\n            *param_3 = param_2; // Set output pointer to the start of the input string\n        }\n        return 0; // Return 0 for error case\n    }\n    \n    if (param_4 == 0) { // Determine base if not specified\n        if (bVar8 != 0x30) { // If not '0'\n            param_4 = 10; // Default to base 10\n        } else if ((*pbVar2 != 0x78) && (*pbVar2 != 0x58)) { // Check for 'x' or 'X'\n            param_4 = 8; // Set base to 8\n        } else {\n            param_4 = 0x10; // Set base to 16\n        }\n    } else if ((param_4 != 0x10) || (bVar8 != 0x30)) { // If base is 16 and first character is not '0'\n        goto LAB_10019c02; // Jump to conversion logic\n    }\n    \n    if ((*pbVar2 == 0x78) || (*pbVar2 == 0x58)) { // Check for 'x' or 'X'\n        bVar8 = *(pbVar2 + 1); // Move to the next character\n        pbVar2 += 2; // Skip 'x' or 'X'\n    }\n    \nLAB_10019c02: // Label for conversion logic\n    uVar4 = (uint)(0xffffffff / (ulonglong)(uint)param_4); // Calculate the maximum value for overflow checking\n    \n    do {\n        ushort uVar1 = *(ushort *)(ptVar5[1].lc_category[0].locale + (uint)bVar8 * 2); // Get character classification\n        \n        if ((uVar1 & 4) == 0) { // Check if character is a digit\n            if ((uVar1 & 0x103) == 0) { // Check if character is not a valid digit\n                pbVar2--; // Move back one character\n                if ((param_5 & 8U) == 0) { // Check if overflow flag is not set\n                    if (param_3 != (char **)0x0) { // Check if output pointer is provided\n                        pbVar2 = (byte *)param_2; // Set output pointer to the start of the input string\n                    }\n                    local_8 = 0; // Set result to 0\n                } else if (((param_5 & 4U) != 0) || // Check for specific overflow conditions\n                           (((param_5 & 1U) == 0 && \n                           ((((param_5 & 2U) != 0 && (0x80000000 < local_8)) || \n                           ((param_5 & 2U) == 0 && (0x7fffffff < local_8)))))))) {\n                    *(__errno()) = 0x22; // Set error number for overflow\n                    local_8 = (param_5 & 1U) ? 0xffffffff : ((param_5 & 2U) != 0) + 0x7fffffff; // Set result based on overflow conditions\n                }\n                if (param_3 != (char **)0x0) { // Check if output pointer is provided\n                    *param_3 = (char *)pbVar2; // Set output pointer to the current position\n                }\n                if ((param_5 & 2U) != 0) { // Check if negative flag is set\n                    local_8 = -local_8; // Negate the result\n                }\n                return local_8; // Return the result\n            }\n            int iVar7 = (int)(char)bVar8; // Convert character to integer\n            if ((byte)(bVar8 + 0x9f) < 0x1a) { // Check if character is a lowercase letter\n                iVar7 -= 0x20; // Convert to uppercase\n            }\n            uint uVar6 = iVar7 - 0x37; // Calculate the value for letters\n        } else {\n            uint uVar6 = (int)(char)bVar8 - 0x30; // Convert digit character to integer\n        }\n        \n        if ((uint)param_4 <= uVar6) goto LAB_10019c5c; // Check if value exceeds base\n        \n        if ((local_8 < uVar4) || // Check for potential overflow\n            (local_8 == uVar4 && (uVar6 <= (uint)(0xffffffff % (ulonglong)(uint)param_4)))) { // Check for exact overflow condition\n            local_8 = local_8 * param_4 + uVar6; // Update the result\n            param_5 |= 8; // Set overflow flag\n        } else {\n            param_5 |= 0xc; // Set error flag for overflow\n            if (param_3 == (char **)0x0) goto LAB_10019c5c; // If no output pointer, jump to end\n        }\n        \n        bVar8 = *(pbVar2++); // Move to the next character\n    } while (true); // Continue processing until all characters are processed\n}\n"}
{"Function Name": "__msize", "Address": "10019d39", "Source Code": "\nsize_t __cdecl __msize(void *memoryPointer) // Function to get the size of allocated memory\n{\n    size_t allocatedSize; // Variable to store the size of memory\n    if (memoryPointer == (void *)0x0) { // Check if the provided memory pointer is null\n        *__errno() = 0x16; // Set errno to indicate an error (invalid parameter)\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to handle invalid parameter\n        allocatedSize = 0xffffffff; // Set size variable to indicate failure\n    }\n    else { // If memory pointer is not null\n        if (conditionFlag == 3) { // Check a specific condition (possibly a state or mode)\n            __lock(4); // Acquire a lock for thread safety\n            if (thunk_FUN_10016ae8((void *)0x4, (int)memoryPointer) != 0) { // Call a function to validate memory\n                allocatedSize = *(int *)((int)memoryPointer + -4) - 9; // Calculate the size of the memory block\n                FUN_10019dd3(); // Call another function (possibly to release the lock or cleanup)\n                return allocatedSize; // Return the calculated size\n            }\n        }\n        allocatedSize = HeapSize(heapHandle, 0, memoryPointer); // Get the size of the memory block from the heap\n    }\n    return allocatedSize; // Return the size of the memory block\n}\n"}
{"Function Name": "FUN_10019dd3", "Address": "10019dd3", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10019dd3\n{\n    callAnotherFunction(4); // Call the function FUN_10016973 with an argument of 4\n}\n"}
{"Function Name": "__amsg_exit", "Address": "10019ddc", "Source Code": "\nvoid __cdecl __amsg_exit(int exitCode)\n{\n    // Call function to display a message banner\n    __FF_MSGBANNER();\n    \n    // Write the message associated with the provided parameter\n    __NMSG_WRITE(exitCode);\n    \n    // Call the exit function with a specific exit code (0xff)\n    ((code *)__decode_pointer((int)PTR___exit_10034af8))(0xff);\n}\n"}
{"Function Name": "FUN_10019e3b", "Address": "10019e3b", "Source Code": "\nvoid lockFunction(void) // Function definition for FUN_10019e3b\n{\n    lock(8); // Call the __lock function with argument 8\n}\n"}
{"Function Name": "FUN_10019e44", "Address": "10019e44", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10019e44\n{\n    callAnotherFunction(8); // Call the function FUN_10016973 with an argument of 8\n}\n"}
{"Function Name": "__cinit", "Address": "10019ef8", "Source Code": "\nint __cdecl __cinit(int input_param)\n{\n    // Check if the pointer to the floating-point math function is not null\n    // and if it is writable in the current image\n    if (fpmath_function_pointer != (undefined *)0x0 && \n        is_nonwritable_in_current_image((PBYTE)&fpmath_function_pointer)) {\n        // Call the floating-point math function with the provided parameter\n        (*(code *)fpmath_function_pointer)(input_param);\n    }\n    \n    // Initialize miscellaneous floating-point conversion table\n    initialize_misc_float_conversion_table();\n    \n    // Initialize a set of functions and check if initialization was successful\n    if (initialize_function_set((undefined **)&function_array_start, (undefined **)&function_array_end) == 0) {\n        // Register a function to be called at program exit\n        register_exit_function((_func_4879 *)&LAB_1001dcfb);\n        \n        // Pointer to the beginning of a function pointer array\n        code **function_pointer_array = (code **)&function_pointer_array_start;\n        \n        // Iterate through the function pointer array\n        while (function_pointer_array < &function_pointer_array_end) {\n            // Check if the current function pointer is not null\n            if (*function_pointer_array != (code *)0x0) {\n                // Call the function pointed to by the current pointer\n                (**function_pointer_array)();\n            }\n            // Move to the next function pointer\n            function_pointer_array++;\n        }\n        \n        // Check if a specific function pointer is not null and writable\n        if (specific_function_pointer != (code *)0x0 && \n            is_nonwritable_in_current_image((PBYTE)&specific_function_pointer)) {\n            // Call the function with specified parameters\n            (*specific_function_pointer)(0, 2, 0);\n        }\n    }\n    \n    // Return 0 indicating successful completion of initialization\n    return 0;\n}\n"}
{"Function Name": "_doexit", "Address": "10019f8a", "Source Code": "\nvoid __cdecl _doexit(int exit_code, int cleanup_flag, int finalization_flag)\n{\n    code **cleanup_start; // Pointer to a function pointer for cleanup\n    code **cleanup_end; // Pointer to track the end of the cleanup functions\n    __lock(8); // Acquire a lock to ensure thread safety\n    if (exit_initiated != 1) { // Check if exit process has not been initiated\n        exit_process_mark = 1; // Mark exit process as initiated\n        stored_param_3 = (undefined)finalization_flag; // Store the third parameter for later use\n        if (cleanup_flag == 0) { // Check if the second parameter is zero\n            cleanup_start = (code **)__decode_pointer(cleanup_start_pointer); // Decode pointer for cleanup functions start\n            cleanup_end = (code **)__decode_pointer(cleanup_end_pointer); // Decode pointer for cleanup functions end\n            if (cleanup_start != (code **)0x0) { // Ensure the start pointer is valid\n                while (cleanup_start <= cleanup_end) { // Iterate through the cleanup functions\n                    if (*cleanup_end != (code *)0x0) { // Check if the current function pointer is valid\n                        (**cleanup_end)(); // Call the cleanup function\n                    }\n                    cleanup_end--; // Move to the previous function pointer\n                }\n            }\n            __initterm((undefined **)&function_set_1); // Initialize a set of functions\n        }\n        __initterm((undefined **)&function_set_2); // Initialize another set of functions\n    }\n    FUN_1001a043(); // Call a function for additional cleanup or finalization\n    if (finalization_flag == 0) { // Check if the third parameter is zero\n        exit_initiated = 1; // Mark exit process as initiated\n        FUN_10016973(8); // Call a function with a specific parameter, possibly for cleanup\n        ___crtExitProcess(exit_code); // Terminate the process with the given exit code\n    }\n}\n"}
{"Function Name": "FUN_1001a043", "Address": "1001a043", "Source Code": "\nvoid check_value(void) // Function definition\n{\n    // Check if the value at the memory address (unaff_EBP + 0x10) is not equal to 0\n    if (*(int *)(base_pointer + 0x10) != 0) {\n        // Call the function FUN_10016973 with the argument 8\n        call_function(8);\n    }\n}\n"}
{"Function Name": "__exit", "Address": "1001a058", "Source Code": "\n// Function declaration for __exit, taking an integer parameter _Code\nvoid __cdecl __exit(int exitCode)\n{\n    // Call the _doexit function with _Code, 1, and 0 as arguments\n    _doexit(exitCode, 1, 0);\n}\n"}
{"Function Name": "__cexit", "Address": "1001a069", "Source Code": "\n// Function declaration for __cexit, which is called during program termination\nvoid __cdecl cleanup_exit(void)\n{\n    // Call _doexit function with parameters 0, 0, and 1 to perform cleanup and exit\n    perform_exit(0, 0, 1);\n}\n"}
{"Function Name": "__vswprintf_helper", "Address": "1001a22e", "Source Code": "\nint __cdecl\n__vswprintf_helper(undefined *param_1, char *param_2, uint param_3, int param_4, undefined4 param_5, undefined4 param_6)\n{\n    FILE local_24; // Declare a local FILE structure to manage output\n\n    // Check for invalid parameters: param_4 must be non-zero and param_2 must not be NULL if param_3 is non-zero\n    if (param_4 == 0 || (param_3 != 0 && param_2 == (char *)0x0)) {\n        *__errno() = 0x16; // Set errno to indicate an invalid parameter error\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return -1; // Return error code\n    }\n\n    // Initialize the local FILE structure\n    local_24._flag = 0x42; // Set the flag for the FILE structure\n    local_24._base = param_2; // Set the base pointer to the output buffer\n    local_24._ptr = param_2; // Set the current pointer to the output buffer\n    local_24._cnt = (param_3 < 0x40000000) ? param_3 * 2 : 0x7fffffff; // Set the count of available characters\n\n    // Call the function pointed to by param_1 with the local FILE structure and other parameters\n    int iVar2 = (*(code *)param_1)(&local_24, param_4, param_5, param_6);\n    \n    // If param_2 is NULL, return the result of the function call\n    if (param_2 == (char *)0x0) {\n        return iVar2;\n    }\n\n    // Check if the function call was successful\n    if (iVar2 >= 0) {\n        local_24._cnt--; // Decrement the count of available characters\n        // Check if the count is negative\n        if (local_24._cnt < 0) {\n            // Flush the buffer if count is negative\n            if (__flsbuf(0, &local_24) == -1) goto LAB_1001a310; // Handle flush error\n        } else {\n            *local_24._ptr++ = '\\0'; // Null-terminate the string\n        }\n        local_24._cnt--; // Decrement the count again\n        // Check if the count is still non-negative\n        if (local_24._cnt >= 0) {\n            *local_24._ptr = '\\0'; // Null-terminate the string\n            return iVar2; // Return the result of the function call\n        }\n        // Attempt to flush the buffer again if count is negative\n        if (__flsbuf(0, &local_24) != -1) {\n            return iVar2; // Return the result if flush was successful\n        }\n    }\nLAB_1001a310:\n    // Null-terminate the output buffer at the calculated position\n    *(undefined2 *)(param_2 + param_3 * 2 - 2) = 0; \n    return (local_24._cnt >= 0) - 2; // Return adjusted count or error code\n}\n"}
{"Function Name": "FID_conflict:__vswprintf_p_l", "Address": "1001a324", "Source Code": "\nint __cdecl\nFID_conflict___vswprintf_p_l\n(wchar_t *_DstBuf, size_t _MaxCount, wchar_t *_Format, _locale_t _Locale, va_list _ArgList)\n{\n    // Call the helper function to format the wide string output\n    // Pass the output function, destination buffer, maximum count, format string, locale, and argument list\n    return __vswprintf_helper(__woutput_l, (char *)_DstBuf, _MaxCount, (int)_Format, _Locale, _ArgList) < 0 ? -1 : 0;\n    // Return -1 if the helper function returns a negative value, otherwise return 0\n}\n"}
{"Function Name": "__flush", "Address": "1001a34c", "Source Code": "\nint __cdecl __flush(FILE *fileStream) // Function to flush the buffer of a file stream\n{\n    int returnValue = 0; // Variable to store return value, initialized to 0\n    // Check if the file is open for writing and if it has a valid buffer\n    if ((((byte)fileStream->_flag & 3) == 2) && ((fileStream->_flag & 0x108U) != 0)) {\n        char *bufferStart = fileStream->_base; // Pointer to the start of the buffer\n        uint bytesToWrite = (int)fileStream->_ptr - (int)bufferStart; // Calculate the number of bytes to write\n        // If there are bytes to write\n        if (0 < (int)bytesToWrite) {\n            int fileDescriptor = __fileno(fileStream); // Get the file descriptor\n            uint bytesWritten = __write(fileDescriptor, bufferStart, bytesToWrite); // Write the buffer to the file\n            // Check if the number of bytes written is less than expected\n            if (bytesWritten != bytesToWrite) {\n                fileStream->_flag |= 0x20; // Set error flag if write fails\n                returnValue = -1; // Set return value to -1 to indicate error\n            } else if ((char)fileStream->_flag < '\\0') { // Check if the file is in a special state\n                fileStream->_flag &= 0xfffffffd; // Clear the special state flag\n            }\n        }\n    }\n    fileStream->_cnt = 0; // Reset the count of bytes in the buffer\n    fileStream->_ptr = fileStream->_base; // Reset the pointer to the start of the buffer\n    return returnValue; // Return the result of the flush operation\n}\n"}
{"Function Name": "FUN_1001a492", "Address": "1001a492", "Source Code": "\nvoid FUN_1001a492(void)\n{\n    // Call the function __unlock_file2 with two arguments:\n    // 1. unaff_ESI - a variable that likely holds a file descriptor or index\n    // 2. The dereferenced pointer from DAT_100367a0, indexed by unaff_ESI, which retrieves a specific file pointer\n    __unlock_file2(file_descriptor, *(void **)(file_pointer_array + file_descriptor * 4));\n}\n"}
{"Function Name": "FUN_1001a4c1", "Address": "1001a4c1", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1001a4c1\n{\n    callAnotherFunction(1); // Call the function FUN_10016973 with an argument of 1\n}\n"}
{"Function Name": "FUN_1001a513", "Address": "1001a513", "Source Code": "\nvoid unlock_file_function(void) // Function declaration\n{\n    // Unlock the file pointed to by the pointer located at the offset 8 of the first integer in memory\n    unlock_file(*(FILE **)(*(int *)0 + 8)); \n}\n"}
{"Function Name": "_fwprintf", "Address": "1001a526", "Source Code": "\nint __cdecl _fwprintf(FILE *filePointer, wchar_t *formatString, ...)\n{\n    int returnValue; // Variable to store the return value\n\n    // Check if the file pointer or format string is null\n    if ((filePointer == (FILE *)0x0) || (formatString == (wchar_t *)0x0)) {\n        *__errno() = 0x16; // Set errno to indicate an error\n        handleInvalidParameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to handle invalid parameters\n        returnValue = -1; // Set return value to -1 to indicate failure\n    } else {\n        lockFile(filePointer); // Lock the file for safe access\n        // Call the function to output formatted wide characters to the file\n        returnValue = outputFormattedWideChars(filePointer, formatString, (_locale_t)0x0, &stack0x0000000c);\n        flushFileBuffer(getFileBuffer(filePointer), filePointer); // Flush the file buffer\n        additionalFunction(); // Call additional function (purpose unclear)\n    }\n    \n    return returnValue; // Return the result of the operation\n}\n"}
{"Function Name": "FUN_1001a5b0", "Address": "1001a5b0", "Source Code": "\nvoid unlockFileFunction(void) // Function declaration for FUN_1001a5b0\n{\n    // Unlock the file pointed to by the pointer located at the offset 8 of the first element of the global data\n    unlockFile(*(FILE **)(*(int *)0 + 8));\n}\n"}
{"Function Name": "FUN_1001a6ae", "Address": "1001a6ae", "Source Code": "\nvoid unlock_file_function(void)\n{\n    // Unlock the file associated with the file pointer located at offset 8 of the first element in the global data structure\n    unlock_file(*(FILE **)(*(int *)0 + 8));\n}\n"}
{"Function Name": "FUN_1001a6b8", "Address": "1001a6b8", "Source Code": "\n// Function declaration: FUN_1001a6b8 returns a pointer to an undefined type (double pointer)\nundefined ** getPointerToUndefinedType(void)\n{\n    // Return the value of the global pointer PTR_DAT_10034b00\n    return globalPointer;\n}\n"}
{"Function Name": "__lock_file2", "Address": "1001a7be", "Source Code": "\nvoid __cdecl lockFile(int index, void *file)\n{\n    // Check if the index is less than 20 (0x14 in hexadecimal)\n    if (index < 0x14) {\n        // Lock the resource using the index offset by 16 (0x10 in hexadecimal)\n        lockResource(index + 0x10);\n    } else {\n        // Enter a critical section for the file, using the address offset by 32 (0x20 in hexadecimal)\n        enterCriticalSection((LPCRITICAL_SECTION)((int)file + 0x20));\n    }\n}\n"}
{"Function Name": "__unlock_file2", "Address": "1001a810", "Source Code": "\nvoid __cdecl __unlock_file2(int fileIndex, void *filePointer)\n{\n    // Check if the index is less than 20 (0x14 in hexadecimal)\n    if (fileIndex < 0x14) {\n        // Call a function with the index incremented by 16 (0x10 in hexadecimal)\n        FUN_10016973(fileIndex + 0x10);\n    } else {\n        // Leave the critical section associated with the file\n        LeaveCriticalSection((LPCRITICAL_SECTION)((int)filePointer + 0x20));\n    }\n}\n"}
{"Function Name": "_siglookup", "Address": "1001a84c", "Source Code": "\nuint __fastcall _siglookup(undefined4 input_value, int target_value, uint start_index)\n{\n    uint current_index = start_index; // Initialize uVar1 with the value of param_3\n    // Loop until uVar1 reaches the calculated upper limit\n    while (current_index < upper_limit * 0xc + start_index) {\n        // Check if the value at the memory address (uVar1 + 4) matches param_2\n        if (*(int *)(current_index + 4) == target_value) {\n            return current_index; // Return the current value of uVar1 if a match is found\n        }\n        current_index += 0xc; // Increment uVar1 by 12 (0xc in hexadecimal)\n    }\n    return 0; // Return 0 if no match is found\n}\n"}
{"Function Name": "___get_sigabrt", "Address": "1001a880", "Source Code": "\n// Function declaration for ___get_sigabrt, returning a pointer of type _PHNDLR\n_PHNDLR cdecl get_signal_abort(void)\n{\n    // Decode the pointer stored at DAT_1003649c and cast it to _PHNDLR type\n    return (_PHNDLR)__decode_pointer(data_pointer);\n}\n"}
{"Function Name": "FUN_1001aa01", "Address": "1001aa01", "Source Code": "\nvoid check_value(void) // Function definition\n{\n    // Check if the value at the memory address (unaff_EBP - 0x1c) is not equal to 0\n    if (*(int *)(base_pointer - 0x1c) != 0) {\n        // Call the function FUN_10016973 with argument 0\n        call_function(0);\n    }\n}\n"}
{"Function Name": "___crtMessageBoxW", "Address": "1001aa3d", "Source Code": "\nint __cdecl ___crtMessageBoxW(LPCWSTR messageText, LPCWSTR messageCaption, UINT messageType)\n{\n    HMODULE moduleHandle; // Handle to the loaded module\n    FARPROC functionPointer; // Pointer to the function retrieved from the module\n    int result; // Variable to store the result of a function call\n    code *functionCodePointer; // Pointer to a function code\n    int osPlatformInfo; // Local variable to store OS platform information\n    uint windowsMajorVersion; // Local variable to store Windows major version\n    int messageBoxResult = 0; // Local variable to store the result of MessageBox call\n\n    osPlatformInfo = 0; // Initialize local_c to 0\n    if (DAT_100364a8 == 0) { // Check if the function pointer is not initialized\n        moduleHandle = LoadLibraryW(L\"USER32.DLL\"); // Load the USER32 DLL\n        // Check if the module was loaded successfully and retrieve MessageBoxW address\n        if ((moduleHandle == (HMODULE)0x0) || (functionPointer = GetProcAddress(moduleHandle, \"MessageBoxW\"), functionPointer == (FARPROC)0x0)) {\n            return 0; // Return 0 if loading or retrieving the function failed\n        }\n        DAT_100364a8 = __encode_pointer((int)functionPointer); // Store the encoded pointer to MessageBoxW\n        functionPointer = GetProcAddress(moduleHandle, \"GetActiveWindow\"); // Retrieve GetActiveWindow address\n        DAT_100364ac = __encode_pointer((int)functionPointer); // Store the encoded pointer to GetActiveWindow\n        functionPointer = GetProcAddress(moduleHandle, \"GetLastActivePopup\"); // Retrieve GetLastActivePopup address\n        DAT_100364b0 = __encode_pointer((int)functionPointer); // Store the encoded pointer to GetLastActivePopup\n        // Check the OS platform and invoke Watson if necessary\n        if (__get_osplatform(&osPlatformInfo) != 0) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n        if (osPlatformInfo == 2) { // If the platform is Windows 2000 or later\n            functionPointer = GetProcAddress(moduleHandle, \"GetUserObjectInformationW\"); // Retrieve GetUserObjectInformationW address\n            DAT_100364b8 = __encode_pointer((int)functionPointer); // Store the encoded pointer to GetUserObjectInformationW\n            if (DAT_100364b8 != 0) { // Check if the pointer is valid\n                functionPointer = GetProcAddress(moduleHandle, \"GetProcessWindowStation\"); // Retrieve GetProcessWindowStation address\n                DAT_100364b4 = __encode_pointer((int)functionPointer); // Store the encoded pointer to GetProcessWindowStation\n            }\n        }\n    }\n\n    result = __encoded_null(); // Get the encoded null pointer\n    // Check if the required function pointers are valid\n    if ((DAT_100364b4 == result) || (DAT_100364b8 == result)) {\n        if (DAT_100364ac != result) { // If GetActiveWindow is valid\n            functionCodePointer = (code *)__decode_pointer(DAT_100364ac); // Decode the pointer\n            messageBoxResult = (*functionCodePointer)(); // Call GetActiveWindow\n            // If the result is valid, call GetLastActivePopup\n            if ((messageBoxResult != 0) && (DAT_100364b0 != result)) {\n                functionCodePointer = (code *)__decode_pointer(DAT_100364b0); // Decode the pointer\n                messageBoxResult = (*functionCodePointer)(messageBoxResult); // Call GetLastActivePopup\n            }\n        }\n    } else {\n        functionCodePointer = (code *)__decode_pointer(DAT_100364b4); // Decode the pointer to GetProcessWindowStation\n        int processWindowStationResult = (*functionCodePointer)(); // Call GetProcessWindowStation\n        if (processWindowStationResult != 0) { // If the result is valid\n            undefined userObjectInfo[4]; // Local variable for storing user object information\n            functionCodePointer = (code *)__decode_pointer(DAT_100364b8); // Decode the pointer to GetUserObjectInformationW\n            processWindowStationResult = (*functionCodePointer)(processWindowStationResult, 1, userObjectInfo, 0xc, (undefined *)0); // Call GetUserObjectInformationW\n            // If the call was successful and a specific condition is met\n            if ((processWindowStationResult != 0) && ((local_1c & 1) != 0)) {\n                if (DAT_100364ac != result) { // If GetActiveWindow is valid\n                    functionCodePointer = (code *)__decode_pointer(DAT_100364ac); // Decode the pointer\n                    messageBoxResult = (*functionCodePointer)(); // Call GetActiveWindow\n                }\n            }\n        }\n        // Check the Windows major version and invoke Watson if necessary\n        if (__get_winmajor(&windowsMajorVersion) != 0) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n        messageType = (messageType | (windowsMajorVersion < 4 ? 0x40000 : 0x200000)); // Modify _UType based on Windows version\n    }\n    functionCodePointer = (code *)__decode_pointer(DAT_100364a8); // Decode the pointer to MessageBoxW\n    return (*functionCodePointer)(messageBoxResult, messageText, messageCaption, messageType); // Call MessageBoxW and return the result\n}\n"}
{"Function Name": "__itow_s", "Address": "1001acca", "Source Code": "\nerrno_t __cdecl __itow_s(int value, wchar_t *destinationBuffer, size_t bufferSize, int base)\n{\n    // Call the internal function _xtow_s_20 to convert the integer to a wide character string\n    // Pass the integer value _Val, size in words _SizeInWords, and determine the radix\n    // If the radix is 10 and the value is negative, use 10; otherwise, use the provided radix\n    // Also determine if the value is negative; if so, pass 1; otherwise, pass 0\n    return _xtow_s_20(value, bufferSize, (base == 10 && value < 0) ? 10 : base, (base == 10 && value < 0) ? 1 : 0);\n}\n"}
{"Function Name": "FUN_1001ae9e", "Address": "1001ae9e", "Source Code": "\nint __cdecl FUN_1001ae9e(short *input_array)\n{\n    short *current_element = input_array; // Initialize a pointer to the start of the input array\n    while (*current_element != 0) { // Loop until a null terminator (0) is found\n        current_element++; // Move the pointer to the next element in the array\n    }\n    // Calculate the number of elements in the array (excluding the null terminator)\n    // by subtracting the starting address from the current address, dividing by 2 (size of short),\n    // and then subtracting 1 to exclude the null terminator itself\n    return ((int)current_element - (int)input_array >> 1) - 1;\n}\n"}
{"Function Name": "__assert", "Address": "1001afe0", "Source Code": "\nvoid __cdecl __assert(uchar *expression, uchar *fileName, int lineNumber)\n{\n    int errorModeStatus; // Variable to store error mode status\n    errno_t errorCode; // Variable to store error codes from string operations\n    DWORD moduleFileNameResult; // Variable to store the result of GetModuleFileNameA\n    size_t stringLength; // Variable to store string lengths\n    uint lastBackslashIndex; // Variable to store the index of the last backslash in the file path\n    uchar lastCharacter; // Variable to store the character at the end of the file path\n    uchar *filePathPointer; // Pointer for traversing the file path\n    char *fileStreamPointer; // Pointer for file stream operations\n    uchar programNameBuffer[112]; // Buffer to hold the program name\n    uchar assertionMessageBuffer[543]; // Buffer to hold the assertion message\n    uint securityCookie = DAT_100345e0 ^ (uint)programNameBuffer; // Security cookie for stack protection\n\n    errorModeStatus = __set_error_mode(3); // Set the error mode to a specific value\n    if ((errorModeStatus == 1) || ((errorModeStatus = __set_error_mode(3), errorModeStatus == 0 && (DAT_10035bb0 == 1)))) {\n        fileStreamPointer = (char *)0x0; // Initialize file pointer to NULL\n        _setvbuf((FILE *)(FUN_1001a6b8() + 0x10), fileStreamPointer, 4, 0); // Set the buffer for the file stream\n        fileStreamPointer = s_Assertion_failed___s__file__s__l_10034d80; // Prepare the assertion failure message\n        _fprintf((FILE *)(FUN_1001a6b8() + 0x10), fileStreamPointer); // Print the assertion failure message\n        _fflush((FILE *)(FUN_1001a6b8() + 0x10)); // Flush the file stream\n    } else {\n        errorCode = _strcpy_s((char *)(assertionMessageBuffer + 3), 0x21c, \"Assertion failed!\"); // Copy assertion message to buffer\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034db0); // Append program name to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, \"Program: \"); // Append \"Program: \" to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        moduleFileNameResult = GetModuleFileNameA((HMODULE)0x0, (LPSTR)programNameBuffer, 0x104); // Get the name of the current module\n        if ((moduleFileNameResult == 0) && (errorCode = _strcpy_s((char *)programNameBuffer, 0x105, \"<program name unknown>\"), errorCode != 0)) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        }\n        stringLength = _strlen((char *)programNameBuffer); // Get the length of the program name\n        if (0x3c < stringLength + 0xb) { // Check if the length exceeds a certain threshold\n            errorCode = __mbsnbcpy_s(programNameBuffer + stringLength, (size_t)(assertionMessageBuffer + -(int)(programNameBuffer + stringLength)), PTR_DAT_10034da8, 3); // Copy additional data to buffer\n            if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        }\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, (char *)programNameBuffer); // Append program name to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034dac); // Append additional data to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, \"File: \"); // Append \"File: \" to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        stringLength = _strlen((char *)fileName); // Get the length of the file name\n        if (0x3c < stringLength + 8) { // Check if the length exceeds a certain threshold\n            lastCharacter = fileName[stringLength - 1]; // Get the last character of the file name\n            if (lastCharacter != '\\\\') { // If the last character is not a backslash\n                filePathPointer = fileName + (stringLength - 1); // Set pointer to the end of the file name\n                while (lastCharacter != '\\\\' && stringLength > 1) { // Find the last backslash in the file name\n                    stringLength--;\n                    lastCharacter = *--filePathPointer;\n                }\n            }\n            lastBackslashIndex = stringLength; // Store the index of the last backslash\n            if (lastBackslashIndex < 0x24 || 0x10 < stringLength) { // Check length conditions\n                if (lastBackslashIndex < 0x23) { // If the length is less than a certain threshold\n                    errorCode = __mbsnbcat_s(assertionMessageBuffer + 3, 0x21c, fileName, 0x31 - (stringLength >> 1)); // Append part of the file name\n                    if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034da8); // Append additional data\n                    if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    fileName += stringLength - (stringLength >> 1); // Adjust the file name pointer\n                } else {\n                    errorCode = __mbsnbcat_s(assertionMessageBuffer + 3, 0x21c, fileName, 0x20); // Append part of the file name\n                    if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034da8); // Append additional data\n                    if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    errorCode = __mbsnbcat_s(assertionMessageBuffer + 3, 0x21c, fileName + lastBackslashIndex, 7); // Append remaining part of the file name\n                    if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034da8); // Append additional data\n                    if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                    fileName += stringLength - 7; // Adjust the file name pointer\n                }\n            } else {\n                errorCode = __mbsnbcat_s(assertionMessageBuffer + 3, 0x21c, fileName, 0x31 - (stringLength >> 1)); // Append part of the file name\n                if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034da8); // Append additional data\n                if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                fileName += lastBackslashIndex; // Adjust the file name pointer\n            }\n        }\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, (char *)fileName); // Append the full file name to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034dac); // Append additional data\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, \"Line: \"); // Append \"Line: \" to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        stringLength = _strlen((char *)(assertionMessageBuffer + 3)); // Get the length of the message so far\n        errorCode = __itoa_s(lineNumber, (char *)(assertionMessageBuffer + stringLength + 3), 0x21c - stringLength, 10); // Convert line number to string and append\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034db0); // Append additional data\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, \"Expression: \"); // Append \"Expression: \" to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        stringLength = _strlen((char *)expression); // Get the length of the expression\n        if (0x21c < stringLength + 0xb0 + _strlen((char *)(assertionMessageBuffer + 3))) { // Check if the total length exceeds a certain threshold\n            errorCode = __mbsnbcat_s(assertionMessageBuffer + 3, 0x21c, expression, 0x169 - _strlen((char *)(assertionMessageBuffer + 3))); // Append part of the expression\n            if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        }\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, (char *)expression); // Append the full expression to message\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034db0); // Append additional data\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, \"For information on how your program can cause an assertion\\nfailure, see the Visual C++ documentation on asserts\"); // Append additional information\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, PTR_DAT_10034db0); // Append additional data\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorCode = _strcat_s((char *)(assertionMessageBuffer + 3), 0x21c, \"(Press Retry to debug the application - JIT must be enabled)\"); // Append debugging instructions\n        if (errorCode != 0) __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n        errorModeStatus = ___crtMessageBoxA((LPCSTR)(assertionMessageBuffer + 3), \"Microsoft Visual C++ Runtime Library\", 0x12012); // Display the assertion message box\n        if (errorModeStatus == 3) { // If the user chooses to abort\n            _raise(0x16); // Raise an abort signal\n            __exit(3); // Exit the program\n        }\n        if (errorModeStatus == 4) { // If the user chooses to retry\n            ((code *)swi(3))(); // Retry the operation\n            return; // Exit the function\n        }\n        if (errorModeStatus == 5) { // If the user chooses to ignore\n            ___security_check_cookie_4(securityCookie); // Check the security cookie\n            return; // Exit the function\n        }\n    }\n    _abort(); // Abort the program if no other conditions were met\n}\n"}
{"Function Name": "__wcstombs_l_helper", "Address": "1001b6ad", "Source Code": "\nvoid __cdecl\n__wcstombs_l_helper(LPSTR param_1, LPCWSTR param_2, uint param_3, localeinfo_struct *param_4)\n{\n    WCHAR WVar2; // Variable to hold a wide character\n    int *piVar3; // Pointer to an integer (used for error handling)\n    LPCWSTR pWVar4; // Pointer to a wide string\n    int iVar5; // Variable to hold return value of WideCharToMultiByte\n    DWORD DVar6; // Variable to hold the last error code\n    uint uVar7; // Variable for character count\n    uint uVar8; // Variable for remaining characters\n    LPCWSTR local_30 = param_2; // Local copy of the wide string parameter\n    uint local_28 = 0; // Counter for the number of characters converted\n    int local_14; // Variable to hold additional information from WideCharToMultiByte\n\n    // Check if output buffer is null and if no characters are requested to convert\n    if ((param_1 != (LPSTR)0x0) && (param_3 == 0)) goto LAB_1001b836;\n\n    // Validate input parameters\n    if ((param_2 == (LPCWSTR)0x0) || (0x7fffffff < param_3)) {\n        piVar3 = __errno(); // Get pointer to errno\n        *piVar3 = 0x16; // Set errno to EINVAL\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        goto LAB_1001b836; // Exit function\n    }\n\n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_24, param_4);\n\n    // Check if output buffer is null\n    if (param_1 == (LPSTR)0x0) {\n        // Check if locale is not set\n        if (*(int *)(local_24[0] + 0x14) == 0) {\n            FUN_1001ae9e(param_2); // Handle conversion without output buffer\n        } else {\n            // Get required buffer size for conversion\n            iVar5 = WideCharToMultiByte(*(UINT *)(local_24[0] + 4), 0, param_2, -1, (LPSTR)0x0, 0, (LPCSTR)0x0, &local_14);\n            // Check for conversion errors or if there are characters to convert\n            if ((iVar5 == 0) || (local_14 != 0)) goto LAB_1001b81c;\n        }\n        goto LAB_1001b76b; // Exit function\n    } else {\n        // Check if locale is not set\n        if (*(int *)(local_24[0] + 0x14) == 0) {\n            // If there are characters to convert\n            if (param_3 != 0) {\n                do {\n                    // Check if character exceeds valid range\n                    if (0xff < (ushort)*param_2) goto LAB_1001b81c;\n                    param_1[local_28] = *(CHAR *)param_2; // Convert wide character to char\n                    WVar2 = *param_2; // Store current wide character\n                    param_2 = param_2 + 1; // Move to the next wide character\n                    // Check for null terminator\n                    if (WVar2 == L'\\0') goto LAB_1001b76b;\n                    local_28 = local_28 + 1; // Increment character count\n                } while (local_28 < param_3); // Continue until max characters are converted\n            }\n            goto LAB_1001b836; // Exit function\n        }\n\n        // Check if specific locale handling is required\n        if (*(int *)(local_24[0] + 0xac) == 1) {\n            pWVar4 = param_2; // Pointer to the wide string\n            uVar8 = param_3; // Remaining characters to convert\n            // If there are characters to convert\n            if (param_3 != 0) {\n                do {\n                    // Check for null terminator\n                    if (*pWVar4 == L'\\0') break;\n                    pWVar4 = pWVar4 + 1; // Move to the next wide character\n                    uVar8 = uVar8 - 1; // Decrement remaining count\n                } while (uVar8 != 0);\n                // Adjust param_3 if null terminator is found\n                if ((uVar8 != 0) && (*pWVar4 == L'\\0')) {\n                    param_3 = ((int)pWVar4 - (int)param_2 >> 1) + 1; // Calculate new length\n                }\n            }\n            // Perform the conversion\n            iVar5 = WideCharToMultiByte(*(UINT *)(local_24[0] + 4), 0, param_2, param_3, param_1, param_3, (LPCSTR)0x0, &local_14);\n            // Check for conversion success\n            if (iVar5 != 0) {\n                if (local_14 == 0) goto LAB_1001b76b; // Exit if no characters were converted\n            }\n        } else {\n            // Perform the conversion with the specified parameters\n            iVar5 = WideCharToMultiByte(*(UINT *)(local_24[0] + 4), 0, param_2, -1, param_1, param_3, (LPCSTR)0x0, &local_14);\n            // Check for conversion success\n            if (iVar5 != 0) goto joined_r0x1001b7fe; // Continue if successful\n            // Check if no characters were converted\n            if (local_14 == 0) {\n                DVar6 = GetLastError(); // Get the last error code\n                uVar8 = 0; // Reset character count\n                // Check if the error indicates a buffer overflow\n                if (DVar6 == 0x7a) {\n                    // Attempt to convert one character at a time\n                    while (uVar8 < param_3) {\n                        uVar7 = WideCharToMultiByte(*(UINT *)(local_24[0] + 4), 0, local_30, 1, local_10, *(int *)(local_24[0] + 0xac), (LPCSTR)0x0, &local_14);\n                        // Check for conversion errors or invalid character count\n                        if ((((uVar7 == 0) || (local_14 != 0)) || ((int)uVar7 < 0)) || (5 < uVar7)) goto LAB_1001b81c;\n                        // Check if output buffer is exceeded\n                        if (param_3 < uVar7 + uVar8) break;\n                        int iVar5 = 0; // Reset index for output buffer\n                        // If characters were converted\n                        if (0 < (int)uVar7) {\n                            do {\n                                param_1[uVar8] = local_10[iVar5]; // Copy converted character to output buffer\n                                // Check for null terminator\n                                if (local_10[iVar5] == '\\0') goto LAB_1001b8a4;\n                                iVar5 = iVar5 + 1; // Increment index\n                                uVar8 = uVar8 + 1; // Increment output character count\n                            } while (iVar5 < (int)uVar7); // Continue until all characters are copied\n                        }\n                        local_30 = local_30 + 1; // Move to the next wide character\n                    }\n                LAB_1001b8a4:\n                    goto LAB_1001b836; // Exit function\n                }\n            }\n        }\n    }\nLAB_1001b81c:\n    piVar3 = __errno(); // Get pointer to errno\n    *piVar3 = 0x2a; // Set errno to ENOMEM\nLAB_1001b836:\n    return; // Exit function\n}\n"}
{"Function Name": "FUN_1001ba9a", "Address": "1001ba9a", "Source Code": "\nvoid FUN_1001ba9a(int input_param)\n{\n    // Call the local unwind function with parameters extracted from the structure at param_1\n    local_unwind_function(*(uint **)(input_param + 0x28), // Pointer to the first argument (uint pointer)\n                    *(int *)(input_param + 0x18),   // Second argument (int value)\n                    *(uint *)(input_param + 0x1c)); // Third argument (uint value)\n}\n"}
{"Function Name": "__ioinit", "Address": "1001bb44", "Source Code": "\nint __cdecl __ioinit(void) // Function to initialize I/O\n{\n    undefined4 *handleArray; // Pointer for dynamic memory allocation\n    DWORD fileType; // Variable to store file type\n    HANDLE currentHandle; // Handle for file operations\n    int loopCounter; // Loop counter\n    UINT *reservedMemoryPtr; // Pointer to reserved memory\n    UINT reservedSize; // Variable to store reserved size\n    UINT numberOfHandles; // Variable to store the number of handles\n    _STARTUPINFOA startupInfo; // Structure to hold startup information\n    uint handleIndex; // Counter for handles\n    HANDLE *handleArrayPtr; // Pointer to handle array\n    undefined4 stackVariable; // Stack variable for initialization\n    stackVariable = 0x1001bb50; // Initialize stack variable\n    GetStartupInfoA(&startupInfo); // Get startup information\n    handleArray = (undefined4 *)__calloc_crt(0x20, 0x28); // Allocate memory for handles\n    if (handleArray == (undefined4 *)0x0) { // Check for allocation failure\n        return -1; // Return error code\n    }\n    handleCount = 0x20; // Set initial handle count\n    allocatedMemoryPtr = handleArray; // Store allocated memory pointer\n    for (; handleArray < allocatedMemoryPtr + 0x140; handleArray += 10) { // Initialize handle array\n        *handleArray = 0xffffffff; // Set handle to invalid\n        *(undefined *)(handleArray + 1) = 0; // Initialize status byte\n        *(undefined *)((int)handleArray + 5) = 10; // Set some default value\n        handleArray[2] = 0; // Initialize count\n        *(undefined *)((int)handleArray + 0x25) = 10; // Set another default value\n        *(undefined *)((int)handleArray + 0x26) = 10; // Set another default value\n    }\n    if ((startupInfo.cbReserved2 != 0) && ((UINT *)startupInfo.lpReserved2 != (UINT *)0x0)) { // Check if reserved memory is available\n        reservedSize = *(UINT *)startupInfo.lpReserved2; // Get reserved size\n        reservedMemoryPtr = (UINT *)((int)startupInfo.lpReserved2 + 4); // Pointer to next reserved memory\n        handleArrayPtr = (HANDLE *)((int)reservedMemoryPtr + reservedSize); // Pointer to handle array\n        if (0x7ff < (int)reservedSize) { // Limit reserved size\n            reservedSize = 0x800; // Set maximum size\n        }\n        loopCounter = 1; // Initialize loop counter\n        while ((numberOfHandles = reservedSize, (int)handleCount < (int)reservedSize && // Loop until handle count is less than reserved size\n               (handleArray = (undefined4 *)__calloc_crt(0x20, 0x28), handleArray != (undefined4 *)0x0))) {\n            (&allocatedMemoryPtr)[loopCounter] = handleArray; // Store allocated memory pointer\n            handleCount += 0x20; // Increment handle count\n            for (; handleArray < handleArray + 0x140; handleArray += 10) { // Initialize new handle array\n                *handleArray = 0xffffffff; // Set handle to invalid\n                *(undefined *)(handleArray + 1) = 0; // Initialize status byte\n                *(undefined *)((int)handleArray + 5) = 10; // Set some default value\n                handleArray[2] = 0; // Initialize count\n                *(undefined *)((int)handleArray + 0x25) = 10; // Set another default value\n                *(undefined *)((int)handleArray + 0x26) = 10; // Set another default value\n            }\n            loopCounter++; // Increment loop counter\n        }\n        handleIndex = 0; // Initialize handle index\n        if (0 < (int)numberOfHandles) { // Check if there are handles to process\n            do {\n                currentHandle = *handleArrayPtr; // Get current handle\n                if ((((currentHandle != (HANDLE)0xffffffff) && (currentHandle != (HANDLE)0xfffffffe)) && // Check if handle is valid\n                     ((*(byte *)reservedMemoryPtr & 1) != 0)) && // Check if a specific flag is set\n                    ((*(byte *)reservedMemoryPtr & 8) != 0 || (fileType = GetFileType(currentHandle), fileType != 0)))) { // Check file type\n                    HANDLE *handleStoragePtr = (HANDLE *)((handleIndex & 0x1f) * 0x28 + (int)(&allocatedMemoryPtr)[(int)handleIndex >> 5]); // Calculate pointer for handle storage\n                    *handleStoragePtr = *handleArrayPtr; // Store the handle\n                    *(byte *)(handleStoragePtr + 1) = *(byte *)reservedMemoryPtr; // Store status byte\n                    if (___crtInitCritSecAndSpinCount(handleStoragePtr + 3, 4000) == 0) { // Initialize critical section\n                        return -1; // Return error code on failure\n                    }\n                    handleStoragePtr[2] = (HANDLE)((int)handleStoragePtr[2] + 1); // Increment handle count\n                }\n                handleIndex++; // Increment handle index\n                reservedMemoryPtr = (UINT *)((int)reservedMemoryPtr + 1); // Move to next reserved memory\n                handleArrayPtr++; // Move to next handle\n            } while ((int)handleIndex < (int)numberOfHandles); // Continue until all handles are processed\n        }\n    }\n    loopCounter = 0; // Reset loop counter for standard handles\n    for (int standardHandleIndex = 0; standardHandleIndex < 3; standardHandleIndex++) { // Loop through standard handles\n        HANDLE *handleStoragePtr = (HANDLE *)(allocatedMemoryPtr + standardHandleIndex * 10); // Get pointer to current handle\n        if ((*handleStoragePtr == (HANDLE)0xffffffff) || (*handleStoragePtr == (HANDLE)0xfffffffe)) { // Check if handle is invalid\n            *(byte *)(handleStoragePtr + 1) = 0x81; // Set status byte\n            fileType = (standardHandleIndex == 0) ? 0xfffffff6 : 0xfffffff5 - (standardHandleIndex != 1); // Determine standard handle type\n            currentHandle = GetStdHandle(fileType); // Get standard handle\n            if (((currentHandle == (HANDLE)0xffffffff) || (currentHandle == (HANDLE)0x0)) || // Check if handle is valid\n                (fileType = GetFileType(currentHandle), fileType == 0)) { // Check file type\n                *(byte *)(handleStoragePtr + 1) |= 0x40; // Set error flag\n                *handleStoragePtr = (HANDLE)0xfffffffe; // Mark handle as invalid\n            } else {\n                *handleStoragePtr = currentHandle; // Store valid handle\n                if ((fileType & 0xff) == 2) { // Check if handle is a character device\n                    *(byte *)(handleStoragePtr + 1) |= 0x40; // Set character device flag\n                } else if ((fileType & 0xff) == 3) { // Check if handle is a pipe\n                    *(byte *)(handleStoragePtr + 1) |= 8; // Set pipe flag\n                }\n                if (___crtInitCritSecAndSpinCount(handleStoragePtr + 3, 4000) == 0) { // Initialize critical section\n                    return -1; // Return error code on failure\n                }\n                handleStoragePtr[2] = (HANDLE)((int)handleStoragePtr[2] + 1); // Increment handle count\n            }\n        } else {\n            *(byte *)(handleStoragePtr + 1) |= 0x80; // Set flag for existing handle\n        }\n    }\n    SetHandleCount(handleCount); // Set the total number of handles\n    return 0; // Return success\n}\n"}
{"Function Name": "__ftbuf", "Address": "1001be66", "Source Code": "\nvoid __cdecl __ftbuf(int flag, FILE *file)\n{\n    // Check if the flag is not zero and if the file is in a specific state\n    if (flag != 0 && (file->_flag & 0x1000) != 0) {\n        // Flush the file buffer\n        __flush(file);\n        // Clear the specific flag in the file structure\n        file->_flag &= 0xffffeeff;\n        // Set the buffer size to zero\n        file->_bufsiz = 0;\n        // Set the pointer to the buffer to NULL\n        file->_ptr = NULL;\n        // Set the base pointer of the buffer to NULL\n        file->_base = NULL;\n    }\n}\n"}
{"Function Name": "CPtoLCID", "Address": "1001be95", "Source Code": "\nint __cdecl CPtoLCID(int code_page) // Function to convert code page to LCID\n{\n    if (code_page == 0x3a4) { // Check if input is code page 0x3a4\n        return 0x411; // Return corresponding LCID for code page 0x3a4\n    }\n    if (code_page == 0x3a8) { // Check if input is code page 0x3a8\n        return 0x804; // Return corresponding LCID for code page 0x3a8\n    }\n    if (code_page == 0x3b5) { // Check if input is code page 0x3b5\n        return 0x412; // Return corresponding LCID for code page 0x3b5\n    }\n    if (code_page == 0x3b6) { // Check if input is code page 0x3b6\n        return 0x404; // Return corresponding LCID for code page 0x3b6\n    }\n    return 0; // Return 0 if input does not match any known code pages\n}\n"}
{"Function Name": "setSBCS", "Address": "1001bec4", "Source Code": "\nvoid __cdecl setSBCS(threadmbcinfostruct *thread_info)\n{\n    undefined *buffer_pointer; // Pointer to an undefined type\n\n    buffer_pointer = (undefined *)((int)thread_info + 0x1c); // Set pointer to offset 0x1c from param_1\n    _memset(buffer_pointer, 0, 0x101); // Clear 0x101 bytes starting from puVar1\n\n    // Initialize specific fields in the threadmbcinfostruct to 0\n    *(undefined4 *)((int)thread_info + 4) = 0; // Set field at offset 4 to 0\n    *(undefined4 *)((int)thread_info + 8) = 0; // Set field at offset 8 to 0\n    *(undefined4 *)((int)thread_info + 0xc) = 0; // Set field at offset 0xc to 0\n    *(undefined4 *)((int)thread_info + 0x10) = 0; // Set field at offset 0x10 to 0\n    *(undefined4 *)((int)thread_info + 0x14) = 0; // Set field at offset 0x14 to 0\n    *(undefined4 *)((int)thread_info + 0x18) = 0; // Set field at offset 0x18 to 0\n\n    // Copy data from a specific location to the buffer starting at puVar1\n    for (int index = 0; index < 0x101; index++) {\n        buffer_pointer[index] = buffer_pointer[index + ((int)&data_source - (int)thread_info)]; // Copy data with offset adjustment\n    }\n\n    buffer_pointer = (undefined *)((int)thread_info + 0x11d); // Set pointer to offset 0x11d from param_1\n    for (int index = 0; index < 0x100; index++) {\n        buffer_pointer[index] = buffer_pointer[index + ((int)&data_source - (int)thread_info)]; // Copy data with offset adjustment\n    }\n}\n"}
{"Function Name": "___updatetmbcinfo", "Address": "1001c0a3", "Source Code": "\npthreadmbcinfo __cdecl ___updatetmbcinfo(void)\n{\n    _ptiddata threadData; // Declare a variable to hold thread-specific data\n    threadData = __getptd(); // Get the thread-specific data\n    pthreadmbcinfo currentMbcInfo = threadData->ptmbcinfo; // Retrieve the current multi-byte character info\n\n    // Check if the locale is not owned or if the locale info is null\n    if (((threadData->_ownlocale & DAT_10035400) == 0) || (threadData->ptlocinfo == (pthreadlocinfo)0x0)) {\n        __lock(0xd); // Acquire a lock to ensure thread safety\n        // Check if the current multi-byte character info is not the default value\n        if (currentMbcInfo != (pthreadmbcinfo)PTR_DAT_10035308) {\n            // Check if the current multi-byte character info is not null\n            if (currentMbcInfo != (pthreadmbcinfo)0x0) {\n                // Decrement the reference count and check if it reaches zero\n                if (InterlockedDecrement(&currentMbcInfo->refcount) == 0 && currentMbcInfo != (pthreadmbcinfo)&DAT_10034ee0) {\n                    _free(currentMbcInfo); // Free the memory if reference count is zero\n                }\n            }\n            // Update the thread's multi-byte character info to the default value\n            threadData->ptmbcinfo = (pthreadmbcinfo)PTR_DAT_10035308;\n            currentMbcInfo = (pthreadmbcinfo)PTR_DAT_10035308; // Set lpAddend to the default value\n            InterlockedIncrement((LONG *)PTR_DAT_10035308); // Increment the reference count of the default value\n        }\n        FUN_1001c13e(); // Call a function to perform additional updates\n    }\n\n    // Check if the updated multi-byte character info is still null\n    if (currentMbcInfo == (pthreadmbcinfo)0x0) {\n        __amsg_exit(0x20); // Exit with an error message if null\n    }\n    return currentMbcInfo; // Return the updated multi-byte character info\n}\n"}
{"Function Name": "FUN_1001c13e", "Address": "1001c13e", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1001c13e\n{\n    callAnotherFunction(0xd); // Call to FUN_10016973 with argument 0xd (13 in decimal)\n}\n"}
{"Function Name": "getSystemCP", "Address": "1001c147", "Source Code": "\nint __cdecl getSystemCP(int inputParam)\n{\n    UINT codePageValue; // Variable to store the code page value\n    int tempStorage; // Local variable for temporary storage\n    char conditionCheck; // Local variable to check a condition\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)0x0, (localeinfo_struct *)0x0); // Initialize locale update\n    globalCondition = 0; // Reset global variable\n\n    // Check the value of unaff_ESI to determine the code page to retrieve\n    if (codePageCondition == -2) {\n        globalCondition = 1; // Set global variable indicating a specific condition\n        codePageValue = GetOEMCP(); // Get the OEM code page\n    } else if (codePageCondition == -3) {\n        globalCondition = 1; // Set global variable indicating a specific condition\n        codePageValue = GetACP(); // Get the ANSI code page\n    } else {\n        // Check for another specific condition\n        if (codePageCondition == -4) {\n            codePageValue = *(UINT *)(memoryLocation[0] + 4); // Retrieve code page from a specific memory location\n            globalCondition = 1; // Set global variable indicating a specific condition\n        } else {\n            // If none of the conditions are met, check local_8\n            if (conditionCheck == '\\0') {\n                return codePageCondition; // Return unaff_ESI if local_8 is zero\n            }\n            // Modify a specific bit in local_c\n            *(uint *)(tempStorage + 0x70) = *(uint *)(tempStorage + 0x70) & 0xfffffffd; \n            return codePageCondition; // Return unaff_ESI\n        }\n    }\n\n    // If local_8 is not zero, modify a specific bit in local_c\n    if (conditionCheck != '\\0') {\n        *(uint *)(tempStorage + 0x70) = *(uint *)(tempStorage + 0x70) & 0xfffffffd; \n    }\n    return codePageValue; // Return the retrieved code page value\n}\n"}
{"Function Name": "__setmbcp_nolock", "Address": "1001c1c1", "Source Code": "\nvoid __cdecl __setmbcp_nolock(undefined4 param_1, int param_2)\n{\n    UINT codePage; // Variable to store the code page\n    uint loopCounter; // Loop counter or index\n    BOOL resultGetCPInfo; // Variable to store the result of GetCPInfo\n    undefined2 *leadBytesPtr; // Pointer for copying lead bytes\n    byte *byteDataPtr; // Pointer for accessing byte data\n    int lcidValue; // Variable for storing LCID\n    BYTE *leadBytePtr; // Pointer for lead byte processing\n    threadmbcinfostruct *threadMBCSInfoPtr; // Pointer to thread-specific MBCS info\n    uint localIndex; // Local variable for loop index\n    byte *localByteDataPtr; // Local pointer for byte data\n    _cpinfo codePageInfo; // Structure to hold code page information\n    uint stackCookie; // Local variable for stack cookie\n\n    stackCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Initialize stack cookie\n    codePage = getSystemCP((int)threadMBCSInfoPtr); // Get the system code page\n    if (codePage != 0) { // Check if the code page is valid\n        localByteDataPtr = (byte *)0x0; // Initialize local pointer to null\n        loopCounter = 0; // Initialize loop counter\n    LAB_1001c1fd:\n        if (*(UINT *)((int)&DAT_10035310 + loopCounter) != codePage) // Check if current code page matches\n            goto code_r0x1001c205; // Jump to code for handling mismatch\n        _memset((void *)(param_2 + 0x1c), 0, 0x101); // Clear memory for the code page structure\n        localIndex = 0; // Reset local index\n        byteDataPtr = &DAT_10035320 + (int)localByteDataPtr * 0x30; // Set pointer to lead byte data\n        localByteDataPtr = byteDataPtr; // Update local pointer\n        do {\n            for (; (*byteDataPtr != 0 && (byteDataPtr[1] != 0)); byteDataPtr += 2) { // Loop through lead byte pairs\n                for (loopCounter = (uint)*byteDataPtr; loopCounter <= byteDataPtr[1]; loopCounter++) { // Set flags for valid characters\n                    *(byte *)(param_2 + 0x1d + loopCounter) |= (&DAT_1003530c)[localIndex]; // Update character flags\n                }\n            }\n            localIndex++; // Increment local index\n            byteDataPtr = localByteDataPtr + 8; // Move to the next lead byte pair\n            localByteDataPtr = byteDataPtr; // Update local pointer\n        } while (localIndex < 4); // Continue until all lead bytes are processed\n        *(UINT *)(param_2 + 4) = codePage; // Store the code page in the structure\n        *(undefined4 *)(param_2 + 8) = 1; // Set a flag indicating a valid code page\n        lcidValue = CPtoLCID((int)threadMBCSInfoPtr); // Convert code page to LCID\n        *(int *)(param_2 + 0xc) = lcidValue; // Store LCID in the structure\n        leadBytesPtr = (undefined2 *)(param_2 + 0x10); // Pointer for copying lead bytes\n        undefined2 *predefinedLeadBytesPtr = (undefined2 *)(&DAT_10035314); // Pointer to predefined lead bytes\n        for (lcidValue = 0; lcidValue < 6; lcidValue++) { // Copy lead bytes to the structure\n            *leadBytesPtr++ = *predefinedLeadBytesPtr++; // Copy each lead byte\n        }\n        goto LAB_1001c300; // Jump to finalization\n    }\nLAB_1001c1ea:\n    setSBCS(threadMBCSInfoPtr); // Set single-byte character set if code page is invalid\nLAB_1001c35d:\n    ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc); // Check stack integrity\n    return; // Exit function\ncode_r0x1001c205:\n    localByteDataPtr = (byte *)((int)localByteDataPtr + 1); // Increment local pointer\n    loopCounter += 0x30; // Move to the next code page entry\n    if (0xef < loopCounter) // Check if we've exceeded the valid range\n        goto code_r0x1001c212; // Jump to handling for exceeding range\n    goto LAB_1001c1fd; // Repeat the process for the next code page\ncode_r0x1001c212:\n    resultGetCPInfo = GetCPInfo(codePage, &codePageInfo); // Get information about the code page\n    if (resultGetCPInfo != 0) { // Check if the call was successful\n        _memset((void *)(param_2 + 0x1c), 0, 0x101); // Clear memory for the code page structure\n        *(UINT *)(param_2 + 4) = codePage; // Store the code page in the structure\n        *(undefined4 *)(param_2 + 0xc) = 0; // Reset LCID field\n        if (codePageInfo.MaxCharSize < 2) { // Check if max character size is less than 2\n            *(undefined4 *)(param_2 + 8) = 0; // Set flag to indicate single-byte characters\n        } else {\n            if (codePageInfo.LeadByte[0] != '\\0') { // Check if there are lead bytes\n                leadBytePtr = codePageInfo.LeadByte + 1; // Initialize pointer for lead bytes\n                do {\n                    if (*leadBytePtr == 0) break; // Exit if end of lead bytes is reached\n                    for (loopCounter = (uint)leadBytePtr[-1]; loopCounter <= *leadBytePtr; loopCounter++) { // Set flags for lead byte ranges\n                        *(byte *)(param_2 + 0x1d + loopCounter) |= 4; // Update character flags\n                    }\n                    leadBytePtr += 2; // Move to the next lead byte pair\n                } while (*leadBytePtr != 0); // Continue until all lead bytes are processed\n            }\n            byteDataPtr = (byte *)(param_2 + 0x1e); // Pointer for setting additional flags\n            for (lcidValue = 0xfe; lcidValue >= 0; lcidValue--) { // Set flags for all characters\n                *byteDataPtr++ |= 8; // Update character flags\n            }\n            lcidValue = CPtoLCID((int)threadMBCSInfoPtr); // Convert code page to LCID\n            *(int *)(param_2 + 0xc) = lcidValue; // Store LCID in the structure\n            *(undefined4 *)(param_2 + 8) = 0; // Reset flag for multi-byte characters\n        }\n        *(undefined4 *)(param_2 + 0x10) = 0; // Reset lead byte field\n        *(undefined4 *)(param_2 + 0x14) = 0; // Reset additional field\n        *(undefined4 *)(param_2 + 0x18) = 0; // Reset additional field\n    }\nLAB_1001c300:\n    setSBUpLow(threadMBCSInfoPtr); // Finalize settings for the thread\n    goto LAB_1001c35d; // Jump to security check\n    if (DAT_100364c4 == 0) // Check if a specific condition is met\n        goto LAB_1001c35d; // Jump to security check\n    goto LAB_1001c1ea; // Jump to set SBCS if condition is not met\n}\n"}
{"Function Name": "__setmbcp", "Address": "1001c36c", "Source Code": "\nint __cdecl __setmbcp(int code_page)\n{\n    _ptiddata thread_data; // Pointer to thread-specific data\n    pthreadmbcinfo multi_byte_info; // Pointer to multi-byte character information\n    LONG long_value; // Variable for storing long values\n    int return_status = -1; // Local variable to store return status, initialized to -1\n    thread_data = __getptd(); // Get the thread-specific data\n    ___updatetmbcinfo(); // Update the multi-byte character information\n    multi_byte_info = thread_data->ptmbcinfo; // Get the current multi-byte character information\n    int system_code_page = getSystemCP(0); // Get the current system code page\n    \n    if (system_code_page == multi_byte_info->mbcodepage) { // Check if the system code page matches the current one\n        return_status = 0; // Set return status to 0 if they match\n    } else {\n        pthreadmbcinfo new_multi_byte_info = (pthreadmbcinfo)__malloc_crt(0x220); // Allocate memory for new multi-byte character info\n        if (new_multi_byte_info != (pthreadmbcinfo)0x0) { // Check if memory allocation was successful\n            for (int loop_counter = 0x88; loop_counter != 0; loop_counter--) { // Loop to copy reference count and other data\n                new_multi_byte_info->refcount = multi_byte_info->refcount; // Copy reference count\n                multi_byte_info = (pthreadmbcinfo)&multi_byte_info->mbcodepage; // Move to the next field in the structure\n                new_multi_byte_info = (pthreadmbcinfo)&new_multi_byte_info->mbcodepage; // Move to the next field in the new structure\n            }\n            new_multi_byte_info->refcount = 0; // Initialize the reference count of the new structure\n            return_status = __setmbcp_nolock(system_code_page, (int)new_multi_byte_info); // Set the new code page without locking\n            if (return_status == 0) { // Check if setting the new code page was successful\n                long_value = InterlockedDecrement(&thread_data->ptmbcinfo->refcount); // Decrement the reference count of the old info\n                if ((long_value == 0) && (thread_data->ptmbcinfo != (pthreadmbcinfo)&DAT_10034ee0)) { // Check if it can be freed\n                    _free(thread_data->ptmbcinfo); // Free the old multi-byte character info\n                }\n                thread_data->ptmbcinfo = new_multi_byte_info; // Update the thread-specific data with the new info\n                InterlockedIncrement((LONG *)new_multi_byte_info); // Increment the reference count of the new info\n                if (((*(byte *)&thread_data->_ownlocale & 2) == 0) && (((byte)DAT_10035400 & 1) == 0)) { // Check locale settings\n                    __lock(0xd); // Acquire a lock\n                    _DAT_100364d4 = new_multi_byte_info->mbcodepage; // Update global code page variable\n                    _DAT_100364d8 = new_multi_byte_info->ismbcodepage; // Update global is-multi-byte code page variable\n                    _DAT_100364dc = *(undefined4 *)new_multi_byte_info->mbulinfo; // Update global multi-byte info\n                    for (system_code_page = 0; system_code_page < 5; system_code_page++) { // Copy multi-byte locale info\n                        (&DAT_100364c8)[system_code_page] = new_multi_byte_info->mbulinfo[system_code_page + 2]; // Copy specific fields\n                    }\n                    for (system_code_page = 0; system_code_page < 0x101; system_code_page++) { // Copy multi-byte character type info\n                        (&DAT_10035100)[system_code_page] = new_multi_byte_info->mbctype[system_code_page + 4]; // Copy specific fields\n                    }\n                    for (system_code_page = 0; system_code_page < 0x100; system_code_page++) { // Copy multi-byte case map info\n                        (&DAT_10035208)[system_code_page] = new_multi_byte_info->mbcasemap[system_code_page + 4]; // Copy specific fields\n                    }\n                    long_value = InterlockedDecrement((LONG *)PTR_DAT_10035308); // Decrement reference count of old global info\n                    if ((long_value == 0) && (PTR_DAT_10035308 != &DAT_10034ee0)) { // Check if it can be freed\n                        _free(PTR_DAT_10035308); // Free the old global multi-byte character info\n                    }\n                    PTR_DAT_10035308 = (undefined *)new_multi_byte_info; // Update the global pointer to the new info\n                    InterlockedIncrement((LONG *)new_multi_byte_info); // Increment the reference count of the new global info\n                    FUN_1001c4cd(); // Call a function to perform additional updates\n                }\n            } else if (return_status == -1) { // Check if there was an error setting the new code page\n                if (new_multi_byte_info != (pthreadmbcinfo)&DAT_10034ee0) { // Check if the new info is not a special case\n                    _free(new_multi_byte_info); // Free the new multi-byte character info\n                }\n                *__errno() = 0x16; // Set the error number to indicate failure\n            }\n        }\n    }\n    return return_status; // Return the status of the operation\n}\n"}
{"Function Name": "FUN_1001c4cd", "Address": "1001c4cd", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1001c4cd\n{\n    callAnotherFunction(0xd); // Call to FUN_10016973 with argument 0xd (13 in decimal)\n}\n"}
{"Function Name": "___initmbctable", "Address": "1001c506", "Source Code": "\nundefined4 initialize_mbctable(void) // Function to initialize the multi-byte character table\n{\n    if (init_flag == 0) { // Check if the initialization flag is not set\n        set_code_page(-3); // Set the multi-byte code page to a specific value (-3)\n        init_flag = 1; // Mark the initialization as done\n    }\n    return 0; // Return 0 indicating successful execution\n}\n"}
{"Function Name": "___strgtold12_l", "Address": "1001c5da", "Source Code": "\nuint __cdecl\n___strgtold12_l(_LDBL12 *pld12, char **p_end_ptr, char *str, int mult12, int scale, int decpt,\nint implicit_E, _locale_t _Locale)\n{\n    int iVar1; // Variable to hold intermediate integer values\n    uint uVar2; // Variable to hold unsigned integer values\n    int iVar15; // State variable for the parsing state machine\n    ushort uVar7; // Variable to hold unsigned short values\n    char cVar8; // Current character being processed\n    char *pcVar18; // Pointer to the next character in the string\n    undefined4 uVar22; // Variable for holding undefined 4-byte values\n    undefined4 local_40; // Local variable for storing intermediate results\n    undefined4 local_3c; // Local variable for storing intermediate results\n    ushort local_36; // Local variable for storing intermediate results\n    byte local_30; // Local variable for storing byte values\n    char local_24[23]; // Buffer to hold character digits\n    uint local_50 = 0; // Counter for the number of digits processed\n    int local_54 = 0; // Counter for the number of leading zeros\n    int local_68 = 0; // Variable for storing exponent values\n    bool bVar4 = false; // Flag to indicate if a number has been parsed\n    bool bVar5 = false; // Flag to indicate if a decimal point has been encountered\n    bool bVar6 = false; // Flag to indicate if an exponent has been encountered\n    int local_6c = 1; // Sign of the exponent\n    local_8 = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Stack protection\n\n    // Check if a locale is provided\n    if (_Locale != (_locale_t)0x0) {\n        // Skip leading whitespace characters\n        for (; ((cVar8 = *str, cVar8 == ' ' || (cVar8 == '\\t')) || (cVar8 == '\\n')) || (cVar8 == '\\r')); str++) {}\n        \n        for (;;) {\n            cVar8 = *str; // Get the current character\n            pcVar18 = str + 1; // Move to the next character\n            switch(iVar15) {\n                case 0: // Initial state\n                    if ((byte)(cVar8 - 0x31U) < 9) { // Check if the character is a digit\n                        iVar15 = 3; // Move to the digit parsing state\n                        continue;\n                    }\n                    if (cVar8 == **(char **)_Locale->locinfo[1].lc_codepage) { // Check for locale-specific decimal point\n                        iVar15 = 5; // Move to the decimal point state\n                        str = pcVar18; // Update string pointer\n                    } else if (cVar8 == '+') { // Check for positive sign\n                        iVar15 = 2; // Move to the sign state\n                        str = pcVar18; // Update string pointer\n                    } else {\n                        if (cVar8 != '-') { // Check for negative sign\n                            if (cVar8 == '0') goto LAB_1001c6ad; // Handle zero case\n                            goto LAB_1001c838; // Handle invalid character case\n                        }\n                        iVar15 = 2; // Move to the sign state\n                        str = pcVar18; // Update string pointer\n                    }\n                    break;\n                case 1: // After sign state\n                    bVar4 = true; // Set flag indicating a number has started\n                    if ((byte)(cVar8 - 0x31U) < 9) goto LAB_1001c67c; // Check for digits\n                    if (cVar8 == **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_1001c6e4; // Check for decimal point\n                    if ((cVar8 == '+') || (cVar8 == '-')) goto LAB_1001c714; // Check for sign\n                    if (cVar8 == '0') goto LAB_1001c6ad; // Handle zero case\n                    break;\n                case 2: // Sign state\n                    if ((byte)(cVar8 - 0x31U) < 9) goto LAB_1001c67c; // Check for digits\n                    if (cVar8 == **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_1001c693; // Check for decimal point\n                    if (cVar8 != '0') goto LAB_1001c863; // Handle invalid character case\n                    LAB_1001c6ad: // Handle zero case\n                    iVar15 = 1; // Move to digit state\n                    str = pcVar18; // Update string pointer\n                    break;\n                case 3: // Digit parsing state\n                    while (('/' < cVar8 && (cVar8 < ':'))) { // While character is a digit\n                        if (local_50 < 0x19) { // Check buffer overflow\n                            local_50++; // Increment digit count\n                            local_24[local_50 - 1] = cVar8 - 0x30; // Store digit\n                        } else {\n                            local_54++; // Increment leading zero count\n                        }\n                        cVar8 = *pcVar18++; // Move to next character\n                    }\n                    if (cVar8 != **(char **)_Locale->locinfo[1].lc_codepage) goto LAB_1001c787; // Check for decimal point\n                    LAB_1001c6e4: // Decimal point encountered\n                    bVar4 = true; // Set flag indicating a number has started\n                    iVar15 = 4; // Move to decimal state\n                    str = pcVar18; // Update string pointer\n                    break;\n                case 4: // Decimal state\n                    bVar6 = true; // Set flag indicating decimal point encountered\n                    if (local_50 == 0) { // If no digits before decimal\n                        while (cVar8 == '0') { // Skip leading zeros\n                            local_54--; // Decrement leading zero count\n                            cVar8 = *pcVar18++; // Move to next character\n                        }\n                    }\n                    while (('/' < cVar8 && (cVar8 < ':'))) { // While character is a digit\n                        if (local_50 < 0x19) { // Check buffer overflow\n                            local_50++; // Increment digit count\n                            local_24[local_50 - 1] = cVar8 - 0x30; // Store digit\n                            local_54--; // Decrement leading zero count\n                        }\n                        cVar8 = *pcVar18++; // Move to next character\n                    }\n                    LAB_1001c787: // Check for exponent or invalid character\n                    if ((cVar8 == '+') || (cVar8 == '-')) { // Check for exponent sign\n                        bVar4 = true; // Set flag indicating a number has started\n                        iVar15 = 0xb; // Move to exponent state\n                        str = pcVar18 - 1; // Update string pointer\n                    } else {\n                        LAB_1001c6f4: // Check for exponent character\n                        bVar4 = true; // Set flag indicating a number has started\n                        if ((cVar8 < 'D') || (('E' < cVar8 && ((cVar8 < 'd' || ('e' < cVar8)))))) goto LAB_1001c838; // Check for valid exponent\n                        iVar15 = 6; // Move to exponent parsing state\n                        str = pcVar18; // Update string pointer\n                    }\n                    break;\n                case 5: // After decimal point state\n                    str = local_58; // Update string pointer\n                    if ((byte)(cVar8 - 0x30U) < 10) { // Check for digits\n                        iVar15 = 4; // Move to decimal state\n                        continue;\n                    }\n                    goto LAB_1001c863; // Handle invalid character case\n                case 6: // Exponent parsing state\n                    if (8 < (byte)(cVar8 - 0x31U)) { // Check for valid exponent digits\n                        if (cVar8 == '+') goto LAB_1001c81f; // Check for positive exponent\n                        if (cVar8 == '-') goto LAB_1001c813; // Check for negative exponent\n                        LAB_1001c806: // Handle invalid character case\n                        str = local_58; // Update string pointer\n                        if (cVar8 != '0') goto LAB_1001c863; // Handle invalid character case\n                        iVar15 = 8; // Move to exponent digit state\n                        str = pcVar18; // Update string pointer\n                        break;\n                    }\n                    break;\n                case 7: // Exponent digit state\n                    if (8 < (byte)(cVar8 - 0x31U)) goto LAB_1001c806; // Check for valid exponent digits\n                    break;\n                case 8: // Exponent digit processing state\n                    bVar5 = true; // Set flag indicating exponent digits processed\n                    while (cVar8 == '0') { // Skip leading zeros in exponent\n                        cVar8 = *pcVar18++; // Move to next character\n                    }\n                    if (8 < (byte)(cVar8 - 0x31U)) goto LAB_1001c838; // Check for valid exponent digits\n                    break;\n                case 9: // After exponent state\n                    bVar5 = true; // Set flag indicating exponent digits processed\n                    local_68 = 0; // Reset exponent value\n                    goto LAB_1001c8c5; // Move to exponent processing\n                default: // Default case for switch statement\n                    goto switchD_1001c66b_caseD_a; // Handle unexpected state\n                case 0xb: // Exponent sign state\n                    if (implicit_E != 0) { // Check if implicit exponent is set\n                        str = local_58; // Update string pointer\n                        if (cVar8 == '+') { // Check for positive exponent\n                            iVar15 = 7; // Move to exponent digit state\n                            str = pcVar18; // Update string pointer\n                        } else {\n                            if (cVar8 != '-') goto LAB_1001c863; // Handle invalid character case\n                            local_6c = -1; // Set exponent sign to negative\n                            iVar15 = 7; // Move to exponent digit state\n                            str = pcVar18; // Update string pointer\n                        }\n                        continue; // Continue parsing\n                    }\n                    iVar15 = 10; // Move to final state\n                    pcVar18 = str; // Update string pointer\n                    switchD_1001c66b_caseD_a: // Handle unexpected state\n                    str = pcVar18; // Update string pointer\n                    if (iVar15 != 10) continue; // Continue parsing if not in final state\n                    goto LAB_1001c863; // Handle invalid character case\n            }\n        }\n        piVar10 = __errno(); // Get the error number\n        *piVar10 = 0x16; // Set error code\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        uVar2 = CONCAT22(local_40._2_2_, (undefined2)local_40); // Combine results\n        goto LAB_1001cc5c; // Move to final processing\n        LAB_1001c8c5: // Exponent processing\n        if ((cVar8 < '0') || ('9' < cVar8)) goto LAB_1001c8e0; // Check for valid exponent digits\n        local_68 = local_68 * 10 + -0x30 + (int)cVar8; // Update exponent value\n        if (local_68 < 0x1451) { // Check for overflow\n            cVar8 = *pcVar18++; // Move to next character\n            goto LAB_1001c8c5; // Continue processing\n        }\n        local_68 = 0x1451; // Cap exponent value\n        LAB_1001c8e0: // Handle invalid character case\n        while (('/' < cVar8 && (cVar8 < ':'))) { // Skip characters until invalid\n            cVar8 = *pcVar18++; // Move to next character\n        }\n        LAB_1001c838: // Handle invalid character case\n        str = pcVar18 - 1; // Update string pointer\n        LAB_1001c863: // Final processing before returning\n        *p_end_ptr = str; // Set end pointer to current position\n        if (bVar4) { // If a number has been parsed\n            if (0x18 < local_50) { // Check for buffer overflow\n                local_24[local_50 - 1] = '\\0'; // Null-terminate the buffer\n                local_50 = 0x18; // Cap digit count\n            }\n            if (local_50 == 0) goto LAB_1001cc3e; // Handle case with no digits\n            while (local_24[--local_50] == '\\0') { // Trim trailing zeros\n                local_54++; // Increment leading zero count\n            }\n            ___mtold12(local_24, local_50, &local_40); // Convert string to long double\n            iVar1 = CONCAT22(local_3c._2_2_, (undefined2)local_3c); // Combine results\n            uVar2 = CONCAT22(local_40._2_2_, (undefined2)local_40); // Combine results\n            if (local_6c < 0) { // Check if exponent is negative\n                local_68 = -local_68; // Negate exponent value\n            }\n            local_58 = (char *)(local_68 + local_54); // Calculate final value\n            if (!bVar5) { // If no decimal point was encountered\n                local_58 = (char *)((int)local_58 + scale); // Adjust for scale\n            }\n            if (!bVar6) { // If no exponent was encountered\n                local_58 = (char *)((int)local_58 - decpt); // Adjust for decimal point\n            }\n            if ((int)local_58 < 0x1451) { // Check for underflow\n                if ((int)local_58 < -0x1450) goto LAB_1001cc3e; // Handle underflow\n                puVar20 = &DAT_100356d0; // Set pointer for result storage\n                if (local_58 != (char *)0x0) { // Check if value is valid\n                    if ((int)local_58 < 0) { // Check for negative value\n                        local_58 = (char *)-(int)local_58; // Negate value\n                        puVar20 = (undefined4 *)&DAT_10035830; // Set pointer for result storage\n                    }\n                    if (mult12 == 0) { // Check if multiplication factor is zero\n                        local_40._0_2_ = 0; // Reset result\n                    }\n                    iVar15 = uStack_4a; // Store state\n                    uVar13 = uStack_2e; // Store intermediate result\n                    iVar1 = uStack_2a; // Store intermediate result\n                    uVar2 = CONCAT22(local_40._2_2_, (undefined2)local_40); // Combine results\n                    iVar12 = local_3c; // Store intermediate result\n                    joined_r0x1001c96b: // Continue processing\n                    if (local_58 != (char *)0x0) { // Check if value is valid\n                        uVar16 = (int)local_58 >> 3; // Calculate index for result storage\n                        puVar20 = puVar20 + 0x15; // Adjust pointer for result storage\n                        uVar11 = (uint)local_58 & 7; // Calculate remainder\n                        local_58 = (char *)uVar16; // Update value\n                        if (uVar11 != 0) { // If there is a remainder\n                            piVar10 = puVar20 + uVar11 * 3; // Get pointer for result storage\n                            if (0x7fff < *(ushort *)piVar10) { // Check for overflow\n                                local_4c = (undefined2)*piVar10; // Store result\n                                uStack_4a._0_2_ = (undefined2)((uint)*piVar10 >> 0x10); // Store result\n                                uStack_4a._2_2_ = (undefined2)piVar10[1]; // Store result\n                                uStack_46 = (undefined2)((uint)piVar10[1] >> 0x10); // Store result\n                                local_44 = piVar10[2]; // Store result\n                                iVar15 = CONCAT22(uStack_4a._2_2_, (undefined2)uStack_4a) + -1; // Update result\n                                uStack_4a._0_2_ = (undefined2)iVar15; // Store result\n                                uStack_4a._2_2_ = (undefined2)((uint)iVar15 >> 0x10); // Store result\n                                piVar10 = (int *)&local_4c; // Update pointer for result storage\n                            }\n                            local_54 = 0; // Reset leading zero count\n                            local_30 = 0; // Reset byte value\n                            uStack_2f = 0; // Reset undefined value\n                            uStack_2e._0_2_ = 0; // Reset result\n                            uStack_2e._2_2_ = 0; // Reset result\n                            uVar16 = 0; // Reset value\n                            uStack_2a._0_2_ = 0; // Reset result\n                            uStack_2a._2_2_ = 0; // Reset result\n                            iVar3 = 0; // Reset index\n                            uStack_26 = 0; // Reset result\n                            uVar14 = local_36 & 0x7fff; // Extract value\n                            uVar17 = *(ushort *)((int)piVar10 + 10) & 0x7fff; // Extract value\n                            uVar9 = (*(ushort *)((int)piVar10 + 10) ^ local_36) & 0x8000; // Extract value\n                            uVar23 = uVar17 + uVar14; // Combine values\n                            uVar13 = 0; // Reset value\n                            iVar1 = 0; // Reset index\n                            if (((uVar14 < 0x7fff) && (uVar13 = 0, iVar1 = 0, uVar17 < 0x7fff)) &&\n                            (uVar13 = uVar16, iVar1 = iVar3, uVar23 < 0xbffe)) {\n                                if (0x3fbf < uVar23) { // Check for overflow\n                                    if (((uVar14 == 0) &&\n                                    (uVar23 = uVar23 + 1, (CONCAT22(local_36, uStack_38) & 0x7fffffff) == 0)) &&\n                                    ((iVar12 == 0 && (uVar2 == 0)))) {\n                                        local_36 = 0; // Reset result\n                                    } else if (((uVar17 == 0) && (uVar23 = uVar23 + 1, (piVar10[2] & 0x7fffffffU) == 0))\n                                    && ((piVar10[1] == 0 && (*piVar10 == 0)))) {\n                                        uStack_38 = 0; // Reset result\n                                        local_36 = 0; // Reset result\n                                        local_3c._0_2_ = 0; // Reset result\n                                        local_3c._2_2_ = 0; // Reset result\n                                        local_40._0_2_ = 0; // Reset result\n                                        local_40._2_2_ = 0; // Reset result\n                                        uVar2 = 0; // Reset result\n                                        iVar12 = 0; // Reset index\n                                    } else {\n                                        local_6c = 0; // Reset exponent sign\n                                        psVar21 = (short *)((int)&uStack_2e + 2); // Pointer for result storage\n                                        local_5c = 5; // Set counter\n                                        do {\n                                            local_68 = local_5c; // Store counter\n                                            if (0 < local_5c) { // Check if counter is positive\n                                                local_60 = (ushort *)((int)&local_40 + local_6c * 2); // Pointer for result storage\n                                                local_64 = piVar10 + 2; // Pointer for result storage\n                                                do {\n                                                    bVar4 = false; // Reset flag\n                                                    uVar13 = *(uint *)(psVar21 + -2) +\n                                                    (uint)*(ushort *)local_64 * (uint)*local_60; // Calculate result\n                                                    if ((uVar13 < *(uint *)(psVar21 + -2)) ||\n                                                    (uVar13 < (uint)*(ushort *)local_64 * (uint)*local_60)) {\n                                                        bVar4 = true; // Set overflow flag\n                                                    }\n                                                    *(uint *)(psVar21 + -2) = uVar13; // Store result\n                                                    if (bVar4) { // Check for overflow\n                                                        *psVar21 += 1; // Increment counter\n                                                    }\n                                                    local_60 = local_60 + 1; // Move to next result\n                                                    local_64 = (int *)((int)local_64 + -2); // Move to next result\n                                                    local_68--; // Decrement counter\n                                                } while (0 < local_68); // Continue while counter is positive\n                                            }\n                                            psVar21++; // Move to next result\n                                            local_6c++; // Increment index\n                                            local_5c--; // Decrement counter\n                                        } while (0 < local_5c); // Continue while counter is positive\n                                        uVar23 = uVar23 + 0xc002; // Adjust result\n                                        if ((short)uVar23 < 1) { // Check for underflow\n                                            LAB_1001cb21: // Handle underflow case\n                                            uVar23 = uVar23 - 1; // Decrement result\n                                            if ((short)uVar23 < 0) { // Check for negative result\n                                                uVar13 = (uint)(ushort)-uVar23; // Convert to positive\n                                                uVar23 = 0; // Reset result\n                                                do {\n                                                    if ((local_30 & 1) != 0) { // Check for leading zeros\n                                                        local_54++; // Increment leading zero count\n                                                    }\n                                                    iVar12 = CONCAT22(uStack_26, uStack_2a._2_2_); // Combine results\n                                                    uVar2 = CONCAT22((ushort)uStack_2a, uStack_2e._2_2_); // Combine results\n                                                    iVar1 = CONCAT22((ushort)uStack_2a, uStack_2e._2_2_); // Combine results\n                                                    uStack_2a._2_2_ = (ushort)(CONCAT22(uStack_26, uStack_2a._2_2_) >> 1); // Shift result\n                                                    uStack_26 = uStack_26 >> 1; // Shift result\n                                                    uStack_2a._0_2_ =\n                                                    (ushort)uStack_2a >> 1 | (ushort)((uint)(iVar12 << 0x1f) >> 0x10); // Shift result\n                                                    uVar16 = CONCAT22((ushort)uStack_2e, CONCAT11(uStack_2f, local_30)) >> 1; // Shift result\n                                                    uStack_2e._0_2_ =\n                                                    (ushort)uStack_2e >> 1 | (ushort)((uint)(iVar1 << 0x1f) >> 0x10); // Shift result\n                                                    uVar13 = uVar13 - 1; // Decrement counter\n                                                    uStack_2e._2_2_ = (ushort)(uVar2 >> 1); // Shift result\n                                                    local_30 = (byte)uVar16; // Store result\n                                                    uStack_2f = (undefined)(uVar16 >> 8); // Store result\n                                                } while (uVar13 != 0); // Continue while counter is positive\n                                                if (local_54 != 0) { // Check for leading zeros\n                                                    local_30 |= 1; // Set flag for leading zeros\n                                                }\n                                            }\n                                        } else {\n                                            do {\n                                                uVar14 = (ushort)uStack_2e; // Extract value\n                                                if ((uStack_26 & 0x8000) != 0) break; // Check for overflow\n                                                iVar1 = CONCAT22((ushort)uStack_2e, CONCAT11(uStack_2f, local_30)) << 1; // Shift result\n                                                local_30 = (byte)iVar1; // Store result\n                                                uStack_2f = (undefined)((uint)iVar1 >> 8); // Store result\n                                                uStack_2e._0_2_ = (ushort)((uint)iVar1 >> 0x10); // Store result\n                                                iVar1 = CONCAT22((ushort)uStack_2a, uStack_2e._2_2_) * 2; // Shift result\n                                                uStack_2e._2_2_ = (ushort)iVar1 | uVar14 >> 0xf; // Store result\n                                                iVar12 = CONCAT22(uStack_26, uStack_2a._2_2_) * 2; // Shift result\n                                                uStack_2a._2_2_ = (ushort)iVar12 | (ushort)uStack_2a >> 0xf; // Store result\n                                                uVar23 = uVar23 - 1; // Decrement counter\n                                                uStack_2a._0_2_ = (ushort)((uint)iVar1 >> 0x10); // Store result\n                                                uStack_26 = (ushort)((uint)iVar12 >> 0x10); // Store result\n                                            } while (0 < (short)uVar23); // Continue while counter is positive\n                                            if ((short)uVar23 < 1) goto LAB_1001cb21; // Handle underflow case\n                                        }\n                                        if ((0x8000 < CONCAT11(uStack_2f, local_30)) ||\n                                        (iVar1 = CONCAT22(uStack_2a._2_2_, (ushort)uStack_2a),\n                                        uVar13 = CONCAT22(uStack_2e._2_2_, (ushort)uStack_2e),\n                                        (CONCAT22((ushort)uStack_2e, CONCAT11(uStack_2f, local_30)) & 0x1ffff) == 0x18000\n                                        )) {\n                                            if (CONCAT22(uStack_2e._2_2_, (ushort)uStack_2e) == -1) { // Check for overflow\n                                                uStack_2e._0_2_ = 0; // Reset result\n                                                uStack_2e._2_2_ = 0; // Reset result\n                                                uVar13 = 0; // Reset result\n                                                if (CONCAT22(uStack_2a._2_2_, (ushort)uStack_2a) == -1) { // Check for overflow\n                                                    uStack_2a._0_2_ = 0; // Reset result\n                                                    uStack_2a._2_2_ = 0; // Reset result\n                                                    if (uStack_26 == 0xffff) { // Check for overflow\n                                                        uStack_26 = 0x8000; // Set result\n                                                        uVar23 = uVar23 + 1; // Increment counter\n                                                        iVar1 = 0; // Reset index\n                                                        uVar13 = 0; // Reset result\n                                                    } else {\n                                                        uStack_26++; // Increment result\n                                                        iVar1 = 0; // Reset index\n                                                        uVar13 = 0; // Reset result\n                                                    }\n                                                } else {\n                                                    iVar1 = CONCAT22(uStack_2a._2_2_, (ushort)uStack_2a) + 1; // Increment result\n                                                    uStack_2a._0_2_ = (ushort)iVar1; // Store result\n                                                    uStack_2a._2_2_ = (ushort)((uint)iVar1 >> 0x10); // Store result\n                                                }\n                                            } else {\n                                                uVar13 = CONCAT22(uStack_2a._2_2_, (ushort)uStack_2a) + 1; // Increment result\n                                                uStack_2e._0_2_ = (ushort)uVar13; // Store result\n                                                uStack_2e._2_2_ = (ushort)(uVar13 >> 0x10); // Store result\n                                                iVar1 = CONCAT22(uStack_2a._2_2_, (ushort)uStack_2a); // Combine results\n                                            }\n                                        } else {\n                                            uVar13 = CONCAT22(uStack_2e._2_2_, (ushort)uStack_2e) + 1; // Increment result\n                                            uStack_2e._0_2_ = (ushort)uVar13; // Store result\n                                            uStack_2e._2_2_ = (ushort)(uVar13 >> 0x10); // Store result\n                                            iVar1 = CONCAT22(uStack_2a._2_2_, (ushort)uStack_2a); // Combine results\n                                        }\n                                        uStack_2e._2_2_ = (ushort)(uVar13 >> 0x10); // Store result\n                                        uStack_2e._0_2_ = (ushort)uVar13; // Store result\n                                        uStack_2a._2_2_ = (ushort)((uint)iVar1 >> 0x10); // Store result\n                                        uStack_2a._0_2_ = (ushort)iVar1; // Store result\n                                        if (0x7ffe < uVar23) goto LAB_1001cbe1; // Check for overflow\n                                        local_40._0_2_ = (ushort)uStack_2e; // Store result\n                                        local_40._2_2_ = uStack_2e._2_2_; // Store result\n                                        local_3c._0_2_ = (ushort)uStack_2a; // Store result\n                                        local_3c._2_2_ = uStack_2a._2_2_; // Store result\n                                        uStack_38 = uStack_26; // Store result\n                                        local_36 = uVar23 | uVar9; // Store result\n                                        uVar2 = uVar13; // Store result\n                                        iVar12 = iVar1; // Store result\n                                    }\n                                    goto joined_r0x1001c96b; // Continue processing\n                                }\n                                iVar12 = 0; // Reset index\n                                local_3c._0_2_ = 0; // Reset result\n                                local_3c._2_2_ = 0; // Reset result\n                                local_40._0_2_ = 0; // Reset result\n                                local_40._2_2_ = 0; // Reset result\n                            } else {\n                                LAB_1001cbe1: // Handle overflow case\n                                local_3c._0_2_ = 0; // Reset result\n                                local_3c._2_2_ = 0; // Reset result\n                                iVar12 = (-(uint)(uVar9 != 0) & 0x80000000) + 0x7fff8000; // Set result\n                                local_40._0_2_ = 0; // Reset result\n                            }\n                            uStack_38 = (ushort)iVar12; // Store result\n                            local_36 = (ushort)((uint)iVar12 >> 0x10); // Store result\n                            uVar2 = 0; // Reset result\n                            iVar12 = 0; // Reset index\n                        }\n                        goto joined_r0x1001c96b; // Continue processing\n                    }\n                }\n            }\n        }\n    }\n    local_3c._2_2_ = (undefined2)((uint)iVar12 >> 0x10); // Store result\n    local_3c._0_2_ = (undefined2)iVar12; // Store result\n    local_40._2_2_ = (undefined2)(uVar2 >> 0x10); // Store result\n    local_40._0_2_ = (undefined2)uVar2; // Store result\n    uVar22 = CONCAT22((undefined2)local_3c, local_40._2_2_); // Combine results\n    uVar19 = CONCAT22(uStack_38, local_3c._2_2_); // Combine results\n    uVar23 = local_36; // Store result\n    uStack_4a = iVar15; // Store state\n    uStack_2e = uVar13; // Store intermediate result\n    uStack_2a = iVar1; // Store intermediate result\n    local_3c = iVar12; // Store intermediate result\n}\n"}
{"Function Name": "_isleadbyte", "Address": "1001d868", "Source Code": "\n// Function declaration for _isleadbyte, taking an integer _C as input\nint __cdecl _isleadbyte(int characterCode)\n{\n    // Call to __isleadbyte_l function with _C and a null locale pointer\n    return __isleadbyte_l(characterCode, (_locale_t)0x0);\n}\n"}
{"Function Name": "__setenvp", "Address": "1001d876", "Source Code": "\nint __cdecl __setenvp(void) // Function to set environment variables\n{\n    size_t lengthOfString; // Variable to hold the length of strings\n    char *allocatedMemoryPointer; // Pointer for dynamically allocated memory\n    errno_t errorCode; // Variable to hold error codes\n    char *envVarStringPointer; // Pointer to traverse the environment variable string\n    int envVarCount = 0; // Counter for the number of environment variables\n\n    if (DAT_100377d0 == 0) { // Check if initialization is needed\n        ___initmbctable(); // Initialize multibyte character table\n    }\n\n    envVarStringPointer = envVarString; // Set pointer to the environment variable string\n    if (envVarStringPointer != (char *)0x0) { // Check if the environment variable string is not null\n        for (; *envVarStringPointer != '\\0'; envVarStringPointer += lengthOfString + 1) { // Loop through the environment variable string\n            if (*envVarStringPointer != '=') { // Check if the current character is not '='\n                envVarCount++; // Increment the counter for valid environment variables\n            }\n            lengthOfString = _strlen(envVarStringPointer); // Get the length of the current environment variable\n        }\n\n        char **envVarPointerArray = (char **)__calloc_crt(envVarCount + 1, 4); // Allocate memory for environment variable pointers\n        allocatedMemoryPointerArray = envVarPointerArray; // Store the pointer to the allocated memory\n        if (envVarPointerArray != (char **)0x0) { // Check if memory allocation was successful\n            do {\n                if (*envVarStringPointer == '\\0') { // Check if the end of the string is reached\n                    _free(envVarString); // Free the original environment variable string\n                    envVarString = (char *)0x0; // Set the pointer to null\n                    *envVarPointerArray = (char *)0x0; // Null-terminate the array of pointers\n                    operationSuccessFlag = 1; // Set a flag indicating successful operation\n                    return 0; // Return success\n                }\n                lengthOfString = _strlen(envVarStringPointer) + 1; // Get the length of the current variable including null terminator\n                if (*envVarStringPointer != '=') { // Check if the current character is not '='\n                    allocatedMemoryPointer = (char *)__calloc_crt(lengthOfString, 1); // Allocate memory for the current environment variable\n                    *envVarPointerArray = allocatedMemoryPointer; // Store the pointer to the allocated memory\n                    if (allocatedMemoryPointer == (char *)0x0) { // Check if memory allocation was successful\n                        _free(allocatedMemoryPointerArray); // Free previously allocated memory\n                        allocatedMemoryPointerArray = (char **)0x0; // Set the pointer to null\n                        return -1; // Return error\n                    }\n                    errorCode = _strcpy_s(allocatedMemoryPointer, lengthOfString, envVarStringPointer); // Copy the current environment variable to allocated memory\n                    if (errorCode != 0) { // Check for errors during string copy\n                        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n                    }\n                    envVarPointerArray++; // Move to the next pointer in the array\n                }\n                envVarStringPointer += lengthOfString; // Move to the next environment variable in the string\n            } while (true); // Continue until the end of the string is reached\n        }\n    }\n    return -1; // Return error if the environment variable string is null\n}\n"}
{"Function Name": "__setargv", "Address": "1001dae9", "Source Code": "\nint __cdecl __setargv(void) // Function to set the argument vector\n{\n    uint numParsedArgs; // Variable to hold the number of parsed arguments\n    byte **parsedArgsPtr; // Pointer to hold the parsed command line arguments\n    uint argListSize; // Variable to store the size of the argument list\n    byte *cmdLineStr; // Pointer to the command line string\n\n    if (isMbctableInitialized == 0) { // Check if the multi-byte character table is initialized\n        ___initmbctable(); // Initialize the multi-byte character table\n    }\n    globalVarReset = 0; // Reset a global variable to 0\n    GetModuleFileNameA((HMODULE)0x0, &moduleFileName, 0x104); // Retrieve the module file name and store it\n\n    // Determine the command line to parse: use the stored command line or the module file name\n    cmdLineStr = (storedCmdLine == (byte *)0x0 || *storedCmdLine == 0) ? &moduleFileName : storedCmdLine;\n\n    // Parse the command line and store the number of arguments in local_c\n    _parse_cmdline(0, cmdLineStr, (byte **)0x0, (byte *)0x0, (int *)&argListSize);\n    numParsedArgs = argListSize; // Store the number of parsed arguments\n\n    // Check if the number of arguments is within limits and local_10 is valid\n    if (argListSize < 0x3fffffff && argArraySize != 0xffffffff) {\n        uint neededSize = argListSize * 4 + argArraySize; // Calculate the size needed for the argument array\n        // Check if local_10 is less than or equal to _Size and allocate memory for the arguments\n        if (argArraySize <= neededSize && (parsedArgsPtr = (byte **)__malloc_crt(neededSize), parsedArgsPtr != (byte **)0x0)) {\n            // Parse the command line again with allocated memory for arguments\n            _parse_cmdline(neededSize, cmdLineStr, parsedArgsPtr, (byte *)(parsedArgsPtr + numParsedArgs), (int *)&argListSize);\n            numArgsMinusOne = argListSize - 1; // Store the number of arguments minus one\n            argsPointer = parsedArgsPtr; // Store the pointer to the arguments\n            return 0; // Return success\n        }\n    }\n    return -1; // Return failure if conditions are not met\n}\n"}
{"Function Name": "___ansicp", "Address": "1001df44", "Source Code": "\nvoid __cdecl ___ansicp(LCID locale_id)\n{\n    CHAR locale_buffer[6]; // Buffer to store locale information\n    uint security_cookie = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Calculate a security cookie value\n    \n    // Retrieve locale information and store it in local_10\n    if (GetLocaleInfoA(locale_id, 0x1004, locale_buffer, 6) != 0) {\n        _atol(locale_buffer); // Convert the retrieved string to a long integer\n    }\n    \n    // Perform a security check using the calculated cookie value\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1001e460", "Address": "1001e460", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1001e460\n{\n    callAnotherFunction(4); // Call the function FUN_10016973 with an argument of 4\n}\n"}
{"Function Name": "FUN_1001e5c6", "Address": "1001e5c6", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1001e5c6\n{\n    callAnotherFunction(4); // Call the function FUN_10016973 with an argument of 4\n}\n"}
{"Function Name": "__get_lc_time", "Address": "1001e6e4", "Source Code": "\nuint __get_lc_time(void) // Function to retrieve locale time information\n{\n    LPCWSTR localeWideCharPtr; // Pointer to wide character string for locale information\n    LPCWSTR localeWideCharPtr2; // Pointer to wide character string for another locale information\n    uint localeInfoResult; // Variable to store the result of locale information retrieval\n    void *unusedThreadDataPtr; // Unused pointer, possibly for thread-specific data\n    localeinfo_struct localeInfoStruct; // Structure to hold locale information\n\n    // Retrieve locale information based on offsets from in_EAX\n    localeWideCharPtr2 = (LPCWSTR)(uint)*(ushort *)(in_EAX + 0x42);\n    localeWideCharPtr = (LPCWSTR)(uint)*(ushort *)(in_EAX + 0x44);\n\n    // Check if the pointer is null, return error code if so\n    if (unusedThreadDataPtr == (void *)0x0) {\n        return 0xffffffff; // Return error code\n    }\n\n    localeInfoStruct.mbcinfo = (pthreadmbcinfo)0x0; // Initialize mbcinfo to null\n\n    // Loop to retrieve locale information for specific indices (0x31 to 0x49)\n    for (int index = 0x31; index <= 0x49; index++) {\n        localeInfoResult |= ___getlocaleinfo(&localeInfoStruct, 1, localeWideCharPtr2, index, (void *)((int)unusedThreadDataPtr + (index - 0x31) * 4));\n    }\n\n    // Loop to retrieve locale information for specific indices (0x28 to 0x29)\n    for (int index = 0x28; index <= 0x29; index++) {\n        localeInfoResult |= ___getlocaleinfo(&localeInfoStruct, 1, localeWideCharPtr2, index, (void *)((int)unusedThreadDataPtr + (index - 0x28) * 4 + 0x98));\n    }\n\n    // Loop to retrieve locale information for specific indices (0x1f to 0x20)\n    for (int index = 0x1f; index <= 0x20; index++) {\n        localeInfoResult |= ___getlocaleinfo(&localeInfoStruct, 1, localeWideCharPtr, index, (void *)((int)unusedThreadDataPtr + (index - 0x1f) * 4 + 0xa0));\n    }\n\n    // Retrieve additional locale information for specific indices\n    localeInfoResult |= ___getlocaleinfo(&localeInfoStruct, 1, localeWideCharPtr, 0x1003, (void *)((int)unusedThreadDataPtr + 0xa8));\n    localeInfoResult |= ___getlocaleinfo(&localeInfoStruct, 0, localeWideCharPtr, 0x1009, (void *)((int)unusedThreadDataPtr + 0xb0));\n    \n    // Store the locale information pointer in the specified location\n    *(LPCWSTR *)((int)unusedThreadDataPtr + 0xac) = localeWideCharPtr;\n\n    return localeInfoResult; // Return the result of the locale information retrieval\n}\n"}
{"Function Name": "___free_lc_time", "Address": "1001eafd", "Source Code": "\nvoid __cdecl ___free_lc_time(void **pointer_array)\n{\n    // Check if the input parameter is not a null pointer\n    if (pointer_array != (void **)0x0) {\n        // Iterate through the array of pointers from index 0 to 42 (0x2a in hexadecimal)\n        for (int index = 0; index <= 0x2a; index++) {\n            // Free the memory allocated for each pointer in the array\n            _free(pointer_array[index]);\n        }\n    }\n}\n"}
{"Function Name": "___init_numeric", "Address": "1001ed40", "Source Code": "\nint __cdecl ___init_numeric(threadlocinfo *locale_info)\n{\n    threadlocinfo *thread_info = locale_info; // Pointer to the thread-local information\n    localeinfo_struct locale_info_struct; // Structure to hold locale information\n    uint *locale_codepage_ptr; // Pointer for locale codepage\n    uint locale_info_return; // Variable to hold locale info return value\n    undefined4 *temp_storage_ptr; // Pointer for temporary storage\n    undefined4 *null_pointer = (undefined4 *)0x0; // Pointer initialized to null\n    LONG interlocked_var; // Variable for interlocked operations\n    int loop_counter; // Loop counter\n\n    locale_info_struct.locinfo = locale_info; // Set the locale information structure\n    locale_info_struct.mbcinfo = (pthreadmbcinfo)0x0; // Initialize multi-byte character info to null\n\n    // Check if the reference counts for the locale category are zero\n    if ((thread_info->lc_category[0].wrefcount == (int *)0x0) && (thread_info->lc_category[0].refcount == (int *)0x0)) {\n        // Decrement the reference count for locale_name[5] if it's not null\n        if ((LONG *)thread_info->locale_name[5] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)thread_info->locale_name[5]);\n        }\n        // Decrement the reference count for locale_name[4] and free if it reaches zero\n        if (((LONG *)thread_info->locale_name[4] != (LONG *)0x0) && (interlocked_var = InterlockedDecrement((LONG *)thread_info->locale_name[4]), interlocked_var == 0)) {\n            _free(thread_info->locale_name[4]); // Free locale_name[4]\n            _free((void *)thread_info[1].lc_codepage); // Free the codepage\n        }\n        thread_info->locale_name[5] = (wchar_t *)null_pointer; // Set locale_name[5] to null\n        thread_info[1].lc_codepage = (uint)locale_info; // Set the codepage to the provided locale info\n        return 0; // Return success\n    } else {\n        // Allocate memory for a new threadlocinfo structure\n        threadlocinfo *new_thread_info = (threadlocinfo *)__calloc_crt(1, 0x30);\n        if (new_thread_info != (threadlocinfo *)0x0) {\n            void **codepage_ptr = (void **)locale_info[1].lc_codepage; // Pointer to the codepage\n            threadlocinfo *new_thread_info_ptr = new_thread_info; // Pointer to the new threadlocinfo\n\n            // Copy refcount values from the original locale info\n            for (loop_counter = 0xc; loop_counter != 0; loop_counter--) {\n                new_thread_info_ptr->refcount = (int)*codepage_ptr; // Copy refcount\n                codepage_ptr++; // Move to the next codepage\n                new_thread_info_ptr = (threadlocinfo *)&new_thread_info_ptr->lc_codepage; // Move to the next threadlocinfo\n            }\n\n            // Allocate memory for temporary storage\n            temp_storage_ptr = (undefined4 *)__malloc_crt(4);\n            if (temp_storage_ptr != (undefined4 *)0x0) {\n                *temp_storage_ptr = 0; // Initialize temporary storage\n                // Check if the reference count for the locale category is zero\n                if (thread_info->lc_category[0].wrefcount == (int *)0x0) {\n                    new_thread_info->refcount = (int)PTR_DAT_10035640; // Set refcount from predefined data\n                    new_thread_info->lc_codepage = (uint)PTR_DAT_10035644; // Set codepage from predefined data\n                    new_thread_info->lc_collate_cp = (uint)PTR_DAT_10035648; // Set collate codepage from predefined data\n                } else {\n                    // Allocate memory for local_8\n                    null_pointer = (undefined4 *)__malloc_crt(4);\n                    if (null_pointer == (undefined4 *)0x0) {\n                        _free(new_thread_info); // Free allocated memory if allocation fails\n                        _free(temp_storage_ptr); // Free temporary storage\n                        return 1; // Return failure\n                    }\n                    *null_pointer = 0; // Initialize local_8\n                    LPCWSTR locale_name = (LPCWSTR)(uint)*(ushort *)((int)&locale_info->lc_category[2].wrefcount + 2); // Get locale name\n                    locale_info_return = ___getlocaleinfo(&locale_info_struct, 1, locale_name, 0xe, new_thread_info); // Get locale info\n                    uint locale_info_result = ___getlocaleinfo(&locale_info_struct, 1, locale_name, 0xf, &new_thread_info->lc_codepage); // Get codepage info\n                    locale_info_return |= locale_info_result; // Combine results\n                    locale_codepage_ptr = &new_thread_info->lc_collate_cp; // Pointer to collate codepage\n                    locale_info_result = ___getlocaleinfo(&locale_info_struct, 1, locale_name, 0x10, locale_codepage_ptr); // Get collate codepage info\n                    // Check if any locale info retrieval failed\n                    if ((locale_info_result | locale_info_return) != 0) {\n                        ___free_lconv_num((void **)new_thread_info); // Free allocated locale number\n                        _free(new_thread_info); // Free allocated memory\n                        _free(temp_storage_ptr); // Free temporary storage\n                        return -1; // Return failure\n                    }\n                    char *collate_codepage_ptr = (char *)*locale_codepage_ptr; // Pointer to collate codepage string\n                    // Process the collate codepage string\n                    while (*collate_codepage_ptr != '\\0') {\n                        char current_character = *collate_codepage_ptr; // Get current character\n                        // Check if character is a digit\n                        if ((current_character < '0') || ('9' < current_character)) {\n                            if (current_character == ';') { // If character is a semicolon\n                                do {\n                                    collate_codepage_ptr++; // Skip to the next character\n                                } while (*collate_codepage_ptr != '\\0'); // Continue until end of string\n                            }\n                        } else {\n                            *collate_codepage_ptr = current_character - 0x30; // Convert character to numeric value\n                        }\n                        collate_codepage_ptr++; // Move to the next character\n                    }\n                }\n                *temp_storage_ptr = 1; // Set temporary storage to indicate success\n                locale_info = new_thread_info; // Update the provided locale info pointer\n                if (null_pointer != (undefined4 *)0x0) {\n                    *null_pointer = 1; // Set local_8 to indicate success\n                }\n                // Decrement reference count for locale_name[5] if it's not null\n                if ((LONG *)thread_info->locale_name[5] != (LONG *)0x0) {\n                    InterlockedDecrement((LONG *)thread_info->locale_name[5]);\n                }\n                // Decrement reference count for locale_name[4] and free if it reaches zero\n                if (((LONG *)thread_info->locale_name[4] != (LONG *)0x0) && (interlocked_var = InterlockedDecrement((LONG *)thread_info->locale_name[4]), interlocked_var == 0)) {\n                    _free(thread_info->locale_name[4]); // Free locale_name[4]\n                    _free((void *)thread_info[1].lc_codepage); // Free the codepage\n                }\n                thread_info->locale_name[5] = (wchar_t *)null_pointer; // Set locale_name[5] to local_8\n                thread_info[1].lc_codepage = (uint)locale_info; // Set the codepage to the updated locale info\n                return 0; // Return success\n            }\n            _free(new_thread_info); // Free allocated memory if local_c allocation fails\n        }\n        return 1; // Return failure if memory allocation fails\n    }\n}\n"}
{"Function Name": "_ProcessCodePage", "Address": "1001f3b9", "Source Code": "\nvoid __fastcall _ProcessCodePage(CHAR *inputString)\n{\n    int comparisonResult; // Variable to store the result of string comparisons\n    LCTYPE localeType; // Variable to hold the locale type\n    CHAR localeBuffer[8]; // Buffer to store locale information\n    uint stackCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Security cookie for stack protection\n\n    // Check if the input parameter is NULL or an empty string\n    if ((inputString == (CHAR *)0x0) || (*inputString == '\\0')) {\n        localeType = 0x1004; // Set locale type to default if input is invalid\n        goto get_locale_info; // Jump to locale information retrieval\n    } else {\n        // Compare input with \"ACP\"\n        comparisonResult = _strcmp(inputString, \"ACP\");\n        if (comparisonResult == 0) {\n            localeType = 0x1004; // Set locale type for ACP\n            goto get_locale_info; // Jump to locale information retrieval\n        }\n        // Compare input with \"OCP\"\n        comparisonResult = _strcmp(inputString, \"OCP\");\n        if (comparisonResult == 0) {\n            localeType = 0xb; // Set locale type for OCP\n            goto get_locale_info; // Jump to locale information retrieval\n        }\n    }\n    _atol(inputString); // Convert the input string to a long integer (not used further)\n\nget_locale_info:\n    // Retrieve locale information based on the LCID and LCType\n    comparisonResult = GetLocaleInfoA(*(LCID *)(unaff_EDI + 0x1c), localeType, localeBuffer, 8);\n    if (comparisonResult != 0) {\n        inputString = localeBuffer; // Update param_1 with the retrieved locale information if successful\n    }\n    // Perform security check on the stack cookie\n    ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc);\n    return; // Exit the function\n}\n"}
{"Function Name": "_TestDefaultCountry", "Address": "1001f430", "Source Code": "\nundefined4 __cdecl _TestDefaultCountry(short country_code)\n{\n    // Loop through the range of 0 to 20, incrementing by 2\n    for (uint index = 0; index < 0x14; index += 2) {\n        // Check if the input parameter matches the value at the calculated memory address\n        if (country_code == *(short *)((int)&DAT_1002ef38 + index)) {\n            // Return 0 if a match is found\n            return 0;\n        }\n    }\n    // Return 1 if no match is found after the loop\n    return 1;\n}\n"}
{"Function Name": "_LcidFromHexString", "Address": "1001f44e", "Source Code": "\nint __fastcall _LcidFromHexString(undefined4 hexString, char *inputString)\n{\n    int result = 0; // Initialize the result variable to 0\n    char currentChar; // Declare a character variable to hold the current character\n\n    // Loop through each character in the input string until the null terminator is reached\n    while ((currentChar = *inputString) != '\\0') {\n        inputString++; // Move to the next character in the string\n\n        // Check if the character is a valid hexadecimal digit (0-9, A-F)\n        if ((byte)(currentChar + 0x9fU) < 6) {\n            currentChar -= 0x27; // Convert 'A'-'F' to their numeric values (10-15)\n        } else if ((byte)(currentChar + 0xbfU) < 6) {\n            currentChar -= 7; // Convert 'a'-'f' to their numeric values (10-15)\n        }\n\n        // Update the result by shifting left and adding the new digit value\n        result = result * 0x10 + (int)currentChar - 0x30; // Convert character to integer and accumulate\n    }\n    return result; // Return the final integer value\n}\n"}
{"Function Name": "_GetPrimaryLen", "Address": "1001f480", "Source Code": "\nint __fastcall _GetPrimaryLen(undefined4 input_param, char *char_pointer)\n{\n    int length_counter = 0; // Initialize length counter to 0\n    char current_char; // Variable to hold the current character\n    while (true) { // Start an infinite loop\n        current_char = *char_pointer++; // Get the current character and move to the next one\n        // Check if the character is not an uppercase letter (A-Z) or not a valid character\n        if (((current_char < 'A') || ('Z' < current_char)) && (0x19 < (byte)(current_char + 0x9fU))) break; // Exit loop if condition is met\n        length_counter++; // Increment the length counter\n    }\n    return length_counter; // Return the length of the primary characters\n}\n"}
{"Function Name": "_CountryEnumProc@4", "Address": "1001f49b", "Source Code": "\nvoid _CountryEnumProc_4(char *localeString)\n{\n    // Declare a pointer to thread-local data structure\n    _ptiddata threadLocalData;\n    \n    // Declare a variable to hold the locale identifier\n    LCID localeId;\n    \n    // Declare an integer variable for locale information retrieval status\n    int localeInfoStatus;\n    \n    // Buffer to hold the locale information string\n    CHAR localeInfoBuffer[120];\n    \n    // Initialize a local variable with a security cookie value\n    uint securityCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc;\n\n    // Get the pointer to the thread-local data\n    threadLocalData = __getptd();\n    \n    // Convert the hex string parameter to a locale identifier\n    localeId = _LcidFromHexString(0, localeString);\n    \n    // Retrieve locale information based on the locale identifier\n    localeInfoStatus = GetLocaleInfoA(localeId, (-(uint)((threadLocalData->_setloc_data).bAbbrevCountry != 0) & 0xfffff005) + 0x1002, localeInfoBuffer, 0x78);\n\n    // Check if the locale information retrieval was successful\n    if (localeInfoStatus == 0) {\n        // If unsuccessful, reset the locale state\n        (threadLocalData->_setloc_data).iLocState = 0;\n    } else {\n        // Compare the retrieved country string with the stored country string\n        localeInfoStatus = __stricmp((char *)(threadLocalData->_setloc_data).pchCountry, localeInfoBuffer);\n        \n        // Check if the country strings match and if the locale is a default country\n        if (localeInfoStatus == 0 && _TestDefaultCountry((short)localeId) != 0) {\n            // Update the locale state to indicate a match\n            (threadLocalData->_setloc_data).iLocState |= 4;\n            \n            // Cache the locale identifier in the thread-local data\n            *(LCID *)(threadLocalData->_setloc_data)._cachein = localeId;\n            (threadLocalData->_setloc_data)._cachecp = localeId;\n        }\n    }\n    \n    // Perform a security check using the local cookie value\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    \n    // Return from the function\n    return;\n}\n"}
{"Function Name": "_TestDefaultLanguage", "Address": "1001f531", "Source Code": "\nvoid __thiscall _TestDefaultLanguage(void *this, uint param_1, int param_2)\n{\n    int localeInfoResult; // Variable to store the result of GetLocaleInfoA\n    uint lcidResult; // Variable to store the result of _LcidFromHexString\n    CHAR localeBuffer[120]; // Buffer to hold locale information\n    uint stackProtection; // Variable for stack protection\n\n    // Initialize local_8 with a value for security check\n    stackProtection = DAT_100345e0 ^ (uint)&stack0xfffffffc;\n\n    // Retrieve locale information based on param_1 and store it in local_80\n    localeInfoResult = GetLocaleInfoA(param_1 & 0x3ff | 0x400, 1, localeBuffer, 0x78);\n\n    // Check if GetLocaleInfoA was successful and if the locale differs from param_1\n    if (localeInfoResult != 0 && (lcidResult = _LcidFromHexString(0, localeBuffer), param_1 != lcidResult) && param_2 != 0) {\n        // Call _GetPrimaryLen with this pointer\n        _GetPrimaryLen(0, this);\n        // Call _strlen with this pointer\n        _strlen(this);\n    }\n\n    // Perform security check before returning\n    ___security_check_cookie_4(stackProtection ^ (uint)&stack0xfffffffc);\n    return; // Exit the function\n}\n"}
{"Function Name": "_LangCountryEnumProc@4", "Address": "1001f5a3", "Source Code": "\nvoid _LangCountryEnumProc_4(char *localeString)\n{\n    // Declare a pointer to thread-local data structure\n    _ptiddata threadLocalData;\n    // Declare a variable to hold the locale identifier\n    LCID localeId;\n    // Declare an integer variable for locale information retrieval status\n    int localeInfoStatus;\n    // Declare a variable for string length\n    size_t stringLength;\n    // Declare a local variable for stack protection\n    uint stackProtection;\n    // Initialize local_8 with a value for security check\n    stackProtection = DAT_100345e0 ^ (uint)&stack0xfffffffc;\n    // Get the pointer to the thread-local data\n    threadLocalData = __getptd();\n    // Convert the hex string to a locale identifier\n    localeId = _LcidFromHexString(0, localeString);\n    // Retrieve locale information based on the locale identifier\n    localeInfoStatus = GetLocaleInfoA(localeId, (-(uint)((threadLocalData->_setloc_data).bAbbrevCountry != 0) & 0xfffff005) + 0x1002, countryOrLanguageBuffer, 0x78);\n    // Check if the locale information retrieval was successful\n    if (localeInfoStatus == 0) {\n        // Set the locale state to 0 if retrieval failed\n        (threadLocalData->_setloc_data).iLocState = 0;\n        goto LAB_1001f762; // Jump to cleanup and return\n    }\n    // Compare the retrieved country string with the stored country string\n    localeInfoStatus = __stricmp((char *)(threadLocalData->_setloc_data).pchCountry, countryOrLanguageBuffer);\n    // If the country strings match\n    if (localeInfoStatus == 0) {\n        // Retrieve language information based on the locale identifier\n        localeInfoStatus = GetLocaleInfoA(localeId, (-(uint)((threadLocalData->_setloc_data).bAbbrevLanguage != 0) & 0xfffff002) + 0x1001, countryOrLanguageBuffer, 0x78);\n        // Check if the language information retrieval was successful\n        if (localeInfoStatus == 0) goto LAB_1001f5f4; // Jump to error handling\n        // Compare the retrieved language string with the stored language string\n        localeInfoStatus = __stricmp((char *)threadLocalData->_setloc_data.pchLanguage, countryOrLanguageBuffer);\n        // If the language strings match\n        if (localeInfoStatus == 0) {\n            // Update locale state and cache with the current locale\n            (threadLocalData->_setloc_data).iLocState |= 0x304;\n            (threadLocalData->_setloc_data)._cachecp = localeId;\n            *(LCID *)(threadLocalData->_setloc_data)._cachein = localeId;\n        } else if ((*(byte *)&(threadLocalData->_setloc_data).iLocState & 2) == 0) {\n            // Get the length of the primary language string\n            stringLength = (threadLocalData->_setloc_data).iPrimaryLen;\n            // Check if the primary language length is valid and compare\n            if ((stringLength == 0) || (localeInfoStatus = __strnicmp((char *)threadLocalData->_setloc_data.pchLanguage, countryOrLanguageBuffer, stringLength), localeInfoStatus != 0)) {\n                // If the locale state does not indicate a default country\n                if ((((threadLocalData->_setloc_data).iLocState & 1U) == 0) && (localeInfoStatus = _TestDefaultCountry((short)localeId), localeInfoStatus != 0)) {\n                    // Update locale state to indicate a default country\n                    (threadLocalData->_setloc_data).iLocState |= 1;\n                    goto LAB_1001f6a4; // Jump to further processing\n                }\n            } else {\n                // Update locale state to indicate a match in primary language\n                (threadLocalData->_setloc_data).iLocState |= 2;\n                *(LCID *)(threadLocalData->_setloc_data)._cachein = localeId;\n                // Check if the primary language length matches the stored length\n                stringLength = _strlen((char *)threadLocalData->_setloc_data.pchLanguage);\n                if (stringLength == (threadLocalData->_setloc_data).iPrimaryLen) {\n                    // Update cache with the current locale\n                    (threadLocalData->_setloc_data)._cachecp = localeId;\n                }\n            }\n        }\n    }\n    // Check if both country and language states are set\n    if (((threadLocalData->_setloc_data).iLocState & 0x300U) == 0x300) goto LAB_1001f762; // Jump to cleanup and return\n    // Retrieve language information again based on the locale identifier\n    localeInfoStatus = GetLocaleInfoA(localeId, (-(uint)((threadLocalData->_setloc_data).bAbbrevLanguage != 0) & 0xfffff002) + 0x1001, countryOrLanguageBuffer, 0x78);\n    // Check if the language information retrieval was successful\n    if (localeInfoStatus == 0) goto LAB_1001f5f4; // Jump to error handling\n    // Compare the retrieved language string with the stored language string\n    localeInfoStatus = __stricmp((char *)threadLocalData->_setloc_data.pchLanguage, countryOrLanguageBuffer);\n    // If the language strings match\n    if (localeInfoStatus == 0) {\n        // Update locale state to indicate a match in language\n        (threadLocalData->_setloc_data).iLocState |= 0x200;\n        // If abbreviation for language is not set\n        if ((threadLocalData->_setloc_data).bAbbrevLanguage == 0) {\n            // Check if primary length is valid and matches\n            if (((threadLocalData->_setloc_data).iPrimaryLen != 0) && (stringLength = _strlen((char *)threadLocalData->_setloc_data.pchLanguage), stringLength == (threadLocalData->_setloc_data).iPrimaryLen)) {\n                localeInfoStatus = 1; // Set iVar3 to indicate a match\n                goto LAB_1001f73a; // Jump to further processing\n            }\n            goto LAB_1001f748; // Jump to error handling\n        }\n        // Update locale state to indicate abbreviation for language is set\n        (threadLocalData->_setloc_data).iLocState |= 0x100;\n    } else {\n        // If abbreviation for language is set or primary length is zero\n        if ((((threadLocalData->_setloc_data).bAbbrevLanguage != 0) || ((threadLocalData->_setloc_data).iPrimaryLen == 0)) || (localeInfoStatus = __stricmp((char *)threadLocalData->_setloc_data.pchLanguage, countryOrLanguageBuffer), localeInfoStatus != 0)) goto LAB_1001f762; // Jump to cleanup and return\n        localeInfoStatus = 0; // Set iVar3 to indicate no match\nLAB_1001f73a:\n        // Test if the language is the default language\n        localeInfoStatus = _TestDefaultLanguage(threadLocalData->_setloc_data.pchLanguage, localeId, localeInfoStatus);\n        // If the test fails, jump to cleanup and return\n        if (localeInfoStatus == 0) goto LAB_1001f762;\nLAB_1001f748:\n        // Update locale state to indicate abbreviation for language is set\n        (threadLocalData->_setloc_data).iLocState |= 0x100;\n    }\n    // If cache code page is not set\n    if ((threadLocalData->_setloc_data)._cachecp == 0) {\n        // Set cache code page to the current locale\n        (threadLocalData->_setloc_data)._cachecp = localeId;\n    }\nLAB_1001f762:\n    // Perform security check before returning\n    ___security_check_cookie_4(stackProtection ^ (uint)&stack0xfffffffc);\n    return; // Exit the function\n}\n"}
{"Function Name": "_LanguageEnumProc@4", "Address": "1001f773", "Source Code": "\nvoid _LanguageEnumProc_4(char *localeString)\n{\n    _ptiddata threadData; // Pointer to thread-local data structure\n    LCID localeId; // Locale identifier\n    int returnValue; // Variable to store return values from functions\n    CHAR localeBuffer[120]; // Buffer to hold locale information\n    uint securityCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Security cookie for stack protection\n    \n    threadData = __getptd(); // Get the thread-local data\n    localeId = _LcidFromHexString(0, localeString); // Convert hex string to LCID\n    returnValue = GetLocaleInfoA(localeId, -(uint)((threadData->_setloc_data).bAbbrevLanguage != 0) & 0xfffff002 + 0x1001, localeBuffer, 0x78); // Retrieve locale information\n    \n    if (returnValue == 0) { // Check if locale info retrieval failed\n        (threadData->_setloc_data).iLocState = 0; // Reset locale state\n        goto LAB_1001f822; // Jump to cleanup and exit\n    }\n    \n    returnValue = __stricmp((char *)threadData->_setloc_data.pchLanguage, localeBuffer); // Compare current language with retrieved language\n    if (returnValue == 0) { // If languages match\n        if ((threadData->_setloc_data).bAbbrevLanguage == 0) { // Check if abbreviation is not used\n            returnValue = 1; // Set iVar3 to indicate a match\n            goto LAB_1001f7ff; // Jump to default language test\n        }\n    } else { // If languages do not match\n        if (((threadData->_setloc_data).bAbbrevLanguage != 0) || // Check if abbreviation is used\n            ((threadData->_setloc_data).iPrimaryLen == 0) || // Check if primary length is zero\n            (returnValue = __stricmp((char *)threadData->_setloc_data.pchLanguage, localeBuffer), returnValue != 0)) { // Compare again if necessary\n            goto LAB_1001f822; // Jump to cleanup and exit\n        }\n        returnValue = 0; // Set iVar3 to indicate no match\n    }\n    \nLAB_1001f7ff:\n    returnValue = _TestDefaultLanguage(&threadData->_setloc_data, localeId, returnValue); // Test if the default language is valid\n    if (returnValue == 0) goto LAB_1001f822; // Jump to cleanup and exit if not valid\n\n    threadData->_setloc_data.iLocState |= 4; // Update locale state to indicate success\n    threadData->_setloc_data._cachecp = localeId; // Cache the current locale\n    *(LCID *)(threadData->_setloc_data)._cachein = localeId; // Store the locale in the cache\n\nLAB_1001f822:\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); // Security check for stack integrity\n    return; // Exit the function\n}\n"}
{"Function Name": "_GetLcidFromLangCountry", "Address": "1001f832", "Source Code": "\nvoid _GetLcidFromLangCountry(void)\n{\n    // Retrieve the language string from the unaff_ESI pointer\n    char *languageString = *langCountryArray;\n\n    // Check if the length of the language string is 3 and store the result in the fifth element of unaff_ESI\n    langCountryArray[4] = (char *)(uint)(_strlen(languageString) == 3);\n\n    // Check if the length of the second element in unaff_ESI is 3 and store the result in the sixth element of unaff_ESI\n    langCountryArray[5] = (char *)(uint)(_strlen(langCountryArray[1]) == 3);\n\n    // Determine the primary length based on the previous checks and store it in the third element of unaff_ESI\n    languageString = (langCountryArray[4] == (char *)0x0) ? (char *)_GetPrimaryLen(languageString, *langCountryArray) : (char *)0x2;\n    langCountryArray[3] = languageString;\n\n    // Enumerate system locales using the specified callback function\n    EnumSystemLocalesA(langCountryEnumCallback, 1);\n\n    // Check specific flags in the second element of unaff_ESI and reset it to null if conditions are met\n    if (((((uint)langCountryArray[2] & 0x100) == 0) || (((uint)langCountryArray[2] & 0x200) == 0)) || (((uint)langCountryArray[2] & 7) == 0)) {\n        langCountryArray[2] = (char *)0x0;\n    }\n\n    // Return from the function\n    return;\n}\n"}
{"Function Name": "_GetLcidFromLanguage", "Address": "1001f897", "Source Code": "\nvoid _GetLcidFromLanguage(void)\n{\n    char **languageArray = ...; // Pointer to an array of character pointers, initialized elsewhere\n    size_t stringLength = _strlen(*languageArray); // Get the length of the string pointed to by the first element of unaff_ESI\n    languageArray[4] = (char *)(uint)(stringLength == 3); // Set the fifth element of unaff_ESI to 1 if length is 3, otherwise 0\n    // Set the fourth element of unaff_ESI to 0x2 if length is 3, otherwise call _GetPrimaryLen function\n    languageArray[3] = (stringLength == 3) ? (char *)0x2 : (char *)_GetPrimaryLen(*languageArray, *languageArray);\n    EnumSystemLocalesA(_LanguageEnumProc_4, 1); // Enumerate system locales using the specified callback function\n    // If the third element of unaff_ESI does not have the 4th bit set, set it to NULL\n    if ((*(byte *)(languageArray + 2) & 4) == 0) {\n        languageArray[2] = (char *)0x0; // Set the third element of unaff_ESI to NULL\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "___crtMessageBoxA", "Address": "10021180", "Source Code": "\nint __cdecl ___crtMessageBoxA(LPCSTR messageText, LPCSTR messageCaption, UINT messageType)\n{\n    HMODULE moduleHandle; // Handle for the loaded module\n    FARPROC functionPointer; // Pointer to the function to be called\n    int functionResult; // Variable to store the result of function calls\n    code *functionCodePointer; // Pointer to function code\n    int osPlatformInfo; // Variable to store OS platform information\n    uint windowsVersionInfo; // Variable to store Windows version information\n    int messageBoxResult = 0; // Variable to store the result of MessageBox or related calls\n\n    osPlatformInfo = 0; // Initialize local_c to 0\n    windowsVersionInfo = 0; // Initialize local_10 to 0\n\n    // Check if the function pointers have been initialized\n    if (DAT_10036650 == 0) {\n        moduleHandle = LoadLibraryA(\"USER32.DLL\"); // Load the USER32.DLL library\n        // Check if the library was loaded successfully and get the MessageBoxA address\n        if ((moduleHandle == (HMODULE)0x0) || (functionPointer = GetProcAddress(moduleHandle, \"MessageBoxA\"), functionPointer == (FARPROC)0x0)) {\n            return 0; // Return 0 if loading failed or MessageBoxA not found\n        }\n        // Store the encoded pointer for MessageBoxA\n        DAT_10036650 = __encode_pointer((int)functionPointer);\n        // Get and store pointers for other functions\n        functionPointer = GetProcAddress(moduleHandle, \"GetActiveWindow\");\n        DAT_10036654 = __encode_pointer((int)functionPointer);\n        functionPointer = GetProcAddress(moduleHandle, \"GetLastActivePopup\");\n        DAT_10036658 = __encode_pointer((int)functionPointer);\n        __get_osplatform(&osPlatformInfo); // Get the OS platform information\n        // If the platform is Windows NT\n        if (osPlatformInfo == 2) {\n            functionPointer = GetProcAddress(moduleHandle, \"GetUserObjectInformationA\");\n            DAT_10036660 = __encode_pointer((int)functionPointer); // Store pointer for GetUserObjectInformationA\n            // If the pointer is valid, get the process window station\n            if (DAT_10036660 != 0) {\n                functionPointer = GetProcAddress(moduleHandle, \"GetProcessWindowStation\");\n                DAT_1003665c = __encode_pointer((int)functionPointer); // Store pointer for GetProcessWindowStation\n            }\n        }\n    }\n\n    // Check if the current context matches the stored context\n    if ((DAT_1003665c == osPlatformInfo) || (DAT_10036660 == osPlatformInfo)) {\n        // If the active window function pointer is valid\n        if (DAT_10036654 != osPlatformInfo) {\n            functionCodePointer = (code *)__decode_pointer(DAT_10036654); // Decode the pointer\n            functionResult = (*functionCodePointer)(); // Call GetActiveWindow\n            messageBoxResult = functionResult; // Store the result\n            // If the result is valid and the last active popup function pointer is valid\n            if ((functionResult != 0) && (DAT_10036658 != osPlatformInfo)) {\n                functionCodePointer = (code *)__decode_pointer(DAT_10036658); // Decode the pointer\n                messageBoxResult = (*functionCodePointer)(functionResult); // Call GetLastActivePopup\n            }\n        }\n    } else {\n        // If the context is different, call GetProcessWindowStation\n        functionCodePointer = (code *)__decode_pointer(DAT_1003665c);\n        functionResult = (*functionCodePointer)(); // Call GetProcessWindowStation\n        if (functionResult != 0) {\n            byte userObjectInfo; // Variable to store user object information\n            undefined userObjectInfoBuffer1[4]; // Buffer for user object information\n            undefined userObjectInfoBuffer2[8]; // Buffer for user object information\n            uint userObjectInfoParam = 1; // Parameter for GetUserObjectInformationA\n            uint userObjectInfoBufferSize = 0xc; // Size of the buffer\n            functionCodePointer = (code *)__decode_pointer(DAT_10036660); // Decode pointer for GetUserObjectInformationA\n            functionResult = (*functionCodePointer)(functionResult, userObjectInfoParam, userObjectInfoBuffer2, userObjectInfoBufferSize, userObjectInfoBuffer1); // Call GetUserObjectInformationA\n            // If the call was successful and the information indicates a specific condition\n            if ((functionResult != 0) && ((userObjectInfo & 1) != 0)) {\n                // If the active window function pointer is valid\n                if (DAT_10036654 != osPlatformInfo) {\n                    functionCodePointer = (code *)__decode_pointer(DAT_10036654); // Decode the pointer\n                    functionResult = (*functionCodePointer)(); // Call GetActiveWindow\n                    messageBoxResult = functionResult; // Store the result\n                    // If the result is valid and the last active popup function pointer is valid\n                    if ((functionResult != 0) && (DAT_10036658 != osPlatformInfo)) {\n                        functionCodePointer = (code *)__decode_pointer(DAT_10036658); // Decode the pointer\n                        messageBoxResult = (*functionCodePointer)(functionResult); // Call GetLastActivePopup\n                    }\n                }\n            }\n        }\n        __get_winmajor(&windowsVersionInfo); // Get the major version of Windows\n        // Adjust the message box type based on the Windows version\n        if (windowsVersionInfo < 4) {\n            messageType = messageType | 0x40000; // Set a flag for older versions\n        } else {\n            messageType = messageType | 0x200000; // Set a different flag for newer versions\n        }\n    }\n    \n    functionCodePointer = (code *)__decode_pointer(DAT_10036650); // Decode the pointer for MessageBoxA\n    return (*functionCodePointer)(messageBoxResult, messageText, messageCaption, messageType); // Call MessageBoxA and return the result\n}\n"}
{"Function Name": "_ValidateRead", "Address": "1002160c", "Source Code": "\nint __cdecl _ValidateRead(void *inputPointer, uint inputValue)\n{\n    // Check if the pointer 'param_1' is not NULL\n    // Return 1 (true) if 'param_1' is not NULL, otherwise return 0 (false)\n    return (uint)(inputPointer != NULL);\n}\n"}
{"Function Name": "__NLG_Notify1", "Address": "10021728", "Source Code": "\nundefined4 __fastcall __NLG_Notify1(undefined4 input_value)\n{\n    // Store the value of param_1 in the global variable DAT_10035688\n    global_variable = input_value;\n    \n    // Return the value in the EAX register\n    return return_value;\n}\n"}
{"Function Name": "FUN_10021750", "Address": "10021750", "Source Code": "\nvoid FUN_10021750(void) // Function definition for FUN_10021750\n{\n    code *function_pointer; // Declare a pointer to a function (code type)\n    function_pointer(); // Call the function pointed to by in_EAX\n}\n"}
{"Function Name": "__get_sse2_info", "Address": "100217a3", "Source Code": "\nundefined4 __get_sse2_info(void) // Function to retrieve SSE2 information\n{\n    uint cpuFeatureFlags; // Variable to hold combined CPU feature flags\n    undefined4 sse2Support; // Variable to hold the return value indicating SSE2 support\n    byte flagAF, flagTF, flagIF, flagNT, flagAC, flagVIF, flagVIP, flagID; // Input flags for CPU features\n    uint additionalInfo = 0; // Local variable to store additional information from CPUID\n\n    // Combine input flags into a single variable representing CPU features\n    cpuFeatureFlags = (uint)(flagNT & 1) * 0x4000 | (uint)(flagIF & 1) * 0x200 | (uint)(flagTF & 1) * 0x100 | 0x40\n           | (uint)(flagAF & 1) * 0x10 | 4 | (uint)(flagID & 1) * 0x200000 |\n           (uint)(flagVIP & 1) * 0x100000 | (uint)(flagVIF & 1) * 0x80000 | (uint)(flagAC & 1) * 0x40000;\n\n    // Check if the SSE2 feature is supported based on the combined flags\n    if ((cpuFeatureFlags ^ 0x200000) != (cpuFeatureFlags & 0x4000 | cpuFeatureFlags & 0x400 | cpuFeatureFlags & 0x200 | cpuFeatureFlags & 0x100 |\n                              cpuFeatureFlags & 0x40 | cpuFeatureFlags & 0x10 | cpuFeatureFlags & 4 | cpuFeatureFlags & 0x200000 |\n                              cpuFeatureFlags & 0x40000)) {\n        cpuid_basic_info(0); // Retrieve basic CPUID information\n        additionalInfo = *(uint *)(cpuid_Version_info(1) + 8); // Get additional version info from CPUID\n    }\n\n    // Determine if SSE2 is supported based on the retrieved information\n    sse2Support = ((additionalInfo & 0x4000000) != 0 && FUN_10021753() != 0) ? 1 : 0; \n    return sse2Support; // Return 1 if SSE2 is supported, otherwise return 0\n}\n"}
{"Function Name": "FUN_10021810", "Address": "10021810", "Source Code": "\nvoid __cdecl FUN_10021810(undefined4 inputValue) // Function definition with a calling convention\n{\n    globalData = inputValue; // Assign the value of param_1 to the global variable DAT_10036670\n}\n"}
{"Function Name": "___crtInitCritSecNoSpinCount@8", "Address": "1002181a", "Source Code": "\nundefined4 ___crtInitCritSecNoSpinCount_8(LPCRITICAL_SECTION critical_section)\n{\n    // Initialize the critical section object pointed to by param_1\n    InitializeCriticalSection(critical_section);\n    \n    // Return a success indicator (1)\n    return 1;\n}\n"}
{"Function Name": "__ValidateImageBase", "Address": "100218f0", "Source Code": "\nBOOL __cdecl __ValidateImageBase(PBYTE imageBase)\n{\n    // Check if the first two bytes of the image base match the 'MZ' signature (0x5a4d)\n    return (*(short *)imageBase == 0x5a4d) &&\n           // Check if the signature at the offset specified in the PE header (0x3c) matches 'PE' (0x4550)\n           (*(int *)(imageBase + *(int *)(imageBase + 0x3c)) == 0x4550) &&\n           // Check if the machine type at the offset (0x18) in the PE header matches the expected value (0x10b)\n           (*(short *)((int)(imageBase + *(int *)(imageBase + 0x3c)) + 0x18) == 0x10b);\n}\n"}
{"Function Name": "FID_conflict:__atoflt_l", "Address": "100219fd", "Source Code": "\nint __cdecl FID_conflict___atoflt_l(_CRT_FLOAT *_Result, char *_Str, _locale_t _Locale)\n{\n    INTRNCVT_STATUS conversionStatus; // Status of internal conversion\n    int securityCheckResult; // Variable to hold return value for security check\n    char *endOfStringPtr; // Pointer for the end of the string after conversion\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    uint conversionFlags; // Variable to hold conversion status flags\n    LDBL12 convertedLongDouble; // Variable to hold the converted long double value\n    uint stackCookie; // Variable to store stack cookie for security check\n\n    // Calculate stack cookie for security check\n    stackCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc;\n    \n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, _Locale);\n    \n    // Convert string to long double with locale support\n    conversionFlags = ___strgtold12_l(&convertedLongDouble, &endOfStringPtr, _Str, 0, 0, 0, 0, &localeInfo);\n    \n    // Convert long double to double and get the status\n    conversionStatus = FID_conflict___ld12tod(&convertedLongDouble, (_CRT_DOUBLE *)_Result);\n\n    // Check if conversion was successful\n    if ((conversionFlags & 3) == 0) {\n        // Check for overflow condition\n        if (conversionStatus == INTRNCVT_OVERFLOW) {\n            if (overflowFlag != '\\0') {\n                // Clear overflow flag in the status\n                *(uint *)(statusPointer + 0x70) &= 0xfffffffd;\n            }\n            goto LAB_10021a94; // Jump to cleanup and return\n        }\n        // Check for underflow condition\n        if (conversionStatus != INTRNCVT_UNDERFLOW) {\n            if (overflowFlag != '\\0') {\n                // Clear underflow flag in the status\n                *(uint *)(statusPointer + 0x70) &= 0xfffffffd;\n            }\n            goto LAB_10021a94; // Jump to cleanup and return\n        }\n    } else if ((conversionFlags & 1) == 0) {\n        // Check if there was a conversion error\n        if ((conversionFlags & 2) == 0) {\n            goto LAB_10021a86; // Jump to error handling\n        }\n        goto LAB_10021a54; // Jump to another error handling\n    }\n    \n    // Clear status flag if needed\n    if (overflowFlag != '\\0') {\n        *(uint *)(statusPointer + 0x70) &= 0xfffffffd;\n    }\n    \nLAB_10021a94:\n    // Perform security check on the stack cookie\n    securityCheckResult = ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc);\n    return securityCheckResult; // Return the result of the security check\n}\n"}
{"Function Name": "FID_conflict:__atoflt_l", "Address": "10021aa3", "Source Code": "\nint __cdecl FID_conflict___atoflt_l(_CRT_FLOAT *_Result, char *_Str, _locale_t _Locale)\n{\n    INTRNCVT_STATUS conversionStatus; // Status variable for internal conversion\n    int securityCheckResult; // Variable to hold the return value of security check\n    char *endOfStringPtr; // Pointer for the end of the string after conversion\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    uint conversionStatusFlags; // Variable to hold the conversion status flags\n    LDBL12 convertedLongDouble; // Variable to hold the converted long double value\n    uint stackProtectionCookie; // Variable for stack protection cookie\n\n    // Initialize stack protection cookie\n    stackProtectionCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc;\n    \n    // Update the locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, _Locale);\n    \n    // Convert string to long double with locale support\n    conversionStatusFlags = ___strgtold12_l(&convertedLongDouble, &endOfStringPtr, _Str, 0, 0, 0, 0, &localeInfo);\n    \n    // Convert long double to double and store in _Result\n    conversionStatus = FID_conflict___ld12tod(&convertedLongDouble, (_CRT_DOUBLE *)_Result);\n\n    // Check for conversion status\n    if ((conversionStatusFlags & 3) == 0) {\n        // Check for overflow condition\n        if (conversionStatus == INTRNCVT_OVERFLOW) {\n            // Clear a specific flag if local_1c is not zero\n            if (local_1c != '\\0') {\n                *(uint *)(local_20 + 0x70) &= 0xfffffffd;\n            }\n            goto LAB_10021b3a; // Jump to cleanup and return\n        }\n        // Check for underflow condition\n        if (conversionStatus != INTRNCVT_UNDERFLOW) {\n            // Clear a specific flag if local_1c is not zero\n            if (local_1c != '\\0') {\n                *(uint *)(local_20 + 0x70) &= 0xfffffffd;\n            }\n            goto LAB_10021b3a; // Jump to cleanup and return\n        }\n    } else if ((conversionStatusFlags & 1) == 0) {\n        // Check if the conversion failed due to invalid input\n        if ((conversionStatusFlags & 2) == 0) goto LAB_10021b2c; // Jump to normal return\n        goto LAB_10021afa; // Jump to specific error handling\n    }\n    \n    // Clear a specific flag if local_1c is not zero\n    if (local_1c != '\\0') {\n        *(uint *)(local_20 + 0x70) &= 0xfffffffd;\n    }\n    \nLAB_10021b3a:\n    // Perform security check on the stack cookie\n    securityCheckResult = ___security_check_cookie_4(stackProtectionCookie ^ (uint)&stack0xfffffffc);\n    return securityCheckResult; // Return the result of the security check\n}\n"}
{"Function Name": "___dtold", "Address": "10021c06", "Source Code": "\nvoid __cdecl ___dtold(uint *param_1, uint *param_2)\n{\n    uint mantissa; // Variable to hold the first parameter value\n    ushort exponentShifted; // Variable to hold the shifted value of the second parameter\n    ushort exponentValue; // Variable to hold the exponent part of the floating-point number\n    ushort signExponent; // Variable to hold the sign bit and exponent\n\n    // Extract the exponent and sign from the second parameter\n    exponentShifted = *(ushort *)((int)param_2 + 6) >> 4; // Get the exponent part\n    signExponent = *(ushort *)((int)param_2 + 6) & 0x8000; // Get the sign bit\n    exponentValue = exponentShifted & 0x7ff; // Isolate the exponent value\n    mantissa = *param_2; // Get the mantissa from the second parameter\n\n    // Check if the exponent is zero\n    if ((exponentShifted & 0x7ff) == 0) {\n        // Check if both the mantissa and the next part are zero\n        if (((param_2[1] & 0xfffff) == 0) && (mantissa == 0)) {\n            param_1[1] = 0; // Set the result mantissa to zero\n            *param_1 = 0; // Set the result exponent to zero\n            goto LAB_10021cb8; // Jump to the end of the function\n        }\n        exponentValue += 0x3c01; // Adjust the exponent for denormalized numbers\n    } else if (exponentValue == 0x7ff) {\n        exponentValue = 0x7fff; // Set to maximum exponent for special cases (infinity/NaN)\n    } else {\n        exponentValue += 0x3c00; // Adjust the exponent for normalized numbers\n    }\n\n    // Combine the mantissa and exponent into the result\n    param_1[1] = mantissa >> 0x15 | (param_2[1] & 0xfffff) << 0xb; // Set the upper part of the result\n    *param_1 = mantissa << 0xb; // Set the lower part of the result\n\n    // Normalize the result\n    while ((param_1[1] & 0x80000000) == 0) { // While the result is not normalized\n        mantissa = param_1[1]; // Get the current mantissa\n        exponentValue--; // Decrease the exponent\n        param_1[1] = mantissa * 2 | *param_1 >> 0x1f; // Shift left and handle overflow\n        *param_1 *= 2; // Shift the exponent left\n    }\n    \n    signExponent |= exponentValue; // Combine the sign bit with the exponent\nLAB_10021cb8:\n    *(ushort *)(param_1 + 2) = signExponent; // Store the final result\n    return; // Exit the function\n}\n"}
{"Function Name": "__fltout2", "Address": "10021cc1", "Source Code": "\nSTRFLT __cdecl __fltout2(_CRT_DOUBLE _Dbl, STRFLT _Flt, char *_ResultStr, size_t _SizeInBytes)\n{\n    int outputStatus; // Variable to store the output status from __I10_OUTPUT\n    errno_t stringCopyResult; // Variable to store the result of the string copy operation\n    short decimalPointPosition; // Variable to hold the decimal point position\n    char signCharacter; // Variable to hold the sign of the floating-point number\n    char formattedStringBuffer[24]; // Buffer to store the formatted string representation of the float\n    uint stackProtectionCookie; // Variable for stack protection cookie\n\n    // Initialize local_8 with a value for stack protection\n    stackProtectionCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc;\n\n    // Convert the double to a long double representation\n    ___dtold((uint *)&local_14, (uint *)&_Dbl);\n\n    // Format the long double into a string and get the output status\n    outputStatus = __I10_OUTPUT(local_14, uStack_10, uStack_c, 0x11, 0, &decimalPointPosition);\n\n    // Set the flag, sign, and decimal point position in the STRFLT structure\n    _Flt->flag = outputStatus;\n    _Flt->sign = (int)signCharacter;\n    _Flt->decpt = (int)decimalPointPosition;\n\n    // Copy the formatted string into the result buffer and check for errors\n    stringCopyResult = _strcpy_s(_ResultStr, _SizeInBytes, formattedStringBuffer);\n    if (stringCopyResult != 0) {\n        // Invoke error handling if string copy fails\n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n\n    // Assign the result string to the mantissa field of the STRFLT structure\n    _Flt->mantissa = _ResultStr;\n\n    // Return the STRFLT structure after checking the stack protection cookie\n    return (STRFLT)___security_check_cookie_4(stackProtectionCookie ^ (uint)&stack0xfffffffc);\n}\n"}
{"Function Name": "__getenv_helper_nolock", "Address": "10021ec2", "Source Code": "\nchar * __cdecl __getenv_helper_nolock(char *env_var_name) // Function to retrieve environment variable value\n{\n    size_t max_length; // Variable to hold the maximum count of characters in param_1\n    size_t current_var_length; // Variable to hold the length of the current environment variable\n    uchar **env_var_list; // Pointer to iterate through the list of environment variables\n\n    if (DAT_100377c4 == 0) { // Check if the environment variable list is initialized\n        return (char *)0x0; // Return null if not initialized\n    }\n\n    if ((DAT_1003646c != (uchar **)0x0) && (env_var_name != (char *)0x0)) { // Check if the environment variable list and param_1 are not null\n        max_length = _strlen(env_var_name); // Get the length of the input parameter\n        env_var_list = DAT_1003646c; // Initialize pointer to the start of the environment variable list\n\n        for (; *env_var_list != (uchar *)0x0; env_var_list++) { // Iterate through the environment variable list\n            current_var_length = _strlen((char *)*env_var_list); // Get the length of the current environment variable\n\n            // Check if the current variable is longer than param_1, has an '=' character at the right position,\n            // and matches the input parameter up to _MaxCount\n            if ((max_length < current_var_length) && ((*env_var_list)[max_length] == '=') && (__mbsnbicoll(*env_var_list, (uchar *)env_var_name, max_length) == 0)) {\n                return (char *)(*env_var_list + max_length + 1); // Return the value of the environment variable\n            }\n        }\n    }\n\n    return (char *)0x0; // Return null if the variable is not found\n}\n"}
{"Function Name": "FUN_10022116", "Address": "10022116", "Source Code": "\nvoid unlockFileHandleFunction(void) // Function definition for FUN_10022116\n{\n    // Dereference the pointer at address 0, then dereference that result to get an integer pointer\n    // Access the integer at offset 8 from that pointer and pass it to __unlock_fhandle\n    unlockFileHandle(*(int *)(*(int *)0 + 8));\n}\n"}
{"Function Name": "__write_nolock", "Address": "10022120", "Source Code": "\nint __cdecl __write_nolock(int file_handle, void *buffer, uint max_char_count)\n{\n    char char_value; // Variable to hold a character value\n    WCHAR wide_char_value; // Variable to hold a wide character value\n    int *file_handle_ptr; // Pointer to an integer, likely for file handle management\n    int conversion_result; // Variable to store the result of isatty check\n    BOOL write_file_result; // Boolean variable to store the result of WriteFile\n    DWORD bytes_to_write; // Number of bytes to write\n    UINT internal_var; // Local variable for internal use\n    char *written_bytes_ptr = (char *)0x0; // Pointer for tracking written bytes\n    WCHAR *buffer_ptr = (WCHAR *)buffer; // Pointer to the buffer being written\n    uint newline_count = 0; // Counter for newline conversions\n    uint security_cookie = DAT_100345e0 ^ (uint)security_cookie_value; // Security cookie check\n\n    // Check if the maximum character count is zero\n    if (max_char_count == 0) goto LAB_100226d0;\n\n    // Check if the buffer is null\n    if (buffer == (void *)0x0) {\n        *___doserrno() = 0; // Clear DOS error\n        *__errno() = 0x16; // Set errno to invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        goto LAB_100226d0; // Exit function\n    }\n\n    // Calculate the index for the file handle\n    int file_handle_index = (file_handle & 0x1fU) * 0x28;\n    file_handle_ptr = &DAT_100366a0 + (file_handle >> 5); // Get pointer to file handle structure\n    char file_type = (char)(*(char *)(*file_handle_ptr + file_handle_index + 0x24) * '\\x02') >> 1; // Get file type\n\n    // Check for invalid character count for certain file types\n    if (((file_type == '\\x02') || (file_type == '\\x01')) && ((~max_char_count & 1) == 0)) {\n        *___doserrno() = 0; // Clear DOS error\n        *__errno() = 0x16; // Set errno to invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        goto LAB_100226d0; // Exit function\n    }\n\n    // Check if the file handle is a special type that requires seeking\n    if ((*(byte *)(*file_handle_ptr + file_handle_index + 4) & 0x20) != 0) {\n        __lseeki64_nolock(file_handle, 0x200000000, 0); // Seek to the end of the file\n    }\n\n    // Check if the file handle refers to a terminal\n    conversion_result = __isatty(file_handle);\n    if ((conversion_result == 0) || ((*(byte *)(file_handle_index + 4 + *file_handle_ptr) & 0x80) == 0)) {\n        // Check if the file handle is not a special type\n        if ((*(byte *)((HANDLE *)(*file_handle_ptr + file_handle_index) + 1) & 0x80) == 0) {\n            // Attempt to write to the file\n            write_file_result = WriteFile(*(HANDLE *)(*file_handle_ptr + file_handle_index), buffer_ptr, max_char_count, (LPDWORD)&written_bytes_ptr, (LPOVERLAPPED)0x0);\n            if (write_file_result == 0) {\n                write_error = GetLastError(); // Capture error if write fails\n            } else {\n                write_error = 0; // Reset error if write succeeds\n            }\n            if (written_bytes_ptr != (char *)0x0) goto LAB_100226d0; // Check if bytes were written\n            goto LAB_10022678; // Proceed to next step\n        }\n        write_error = 0; // Reset error for terminal case\n        if (file_type == '\\0') { // If not a special file type\n            WCHAR *processing_ptr = buffer_ptr; // Pointer for processing buffer\n            if (max_char_count == 0) goto LAB_1002269f; // Check for zero character count\n            do {\n                WCHAR *local_processing_ptr = (WCHAR *)0x0; // Local pointer for tracking\n                uint offset = (int)processing_ptr - (int)buffer_ptr; // Calculate offset\n                WCHAR *output_ptr = output_buffer_start; // Pointer for writing output\n                do {\n                    if (max_char_count <= offset) break; // Check bounds\n                    WCHAR *incremented_ptr = (WCHAR *)((int)processing_ptr + 1); // Increment pointer\n                    char_value = *(char *)processing_ptr; // Get current character\n                    offset++; // Increment offset\n                    if (char_value == '\\n') { // Check for newline\n                        newline_count++; // Increment newline count\n                        *(char *)output_ptr = '\\r'; // Write carriage return\n                        output_ptr++; // Move to next position\n                        local_processing_ptr++; // Increment local pointer\n                    }\n                    *(char *)output_ptr = char_value; // Write character\n                    output_ptr++; // Move to next position\n                    local_processing_ptr++; // Increment local pointer\n                    processing_ptr = incremented_ptr; // Move to next character\n                } while (local_processing_ptr < (WCHAR *)0x400); // Limit processing\n                // Attempt to write the processed buffer to the file\n                write_file_result = WriteFile(*(HANDLE *)(file_handle_index + *file_handle_ptr), output_buffer_start, (int)output_ptr - (int)output_buffer_start, (LPDWORD)&written_bytes_ptr, (LPOVERLAPPED)0x0);\n                if (write_file_result == 0) goto LAB_10022665; // Check for write error\n                written_bytes_ptr += (int)written_bytes_ptr; // Update written bytes count\n            } while (((int)output_ptr - (int)output_buffer_start <= (int)written_bytes_ptr) && ((uint)((int)processing_ptr - (int)buffer_ptr) < max_char_count)); // Loop until all characters are processed\n            goto LAB_1002266e; // Exit processing\n        }\n        if (file_type == '\\x02') { // If file type is special\n            WCHAR *processing_ptr = buffer_ptr; // Pointer for processing buffer\n            if (max_char_count != 0) {\n                do {\n                    uint processed_count = 0; // Counter for processed characters\n                    uint offset = (int)processing_ptr - (int)buffer_ptr; // Calculate offset\n                    WCHAR *output_ptr = output_buffer_start; // Pointer for writing output\n                    do {\n                        if (max_char_count <= offset) break; // Check bounds\n                        WCHAR *incremented_ptr = processing_ptr + 1; // Increment pointer\n                        wide_char_value = *processing_ptr; // Get current wide character\n                        offset += 2; // Increment offset for wide character\n                        if (wide_char_value == L'\\n') { // Check for newline\n                            newline_count += 2; // Increment newline count\n                            *output_ptr = L'\\r'; // Write carriage return\n                            output_ptr++; // Move to next position\n                            processed_count += 2; // Increment processed count\n                        }\n                        *output_ptr = wide_char_value; // Write wide character\n                        output_ptr++; // Move to next position\n                        processed_count += 2; // Increment processed count\n                        processing_ptr = incremented_ptr; // Move to next character\n                    } while (processed_count < 0x3ff); // Limit processing\n                    // Attempt to write the processed buffer to the file\n                    write_file_result = WriteFile(*(HANDLE *)(file_handle_index + *file_handle_ptr), output_buffer_start, (int)output_ptr - (int)output_buffer_start, (LPDWORD)&written_bytes_ptr, (LPOVERLAPPED)0x0);\n                    if (write_file_result == 0) goto LAB_10022665; // Check for write error\n                    written_bytes_ptr += (int)written_bytes_ptr; // Update written bytes count\n                } while (((int)output_ptr - (int)output_buffer_start <= (int)written_bytes_ptr) && ((uint)((int)processing_ptr - (int)buffer_ptr) < max_char_count)); // Loop until all characters are processed\n                goto LAB_1002266e; // Exit processing\n            }\n        }\n    } else {\n        WCHAR *local_processing_ptr = buffer_ptr; // Pointer for processing buffer\n        if (max_char_count != 0) {\n            do {\n                WCHAR *processing_ptr = (WCHAR *)0x0; // Local pointer for tracking\n                uint offset = (int)local_processing_ptr - (int)buffer_ptr; // Calculate offset\n                WCHAR *output_ptr = output_buffer; // Pointer for writing output\n                do {\n                    if (max_char_count <= offset) break; // Check bounds\n                    wide_char_value = *local_processing_ptr; // Get current wide character\n                    local_processing_ptr++; // Move to next character\n                    offset += 2; // Increment offset for wide character\n                    if (wide_char_value == L'\\n') { // Check for newline\n                        *output_ptr = L'\\r'; // Write carriage return\n                        output_ptr++; // Move to next position\n                        processing_ptr++; // Increment local pointer\n                    }\n                    processing_ptr++; // Increment local pointer\n                    *output_ptr = wide_char_value; // Write wide character\n                    output_ptr++; // Move to next position\n                } while (processing_ptr < (WCHAR *)0x152); // Limit processing\n                char *multi_byte_ptr = (char *)0x0; // Pointer for multi-byte conversion\n                conversion_result = WideCharToMultiByte(0xfde9, 0, output_buffer, ((int)output_ptr - (int)output_buffer) / 2, multi_byte_buffer, 0x2ab, (LPCSTR)0x0, (LPBOOL)0x0); // Convert wide characters to multi-byte\n                if (conversion_result == 0) goto LAB_10022665; // Check for conversion error\n                do {\n                    // Attempt to write the converted multi-byte data to the file\n                    write_file_result = WriteFile(*(HANDLE *)(file_handle_index + *file_handle_ptr), multi_byte_buffer + (int)multi_byte_ptr, conversion_result - (int)multi_byte_ptr, (LPDWORD)&written_bytes_ptr, (LPOVERLAPPED)0x0);\n                    if (write_file_result == 0) {\n                        write_error = GetLastError(); // Capture error if write fails\n                        break; // Exit loop on error\n                    }\n                    multi_byte_ptr += (int)written_bytes_ptr; // Update pointer for written bytes\n                } while ((int)multi_byte_ptr < conversion_result); // Loop until all bytes are written\n            } while ((conversion_result <= (int)multi_byte_ptr) && (written_bytes_ptr = (char *)((int)local_processing_ptr - (int)buffer_ptr), written_bytes_ptr < max_char_count)); // Loop until all characters are processed\n            goto LAB_1002266e; // Exit processing\n        }\n    }\nLAB_1002269f:\n    // Check for special end-of-file condition\n    if (((*(byte *)(file_handle_index + 4 + *file_handle_ptr) & 0x40) != 0) && (*(char *)buffer_ptr == '\\x1a')) goto LAB_100226d0; // Handle Ctrl+Z as EOF\n    *__errno() = 0x1c; // Set errno to write fault\n    goto LAB_100226d0; // Exit function\n\nLAB_10022678:\n    // Check if there was an error during write\n    if (write_error == 0) goto LAB_1002269f; // If no error, check for special conditions\n    uint uVar16 = 5; // Temporary variable for error handling\n    if (write_error != 5) {\n        __dosmaperr(write_error); // Map Windows error to DOS error\n        goto LAB_100226d0; // Exit function\n    }\n    *__errno() = 9; // Set errno to bad file number\n\nLAB_100226d0:\n    return ___security_check_cookie_4(security_cookie ^ (uint)security_cookie_value); // Return with security check\n}\n"}
{"Function Name": "FUN_100227b8", "Address": "100227b8", "Source Code": "\nvoid unlockFileHandle(void) // Function definition for FUN_100227b8\n{\n    // Unlock the file handle obtained from the memory address pointed to by the first integer at address 0\n    // The file handle is located at an offset of 8 bytes from that address\n    unlockHandle(*(int *)(*(int *)0 + 8));\n}\n"}
{"Function Name": "__getbuf", "Address": "100227c2", "Source Code": "\nvoid __cdecl __getbuf(FILE *fileStream) // Function to allocate a buffer for a FILE structure\n{\n    globalCounter++; // Increment a global or static counter\n\n    fileStream->_base = (char *)__malloc_crt(0x1000); // Allocate 4KB buffer for the file stream\n\n    if (fileStream->_base == (char *)0x0) { // Check if memory allocation failed\n        fileStream->_flag |= 4; // Set the error flag in the FILE structure\n        fileStream->_base = (char *)&fileStream->_charbuf; // Use a fallback character buffer\n        fileStream->_bufsiz = 2; // Set buffer size to 2 for the fallback\n    } else {\n        fileStream->_flag |= 8; // Set the buffer allocated flag in the FILE structure\n        fileStream->_bufsiz = 0x1000; // Set buffer size to 4KB\n    }\n\n    fileStream->_cnt = 0; // Initialize character count to 0\n    fileStream->_ptr = fileStream->_base; // Set the pointer to the start of the buffer\n}\n"}
{"Function Name": "__isatty", "Address": "10022806", "Source Code": "\nint __cdecl __isatty(int file_handle)\n{\n    // Check if the file handle is -2, indicating an invalid handle\n    if (file_handle == -2) {\n        // Set errno to 9 (invalid handle)\n        *get_errno() = 9;\n        return 0; // Return 0 indicating not a terminal\n    }\n    \n    // Check if the file handle is valid (greater than -1 and within bounds)\n    if ((-1 < file_handle) && ((uint)file_handle < max_file_handle)) {\n        // Retrieve the status of the file handle and check if it is a terminal\n        return *(byte *)((&file_status_array)[file_handle >> 5] + 4 + (file_handle & 0x1fU) * 0x28) & 0x40;\n    }\n    \n    // Set errno to 9 for invalid handle\n    *get_errno() = 9;\n    // Call invalid parameter handler with null parameters\n    handle_invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    return 0; // Return 0 indicating not a terminal\n}\n"}
{"Function Name": "__get_printf_count_output", "Address": "10022864", "Source Code": "\nint __cdecl __get_printf_count_output(void)\n{\n    // Compare the value of DAT_10036678 with the result of the bitwise OR operation\n    // between DAT_100345e0 and 1, and return the result as an unsigned integer.\n    return (uint)(comparisonValue == (bitwiseValue | 1));\n}\n"}
{"Function Name": "_wctomb_s", "Address": "100229d9", "Source Code": "\nerrno_t __cdecl _wctomb_s(int *sizeConverted, char *mbCh, rsize_t sizeInBytes, wchar_t wCh)\n{\n    // Call the internal function __wctomb_s_l to perform the wide character to multibyte conversion\n    // Pass a null locale (_locale_t) indicating the default locale\n    return __wctomb_s_l(sizeConverted, mbCh, sizeInBytes, wCh, (_locale_t)0x0);\n}\n"}
{"Function Name": "FUN_10022a95", "Address": "10022a95", "Source Code": "\nvoid __cdecl FUN_10022a95(undefined4 input_value)\n{\n    // Assign the value of param_1 to the global variable _DAT_1003667c\n    global_variable = input_value;\n}\n"}
{"Function Name": "_write_string", "Address": "10022ae9", "Source Code": "\nvoid __thiscall _write_string(void *char_pointer, int char_count)\n{\n    int *error_pointer;          // Pointer to an integer, likely used for error handling\n    int *errno_pointer;         // Pointer to an integer, used to access errno\n    int context_pointer;       // Unused variable, possibly a register or context pointer\n    \n    // Check if a specific condition is met based on the byte at offset 0xc and the integer at offset 8\n    if (((*(byte *)(context_pointer + 0xc) & 0x40) == 0) || (*(int *)(context_pointer + 8) != 0)) {\n        // Loop while param_1 is greater than 0\n        while (char_count > 0) {\n            char_count--;                       // Decrement the count of characters to write\n            _write_char(*char_pointer);             // Write the character pointed to by 'this'\n            char_pointer = (void *)((int)char_pointer + 2); // Move to the next character (assuming 2 bytes per character)\n            \n            // Check if an error occurred during writing\n            if (*error_pointer == -1) {\n                errno_pointer = __errno();          // Get the address of the errno variable\n                // If the error is not a specific error code (0x2a), exit the function\n                if (*errno_pointer != 0x2a) {\n                    return;\n                }\n                _write_char(L'?');           // Write a '?' character in case of an error\n            }\n        }\n    } else {\n        *error_pointer += char_count;                // If the condition is not met, increment the error count by param_1\n    }\n}\n"}
{"Function Name": "__woutput_l", "Address": "10022b38", "Source Code": "\nint __cdecl __woutput_l(FILE *_File, wchar_t *_Format, _locale_t _Locale, va_list _ArgList)\n{\n    int *errorPointer; // Pointer to an integer variable for error handling\n    uint currentChar; // Variable to hold the current character from the format string\n    int indexOrState; // Variable for index or state tracking\n    int formatOptions = 0; // Local variable for formatting options\n    int additionalState = 0; // Local variable for additional state\n    int *dynamicMemoryPointer1 = (int *)0x0; // Pointer for dynamic memory allocation\n    int *dynamicMemoryPointer2 = (int *)0x0; // Another pointer for dynamic memory allocation\n    int *dynamicMemoryPointer3 = (int *)0x0; // Pointer for dynamic memory allocation\n    wchar_t *nextChar; // Pointer to the next character in the format string\n    localeinfo_struct localeInfo; // Structure to hold locale information\n\n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, _Locale);\n    \n    // Check for null file or format string\n    if ((_File == (FILE *)0x0) || (_Format == (wchar_t *)0x0)) {\n        errorPointer = __errno(); // Get the error number pointer\n        *errorPointer = 0x16; // Set error code for invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        return 0; // Return 0 on error\n    }\n\n    // Process the format string\n    while ((currentChar = (uint)(ushort)*_Format) != 0) {\n        nextChar = _Format + 1; // Move to the next character in the format string\n        if (formatOptions < 0) break; // Break if local_40c is negative\n\n        // Determine the type of format specifier\n        if ((ushort)(currentChar + L'') < 0x59) {\n            currentChar = localeData[0x1002e3b8] & 0xf; // Update uVar5 based on locale\n        } else {\n            currentChar = 0; // Default case\n        }\n\n        // Switch case to handle different format specifiers\n        switch ((int)(char)(&DAT_1002e3d8)[currentChar * 8 + indexOrState] >> 4) {\n            case 0:\n                _write_char(*_Format); // Write a character directly\n                break;\n            case 1:\n                dynamicMemoryPointer1 = (int *)0xffffffff; // Set local_410 to a specific value\n                formatOptions = 0; // Reset local_40c\n                break;\n            case 2:\n                // Update local_40c based on the format specifier\n                if (localeData == (byte *)0x20) formatOptions |= 2;\n                else if (localeData == (byte *)0x23) formatOptions |= 0x80;\n                else if (localeData == (byte *)0x2b) formatOptions |= 1;\n                else if (localeData == (byte *)0x2d) formatOptions |= 4;\n                else if (localeData == (byte *)0x30) formatOptions |= 8;\n                break;\n            case 3:\n                // Handle '*' in format specifier\n                if (*_Format == L'*') {\n                    dynamicMemoryPointer1 = *(int **)_ArgList; // Get argument from va_list\n                    if ((int)dynamicMemoryPointer1 < 0) {\n                        formatOptions |= 4; // Set flag if negative\n                        dynamicMemoryPointer1 = (int *)-(int)dynamicMemoryPointer1; // Make positive\n                    }\n                } else {\n                    dynamicMemoryPointer1 = (int *)(localeData + (int)dynamicMemoryPointer1 * 10 + -0x30); // Update local_410\n                }\n                break;\n            case 4:\n                dynamicMemoryPointer1 = (int *)0x0; // Reset local_410\n                break;\n            case 5:\n                // Handle '*' in format specifier for another case\n                if (*_Format == L'*') {\n                    dynamicMemoryPointer1 = *(int **)_ArgList; // Get argument from va_list\n                    if ((int)dynamicMemoryPointer1 < 0) {\n                        dynamicMemoryPointer1 = (int *)0xffffffff; // Set to specific value if negative\n                    }\n                } else {\n                    dynamicMemoryPointer1 = (int *)(localeData + (int)dynamicMemoryPointer1 * 10 + -0x30); // Update local_410\n                }\n                break;\n            case 6:\n                // Handle specific locale cases\n                if (localeData == (byte *)0x49) {\n                    if ((*nextChar == L'6') && (_Format[2] == L'4')) {\n                        formatOptions |= 0x8000; // Set specific flag\n                    } else if ((*nextChar == L'3') && (_Format[2] == L'2')) {\n                        formatOptions &= 0xffff7fff; // Clear specific flag\n                    }\n                } else if (localeData == (byte *)0x68) {\n                    formatOptions |= 0x20; // Set flag for 'h'\n                } else if (localeData == (byte *)0x6c) {\n                    // Set flags based on 'l' or other characters\n                    if (*nextChar == L'l') {\n                        formatOptions |= 0x1000;\n                    } else {\n                        formatOptions |= 0x10;\n                    }\n                } else if (localeData == (byte *)0x77) {\n                    formatOptions |= 0x800; // Set flag for 'w'\n                }\n                break;\n            case 7:\n                // Handle additional formatting logic\n                if (localeData < (byte *)0x65) {\n                    if (localeData == (byte *)0x64) {\n                        formatOptions |= 0x40; // Set flag for 'd'\n                    }\n                    if ((formatOptions & 0x8000) == 0 && (formatOptions & 0x1000) == 0) {\n                        argumentPointer = (int **)((int)_ArgList + 4); // Update pointer for arguments\n                        if ((formatOptions & 0x20) == 0) {\n                            errorPointer = *(int **)_ArgList; // Get argument\n                            if ((formatOptions & 0x40) == 0) {\n                                nextArgumentPointer = (int *)0x0; // Default case\n                            } else {\n                                nextArgumentPointer = (int *)((int)errorPointer >> 0x1f); // Handle sign\n                            }\n                        } else {\n                            // Handle case for 'h' and 'l'\n                            if ((formatOptions & 0x40) == 0) {\n                                errorPointer = (int *)(uint)*(ushort *)_ArgList; // Get unsigned short argument\n                            } else {\n                                errorPointer = (int *)(int)*(short *)_ArgList; // Get signed short argument\n                            }\n                            nextArgumentPointer = (int *)((int)errorPointer >> 0x1f); // Handle sign\n                        }\n                    } else {\n                        errorPointer = *(int **)_ArgList; // Get argument\n                        nextArgumentPointer = *(int **)((int)_ArgList + 4); // Get next argument\n                        argumentPointer = (int **)((int)_ArgList + 8); // Update pointer for next argument\n                    }\n                    // Handle negative values and formatting\n                    if ((((formatOptions & 0x40) != 0) && ((int)nextArgumentPointer < 1)) && ((int)nextArgumentPointer < 0)) {\n                        errorPointer = (int *)-(int)errorPointer; // Make piVar4 positive\n                        nextArgumentPointer = (int *)-(int)((int)nextArgumentPointer + (uint)(errorPointer != (int *)0x0)); // Adjust piVar9\n                        formatOptions |= 0x100; // Set flag\n                    }\n                    if ((formatOptions & 0x9000) == 0) {\n                        nextArgumentPointer = (int *)0x0; // Reset piVar9\n                    }\n                    combinedValues = CONCAT44(nextArgumentPointer, errorPointer); // Combine values\n                    if ((int)dynamicMemoryPointer1 < 0) {\n                        dynamicMemoryPointer1 = (int *)0x1; // Set local_410 to 1 if negative\n                    } else {\n                        formatOptions &= 0xfffffff7; // Clear specific flag\n                        if (0x200 < (int)dynamicMemoryPointer1) {\n                            dynamicMemoryPointer1 = (int *)0x200; // Cap local_410\n                        }\n                    }\n                    if (((uint)errorPointer | (uint)nextArgumentPointer) == 0) {\n                        additionalState = 0; // Reset local_428\n                    }\n                    errorPointer = &local_209; // Initialize pointer for output\n                    while (true) {\n                        nextArgumentPointer = (int *)((int)dynamicMemoryPointer1 + -1); // Decrement local_410\n                        if (((int)dynamicMemoryPointer1 < 1) && (combinedValues == 0)) break; // Break if conditions met\n                        dynamicMemoryPointer1 = nextArgumentPointer; // Update local_410\n                        combinedValues = __aulldvrm((uint)combinedValues, (uint)((ulonglong)combinedValues >> 0x20), (uint)localeData, (int)localeData >> 0x1f); // Perform division\n                        indexOrState = extraout_ECX + 0x30; // Update index\n                        if (0x39 < indexOrState) {\n                            indexOrState += adjustmentValue; // Adjust based on local_44c\n                        }\n                        *(byte *)errorPointer = (byte)indexOrState; // Store result in output\n                        errorPointer = (int *)((int)errorPointer + -1); // Move pointer backwards\n                    }\n                    outputLength = (byte *)((int)&local_209 + -(int)errorPointer); // Calculate length of output\n                    dynamicMemoryPointer2 = (int *)((int)errorPointer + 1); // Update pointer for output\n                    dynamicMemoryPointer1 = nextArgumentPointer; // Update local_410\n                    // Handle special case for leading zeros\n                    if (((formatOptions & 0x200) != 0) && ((outputLength == (byte *)0x0 || (*(byte *)dynamicMemoryPointer2 != 0x30)))) {\n                        *(byte *)errorPointer = 0x30; // Set leading zero\n                        outputLength = (byte *)((int)&local_209 + -(int)errorPointer + 1); // Update length\n                        dynamicMemoryPointer2 = errorPointer; // Update pointer\n                    }\n                }\n                break;\n        }\n        _Format++; // Move to the next character in the format string\n    }\n\n    // Free allocated memory if necessary\n    if (dynamicMemoryPointer3 != (int *)0x0) {\n        _free(dynamicMemoryPointer3); // Free memory\n        dynamicMemoryPointer3 = (int *)0x0; // Reset pointer\n    }\n    return 0; // Return 0 at the end of the function\n}\n"}
{"Function Name": "FUN_10023523", "Address": "10023523", "Source Code": "\nvoid unlockFileHandleFunction(void) // Function definition\n{\n    // Dereference the pointer at address 0, then dereference that result to get an integer pointer\n    // Access the integer at offset 8 from that pointer and pass it to __unlock_fhandle\n    unlockFileHandle(*(int *)(*(int *)0 + 8));\n}\n"}
{"Function Name": "__itoa_s", "Address": "100236a7", "Source Code": "\nerrno_t __cdecl __itoa_s(int value, char *destinationBuffer, size_t bufferSize, int radix)\n{\n    // Call the helper function _xtoa_s_20 to convert the integer to a string\n    // Pass the destination buffer, size, radix, and a flag for negative values\n    return _xtoa_s_20(destinationBuffer, bufferSize, \n                      (radix == 10 && value < 0) ? 10 : radix, // Use radix 10 if value is negative and radix is 10\n                      (radix == 10 && value < 0) ? 1 : 0);    // Set flag for negative value if applicable\n}\n"}
{"Function Name": "__mbsnbcat_s", "Address": "100236cf", "Source Code": "\nerrno_t __cdecl __mbsnbcat_s(uchar *destinationBuffer, size_t destinationSize, uchar *sourceBuffer, size_t maxSourceCount)\n{\n    // Call the internal function __mbsnbcat_s_l with the provided parameters\n    // and a null locale pointer.\n    return __mbsnbcat_s_l(destinationBuffer, destinationSize, sourceBuffer, maxSourceCount, (_locale_t)0x0);\n}\n"}
{"Function Name": "__mbsnbcpy_s", "Address": "100236ea", "Source Code": "\nerrno_t __cdecl __mbsnbcpy_s(uchar *destinationBuffer, size_t destinationSize, uchar *sourceBuffer, size_t maxCount)\n{\n    // Call the internal function __mbsnbcpy_s_l to perform the copy operation\n    // Pass the destination buffer, size in bytes, source buffer, maximum count,\n    // and a null locale pointer (default locale)\n    return __mbsnbcpy_s_l(destinationBuffer, destinationSize, sourceBuffer, maxCount, (_locale_t)0x0);\n}\n"}
{"Function Name": "__get_osfhandle", "Address": "10023786", "Source Code": "\nintptr_t __cdecl __get_osfhandle(int file_handle)\n{\n    ulong *dos_error_ptr;        // Pointer to store the address of the DOS error number\n    int *errno_ptr;          // Pointer to store the address of the current errno\n    intptr_t *file_handle_ptr;     // Pointer to retrieve the file handle from the internal structure\n\n    // Check if the file handle is -2, which indicates an invalid handle\n    if (file_handle == -2) {\n        dos_error_ptr = ___doserrno();  // Get the address of the DOS error number\n        *dos_error_ptr = 0;             // Set DOS error number to 0\n        errno_ptr = __errno();      // Get the address of the current errno\n        *errno_ptr = 9;             // Set errno to 9 (invalid file handle)\n        return -1;               // Return -1 to indicate an error\n    }\n\n    // Check if the file handle is valid (non-negative and within bounds)\n    if ((-1 < file_handle) && ((uint)file_handle < DAT_1003668c) &&\n        (file_handle_ptr = (intptr_t *)((file_handle & 0x1fU) * 0x28 + (&DAT_100366a0)[file_handle >> 5]),\n        (*(byte *)(file_handle_ptr + 1) & 1) != 0)) {\n        return *file_handle_ptr;         // Return the valid file handle\n    }\n\n    // Handle the case where the file handle is invalid\n    dos_error_ptr = ___doserrno();  // Get the address of the DOS error number\n    *dos_error_ptr = 0;             // Set DOS error number to 0\n    errno_ptr = __errno();      // Get the address of the current errno\n    *errno_ptr = 9;             // Set errno to 9 (invalid file handle)\n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to report invalid parameter\n    return -1;               // Return -1 to indicate an error\n}\n"}
{"Function Name": "___lock_fhandle", "Address": "100237f7", "Source Code": "\nint __cdecl ___lock_fhandle(int fileHandle)\n{\n    int index; // Variable to hold the calculated index for the file handle\n    uint successFlag = 1; // Flag to indicate success or failure of locking\n\n    // Calculate the index for the critical section based on the file handle\n    index = (fileHandle & 0x1fU) * 0x28 + (&DAT_100366a0)[fileHandle >> 5];\n    \n    // Check if the critical section is already initialized\n    if (*(int *)(index + 8) == 0) {\n        __lock(10); // Lock the resource to ensure thread safety\n        // Check again if the critical section is still uninitialized\n        if (*(int *)(index + 8) == 0) {\n            // Initialize the critical section with a spin count of 4000\n            if (___crtInitCritSecAndSpinCount(index + 0xc, 4000) != 0) {\n                *(int *)(index + 8)++; // Mark the critical section as initialized\n            } else {\n                successFlag = 0; // Set failure flag if initialization fails\n            }\n        }\n        FUN_1002388e(); // Call a function (possibly for additional setup)\n    }\n    \n    // If initialization was successful, enter the critical section\n    if (successFlag != 0) {\n        EnterCriticalSection((LPCRITICAL_SECTION)((&DAT_100366a0)[fileHandle >> 5] + 0xc + (fileHandle & 0x1fU) * 0x28));\n    }\n    \n    return successFlag; // Return the success or failure flag\n}\n"}
{"Function Name": "FUN_1002388e", "Address": "1002388e", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_1002388e\n{\n    processValue(10); // Call the function FUN_10016973 with an argument of 10\n}\n"}
{"Function Name": "__unlock_fhandle", "Address": "10023897", "Source Code": "\nvoid __cdecl __unlock_fhandle(int fileHandle)\n{\n    // Leave the critical section associated with the specified file handle\n    LeaveCriticalSection((LPCRITICAL_SECTION)((&DAT_100366a0)[fileHandle >> 5] + 0xc + (fileHandle & 0x1fU) * 0x28));\n}\n"}
{"Function Name": "_mbtowc", "Address": "100239cc", "Source Code": "\nint __cdecl _mbtowc(wchar_t *destinationWideChar, char *sourceMultiByteChar, size_t sourceSizeInBytes)\n{\n    // Call the __mbtowc_l function to convert a multibyte character to a wide character\n    // _DstCh: pointer to the destination wide character\n    // _SrcCh: pointer to the source multibyte character\n    // _SrcSizeInBytes: size of the source multibyte character in bytes\n    // (_locale_t)0x0: passing a null locale, indicating the default locale\n    return __mbtowc_l(destinationWideChar, sourceMultiByteChar, sourceSizeInBytes, (_locale_t)0x0);\n}\n"}
{"Function Name": "FID_conflict:__ld12tod", "Address": "100239e3", "Source Code": "\nINTRNCVT_STATUS __cdecl FID_conflict___ld12tod(_LDBL12 *_Ifp,_CRT_DOUBLE *_D)\n{\n    _LDBL12 *pointerToLDBL12; // Pointer to a _LDBL12 variable\n    undefined4 tempValue; // Temporary variable to hold a 4-byte value\n    int loopCounter; // Integer variable for loop control and calculations\n    INTRNCVT_STATUS returnStatus; // Status variable for return value\n    int secondaryLoopCounter; // Integer variable for loop control\n    byte bitPosition; // Byte variable for bit manipulation\n    uint unsignedCalcValue; // Unsigned integer variable for calculations\n    uint partOfIfp; // Unsigned integer variable for storing part of _Ifp\n    int calculationValue; // Integer variable for calculations\n    bool conditionCheck; // Boolean variable for condition checks\n    _LDBL12 *localPointersArray[2]; // Local array to hold pointers to _LDBL12\n    uint localCalcValue; // Local variable for calculations\n    uint localSecondaryCalcValue; // Local variable for calculations\n    _LDBL12 *localPointer; // Local pointer to _LDBL12\n\n    // Initialize local variables with values from _Ifp\n    localPointersArray[0] = *(_LDBL12 **)(_Ifp->ld12 + 6);\n    tempValue = *(undefined4 *)(_Ifp->ld12 + 2);\n    partOfIfp = *(ushort *)(_Ifp->ld12 + 10) & 0x7fff;\n    calculationValue = partOfIfp - 0x3fff;\n    loopCounter = (uint)*(ushort *)_Ifp->ld12 << 0x10;\n    localPointersArray[1] = (_LDBL12 *)tempValue;\n\n    // Check for special case of zero\n    if (calculationValue == -0x3fff) {\n        for (loopCounter = 0; loopCounter < 3; loopCounter++) {\n            if (localPointersArray[loopCounter] != (_LDBL12 *)0x0) {\n                localPointersArray[0] = (_LDBL12 *)0x0; // Set first pointer to null\n                localPointersArray[1] = (_LDBL12 *)0x0; // Set second pointer to null\n                return INTRNCVT_UNDERFLOW; // Return underflow status\n            }\n        }\n        return INTRNCVT_OK; // Return OK status\n    } else {\n        // Calculate index and bit position for further processing\n        secondaryLoopCounter = (DAT_10035708 - 1) >> 5;\n        unsignedCalcValue = DAT_10035708 & 0x8000001f;\n        if ((int)unsignedCalcValue < 0) {\n            unsignedCalcValue = (unsignedCalcValue - 1 | 0xffffffe0) + 1; // Adjust uVar10 if negative\n        }\n        bitPosition = (byte)(0x1f - unsignedCalcValue); // Calculate bit position\n        localCalcValue = calculationValue; // Store iVar14 in local_14\n\n        // Check if the bit at the calculated position is set\n        if (((uint)localPointersArray[secondaryLoopCounter] & 1 << (bitPosition & 0x1f)) != 0) {\n            _LDBL12 *p_Var12 = (_LDBL12 *)((uint)localPointersArray[secondaryLoopCounter] & ~(-1 << (bitPosition & 0x1f)));\n            while (true) {\n                if (p_Var12 != (_LDBL12 *)0x0) {\n                    secondaryLoopCounter = (DAT_10035708 - 1) >> 5; // Recalculate index\n                    localPointer = (_LDBL12 *)0x0; // Initialize local_8\n                    undefined *puVar11 = (undefined *)(1 << (0x1f - ((byte)(DAT_10035708 - 1) & 0x1f))); // Calculate pointer adjustment\n                    _LDBL12 **pp_Var8 = localPointersArray + secondaryLoopCounter; // Pointer to current location in local_24\n                    _Ifp = (_LDBL12 *)((*pp_Var8)->ld12 + (int)puVar11); // Update _Ifp\n                    if (_Ifp < *pp_Var8) goto LAB_10023b16; // Check bounds\n                    conditionCheck = _Ifp < puVar11; // Check condition for loop\n                    do {\n                        localPointer = (_LDBL12 *)0x0; // Reset local_8\n                        if (!conditionCheck) goto LAB_10023b1d; // If condition not met, jump\n                    LAB_10023b16:\n                        do {\n                            localPointer = (_LDBL12 *)0x1; // Set local_8 to 1\n                        LAB_10023b1d:\n                            secondaryLoopCounter--; // Decrement index\n                            *pp_Var8 = _Ifp; // Update pointer\n                            if (secondaryLoopCounter < 0 || localPointer == (_LDBL12 *)0x0) {\n                                _Ifp = localPointer; // Update _Ifp\n                                goto LAB_10023b2b; // Jump to cleanup\n                            }\n                            pp_Var8 = localPointersArray + secondaryLoopCounter; // Move to previous pointer\n                            _Ifp = (_LDBL12 *)((*pp_Var8)->ld12 + 1); // Increment _Ifp\n                        } while (_Ifp < *pp_Var8); // Continue while within bounds\n                        conditionCheck = _Ifp == (_LDBL12 *)0x0; // Check if _Ifp is null\n                    } while (true); // Infinite loop until break condition\n                }\n                secondaryLoopCounter++; // Increment index\n                if (secondaryLoopCounter > 2) break; // Break if index exceeds limit\n                p_Var12 = localPointersArray[secondaryLoopCounter]; // Move to next pointer\n            }\n        }\n    }\nLAB_10023b2b:\n    *localPointersArray[secondaryLoopCounter] = (_LDBL12 *)((uint)*localPointersArray[secondaryLoopCounter] & -1 << (bitPosition & 0x1f)); // Clear the bit at bVar7\n    secondaryLoopCounter++; // Increment index\n    if (secondaryLoopCounter < 3) {\n        for (int i = 3 - secondaryLoopCounter; i != 0; i--) {\n            localPointersArray[secondaryLoopCounter++] = (_LDBL12 *)0x0; // Set remaining pointers to null\n        }\n    }\n    if (_Ifp != (_LDBL12 *)0x0) {\n        calculationValue = partOfIfp - 0x3ffe; // Adjust iVar14 based on uVar13\n    }\n    if (calculationValue < (int)(DAT_10035704 - DAT_10035708)) {\n        localPointersArray[0] = (_LDBL12 *)0x0; // Set first pointer to null\n        localPointersArray[1] = (_LDBL12 *)0x0; // Set second pointer to null\n    } else {\n        if (DAT_10035704 < calculationValue) {\n            if (calculationValue < DAT_10035700) {\n                localPointersArray[0] = (_LDBL12 *)((uint)localPointersArray[0] & 0x7fffffff); // Clear sign bit\n                calculationValue += DAT_10035714; // Adjust iVar14\n                loopCounter = (int)(DAT_1003570c + ((int)DAT_1003570c >> 0x1f & 0x1fU)) >> 5; // Calculate index\n                partOfIfp = DAT_1003570c & 0x8000001f; // Get part of DAT_1003570c\n                if ((int)partOfIfp < 0) {\n                    partOfIfp = (partOfIfp - 1 | 0xffffffe0) + 1; // Adjust if negative\n                }\n                localSecondaryCalcValue = 0; // Initialize local_10\n                _Ifp = (_LDBL12 *)0x0; // Initialize _Ifp\n                localPointer = (_LDBL12 *)(0x20 - partOfIfp); // Calculate limit\n                do {\n                    uint localCalcValue = (uint)localPointersArray[(int)_Ifp] & ~(-1 << ((byte)partOfIfp & 0x1f)); // Clear bits\n                    localPointersArray[(int)_Ifp] = (_LDBL12 *)((uint)localPointersArray[(int)_Ifp] >> ((byte)partOfIfp & 0x1f) | localSecondaryCalcValue); // Shift and combine\n                    _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to next pointer\n                    localSecondaryCalcValue = localCalcValue << ((byte)(0x20 - partOfIfp) & 0x1f); // Update local_10\n                } while ((int)_Ifp < 3); // Continue until all pointers processed\n                secondaryLoopCounter = 2; // Set index for next loop\n                _LDBL12 **pp_Var9 = localPointersArray + (2 - loopCounter); // Pointer for copying\n                do {\n                    if (secondaryLoopCounter < loopCounter) {\n                        localPointersArray[secondaryLoopCounter] = (_LDBL12 *)0x0; // Set to null if index is less\n                    } else {\n                        localPointersArray[secondaryLoopCounter] = *pp_Var9; // Copy pointer\n                    }\n                    secondaryLoopCounter--; // Decrement index\n                    pp_Var9--; // Move to previous pointer\n                } while (secondaryLoopCounter >= 0); // Continue until all pointers processed\n                returnStatus = INTRNCVT_OK; // Set return status to OK\n            } else {\n                localPointersArray[1] = (_LDBL12 *)0x0; // Set second pointer to null\n                localPointersArray[0] = (_LDBL12 *)0x80000000; // Set first pointer to a specific value\n                calculationValue = (int)(DAT_1003570c + ((int)DAT_1003570c >> 0x1f & 0x1fU)) >> 5; // Calculate index\n                partOfIfp = DAT_1003570c & 0x8000001f; // Get part of DAT_1003570c\n                if ((int)partOfIfp < 0) {\n                    partOfIfp = (partOfIfp - 1 | 0xffffffe0) + 1; // Adjust if negative\n                }\n                localSecondaryCalcValue = 0; // Initialize local_10\n                _Ifp = (_LDBL12 *)0x0; // Initialize _Ifp\n                localPointer = (_LDBL12 *)(0x20 - partOfIfp); // Calculate limit\n                do {\n                    pointerToLDBL12 = localPointersArray[(int)_Ifp]; // Get current pointer\n                    uint localCalcValue = (uint)pointerToLDBL12 & ~(-1 << ((byte)partOfIfp & 0x1f)); // Clear bits\n                    localPointersArray[(int)_Ifp] = (_LDBL12 *)((uint)pointerToLDBL12 >> ((byte)partOfIfp & 0x1f) | localSecondaryCalcValue); // Shift and combine\n                    _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to next pointer\n                    localSecondaryCalcValue = localCalcValue << ((byte)(0x20 - partOfIfp) & 0x1f); // Update local_10\n                } while ((int)_Ifp < 3); // Continue until all pointers processed\n                loopCounter = 2; // Set index for next loop\n                _LDBL12 **pp_Var9 = localPointersArray + (2 - calculationValue); // Pointer for copying\n                do {\n                    if (loopCounter < calculationValue) {\n                        localPointersArray[loopCounter] = (_LDBL12 *)0x0; // Set to null if index is less\n                    } else {\n                        localPointersArray[loopCounter] = *pp_Var9; // Copy pointer\n                    }\n                    loopCounter--; // Decrement index\n                    pp_Var9--; // Move to previous pointer\n                } while (loopCounter >= 0); // Continue until all pointers processed\n                calculationValue = DAT_10035714 + DAT_10035700; // Adjust iVar14 for overflow\n                returnStatus = INTRNCVT_OVERFLOW; // Set return status to overflow\n            }\n            goto LAB_10023ee2; // Jump to cleanup\n        }\n        localCalcValue = DAT_10035704 - localCalcValue; // Calculate remaining value\n        localPointersArray[0] = pointerToLDBL12; // Set first pointer\n        localPointersArray[1] = (_LDBL12 *)tempValue; // Set second pointer\n        calculationValue = (int)(localCalcValue + ((int)localCalcValue >> 0x1f & 0x1fU)) >> 5; // Calculate index\n        partOfIfp = localCalcValue & 0x8000001f; // Get part of local_14\n        if ((int)partOfIfp < 0) {\n            partOfIfp = (partOfIfp - 1 | 0xffffffe0) + 1; // Adjust if negative\n        }\n        localSecondaryCalcValue = 0; // Initialize local_10\n        _Ifp = (_LDBL12 *)0x0; // Initialize _Ifp\n        localPointer = (_LDBL12 *)(0x20 - partOfIfp); // Calculate limit\n        do {\n            pointerToLDBL12 = localPointersArray[(int)_Ifp]; // Get current pointer\n            uint localCalcValue = (uint)pointerToLDBL12 & ~(-1 << ((byte)partOfIfp & 0x1f)); // Clear bits\n            localPointersArray[(int)_Ifp] = (_LDBL12 *)((uint)pointerToLDBL12 >> ((byte)partOfIfp & 0x1f) | localSecondaryCalcValue); // Shift and combine\n            _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to next pointer\n            localSecondaryCalcValue = localCalcValue << ((byte)(0x20 - partOfIfp) & 0x1f); // Update local_10\n        } while ((int)_Ifp < 3); // Continue until all pointers processed\n        loopCounter = 2; // Set index for next loop\n        _LDBL12 **pp_Var9 = localPointersArray + (2 - calculationValue); // Pointer for copying\n        do {\n            if (loopCounter < calculationValue) {\n                localPointersArray[loopCounter] = (_LDBL12 *)0x0; // Set to null if index is less\n            } else {\n                localPointersArray[loopCounter] = *pp_Var9; // Copy pointer\n            }\n            loopCounter--; // Decrement index\n            pp_Var9--; // Move to previous pointer\n        } while (loopCounter >= 0); // Continue until all pointers processed\n        loopCounter = DAT_10035708 - 1; // Set index for next loop\n        calculationValue = (int)(DAT_10035708 + ((int)DAT_10035708 >> 0x1f & 0x1fU)) >> 5; // Calculate index\n        partOfIfp = DAT_10035708 & 0x8000001f; // Get part of DAT_10035708\n        localSecondaryCalcValue = calculationValue; // Store index in local_10\n        if ((int)partOfIfp < 0) {\n            partOfIfp = (partOfIfp - 1 | 0xffffffe0) + 1; // Adjust if negative\n        }\n        bitPosition = (byte)(0x1f - partOfIfp); // Calculate bit position\n        _LDBL12 **pp_Var9 = localPointersArray + calculationValue; // Pointer for current location\n        localCalcValue = 0x1f - partOfIfp; // Calculate remaining bits\n        if (((uint)*pp_Var9 & 1 << (bitPosition & 0x1f)) != 0) {\n            pointerToLDBL12 = (_LDBL12 *)((uint)localPointersArray[calculationValue] & ~(-1 << (bitPosition & 0x1f))); // Clear bit\n            while (pointerToLDBL12 == (_LDBL12 *)0x0) {\n                calculationValue++; // Increment index\n                if (calculationValue > 2) goto LAB_10023cce; // Break if out of bounds\n                pointerToLDBL12 = localPointersArray[calculationValue]; // Move to next pointer\n            }\n            calculationValue = (int)(loopCounter + (loopCounter >> 0x1f & 0x1fU)) >> 5; // Calculate index\n            conditionCheck = false; // Initialize boolean flag\n            _LDBL12 *p_Var12 = (_LDBL12 *)(1 << (0x1f - ((byte)loopCounter & 0x1f) & 0x1f)); // Calculate bit mask\n            pointerToLDBL12 = localPointersArray[calculationValue]; // Get current pointer\n            uchar *puVar1 = p_Var12->ld12 + (int)pointerToLDBL12->ld12; // Calculate new pointer\n            if ((puVar1 < pointerToLDBL12) || (puVar1 < p_Var12)) {\n                conditionCheck = true; // Set flag if out of bounds\n            }\n            localPointersArray[calculationValue] = (_LDBL12 *)puVar1; // Update pointer\n            while ((calculationValue = calculationValue - 1, calculationValue >= 0 && conditionCheck)) {\n                pointerToLDBL12 = localPointersArray[calculationValue]; // Get current pointer\n                puVar1 = pointerToLDBL12->ld12 + 1; // Increment pointer\n                conditionCheck = false; // Reset flag\n                if ((puVar1 < pointerToLDBL12) || (puVar1 == (uchar *)0x0)) {\n                    conditionCheck = true; // Set flag if out of bounds\n                }\n                localPointersArray[calculationValue] = (_LDBL12 *)puVar1; // Update pointer\n            }\n        }\n    }\nLAB_10023cce:\n    *pp_Var9 = (_LDBL12 *)((uint)*pp_Var9 & -1 << ((byte)localCalcValue & 0x1f)); // Clear bits in the pointer\n    calculationValue = localSecondaryCalcValue + 1; // Increment index\n    if (calculationValue < 3) {\n        pp_Var9 = localPointersArray + calculationValue; // Pointer for remaining pointers\n        for (loopCounter = 3 - calculationValue; loopCounter != 0; loopCounter--) {\n            *pp_Var9++ = (_LDBL12 *)0x0; // Set remaining pointers to null\n        }\n    }\n    partOfIfp = DAT_1003570c + 1; // Increment DAT_1003570c\n    calculationValue = (int)(partOfIfp + ((int)partOfIfp >> 0x1f & 0x1fU)) >> 5; // Calculate index\n    partOfIfp = partOfIfp & 0x8000001f; // Get part of uVar13\n    if ((int)partOfIfp < 0) {\n        partOfIfp = (partOfIfp - 1 | 0xffffffe0) + 1; // Adjust if negative\n    }\n    localSecondaryCalcValue = 0; // Initialize local_10\n    _Ifp = (_LDBL12 *)0x0; // Initialize _Ifp\n    localPointer = (_LDBL12 *)(0x20 - partOfIfp); // Calculate limit\n    do {\n        pointerToLDBL12 = localPointersArray[(int)_Ifp]; // Get current pointer\n        uint localCalcValue = (uint)pointerToLDBL12 & ~(-1 << ((byte)partOfIfp & 0x1f)); // Clear bits\n        localPointersArray[(int)_Ifp] = (_LDBL12 *)((uint)pointerToLDBL12 >> ((byte)partOfIfp & 0x1f) | localSecondaryCalcValue); // Shift and combine\n        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to next pointer\n        localSecondaryCalcValue = localCalcValue << ((byte)(0x20 - partOfIfp) & 0x1f); // Update local_10\n    } while ((int)_Ifp < 3); // Continue until all pointers processed\n    loopCounter = 2; // Set index for next loop\n    _LDBL12 **pp_Var9 = localPointersArray + (2 - calculationValue); // Pointer for copying\n    do {\n        if (loopCounter < calculationValue) {\n            localPointersArray[loopCounter] = (_LDBL12 *)0x0; // Set to null if index is less\n        } else {\n            localPointersArray[loopCounter] = *pp_Var9; // Copy pointer\n        }\n        loopCounter--; // Decrement index\n        pp_Var9--; // Move to previous pointer\n    } while (loopCounter >= 0); // Continue until all pointers processed\n    return returnStatus; // Return the status\n}\n"}
{"Function Name": "FID_conflict:__ld12tod", "Address": "10023f25", "Source Code": "\nINTRNCVT_STATUS __cdecl FID_conflict___ld12tod(_LDBL12 *_Ifp, _CRT_DOUBLE *_D) {\n    _LDBL12 *pointerToLDBL12; // Pointer to a _LDBL12 variable\n    undefined4 tempData; // Temporary variable for storing data\n    int loopIndex; // Loop index variable\n    INTRNCVT_STATUS status; // Status variable for return value\n    int localArrayIndex; // Index variable for local_24 array\n    byte tempByte; // Temporary byte variable\n    uint tempUnsignedInt; // Temporary unsigned integer variable\n    uint anotherTempUnsignedInt; // Another temporary unsigned integer variable\n    int calculationVar; // Variable for calculations\n    _LDBL12 *pointerArray[2]; // Array to hold pointers to _LDBL12\n    uint partOfIfp; // Local variable for storing a part of _Ifp\n\n    // Extract the exponent part from _Ifp and mask it\n    partOfIfp = *(ushort *)(_Ifp->ld12 + 10) & 0x7fff;\n    // Get the pointer from _Ifp\n    pointerToLDBL12 = *(_LDBL12 **)(_Ifp->ld12 + 6);\n    pointerArray[0] = pointerToLDBL12; // Store the pointer in local_24\n    tempData = *(undefined4 *)(_Ifp->ld12 + 2); // Get another part of _Ifp\n    calculationVar = partOfIfp - 0x3fff; // Calculate the adjusted exponent\n    loopIndex = (uint)*(ushort *)_Ifp->ld12 << 0x10; // Shift the value for further calculations\n    pointerArray[1] = (_LDBL12 *)tempData; // Store the second part in local_24\n\n    // Check if the exponent is equal to -0x3fff\n    if (calculationVar == -0x3fff) {\n        calculationVar = 0; // Reset iVar14\n        loopIndex = 0; // Reset iVar4\n        do {\n            // Check if the current pointer in local_24 is not null\n            if (pointerArray[loopIndex] != (_LDBL12 *)0x0) {\n                pointerArray[0] = (_LDBL12 *)0x0; // Set first pointer to null\n                pointerArray[1] = (_LDBL12 *)0x0; // Set second pointer to null\n                status = INTRNCVT_UNDERFLOW; // Set status to underflow\n                goto LAB_10024424; // Jump to the end\n            }\n            loopIndex++; // Increment loop index\n        } while (loopIndex < 3); // Loop until 3\n        status = INTRNCVT_OK; // Set status to OK\n    } else {\n        _Ifp = (_LDBL12 *)0x0; // Reset _Ifp to null\n        localArrayIndex = (DAT_10035720 - 1) >> 5; // Calculate index based on DAT_10035720\n        tempUnsignedInt = DAT_10035720 & 0x8000001f; // Mask DAT_10035720\n        // Adjust uVar10 if it's negative\n        if ((int)tempUnsignedInt < 0) {\n            tempUnsignedInt = (tempUnsignedInt - 1 | 0xffffffe0) + 1;\n        }\n        tempByte = (byte)(0x1f - tempUnsignedInt); // Calculate the bit position\n        // Check if the bit at the calculated position is set\n        if (((uint)pointerArray[localArrayIndex] & 1 << (tempByte & 0x1f)) != 0) {\n            _LDBL12 *p_Var12 = (_LDBL12 *)((uint)pointerArray[localArrayIndex] & ~(-1 << (tempByte & 0x1f))); // Clear the bit\n            while (true) {\n                // Check if p_Var12 is not null\n                if (p_Var12 != (_LDBL12 *)0x0) {\n                    localArrayIndex = (DAT_10035720 - 1) >> 5; // Reset index\n                    _Ifp = (_LDBL12 *)0x0; // Reset _Ifp to null\n                    do {\n                        pointerArray[localArrayIndex] = _Ifp; // Set local_24 to null\n                        localArrayIndex--; // Decrement index\n                    } while (localArrayIndex >= 0); // Loop until index is negative\n                    goto LAB_1002406d; // Jump to the next section\n                }\n                localArrayIndex++; // Increment index\n                if (2 < localArrayIndex) break; // Break if index exceeds 2\n                p_Var12 = pointerArray[localArrayIndex]; // Update p_Var12\n            }\n        }\nLAB_1002406d:\n        // Clear the bit in local_24\n        pointerArray[localArrayIndex] = (_LDBL12 *)((uint)pointerArray[localArrayIndex] & -1 << (tempByte & 0x1f));\n        localArrayIndex++; // Increment index\n        // Fill remaining local_24 with null pointers if needed\n        if (localArrayIndex < 3) {\n            for (calculationVar = 3 - localArrayIndex; calculationVar != 0; calculationVar--) {\n                pointerArray[localArrayIndex++] = (_LDBL12 *)0x0; // Set to null\n            }\n        }\n        // Check if _Ifp is not null\n        if (_Ifp != (_LDBL12 *)0x0) {\n            calculationVar = partOfIfp - 0x3ffe; // Adjust iVar14\n        }\n        // Check if iVar14 is within bounds\n        if (calculationVar < (int)(DAT_1003571c - DAT_10035720)) {\n            pointerArray[0] = (_LDBL12 *)0x0; // Set first pointer to null\n            pointerArray[1] = (_LDBL12 *)0x0; // Set second pointer to null\n        } else {\n            // Handle cases based on the value of iVar14\n            if (DAT_1003571c < calculationVar) {\n                if (calculationVar < DAT_10035718) {\n                    pointerArray[0] = (_LDBL12 *)((uint)pointerArray[0] & 0x7fffffff); // Clear sign bit\n                    calculationVar += DAT_1003572c; // Adjust iVar14\n                    loopIndex = (DAT_10035724 + ((int)DAT_10035724 >> 0x1f & 0x1fU)) >> 5; // Calculate index\n                    anotherTempUnsignedInt = DAT_10035724 & 0x8000001f; // Mask DAT_10035724\n                    // Adjust uVar13 if negative\n                    if ((int)anotherTempUnsignedInt < 0) {\n                        anotherTempUnsignedInt = (anotherTempUnsignedInt - 1 | 0xffffffe0) + 1;\n                    }\n                    partOfIfp = 0; // Reset local_10\n                    _Ifp = (_LDBL12 *)0x0; // Reset _Ifp to null\n                    do {\n                        // Shift and combine values into local_24\n                        pointerArray[(int)_Ifp] = (_LDBL12 *)((uint)pointerArray[(int)_Ifp] >> ((byte)anotherTempUnsignedInt & 0x1f) | partOfIfp);\n                        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to the next pointer\n                    } while ((int)_Ifp < 3); // Loop until 3\n                    localArrayIndex = 2; // Set index for clearing\n                    do {\n                        pointerArray[localArrayIndex] = (_LDBL12 *)0x0; // Clear local_24\n                        localArrayIndex--; // Decrement index\n                    } while (localArrayIndex >= 0); // Loop until index is negative\n                    status = INTRNCVT_OK; // Set status to OK\n                } else {\n                    pointerArray[1] = (_LDBL12 *)0x0; // Set second pointer to null\n                    pointerArray[0] = (_LDBL12 *)0x80000000; // Set first pointer to a specific value\n                    calculationVar = (int)(DAT_10035724 + ((int)DAT_10035724 >> 0x1f & 0x1fU)) >> 5; // Calculate index\n                    anotherTempUnsignedInt = DAT_10035724 & 0x8000001f; // Mask DAT_10035724\n                    // Adjust uVar13 if negative\n                    if ((int)anotherTempUnsignedInt < 0) {\n                        anotherTempUnsignedInt = (anotherTempUnsignedInt - 1 | 0xffffffe0) + 1;\n                    }\n                    partOfIfp = 0; // Reset local_10\n                    _Ifp = (_LDBL12 *)0x0; // Reset _Ifp to null\n                    do {\n                        // Shift and combine values into local_24\n                        pointerArray[(int)_Ifp] = (_LDBL12 *)((uint)pointerArray[(int)_Ifp] >> ((byte)anotherTempUnsignedInt & 0x1f) | partOfIfp);\n                        _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to the next pointer\n                    } while ((int)_Ifp < 3); // Loop until 3\n                    loopIndex = 2; // Set index for clearing\n                    do {\n                        pointerArray[loopIndex] = (_LDBL12 *)0x0; // Clear local_24\n                        loopIndex--; // Decrement index\n                    } while (loopIndex >= 0); // Loop until index is negative\n                    calculationVar = DAT_1003572c + DAT_10035718; // Adjust iVar14\n                    status = INTRNCVT_OVERFLOW; // Set status to overflow\n                }\n                goto LAB_10024424; // Jump to the end\n            }\n            partOfIfp = DAT_1003571c - partOfIfp; // Calculate local_10\n            pointerArray[0] = pointerToLDBL12; // Restore first pointer\n            pointerArray[1] = (_LDBL12 *)tempData; // Restore second pointer\n            calculationVar = (int)(partOfIfp + ((int)partOfIfp >> 0x1f & 0x1fU)) >> 5; // Calculate index\n            anotherTempUnsignedInt = partOfIfp & 0x8000001f; // Mask local_10\n            // Adjust uVar13 if negative\n            if ((int)anotherTempUnsignedInt < 0) {\n                anotherTempUnsignedInt = (anotherTempUnsignedInt - 1 | 0xffffffe0) + 1;\n            }\n            partOfIfp = 0; // Reset local_10\n            _Ifp = (_LDBL12 *)0x0; // Reset _Ifp to null\n            do {\n                // Shift and combine values into local_24\n                pointerArray[(int)_Ifp] = (_LDBL12 *)((uint)pointerArray[(int)_Ifp] >> ((byte)anotherTempUnsignedInt & 0x1f) | partOfIfp);\n                _Ifp = (_LDBL12 *)(_Ifp->ld12 + 1); // Move to the next pointer\n            } while ((int)_Ifp < 3); // Loop until 3\n            loopIndex = 2; // Set index for clearing\n            do {\n                pointerArray[loopIndex] = (_LDBL12 *)0x0; // Clear local_24\n                loopIndex--; // Decrement index\n            } while (loopIndex >= 0); // Loop until index is negative\n        }\n        calculationVar = 0; // Reset iVar14\n        status = INTRNCVT_UNDERFLOW; // Set status to underflow\n    }\nLAB_10024424:\n    // Combine results into uVar13 for final output\n    anotherTempUnsignedInt = calculationVar << (0x1fU - (char)DAT_10035724 & 0x1f) | -(uint)(partOfIfp != 0) & 0x80000000 | (uint)pointerArray[0];\n    // Check the value of DAT_10035728 to determine how to store the result\n    if (DAT_10035728 == 0x40) {\n        *(uint *)((int)&_D->x + 4) = anotherTempUnsignedInt; // Store in the upper part of _D\n        *(_LDBL12 **)&_D->x = pointerArray[1]; // Store second pointer in _D\n    } else if (DAT_10035728 == 0x20) {\n        *(uint *)&_D->x = anotherTempUnsignedInt; // Store in the lower part of _D\n    }\n    return status; // Return the status\n}\n"}
{"Function Name": "___mtold12", "Address": "10024467", "Source Code": "\nvoid __cdecl ___mtold12(char *input_string, int char_count, uint *result_array)\n{\n    uint temp_value1, temp_value2, temp_value3, temp_value4, temp_value5; // Variable declarations for intermediate calculations\n    short exponent = 0x404e; // Initialize a short variable for exponent or shift value\n    uint security_cookie = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Security cookie for stack protection\n\n    *result_array = 0; // Initialize the first element of param_3 to 0\n    result_array[1] = 0; // Initialize the second element of param_3 to 0\n    result_array[2] = 0; // Initialize the third element of param_3 to 0\n\n    if (char_count != 0) { // Check if there are characters to process\n        do {\n            temp_value2 = *result_array; // Get the current value of the first element of param_3\n            temp_value1 = result_array[1]; // Get the current value of the second element of param_3\n            temp_value5 = result_array[2]; // Get the current value of the third element of param_3\n            temp_value3 = temp_value2 * 4; // Calculate four times the first element of param_3\n            *result_array = temp_value3; // Update the first element of param_3 with the new value\n            result_array[1] = (result_array[1] * 2 | temp_value2 >> 0x1f) * 2 | (temp_value1 * 2 | temp_value1 >> 0x1f); // Update the second element\n            result_array[2] = (temp_value5 * 2 | result_array[1] >> 0x1f); // Update the third element\n\n            temp_value2 += temp_value3; // Increment uVar2 by the value of uVar3\n            if ((temp_value2 < temp_value3) || (temp_value2 < *result_array)) { // Check for overflow\n                result_array[1]++; // Increment the second element if overflow occurs\n                if (result_array[1] == 0) { // Check if the second element rolled over\n                    result_array[2]++; // Increment the third element if it did\n                }\n            }\n\n            result_array[2] += result_array[1] + temp_value1; // Update the third element with the sum of second element and uVar1\n\n            temp_value1 = temp_value2 * 2; // Double the value of uVar2\n            *result_array = temp_value1; // Update the first element of param_3 with the doubled value\n            result_array[1] = (result_array[1] * 2 | temp_value2 >> 0x1f); // Update the second element\n            result_array[2] = (result_array[2] * 2 | result_array[1] >> 0x1f); // Update the third element\n\n            temp_value2 += (uint)(int)*input_string; // Add the current character value to uVar2\n            if ((temp_value2 < (uint)(int)*input_string)) { // Check for overflow\n                result_array[1]++; // Increment the second element if overflow occurs\n                if (result_array[1] == 0) { // Check if the second element rolled over\n                    result_array[2]++; // Increment the third element if it did\n                }\n            }\n\n            char_count--; // Decrement the character count\n            input_string++; // Move to the next character in the input string\n        } while (char_count != 0); // Continue until all characters are processed\n    }\n\n    while (result_array[2] == 0) { // Normalize the result if the third element is zero\n        result_array[2] = result_array[1] >> 0x10; // Shift the second element to the third\n        exponent -= 0x10; // Decrease the exponent\n        result_array[1] = result_array[1] << 0x10 | *result_array >> 0x10; // Shift first element to the second\n        *result_array <<= 0x10; // Shift the first element left\n    }\n\n    while ((result_array[2] & 0x8000) == 0) { // Normalize until the sign bit of the third element is set\n        exponent--; // Decrease the exponent\n        *result_array *= 2; // Double the first element\n        result_array[1] = result_array[1] * 2 | *result_array >> 0x1f; // Update the second element\n        result_array[2] *= 2 | result_array[1] >> 0x1f; // Update the third element\n    }\n\n    *(short *)((int)result_array + 10) = exponent; // Store the exponent in the appropriate location\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); // Check for stack corruption\n    return; // Exit the function\n}\n"}
{"Function Name": "__ismbblead_l", "Address": "10024684", "Source Code": "\n// Function declaration for __ismbblead_l\n// Takes an integer _C and a locale type _Locale as parameters\nint __cdecl __ismbblead_l(uint character, _locale_t locale)\n{\n    // Call to x_ismbbtype_l function to check if the character _C is a lead byte\n    // The parameters passed are the locale, character, and specific type (0 for lead byte)\n    return check_lead_byte(locale, character, 0, 4);\n}\n"}
{"Function Name": "__ismbblead", "Address": "10024699", "Source Code": "\n// Function declaration for __ismbblead, taking an unsigned integer _C as input\nint __cdecl __ismbblead(uint inputCharacter)\n{\n    // Call the x_ismbbtype_l function with a null pointer for localeinfo_struct,\n    // the input character _C, and additional parameters 0 and 4\n    return x_ismbbtype_l((localeinfo_struct *)0x0, inputCharacter, 0, 4);\n}\n"}
{"Function Name": "__stricmp_l", "Address": "10024710", "Source Code": "\nint __cdecl __stricmp_l(char *firstString, char *secondString, _locale_t locale)\n{\n    int firstCharLower; // Variable to store the lowercase value of the first string character\n    int secondCharLower; // Variable to store the lowercase value of the second string character\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale); // Update locale information\n\n    // Check if either input string is null\n    if (firstString == (char *)0x0 || secondString == (char *)0x0) {\n        int *errnoPointer = __errno(); // Get pointer to the errno variable\n        *errnoPointer = 0x16; // Set errno to indicate an invalid parameter error\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to handle invalid parameters\n        return 0x7fffffff; // Return maximum integer value to indicate error\n    }\n    \n    // Check if the locale's category for the first string is not set\n    if ((localeInfo.locinfo)->lc_category[0].wlocale == (wchar_t *)0x0) {\n        return ___ascii_stricmp(firstString, secondString); // Use ASCII comparison if locale is not set\n    }\n    \n    // Loop to compare characters of both strings\n    do {\n        firstCharLower = __tolower_l((uint)(byte)*firstString++, &localeInfo); // Convert character from first string to lowercase\n        secondCharLower = __tolower_l((uint)(byte)*secondString++, &localeInfo); // Convert character from second string to lowercase\n        if (firstCharLower == 0) break; // Break if end of first string is reached\n    } while (firstCharLower == secondCharLower); // Continue while characters are equal\n    \n    return firstCharLower - secondCharLower; // Return the difference between the two characters\n}\n"}
{"Function Name": "_$I10_OUTPUT", "Address": "1002497f", "Source Code": "\nvoid __cdecl __I10_OUTPUT(int input_integer, uint input_uint, ushort input_ushort, int input_short, byte input_byte, short *output_short_ptr) {\n    int temp_integer; // Variable for temporary integer storage\n    errno_t error_code; // Variable for error handling\n    char *string_ptr; // Pointer for string manipulation\n    ushort sign_bit; // Variable to store sign bit of param_3\n    ushort absolute_value; // Variable to store the absolute value of param_3\n    ushort unused_var1; // Unused variable\n    ushort unused_var2; // Unused variable\n    ushort local_var1; // Local variable for intermediate calculations\n    ushort local_var2; // Local variable for intermediate calculations\n    ushort local_var3; // Local variable for intermediate calculations\n    ushort local_var4; // Local variable for intermediate calculations\n    ushort local_var5; // Local variable for intermediate calculations\n    ushort local_var6; // Local variable for intermediate calculations\n    ushort local_var7; // Local variable for intermediate calculations\n    ushort local_var8; // Local variable for intermediate calculations\n    uint calculated_value; // Local variable for intermediate calculations\n    uint unused_var3; // Unused variable\n    ushort *output_ptr; // Pointer for string manipulation\n    short *manipulation_ptr; // Pointer for string manipulation\n    short *last_char_ptr; // Pointer for string manipulation\n\n    sign_bit = input_ushort & 0x8000; // Extract the sign bit from param_3\n    absolute_value = input_ushort & 0x7fff; // Extract the absolute value from param_3\n\n    // Determine the sign character based on the sign bit\n    if (sign_bit == 0) {\n        *(undefined *)(output_short_ptr + 1) = 0x20; // Set to space for positive numbers\n    } else {\n        *(undefined *)(output_short_ptr + 1) = 0x2d; // Set to minus for negative numbers\n    }\n\n    // Check for zero case\n    if (((short)absolute_value == 0) && (input_uint == 0) && (input_integer == 0)) {\n        *output_short_ptr = 0; // Set output to zero\n        *(byte *)(output_short_ptr + 1) = ((sign_bit != 0x8000) - 1U & 0xd) + 0x20; // Set appropriate character\n        *(undefined *)((int)output_short_ptr + 3) = 1; // Set length to 1\n        *(undefined *)(output_short_ptr + 2) = 0x30; // Set character to '0'\n        *(undefined *)((int)output_short_ptr + 5) = 0; // Null terminate\n        goto LAB_100251ff; // Jump to end\n    }\n\n    // Check for special case of maximum value\n    if ((short)absolute_value == 0x7fff) {\n        *output_short_ptr = 1; // Set output to special case\n        // Check for infinity or NaN conditions\n        if (((input_uint == 0x80000000) && (input_integer == 0)) || ((input_uint & 0x40000000) != 0)) {\n            // Handle positive or negative infinity\n            if ((sign_bit == 0) || (input_uint != 0xc0000000)) {\n                if ((input_uint != 0x80000000) || (input_integer != 0)) {\n                    string_ptr = \"1#INF\"; // Set string to positive infinity\n                } else {\n                    string_ptr = \"1#IND\"; // Set string to indeterminate\n                }\n            } else {\n                if (input_integer != 0) {\n                    string_ptr = \"1#QNAN\"; // Set string to quiet NaN\n                } else {\n                    string_ptr = \"1#IND\"; // Set string to indeterminate\n                }\n            }\n            error_code = _strcpy_s((char *)(output_short_ptr + 2), 0x16, string_ptr); // Copy string to output\n            if (error_code != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n            }\n            *(undefined *)((int)output_short_ptr + 3) = 5; // Set length for special case\n        } else {\n            string_ptr = \"1#SNAN\"; // Set string to signaling NaN\n            error_code = _strcpy_s((char *)(output_short_ptr + 2), 0x16, string_ptr); // Copy string to output\n            if (error_code != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n            }\n            *(undefined *)((int)output_short_ptr + 3) = 6; // Set length for special case\n        }\n        goto LAB_100251ff; // Jump to end\n    }\n\n    // Prepare local variables for conversion\n    local_var3 = (ushort)input_uint; // Store lower part of param_2\n    local_var4 = input_ushort; // Store param_3\n    local_var5 = (ushort)((uint)input_integer >> 0x10); // Store upper part of param_1\n    local_var7 = (ushort)input_integer; // Store lower part of param_1\n    local_var8 = (ushort)((uint)input_uint >> 0x10); // Store upper part of param_2\n    local_var1 = (ushort)((uint)input_uint >> 0x10); // Store upper part of param_2 again\n    local_var2 = (ushort)((uint)input_integer >> 0x10); // Store upper part of param_1 again\n    \n    // Calculate local_48 based on input parameters\n    calculated_value = (uint)(short)(((absolute_value >> 8) + (input_uint >> 0x18) * 2) * 0x4d + -0x134312f4 + absolute_value * 0x4d10 >> 0x10);\n    \n    // Check if local_48 is non-zero\n    if (calculated_value != 0) {\n        output_ptr = output_short_ptr + 2; // Initialize pointer for output\n        manipulation_ptr = output_ptr; // Set pointer for manipulation\n        // Loop to convert number to string\n        for (int loop_counter = input_short + 1; 0 < loop_counter; loop_counter--) {\n            local_var3 = (ushort)(local_var3 >> 1); // Shift right to get next digit\n            *(char *)manipulation_ptr = (char)((uint)local_var3 >> 0x18) + '0'; // Convert to character\n            manipulation_ptr++; // Move to next character position\n        }\n        last_char_ptr = manipulation_ptr - 1; // Set pointer to last character\n        // Check if last character is less than '5'\n        if (*(char *)last_char_ptr < '5') {\n            // Trim trailing zeros\n            for (; (output_ptr <= last_char_ptr && (*(char *)last_char_ptr == '0')); last_char_ptr--) {}\n            if (last_char_ptr < output_ptr) {\n                *output_short_ptr = 0; // Set output to zero\n                *(undefined *)((int)output_short_ptr + 3) = 1; // Set length to 1\n                *(byte *)(output_short_ptr + 1) = ((sign_bit != 0x8000) - 1U & 0xd) + 0x20; // Set appropriate character\n                *(char *)output_ptr = '0'; // Set character to '0'\n                *(undefined *)((int)output_short_ptr + 5) = 0; // Null terminate\n                goto LAB_100251ff; // Jump to end\n            }\n        } else {\n            // Handle rounding up\n            for (; (output_ptr <= last_char_ptr && (*(char *)last_char_ptr == '9')); last_char_ptr--) {\n                *(char *)last_char_ptr = '0'; // Set to '0' if rounding\n            }\n            if (last_char_ptr < output_ptr) {\n                last_char_ptr++; // Move pointer for increment\n                *output_short_ptr += 1; // Increment output length\n            }\n            *(char *)last_char_ptr = *(char *)last_char_ptr + '\\x01'; // Increment last character\n        }\n        *(char *)((int)output_short_ptr + 3) = ((char)last_char_ptr - (char)output_short_ptr) + -3; // Set length of output\n        *(undefined *)(cVar16 + 4 + (int)output_short_ptr) = 0; // Null terminate output\n    } else {\n        *output_short_ptr = 0; // Set output to zero\n        *(undefined *)((int)output_short_ptr + 3) = 1; // Set length to 1\n        *(byte *)(output_short_ptr + 1) = ((sign_bit != 0x8000) - 1U & 0xd) + 0x20; // Set appropriate character\n        *(undefined *)(output_short_ptr + 2) = 0x30; // Set character to '0'\n        *(undefined *)((int)output_short_ptr + 5) = 0; // Null terminate\n    }\nLAB_100251ff:\n    return; // Exit function\n}\n"}
{"Function Name": "__hw_cw", "Address": "10025247", "Source Code": "\nuint __hw_cw(void)\n{\n    // Initialize uVar1 based on the 0x10 bit of unaff_EBX\n    uint resultFlags = (uint)((inputFlags & 0x10) != 0);\n    \n    // Check if the 8 bit is set; if so, set the 2nd bit of uVar1\n    if (inputFlags & 8) resultFlags |= 4;\n    // Check if the 4 bit is set; if so, set the 3rd bit of uVar1\n    if (inputFlags & 4) resultFlags |= 8;\n    // Check if the 2 bit is set; if so, set the 4th bit of uVar1\n    if (inputFlags & 2) resultFlags |= 0x10;\n    // Check if the 1 bit is set; if so, set the 5th bit of uVar1\n    if (inputFlags & 1) resultFlags |= 0x20;\n    // Check if the 0x80000 bit is set; if so, set the 1st bit of uVar1\n    if (inputFlags & 0x80000) resultFlags |= 2;\n\n    // Extract the bits 8 and 9 from unaff_EBX\n    uint matchedBits = inputFlags & 0x300;\n    // Set the 10th bit of uVar1 if bits 8 and 9 match 0x100\n    if (matchedBits == 0x100) resultFlags |= 0x400;\n    // Set the 11th bit of uVar1 if bits 8 and 9 match 0x200\n    else if (matchedBits == 0x200) resultFlags |= 0x800;\n    // Set the 12th bit of uVar1 if bits 8 and 9 match 0x300\n    else if (matchedBits == 0x300) resultFlags |= 0xc00;\n\n    // Check if bits 16 and 17 are not set; if so, set bits 9 and 10 of uVar1\n    if ((inputFlags & 0x30000) == 0) resultFlags |= 0x300;\n    // Check if bit 16 is set; if so, set the 9th bit of uVar1\n    else if ((inputFlags & 0x30000) == 0x10000) resultFlags |= 0x200;\n\n    // Check if the 0x40000 bit is set; if so, set the 13th bit of uVar1\n    if (inputFlags & 0x40000) resultFlags |= 0x1000;\n\n    // Return the final value of uVar1\n    return resultFlags;\n}\n"}
{"Function Name": "___hw_cw_sse2", "Address": "100252d5", "Source Code": "\nuint __fastcall ___hw_cw_sse2(undefined4 input_param, uint flags)\n{\n    uint result = 0; // Initialize uVar1 to 0\n\n    // Check specific bits in param_2 and set corresponding bits in uVar1\n    if (flags & 0x10) result |= 0x80;       // Bit 4\n    if (flags & 8) result |= 0x200;         // Bit 3\n    if (flags & 4) result |= 0x400;         // Bit 2\n    if (flags & 2) result |= 0x800;         // Bit 1\n    if (flags & 1) result |= 0x1000;        // Bit 0\n    if (flags & 0x80000) result |= 0x100;   // Bit 19\n\n    // Check bits 8 and 9 of param_2 and set corresponding bits in uVar1\n    uint isolated_bits = flags & 0x300;            // Isolate bits 8 and 9\n    if (isolated_bits == 0x100) result |= 0x2000;     // If bit 8 is set\n    else if (isolated_bits == 0x200) result |= 0x4000; // If bit 9 is set\n    else if (isolated_bits == 0x300) result |= 0x6000; // If both bits 8 and 9 are set\n\n    // Check bits 24 and 25 of param_2 and return modified uVar1\n    isolated_bits = flags & 0x3000000;             // Isolate bits 24 and 25\n    if (isolated_bits == 0x1000000) return result | 0x8040; // If bit 24 is set\n    if (isolated_bits == 0x2000000) return result | 0x40;   // If bit 25 is set\n    if (isolated_bits == 0x3000000) return result | 0x8000; // If both bits 24 and 25 are set\n\n    return result; // Return the final value of uVar1\n}\n"}
{"Function Name": "__control87", "Address": "10025375", "Source Code": "\nuint __cdecl __control87(uint newValue, uint mask)\n{\n    ushort fpuControlWord; // Variable to hold the FPU control word\n    uint modifiedControlWord = 0; // Variable to store the modified control word\n\n    // Check bits in the FPU control word and set corresponding bits in uVar5\n    if ((fpuControlWord & 1) != 0) modifiedControlWord |= 0x10;\n    if ((fpuControlWord & 4) != 0) modifiedControlWord |= 8;\n    if ((fpuControlWord & 8) != 0) modifiedControlWord |= 4;\n    if ((fpuControlWord & 0x10) != 0) modifiedControlWord |= 2;\n    if ((fpuControlWord & 0x20) != 0) modifiedControlWord |= 1;\n    if ((fpuControlWord & 2) != 0) modifiedControlWord |= 0x80000;\n\n    // Check specific bits in the FPU control word for rounding mode\n    ushort roundingMode = fpuControlWord & 0xc00;\n    if (roundingMode == 0x400) modifiedControlWord |= 0x100; // Round to nearest\n    else if (roundingMode == 0x800) modifiedControlWord |= 0x200; // Round down\n    else if (roundingMode == 0xc00) modifiedControlWord |= 0x300; // Round up\n\n    // Check for exceptions in the FPU control word\n    if ((fpuControlWord & 0x300) == 0) modifiedControlWord |= 0x20000; // No exceptions\n    else if ((fpuControlWord & 0x300) == 0x200) modifiedControlWord |= 0x10000; // Some exceptions\n\n    // Check for additional flags in the FPU control word\n    if ((fpuControlWord & 0x1000) != 0) modifiedControlWord |= 0x40000;\n\n    // Combine new value and mask with existing control word\n    uint currentControlWord = ~mask & modifiedControlWord | newValue & mask;\n    if (currentControlWord != modifiedControlWord) {\n        modifiedControlWord = __hw_cw(); // Get the current hardware control word\n        currentControlWord = 0; // Reset uVar2\n\n        // Check bits in the current hardware control word and set corresponding bits in uVar2\n        if ((modifiedControlWord & 1) != 0) currentControlWord |= 0x10;\n        if ((modifiedControlWord & 4) != 0) currentControlWord |= 8;\n        if ((modifiedControlWord & 8) != 0) currentControlWord |= 4;\n        if ((modifiedControlWord & 0x10) != 0) currentControlWord |= 2;\n        if ((modifiedControlWord & 0x20) != 0) currentControlWord |= 1;\n        if ((modifiedControlWord & 2) != 0) currentControlWord |= 0x80000;\n\n        // Check specific bits in the current hardware control word for rounding mode\n        roundingMode = modifiedControlWord & 0xc00;\n        if (roundingMode == 0x400) currentControlWord |= 0x100; // Round to nearest\n        else if (roundingMode == 0x800) currentControlWord |= 0x200; // Round down\n        else if (roundingMode == 0xc00) currentControlWord |= 0x300; // Round up\n\n        // Check for exceptions in the current hardware control word\n        if ((modifiedControlWord & 0x300) == 0) currentControlWord |= 0x20000; // No exceptions\n        else if ((modifiedControlWord & 0x300) == 0x200) currentControlWord |= 0x10000; // Some exceptions\n\n        // Check for additional flags in the current hardware control word\n        if ((modifiedControlWord & 0x1000) != 0) currentControlWord |= 0x40000;\n    }\n\n    // Check if a specific condition is met\n    if (DAT_100377fc != 0) {\n        modifiedControlWord = 0; // Reset uVar5\n        // Check bits in MXCSR and set corresponding bits in uVar5\n        if ((char)MXCSR < '\\0') modifiedControlWord |= 0x10;\n        if ((MXCSR & 0x200) != 0) modifiedControlWord |= 8;\n        if ((MXCSR & 0x400) != 0) modifiedControlWord |= 4;\n        if ((MXCSR & 0x800) != 0) modifiedControlWord |= 2;\n        if ((MXCSR & 0x1000) != 0) modifiedControlWord |= 1;\n        if ((MXCSR & 0x100) != 0) modifiedControlWord |= 0x80000;\n\n        // Check specific bits in MXCSR for rounding mode\n        uint mxcsrRoundingMode = MXCSR & 0x6000;\n        if (mxcsrRoundingMode == 0x2000) modifiedControlWord |= 0x100; // Round to nearest\n        else if (mxcsrRoundingMode == 0x4000) modifiedControlWord |= 0x200; // Round down\n        else if (mxcsrRoundingMode == 0x6000) modifiedControlWord |= 0x300; // Round up\n\n        // Check specific bits in MXCSR for additional flags\n        mxcsrRoundingMode = MXCSR & 0x8040;\n        if (mxcsrRoundingMode == 0x40) modifiedControlWord |= 0x2000000; // Flag set\n        else if (mxcsrRoundingMode == 0x8000) modifiedControlWord |= 0x3000000; // Flag set\n        else if (mxcsrRoundingMode == 0x8040) modifiedControlWord |= 0x1000000; // Flag set\n\n        // Combine new value and mask with existing MXCSR control word\n        mxcsrFlags = ~(mask & 0x308031f) & modifiedControlWord | mask & 0x308031f & newValue;\n        if (mxcsrFlags != modifiedControlWord) {\n            modifiedControlWord = ___hw_cw_sse2(mxcsrRoundingMode, mxcsrFlags); // Update hardware control word for SSE2\n            modifiedControlWord = 0; // Reset uVar5\n            // Check bits in MXCSR and set corresponding bits in uVar5\n            if ((char)MXCSR < '\\0') modifiedControlWord |= 0x10;\n            if ((MXCSR & 0x200) != 0) modifiedControlWord |= 8;\n            if ((MXCSR & 0x400) != 0) modifiedControlWord |= 4;\n            if ((MXCSR & 0x800) != 0) modifiedControlWord |= 2;\n            if ((MXCSR & 0x1000) != 0) modifiedControlWord |= 1;\n            if ((MXCSR & 0x100) != 0) modifiedControlWord |= 0x80000;\n\n            // Check specific bits in MXCSR for rounding mode\n            mxcsrRoundingMode = MXCSR & 0x6000;\n            if (mxcsrRoundingMode == 0x2000) modifiedControlWord |= 0x100; // Round to nearest\n            else if (mxcsrRoundingMode == 0x4000) modifiedControlWord |= 0x200; // Round down\n            else if (mxcsrRoundingMode == 0x6000) modifiedControlWord |= 0x300; // Round up\n\n            // Check specific bits in MXCSR for additional flags\n            mxcsrRoundingMode = MXCSR & 0x8040;\n            if (mxcsrRoundingMode == 0x40) modifiedControlWord |= 0x2000000; // Flag set\n            else if (mxcsrRoundingMode == 0x8000) modifiedControlWord |= 0x3000000; // Flag set\n            else if (mxcsrRoundingMode == 0x8040) modifiedControlWord |= 0x1000000; // Flag set\n        }\n        // Combine results for final output\n        mxcsrRoundingMode = modifiedControlWord ^ currentControlWord; // XOR operation\n        currentControlWord = modifiedControlWord | currentControlWord; // OR operation\n        if ((mxcsrRoundingMode & 0x8031f) != 0) currentControlWord |= 0x80000000; // Set high bit if condition met\n    }\n    return currentControlWord; // Return the final control word\n}\n"}
{"Function Name": "__mbsnbicoll_l", "Address": "10025678", "Source Code": "\nint __cdecl __mbsnbicoll_l(uchar *str1, uchar *str2, size_t maxCount, _locale_t locale)\n{\n    int *errnoPtr; // Pointer to an integer for error handling\n    int comparisonResult; // Variable to store comparison result\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale); // Update locale information\n\n    if (maxCount == 0) { // Check if maximum count is zero\n        return 0; // Return 0 if no characters to compare\n    }\n    \n    if ((str1 == (uchar *)0x0) || (str2 == (uchar *)0x0)) { // Check for null string pointers\n        errnoPtr = __errno(); // Get pointer to errno\n        *errnoPtr = 0x16; // Set errno to indicate an invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Trigger invalid parameter handler\n        return 0x7fffffff; // Return maximum integer value on error\n    }\n    \n    if (maxCount < 0x80000000) { // Check if _MaxCount is within valid range\n        if ((localeInfo.mbcinfo)->ismbcodepage == 0) { // Check if the code page is single-byte\n            comparisonResult = __strnicoll_l((char *)str1, (char *)str2, maxCount, locale); // Perform string comparison\n        } else { // Handle multi-byte character set\n            comparisonResult = ___crtCompareStringA(&localeInfo, *(LPCWSTR *)(localeInfo.mbcinfo)->mbulinfo, 0x1001, (LPCSTR)str1, maxCount, (LPCSTR)str2, maxCount, (localeInfo.mbcinfo)->mbcodepage); // Compare strings using CRT function\n            if (comparisonResult == 0) { // Check if comparison result is zero\n                return 0; // Return 0 if strings are equal\n            }\n            comparisonResult -= 2; // Adjust result for comparison\n        }\n    } else { // Handle case where _MaxCount is too large\n        errnoPtr = __errno(); // Get pointer to errno\n        *errnoPtr = 0x16; // Set errno to indicate an invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Trigger invalid parameter handler\n        comparisonResult = 0x7fffffff; // Set iVar2 to maximum integer value on error\n    }\n    \n    return comparisonResult; // Return the result of the comparison\n}\n"}
{"Function Name": "__mbsnbicoll", "Address": "10025764", "Source Code": "\nint __cdecl __mbsnbicoll(uchar *string1, uchar *string2, size_t maxCount)\n{\n    // Call the __mbsnbicoll_l function with the provided strings and max count\n    // Pass a null locale (_locale_t) to use the default locale\n    return __mbsnbicoll_l(string1, string2, maxCount, (_locale_t)0x0);\n}\n"}
{"Function Name": "__mbsnbcat_s_l", "Address": "10025ab0", "Source Code": "\nerrno_t __cdecl\n__mbsnbcat_s_l(uchar *_Dst, size_t _DstSizeInBytes, uchar *_Src, size_t _MaxCount, _locale_t _Locale)\n{\n    byte *pbVar1; // Pointer for traversing destination buffer\n    byte bVar2;   // Variable to hold current source character\n    int *piVar3;  // Pointer to store error number\n    errno_t eVar4; // Variable to hold error code\n    uint uVar5;   // Variable to track remaining space in destination buffer\n    byte *pbVar6; // Pointer for traversing destination buffer\n    int iVar7;    // Variable for checking multi-byte lead\n    localeinfo_struct local_20; // Structure to hold locale information\n    int local_c = 0; // Flag to indicate if a null terminator was added\n\n    // Check if _MaxCount is zero\n    if (_MaxCount == 0) {\n        // Check if destination pointer is null\n        if (_Dst == (uchar *)0x0) {\n            // If destination size is zero, return success\n            if (_DstSizeInBytes == 0) {\n                return 0;\n            }\n            goto LAB_10025ae1; // Jump to error handling\n        }\n    } else if (_Dst == (uchar *)0x0) {\n        goto LAB_10025ae1; // Jump to error handling if destination is null\n    }\n\n    // Check if destination size is zero\n    if (_DstSizeInBytes == 0) {\n    LAB_10025ae1:\n        piVar3 = __errno(); // Get pointer to error number\n        *piVar3 = 0x16; // Set error code for invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n        return 0x16; // Return error code\n    }\n\n    // Check if source is null when _MaxCount is not zero\n    if ((_MaxCount != 0) && (_Src == (uchar *)0x0)) {\n        *_Dst = '\\0'; // Set destination to null terminator\n        goto LAB_10025ae1; // Jump to error handling\n    }\n\n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_20, _Locale);\n    // Check if the current code page is not multi-byte\n    if ((local_20.mbcinfo)->ismbcodepage == 0) {\n        return _strncat_s((char *)_Dst, _DstSizeInBytes, (char *)_Src, _MaxCount); // Use standard string concatenation\n    }\n\n    uint local_10 = _DstSizeInBytes; // Store the size of destination buffer\n    pbVar6 = _Dst; // Initialize pointer to destination buffer\n    // Traverse destination buffer to find the end\n    while (local_10 != 0 && *pbVar6 != 0) {\n        pbVar6++; // Move to the next character\n        local_10--; // Decrease remaining size\n    }\n\n    // Check if destination buffer is full\n    if (local_10 == 0) {\n        *_Dst = '\\0'; // Set destination to null terminator\n        piVar3 = __errno(); // Get pointer to error number\n        goto LAB_10025b67; // Jump to error handling\n    }\n\n    uVar5 = local_10; // Store remaining space in destination buffer\n    // Check if there is space for multi-byte character\n    if (local_10 < _DstSizeInBytes) {\n        pbVar1 = pbVar6 - 1; // Set pointer to the last character in destination\n        // Check for lead byte of multi-byte character\n        while (_Dst <= pbVar1 && (iVar7 = __ismbblead_l((uint)*pbVar1, &local_20), iVar7 != 0)) {\n            pbVar1--; // Move back if lead byte is found\n        }\n        // Check if the last character was a lead byte\n        if (((int)pbVar1 - (int)(pbVar6 - 1) & 1U) != 0) {\n            *pbVar6 = 0; // Set null terminator\n            uVar5++; // Increase available space\n            local_c = 1; // Set flag indicating null terminator was added\n        }\n    }\n\n    // Check if _MaxCount is set to maximum value\n    if (_MaxCount == 0xffffffff) {\n        do {\n            bVar2 = *_Src; // Get current source character\n            *pbVar6++ = bVar2; // Copy to destination\n            _Src++; // Move to next source character\n            if (bVar2 == 0) break; // Break if null terminator is reached\n            uVar5--; // Decrease remaining space\n        } while (uVar5 != 0); // Continue until space is exhausted\n    } else {\n        // If _MaxCount is not zero\n        if (_MaxCount != 0) {\n            do {\n                bVar2 = *_Src; // Get current source character\n                *pbVar6++ = bVar2; // Copy to destination\n                _Src++; // Move to next source character\n                if ((bVar2 == 0) || (--uVar5 == 0)) break; // Break if null terminator or space is exhausted\n                _MaxCount--; // Decrease remaining count\n            } while (_MaxCount != 0); // Continue until count is exhausted\n        }\n        // If _MaxCount is zero, set null terminator\n        if (_MaxCount == 0) {\n            *pbVar6 = 0; // Set null terminator\n            pbVar6++; // Move to next position\n        }\n    }\n\n    // Check if there is remaining space in destination buffer\n    if (uVar5 != 0) {\n        if (uVar5 < _DstSizeInBytes) {\n            pbVar1 = pbVar6 - 2; // Set pointer to the second last character\n            // Check for lead byte of multi-byte character\n            while (_Dst <= pbVar1 && (iVar7 = __ismbblead_l((uint)*pbVar1, &local_20), iVar7 != 0)) {\n                pbVar1--; // Move back if lead byte is found\n            }\n            // Check if the last character was a lead byte\n            if (((int)pbVar6 - (int)pbVar1 & 1U) != 0) {\n                *pbVar6 = 0; // Set null terminator\n                local_c = 1; // Set flag indicating null terminator was added\n            }\n        }\n        // If no null terminator was added, return success\n        if (local_c == 0) {\n            return 0; // Return success\n        }\n    }\n\nLAB_10025b32:\n    piVar3 = __errno(); // Get pointer to error number\n    eVar4 = 0x2a; // Set error code for buffer overflow\n    *piVar3 = 0x2a; // Store error code\n\nLAB_10025b67:\n    *piVar3 = 0x22; // Set error code for invalid parameter\n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle invalid parameter\n    return eVar4; // Return error code\n}\n"}
{"Function Name": "__mbsnbcpy_s_l", "Address": "10025d42", "Source Code": "\nerrno_t __cdecl\n__mbsnbcpy_s_l(uchar *_Dst, size_t _DstSizeInBytes, uchar *_Src, size_t _MaxCount, _locale_t _Locale)\n{\n    errno_t eVar4; // Variable to store error codes\n    uchar *puVar5; // Pointer for destination buffer\n    size_t sVar8; // Size variable for remaining bytes in destination\n    byte *pbVar9; // Pointer for processing multi-byte characters\n    localeinfo_struct local_18; // Structure to hold locale information\n    int *piVar3; // Pointer for error handling\n\n    // Check if _MaxCount is zero\n    if (_MaxCount == 0) {\n        // Check if destination is NULL\n        if (_Dst == (uchar *)0x0) {\n            // If destination size is zero, return success\n            if (_DstSizeInBytes == 0) {\n                return 0;\n            }\n            // Go to error handling\n            goto LAB_10025d6d;\n        }\n    } else if (_Dst == (uchar *)0x0) {\n        // If destination is NULL and _MaxCount is not zero, go to error handling\n        goto LAB_10025d6d;\n    }\n\n    // Check if destination size is zero\n    if (_DstSizeInBytes == 0) {\n    LAB_10025d6d:\n        piVar3 = __errno(); // Get pointer to errno\n        *piVar3 = 0x16; // Set error code for invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return 0x16; // Return error code\n    }\n\n    // If _MaxCount is zero, set destination to empty string and return success\n    if (_MaxCount == 0) {\n        *_Dst = '\\0';\n        return 0;\n    }\n\n    // Check if source is NULL\n    if (_Src == (uchar *)0x0) {\n        *_Dst = '\\0'; // Set destination to empty string\n        piVar3 = __errno(); // Get pointer to errno\n        *piVar3 = 0x16; // Set error code for invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return 0x16; // Return error code\n    }\n\n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_18, _Locale);\n    // Check if the current code page supports multi-byte characters\n    if ((local_18.mbcinfo)->ismbcodepage == 0) {\n        // If not, use standard string copy function\n        return _strncpy_s((char *)_Dst, _DstSizeInBytes, (char *)_Src, _MaxCount);\n    }\n\n    puVar5 = _Dst; // Initialize destination pointer\n    sVar8 = _DstSizeInBytes; // Initialize remaining size\n\n    // Handle case where _MaxCount is set to maximum value\n    if (_MaxCount == 0xffffffff) {\n        do {\n            *puVar5 = *_Src; // Copy character from source to destination\n            puVar5++; // Move to next position in destination\n            _Src++; // Move to next position in source\n            if (*puVar5 == '\\0') break; // Break if end of string is reached\n            sVar8--; // Decrease remaining size\n        } while (sVar8 != 0); // Continue until no space left\n    } else {\n        // Handle case where _MaxCount is specified\n        do {\n            *puVar5 = *_Src; // Copy character from source to destination\n            puVar5++; // Move to next position in destination\n            _Src++; // Move to next position in source\n            if ((*puVar5 == '\\0') || (sVar8-- == 1)) break; // Break if end of string or size limit is reached\n            _MaxCount--; // Decrease remaining count\n        } while (_MaxCount != 0); // Continue until count reaches zero\n        if (_MaxCount == 0) {\n            *puVar5 = '\\0'; // Null-terminate the destination string\n        }\n    }\n\n    // Check if there is remaining space in destination\n    if (sVar8 != 0) {\n        // Ensure at least two bytes are copied\n        if ((int)puVar5 - (int)_Dst < 2) {\n            return 0; // Return success if less than two bytes\n        }\n        pbVar9 = puVar5 - 2; // Pointer to the last two bytes copied\n        // Check for lead byte of multi-byte character\n        while ((_Dst <= pbVar9 && __ismbblead_l((uint)*pbVar9, &local_18)) != 0) {\n            pbVar9--; // Move back if lead byte is found\n        }\n        // Check if the last character is a valid multi-byte character\n        if (((int)(puVar5 - 2) - (int)pbVar9 & 1U) == 0) {\n            goto LAB_10025f20; // Go to success handling\n        }\n        *pbVar9 = 0; // Null-terminate the last valid character\n        piVar3 = __errno(); // Get pointer to errno\n        eVar4 = 0x2a; // Set error code for invalid parameter\n        *piVar3 = 0x2a; // Store error code\n        return eVar4; // Return error code\n    }\n\n    // Check if source ends with null or if only one byte is left\n    if ((*_Src == '\\0') || (_MaxCount == 1)) {\n        pbVar9 = puVar5 - 1; // Pointer to the last byte copied\n        // Check for lead byte of multi-byte character\n        while ((_Dst <= pbVar9 && __ismbblead_l((uint)*pbVar9, &local_18)) != 0) {\n            pbVar9--; // Move back if lead byte is found\n        }\n        // Check if the last character is a valid multi-byte character\n        if (((int)(puVar5 - 1) - (int)pbVar9 & 1U) != 0) {\n            goto LAB_10025f20; // Go to success handling\n        }\n    }\n\n    // Check if _MaxCount is not set to maximum value\n    if (_MaxCount != 0xffffffff) {\n        *_Dst = '\\0'; // Null-terminate the destination string\n        piVar3 = __errno(); // Get pointer to errno\n        *piVar3 = 0x22; // Set error code for invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return 0x22; // Return error code\n    }\n\n    // Ensure there is space for null-termination in destination\n    if (1 < _DstSizeInBytes) {\n        pbVar9 = _Dst + (_DstSizeInBytes - 2); // Pointer to the last two bytes of destination\n        // Check for lead byte of multi-byte character\n        while ((_Dst <= pbVar9 && __ismbblead_l((uint)*pbVar9, &local_18)) != 0) {\n            pbVar9--; // Move back if lead byte is found\n        }\n        // Check if the last character is a valid multi-byte character\n        if (((int)(pbVar9 - (_Dst + (_DstSizeInBytes - 2)) & 1U) != 0) {\n            *pbVar9 = 0; // Null-terminate the last valid character\n            goto LAB_10025ea9; // Go to success handling\n        }\n    }\n    _Dst[_DstSizeInBytes - 1] = '\\0'; // Ensure null-termination at the end of destination\nLAB_10025ea9:\n    return 0x50; // Return success code\n}\n"}
{"Function Name": "___set_fpsr_sse2", "Address": "10025fb1", "Source Code": "\nvoid __cdecl ___set_fpsr_sse2(uint input_param)\n{\n    // Check if the global variable DAT_100377fc is not zero\n    if (global_flag != 0) {\n        // Set MXCSR based on the conditions involving param_1 and DAT_10035a18\n        mxcsr_value = (input_param & 0x40) == 0 || condition_value == 0 ? \n                    // If the condition is true, clear the 6th bit of param_1\n                    input_param & 0xffffffbf : \n                    // Otherwise, use param_1 as is\n                    input_param;\n    }\n}\n"}
{"Function Name": "__crtCompareStringA_stat", "Address": "10026023", "Source Code": "\nint __cdecl\n__crtCompareStringA_stat\n(localeinfo_struct *param_1, ulong param_2, ulong param_3, char *param_4, int param_5,\nchar *param_6, int param_7, int param_8)\n{\n    uint local_8; // Local variable to store a checksum for security\n    char *lpMultiByteStr = param_4; // Pointer to the multi-byte string\n    int iVar1; // Variable to store return values from functions\n    DWORD DVar2; // Variable to store error codes\n    byte *pbVar9; // Pointer for converted byte string\n    PCNZCH _Memory; // Pointer for memory allocation\n    byte *local_28; // Local variable for byte pointer\n    undefined4 *local_24 = (undefined4 *)0x0; // Pointer for allocated memory\n    char *pcVar7; // Pointer for character operations\n    ulong uVar8 = param_3; // Copy of param_3 for manipulation\n    byte *in_EDX; // Input byte pointer\n\n    local_8 = DAT_100345e0 ^ (uint)&stack0xfffffffc; // Initialize checksum\n\n    // Check if the global variable is uninitialized\n    if (DAT_10036684 == 0) {\n        iVar1 = CompareStringW(0, 0, L\"\", 1, L\"\", 1); // Test CompareStringW function\n        if (iVar1 == 0) { // If the function failed\n            DVar2 = GetLastError(); // Get the last error code\n            if (DVar2 == 0x78) { // Check if the error code indicates a specific condition\n                DAT_10036684 = 2; // Set global variable to indicate a specific state\n            }\n        } else {\n            DAT_10036684 = 1; // Set global variable to indicate a successful state\n        }\n    }\n\n    // Adjust param_3 based on the input string length\n    if ((int)param_3 >= 1) {\n        do {\n            uVar8--; // Decrement uVar8\n            if (*(in_EDX + uVar8) == 0) break; // Break if null terminator is found\n        } while (uVar8 != 0);\n        param_3 += (-1 - uVar8); // Adjust param_3 to reflect actual length\n    } else {\n        param_3 = 0xffffffff; // Set param_3 to a special value if less than 1\n    }\n\n    // Adjust param_5 based on the multi-byte string length\n    if ((int)param_5 >= 1) {\n        pcVar7 = lpMultiByteStr; // Set pcVar7 to the multi-byte string\n        do {\n            iVar1 = param_5--; // Decrement param_5\n            if (*pcVar7 == '\\0') break; // Break if null terminator is found\n            pcVar7++; // Move to the next character\n        } while (iVar1 != 0);\n        param_5 += (-1 - iVar1); // Adjust param_5 to reflect actual length\n    } else {\n        param_5 = -1; // Set param_5 to -1 if less than 1\n    }\n\n    // Handle string comparison based on the state of DAT_10036684\n    if ((DAT_10036684 == 2) || (DAT_10036684 == 0)) {\n        if (param_1 == (localeinfo_struct *)0x0) { // Check if localeinfo_struct is null\n            param_1 = *(localeinfo_struct **)(*in_ECX + 0x14); // Retrieve default locale\n        }\n        if (param_6 == (char *)0x0) { // Check if param_6 is null\n            param_6 = *(char **)(*in_ECX + 4); // Retrieve default code page\n        }\n        pcVar7 = (char *)___ansicp((LCID)param_1); // Get ANSI code page\n        if (pcVar7 == (char *)0xffffffff) goto LAB_1002639a; // Check for error\n\n        local_28 = in_EDX; // Set local_28 to input byte pointer\n        if (pcVar7 != param_6) { // If code pages differ\n            pbVar9 = (byte *)___convertcp((UINT)param_6, (UINT)pcVar7, (char *)in_EDX, &param_3, (LPSTR)0x0, 0); // Convert input string\n            if (pbVar9 == (byte *)0x0) goto LAB_1002639a; // Check for conversion failure\n            _Memory = (PCNZCH)___convertcp((UINT)param_6, (UINT)pcVar7, lpMultiByteStr, (uint *)&param_5, (LPSTR)0x0, 0); // Convert multi-byte string\n            local_28 = pbVar9; // Update local_28 to converted byte string\n            if (_Memory == (PCNZCH)0x0) { // Check for conversion failure\n                _free(pbVar9); // Free allocated memory\n                goto LAB_1002639a; // Exit function\n            }\n        }\n        CompareStringA((LCID)param_1, param_2, (PCNZCH)local_28, param_3, lpMultiByteStr, param_5); // Perform string comparison\n        if (pbVar9 != (byte *)0x0) { // If conversion was successful\n            _free(pbVar9); // Free converted byte string\n            _free(_Memory); // Free converted multi-byte string\n        }\n        goto LAB_1002639a; // Exit function\n    }\n\n    // Handle case when DAT_10036684 is not 2 or 0\n    if (DAT_10036684 != 1) goto LAB_1002639a; // Exit if not in a valid state\n    if (param_6 == (char *)0x0) { // Check if param_6 is null\n        param_6 = *(char **)(*in_ECX + 4); // Retrieve default code page\n    }\n    // Validate lengths of param_3 and param_5\n    if ((param_3 == 0) || (param_5 == 0)) {\n        if ((param_3 == param_5) || (((1 < param_5 || (1 < (int)param_3)) || (GetCPInfo((UINT)param_6, &local_1c) == 0)))) {\n            goto LAB_1002639a; // Exit if conditions are not met\n        }\n        if (0 < (int)param_3) { // If param_3 is positive\n            if (1 < local_1c.MaxCharSize) { // Check if max char size is greater than 1\n                byte *pBVar4 = local_1c.LeadByte; // Pointer to lead byte\n                while ((local_1c.LeadByte[0] != 0 && (pBVar4[1] != 0) && ((*in_EDX < *pBVar4 || (pBVar4[1] < *in_EDX))))) {\n                    pBVar4 += 2; // Move to next lead byte\n                    local_1c.LeadByte[0] = *pBVar4; // Update lead byte\n                }\n            }\n            goto LAB_1002639a; // Exit function\n        }\n        if (0 < param_5) { // If param_5 is positive\n            if (1 < local_1c.MaxCharSize) { // Check if max char size is greater than 1\n                byte *pBVar4 = local_1c.LeadByte; // Pointer to lead byte\n                while ((local_1c.LeadByte[0] != 0 && (pBVar4[1] != 0) && (((byte)*lpMultiByteStr < *pBVar4 || (pBVar4[1] < (byte)*lpMultiByteStr))))) {\n                    pBVar4 += 2; // Move to next lead byte\n                    local_1c.LeadByte[0] = *pBVar4; // Update lead byte\n                }\n            }\n            goto LAB_1002639a; // Exit function\n        }\n    }\n\n    // Convert multi-byte string to wide character\n    uint cchWideChar = MultiByteToWideChar((UINT)param_6, 9, (LPCSTR)in_EDX, param_3, (LPWSTR)0x0, 0);\n    if (cchWideChar == 0) goto LAB_1002639a; // Check for conversion failure\n\n    // Allocate memory for wide character string\n    if ((int)cchWideChar < 1 || 0xffffffe0 / cchWideChar < 2) {\n        local_24 = (undefined4 *)0x0; // Set to null if size is invalid\n    } else {\n        uint uVar5 = cchWideChar * 2 + 8; // Calculate required size\n        if (uVar5 < 0x401) {\n            local_24 = (undefined4 *)&stack0xffffffc4; // Use stack memory if small enough\n        } else {\n            local_24 = (undefined4 *)_malloc(uVar5); // Allocate memory\n            if (local_24 != (undefined4 *)0x0) {\n                *local_24 = 0xdddd; // Initialize memory\n            }\n        }\n    }\n\n    if (local_24 == (undefined4 *)0x0) goto LAB_1002639a; // Exit if memory allocation failed\n\n    // Convert input string to wide character\n    iVar1 = MultiByteToWideChar((UINT)param_6, 1, (LPCSTR)in_EDX, param_3, (LPWSTR)local_24, cchWideChar);\n    if (iVar1 != 0 && (uVar5 = MultiByteToWideChar((UINT)param_6, 9, lpMultiByteStr, param_5, (LPWSTR)0x0, 0), uVar5 != 0)) {\n        if ((int)uVar5 < 1 || 0xffffffe0 / uVar5 < 2) {\n            local_24 = (undefined4 *)0x0; // Set to null if size is invalid\n        } else {\n            uint _Size = uVar5 * 2 + 8; // Calculate required size\n            if (_Size < 0x401) {\n                local_24 = (undefined4 *)&stack0xffffffcc; // Use stack memory if small enough\n            } else {\n                local_24 = (undefined4 *)_malloc(_Size); // Allocate memory\n                if (local_24 != (undefined4 *)0x0) {\n                    *local_24 = 0xdddd; // Initialize memory\n                    local_24 += 2; // Adjust pointer for further use\n                }\n            }\n        }\n    }\n\n    if (local_24 != (undefined4 *)0x0) { // If memory allocation was successful\n        iVar1 = MultiByteToWideChar((UINT)param_6, 1, lpMultiByteStr, param_5, (LPWSTR)local_24, uVar5); // Convert multi-byte string to wide character\n        if (iVar1 != 0) { // If conversion was successful\n            CompareStringW((LCID)param_1, param_2, (PCNZWCH)local_24, cchWideChar, (PCNZWCH)local_24, uVar5); // Perform wide string comparison\n        }\n        __freea(local_24); // Free allocated memory\n    }\n\nLAB_1002639a:\n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); // Return security check result\n}\n"}
{"Function Name": "__strnicoll_l", "Address": "100263ec", "Source Code": "\nint __cdecl __strnicoll_l(char *str1, char *str2, size_t maxCount, _locale_t locale)\n{\n    LPCWSTR localeName; // Variable to hold the locale name\n    int *errorPtr; // Pointer to store the error number\n    int comparisonResult; // Variable to hold the comparison result\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale); // Update locale information\n    \n    if (maxCount == 0) { // Check if maximum count is zero\n        return 0; // Return 0 if no characters to compare\n    }\n    \n    if (str1 == (char *)0x0 || str2 == (char *)0x0) { // Check for null string pointers\n        errorPtr = __errno(); // Get pointer to the error number\n        *errorPtr = 0x16; // Set error number to indicate invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Trigger invalid parameter handler\n        return 0x7fffffff; // Return maximum integer value on error\n    }\n    \n    if (maxCount < 0x80000000) { // Check if maximum count is within valid range\n        localeName = (LPCWSTR)(localeInfo.locinfo)->lc_category[0].locale; // Get the locale name from locale info\n        if (localeName == (LPCWSTR)0x0) { // Check if locale name is null\n            comparisonResult = __strnicmp_l(str1, str2, maxCount, &localeInfo); // Perform case-insensitive comparison without locale\n        } else {\n            comparisonResult = ___crtCompareStringA(&localeInfo, localeName, 0x1001, str1, maxCount, str2, maxCount, (localeInfo.locinfo)->lc_collate_cp); // Perform locale-aware string comparison\n            if (comparisonResult == 0) { // Check if comparison failed\n                errorPtr = __errno(); // Get pointer to the error number\n                *errorPtr = 0x16; // Set error number to indicate invalid parameter\n                return 0x7fffffff; // Return maximum integer value on error\n            }\n            comparisonResult -= 2; // Adjust the result to get the correct comparison value\n        }\n    } else {\n        errorPtr = __errno(); // Get pointer to the error number\n        *errorPtr = 0x16; // Set error number to indicate invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Trigger invalid parameter handler\n        comparisonResult = 0x7fffffff; // Set result to maximum integer value on error\n    }\n    \n    return comparisonResult; // Return the comparison result\n}\n"}
{"Function Name": "_findenv", "Address": "100264e4", "Source Code": "\nint __cdecl _findenv(uchar *env_var_name) // Function to find the environment variable\n{\n    uchar **env_var_list = env_var_start; // Pointer to the start of the environment variable list\n    while (true) { // Infinite loop to iterate through the environment variables\n        if (*env_var_list == (uchar *)0x0) { // Check if the current pointer is null (end of list)\n            return -((int)env_var_list - (int)env_var_start >> 2); // Return negative index if end is reached\n        }\n        // Compare the input parameter with the current environment variable\n        if (__mbsnbicoll(env_var_name, *env_var_list, match_index) == 0 && \n            ((*env_var_list)[match_index] == '=' || ((*env_var_list)[match_index] == '\\0'))) {\n            break; // Break if a match is found\n        }\n        env_var_list++; // Move to the next environment variable\n    }\n    return (int)env_var_list - (int)env_var_start >> 2; // Return the index of the found environment variable\n}\n"}
{"Function Name": "__mbschr_l", "Address": "10026aa3", "Source Code": "\\*\nuchar * __cdecl __mbschr_l(uchar *inputString, uint searchChar, _locale_t locale)\n{\n    byte currentChar; // Variable to hold the current character from the string\n    byte nextChar; // Variable to hold the next character for multi-byte characters\n    byte *currentPosition; // Pointer to the current position in the string\n    _LocaleUpdate localeUpdate[4]; // Locale update structure for handling locale-specific operations\n    int localeData; // Local variable for storing locale-specific data\n    char tempChar; // Local variable, purpose unclear from the snippet\n\n    _LocaleUpdate::_LocaleUpdate(localeUpdate, locale); // Initialize locale update\n    if (inputString == (uchar *)0x0) { // Check if the input string is null\n        int *errorPointer = __errno(); // Get a pointer to the error number\n        *errorPointer = 0x16; // Set the error number to indicate an invalid parameter\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call invalid parameter handler\n        return (uchar *)0x0; // Return null to indicate failure\n    }\n\n    while (true) { // Start an infinite loop to iterate through the string\n        currentChar = *inputString; // Get the current character from the string\n        if (currentChar == 0) break; // Break the loop if the end of the string is reached\n        if ((*(byte *)(currentChar + 0x1d + *(int *)(localeData + 8)) & 4) == 0) { // Check if the character is a single-byte character\n            currentPosition = inputString; // Set the pointer to the current position\n            if (searchChar == currentChar) break; // Check if the current character matches the search character\n        } else { // Handle multi-byte character case\n            nextChar = inputString[1]; // Get the next character\n            if (nextChar == 0) goto LAB_10026b4b; // If the next character is null, go to the error handling\n            currentPosition = inputString + 1; // Move the pointer to the next character\n            if (searchChar == CONCAT11(currentChar, nextChar)) goto LAB_10026b3d; // Check if the combined characters match the search character\n        }\n        inputString = currentPosition + 1; // Move the string pointer to the next character\n    }\n\n    if (searchChar != (ushort)currentChar) { // Check if the last character matched the search character\nLAB_10026b4b: // Error handling label\n        return (uchar *)0x0; // Return null if no match was found\n    }\nLAB_10026b3d: // Match found label\n    return inputString; // Return the pointer to the found character\n}\n*\\ \n \n\nuchar * __cdecl __mbschr_l(uchar *inputString, uint searchChar, _locale_t locale)\n{\n    byte currentChar;\n    byte nextChar;\n    byte *currentPosition;\n    _LocaleUpdate localeUpdate[4];\n    int localeData;\n    char tempChar;\n\n    _LocaleUpdate::_LocaleUpdate(localeUpdate, locale);\n    if (inputString == (uchar *)0x0) {\n        int *errorPointer = __errno();\n        *errorPointer = 0x16;\n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        return (uchar *)0x0;\n    }\n\n    while (true) {\n        currentChar = *inputString;\n        if (currentChar == 0) break;\n        if ((*(byte *)(currentChar + 0x1d + *(int *)(localeData + 8)) & 4) == 0) {\n            currentPosition = inputString;\n            if (searchChar == currentChar) break;\n        } else {\n            nextChar = inputString[1];\n            if (nextChar == 0) goto LAB_10026b4b;\n            currentPosition = inputString + 1;\n            if (searchChar == CONCAT11(currentChar, nextChar)) goto LAB_10026b3d;\n        }\n        inputString = currentPosition + 1;\n    }\n\n    if (searchChar != (ushort)currentChar) {\nLAB_10026b4b:\n        return (uchar *)0x0;\n    }\nLAB_10026b3d:\n    return inputString;\n}\n"}
{"Function Name": "__mbschr", "Address": "10026b5d", "Source Code": "\\*\n// Function declaration for __mbschr, which searches for the first occurrence of a character in a multibyte string\nuchar * __cdecl __mbschr(uchar *inputString, uint searchChar)\n{\n    // Call the __mbschr_l function with the provided string, character, and a null locale\n    return __mbschr_l(inputString, searchChar, (_locale_t)0x0);\n}\n*\\ \n \n\nuchar * __cdecl __mbschr(uchar *inputString, uint searchChar)\n{\n    return __mbschr_l(inputString, searchChar, (_locale_t)0x0);\n}\n"}
{"Function Name": "Unwind@10026b80", "Address": "10026b80", "Source Code": "\nvoid Unwind_10026b80(void)\n{\n    // Call the function FUN_100013b0 with a pointer obtained from dereferencing\n    // the integer located at memory address 0xFFFFFFEC, which points to an undefined4 pointer.\n    callFunction(*(undefined4 **)(*(int *)0xFFFFFFEC)));\n}\n"}
{"Function Name": "Unwind@10026bb0", "Address": "10026bb0", "Source Code": "\nvoid Unwind_10026bb0(void) // Function declaration for Unwind_10026bb0\n{\n    free_memory(*(void **)(*(int *)0 + 4)); // Free memory pointed to by the pointer located at offset 4 from the integer at address 0\n}\n"}
{"Function Name": "Unwind@10026be0", "Address": "10026be0", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100013b0 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    functionCall(*(undefined4 **)(basePointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10026c10", "Address": "10026c10", "Source Code": "\nvoid Unwind_10026c10(void) // Function definition for Unwind_10026c10\n{\n    // Call the destructor for the exception object pointed to by the address\n    // located at (unaff_EBP - 0x10), casting it to an exception pointer.\n    exception::~ExceptionType(*(exception **)(basePointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10026c40", "Address": "10026c40", "Source Code": "\nvoid Unwind_10026c40(void) // Function definition for Unwind_10026c40\n{\n    // Call the destructor for the exception object pointed to by the address \n    // located at (unaff_EBP - 0x10), casting it to an exception pointer\n    exception::~ExceptionHandler(*(exception **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10026c70", "Address": "10026c70", "Source Code": "\nvoid unwindException(void) // Function definition for Unwind_10026c70\n{\n    // Call the destructor for the exception object pointed to by the address at 0xFFFFFFF0\n    exception::~ExceptionHandler(*(exception **)(*(int *)0xFFFFFFF0));\n}\n"}
{"Function Name": "Unwind@10026ca0", "Address": "10026ca0", "Source Code": "\nvoid Unwind_10026ca0(void) // Function definition for Unwind_10026ca0\n{\n    FUN_1000fe01((int *)(unaff_EBP - 0x10)); // Call FUN_1000fe01 with a pointer to an integer, offset by -0x10 from unaff_EBP\n}\n"}
{"Function Name": "Unwind@10026cd0", "Address": "10026cd0", "Source Code": "\nvoid Unwind_10026cd0(void)\n{\n    // Call the function FUN_1000fe01 with a pointer to an integer\n    // The pointer is calculated by subtracting 0x10 from the value of unaff_EBP\n    FUN_1000fe01((int *)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10026d00", "Address": "10026d00", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10026d00\n{\n    functionCall((int *)(-0x10)); // Call FUN_1000fe01 with a pointer to the integer value -16\n}\n"}
{"Function Name": "Unwind@10026d30", "Address": "10026d30", "Source Code": "\nvoid Unwind_10026d30(void)\n{\n    // Call the function FUN_10001910 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    function_call(*(undefined4 **)(base_pointer + -0x10));\n}\n"}
{"Function Name": "Unwind@10026d60", "Address": "10026d60", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10026d60\n{\n    // Call FUN_10001910 with the dereferenced pointer from the address 0xFFFFFFF0\n    functionCall(*(undefined4 **)(*(int *)0xFFFFFFF0)));\n}\n"}
{"Function Name": "Unwind@10026d90", "Address": "10026d90", "Source Code": "\nvoid Unwind_10026d90(void)\n{\n    // Call the function FUN_10001910 with a pointer to an undefined type\n    // retrieved from the stack frame at an offset of -0x10 from the base pointer (unaff_EBP).\n    FUN_10001910(*(undefined4 **)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10026dc0", "Address": "10026dc0", "Source Code": "\nvoid Unwind_10026dc0(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x10) is set\n    if ((*(uint *)(base_pointer - 0x10) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x10)\n        *(uint *)(base_pointer - 0x10) &= 0xfffffffe;\n        // Call the function FUN_10001920 with the address stored at (unaff_EBP + 4)\n        function_call(*(uint **)(base_pointer + 4));\n    }\n}\n"}
{"Function Name": "Unwind@10026e00", "Address": "10026e00", "Source Code": "\nvoid Unwind_10026e00(void) // Function definition for Unwind_10026e00\n{\n    // Call the function FUN_10001ae0 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the integer located at memory address 0x10\n    callFunction(*(undefined4 **)(*(int *)0x10));\n}\n"}
{"Function Name": "Unwind@10026e30", "Address": "10026e30", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10026e30\n{\n    // Call the function FUN_10001ae0 with the dereferenced pointer from the address \n    // obtained by casting the value at address 0xFFFFFFFFFFFFFFF0 to an integer pointer\n    functionCall(*(undefined4 **)(*(int *)0xFFFFFFFFFFFFFFF0)));\n}\n"}
{"Function Name": "Unwind@10026e60", "Address": "10026e60", "Source Code": "\nvoid Unwind_10026e60(void) // Function declaration for Unwind_10026e60\n{\n    // Call the destructor for the exception object pointed to by the address at 0xFFFFFFF0\n    exception::~ExceptionHandler(*(exception **)(*(int *)0xFFFFFFF0));\n}\n"}
{"Function Name": "Unwind@10026e90", "Address": "10026e90", "Source Code": "\nvoid Unwind_10026e90(void)\n{\n    // Call the function FUN_100101dc with a pointer to a CRITICAL_SECTION\n    // The pointer is obtained by dereferencing the value at (unaff_EBP - 0x10) and adding 4 to it\n    critical_section_handler((LPCRITICAL_SECTION *)(*(int *)(base_pointer - 0x10) + 4));\n}\n"}
{"Function Name": "Unwind@10026ec0", "Address": "10026ec0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10026ec0\n{\n    // Call FUN_10002040 with the dereferenced pointer from the address 0xFFFFFFFFFFFFFFF0\n    callFunction(*(undefined4 **)(*(int *)0xFFFFFFFFFFFFFFF0)));\n}\n"}
{"Function Name": "Unwind@10026ef0", "Address": "10026ef0", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100101dc with a pointer to a CRITICAL_SECTION structure\n    // The pointer is obtained by dereferencing an integer located at an offset from the base pointer (unaff_EBP)\n    // The offset is -0x10, and we add 4 to access the specific member of the structure\n    callFunction((LPCRITICAL_SECTION *)(*(int *)(basePointer - 0x10) + 4));\n}\n"}
{"Function Name": "Unwind@10026f20", "Address": "10026f20", "Source Code": "\nvoid Unwind_10026f20(void)\n{\n    // Call the function FUN_10002020 with a pointer to an integer pointer\n    // The pointer is derived from the value of unaff_EBP minus 16 bytes\n    function_pointer(*(int ***)(&base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10026f50", "Address": "10026f50", "Source Code": "\nvoid Unwind_10026f50(void)\n{\n    // Call the function FUN_10001be0 with an argument calculated from the value at \n    // the memory location pointed to by unaff_EBP minus 0x10, then subtracting 0x48.\n    function_call(*(int *)(base_pointer - 0x10) - 0x48);\n}\n"}
{"Function Name": "Unwind@10026f5b", "Address": "10026f5b", "Source Code": "\nvoid Unwind_10026f5b(void) // Function definition for Unwind_10026f5b\n{\n    // Call FUN_100021e0 with a pointer to an undefined 4-byte value\n    // The pointer is derived from the value at (unaff_EBP - 0x10) minus 0x48\n    FUN_100021e0((undefined4 *)(*(int *)(base_pointer - 0x10) - 0x48));\n}\n"}
{"Function Name": "Unwind@10026ff0", "Address": "10026ff0", "Source Code": "\nvoid Unwind_10026ff0(void)\n{\n    // Call the function FUN_10002040 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027020", "Address": "10027020", "Source Code": "\nvoid Unwind_10027020(void) // Function definition for Unwind_10027020\n{\n    // Call the destructor for the exception object pointed to by the address \n    // calculated from the stack pointer (unaff_EBP) minus 16 bytes\n    exception::~exception(*(exception **)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10027028", "Address": "10027028", "Source Code": "\nvoid Unwind_10027028(void)\n{\n    // Call the function located at the address obtained by dereferencing the pointer\n    // at (unaff_EBP - 0x10) and adding 0xc to the resulting integer value.\n    function_call(*(int *)(*(int *)(base_pointer + -0x10)) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027050", "Address": "10027050", "Source Code": "\nvoid Unwind_10027050(void) // Function definition for Unwind_10027050\n{\n    // Call the destructor for the exception object pointed to by the address \n    // calculated from the stack pointer (unaff_EBP) minus 0x10\n    exception::~exception(*(exception **)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10027058", "Address": "10027058", "Source Code": "\nvoid Unwind_10027058(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the result of adding 0xc to the value\n    // stored at the memory location pointed to by \n    // (unaff_EBP - 0x10).\n    function_call(*(int *)(base_pointer - 0x10) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027080", "Address": "10027080", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027080\n{\n    // Call the function FUN_1000fe01 with a pointer obtained from dereferencing the value at memory address 0x10\n    functionToCall(*(int **)(*(int *)0x10));\n}\n"}
{"Function Name": "Unwind@10027088", "Address": "10027088", "Source Code": "\nvoid Unwind_10027088(void)\n{\n    // Call the function FUN_100033d0 with an argument that is \n    // the value at the memory location pointed to by (unaff_EBP - 0x10) \n    // plus an offset of 4.\n    function_call(*(int *)(base_pointer - 0x10) + 4);\n}\n"}
{"Function Name": "Unwind@10027093", "Address": "10027093", "Source Code": "\nvoid Unwind_10027093(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer located at \n    // (unaff_EBP - 0x10) and adding 0x20 to the resulting integer value\n    function_call(*(int *)(base_pointer - 0x10) + 0x20);\n}\n"}
{"Function Name": "Unwind@1002709e", "Address": "1002709e", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002709e\n{\n    // Call the function FUN_100033d0 with a calculated argument\n    functionCall( // Function call to FUN_100033d0\n        *(int *)(*(int *)0xFFFFFFFF + -0x10) + 0x3c // Dereference a pointer and add offset\n    );\n}\n"}
{"Function Name": "Unwind@100270a9", "Address": "100270a9", "Source Code": "\nvoid Unwind_100270a9(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the sum of the value at the memory address\n    // (unaff_EBP - 0x10) and the offset 0x58.\n    function_call(*(int *)(base_pointer - 0x10) + 0x58);\n}\n"}
{"Function Name": "Unwind@100270d0", "Address": "100270d0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100270d0\n{\n    // Call the function FUN_100033d0 with the argument being the dereferenced value\n    // of the pointer located at address 0xFFFFFFF0, which itself is dereferenced to get an integer.\n    functionCall(*(int *)(*(int *)0xFFFFFFF0));\n}\n"}
{"Function Name": "Unwind@100270d8", "Address": "100270d8", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the sum of the value at the memory address \n    // (unaff_EBP - 0x10) and 0x20.\n    functionCall(*(int *)(basePointer - 0x10) + 0x20);\n}\n"}
{"Function Name": "Unwind@100270e3", "Address": "100270e3", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100270e3\n{\n    // Call the function FUN_100033d0 with an argument calculated from a pointer dereference\n    functionCall(*(int *)(*(int *)0xFFFFFFEC) + 0x3c);\n}\n"}
{"Function Name": "Unwind@100270ee", "Address": "100270ee", "Source Code": "\nvoid Unwind_100270ee(void) // Function definition for Unwind_100270ee\n{\n    // Call the function FUN_100033d0 with an argument that is the sum of \n    // the value at the memory address (unaff_EBP - 0x10) and 0x58\n    FUN_100033d0(*(int *)(unaff_EBP - 0x10) + 0x58);\n}\n"}
{"Function Name": "Unwind@100270f9", "Address": "100270f9", "Source Code": "\nvoid Unwind_100270f9(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer at (unaff_EBP - 0x10)\n    // and adding 0x78 to the resulting integer value.\n    function_call(*(int *)(base_pointer - 0x10) + 0x78);\n}\n"}
{"Function Name": "Unwind@10027104", "Address": "10027104", "Source Code": "\nvoid Unwind_10027104(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is calculated by dereferencing the pointer at (unaff_EBP - 0x10)\n    // and adding 0x94 to the resulting integer value.\n    function_call(*(int *)(base_pointer - 0x10) + 0x94);\n}\n"}
{"Function Name": "Unwind@10027112", "Address": "10027112", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027112\n{\n    // Call the function FUN_100033d0 with an argument calculated from a pointer dereference\n    processData(*(int *)(*(int *)0xFFFFFFF0) + 0xb0);\n}\n"}
{"Function Name": "Unwind@10027120", "Address": "10027120", "Source Code": "\nvoid Unwind_10027120(void)\n{\n    // Call the function FUN_100033d0 with an argument that is the result of \n    // adding 0xcc to the integer value located at the memory address \n    // pointed to by (unaff_EBP - 0x10).\n    function_call(*(int *)(base_pointer - 0x10) + 0xcc);\n}\n"}
{"Function Name": "Unwind@1002712e", "Address": "1002712e", "Source Code": "\nvoid Unwind_1002712e(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the result of adding 0xec to the value\n    // located at the memory address (unaff_EBP - 0x10).\n    function_call(*(int *)(base_pointer - 0x10) + 0xec);\n}\n"}
{"Function Name": "Unwind@1002713c", "Address": "1002713c", "Source Code": "\nvoid Unwind_1002713c(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer stored at unaff_EBP - 0x10\n    // and adding 0x11c to the integer value pointed to by that dereferenced pointer\n    function_call(*(int *)(*(int *)(base_pointer + -0x10)) + 0x11c);\n}\n"}
{"Function Name": "Unwind@1002714a", "Address": "1002714a", "Source Code": "\nvoid Unwind_1002714a(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the sum of the value at the memory address \n    // (unaff_EBP - 0x10) and the offset 0x138\n    function_call(*(int *)(base_pointer - 0x10) + 0x138);\n}\n"}
{"Function Name": "Unwind@10027180", "Address": "10027180", "Source Code": "\nvoid Unwind_10027180(void)\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained from the stack at the offset -0x10 from the base pointer (unaff_EBP)\n    FUN_100033d0(*(int *)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10027188", "Address": "10027188", "Source Code": "\nvoid Unwind_10027188(void)\n{\n    // Call the function FUN_10003810 with an argument\n    // The argument is obtained by dereferencing a pointer at (unaff_EBP - 0x10)\n    // and adding 0x20 to the resulting integer value\n    function_call(*(int *)(base_pointer - 0x10) + 0x20);\n}\n"}
{"Function Name": "Unwind@100271b0", "Address": "100271b0", "Source Code": "\nvoid Unwind_100271b0(void)\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained from the stack using the offset from the base pointer (unaff_EBP)\n    function_call(*(int *)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100271b8", "Address": "100271b8", "Source Code": "\nvoid Unwind_100271b8(void)\n{\n    // Call the function FUN_10003810 with an argument\n    // The argument is calculated by dereferencing a pointer at (unaff_EBP - 0x10)\n    // and adding 0x20 to the integer value obtained from that pointer\n    function_call(*(int *)(base_pointer - 0x10) + 0x20);\n}\n"}
{"Function Name": "Unwind@100271e0", "Address": "100271e0", "Source Code": "\nvoid Unwind_100271e0(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer at (unaff_EBP - 0x10) and adding 4 to the resulting integer\n    function_call(*(int *)(base_pointer - 0x10) + 4);\n}\n"}
{"Function Name": "Unwind@10027210", "Address": "10027210", "Source Code": "\nvoid Unwind_10027210(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing the pointer at (unaff_EBP - 0x10)\n    // and adding 4 to the resulting integer value.\n    function_call(*(int *)(base_pointer - 0x10) + 4);\n}\n"}
{"Function Name": "Unwind@10027260", "Address": "10027260", "Source Code": "\nvoid Unwind_10027260(void)\n{\n    // Call the function FUN_100033d0 with the argument calculated as \n    // the value at the memory address (unaff_EBP - 0x10) plus 4.\n    function_call(*(int *)(base_pointer - 0x10) + 4);\n}\n"}
{"Function Name": "Unwind@10027290", "Address": "10027290", "Source Code": "\nvoid Unwind_10027290(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer located at \n    // (unaff_EBP - 0x10) and adding 4 to the resulting integer value.\n    function_call(*(int *)(base_pointer - 0x10) + 4);\n}\n"}
{"Function Name": "Unwind@100272c0", "Address": "100272c0", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer at (unaff_EBP - 0x10)\n    // and adding 4 to the resulting integer value\n    functionCall(*(int *)(basePointer - 0x10) + 4);\n}\n"}
{"Function Name": "Unwind@100272f0", "Address": "100272f0", "Source Code": "\nvoid Unwind_100272f0(void) // Function definition for Unwind_100272f0\n{\n    // Call the destructor for the exception object pointed to by the address\n    // calculated as (unaff_EBP - 0x10), casting it to a pointer to an exception object.\n    exception::~ExceptionObject(*(exception **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100272f8", "Address": "100272f8", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100272f8\n{\n    // Call the function FUN_100033d0 with the argument calculated as follows:\n    // Dereference the pointer at address 0x10 to get an integer pointer,\n    // then dereference that pointer to get an integer value,\n    // add 0xc (12 in decimal) to that integer value,\n    // and pass the result to FUN_100033d0.\n    processFunction(*(int *)(*(int *)0x10) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027320", "Address": "10027320", "Source Code": "\nvoid Unwind_10027320(void) // Function definition for Unwind_10027320\n{\n    // Call the function FUN_100035d0 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    FUN_100035d0(*(undefined4 **)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10027350", "Address": "10027350", "Source Code": "\nvoid Unwind_10027350(void)\n{\n    // Call the function FUN_100035d0 with the argument being a pointer\n    // dereferenced from the stack frame at offset -0x10 from the base pointer (unaff_EBP).\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027380", "Address": "10027380", "Source Code": "\nvoid Unwind_10027380(void)\n{\n    // Call the function FUN_100035d0 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    callFunction(*(undefined4 **)(basePointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100273b0", "Address": "100273b0", "Source Code": "\nvoid Unwind_100273b0(void)\n{\n    // Call the function FUN_100035d0 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100273e0", "Address": "100273e0", "Source Code": "\nvoid Unwind_100273e0(void)\n{\n    // Call the function FUN_100035d0 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    function_call(*(undefined4 **)(base_pointer + -0x10));\n}\n"}
{"Function Name": "Unwind@10027410", "Address": "10027410", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027410\n{\n    // Call FUN_100035d0 with the dereferenced pointer from the address 0x10\n    functionCall(*(undefined4 **)(*(int *)0x10));\n}\n"}
{"Function Name": "Unwind@10027440", "Address": "10027440", "Source Code": "\nvoid Unwind_10027440(void)\n{\n    // Call the destructor for the exception object pointed to by the address \n    // stored at (unaff_EBP - 0x10), which is cast to a pointer to an exception object.\n    exception::~ExceptionHandler(*(exception **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027448", "Address": "10027448", "Source Code": "\nvoid Unwind_10027448(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the result of adding 0xc to the value\n    // stored at the memory location pointed to by\n    // (unaff_EBP - 0x10) cast to an integer pointer.\n    function_call(*(int *)(base_pointer - 0x10) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027470", "Address": "10027470", "Source Code": "\nvoid Unwind_10027470(void) // Function definition for Unwind_10027470\n{\n    // Call the function FUN_10003680 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the address at (unaff_EBP - 0x10)\n    FUN_10003680(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100274a0", "Address": "100274a0", "Source Code": "\nvoid Unwind_100274a0(void)\n{\n    // Call the function FUN_10003680 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100274d0", "Address": "100274d0", "Source Code": "\nvoid Unwind_100274d0(void)\n{\n    // Call the function FUN_10003680 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // EBP register (unaff_EBP).\n    callFunction(*(undefined4 **)(basePointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027500", "Address": "10027500", "Source Code": "\nvoid Unwind_10027500(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x20) is set\n    if ((*(uint *)(base_pointer - 0x20) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x20)\n        *(uint *)(base_pointer - 0x20) &= 0xfffffffe;\n        // Call the function FUN_100033d0 with the value at (unaff_EBP - 0x24) as an argument\n        function_call(*(int *)(base_pointer - 0x24));\n    }\n}\n"}
{"Function Name": "Unwind@10027550", "Address": "10027550", "Source Code": "\nvoid Unwind_10027550(void) // Function definition for Unwind_10027550\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained by dereferencing a pointer located at \n    // the address of unaff_EBP minus 16 bytes\n    FUN_100033d0(*(int *)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10027558", "Address": "10027558", "Source Code": "\nvoid Unwind_10027558(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the sum of the value at the address (unaff_EBP - 0x10)\n    // and an offset of 0x20.\n    function_call(*(int *)(base_pointer - 0x10) + 0x20);\n}\n"}
{"Function Name": "Unwind@10027563", "Address": "10027563", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with the argument calculated as follows:\n    // Dereference the pointer at address 0xFFFFFFEC to get an integer pointer,\n    // then dereference that pointer to get an integer value.\n    // Add 0x3c to this integer value before passing it to FUN_100033d0.\n    calculateFunction(*(int *)(*(int *)0xFFFFFFEC) + 0x3c);\n}\n"}
{"Function Name": "Unwind@1002756e", "Address": "1002756e", "Source Code": "\nvoid Unwind_1002756e(void) // Function definition for Unwind_1002756e\n{\n    // Call the function FUN_100033d0 with an argument that is the sum of \n    // the value at the memory address (unaff_EBP - 0x10) and 0x58\n    FUN_100033d0(*(int *)(unaff_EBP - 0x10) + 0x58);\n}\n"}
{"Function Name": "Unwind@10027579", "Address": "10027579", "Source Code": "\nvoid Unwind_10027579(void)\n{\n    // Call the function FUN_100033d0 with an argument calculated from the value at \n    // the memory location (unaff_EBP - 0x10) plus an offset of 0x78.\n    function_call(*(int *)(base_pointer - 0x10) + 0x78);\n}\n"}
{"Function Name": "Unwind@10027584", "Address": "10027584", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the result of adding 0x94 to the value\n    // located at the memory address (unaff_EBP - 0x10).\n    functionCall(*(int *)(basePointer - 0x10) + 0x94);\n}\n"}
{"Function Name": "Unwind@10027592", "Address": "10027592", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with a calculated argument\n    // Dereference the pointer at address 0xFFFFFFFF to get an integer\n    // Subtract 0x10 from that integer to get another pointer\n    // Dereference that pointer to get another integer\n    // Add 0xb0 to that integer and pass the result to FUN_100033d0\n    functionCall(*(int *)(*(int *)0xFFFFFFFF + -0x10) + 0xb0);\n}\n"}
{"Function Name": "Unwind@100275a0", "Address": "100275a0", "Source Code": "\nvoid Unwind_100275a0(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the sum of the value at the memory address\n    // (unaff_EBP - 0x10) and the constant 0xcc\n    function_call(*(int *)(base_pointer - 0x10) + 0xcc);\n}\n"}
{"Function Name": "Unwind@100275ae", "Address": "100275ae", "Source Code": "\nvoid Unwind_100275ae(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer located at \n    // the address calculated from unaff_EBP and offset -0x10, \n    // and then accessing the member at offset 0xec of that structure.\n    function_call(*(int *)(*(int *)(base_pointer + -0x10) + 0xec));\n}\n"}
{"Function Name": "Unwind@100275bc", "Address": "100275bc", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100275bc\n{\n    // Call the function FUN_100033d0 with an argument calculated from a pointer dereference\n    functionCall(*(int *)(*(int *)0x10) + 0x11c);\n}\n"}
{"Function Name": "Unwind@100275ca", "Address": "100275ca", "Source Code": "\nvoid Unwind_100275ca(void)\n{\n    // Call the function FUN_100033d0 with an argument calculated from the value at \n    // the memory location (unaff_EBP - 0x10) plus an offset of 0x138.\n    function_call(*(int *)(base_pointer - 0x10) + 0x138);\n}\n"}
{"Function Name": "Unwind@10027600", "Address": "10027600", "Source Code": "\nvoid Unwind_10027600(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x10) is set\n    if ((*(uint *)(base_pointer - 0x10) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x10)\n        *(uint *)(base_pointer - 0x10) &= 0xfffffffe;\n        // Call the function FUN_100033d0 with the value at (unaff_EBP + 4) as an argument\n        function_call(*(int *)(base_pointer + 4));\n    }\n}\n"}
{"Function Name": "Unwind@10027640", "Address": "10027640", "Source Code": "\nvoid Unwind_10027640(void)\n{\n    // Call the function FUN_10003b90 with an argument\n    // The argument is obtained by dereferencing a pointer located at unaff_EBP - 0x10,\n    // then accessing the member at offset 0xc of that structure.\n    function_call(*(int *)(*(int *)(base_pointer + -0x10) + 0xc));\n}\n"}
{"Function Name": "Unwind@10027670", "Address": "10027670", "Source Code": "\nvoid Unwind_10027670(void) // Function definition for Unwind_10027670\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained by dereferencing a pointer located at (unaff_EBP - 0x10)\n    function_call(*(int *)(base_pointer + -0x10));\n}\n"}
{"Function Name": "Unwind@10027678", "Address": "10027678", "Source Code": "\nvoid Unwind_10027678(void)\n{\n    // Call the function FUN_10003810 with an argument calculated from the value at the stack pointer\n    // (unaff_EBP - 0x10) and an offset of 0x20 added to it.\n    function_call(*(int *)(base_pointer - 0x10) + 0x20);\n}\n"}
{"Function Name": "Unwind@100276a0", "Address": "100276a0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100276a0\n{\n    functionCall(-0x28); // Call to FUN_100033d0 with an argument of -0x28\n}\n"}
{"Function Name": "Unwind@100276a8", "Address": "100276a8", "Source Code": "\nvoid Unwind_100276a8(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x2c) is set\n    if ((*(uint *)(base_pointer - 0x2c) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x2c)\n        *(uint *)(base_pointer - 0x2c) &= 0xfffffffe;\n        // Call the function FUN_100033d0 with the argument from (unaff_EBP + 4)\n        function_call(*(int *)(base_pointer + 4));\n    }\n}\n"}
{"Function Name": "Unwind@100276e0", "Address": "100276e0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100276e0\n{\n    callFunction(-0x28); // Call to FUN_100033d0 with argument -0x28\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100276e8", "Address": "100276e8", "Source Code": "\nvoid Unwind_100276e8(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x2c) is set\n    if ((*(uint *)(base_pointer - 0x2c) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x2c)\n        *(uint *)(base_pointer - 0x2c) &= 0xfffffffe;\n        // Call the function FUN_100033d0 with the argument at (unaff_EBP + 4)\n        function_call(*(int *)(base_pointer + 4));\n    }\n}\n"}
{"Function Name": "Unwind@10027720", "Address": "10027720", "Source Code": "\nvoid Unwind_10027720(void) // Function definition for Unwind_10027720\n{\n    // Call the function FUN_100033d0 with an argument that is the integer value\n    // located at the memory address calculated by subtracting 0x10 from the value\n    // in the register unaff_EBP.\n    FUN_100033d0(*(int *)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027728", "Address": "10027728", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027728\n{\n    // Call the function FUN_10003810 with an argument calculated from a pointer dereference\n    functionCall(*(int *)(*(int *)0xFFFFFFF0) + 0x20);\n}\n"}
{"Function Name": "Unwind@10027750", "Address": "10027750", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027750\n{\n    functionCall(0xc); // Call to FUN_100033d0 with argument 0xc\n}\n"}
{"Function Name": "Unwind@10027758", "Address": "10027758", "Source Code": "\nvoid Unwind_10027758(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x14) is set\n    if ((*(uint *)(base_pointer - 0x14) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x14)\n        *(uint *)(base_pointer - 0x14) &= 0xfffffffe;\n        // Call the function FUN_10003b20 with the value at (unaff_EBP - 0x10) as an argument\n        function_call(*(int *)(base_pointer - 0x10));\n    }\n}\n"}
{"Function Name": "Unwind@10027790", "Address": "10027790", "Source Code": "\nvoid Unwind_10027790(void) // Function definition for Unwind_10027790\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained by dereferencing a pointer located at \n    // an offset of -0x10 from the base pointer (unaff_EBP)\n    FUN_100033d0(*(int *)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10027798", "Address": "10027798", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function located at the address obtained by dereferencing the pointer at 0xFFFFFFF0\n    // and adding 0x20 to the integer value it points to.\n    functionCall(*(int *)(*(int *)0xFFFFFFF0) + 0x20);\n}\n"}
{"Function Name": "Unwind@100277c0", "Address": "100277c0", "Source Code": "\nvoid Unwind_100277c0(void)\n{\n    // Call the function FUN_1000fe01 with a pointer obtained from the stack frame\n    // The pointer is located at an offset of -0x54 from the base pointer (unaff_EBP)\n    FUN_1000fe01(*(int **)(base_pointer - 0x54));\n}\n"}
{"Function Name": "Unwind@100277c8", "Address": "100277c8", "Source Code": "\nvoid Unwind_100277c8(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the value at the memory address (unaff_EBP - 0x54) plus 4\n    function_call(*(int *)(base_pointer - 0x54) + 4);\n}\n"}
{"Function Name": "Unwind@100277d3", "Address": "100277d3", "Source Code": "\nvoid Unwind_100277d3(void) // Function definition for Unwind_100277d3\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained by dereferencing a pointer located at \n    // the address (unaff_EBP - 0x34)\n    FUN_100033d0(*(int *)(unaff_EBP - 0x34));\n}\n"}
{"Function Name": "Unwind@100277de", "Address": "100277de", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100277de\n{\n    // Call FUN_100033d0 with an argument calculated from a dereferenced pointer\n    functionCall(*(int *)(*(int *)0x0 - 0x54) + 0x3c);\n}\n"}
{"Function Name": "Unwind@100277e9", "Address": "100277e9", "Source Code": "\nvoid Unwind_100277e9(void)\n{\n    // Call the function FUN_100033d0 with an argument calculated from the value at \n    // the memory location (unaff_EBP - 0x54) plus an offset of 0x58.\n    function_call(*(int *)(base_pointer - 0x54) + 0x58);\n}\n"}
{"Function Name": "Unwind@100277f4", "Address": "100277f4", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100277f4\n{\n    functionCall(-0x50); // Call to FUN_100033d0 with argument -0x50\n}\n"}
{"Function Name": "Unwind@10027820", "Address": "10027820", "Source Code": "\nvoid Unwind_10027820(void) // Function definition for Unwind_10027820\n{\n    // Call the destructor for the exception object pointed to by the address\n    // calculated as (unaff_EBP - 0x10), which is cast to a pointer to an exception object.\n    exception::~ExceptionObject(*(exception **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027828", "Address": "10027828", "Source Code": "\nvoid Unwind_10027828(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the result of adding 0xc to the value\n    // located at the memory address pointed to by\n    // (unaff_EBP - 0x10).\n    function_call(*(int *)(base_pointer - 0x10) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027850", "Address": "10027850", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027850\n{\n    // Call the function FUN_100019c0 with a pointer obtained from dereferencing a pointer at address 0xFFFFFFC4\n    functionCall(*(undefined4 **)(*(int *)0xFFFFFFC4)));\n}\n"}
{"Function Name": "Unwind@1002785b", "Address": "1002785b", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002785b\n{\n    functionCall((int *)(basePointer - 0x84)); // Call FUN_10003720 with a pointer to an integer, offset from unaff_EBP\n}\n"}
{"Function Name": "Unwind@100278a0", "Address": "100278a0", "Source Code": "\nvoid Unwind_100278a0(void)\n{\n    // Call the function FUN_100019c0 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // EBP register (unaff_EBP).\n    FUN_100019c0(*(undefined4 **)(unaff_EBP_value - 0x10));\n}\n"}
{"Function Name": "Unwind@100278a8", "Address": "100278a8", "Source Code": "\nvoid Unwind_100278a8(void)\n{\n    // Call the function FUN_10001910 with a pointer obtained from the address 0xFFFFFFF0\n    // Dereference the pointer at 0xFFFFFFF0 to get an integer, then dereference that integer\n    // to obtain a pointer of type undefined4* which is passed to FUN_10001910\n    callFunction(*(undefined4 **)(*(int *)0xFFFFFFF0)));\n}\n"}
{"Function Name": "Unwind@100278d0", "Address": "100278d0", "Source Code": "\nvoid Unwind_100278d0(void)\n{\n    // Dereference the null pointer (0) to get the first integer\n    // Then access the integer at offset 4 from that address\n    // Cast it to a pointer to void and dereference it to get the pointer to free\n    // Finally, call the _free function with the obtained pointer\n    free_function(*(void **)(*(int *)0 + 4));\n}\n"}
{"Function Name": "Unwind@10027900", "Address": "10027900", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027900\n{\n    callFunction(-0x50); // Call to FUN_100033d0 with argument -0x50\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027908", "Address": "10027908", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027908\n{\n    functionCall(-0x50); // Call to FUN_100033d0 with argument -0x50\n}\n"}
{"Function Name": "Unwind@10027910", "Address": "10027910", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027910\n{\n    callFunction(-0x50); // Call to FUN_100033d0 with an argument of -80 (hexadecimal -0x50)\n}\n"}
{"Function Name": "Unwind@10027940", "Address": "10027940", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027940\n{\n    // Call FUN_10003680 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the integer at memory address 0x10\n    callFunction(*(undefined4 **)(*(int *)0x10));\n}\n"}
{"Function Name": "Unwind@10027970", "Address": "10027970", "Source Code": "\nvoid Unwind_10027970(void)\n{\n    int basePointer; // Declare an integer variable to hold an unspecified base pointer\n    // Check if the least significant bit of the value at (unaff_EBP - 0x40) is set\n    if ((*(uint *)(basePointer - 0x40) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x40)\n        *(uint *)(basePointer - 0x40) &= 0xfffffffe;\n        // Call the function FUN_100033d0 with the value at (unaff_EBP - 0x3c)\n        processValue(*(int *)(basePointer - 0x3c));\n    }\n}\n"}
{"Function Name": "Unwind@100279c0", "Address": "100279c0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100279c0\n{\n    callFunction(-0x28); // Call to FUN_100033d0 with an argument of -0x28\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100279f0", "Address": "100279f0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100279f0\n{\n    functionCall(-0x28); // Call FUN_100033d0 with an argument of -0x28\n}\n"}
{"Function Name": "Unwind@10027a50", "Address": "10027a50", "Source Code": "\nvoid Unwind_10027a50(void)\n{\n    // Call the function FUN_10003aa0 with an argument\n    // The argument is obtained by dereferencing the pointer at (unaff_EBP - 0x10)\n    // and adding 0x10 to the resulting integer value.\n    function_call(*(int *)(base_pointer - 0x10) + 0x10);\n}\n"}
{"Function Name": "Unwind@10027a80", "Address": "10027a80", "Source Code": "\nvoid Unwind_10027a80(void)\n{\n    // Call the function FUN_1000fe01 with a pointer to an integer\n    // The pointer is calculated by subtracting 0x1c from the value of unaff_EBP\n    function_call((int *)(base_pointer - 0x1c));\n}\n"}
{"Function Name": "Unwind@10027ab0", "Address": "10027ab0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027ab0\n{\n    callFunction(-0x28); // Call to FUN_100033d0 with argument -0x28\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10027ab8", "Address": "10027ab8", "Source Code": "\nvoid Unwind_10027ab8(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x2c) is set\n    if ((*(uint *)(base_pointer - 0x2c) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x2c)\n        *(uint *)(base_pointer - 0x2c) &= 0xfffffffe;\n        // Call the function FUN_100033d0 with the argument from (unaff_EBP + 4)\n        function_call(*(int *)(base_pointer + 4));\n    }\n}\n"}
{"Function Name": "Unwind@10027af0", "Address": "10027af0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027af0\n{\n    callFunction(0x24); // Call to FUN_10003810 with argument 0x24\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027af8", "Address": "10027af8", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027af8\n{\n    callFunction(8); // Call the function FUN_100033d0 with an argument of 8\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027b00", "Address": "10027b00", "Source Code": "\nvoid Unwind_10027b00(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x14) is set\n    if ((*(uint *)(base_pointer - 0x14) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x14)\n        *(uint *)(base_pointer - 0x14) &= 0xfffffffe;\n        // Call the function FUN_10003a20 with the value at (unaff_EBP - 0x10) as an argument\n        function_call(*(int *)(base_pointer - 0x10));\n    }\n}\n"}
{"Function Name": "Unwind@10027b40", "Address": "10027b40", "Source Code": "\nvoid Unwind_10027b40(void) // Function declaration for Unwind_10027b40\n{\n    // Call the function FUN_100033d0 with an integer argument\n    // The argument is obtained by dereferencing a pointer located at \n    // the address of unaff_EBP minus 0x2c (44 in decimal)\n    FUN_100033d0(*(int *)(unaff_base_pointer - 0x2c));\n}\n"}
{"Function Name": "Unwind@10027b48", "Address": "10027b48", "Source Code": "\nvoid Unwind_10027b48(void)\n{\n    // Call the function FUN_100033d0 with an argument calculated from the value\n    // at the memory address (unaff_EBP - 0x2c) plus an offset of 0x20.\n    function_call(*(int *)(base_pointer - 0x2c) + 0x20);\n}\n"}
{"Function Name": "Unwind@10027b53", "Address": "10027b53", "Source Code": "\nvoid Unwind_10027b53(void)\n{\n    // Call the function FUN_100033d0 with an argument calculated from the value at \n    // the memory location pointed to by (unaff_EBP - 0x2c) plus an offset of 0x3c.\n    function_call(*(int *)(base_pointer - 0x2c) + 0x3c);\n}\n"}
{"Function Name": "Unwind@10027b5e", "Address": "10027b5e", "Source Code": "\nvoid Unwind_10027b5e(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer at address 0xFFFFFFD4,\n    // then dereferencing that result to get an integer, and finally adding 0x58 to it.\n    callFunction(*(int *)(*(int *)0xFFFFFFD4) + 0x58);\n}\n"}
{"Function Name": "Unwind@10027b69", "Address": "10027b69", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function located at the address calculated by dereferencing the pointer at 0xFFFFFFD4\n    // and adding 0x78 to the integer value it points to.\n    executeFunction(*(int *)(*(int *)0xFFFFFFD4) + 0x78);\n}\n"}
{"Function Name": "Unwind@10027b74", "Address": "10027b74", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function located at the address obtained by dereferencing the pointer at 0xFFFFFFD4\n    // and adding 0x94 to the integer value pointed to by that address.\n    callFunction(*(int *)(*(int *)0xFFFFFFD4) + 0x94);\n}\n"}
{"Function Name": "Unwind@10027b82", "Address": "10027b82", "Source Code": "\nvoid Unwind_10027b82(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is calculated by dereferencing a pointer located at (unaff_EBP - 0x2c)\n    // and then adding 0xb0 to the integer value obtained from that pointer.\n    function_call(*(int *)(*(int *)(base_pointer + -0x2c)) + 0xb0);\n}\n"}
{"Function Name": "Unwind@10027b90", "Address": "10027b90", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function located at the address calculated by dereferencing \n    // the pointer at address 0xFFFFFFD4 and adding 0xcc to the integer value \n    // obtained from that pointer.\n    callFunction(*(int *)(*(int *)0xFFFFFFD4) + 0xcc);\n}\n"}
{"Function Name": "Unwind@10027b9e", "Address": "10027b9e", "Source Code": "\nvoid Unwind_10027b9e(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // that is the result of adding 0xec to the value\n    // stored at the memory address (unaff_EBP - 0x2c).\n    function_call(*(int *)(base_pointer - 0x2c) + 0xec);\n}\n"}
{"Function Name": "Unwind@10027bac", "Address": "10027bac", "Source Code": "\nvoid Unwind_10027bac(void)\n{\n    // Call the function FUN_100033d0 with an argument calculated from the value at \n    // the memory address (unaff_EBP - 0x2c) plus an offset of 0x11c.\n    function_call(*(int *)(base_pointer - 0x2c) + 0x11c);\n}\n"}
{"Function Name": "Unwind@10027bba", "Address": "10027bba", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027bba\n{\n    // Call the function FUN_100033d0 with an argument calculated from a dereferenced pointer\n    functionCall(*(int *)(*(int *)0xFFFFFFD4) + 0x138);\n}\n"}
{"Function Name": "Unwind@10027bc8", "Address": "10027bc8", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027bc8\n{\n    callFunction(-0x28); // Call FUN_100033d0 with argument -0x28\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027bf0", "Address": "10027bf0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027bf0\n{\n    callFunction(0x38); // Call the function FUN_100033d0 with argument 0x38\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027bf8", "Address": "10027bf8", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027bf8\n{\n    callFunction(0x54); // Call to FUN_100033d0 with argument 0x54\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027c00", "Address": "10027c00", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027c00\n{\n    callFunction(0x8c); // Call to FUN_100033d0 with argument 0x8c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027c0b", "Address": "10027c0b", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c0b\n{\n    callFunction(0x70); // Call to FUN_100033d0 with argument 0x70\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10027c13", "Address": "10027c13", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c13\n{\n    functionCall(basePointer + 0x8c); // Call FUN_100033d0 with an argument calculated from unaff_EBP\n}\n"}
{"Function Name": "Unwind@10027c1e", "Address": "10027c1e", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027c1e\n{\n    callFunction(0x1c); // Call to FUN_100033d0 with argument 0x1c\n}\n"}
{"Function Name": "Unwind@10027c26", "Address": "10027c26", "Source Code": "\nvoid Unwind_10027c26(void) // Function declaration for Unwind_10027c26\n{\n    FUN_100033d0(unaff_EBP); // Call to FUN_100033d0 with unaff_EBP as an argument\n}\n"}
{"Function Name": "Unwind@10027c2e", "Address": "10027c2e", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c2e\n{\n    callFunction(0x54); // Call to FUN_100033d0 with argument 0x54\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027c36", "Address": "10027c36", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c36\n{\n    callFunction(-0x4c); // Call to FUN_100033d0 with argument -0x4c\n}\n"}
{"Function Name": "Unwind@10027c3e", "Address": "10027c3e", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027c3e\n{\n    callFunction(-0x68); // Call FUN_100033d0 with an argument of -0x68\n}\n"}
{"Function Name": "Unwind@10027c46", "Address": "10027c46", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c46\n{\n    callFunction(-0x84); // Call FUN_100033d0 with an argument of -0x84\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027c51", "Address": "10027c51", "Source Code": "\nvoid Unwind_10027c51(void)\n{\n    // Dereference the pointer at address 0xFFFFFFD8 to get an integer\n    // Then, use that integer to dereference again to get a pointer\n    // Finally, dereference that pointer to get the actual pointer to free\n    free_pointer(*(void **)(*(int *)0xFFFFFFD8));\n}\n"}
{"Function Name": "Unwind@10027c5c", "Address": "10027c5c", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c5c\n{\n    callFunction(0x1c); // Call the function FUN_100033d0 with argument 0x1c\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10027c64", "Address": "10027c64", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027c64\n{\n    processFunction(-0x4c); // Call to FUN_100033d0 with argument -0x4c\n}\n"}
{"Function Name": "Unwind@10027c6c", "Address": "10027c6c", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c6c\n{\n    callFunction(-0x68); // Call FUN_100033d0 with argument -0x68\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027c74", "Address": "10027c74", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027c74\n{\n    callFunction(-0x4c); // Call to FUN_100033d0 with argument -0x4c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027c7c", "Address": "10027c7c", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c7c\n{\n    callFunction(-0x68); // Call to FUN_100033d0 with an argument of -0x68\n}\n"}
{"Function Name": "Unwind@10027c84", "Address": "10027c84", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027c84\n{\n    callFunction(-0x4c); // Call to FUN_100033d0 with argument -0x4c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027cc0", "Address": "10027cc0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027cc0\n{\n    callFunction(-0x50); // Call to FUN_100033d0 with argument -0x50\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027cf0", "Address": "10027cf0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027cf0\n{\n    // Call the destructor for the exception object pointed to by the address at 0xFFFFFFF0\n    exception::~ExceptionType(*(exception **)(*(int *)0xFFFFFFF0)); \n}\n"}
{"Function Name": "Unwind@10027cf8", "Address": "10027cf8", "Source Code": "\nvoid Unwind_10027cf8(void)\n{\n    // Call the function FUN_100033d0 with an argument that is the sum of \n    // the value at the memory address (unaff_EBP - 0x10) and 0xc\n    function_call(*(int *)(base_pointer - 0x10) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027d20", "Address": "10027d20", "Source Code": "\nvoid Unwind_10027d20(void)\n{\n    // Call the function FUN_100035d0 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10).\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027d80", "Address": "10027d80", "Source Code": "\nvoid Unwind_10027d80(void)\n{\n    // Call the function FUN_10001920 with a pointer to an integer\n    // located at the address (unaff_EBP - 0x10)\n    function_call((uint *)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027db0", "Address": "10027db0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027db0\n{\n    functionCall(-0x50); // Call FUN_100033d0 with an argument of -80 (hex -0x50)\n}\n"}
{"Function Name": "Unwind@10027db8", "Address": "10027db8", "Source Code": "\nvoid Unwind_10027db8(void)\n{\n    // Call the function FUN_10003aa0 with an argument calculated from the value at \n    // the memory location (unaff_EBP - 0x54) plus an offset of 0x10.\n    function_call(*(int *)(base_pointer - 0x54) + 0x10);\n}\n"}
{"Function Name": "Unwind@10027de0", "Address": "10027de0", "Source Code": "\nvoid Unwind_10027de0(void)\n{\n    // Call the function FUN_100035d0 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // unaff_EBP register.\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027e10", "Address": "10027e10", "Source Code": "\nvoid Unwind_10027e10(void)\n{\n    // Call the function FUN_10003aa0 with an argument\n    // that is the sum of the value at (unaff_EBP + 4) and 0x10\n    function_call(*(int *)(base_pointer + 4) + 0x10);\n}\n"}
{"Function Name": "Unwind@10027e40", "Address": "10027e40", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027e40\n{\n    callFunction(-0x50); // Call to FUN_100033d0 with argument -0x50\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10027e48", "Address": "10027e48", "Source Code": "\nvoid Unwind_10027e48(void)\n{\n    // Call the function FUN_10003b90 with an argument calculated from the value at \n    // the memory location (unaff_EBP - 0x54) plus an offset of 0xc\n    function_call(*(int *)(base_pointer - 0x54) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027e70", "Address": "10027e70", "Source Code": "\nvoid Unwind_10027e70(void)\n{\n    // Call the function FUN_10003b90 with an argument calculated from a pointer dereference\n    // Dereference the pointer at address 0, then dereference that result to get an integer\n    // Add 4 to that integer to get the address of the next integer\n    // Dereference that integer to get another integer, then add 0xc (12 in decimal) to it\n    // Pass the resulting integer to FUN_10003b90\n    callFunction(*(int *)(*(int *)0 + 4) + 0xc);\n}\n"}
{"Function Name": "Unwind@10027e7b", "Address": "10027e7b", "Source Code": "\nvoid Unwind_10027e7b(void)\n{\n    // Call the function FUN_100033d0 with the argument being the value at the address\n    // obtained by dereferencing the pointer stored at unaff_EBP and adding 4 to it.\n    function_call(*(int *)(*(int *)base_pointer + 4));\n}\n"}
{"Function Name": "Unwind@10027eb0", "Address": "10027eb0", "Source Code": "\nvoid Unwind_10027eb0(void)\n{\n    // Call the function FUN_10001920 with a pointer to an integer\n    // The pointer is obtained by dereferencing the integer at address 0\n    // and then adding 8 to it, effectively accessing the value at that offset\n    callFunction((uint *)(*(int *)0 + 8));\n}\n"}
{"Function Name": "Unwind@10027ee0", "Address": "10027ee0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027ee0\n{\n    functionCall(-0x50); // Call to FUN_100033d0 with argument -0x50\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10027f10", "Address": "10027f10", "Source Code": "\nvoid Unwind_10027f10(void)\n{\n    // Call the function FUN_10002020 with a pointer to an integer pointer pointer\n    // The pointer is obtained by dereferencing the value at the address of unaff_EBP minus 0x10\n    function_call(*(int ***)(*(int *)&base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10027f40", "Address": "10027f40", "Source Code": "\nvoid Unwind_10027f40(void)\n{\n    // Call the function FUN_10002a50 with a pointer to an integer pointer,\n    // which is derived from the value of the stack pointer (unaff_EBP) minus 0x24.\n    FUN_10002a50((int **)(stack_pointer - 0x24));\n}\n"}
{"Function Name": "Unwind@10027f48", "Address": "10027f48", "Source Code": "\nvoid Unwind_10027f48(void)\n{\n    // Call the function FUN_10002020 with a pointer to an integer pointer,\n    // which is derived from the value of unaff_EBP minus 0x24.\n    function_call((int **)(base_pointer - 0x24));\n}\n"}
{"Function Name": "Unwind@10027f70", "Address": "10027f70", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027f70\n{\n    functionCall(-0x168); // Call to FUN_10003810 with argument -0x168\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027f7b", "Address": "10027f7b", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027f7b\n{\n    callFunction(-0x184); // Call to FUN_100033d0 with a negative integer argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027f86", "Address": "10027f86", "Source Code": "\nvoid Unwind_10027f86(void)\n{\n    // Call the function FUN_10003810 with an argument\n    // The argument is obtained by dereferencing a pointer located at \n    // the address of unaff_EBP minus 0x488, which is an offset from the base pointer.\n    function_call(*(int *)(base_pointer - 0x488));\n}\n"}
{"Function Name": "Unwind@10027f91", "Address": "10027f91", "Source Code": "\nvoid Unwind_10027f91(void) // Function declaration for Unwind_10027f91\n{\n    // Call the function FUN_100033d0 with an argument that is derived from a pointer\n    callFunction(*(int *)(*(int *)0xFFFFFFBC + -0x484));\n}\n"}
{"Function Name": "Unwind@10027f9c", "Address": "10027f9c", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027f9c\n{\n    functionCall(-0x2fc); // Call to FUN_10003a20 with argument -0x2fc\n}\n"}
{"Function Name": "Unwind@10027fa7", "Address": "10027fa7", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027fa7\n{\n    funCall(-0x474); // Call to FUN_10003aa0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10027fe0", "Address": "10027fe0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027fe0\n{\n    callFunction(0x54); // Call the function FUN_100033d0 with the argument 0x54\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027fe8", "Address": "10027fe8", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027fe8\n{\n    callFunction(0x1c); // Call FUN_100033d0 with argument 0x1c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027ff0", "Address": "10027ff0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10027ff0\n{\n    callFunction(0x38); // Call the function FUN_100033d0 with argument 0x38\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10027ff8", "Address": "10027ff8", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10027ff8\n{\n    functionCall(0); // Call to FUN_100033d0 with argument 0\n}\n"}
{"Function Name": "Unwind@10028000", "Address": "10028000", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028000\n{\n    functionCall(-0x34); // Call FUN_100033d0 with argument -0x34\n}\n"}
{"Function Name": "Unwind@10028030", "Address": "10028030", "Source Code": "\nvoid Unwind_10028030(void)\n{\n    int base_pointer; // Declare an integer variable to hold the base pointer\n\n    // Check if the least significant bit of the value at (unaff_EBP - 0x14) is set\n    if (*(uint *)(base_pointer - 0x14) & 1) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x14)\n        *(uint *)(base_pointer - 0x14) &= 0xfffffffe;\n\n        // Call the function FUN_10001b80 with a pointer to a specific location\n        function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x50));\n    }\n}\n"}
{"Function Name": "Unwind@1002804c", "Address": "1002804c", "Source Code": "\nvoid Unwind_1002804c(void)\n{\n    // Call the function FUN_10001be0 with an argument\n    // The argument is obtained by dereferencing a pointer located at \n    // (unaff_EBP - 0x10) and adding 8 to the integer value retrieved\n    function_call(*(int *)(base_pointer - 0x10) + 8);\n}\n"}
{"Function Name": "Unwind@10028057", "Address": "10028057", "Source Code": "\nvoid Unwind_10028057(void)\n{\n    // Call the function FUN_100021e0 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the value at (unaff_EBP - 0x10) and adding 8 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 8));\n}\n"}
{"Function Name": "Unwind@100280a0", "Address": "100280a0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280a0\n{\n    callFunction(-0x2c); // Call to FUN_100033d0 with argument -0x2c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100280a8", "Address": "100280a8", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100280a8\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with argument -0xcc\n}\n"}
{"Function Name": "Unwind@100280b3", "Address": "100280b3", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280b3\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with a negative argument of -0xb0\n}\n"}
{"Function Name": "Unwind@100280be", "Address": "100280be", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280be\n{\n    functionCall(-0x70); // Call to FUN_100033d0 with argument -0x70\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100280c6", "Address": "100280c6", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280c6\n{\n    functionCall(-0x70); // Call to FUN_100033d0 with argument -0x70\n}\n"}
{"Function Name": "Unwind@100280ce", "Address": "100280ce", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280ce\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100280d9", "Address": "100280d9", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280d9\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@100280e4", "Address": "100280e4", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280e4\n{\n    functionCall(-0x70); // Call to FUN_100033d0 with argument -0x70\n}\n"}
{"Function Name": "Unwind@100280ec", "Address": "100280ec", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100280ec\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100280f7", "Address": "100280f7", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100280f7\n{\n    functionCall(-0xcc); // Call to FUN_100033d0 with argument -0xcc\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10028102", "Address": "10028102", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028102\n{\n    callFunction(-0x70); // Call to FUN_100033d0 with an argument of -112\n}\n"}
{"Function Name": "Unwind@1002810a", "Address": "1002810a", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002810a\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10028115", "Address": "10028115", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028115\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028120", "Address": "10028120", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028120\n{\n    functionCall(-0x70); // Call to FUN_100033d0 with argument -0x70\n}\n"}
{"Function Name": "Unwind@10028128", "Address": "10028128", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028128\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@10028133", "Address": "10028133", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028133\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative hexadecimal argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002813e", "Address": "1002813e", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002813e\n{\n    functionCall(-0x70); // Call to FUN_100033d0 with argument -0x70\n}\n"}
{"Function Name": "Unwind@10028146", "Address": "10028146", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028146\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028151", "Address": "10028151", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028151\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@1002815c", "Address": "1002815c", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002815c\n{\n    functionCall(-0x70); // Call to FUN_100033d0 with argument -0x70\n}\n"}
{"Function Name": "Unwind@10028164", "Address": "10028164", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028164\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002816f", "Address": "1002816f", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002816f\n{\n    functionCall(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@1002817a", "Address": "1002817a", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002817a\n{\n    callFunction(-0x70); // Call FUN_100033d0 with argument -0x70\n}\n"}
{"Function Name": "Unwind@10028182", "Address": "10028182", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028182\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002818d", "Address": "1002818d", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002818d\n{\n    functionCall(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028198", "Address": "10028198", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028198\n{\n    performAction(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@100281a3", "Address": "100281a3", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281a3\n{\n    functionCall(-0x70); // Call FUN_100033d0 with an argument of -0x70\n}\n"}
{"Function Name": "Unwind@100281ab", "Address": "100281ab", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281ab\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@100281b6", "Address": "100281b6", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100281b6\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@100281c1", "Address": "100281c1", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281c1\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100281cc", "Address": "100281cc", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281cc\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with argument -0xcc\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100281d7", "Address": "100281d7", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281d7\n{\n    functionCall(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@100281e2", "Address": "100281e2", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281e2\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@100281ed", "Address": "100281ed", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100281ed\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100281f8", "Address": "100281f8", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100281f8\n{\n    functionCall(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@10028203", "Address": "10028203", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028203\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002820e", "Address": "1002820e", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002820e\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028219", "Address": "10028219", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028219\n{\n    functionCall(-0x8c); // Call to FUN_100033d0 with an argument of -140 (0x8c in hexadecimal)\n}\n"}
{"Function Name": "Unwind@10028224", "Address": "10028224", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028224\n{\n    callFunction(-0x70); // Call to FUN_100033d0 with argument -0x70\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002822c", "Address": "1002822c", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002822c\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@10028237", "Address": "10028237", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028237\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028242", "Address": "10028242", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028242\n{\n    callFunction(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@1002824d", "Address": "1002824d", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002824d\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@10028258", "Address": "10028258", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028258\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028263", "Address": "10028263", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028263\n{\n    callFunction(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@1002826e", "Address": "1002826e", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002826e\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028279", "Address": "10028279", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028279\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with argument -0xcc\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028284", "Address": "10028284", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028284\n{\n    callFunction(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002828f", "Address": "1002828f", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002828f\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002829a", "Address": "1002829a", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002829a\n{\n    processFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@100282a5", "Address": "100282a5", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282a5\n{\n    callFunction(-0x8c); // Call to FUN_100033d0 with an argument of -140 (0x8c in hexadecimal)\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100282b0", "Address": "100282b0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282b0\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@100282bb", "Address": "100282bb", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282bb\n{\n    processFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument -0xcc\n}\n"}
{"Function Name": "Unwind@100282c6", "Address": "100282c6", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100282c6\n{\n    functionCall(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@100282d1", "Address": "100282d1", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100282d1\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with a negative argument -0xb0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100282dc", "Address": "100282dc", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282dc\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100282e7", "Address": "100282e7", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282e7\n{\n    functionCall(-0x8c); // Call to FUN_100033d0 with an argument of -140 (0x8c in hexadecimal)\n}\n"}
{"Function Name": "Unwind@100282f2", "Address": "100282f2", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282f2\n{\n    functionCall(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@100282fd", "Address": "100282fd", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100282fd\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028308", "Address": "10028308", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028308\n{\n    funCall(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@10028313", "Address": "10028313", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028313\n{\n    callFunction(-0xb0); // Call to FUN_100033d0 with argument -0xb0\n}\n"}
{"Function Name": "Unwind@1002831e", "Address": "1002831e", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002831e\n{\n    callFunction(-0xcc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028329", "Address": "10028329", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028329\n{\n    functionCall(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n}\n"}
{"Function Name": "Unwind@10028370", "Address": "10028370", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028370\n{\n    functionCall(-0x4c); // Call to FUN_100033d0 with argument -0x4c\n}\n"}
{"Function Name": "Unwind@10028378", "Address": "10028378", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028378\n{\n    callFunction(-0x6c); // Call FUN_100033d0 with an argument of -108 (0x6c in hexadecimal)\n}\n"}
{"Function Name": "Unwind@10028380", "Address": "10028380", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028380\n{\n    callFunction(-0x30); // Call to FUN_100033d0 with argument -0x30\n}\n"}
{"Function Name": "Unwind@100283b0", "Address": "100283b0", "Source Code": "\nvoid Unwind_100283b0(void)\n{\n    // Call the function FUN_10009c50 with the argument being the value\n    // at the memory address calculated by subtracting 0x14 from the \n    // value in the register unaff_EBP, cast to a void pointer.\n    function_call(*(void **)(base_pointer - 0x14));\n}\n"}
{"Function Name": "Unwind@100283e0", "Address": "100283e0", "Source Code": "\nvoid Unwind_100283e0(void)\n{\n    // Call the function FUN_10009c90 with a pointer obtained from the stack frame\n    function_call(*(void **)(base_pointer - 0x14));\n}\n"}
{"Function Name": "Unwind@10028410", "Address": "10028410", "Source Code": "\nvoid Unwind_10028410(void) // Function declaration for Unwind_10028410\n{\n    // Call FUN_10009c50 with the dereferenced pointer from the address 0xFFFFFFF0\n    callFunction(*(void **)(*(int *)0xFFFFFFF0)));\n}\n"}
{"Function Name": "Unwind@10028440", "Address": "10028440", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028440\n{\n    // Call the function FUN_10009c90 with the argument being a pointer\n    // obtained from the stack frame at the offset of -0x10 from the base pointer (unaff_EBP)\n    functionCall(*(void **)(basePointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028470", "Address": "10028470", "Source Code": "\nvoid Unwind_10028470(void)\n{\n    // Check if the least significant bit of the value at (unaff_EBP - 0x10) is set\n    if ((*(uint *)(base_pointer - 0x10) & 1) != 0) {\n        // Clear the least significant bit of the value at (unaff_EBP - 0x10)\n        *(uint *)(base_pointer - 0x10) &= 0xfffffffe;\n        // Call the function FUN_10009cd0 with the argument at (unaff_EBP + 4)\n        function_call(*(void **)(base_pointer + 4));\n    }\n}\n"}
{"Function Name": "Unwind@100284b0", "Address": "100284b0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100284b0\n{\n    functionCall(-0x48); // Call to FUN_100033d0 with argument -0x48\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100284b8", "Address": "100284b8", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100284b8\n{\n    callFunction(-0x2c); // Call to FUN_100033d0 with argument -0x2c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100284c0", "Address": "100284c0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100284c0\n{\n    callFunction(-0x128); // Call to FUN_100033d0 with an argument of -0x128\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100284cb", "Address": "100284cb", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100284cb\n{\n    functionCall(-0xb8); // Call to FUN_100033d0 with argument -0xb8\n}\n"}
{"Function Name": "Unwind@100284d6", "Address": "100284d6", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100284d6\n{\n    funCall(-100); // Call FUN_100033d0 with an argument of -100\n}\n"}
{"Function Name": "Unwind@100284de", "Address": "100284de", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100284de\n{\n    functionCall(-0x80); // Call to FUN_100033d0 with argument -128\n}\n"}
{"Function Name": "Unwind@100284e6", "Address": "100284e6", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100284e6\n{\n    callFunction(-0xf0); // Call to FUN_100033d0 with argument -0xf0\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100284f1", "Address": "100284f1", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100284f1\n{\n    callFunction(-0x128); // Call to FUN_100033d0 with an argument of -0x128\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100284fc", "Address": "100284fc", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100284fc\n{\n    funCall(-0x10c); // Call to FUN_100033d0 with an argument of -0x10c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028507", "Address": "10028507", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028507\n{\n    callFunction(-0x9c); // Call to FUN_100033d0 with an argument of -156 (0x9c in hexadecimal)\n}\n"}
{"Function Name": "Unwind@10028512", "Address": "10028512", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028512\n{\n    callFunction(-0xd4); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@1002851d", "Address": "1002851d", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002851d\n{\n    someFunction(-700); // Call to FUN_100033d0 with argument -700\n}\n"}
{"Function Name": "Unwind@10028528", "Address": "10028528", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028528\n{\n    callFunction(-0x2a0); // Call to FUN_100033d0 with argument -0x2a0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028533", "Address": "10028533", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028533\n{\n    callFunction(-0x26c); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@1002853e", "Address": "1002853e", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002853e\n{\n    functionCall(-0x1dc); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028549", "Address": "10028549", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028549\n{\n    callFunction(-0x214); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028554", "Address": "10028554", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028554\n{\n    callFunction(-0x230); // Call to FUN_100033d0 with an argument of -0x230\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@1002855f", "Address": "1002855f", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002855f\n{\n    functionCall(-0x1f8); // Call to FUN_100033d0 with argument -0x1f8\n}\n"}
{"Function Name": "Unwind@1002856a", "Address": "1002856a", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002856a\n{\n    callFunction(-0x24c); // Call FUN_100033d0 with the argument -0x24c\n}\n"}
{"Function Name": "Unwind@10028575", "Address": "10028575", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028575\n{\n    performAction(-700); // Call to FUN_100033d0 with argument -700\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028580", "Address": "10028580", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028580\n{\n    callFunction(-0xd4); // Call to FUN_100033d0 with argument -0xd4\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002858b", "Address": "1002858b", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002858b\n{\n    callFunction((void *)(-0x280)); // Call FUN_10009d40 with a pointer offset of -0x280\n}\n"}
{"Function Name": "Unwind@10028596", "Address": "10028596", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028596\n{\n    callFunction(-0x1ac); // Call to FUN_10003390 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@100285a1", "Address": "100285a1", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100285a1\n{\n    callFunction(-0x128); // Call to FUN_100033d0 with a negative integer argument\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100285ac", "Address": "100285ac", "Source Code": "\nvoid Unwind_100285ac(void) // Function definition for Unwind_100285ac\n{\n    // Call the function FUN_100033d0 with an argument that is the value \n    // at the memory address calculated by subtracting 0x2c0 from the \n    // value in the register unaff_EBP (unaffected EBP).\n    function_call(*(int *)(base_pointer - 0x2c0));\n}\n"}
{"Function Name": "Unwind@100285b7", "Address": "100285b7", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100285b7\n{\n    callFunction(-0x26c); // Call to FUN_10003b20 with argument -0x26c\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100285c2", "Address": "100285c2", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100285c2\n{\n    functionCall(-0x2a0); // Call to FUN_10003b90 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@100285cd", "Address": "100285cd", "Source Code": "\nvoid Unwind_100285cd(void)\n{\n    // Free the memory pointed to by the pointer located at the address \n    // calculated by subtracting 0x2c8 from the value in the unaff_EBP register.\n    free_memory(*(void **)(base_pointer - 0x2c8));\n}\n"}
{"Function Name": "Unwind@100285db", "Address": "100285db", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100285db\n{\n    someFunction(-0xf0); // Call to FUN_100033d0 with argument -0xf0\n}\n"}
{"Function Name": "Unwind@100285e6", "Address": "100285e6", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100285e6\n{\n    functionCall(-0x9c); // Call to FUN_100033d0 with argument -0x9c\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100285f1", "Address": "100285f1", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100285f1\n{\n    functionCall(-0x10c); // Call to FUN_100033d0 with argument -0x10c\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100285fc", "Address": "100285fc", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100285fc\n{\n    functionCall(-0xd4); // Call to FUN_100033d0 with argument -0xd4\n}\n"}
{"Function Name": "Unwind@10028607", "Address": "10028607", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028607\n{\n    performAction(-0x80); // Call to FUN_100033d0 with an argument of -128\n}\n"}
{"Function Name": "Unwind@1002860f", "Address": "1002860f", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002860f\n{\n    functionCall(-700); // Call to FUN_100033d0 with argument -700\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002861a", "Address": "1002861a", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_1002861a\n{\n    callFunction(-0x24c); // Call to FUN_100033d0 with an argument of -0x24c\n}\n"}
{"Function Name": "Unwind@10028625", "Address": "10028625", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028625\n{\n    callFunction(-0x1f8); // Call to FUN_100033d0 with argument -0x1f8\n}\n"}
{"Function Name": "Unwind@10028630", "Address": "10028630", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028630\n{\n    callFunction(-0x230); // Call to FUN_100033d0 with argument -0x230\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@1002863b", "Address": "1002863b", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002863b\n{\n    callFunction(-0x214); // Call to FUN_100033d0 with a negative integer argument\n}\n"}
{"Function Name": "Unwind@10028646", "Address": "10028646", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028646\n{\n    callFunction(-0x1dc); // Call to FUN_100033d0 with argument -0x1dc\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028651", "Address": "10028651", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028651\n{\n    callFunction(-0x26c); // Call to FUN_100033d0 with argument -0x26c\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@1002865c", "Address": "1002865c", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002865c\n{\n    performAction(-0x2a0); // Call to FUN_100033d0 with argument -0x2a0\n}\n"}
{"Function Name": "Unwind@10028667", "Address": "10028667", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028667\n{\n    performAction(-100); // Call to FUN_100033d0 with argument -100\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286a0", "Address": "100286a0", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100286a0\n{\n    callFunction(0xfc); // Call the function FUN_100033d0 with argument 0xfc\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286ab", "Address": "100286ab", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100286ab\n{\n    callFunction(0x118); // Call to FUN_100033d0 with argument 0x118\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@100286b6", "Address": "100286b6", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100286b6\n{\n    functionCall(0x134); // Call to FUN_100033d0 with argument 0x134\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286c1", "Address": "100286c1", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100286c1\n{\n    functionCall(0x38); // Call FUN_100033d0 with argument 0x38\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286c9", "Address": "100286c9", "Source Code": "\nvoid Unwind_100286c9(void) // Function declaration for Unwind_100286c9\n{\n    FUN_100033d0(unaff_EBP); // Call to FUN_100033d0 with unaff_EBP as an argument\n}\n"}
{"Function Name": "Unwind@100286d1", "Address": "100286d1", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with an argument of 0x1c (28 in decimal)\n    callFunction(0x1c);\n    \n    // Return from the function\n    return;\n}\n"}
{"Function Name": "Unwind@100286d9", "Address": "100286d9", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100286d9\n{\n    callFunction(0x70); // Call the function FUN_100033d0 with argument 0x70\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286e1", "Address": "100286e1", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100286e1\n{\n    callFunction(0x8c); // Call to FUN_100033d0 with argument 0x8c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286ec", "Address": "100286ec", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_100286ec\n{\n    callFunction(0xa8); // Call the function FUN_100033d0 with argument 0xa8\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100286f7", "Address": "100286f7", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_100286f7\n{\n    callFunction(0xe0); // Call to FUN_100033d0 with argument 0xe0\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028702", "Address": "10028702", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028702\n{\n    performAction(-0x78); // Call to FUN_100033d0 with argument -0x78\n}\n"}
{"Function Name": "Unwind@1002870a", "Address": "1002870a", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002870a\n{\n    callFunction(0x54); // Call the function FUN_100033d0 with the argument 0x54\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028712", "Address": "10028712", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028712\n{\n    functionCall(-0x78); // Call to FUN_100033d0 with argument -0x78\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@1002871a", "Address": "1002871a", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_1002871a\n{\n    callFunction(0xc4); // Call to FUN_100033d0 with argument 0xc4\n}\n"}
{"Function Name": "Unwind@10028725", "Address": "10028725", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028725\n{\n    callFunction(0x134); // Call to FUN_100033d0 with argument 0x134\n    return; // Return from the function\n}\n"}
{"Function Name": "Unwind@10028760", "Address": "10028760", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028760\n{\n    performAction(-0x30); // Call to FUN_100033d0 with argument -0x30\n}\n"}
{"Function Name": "Unwind@10028768", "Address": "10028768", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028768\n{\n    functionCall(-0x4c); // Call to FUN_100033d0 with argument -0x4c\n}\n"}
{"Function Name": "Unwind@10028770", "Address": "10028770", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028770\n{\n    callFunction(-0x8c); // Call to FUN_100033d0 with argument -0x8c\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@100287b0", "Address": "100287b0", "Source Code": "\nvoid Unwind_100287b0(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined4 type,\n    // which is calculated by adding 4 to the value of the unaff_EBP variable.\n    function_call((undefined4 *)(base_pointer + 4));\n}\n"}
{"Function Name": "Unwind@100287e0", "Address": "100287e0", "Source Code": "\nvoid Unwind_100287e0(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by adding 8 to the value of the unaff_EBP register\n    FUN_1000bc00((undefined4 *)(base_pointer + 8));\n}\n"}
{"Function Name": "Unwind@10028810", "Address": "10028810", "Source Code": "\nvoid Unwind_10028810(void)\n{\n    // Call the function FUN_1000be30 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // register unaff_EBP.\n    callFunction(*(undefined4 **)(basePointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028818", "Address": "10028818", "Source Code": "\nvoid Unwind_10028818(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x14 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x14));\n}\n"}
{"Function Name": "Unwind@10028823", "Address": "10028823", "Source Code": "\nvoid Unwind_10028823(void) // Function definition for Unwind_10028823\n{\n    // Call FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x18 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x18));\n}\n"}
{"Function Name": "Unwind@10028850", "Address": "10028850", "Source Code": "\nvoid Unwind_10028850(void) // Function declaration for Unwind_10028850\n{\n    // Call the function FUN_1000be30 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028858", "Address": "10028858", "Source Code": "\nvoid Unwind_10028858(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x14 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x14));\n}\n"}
{"Function Name": "Unwind@10028863", "Address": "10028863", "Source Code": "\nvoid Unwind_10028863(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) \n    // and adding 0x18 to it.\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x18));\n}\n"}
{"Function Name": "Unwind@10028890", "Address": "10028890", "Source Code": "\nvoid Unwind_10028890(void)\n{\n    // Call the function FUN_1000be30 with a pointer to an undefined type\n    // retrieved from the stack frame at the offset of -0x10 from the base pointer (unaff_EBP).\n    FUN_1000be30(*(undefined4 **)(unaff_EBP - 0x10));\n}\n"}
{"Function Name": "Unwind@10028898", "Address": "10028898", "Source Code": "\nvoid Unwind_10028898(void)\n{\n    // Call the function FUN_1000bc00\n    // Pass a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10)\n    // and adding an offset of 0x20 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x20));\n}\n"}
{"Function Name": "Unwind@100288c0", "Address": "100288c0", "Source Code": "\nvoid Unwind_100288c0(void)\n{\n    // Call the function FUN_1000be30 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // EBP register (unaff_EBP).\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100288c8", "Address": "100288c8", "Source Code": "\nvoid Unwind_100288c8(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x20 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x20));\n}\n"}
{"Function Name": "Unwind@100288f0", "Address": "100288f0", "Source Code": "\nvoid Unwind_100288f0(void) // Function definition for Unwind_100288f0\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100288f8", "Address": "100288f8", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined4 type\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10)\n    // and adding 0x34 to it.\n    callFunction((undefined4 *)(*(int *)(basePointer - 0x10) + 0x34));\n}\n"}
{"Function Name": "Unwind@10028920", "Address": "10028920", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028920\n{\n    // Dereference the pointer at address 0xFFFFFFFF, cast it to an int pointer,\n    // and access the value at that address, then subtract 0x10 from it.\n    // The result is treated as a pointer to a void pointer.\n    // Finally, dereference that void pointer and pass it to the _free function.\n    freeMemory(*(void **)(*(int *)0xFFFFFFFF + -0x10));\n}\n"}
{"Function Name": "Unwind@10028950", "Address": "10028950", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028950\n{\n    functionCall((undefined4 *)(basePointer - 0x10)); // Call FUN_1000bc00 with a pointer to a specific memory location\n}\n"}
{"Function Name": "Unwind@10028958", "Address": "10028958", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028958\n{\n    callFunction((undefined4 *)(basePointer - 0x14)); // Call FUN_1000bc00 with a pointer to a specific location in the stack\n}\n"}
{"Function Name": "Unwind@10028980", "Address": "10028980", "Source Code": "\nvoid Unwind_10028980(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an integer\n    // The pointer is obtained by dereferencing the value at address 0\n    // and adding 4 to it, effectively accessing the memory at that offset.\n    callFunction((undefined4 *)(*(int *)0 + 4));\n}\n"}
{"Function Name": "Unwind@100289b0", "Address": "100289b0", "Source Code": "\nvoid Unwind_100289b0(void)\n{\n    // Call the function FUN_1000c280 with a pointer to an undefined 4-byte value\n    // located at the address calculated by subtracting 0x10 from the value in the \n    // EBP register (unaff_EBP).\n    FUN_1000c280(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@100289e0", "Address": "100289e0", "Source Code": "\nvoid Unwind_100289e0(void)\n{\n    // Call the function FUN_1000c280 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10).\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028a10", "Address": "10028a10", "Source Code": "\nvoid Unwind_10028a10(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // Then access the value at offset 4 from that integer\n    // Cast it to a void pointer and dereference it to get the pointer to free\n    free_pointer(*(void **)(*(int *)0 + 4));\n}\n"}
{"Function Name": "Unwind@10028a40", "Address": "10028a40", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028a40\n{\n    // Call FUN_1000c570 with the dereferenced pointer from the address 0xFFFFFFEC\n    functionCall(*(undefined4 **)(*(int *)0xFFFFFFEC)));\n}\n"}
{"Function Name": "Unwind@10028a70", "Address": "10028a70", "Source Code": "\nvoid Unwind_10028a70(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    FUN_1000c570(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028aa0", "Address": "10028aa0", "Source Code": "\nvoid Unwind_10028aa0(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028ad0", "Address": "10028ad0", "Source Code": "\nvoid Unwind_10028ad0(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028b00", "Address": "10028b00", "Source Code": "\nvoid Unwind_10028b00(void)\n{\n    // Call the function FUN_1000c570 with a pointer obtained from the stack frame\n    // The pointer is located at an offset of -0x10 from the base pointer (unaff_EBP)\n    function_pointer(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028b08", "Address": "10028b08", "Source Code": "\nvoid Unwind_10028b08(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x2c to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x2c));\n}\n"}
{"Function Name": "Unwind@10028b13", "Address": "10028b13", "Source Code": "\nvoid Unwind_10028b13(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x30 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x30));\n}\n"}
{"Function Name": "Unwind@10028b1e", "Address": "10028b1e", "Source Code": "\nvoid Unwind_10028b1e(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined4 type\n    // The pointer is obtained by dereferencing the value at (unaff_EBP - 0x10) \n    // and adding 0x34 to it.\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x34));\n}\n"}
{"Function Name": "Unwind@10028b50", "Address": "10028b50", "Source Code": "\nvoid Unwind_10028b50(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10).\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028b58", "Address": "10028b58", "Source Code": "\nvoid Unwind_10028b58(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined4 type\n    // The pointer is obtained by dereferencing the value at (unaff_EBP - 0x10) and adding 0x2c to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x2c));\n}\n"}
{"Function Name": "Unwind@10028b63", "Address": "10028b63", "Source Code": "\nvoid Unwind_10028b63(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte type\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) \n    // and adding 0x30 to it.\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x30));\n}\n"}
{"Function Name": "Unwind@10028b6e", "Address": "10028b6e", "Source Code": "\nvoid Unwind_10028b6e(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined4 type\n    // The pointer is obtained by dereferencing the value at (unaff_EBP - 0x10) and adding 0x34 to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x34));\n}\n"}
{"Function Name": "Unwind@10028ba0", "Address": "10028ba0", "Source Code": "\nvoid Unwind_10028ba0(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028bd0", "Address": "10028bd0", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028bd0\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the integer located at memory address 0x10\n    processPointer(*(undefined4 **)(*(int *)0x10)));\n}\n"}
{"Function Name": "Unwind@10028c00", "Address": "10028c00", "Source Code": "\nvoid Unwind_10028c00(void) // Function declaration for Unwind_10028c00\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the address at (unaff_EBP - 0x10)\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028c08", "Address": "10028c08", "Source Code": "\nvoid Unwind_10028c08(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined4 type\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10)\n    // and adding 0x34 to it.\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x34));\n}\n"}
{"Function Name": "Unwind@10028c30", "Address": "10028c30", "Source Code": "\nvoid Unwind_10028c30(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10).\n    function_call(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028c38", "Address": "10028c38", "Source Code": "\nvoid Unwind_10028c38(void)\n{\n    // Call the function FUN_1000d080 with a pointer to an undefined4 type\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10)\n    // and adding an offset of 0x2c to it.\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x2c));\n}\n"}
{"Function Name": "Unwind@10028c60", "Address": "10028c60", "Source Code": "\nvoid Unwind_10028c60(void)\n{\n    // Call the function FUN_1000c570 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10).\n    FUN_1000c570(*(undefined4 **)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028c68", "Address": "10028c68", "Source Code": "\nvoid Unwind_10028c68(void)\n{\n    // Call the function FUN_1000d080 with a pointer to an undefined 4-byte value\n    // The pointer is calculated by dereferencing the value at (unaff_EBP - 0x10) and adding 0x2c to it\n    function_call((undefined4 *)(*(int *)(base_pointer - 0x10) + 0x2c));\n}\n"}
{"Function Name": "Unwind@10028c90", "Address": "10028c90", "Source Code": "\nvoid unwindMemory(void)\n{\n    // Dereference the pointer at address 0xFFFFFFF0 to get an integer\n    // and then dereference that integer to get a pointer to free\n    // the memory allocated at that location.\n    freeMemory(*(void **)(*(int *)0xFFFFFFF0));\n}\n"}
{"Function Name": "Unwind@10028cc0", "Address": "10028cc0", "Source Code": "\nvoid Unwind_10028cc0(void)\n{\n    // Dereference the null pointer (0) to get an integer value\n    // Subtract 0x10 from that integer value to get an offset\n    // Dereference the resulting pointer to get a void pointer\n    // Free the memory pointed to by the void pointer\n    free_memory(*(void **)(*(int *)0 + -0x10));\n}\n"}
{"Function Name": "Unwind@10028cf0", "Address": "10028cf0", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Dereference the null pointer (0) to get the integer value at that address\n    // Subtract 0x10 from that integer value to get the address of the target pointer\n    // Dereference that address to get the pointer to be freed\n    // Call the _free function to free the allocated memory at that pointer\n    freeMemory(*(void **)(*(int *)0 - 0x10));\n}\n"}
{"Function Name": "Unwind@10028d20", "Address": "10028d20", "Source Code": "\nvoid Unwind_10028d20(void)\n{\n    // Dereference the pointer at address 0, then subtract 0x10 from it to get the target address\n    // Cast the result to an int pointer and dereference it to get another pointer\n    // Dereference that pointer to get the actual pointer to free\n    // Call the _free function to deallocate the memory pointed to by the obtained pointer\n    free_function(*(void **)(*(int *)0 - 0x10));\n}\n"}
{"Function Name": "Unwind@10028d50", "Address": "10028d50", "Source Code": "\nvoid Unwind_10028d50(void)\n{\n    // Dereference the pointer at address 0xFFFFFFF0 to get an integer\n    // Then dereference that integer to get a pointer\n    // Finally, dereference that pointer to get the actual pointer to free\n    free_pointer(*(void **)(*(int *)0xFFFFFFF0));\n}\n"}
{"Function Name": "Unwind@10028d80", "Address": "10028d80", "Source Code": "\nvoid Unwind_10028d80(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to an undefined 4-byte value\n    // located at the address (unaff_EBP - 0x10)\n    function_call((undefined4 *)(base_pointer - 0x10));\n}\n"}
{"Function Name": "Unwind@10028db0", "Address": "10028db0", "Source Code": "\nvoid Unwind_10028db0(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // Then access the 8th byte offset from that integer value\n    // Cast the value at that offset to a pointer to void\n    // Dereference that pointer to get the actual pointer to free\n    free_memory(*(void **)(*(int *)0 + 8)); // Free the memory pointed to by the dereferenced pointer\n}\n"}
{"Function Name": "Unwind@10028dbb", "Address": "10028dbb", "Source Code": "\nvoid Unwind_10028dbb(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // and then access the 8th byte offset from that integer value.\n    // This is expected to be a pointer to a memory block.\n    \n    // Free the memory block pointed to by the dereferenced pointer.\n    free_memory(*(void **)(*(int *)0 + 8));\n}\n"}
{"Function Name": "Unwind@10028dc6", "Address": "10028dc6", "Source Code": "\nvoid Unwind_10028dc6(void)\n{\n    // Dereference the null pointer (0) to get the first integer\n    // Then access the 8th byte offset from that integer\n    // Cast the value at that offset to a void pointer\n    // Dereference that pointer to get the actual pointer to free\n    free_pointer(*(void **)(*(int *)0 + 8));\n}\n"}
{"Function Name": "Unwind@10028dd1", "Address": "10028dd1", "Source Code": "\nvoid Unwind_10028dd1(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // Then access the 8th byte offset from that integer value\n    // Cast the result to a pointer to a pointer (void **)\n    // Dereference that pointer to get the actual pointer to free\n    free_memory(*(void **)(*(int *)0 + 8)); // Free the memory pointed to by the obtained pointer\n}\n"}
{"Function Name": "Unwind@10028ddc", "Address": "10028ddc", "Source Code": "\nvoid Unwind_10028ddc(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // Then access the 8th byte offset from that integer value\n    // Cast the result to a pointer to void pointer\n    // Dereference that pointer to get the actual pointer to free\n    free_memory(*(void **)(*(int *)0 + 8)); // Free the memory pointed to by the obtained pointer\n}\n"}
{"Function Name": "Unwind@10028de7", "Address": "10028de7", "Source Code": "\nvoid Unwind_10028de7(void)\n{\n    // Dereference the null pointer (0) to access the first integer\n    // Then, add 8 to that integer to get the address of the pointer to free\n    // Dereference that pointer to get the actual pointer to free\n    free_function(*(void **)(*(int *)0 + 8));\n}\n"}
{"Function Name": "Unwind@10028e10", "Address": "10028e10", "Source Code": "\nvoid Unwind_10028e10(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // Then, access the integer at offset 4 from that value\n    // Finally, dereference that value as a pointer and free the allocated memory\n    free_memory(*(void **)(*(int *)0 + 4));\n}\n"}
{"Function Name": "Unwind@10028e40", "Address": "10028e40", "Source Code": "\nvoid Unwind_10028e40(void) // Function definition for Unwind_10028e40\n{\n    FUN_1000bc00((undefined4 *)(unaff_EBP + 0xc)); // Call FUN_1000bc00 with a pointer to a specific memory location\n}\n"}
{"Function Name": "Unwind@10028e48", "Address": "10028e48", "Source Code": "\nvoid Unwind_10028e48(void)\n{\n    // Dereference the null pointer (0) to get the first integer value\n    // Then access the memory at offset 4 from that integer value\n    // Finally, dereference that value as a pointer to free the allocated memory\n    free_memory(*(void **)(*(int *)0 + 4));\n}\n"}
{"Function Name": "Unwind@10028e70", "Address": "10028e70", "Source Code": "\nvoid Unwind_10028e70(void)\n{\n    // Call the function FUN_1000bc00 with a pointer to the memory location\n    // calculated by adding 8 to the value of the unaff_EBP register.\n    function_call((undefined4 *)(base_pointer + 8));\n}\n"}
{"Function Name": "Unwind@10028ea0", "Address": "10028ea0", "Source Code": "\nvoid Unwind_10028ea0(void)\n{\n    // Call the function FUN_1000c280 with a pointer to a specific location\n    // in memory, calculated as unaff_EBP minus 0x78 (120 in decimal).\n    callFunction((undefined4 *)(basePointer - 0x78));\n}\n"}
{"Function Name": "Unwind@10028ea8", "Address": "10028ea8", "Source Code": "\nvoid Unwind_10028ea8(void)\n{\n    // Call the function FUN_1000c280 with a pointer to an undefined4 type,\n    // which is calculated by subtracting 0x54 from the value in the unaff_EBP register.\n    function_call((undefined4 *)(base_pointer - 0x54));\n}\n"}
{"Function Name": "Unwind@10028eb0", "Address": "10028eb0", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_1000c280 with a pointer to a location \n    // in the stack frame, specifically 48 bytes (0x30) below the \n    // current base pointer (unaff_EBP).\n    functionCall((undefined4 *)(basePointer - 0x30));\n}\n"}
{"Function Name": "Unwind@10028ed9", "Address": "10028ed9", "Source Code": "\nvoid Unwind_10028ed9(void) // Function definition for Unwind_10028ed9\n{\n    FUN_1000fe01((int *)(unaff_EBP - 0x10)); // Call FUN_1000fe01 with a pointer to an integer located at (unaff_EBP - 0x10)\n}\n"}
{"Function Name": "Unwind@10028efc", "Address": "10028efc", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028efc\n{\n    // Call FUN_10001910 with the dereferenced pointer from the address 0x10\n    functionCall(*(undefined4 **)(*(int *)0x10)); \n}\n"}
{"Function Name": "Unwind@10028f1f", "Address": "10028f1f", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028f1f\n{\n    // Call the function FUN_10001910 with a pointer to an undefined 4-byte value\n    // The pointer is obtained by dereferencing the integer located at address 0x10\n    functionCall(*(undefined4 **)(*(int *)0x10));\n}\n"}
{"Function Name": "Unwind@10028f27", "Address": "10028f27", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_100033d0 with an argument\n    // The argument is obtained by dereferencing a pointer located at\n    // (unaff_EBP - 0x10) and adding 0x18 to the integer value retrieved\n    callFunction(*(int *)(basePointer - 0x10) + 0x18);\n}\n"}
{"Function Name": "Unwind@10028f4d", "Address": "10028f4d", "Source Code": "\nvoid unwindFunction(void)\n{\n    // Call the function FUN_1000fe01 with a pointer to an integer\n    // The pointer is set to -0x10, which may represent an offset or a specific memory address\n    functionCall((int *)(-0x10));\n}\n"}
{"Function Name": "Unwind@10028f55", "Address": "10028f55", "Source Code": "\nvoid Unwind_10028f55(void)\n{\n    // Dereference the pointer at address 0xFFFFFFEC to get an integer\n    // Then, use that integer to dereference another pointer to get a void pointer\n    // Finally, free the memory pointed to by that void pointer\n    free_memory(*(void **)(*(int *)0xFFFFFFEC));\n}\n"}
{"Function Name": "Unwind@10028f7a", "Address": "10028f7a", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_10028f7a\n{\n    functionCall(-0x28); // Call to FUN_100033d0 with argument -0x28\n    return; // Exit the function\n}\n"}
{"Function Name": "Unwind@10028f9d", "Address": "10028f9d", "Source Code": "\nvoid unwindFunction(void) // Function declaration for Unwind_10028f9d\n{\n    callFunction(-0x28); // Call FUN_100033d0 with argument -0x28\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10029090", "Address": "10029090", "Source Code": "\nvoid FUN_10029090(void)\n{\n    // Check if the value of DAT_100340b0 is greater than 15 (0xf)\n    if (0xf < threshold_value) {\n        // Free the memory pointed to by DAT_1003409c\n        _free(memory_pointer);\n    }\n    // Set DAT_100340b0 to 15 (0xf)\n    threshold_value = 0xf;\n    // Mask the lower 8 bits of DAT_1003409c, keeping only the upper 24 bits\n    memory_pointer = (void *)((uint)memory_pointer & 0xffffff00);\n}\n"}
{"Function Name": "FUN_100290c0", "Address": "100290c0", "Source Code": "\nvoid FUN_100290c0(void)\n{\n    // Check if the value of DAT_100340cc is greater than 15\n    if (0xf < thresholdValue) {\n        // Free the memory pointed to by DAT_100340b8\n        _free(memoryPointer);\n    }\n    // Set DAT_100340cc to 15\n    thresholdValue = 0xf;\n    // Mask DAT_100340b8 to keep only the upper 24 bits\n    memoryPointer = (void *)((uint)memoryPointer & 0xffffff00);\n}\n"}
{"Function Name": "FUN_100290f0", "Address": "100290f0", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_100290f0\n{\n    callFunction(&dataAddress); // Call FUN_10009cd0 with the address of DAT_10035a4c as an argument\n}\n"}
{"Function Name": "FUN_100290fa", "Address": "100290fa", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_100290fa\n{\n    callAnotherFunction(); // Call to another function FUN_1000fdb7\n}\n"}
{"Function Name": "FUN_10029104", "Address": "10029104", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10029104\n{\n    callFunction((uint *)&dataAddress); // Call FUN_10001920 with the address of DAT_10035aec cast to a pointer to uint\n}\n"}
{"Function Name": "FUN_1002910e", "Address": "1002910e", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_1002910e\n{\n    callAnotherFunction(); // Call to another function FUN_1000fdb7\n}\n"}
{"Function Name": "FUN_10029118", "Address": "10029118", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_10029118\n{\n    callThunkFunction(); // Call to thunk_FUN_10010400 function\n}\n"}
{"Function Name": "FUN_100013f0", "Address": "100013f0", "Source Code": "void __fastcall FUN_100013f0(undefined4 *vftable_pointer)\n{\n    \n    *vftable_pointer = SecurityHttpModule::vftable;\n    return; \n}"}
{"Function Name": "FUN_10001450", "Address": "10001450", "Source Code": "undefined4 FUN_10001450(int *input_pointer) \n{\n    undefined4 *undefined_pointer; \n    int function_result; \n    if (input_pointer == (int *)0x0) { \n        return 0x80070057; \n    }\n    exception_list = &local_variable; \n    undefined_pointer = (undefined4 *)operator_new(4); \n    if (undefined_pointer == (undefined4 *)0x0) { \n        return 0x80070008; \n    }\n    function_result = FUN_100013f0(undefined_pointer); \n    if (function_result == 0) { \n        return 0x80070008; \n    }\n    *input_pointer = function_result; \n    return 0; \n}"}
{"Function Name": "FUN_10001500", "Address": "10001500", "Source Code": "\\*\nundefined4 * __thiscall FUN_10001500(void *object, byte flag)\n{\n    void *current_exception_list = ExceptionList; \n    ExceptionList = &current_exception_list; \n    *(undefined ***)object = CHttpModule::vftable; \n    if ((flag & 1) != 0) { \n        _free(object); \n    }\n    ExceptionList = current_exception_list; \n    return (undefined4 *)object; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10001500(void *object, byte flag)\n{\n    void *current_exception_list = ExceptionList;\n    ExceptionList = &current_exception_list;\n    *(undefined ***)object = CHttpModule::vftable;\n    if ((flag & 1) != 0) {\n        _free(object);\n    }\n    ExceptionList = current_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100015f0", "Address": "100015f0", "Source Code": "\\*\nundefined4 * __fastcall FUN_100015f0(undefined4 *exception_ptr, undefined error_code, undefined error_message)\n{\n    void *current_exception_list; \n    current_exception_list = ExceptionList; \n    ExceptionList = &current_exception_list; \n    std::exception::exception((exception *)exception_ptr, (char **)&error_message); \n    *exception_ptr = std::bad_alloc::vftable; \n    ExceptionList = current_exception_list; \n    return exception_ptr; \n}\n*\\ \n \nundefined4 * __fastcall FUN_100015f0(undefined4 *exception_ptr, undefined error_code, undefined error_message)\n{\n    void *current_exception_list;\n    current_exception_list = ExceptionList;\n    ExceptionList = &current_exception_list;\n    std::exception::exception((exception *)exception_ptr, (char **)&error_message);\n    *exception_ptr = std::bad_alloc::vftable;\n    ExceptionList = current_exception_list;\n    return exception_ptr;\n}"}
{"Function Name": "FUN_10001650", "Address": "10001650", "Source Code": "void __fastcall FUN_10001650(undefined4 *exception_pointer)\n{\n    void *current_exception_list; \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    *exception_pointer = std::bad_alloc::vftable; \n    exception::~exception((exception *)exception_pointer); \n    exception_list = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_100016a0", "Address": "100016a0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100016a0(void *current_object, byte flag)\n{\n    void *current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    *(undefined ***)current_object = std::bad_alloc::vftable; \n    exception::~exception((exception *)current_object); \n    if ((flag & 1) != 0) { \n        free_memory(current_object); \n    }\n    exception_list = current_exception_list; \n    return (undefined4 *)current_object; \n}\n*\\ \n \nundefined4 * __thiscall FUN_100016a0(void *current_object, byte flag)\n{\n    void *current_exception_list = exception_list;\n    exception_list = &current_exception_list;\n    *(undefined ***)current_object = std::bad_alloc::vftable;\n    exception::~exception((exception *)current_object);\n    if ((flag & 1) != 0) {\n        free_memory(current_object);\n    }\n    exception_list = current_exception_list;\n    return (undefined4 *)current_object;\n}"}
{"Function Name": "FUN_100017a0", "Address": "100017a0", "Source Code": "int __fastcall FUN_100017a0(int *input_pointer)\n{\n    void *current_exception_list; \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    if (*input_pointer == 0) { \n        std::_Lockit::_Lockit((_Lockit *)&input_pointer, 0); \n        if (*input_pointer == 0) { \n            global_counter = global_counter + 1; \n            *input_pointer = global_counter; \n        }\n        FUN_1000fe01((int *)&input_pointer); \n    }\n    exception_list = current_exception_list; \n    return *input_pointer; \n}"}
{"Function Name": "FUN_10001820", "Address": "10001820", "Source Code": "void __fastcall FUN_10001820(int input_param)\n{\n    void *current_exception_list; \n    current_exception_list = exception_list_pointer; \n    exception_list_pointer = &current_exception_list; \n    \n    if (*(int *)(input_param + 4) != -1) {\n        \n        *(int *)(input_param + 4) = *(int *)(input_param + 4) + 1;\n    }\n    \n    FUN_1000fe01(&input_param);\n    exception_list_pointer = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10001890", "Address": "10001890", "Source Code": "uint __fastcall FUN_10001890(uint input_param) \n{\n    int integer_value; \n    uint local_param; \n    local_param = input_param; \n    std::_Lockit::_Lockit((_Lockit *)&local_param, 0); \n    integer_value = *(int *)(input_param + 4); \n    if ((integer_value != 0) && (integer_value != -1)) { \n        *(int *)(input_param + 4) = integer_value - 1; \n    }\n    FUN_1000fe01((int *)&local_param); \n    return ~-(uint)(integer_value != 0) & input_param; \n}"}
{"Function Name": "FUN_10001960", "Address": "10001960", "Source Code": "void __thiscall FUN_10001960(void *object, undefined4 value)\n{\n    \n    *(undefined ***)object = std::ctype_base::vftable;\n    \n    \n    *(undefined4 *)((int)object + 4) = value;\n}"}
{"Function Name": "FUN_100019c0", "Address": "100019c0", "Source Code": "void __fastcall FUN_100019c0(undefined4 *locale_facet_vftable_pointer) \n{\n    *locale_facet_vftable_pointer = std::locale::facet::vftable; \n}"}
{"Function Name": "FUN_10001a10", "Address": "10001a10", "Source Code": "\\*\nundefined4 * __thiscall FUN_10001a10(void *object_pointer, byte flag)\n{\n    void *current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    *(undefined ***)object_pointer = std::ctype_base::vftable; \n    if ((flag & 1) != 0) { \n        free_memory(object_pointer); \n    }\n    exception_list = current_exception_list; \n    return (undefined4 *)object_pointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10001a10(void *object_pointer, byte flag)\n{\n    void *current_exception_list = exception_list;\n    exception_list = &current_exception_list;\n    *(undefined ***)object_pointer = std::ctype_base::vftable;\n    if ((flag & 1) != 0) {\n        free_memory(object_pointer);\n    }\n    exception_list = current_exception_list;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FUN_10001a80", "Address": "10001a80", "Source Code": "int * __thiscall FUN_10001a80(void *instance, int *output_value)\n{\n    void *current_exception_list; \n    current_exception_list = exception_list_pointer; \n    exception_list_pointer = &current_exception_list; \n    *output_value = **(int **)((int)instance + 0x24); \n    FUN_10001820(*output_value); \n    exception_list_pointer = current_exception_list; \n    return output_value; \n}"}
{"Function Name": "FUN_10001ae0", "Address": "10001ae0", "Source Code": "void __fastcall FUN_10001ae0(undefined4 *ios_base_pointer)\n{\n    \n    *ios_base_pointer = std::ios_base::vftable;\n    \n    std::ios_base::_Ios_base_dtor((ios_base *)ios_base_pointer);\n}"}
{"Function Name": "FUN_10001b80", "Address": "10001b80", "Source Code": "void __fastcall FUN_10001b80(undefined4 *input_param) \n{\n    void *previous_exception_list; \n    undefined *unused_stack_pointer; \n    unused_stack_pointer = &LAB_10026e08; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    *input_param = std::ios_base::vftable; \n    std::ios_base::_Ios_base_dtor((ios_base *)input_param); \n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10001c10", "Address": "10001c10", "Source Code": "void __fastcall FUN_10001c10(undefined4 *ios_pointer) \n{\n    *ios_pointer = std::basic_ios<char,struct_std::char_traits<char>_>::vftable; \n}"}
{"Function Name": "FUN_10001c90", "Address": "10001c90", "Source Code": "void __fastcall FUN_10001c90(int input_pointer)\n{\n    \n    if ((*(byte *)(input_pointer + 0x40) & 1) != 0) {\n        \n        _free(**(void ***)(input_pointer + 0x10));\n    }\n    \n    memset((void *)(input_pointer + 0x10), 0, 0x28);\n    \n    *(uint *)(input_pointer + 0x40) &= 0xfffffffe;\n    \n    *(undefined4 *)(input_pointer + 0x3c) = 0;\n    return; \n}"}
{"Function Name": "FUN_10001df0", "Address": "10001df0", "Source Code": "void __fastcall FUN_10001df0(int *inputArray) \n{\n    int *secondElementPointer = (int *)inputArray[1]; \n    if (*inputArray == 0) { \n        anotherFunction(); \n    } else if (*(char *)((int)secondElementPointer + 0x189) == '\\0') { \n        int currentElement = *secondElementPointer; \n        if (*(char *)(currentElement + 0x189) == '\\0') { \n            while (*(char *)(*(int *)(currentElement + 8) + 0x189) == '\\0') { \n                currentElement = *(int *)(currentElement + 8); \n            }\n            inputArray[1] = currentElement; \n            return; \n        }\n        secondElementPointer = (int *)secondElementPointer[1]; \n        while (*(char *)((int)secondElementPointer + 0x189) == '\\0' && (inputArray[1] == *secondElementPointer)) { \n            inputArray[1] = (int)secondElementPointer; \n            secondElementPointer = (int *)secondElementPointer[1]; \n        }\n        if (*(char *)(inputArray[1] + 0x189) != '\\0') { \n            anotherFunction(); \n            return; \n        }\n        inputArray[1] = (int)secondElementPointer; \n    } else { \n        inputArray[1] = secondElementPointer[2]; \n        if (*(char *)(inputArray[1] + 0x189) != '\\0') { \n            anotherFunction(); \n            return; \n        }\n    }\n}"}
{"Function Name": "FUN_10001e90", "Address": "10001e90", "Source Code": "void __fastcall FUN_10001e90(int *inputArray)\n{\n    int currentValue; \n    int **pointerToPointerA; \n    int **pointerToPointerB; \n    \n    if (*inputArray == 0) {\n        FUN_10011202(); \n    }\n    \n    currentValue = inputArray[1]; \n    \n    if (*(char *)(currentValue + 0x189) == '\\0') {\n        pointerToPointerA = *(int ***)(currentValue + 8); \n        \n        if (*(char *)((int)pointerToPointerA + 0x189) != '\\0') {\n            currentValue = *(int *)(currentValue + 4); \n            \n            \n            \n            while (*(char *)(currentValue + 0x189) == '\\0' && (inputArray[1] == *(int *)(currentValue + 8))) {\n                inputArray[1] = currentValue; \n                currentValue = *(int *)(currentValue + 4); \n            }\n            inputArray[1] = currentValue; \n            return; \n        }\n        \n        pointerToPointerB = (int **)*pointerToPointerA; \n        \n        \n        while (*(char *)((int)*pointerToPointerB + 0x189) == '\\0') {\n            pointerToPointerA = pointerToPointerB; \n            pointerToPointerB = (int **)*pointerToPointerB; \n        }\n        \n        inputArray[1] = (int)pointerToPointerA; \n        return; \n    }\n    \n    FUN_10011202(); \n    return; \n}"}
{"Function Name": "FUN_10001f50", "Address": "10001f50", "Source Code": "\\*\nundefined4 * __thiscall FUN_10001f50(void *current_instance, exception *exception_param)\n{\n    void *previous_exception_list; \n    undefined *stack_pointer; \n    stack_pointer = &LAB_10026e68; \n    previous_exception_list = ExceptionList; \n    ExceptionList = &previous_exception_list; \n    std::exception::exception((exception *)current_instance, exception_param); \n    *(undefined ***)current_instance = std::bad_alloc::vftable; \n    ExceptionList = previous_exception_list; \n    return (undefined4 *)current_instance; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10001f50(void *current_instance, exception *exception_param)\n{\n    void *previous_exception_list;\n    undefined *stack_pointer;\n    stack_pointer = &LAB_10026e68;\n    previous_exception_list = ExceptionList;\n    ExceptionList = &previous_exception_list;\n    std::exception::exception((exception *)current_instance, exception_param);\n    *(undefined ***)current_instance = std::bad_alloc::vftable;\n    ExceptionList = previous_exception_list;\n    return (undefined4 *)current_instance;\n}"}
{"Function Name": "FUN_10002040", "Address": "10002040", "Source Code": "void __fastcall FUN_10002040(undefined4 *param_1)\n{\n    uint *memoryBlock; \n    uint computedValue;    \n    undefined4 *functionPointer; \n    \n    computedValue = DAT_100345e0 ^ (uint)&stack0xffffffe8;\n    \n    \n    ExceptionList = &local_c;\n    \n    \n    *param_1 = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n    \n    \n    memoryBlock = (uint *)param_1[0xe];\n    \n    \n    if (memoryBlock != (uint *)0x0) {\n        \n        if (*memoryBlock != 0) {\n            \n            functionPointer = (undefined4 *)FUN_10001890(*memoryBlock);\n            \n            \n            if (functionPointer != (undefined4 *)0x0) {\n                (**(code **)*functionPointer)(1,computedValue);\n            }\n        }\n        \n        _free(memoryBlock);\n    }\n    \n    \n    FUN_100101dc((LPCRITICAL_SECTION *)(param_1 + 1));\n    \n    return; \n}"}
{"Function Name": "FUN_100021e0", "Address": "100021e0", "Source Code": "void __fastcall FUN_100021e0(undefined4 *params)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    *params = std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>>::vftable; \n    callFunction1((int)params); \n    callFunction2(params); \n    exceptionList = currentExceptionList; \n    return; \n}"}
{"Function Name": "FUN_10002240", "Address": "10002240", "Source Code": "int __thiscall FUN_10002240(void *object, int input_param)\n{\n    \n    uint value_at_offset_0x20 = **(uint **)((int)object + 0x20);\n    \n    \n    if ((value_at_offset_0x20 != 0) && (**(uint **)((int)object + 0x10) < value_at_offset_0x20)) {\n        \n        \n        \n        if ((input_param == -1) || ((char)input_param == *(char *)(value_at_offset_0x20 - 1) || ((*(byte *)((int)object + 0x40) & 2) == 0))) {\n            \n            \n            **(int **)((int)object + 0x30) += 1;\n            \n            \n            **(int **)((int)object + 0x20) -= 1;\n            \n            \n            if (input_param != -1) {\n                ***(char ***)((int)object + 0x20) = (char)input_param;\n                return input_param;\n            }\n            \n            return 0;\n        }\n    }\n    \n    return -1;\n}"}
{"Function Name": "FUN_10002300", "Address": "10002300", "Source Code": "void __thiscall FUN_10002300(void *object, int *outputArray, int inputValue, int condition, byte flags)\n{\n    \n    uint retrievedValue = **(uint **)((int)object + 0x24);\n    \n    \n    if ((retrievedValue != 0) && (*(uint *)((int)object + 0x3c) < retrievedValue)) {\n        \n        *(uint *)((int)object + 0x3c) = retrievedValue;\n    }\n    \n    \n    int calculatedValue = defaultValue; \n    int tempValue = **(int **)((int)object + 0x20); \n    \n    \n    if (((flags & 1) == 0) || (tempValue == 0)) {\n        \n        if (((flags & 2) != 0) && (retrievedValue != 0)) {\n            \n            if (condition == 2) {\n                tempValue = inputValue + (*(int *)((int)object + 0x3c) - **(int **)((int)object + 0x10));\n            } else if (condition == 1) {\n                tempValue = inputValue + (retrievedValue - **(int **)((int)object + 0x10));\n            } else if (condition == 0) {\n                tempValue = inputValue;\n            } else {\n                tempValue = defaultValue; \n            }\n            \n            if ((-1 < tempValue) && (tempValue <= *(int *)((int)object + 0x3c) - **(int **)((int)object + 0x10))) {\n                \n                calculatedValue = (**(int **)((int)object + 0x10) - retrievedValue) + tempValue;\n                **(int **)((int)object + 0x34) -= calculatedValue;\n                **(int **)((int)object + 0x24) += calculatedValue;\n                calculatedValue = tempValue; \n            }\n        }\n        goto LAB_1000243d; \n    }\n    \n    \n    if (condition == 2) {\n        inputValue += (*(int *)((int)object + 0x3c) - **(int **)((int)object + 0x10));\n    } else if (condition == 1) {\n        if ((flags & 2) == 0) {\n            inputValue += (tempValue - **(int **)((int)object + 0x10));\n        } else {\n            inputValue = defaultValue; \n        }\n    } else if (condition != 0) {\n        inputValue = defaultValue; \n    }\n    \n    \n    if ((-1 < inputValue) && (inputValue <= *(int *)((int)object + 0x3c) - **(int **)((int)object + 0x10))) {\n        \n        calculatedValue = (**(int **)((int)object + 0x10) - tempValue) + inputValue;\n        **(int **)((int)object + 0x30) -= calculatedValue;\n        **(int **)((int)object + 0x20) += calculatedValue;\n        \n        \n        if ((flags & 2) != 0) {\n            if (tempValue != 0) {\n                \n                int tempValue1 = **(int **)((int)object + 0x20);\n                int tempValue2 = **(int **)((int)object + 0x34);\n                **(int **)((int)object + 0x24) = tempValue1;\n                **(int **)((int)object + 0x34) = (tempValue2 + tempValue) - tempValue1;\n            }\n        }\n    }\n    \nLAB_1000243d:\n    \n    *outputArray = calculatedValue; \n    outputArray[2] = 0; \n    outputArray[3] = 0; \n    outputArray[4] = 0; \n    return; \n}"}
{"Function Name": "FUN_10002460", "Address": "10002460", "Source Code": "void __thiscall FUN_10002460(void *this, int *outputParam, int inputParam2, undefined4 undefinedParam, int inputParam4)\n{\n    uint valueFromPointer; \n    int calculatedIndex; \n    byte stackByte; \n    calculatedIndex = inputParam4 + inputParam2; \n    valueFromPointer = **(uint **)((int)this + 0x24); \n    \n    if ((valueFromPointer != 0) && (*(uint *)((int)this + 0x3c) < valueFromPointer)) {\n        *(uint *)((int)this + 0x3c) = valueFromPointer; \n    }\n    \n    if (calculatedIndex != DAT_1002d090) {\n        \n        if (((stackByte & 1) == 0) || (**(int **)((int)this + 0x20) == 0)) {\n            \n            if (((stackByte & 2) != 0) &&\n                (valueFromPointer != 0 && (-1 < calculatedIndex) && (calculatedIndex <= *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10)))) {\n                calculatedIndex = (**(int **)((int)this + 0x10) - valueFromPointer) + calculatedIndex; \n                **(int **)((int)this + 0x34) -= calculatedIndex; \n                **(int **)((int)this + 0x24) += calculatedIndex; \n            }\n        }\n    } else if ((-1 < calculatedIndex) && (calculatedIndex <= *(int *)((int)this + 0x3c) - **(int **)((int)this + 0x10))) {\n        calculatedIndex = (**(int **)((int)this + 0x10) - **(int **)((int)this + 0x20)) + calculatedIndex; \n        **(int **)((int)this + 0x30) -= calculatedIndex; \n        **(int **)((int)this + 0x20) += calculatedIndex; \n        \n        if ((stackByte & 2) != 0) {\n            int valueFromOffset24 = **(int **)((int)this + 0x24); \n            if (valueFromOffset24 != 0) {\n                **(int **)((int)this + 0x24) = **(int **)((int)this + 0x20); \n                **(int **)((int)this + 0x34) += valueFromOffset24 - **(int **)((int)this + 0x20); \n            }\n        }\n    }\n    *outputParam = calculatedIndex; \n    outputParam[2] = 0; \n    outputParam[3] = 0; \n    outputParam[4] = 0; \n    return; \n}"}
{"Function Name": "FUN_100025a0", "Address": "100025a0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100025a0(void *this, int *search_char, undefined4 *result_ptr, uint count)\n{\n    undefined4 *initial_ptr = result_ptr; \n    uint pointer_diff; \n    size_t max_elements; \n    \n    if ((count != 0) || (*(undefined4 **)((int)this + 0x14) < result_ptr)) {\n        \n        if ((result_ptr < *(undefined4 **)((int)this + 0x14)) &&\n            (pointer_diff = (int)*(undefined4 **)((int)this + 0x14) - (int)result_ptr, count <= pointer_diff)) {\n            \n            max_elements = pointer_diff + (1 - count);\n            \n            int buffer_address = (*(uint *)((int)this + 0x18) < 0x10) ? (int)this + 4 : *(int *)((int)this + 4);\n            void *buffer_ptr = (void *)(buffer_address + (int)initial_ptr); \n            \n            int *found_ptr = (int *)_memchr(buffer_ptr, (int)*(char *)search_char, max_elements);\n            \n            while (found_ptr != (int *)0x0) {\n                \n                if (FUN_10001710(found_ptr, search_char, count) == 0) {\n                    \n                    if (0xf < *(uint *)((int)this + 0x18)) {\n                        result_ptr = (undefined4 *)*result_ptr;\n                    }\n                    \n                    return (undefined4 *)((int)found_ptr - (int)result_ptr);\n                }\n                \n                max_elements = (int)buffer_ptr + ((max_elements - 1) - (int)found_ptr);\n                buffer_ptr = (void *)((int)found_ptr + 1); \n                \n                found_ptr = (int *)_memchr(buffer_ptr, (int)*(char *)search_char, max_elements);\n            }\n        }\n        result_ptr = (undefined4 *)0xffffffff; \n    }\n    return result_ptr; \n}\n*\\ \n \nundefined4 * __thiscall FUN_100025a0(void *this,int *search_char,undefined4 *result_ptr,uint count)\n{\n    undefined4 *initial_ptr = result_ptr;\n    uint pointer_diff;\n    size_t max_elements;\n    if ((count != 0) || (*(undefined4 **)((int)this + 0x14) < result_ptr)) {\n        if ((result_ptr < *(undefined4 **)((int)this + 0x14)) &&\n            (pointer_diff = (int)*(undefined4 **)((int)this + 0x14) - (int)result_ptr, count <= pointer_diff)) {\n            max_elements = pointer_diff + (1 - count);\n            int buffer_address = (*(uint *)((int)this + 0x18) < 0x10) ? (int)this + 4 : *(int *)((int)this + 4);\n            void *buffer_ptr = (void *)(buffer_address + (int)initial_ptr);\n            int *found_ptr = (int *)_memchr(buffer_ptr, (int)*(char *)search_char, max_elements);\n            while (found_ptr != (int *)0x0) {\n                if (FUN_10001710(found_ptr, search_char, count) == 0) {\n                    if (0xf < *(uint *)((int)this + 0x18)) {\n                        result_ptr = (undefined4 *)*result_ptr;\n                    }\n                    return (undefined4 *)((int)found_ptr - (int)result_ptr);\n                }\n                max_elements = (int)buffer_ptr + ((max_elements - 1) - (int)found_ptr);\n                buffer_ptr = (void *)((int)found_ptr + 1);\n                found_ptr = (int *)_memchr(buffer_ptr, (int)*(char *)search_char, max_elements);\n            }\n        }\n        result_ptr = (undefined4 *)0xffffffff;\n    }\n    return result_ptr;\n}"}
{"Function Name": "FUN_10002660", "Address": "10002660", "Source Code": "uint this_call FUN_10002660(void *this, uint input_param_1, uint input_param_2, int *input_param_3, uint input_param_4)\n{\n    uint intermediate_result; \n    int offset_value;  \n    \n    if (*(uint *)((int)this + 0x14) < input_param_1) {\n        FUN_10010242(); \n    }\n    \n    intermediate_result = *(int *)((int)this + 0x14) - input_param_1;\n    \n    if (intermediate_result < input_param_2) {\n        input_param_2 = intermediate_result;\n    }\n    \n    if (input_param_4 <= input_param_2) {\n        intermediate_result = input_param_4; \n    } else {\n        intermediate_result = input_param_2; \n    }\n    \n    offset_value = (*(uint *)((int)this + 0x18) < 0x10) ? (int)this + 4 : *(int *)((int)this + 4);\n    \n    intermediate_result = FUN_10001710((int *)(offset_value + input_param_1), input_param_3, intermediate_result);\n    \n    if (intermediate_result == 0) {\n        return (input_param_2 < input_param_4) ? 0xffffffff : (uint)(input_param_2 != input_param_4);\n    }\n    \n    return intermediate_result; \n}"}
{"Function Name": "FUN_10002750", "Address": "10002750", "Source Code": "\\*\nundefined4 * __fastcall FUN_10002750(undefined4 *inputPointer)\n{\n    _Locimp **locimpPointerPtr; \n    _Locimp *locimpPointer;   \n    int returnValue;        \n    exceptionList = &exceptionList; \n    *inputPointer = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable; \n    FUN_100101c4((LPCRITICAL_SECTION *)(inputPointer + 1)); \n    locimpPointerPtr = (_Locimp **)operator_new(4); \n    if (locimpPointerPtr != (_Locimp **)0x0) { \n        locimpPointer = std::locale::_Init(); \n        *locimpPointerPtr = locimpPointer; \n        returnValue = FUN_1000fe6e(); \n        FUN_10001820(returnValue); \n    }\n    inputPointer[0xe] = locimpPointerPtr; \n    FUN_10001d90((int)inputPointer); \n    return inputPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_10002750(undefined4 *inputPointer)\n{\n    _Locimp **locimpPointerPtr;\n    _Locimp *locimpPointer;\n    int returnValue;\n    exceptionList = &exceptionList;\n    *inputPointer = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n    FUN_100101c4((LPCRITICAL_SECTION *)(inputPointer + 1));\n    \n    locimpPointerPtr = (_Locimp **)operator_new(4);\n    if (locimpPointerPtr != (_Locimp **)0x0) {\n        locimpPointer = std::locale::_Init();\n        *locimpPointerPtr = locimpPointer;\n        returnValue = FUN_1000fe6e();\n        FUN_10001820(returnValue);\n    }\n    inputPointer[0xe] = locimpPointerPtr;\n    FUN_10001d90((int)inputPointer);\n    return inputPointer;\n}"}
{"Function Name": "FUN_100027e0", "Address": "100027e0", "Source Code": "void __thiscall FUN_100027e0(void *context, int *parameters)\n{\n    \n    int **pointerToPointer1 = (int **)parameters[2];\n    \n    \n    parameters[2] = (int)*pointerToPointer1;\n    \n    \n    if (*(char *)((int)*pointerToPointer1 + 0x189) == '\\0') {\n        \n        (*pointerToPointer1)[1] = (int)parameters;\n    }\n    \n    \n    pointerToPointer1[1] = (int *)parameters[1];\n    \n    \n    if (parameters == *(int **)(*(int *)((int)context + 4) + 4)) {\n        \n        *(int ***)(*(int *)((int)context + 4) + 4) = pointerToPointer1;\n        \n        \n        *pointerToPointer1 = parameters;\n        \n        \n        parameters[1] = (int)pointerToPointer1;\n        return; \n    }\n    \n    \n    int **pointerToPointer2 = (int **)parameters[1];\n    \n    \n    if (parameters == *pointerToPointer2) {\n        \n        *pointerToPointer2 = (int *)pointerToPointer1;\n        \n        \n        *pointerToPointer1 = parameters;\n        \n        \n        parameters[1] = (int)pointerToPointer1;\n        return; \n    }\n    \n    \n    pointerToPointer2[2] = (int *)pointerToPointer1;\n    \n    \n    *pointerToPointer1 = parameters;\n    \n    \n    parameters[1] = (int)pointerToPointer1;\n}"}
{"Function Name": "FUN_10002840", "Address": "10002840", "Source Code": "void __thiscall FUN_10002840(void *context, int *input_pointer)\n{\n    \n    int value_pointer = *input_pointer;\n    \n    *input_pointer = *(int *)(value_pointer + 8);\n    \n    if (*(char *)(*(int *)(value_pointer + 8) + 0x189) == '\\0') {\n        \n        *(int **)(*(int *)(value_pointer + 8) + 4) = input_pointer;\n    }\n    \n    *(int *)(value_pointer + 4) = input_pointer[1];\n    \n    if (input_pointer == *(int **)(*(int *)((int)context + 4) + 4)) {\n        \n        *(int *)(*(int *)((int)context + 4) + 4) = value_pointer;\n        \n        *(int **)(value_pointer + 8) = input_pointer;\n        \n        input_pointer[1] = value_pointer;\n        return;\n    }\n    \n    int *next_element_pointer = (int *)input_pointer[1];\n    \n    if (input_pointer == (int *)next_element_pointer[2]) {\n        \n        next_element_pointer[2] = value_pointer;\n        \n        *(int **)(value_pointer + 8) = input_pointer;\n        \n        input_pointer[1] = value_pointer;\n        return;\n    }\n    \n    *next_element_pointer = value_pointer;\n    \n    *(int **)(value_pointer + 8) = input_pointer;\n    \n    input_pointer[1] = value_pointer;\n    return;\n}"}
{"Function Name": "FUN_100028a0", "Address": "100028a0", "Source Code": "void __thiscall FUN_100028a0(void *instance, int *parameters)\n{\n    \n    int **pointerToPointer1 = (int **)parameters[2];\n    \n    \n    parameters[2] = (int)*pointerToPointer1;\n    \n    \n    if (*(char *)((int)*pointerToPointer1 + 0x2d) == '\\0') {\n        \n        (*pointerToPointer1)[1] = (int)parameters;\n    }\n    \n    \n    pointerToPointer1[1] = (int *)parameters[1];\n    \n    \n    if (parameters == *(int **)(*(int *)((int)instance + 4) + 4)) {\n        \n        *(int ***)(*(int *)((int)instance + 4) + 4) = pointerToPointer1;\n        \n        \n        *pointerToPointer1 = parameters;\n        \n        \n        parameters[1] = (int)pointerToPointer1;\n        return;\n    }\n    \n    \n    int **pointerToPointer2 = (int **)parameters[1];\n    \n    \n    if (parameters == *pointerToPointer2) {\n        \n        *pointerToPointer2 = (int *)pointerToPointer1;\n        \n        \n        *pointerToPointer1 = parameters;\n        \n        \n        parameters[1] = (int)pointerToPointer1;\n        return;\n    }\n    \n    \n    pointerToPointer2[2] = (int *)pointerToPointer1;\n    \n    \n    *pointerToPointer1 = parameters;\n    \n    \n    parameters[1] = (int)pointerToPointer1;\n    return;\n}"}
{"Function Name": "FUN_100028f0", "Address": "100028f0", "Source Code": "void __thiscall FUN_100028f0(void *context, int *inputPointer)\n{\n    \n    int valueAtParam1 = *inputPointer;\n    \n    \n    *inputPointer = *(int *)(valueAtParam1 + 8);\n    \n    \n    if (*(char *)(*(int *)(valueAtParam1 + 8) + 0x2d) == '\\0') {\n        \n        *(int **)(*(int *)(valueAtParam1 + 8) + 4) = inputPointer;\n    }\n    \n    \n    *(int *)(valueAtParam1 + 4) = inputPointer[1];\n    \n    \n    if (inputPointer == *(int **)(*(int *)((int)context + 4) + 4)) {\n        \n        *(int *)(*(int *)((int)context + 4) + 4) = valueAtParam1;\n        \n        \n        *(int **)(valueAtParam1 + 8) = inputPointer;\n        \n        \n        inputPointer[1] = valueAtParam1;\n        return; \n    }\n    \n    \n    int *nextElementPointer = (int *)inputPointer[1];\n    \n    \n    if (inputPointer == (int *)nextElementPointer[2]) {\n        \n        nextElementPointer[2] = valueAtParam1;\n    } else {\n        \n        *nextElementPointer = valueAtParam1;\n    }\n    \n    \n    *(int **)(valueAtParam1 + 8) = inputPointer;\n    \n    \n    inputPointer[1] = valueAtParam1;\n}"}
{"Function Name": "FUN_10002950", "Address": "10002950", "Source Code": "void __fastcall FUN_10002950(int *inputArray)\n{\n    char characterValue; \n    int *intPointer; \n    int firstInteger; \n    int secondInteger; \n    \n    if (*inputArray == 0) {\n        FUN_10011202(); \n    }\n    \n    \n    intPointer = (int *)inputArray[1];\n    \n    \n    if (*(char *)((int)intPointer + 0x2d) == '\\0') {\n        firstInteger = *intPointer; \n        \n        if (*(char *)(firstInteger + 0x2d) == '\\0') {\n            secondInteger = *(int *)(firstInteger + 8); \n            \n            while (*(char *)(secondInteger + 0x2d) == '\\0') {\n                firstInteger = secondInteger; \n                secondInteger = *(int *)(secondInteger + 8); \n            }\n            inputArray[1] = firstInteger; \n            return; \n        }\n        \n        intPointer = (int *)intPointer[1];\n        characterValue = *(char *)((int)intPointer + 0x2d); \n        \n        while ((characterValue == '\\0' && (inputArray[1] == *intPointer))) {\n            inputArray[1] = (int)intPointer; \n            intPointer = (int *)intPointer[1]; \n            characterValue = *(char *)((int)intPointer + 0x2d); \n        }\n        \n        if (*(char *)(inputArray[1] + 0x2d) != '\\0') {\n            FUN_10011202(); \n            return; \n        }\n        inputArray[1] = (int)intPointer; \n    } else {\n        firstInteger = intPointer[2]; \n        inputArray[1] = firstInteger; \n        \n        if (*(char *)(firstInteger + 0x2d) != '\\0') {\n            FUN_10011202(); \n            return; \n        }\n    }\n}"}
{"Function Name": "FUN_100029e0", "Address": "100029e0", "Source Code": "void __fastcall FUN_100029e0(int *input_array)\n{\n    int current_value; \n    int **pointer_to_pointer_1; \n    int **pointer_to_pointer_2; \n    \n    if (*input_array == 0) {\n        FUN_10011202(); \n    }\n    \n    current_value = input_array[1]; \n    \n    if (*(char *)(current_value + 0x2d) == '\\0') {\n        pointer_to_pointer_1 = *(int ***)(current_value + 8); \n        \n        \n        if (*(char *)((int)pointer_to_pointer_1 + 0x2d) != '\\0') {\n            \n            do {\n                current_value = *(int *)(current_value + 4); \n            } while (*(char *)(current_value + 0x2d) == '\\0' && (input_array[1] == *(int *)(current_value + 8)));\n            \n            input_array[1] = current_value; \n            return; \n        }\n        \n        pointer_to_pointer_2 = (int **)*pointer_to_pointer_1; \n        \n        while (*(char *)((int)*pointer_to_pointer_1 + 0x2d) == '\\0') {\n            pointer_to_pointer_1 = pointer_to_pointer_2; \n            pointer_to_pointer_2 = (int **)*pointer_to_pointer_2; \n        }\n        \n        input_array[1] = (int)pointer_to_pointer_1; \n        return; \n    }\n    \n    FUN_10011202(); \n}"}
{"Function Name": "FUN_10002a50", "Address": "10002a50", "Source Code": "void __fastcall FUN_10002a50(int **inputPointer)\n{\n    int value; \n    \n    value = *(int *)(*(int *)(**inputPointer + 4) + 0x28 + (int)*inputPointer);\n    \n    \n    if (value != 0) {\n        \n        FUN_100101fa((LPCRITICAL_SECTION *)(value + 4));\n    }\n    \n    return; \n}"}
{"Function Name": "FUN_10002c30", "Address": "10002c30", "Source Code": "int __thiscall FUN_10002c30(void *this, undefined *output_buffer, rsize_t buffer_size, rsize_t item_count)\n{\n    rsize_t max_item_count; \n    int processed_item_count = 0; \n    \n    if ((int)item_count < 1) {\n        return 0; \n    }\n    \n    do {\n        \n        max_item_count = FUN_10001c70((int)this);\n        \n        \n        if ((int)max_item_count < 1) {\n            \n            int function_result = (**(code **)(*this + 0x14))();\n            \n            \n            if (function_result == -1) {\n                return processed_item_count; \n            }\n            processed_item_count++; \n            *output_buffer++ = (char)function_result; \n        } else {\n            \n            if ((int)item_count < (int)max_item_count) {\n                max_item_count = item_count; \n            }\n            \n            _memcpy_s(output_buffer, buffer_size, **(void ***)((int)this + 0x20), max_item_count);\n            \n            **(int **)((int)this + 0x30) -= max_item_count;\n            processed_item_count += max_item_count; \n            output_buffer += max_item_count; \n            \n            **(int **)((int)this + 0x20) += max_item_count;\n        }\n        \n        item_count += (function_result == -1) ? 0 : -max_item_count;\n    } while (0 < (int)item_count); \n    \n    return processed_item_count; \n}"}
{"Function Name": "FUN_10002cd0", "Address": "10002cd0", "Source Code": "int __thiscall FUN_10002cd0(void *this, undefined *param_1, rsize_t param_2) {\n    rsize_t destinationSize; \n    rsize_t maxCount; \n    int successCount = 0; \n    \n    if ((int)param_2 < 1) {\n        return 0; \n    }\n    \n    do {\n        \n        destinationSize = FUN_10002130((int)this);\n        \n        \n        if ((int)destinationSize < 1) {\n            \n            if ((**(code **)(*this + 4))(*param_1) == -1) {\n                return successCount; \n            }\n            successCount++; \n            param_1++; \n        } else {\n            \n            maxCount = (int)param_2 < (int)destinationSize ? param_2 : destinationSize;\n            \n            _memcpy_s(**(void ***)((int)this + 0x24), destinationSize, param_1, maxCount);\n            \n            **(int **)((int)this + 0x34) -= maxCount;\n            successCount += maxCount; \n            param_1 += maxCount; \n            \n            **(int **)((int)this + 0x24) += maxCount;\n        }\n        \n        param_2 += (int)destinationSize < 1 ? -1 : -maxCount;\n    } while (0 < (int)param_2); \n    \n    return successCount; \n}"}
{"Function Name": "FUN_10002d70", "Address": "10002d70", "Source Code": "void __fastcall FUN_10002d70(int input_param)\n{\n    void *current_exception_list; \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    \n    *(undefined ***)(*(int *)(*(int *)(input_param + -0x50) + 4) + -0x50 + input_param) =\n    std::basic_istringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::\n    virtual_function_table;\n    \n    call_function((undefined4 *)(input_param + -0x48));\n    \n    *(undefined ***)\n    (*(int *)(*(int *)(input_param + -0x50) + 4) + -8 + (int)(undefined4 *)(input_param + -0x48)) =\n    std::basic_istream<char,struct_std::char_traits<char>_>::virtual_function_table;\n    exception_list = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10002fe0", "Address": "10002fe0", "Source Code": "void __thiscall FUN_10002fe0(void *this, uint param_1)\n{\n    uint valueFromMemory; \n    uint halfValue; \n    uint modifiedParam; \n    modifiedParam = param_1 | 0xf; \n    if (modifiedParam != 0xffffffff) { \n        valueFromMemory = *(uint *)((int)this + 0x18); \n        halfValue = valueFromMemory >> 1; \n        if ((modifiedParam / 3 < halfValue) && (valueFromMemory <= -halfValue - 2)) { \n            param_1 = halfValue + valueFromMemory; \n        }\n    }\n    FUN_100026d0(param_1 + 1); \n    FUN_10003095(); \n    return; \n}"}
{"Function Name": "FUN_10003130", "Address": "10003130", "Source Code": "void FUN_10003130(void)\n{\n    undefined4 *memoryPointer; \n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    memoryPointer = (undefined4 *)operator_new(400); \n    if (memoryPointer != (undefined4 *)0x0) { \n        *memoryPointer = 0; \n        memoryPointer[1] = 0; \n        memoryPointer[2] = 0; \n        *(undefined *)(memoryPointer + 0x62) = 1; \n        *(undefined *)((int)memoryPointer + 0x189) = 0; \n    }\n    currentExceptionList = previousExceptionList; \n    return; \n}"}
{"Function Name": "FUN_100031f0", "Address": "100031f0", "Source Code": "void __thiscall FUN_100031f0(void *instance, void *source, uint size, undefined4 flag)\n{\n    void *destination; \n    *(undefined4 *)((int)instance + 0x3c) = 0; \n    *(undefined4 *)((int)instance + 0x40) = flag; \n    if ((size != 0) && (((byte)flag & 6) != 6)) { \n        destination = (void *)FUN_100026d0(size); \n        _memcpy_s(destination, size, source, size); \n        *(void **)((int)instance + 0x3c) = (void *)((int)destination + size); \n        if ((*(byte *)((int)instance + 0x40) & 4) == 0) { \n            **(void ***)((int)instance + 0x10) = destination; \n            **(void ***)((int)instance + 0x20) = destination; \n            **(uint **)((int)instance + 0x30) = size; \n        }\n        \n        if ((*(uint *)((int)instance + 0x40) & 2) == 0) { \n            void *endPointer = (void *)((int)destination + size); \n            if ((*(uint *)((int)instance + 0x40) & 0x10) == 0) { \n                endPointer = destination; \n            }\n            **(void ***)((int)instance + 0x14) = destination; \n            **(void ***)((int)instance + 0x24) = endPointer; \n            **(int **)((int)instance + 0x34) = (int)destination + (size - (int)endPointer); \n            \n            if (**(int **)((int)instance + 0x20) == 0) { \n                **(void ***)((int)instance + 0x10) = destination; \n                **(undefined4 **)((int)instance + 0x20) = 0; \n                **(void ***)((int)instance + 0x30) = destination; \n            }\n        }\n    }\n    *(uint *)((int)instance + 0x40) |= 1; \n}"}
{"Function Name": "FUN_100032a0", "Address": "100032a0", "Source Code": "void FUN_100032a0(void)\n{\n    undefined4 *allocatedMemoryPointer; \n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    allocatedMemoryPointer = (undefined4 *)operator_new(0x30); \n    if (allocatedMemoryPointer != (undefined4 *)0x0) { \n        *allocatedMemoryPointer = 0; \n        allocatedMemoryPointer[1] = 0; \n        allocatedMemoryPointer[2] = 0; \n        *(undefined *)(allocatedMemoryPointer + 0xb) = 1; \n        *(undefined *)((int)allocatedMemoryPointer + 0x2d) = 0; \n    }\n    currentExceptionList = previousExceptionList; \n    return; \n}"}
{"Function Name": "FUN_10003390", "Address": "10003390", "Source Code": "void __fastcall FUN_10003390(int input_param)\n{\n    \n    undefined4 *data_pointer = (undefined4 *)(input_param + 0x50);\n    \n    \n    FUN_10002d70(data_pointer);\n    \n    \n    FUN_10001b80(data_pointer);\n}"}
{"Function Name": "FUN_10003430", "Address": "10003430", "Source Code": "bool __thiscall FUN_10003430(void *instance, uint inputValue, char flag)\n{\n    \n    uint currentCount = *(uint *)((int)instance + 0x18);\n    \n    \n    if (inputValue == 0xffffffff) {\n        \n        FUN_10010203();\n    }\n    \n    \n    if (currentCount < inputValue) {\n        \n        FUN_10002fe0(instance, inputValue);\n        \n        return inputValue != 0;\n    }\n    \n    \n    if (flag != '\\0' && inputValue < 0x10) {\n        \n        uint maxCount = *(uint *)((int)instance + 0x14);\n        \n        \n        if (inputValue < maxCount) {\n            maxCount = inputValue;\n        }\n        \n        \n        if (0xf < currentCount) {\n            \n            void *sourcePointer = *(void **)((int)instance + 4);\n            \n            \n            if (maxCount != 0) {\n                \n                _memcpy_s((void **)((int)instance + 4), 0x10, sourcePointer, maxCount);\n            }\n            \n            _free(sourcePointer);\n        }\n        \n        \n        *(uint *)((int)instance + 0x14) = maxCount;\n        \n        *(undefined4 *)((int)instance + 0x18) = 0xf;\n        \n        *(undefined *)((int)instance + maxCount + 4) = 0;\n        \n        return inputValue != 0;\n    }\n    \n    \n    if (inputValue == 0) {\n        \n        *(undefined4 *)((int)instance + 0x14) = 0;\n        \n        \n        if (0xf < currentCount) {\n            \n            **(undefined **)((int)instance + 4) = 0;\n            \n            return false;\n        }\n        \n        *(undefined *)((int)instance + 4) = 0;\n    }\n    \n    \n    return inputValue != 0;\n}"}
{"Function Name": "FUN_100034f0", "Address": "100034f0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100034f0(void *this, int param_1, byte param_2)\n{\n    uint flags = 0; \n    void *address;   \n    \n    *(undefined ***)this =\n    std::basic_stringbuf<char, struct_std::char_traits<char>, class_std::allocator<char>_>::vftable;\n    \n    if ((param_2 & 1) == 0) {\n        flags = 4; \n    }\n    \n    if ((param_2 & 2) == 0) {\n        flags |= 2; \n    }\n    \n    if ((param_2 & 8) != 0) {\n        flags |= 8; \n    }\n    \n    if ((param_2 & 4) != 0) {\n        flags |= 0x10; \n    }\n    \n    \n    address = (*(uint *)(param_1 + 0x18) < 0x10) ? (void *)(param_1 + 4) : *(void **)(param_1 + 4);\n    \n    \n    FUN_100031f0(this, address, *(uint *)(param_1 + 0x14), flags);\n    \n    \n    return (undefined4 *)this;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100034f0(void *this,int param_1,byte param_2)\n{\n    uint flags = 0;\n    void *address;\n    *(undefined ***)this =\n    std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n    if ((param_2 & 1) == 0) {\n        flags = 4;\n    }\n    if ((param_2 & 2) == 0) {\n        flags |= 2;\n    }\n    if ((param_2 & 8) != 0) {\n        flags |= 8;\n    }\n    if ((param_2 & 4) != 0) {\n        flags |= 0x10;\n    }\n    \n    address = (*(uint *)(param_1 + 0x18) < 0x10) ? (void *)(param_1 + 4) : *(void **)(param_1 + 4);\n    \n    FUN_100031f0(this, address, *(uint *)(param_1 + 0x14), flags);\n    \n    return (undefined4 *)this;\n}"}
{"Function Name": "FUN_100035d0", "Address": "100035d0", "Source Code": "void __fastcall FUN_100035d0(undefined4 *exception_params)\n{\n    undefined *stack_pointer; \n    stack_pointer = &LAB_10027033; \n    exception_list = &exception_list; \n    *exception_params = std::logic_error::vftable; \n    \n    \n    if (0xf < (uint)exception_params[9]) {\n        _free((void *)exception_params[4]); \n    }\n    \n    exception_params[9] = 0xf; \n    exception_params[8] = 0; \n    *(undefined *)(exception_params + 4) = 0; \n    \n    exception::~exception((exception *)exception_params); \n    return; \n}"}
{"Function Name": "FUN_10003680", "Address": "10003680", "Source Code": "void __fastcall FUN_10003680(undefined4 *exception_params) \n{\n    void *previous_exception_list; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    *exception_params = std::runtime_error::vftable; \n    if (0xf < (uint)exception_params[9]) { \n        _free((void *)exception_params[4]); \n    }\n    exception_params[9] = 0xf; \n    exception_params[8] = 0; \n    *(undefined *)(exception_params + 4) = 0; \n    exception::~exception((exception *)exception_params); \n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10003720", "Address": "10003720", "Source Code": "void __fastcall FUN_10003720(int *inputArray)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    std::_Locinfo::_Locinfo_dtor((_Locinfo *)inputArray); \n    \n    if (0xf < (uint)inputArray[0x1c]) {\n        _free((void *)inputArray[0x17]); \n    }\n    inputArray[0x1c] = 0xf; \n    inputArray[0x1b] = 0; \n    *(undefined *)(inputArray + 0x17) = 0; \n    \n    if (0xf < (uint)inputArray[0x15]) {\n        _free((void *)inputArray[0x10]); \n    }\n    inputArray[0x15] = 0xf; \n    inputArray[0x14] = 0; \n    *(undefined *)(inputArray + 0x10) = 0; \n    \n    if (0xf < (uint)inputArray[0xe]) {\n        _free((void *)inputArray[9]); \n    }\n    inputArray[0xe] = 0xf; \n    inputArray[0xd] = 0; \n    *(undefined *)(inputArray + 9) = 0; \n    \n    if (0xf < (uint)inputArray[7]) {\n        _free((void *)inputArray[2]); \n    }\n    inputArray[7] = 0xf; \n    inputArray[6] = 0; \n    *(undefined *)(inputArray + 2) = 0; \n    FUN_1000fe01(inputArray); \n    exceptionList = currentExceptionList; \n    return; \n}"}
{"Function Name": "FUN_10003810", "Address": "10003810", "Source Code": "void __fastcall FUN_10003810(int input_param)\n{\n    void *current_exception_list; \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    \n    for (int index = 0; index < 12; index += 4) {\n        \n        if (0xf < *(uint *)(input_param + 0x18 + index)) {\n            \n            free_memory(*(void **)(input_param + 4 + index));\n        }\n        \n        *(undefined4 *)(input_param + 0x18 + index) = 0xf;\n        \n        *(undefined4 *)(input_param + 0x14 + index) = 0;\n        \n        *(undefined *)(input_param + 4 + index) = 0;\n    }\n    exception_list = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10003a20", "Address": "10003a20", "Source Code": "void __fastcall FUN_10003a20(int input_param)\n{\n    void *previous_exception_list; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    call_function_with_offset(input_param + 0x20); \n    \n    if (0xf < *(uint *)(input_param + 0x18)) {\n        free_memory(*(void **)(input_param + 4)); \n    }\n    *(undefined4 *)(input_param + 0x18) = 0xf; \n    *(undefined4 *)(input_param + 0x14) = 0; \n    *(undefined *)(input_param + 4) = 0; \n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10003aa0", "Address": "10003aa0", "Source Code": "void __fastcall FUN_10003aa0(int input_param)\n{\n    void *previous_exception_list; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    call_function_with_offset(input_param + 0x20); \n    \n    if (0xf < *(uint *)(input_param + 0x18)) {\n        free_memory(*(void **)(input_param + 4)); \n    }\n    *(undefined4 *)(input_param + 0x18) = 0xf; \n    *(undefined4 *)(input_param + 0x14) = 0; \n    *(undefined *)(input_param + 4) = 0; \n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10003b20", "Address": "10003b20", "Source Code": "void __fastcall FUN_10003b20(int input_param)\n{\n    void *previous_exception_list; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    if (0xf < *(uint *)(input_param + 0x1c)) { \n        free_memory(*(void **)(input_param + 8)); \n    }\n    *(undefined4 *)(input_param + 0x1c) = 0xf; \n    *(undefined4 *)(input_param + 0x18) = 0; \n    *(undefined *)(input_param + 8) = 0; \n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10003b90", "Address": "10003b90", "Source Code": "void __fastcall FUN_10003b90(int input_param)\n{\n    void *current_exception_list; \n    \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    \n    \n    if (0xf < *(uint *)(input_param + 0x1c)) {\n        free_memory(*(void **)(input_param + 8)); \n    }\n    \n    *(undefined4 *)(input_param + 0x1c) = 0xf; \n    *(undefined4 *)(input_param + 0x18) = 0; \n    *(undefined *)(input_param + 8) = 0; \n    \n    exception_list = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10003c00", "Address": "10003c00", "Source Code": "void * __thiscall FUN_10003c00(void *object, int input_param, uint threshold, uint limit)\n{\n    uint calculated_value;\n    \n    if (*(uint *)(input_param + 0x14) < threshold) {\n        FUN_10010242(); \n    }\n    \n    calculated_value = *(int *)(input_param + 0x14) - threshold;\n    \n    if (calculated_value < limit) {\n        limit = calculated_value;\n    }\n    \n    calculated_value = *(uint *)((int)object + 0x14);\n    \n    if ((-calculated_value - 1 <= limit) || (calculated_value + limit < calculated_value)) {\n        FUN_10010203(); \n    }\n    \n    if (limit != 0) {\n        \n        calculated_value = *(int *)((int)object + 0x14) + limit;\n        \n        if (calculated_value == 0xffffffff) {\n            FUN_10010203(); \n        }\n        \n        if (*(uint *)((int)object + 0x18) < calculated_value) {\n            FUN_10002fe0(object, calculated_value); \n        } else if (calculated_value == 0) {\n            \n            *(undefined4 *)((int)object + 0x14) = 0;\n            \n            if (0xf < *(uint *)((int)object + 0x18)) {\n                **(undefined **)((int)object + 4) = 0; \n                return object; \n            }\n            *(undefined *)((int)object + 4) = 0; \n            return object; \n        }\n        \n        if (calculated_value != 0) {\n            _memcpy_s((void *)(*(int *)((int)object + 0x14) + ( *(uint *)(input_param + 0x18) < 0x10 ? (int)object + 4 : *(int *)(input_param + 4))),\n                *(uint *)((int)object + 0x18) - *(int *)((int)object + 0x14),\n                (void *)((*(uint *)(input_param + 0x18) < 0x10 ? input_param + 4 : *(int *)(input_param + 4)) + input_param),\n                limit); \n            \n            *(uint *)((int)object + 0x14) = calculated_value;\n            \n            if (0xf < *(uint *)((int)object + 0x18)) {\n                *(undefined *)(*(int *)((int)object + 4) + calculated_value) = 0; \n                return object; \n            }\n            *(undefined *)((int)object + calculated_value + 4) = 0; \n        }\n    }\n    return object; \n}"}
{"Function Name": "FUN_10004040", "Address": "10004040", "Source Code": "void * __thiscall FUN_10004040(void *objectPointer, void *parameter1)\n{\n    \n    *(undefined4 *)((int)objectPointer + 0x14) = 0;\n    \n    *(undefined4 *)((int)objectPointer + 0x18) = 0xf;\n    \n    *(undefined *)((int)objectPointer + 4) = 0;\n    \n    FUN_10003db0(objectPointer, parameter1, 0, 0xffffffff);\n    \n    return objectPointer;\n}"}
{"Function Name": "FUN_10004190", "Address": "10004190", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004190(void *objectPointer, undefined4 *inputParam)\n{\n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    *(undefined4 *)objectPointer = *inputParam; \n    *(undefined4 *)((int)objectPointer + 0x1c) = 0xf; \n    *(undefined4 *)((int)objectPointer + 0x18) = 0; \n    *(undefined *)((int)objectPointer + 8) = 0; \n    FUN_10003db0((void *)((int)objectPointer + 4), inputParam + 1, 0, 0xffffffff); \n    currentExceptionList = previousExceptionList; \n    return (undefined4 *)objectPointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10004190(void *objectPointer, undefined4 *inputParam)\n{\n    void *previousExceptionList;\n    previousExceptionList = currentExceptionList;\n    currentExceptionList = &previousExceptionList;\n    *(undefined4 *)objectPointer = *inputParam;\n    *(undefined4 *)((int)objectPointer + 0x1c) = 0xf;\n    *(undefined4 *)((int)objectPointer + 0x18) = 0;\n    *(undefined *)((int)objectPointer + 8) = 0;\n    FUN_10003db0((void *)((int)objectPointer + 4), inputParam + 1, 0, 0xffffffff);\n    currentExceptionList = previousExceptionList;\n    return (undefined4 *)objectPointer;\n}"}
{"Function Name": "FUN_10004200", "Address": "10004200", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004200(void *objectPointer, undefined4 *inputParam)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionListPointer; \n    exceptionListPointer = &currentExceptionList; \n    *(undefined4 *)objectPointer = *inputParam; \n    *(undefined4 *)((int)objectPointer + 0x1c) = 0xf; \n    *(undefined4 *)((int)objectPointer + 0x18) = 0; \n    *(undefined *)((int)objectPointer + 8) = 0; \n    FUN_10003db0((void *)((int)objectPointer + 4), inputParam + 1, 0, 0xffffffff); \n    exceptionListPointer = currentExceptionList; \n    return (undefined4 *)objectPointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10004200(void *objectPointer, undefined4 *inputParam)\n{\n    void *currentExceptionList;\n    currentExceptionList = exceptionListPointer;\n    exceptionListPointer = &currentExceptionList;\n    *(undefined4 *)objectPointer = *inputParam;\n    *(undefined4 *)((int)objectPointer + 0x1c) = 0xf;\n    *(undefined4 *)((int)objectPointer + 0x18) = 0;\n    *(undefined *)((int)objectPointer + 8) = 0;\n    FUN_10003db0((void *)((int)objectPointer + 4), inputParam + 1, 0, 0xffffffff);\n    exceptionListPointer = currentExceptionList;\n    return (undefined4 *)objectPointer;\n}"}
{"Function Name": "FUN_10004270", "Address": "10004270", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004270(void *object, undefined4 *input_value, void *additional_param)\n{\n    void *previous_exception_list; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    *(undefined4 *)object = *input_value; \n    *(undefined4 *)((int)object + 0x1c) = 0xf; \n    *(undefined4 *)((int)object + 0x18) = 0; \n    *(undefined *)((int)object + 8) = 0; \n    FUN_10003db0((void *)((int)object + 4), additional_param, 0, 0xffffffff); \n    current_exception_list = previous_exception_list; \n    return (undefined4 *)object; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10004270(void *object, undefined4 *input_value, void *additional_param)\n{\n    void *previous_exception_list;\n    previous_exception_list = current_exception_list;\n    current_exception_list = &previous_exception_list;\n    *(undefined4 *)object = *input_value;\n    *(undefined4 *)((int)object + 0x1c) = 0xf;\n    *(undefined4 *)((int)object + 0x18) = 0;\n    *(undefined *)((int)object + 8) = 0;\n    FUN_10003db0((void *)((int)object + 4), additional_param, 0, 0xffffffff);\n    current_exception_list = previous_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100042e0", "Address": "100042e0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100042e0(void *object_pointer, void *parameter_1)\n{\n    \n    void *original_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &original_exception_list;\n    \n    \n    FUN_10010943((undefined4 *)object_pointer);\n    \n    \n    *(undefined ***)object_pointer = std::logic_error::vftable;\n    \n    \n    *(undefined4 *)((int)object_pointer + 0x20) = 0;\n    \n    \n    *(undefined4 *)((int)object_pointer + 0x24) = 0xf;\n    \n    \n    *(undefined *)((int)object_pointer + 0x10) = 0;\n    \n    \n    FUN_10003db0((void *)((int)object_pointer + 0xc), parameter_1, 0, 0xffffffff);\n    \n    \n    ExceptionList = original_exception_list;\n    \n    \n    return (undefined4 *)object_pointer;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100042e0(void *object_pointer, void *parameter_1)\n{\n    void *original_exception_list = ExceptionList;\n    ExceptionList = &original_exception_list;\n    FUN_10010943((undefined4 *)object_pointer);\n    *(undefined ***)object_pointer = std::logic_error::vftable;\n    *(undefined4 *)((int)object_pointer + 0x20) = 0;\n    *(undefined4 *)((int)object_pointer + 0x24) = 0xf;\n    *(undefined *)((int)object_pointer + 0x10) = 0;\n    FUN_10003db0((void *)((int)object_pointer + 0xc), parameter_1, 0, 0xffffffff);\n    ExceptionList = original_exception_list;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FUN_10004360", "Address": "10004360", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004360(void *object, undefined4 argument)\n{\n    \n    void *previous_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &previous_exception_list;\n    \n    \n    FUN_100042e0(object, argument);\n    \n    \n    *(undefined ***)object = std::length_error::vftable;\n    \n    \n    ExceptionList = previous_exception_list;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10004360(void *object, undefined4 argument)\n{\n    void *previous_exception_list = ExceptionList;\n    ExceptionList = &previous_exception_list;\n    FUN_100042e0(object, argument);\n    *(undefined ***)object = std::length_error::vftable;\n    ExceptionList = previous_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100043c0", "Address": "100043c0", "Source Code": "void __fastcall FUN_100043c0(undefined4 *exception_pointer)\n{\n    \n    void *current_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &current_exception_list;\n    \n    \n    *exception_pointer = std::length_error::vftable;\n    \n    \n    FUN_100035d0(exception_pointer);\n    \n    \n    ExceptionList = current_exception_list;\n}"}
{"Function Name": "FUN_10004410", "Address": "10004410", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004410(void *object_pointer, byte flag)\n{\n    void *current_exception_list = previous_exception_list; \n    previous_exception_list = &current_exception_list; \n    *(undefined ***)object_pointer = std::length_error::vftable; \n    call_function((undefined4 *)object_pointer); \n    if ((flag & 1) != 0) { \n        free_memory(object_pointer); \n    }\n    previous_exception_list = current_exception_list; \n    return (undefined4 *)object_pointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10004410(void *object_pointer, byte flag)\n{\n    void *current_exception_list = previous_exception_list;\n    previous_exception_list = &current_exception_list;\n    *(undefined ***)object_pointer = std::length_error::vftable;\n    call_function((undefined4 *)object_pointer);\n    if ((flag & 1) != 0) {\n        free_memory(object_pointer);\n    }\n    previous_exception_list = current_exception_list;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FUN_10004470", "Address": "10004470", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004470(void *object, undefined4 parameter_1)\n{\n    void *current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    FUN_100042e0(object, parameter_1); \n    *(undefined ***)object = std::out_of_range::vftable; \n    exception_list = current_exception_list; \n    return (undefined4 *)object; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10004470(void *object, undefined4 parameter_1)\n{\n    void *current_exception_list = exception_list;\n    exception_list = &current_exception_list;\n    FUN_100042e0(object, parameter_1);\n    *(undefined ***)object = std::out_of_range::vftable;\n    exception_list = current_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100044d0", "Address": "100044d0", "Source Code": "void __fastcall FUN_100044d0(undefined4 *exception_pointer)\n{\n    \n    void *current_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &current_exception_list;\n    \n    \n    *exception_pointer = std::out_of_range::vftable;\n    \n    \n    FUN_100035d0(exception_pointer);\n    \n    \n    ExceptionList = current_exception_list;\n}"}
{"Function Name": "FUN_10004520", "Address": "10004520", "Source Code": "\\*\nundefined4 * function_pointer FUN_10004520(void *object_pointer, byte flag)\n{\n    void *current_exception_list; \n    \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    *(undefined ***)object_pointer = std::out_of_range::vftable; \n    another_function((undefined4 *)object_pointer); \n    if ((flag & 1) != 0) { \n        free_memory(object_pointer); \n    }\n    exception_list = current_exception_list; \n    return (undefined4 *)object_pointer; \n}\n*\\ \n \nundefined4 * function_pointer FUN_10004520(void *object_pointer, byte flag)\n{\n    void *current_exception_list;\n    \n    current_exception_list = exception_list;\n    exception_list = &current_exception_list;\n    *(undefined ***)object_pointer = std::out_of_range::vftable;\n    another_function((undefined4 *)object_pointer);\n    if ((flag & 1) != 0) {\n        free_memory(object_pointer);\n    }\n    exception_list = current_exception_list;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FUN_10004580", "Address": "10004580", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004580(void *object_pointer, void *parameter_1)\n{\n    \n    void *previous_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &previous_exception_list;\n    \n    \n    FUN_10010943((undefined4 *)object_pointer);\n    \n    \n    *(undefined ***)object_pointer = std::runtime_error::vftable;\n    \n    \n    *(undefined4 *)((int)object_pointer + 0x20) = 0;\n    \n    \n    *(undefined4 *)((int)object_pointer + 0x24) = 0xf;\n    \n    \n    *(undefined *)((int)object_pointer + 0x10) = 0;\n    \n    \n    FUN_10003db0((void *)((int)object_pointer + 0xc), parameter_1, 0, 0xffffffff);\n    \n    \n    ExceptionList = previous_exception_list;\n    \n    \n    return (undefined4 *)object_pointer;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10004580(void *object_pointer, void *parameter_1)\n{\n    void *previous_exception_list = ExceptionList;\n    ExceptionList = &previous_exception_list;\n    FUN_10010943((undefined4 *)object_pointer);\n    *(undefined ***)object_pointer = std::runtime_error::vftable;\n    *(undefined4 *)((int)object_pointer + 0x20) = 0;\n    *(undefined4 *)((int)object_pointer + 0x24) = 0xf;\n    *(undefined *)((int)object_pointer + 0x10) = 0;\n    FUN_10003db0((void *)((int)object_pointer + 0xc), parameter_1, 0, 0xffffffff);\n    ExceptionList = previous_exception_list;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FUN_10004600", "Address": "10004600", "Source Code": "\\*\nundefined4 * __thiscall FUN_10004600(void *object_reference, void *parameter_1)\n{\n    void *current_exception_list = ExceptionList; \n    ExceptionList = &current_exception_list; \n    FUN_10004580(object_reference, parameter_1); \n    *(undefined ***)object_reference = std::ios_base::failure::vftable; \n    ExceptionList = current_exception_list; \n    return (undefined4 *)object_reference; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10004600(void *object_reference, void *parameter_1)\n{\n    void *current_exception_list = ExceptionList;\n    ExceptionList = &current_exception_list;\n    FUN_10004580(object_reference, parameter_1);\n    *(undefined ***)object_reference = std::ios_base::failure::vftable;\n    ExceptionList = current_exception_list;\n    return (undefined4 *)object_reference;\n}"}
{"Function Name": "FUN_10004660", "Address": "10004660", "Source Code": "void __fastcall FUN_10004660(undefined4 *exception_pointer)\n{\n    \n    void *current_exception_list = global_exception_list;\n    \n    \n    global_exception_list = &current_exception_list;\n    \n    \n    *exception_pointer = std::ios_base::failure::vftable;\n    \n    \n    FUN_10003680(exception_pointer);\n    \n    \n    global_exception_list = current_exception_list;\n    \n    \n    return;\n}"}
{"Function Name": "FUN_100046b0", "Address": "100046b0", "Source Code": "\\*\nundefined4 * methodCall FUN_100046b0(void *objectPointer, byte flag)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    *(undefined ***)objectPointer = std::ios_base::failure::vftable; \n    anotherFunction((undefined4 *)objectPointer); \n    if ((flag & 1) != 0) { \n        freeMemory(objectPointer); \n    }\n    exceptionList = currentExceptionList; \n    return (undefined4 *)objectPointer; \n}\n*\\ \n \nundefined4 * methodCall FUN_100046b0(void *objectPointer, byte flag)\n{\n    void *currentExceptionList;\n    currentExceptionList = exceptionList;\n    exceptionList = &currentExceptionList;\n    *(undefined ***)objectPointer = std::ios_base::failure::vftable;\n    anotherFunction((undefined4 *)objectPointer);\n    if ((flag & 1) != 0) {\n        freeMemory(objectPointer);\n    }\n    exceptionList = currentExceptionList;\n    return (undefined4 *)objectPointer;\n}"}
{"Function Name": "FUN_100047f0", "Address": "100047f0", "Source Code": "void * __thiscall FUN_100047f0(void *object, void *parameter)\n{\n    exception_list = &local_context;  \n    *(undefined4 *)((int)object + 0x18) = 0xf;  \n    *(undefined4 *)((int)object + 0x14) = 0;    \n    *(undefined *)((int)object + 4) = 0;        \n    function_call(object, parameter, 0, 0xffffffff); \n    *(undefined *)((int)object + 0x1c) = *(undefined *)((int)parameter + 0x1c); \n    *(undefined *)((int)object + 0x1d) = *(undefined *)((int)parameter + 0x1d); \n    *(undefined *)((int)object + 0x1e) = *(undefined *)((int)parameter + 0x1e); \n    *(undefined *)((int)object + 0x1f) = *(undefined *)((int)parameter + 0x1f); \n    *(undefined4 *)((int)object + 0x38) = 0xf;  \n    *(undefined4 *)((int)object + 0x34) = 0;    \n    *(undefined *)((int)object + 0x24) = 0;     \n    function_call((void *)((int)object + 0x20), (void *)((int)parameter + 0x20), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0x54) = 0xf;  \n    *(undefined4 *)((int)object + 0x50) = 0;    \n    *(undefined *)((int)object + 0x40) = 0;     \n    function_call((void *)((int)object + 0x3c), (void *)((int)parameter + 0x3c), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0x70) = 0xf;  \n    *(undefined4 *)((int)object + 0x6c) = 0;    \n    *(undefined *)((int)object + 0x5c) = 0;     \n    function_call((void *)((int)object + 0x58), (void *)((int)parameter + 0x58), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0x74) = *(undefined4 *)((int)parameter + 0x74); \n    *(undefined4 *)((int)object + 0x90) = 0xf;  \n    *(undefined4 *)((int)object + 0x8c) = 0;    \n    *(undefined *)((int)object + 0x7c) = 0;     \n    function_call((void *)((int)object + 0x78), (void *)((int)parameter + 0x78), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0xac) = 0xf;  \n    *(undefined4 *)((int)object + 0xa8) = 0;    \n    *(undefined *)((int)object + 0x98) = 0;     \n    function_call((void *)((int)object + 0x94), (void *)((int)parameter + 0x94), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 200) = 0xf;    \n    *(undefined4 *)((int)object + 0xc4) = 0;    \n    *(undefined *)((int)object + 0xb4) = 0;     \n    function_call((void *)((int)object + 0xb0), (void *)((int)parameter + 0xb0), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0xe4) = 0xf;  \n    *(undefined4 *)((int)object + 0xe0) = 0;    \n    *(undefined *)((int)object + 0xd0) = 0;     \n    function_call((void *)((int)object + 0xcc), (void *)((int)parameter + 0xcc), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0xe8) = *(undefined4 *)((int)parameter + 0xe8); \n    *(undefined4 *)((int)object + 0x104) = 0xf; \n    *(undefined4 *)((int)object + 0x100) = 0;   \n    *(undefined *)((int)object + 0xf0) = 0;     \n    function_call((void *)((int)object + 0xec), (void *)((int)parameter + 0xec), 0, 0xffffffff); \n    *(undefined *)((int)object + 0x108) = *(undefined *)((int)parameter + 0x108); \n    *(undefined4 *)((int)object + 0x110) = *(undefined4 *)((int)parameter + 0x110); \n    *(undefined4 *)((int)object + 0x114) = *(undefined4 *)((int)parameter + 0x114); \n    *(undefined *)((int)object + 0x118) = *(undefined *)((int)parameter + 0x118); \n    *(undefined4 *)((int)object + 0x134) = 0xf;  \n    *(undefined4 *)((int)object + 0x130) = 0;    \n    *(undefined *)((int)object + 0x120) = 0;     \n    function_call((void *)((int)object + 0x11c), (void *)((int)parameter + 0x11c), 0, 0xffffffff); \n    *(undefined4 *)((int)object + 0x150) = 0xf;  \n    *(undefined4 *)((int)object + 0x14c) = 0;    \n    *(undefined *)((int)object + 0x13c) = 0;     \n    function_call((void *)((int)object + 0x138), (void *)((int)parameter + 0x138), 0, 0xffffffff); \n    *(undefined *)((int)object + 0x154) = *(undefined *)((int)parameter + 0x154); \n    *(undefined *)((int)object + 0x155) = *(undefined *)((int)parameter + 0x155); \n    exception_list = local_context;  \n    return object;  \n}"}
{"Function Name": "FUN_10004a20", "Address": "10004a20", "Source Code": "int __thiscall FUN_10004a20(void *object, char *inputString)\n{\n    \n    *(undefined4 *)((int)object + 0x18) = 0xf;\n    \n    \n    *(undefined4 *)((int)object + 0x14) = 0;\n    \n    \n    *(undefined *)((int)object + 4) = 0;\n    \n    char *traversePtr = inputString;\n    \n    \n    while (*traversePtr != '\\0') {\n        traversePtr++; \n    }\n    \n    \n    \n    FUN_10003e90(object, (undefined4 *)inputString, (int)traversePtr - (int)(inputString + 1));\n    \n    \n    return (int)object;\n}"}
{"Function Name": "FUN_10004a80", "Address": "10004a80", "Source Code": "void * __thiscall FUN_10004a80(void *context, void *input_param, uint value_1, uint value_2)\n{\n    void *previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    *(undefined4 *)((int)input_param + 0x18) = 0xf; \n    *(undefined4 *)((int)input_param + 0x14) = 0; \n    *(undefined *)((int)input_param + 4) = 0; \n    FUN_10003db0(input_param, context, value_1, value_2); \n    current_exception_list = previous_exception_list; \n    return input_param; \n}"}
{"Function Name": "FUN_10004af0", "Address": "10004af0", "Source Code": "\\*\nundefined4 * __thiscall\nFUN_10004af0(void *this, undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 *param_4, undefined param_5)\n{\n    void *local_c = ExceptionList; \n    ExceptionList = &local_c; \n    *(undefined4 *)this = param_1; \n    *(undefined4 *)((int)this + 4) = param_2; \n    *(undefined4 *)((int)this + 8) = param_3; \n    FUN_10004190((void *)((int)this + 0xc), param_4); \n    *(undefined *)((int)this + 0x2c) = param_5; \n    *(undefined *)((int)this + 0x2d) = 0; \n    ExceptionList = local_c; \n    return (undefined4 *)this; \n}\n*\\ \n \nundefined4 * __thiscall\nFUN_10004af0(void *this, undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined4 *param_4, undefined param_5)\n{\n    void *local_c = ExceptionList;\n    ExceptionList = &local_c;\n    *(undefined4 *)this = param_1;\n    *(undefined4 *)((int)this + 4) = param_2;\n    *(undefined4 *)((int)this + 8) = param_3;\n    FUN_10004190((void *)((int)this + 0xc), param_4);\n    *(undefined *)((int)this + 0x2c) = param_5;\n    *(undefined *)((int)this + 0x2d) = 0;\n    ExceptionList = local_c;\n    return (undefined4 *)this;\n}"}
{"Function Name": "FUN_10004b70", "Address": "10004b70", "Source Code": "void * __thiscall FUN_10004b70(void *objectPointer, void *inputParam)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    *(undefined4 *)((int)objectPointer + 0x18) = 0xf; \n    *(undefined4 *)((int)objectPointer + 0x14) = 0; \n    *(undefined *)((int)objectPointer + 4) = 0; \n    callAnotherFunction(objectPointer, inputParam, 0, 0xffffffff); \n    adjustedPointerFunction((void *)((int)objectPointer + 0x20), (void *)((int)inputParam + 0x20)); \n    exceptionList = currentExceptionList; \n    return objectPointer; \n}"}
{"Function Name": "FUN_10004da0", "Address": "10004da0", "Source Code": "void * __thiscall FUN_10004da0(void *object, void *parameter1)\n{\n    void *currentExceptionList; \n    currentExceptionList = originalExceptionList; \n    originalExceptionList = &currentExceptionList; \n    *(undefined4 *)((int)object + 0x18) = 0xf; \n    *(undefined4 *)((int)object + 0x14) = 0; \n    *(undefined *)((int)object + 4) = 0; \n    FUN_10003db0(object, parameter1, 0, 0xffffffff); \n    FUN_100047f0((void *)((int)object + 0x20), (void *)((int)parameter1 + 0x20)); \n    originalExceptionList = currentExceptionList; \n    return object; \n}"}
{"Function Name": "FUN_10004eb0", "Address": "10004eb0", "Source Code": "void * __thiscall FUN_10004eb0(void *objectPointer, void *firstParameter, void *secondParameter)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    *(undefined4 *)((int)objectPointer + 0x18) = 0xf; \n    *(undefined4 *)((int)objectPointer + 0x14) = 0; \n    *(undefined *)((int)objectPointer + 4) = 0; \n    callFunctionA(objectPointer, firstParameter, 0, 0xffffffff); \n    callFunctionB((void *)((int)objectPointer + 0x20), secondParameter); \n    exceptionList = currentExceptionList; \n    return objectPointer; \n}"}
{"Function Name": "FUN_10005020", "Address": "10005020", "Source Code": "\\*\nuint32_t * __thiscall FUN_10005020(void *currentObject, exception *exceptionParam)\n{\n    \n    exceptionList = &exceptionList;\n    \n    std::exception::exception((exception *)currentObject, exceptionParam);\n    \n    *(undefined ***)currentObject = std::runtime_error::vftable;\n    \n    *(undefined4 *)((int)currentObject + 0x24) = 0xf;\n    \n    *(undefined4 *)((int)currentObject + 0x20) = 0;\n    \n    *(undefined *)((int)currentObject + 0x10) = 0;\n    \n    processException((void *)((int)currentObject + 0xc), exceptionParam + 0xc, 0, 0xffffffff);\n    \n    return (undefined4 *)currentObject;\n}\n*\\ \n \nuint32_t * __thiscall FUN_10005020(void *currentObject, exception *exceptionParam)\n{\n    exceptionList = &exceptionList;\n    std::exception::exception((exception *)currentObject, exceptionParam);\n    *(undefined ***)currentObject = std::runtime_error::vftable;\n    *(undefined4 *)((int)currentObject + 0x24) = 0xf;\n    *(undefined4 *)((int)currentObject + 0x20) = 0;\n    *(undefined *)((int)currentObject + 0x10) = 0;\n    processException((void *)((int)currentObject + 0xc), exceptionParam + 0xc, 0, 0xffffffff);\n    return (undefined4 *)currentObject;\n}"}
{"Function Name": "FUN_10005270", "Address": "10005270", "Source Code": "void __thiscall FUN_10005270(void *object, int first_param, int second_param, undefined4 third_param)\n{\n    \n    \n    (**(code **)(*object + 0x1c))(first_param, second_param, third_param, second_param - first_param);\n}"}
{"Function Name": "FUN_100052f0", "Address": "100052f0", "Source Code": "void __thiscall\nFUN_100052f0(void *this, int param_1, int param_2, undefined4 param_3, undefined4 param_4)\n{\n    \n    \n    (**(code **)(*this + 0x28))(param_1, param_2, param_3, param_4, param_2 - param_1);\n}"}
{"Function Name": "FUN_10005360", "Address": "10005360", "Source Code": "void __fastcall FUN_10005360(undefined4 *params)\n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    *params = std::ctype<char>::vftable; \n    if ((int)params[5] < 1) { \n        _free((void *)params[4]); \n    }\n    *params = std::locale::facet::vftable; \n    exceptionList = currentExceptionList; \n    return; \n}"}
{"Function Name": "FUN_10005400", "Address": "10005400", "Source Code": "undefined4 __cdecl FUN_10005400(int *param_1)\n{\n    void *allocated_memory; \n    int result;  \n    \n    if ((param_1 != (int *)0x0) && (*param_1 == 0)) {\n        allocated_memory = operator_new(0x18); \n        \n        if (allocated_memory == (void *)0x0) {\n            result = 0; \n        } else {\n            \n            result = FUN_100050a0(allocated_memory, 0, '\\0', 0);\n        }\n        *param_1 = result; \n    }\n    return 2; \n}"}
{"Function Name": "FUN_10005580", "Address": "10005580", "Source Code": "\\*\nundefined4 * __thiscall FUN_10005580(void *object, exception *exception_param)\n{\n    \n    void *current_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &current_exception_list;\n    \n    \n    FUN_10005020(object, exception_param);\n    \n    \n    *(undefined ***)object = std::ios_base::failure::vftable;\n    \n    \n    ExceptionList = current_exception_list;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10005580(void *object, exception *exception_param)\n{\n    void *current_exception_list = ExceptionList;\n    ExceptionList = &current_exception_list;\n    FUN_10005020(object, exception_param);\n    *(undefined ***)object = std::ios_base::failure::vftable;\n    ExceptionList = current_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100055e0", "Address": "100055e0", "Source Code": "void __fastcall FUN_100055e0(void *param_1) \n{\n    _Locimp **localePointer; \n    _Locimp *localeInstance;   \n    int returnValue;        \n    *(undefined4 *)((int)param_1 + 0x24) = 0; \n    *(undefined4 *)((int)param_1 + 0xc) = 0;   \n    *(undefined4 *)((int)param_1 + 0x10) = 0x201; \n    *(undefined4 *)((int)param_1 + 0x14) = 6;   \n    FUN_10005480(param_1, 0, '\\0'); \n    localePointer = (_Locimp **)operator_new(4); \n    if (localePointer != (_Locimp **)0x0) { \n        localeInstance = std::locale::_Init(); \n        *localePointer = localeInstance; \n        returnValue = FUN_1000fe6e(); \n        FUN_10001820(returnValue); \n        *(_Locimp ***)((int)param_1 + 0x24) = localePointer; \n        return; \n    }\n}"}
{"Function Name": "FUN_10005a60", "Address": "10005a60", "Source Code": "void * FUN_10005a60(undefined4 input_param_1, undefined4 input_param_2, undefined4 input_param_3, undefined4 *input_param_4, undefined input_param_5)\n{\n    void *allocated_object;          \n    void *previous_exception_list;     \n    previous_exception_list = current_exception_list;           \n    current_exception_list = &previous_exception_list;          \n    allocated_object = operator_new(0x30);          \n    if (allocated_object != (void *)0x0) {          \n        FUN_10004af0(allocated_object, input_param_1, input_param_2, input_param_3, input_param_4, input_param_5); \n    }\n    current_exception_list = previous_exception_list;           \n    return allocated_object;                         \n}"}
{"Function Name": "FUN_10005b00", "Address": "10005b00", "Source Code": "\\*\nundefined4 * __thiscall\nFUN_10005b00(void *this, undefined4 param_1, undefined4 param_2, undefined4 param_3, void *param_4,\nundefined param_5)\n{\n    void *local_c; \n    local_c = ExceptionList; \n    ExceptionList = &local_c; \n    *(undefined4 *)this = param_1; \n    *(undefined4 *)((int)this + 4) = param_2; \n    *(undefined4 *)((int)this + 8) = param_3; \n    FUN_10004b70((void *)((int)this + 0x10), param_4); \n    *(undefined *)((int)this + 0x188) = param_5; \n    *(undefined *)((int)this + 0x189) = 0; \n    ExceptionList = local_c; \n    return (undefined4 *)this; \n}\n*\\ \n \nundefined4 * __thiscall\nFUN_10005b00(void *this, undefined4 param_1, undefined4 param_2, undefined4 param_3, void *param_4,\nundefined param_5)\n{\nvoid *local_c;\nlocal_c = ExceptionList;\nExceptionList = &local_c;\n*(undefined4 *)this = param_1;\n*(undefined4 *)((int)this + 4) = param_2;\n*(undefined4 *)((int)this + 8) = param_3;\nFUN_10004b70((void *)((int)this + 0x10), param_4);\n*(undefined *)((int)this + 0x188) = param_5;\n*(undefined *)((int)this + 0x189) = 0;\nExceptionList = local_c;\nreturn (undefined4 *)this;\n}"}
{"Function Name": "FUN_10007a60", "Address": "10007a60", "Source Code": "int ** __thiscall FUN_10007a60(void *objectPointer, int *inputArray, uint inputValue)\n{\n    int retrievedValue; \n    uint functionResult; \n    *(int **)objectPointer = inputArray; \n    retrievedValue = *(int *)(*(int *)(*inputArray + 4) + 0x28 + (int)inputArray); \n    if (retrievedValue != 0) { \n        FUN_100101f1((LPCRITICAL_SECTION *)(retrievedValue + 4)); \n    }\n    functionResult = FUN_100076e0(*objectPointer, inputValue); \n    *(char *)((int)objectPointer + 4) = (char)functionResult; \n    return (int **)objectPointer; \n}"}
{"Function Name": "FUN_10009c50", "Address": "10009c50", "Source Code": "void __fastcall FUN_10009c50(void *input_pointer) \n{\n    \n    process_data(input_pointer, NULL, input_pointer, (int **)**(int ***)((int)input_pointer + 4), input_pointer,\n    *(int ***)((int)input_pointer + 4));\n    \n    \n    free_memory(*(void **)((int)input_pointer + 4));\n    \n    \n    *(undefined4 *)((int)input_pointer + 4) = 0;\n    \n    \n    *(undefined4 *)((int)input_pointer + 8) = 0;\n    \n    return; \n}"}
{"Function Name": "FUN_10009c90", "Address": "10009c90", "Source Code": "void __fastcall FUN_10009c90(void *input_ptr)\n{\n    \n    process_data(input_ptr, NULL, input_ptr, (int **)**(int ***)((int)input_ptr + 4), input_ptr,\n                  *(int ***)((int)input_ptr + 4));\n    \n    \n    free_memory(*(void **)((int)input_ptr + 4));\n    \n    \n    *(undefined4 *)((int)input_ptr + 4) = 0;\n    \n    \n    *(undefined4 *)((int)input_ptr + 8) = 0;\n    \n    \n    return;\n}"}
{"Function Name": "FUN_10009db0", "Address": "10009db0", "Source Code": "int __fastcall FUN_10009db0(int input_param)\n{\n    int result;               \n    void *current_exception_list;          \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    result = function_call();  \n    *(int *)(input_param + 4) = result; \n    *(undefined *)(result + 0x189) = 1; \n    *(int *)(result + 4) = result; \n    *(int *)(result + 8) = result; \n    *(undefined4 *)(input_param + 8) = 0; \n    exception_list = current_exception_list; \n    return input_param; \n}"}
{"Function Name": "FUN_10009e20", "Address": "10009e20", "Source Code": "int __fastcall FUN_10009e20(int input_param)\n{\n    int result;                \n    void *current_exception_list;           \n    current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    result = function_call();  \n    *(int *)(input_param + 4) = result; \n    *(undefined *)(result + 0x2d) = 1; \n    *(int *)(result + 4) = result; \n    *(int *)(result + 8) = result; \n    *(undefined4 *)(input_param + 8) = 0; \n    exception_list = current_exception_list; \n    return input_param;          \n}"}
{"Function Name": "FUN_10009e90", "Address": "10009e90", "Source Code": "int __cdecl FUN_10009e90(int input_param)\n{\n    \n    void *current_exception_list = exception_list_pointer;\n    \n    \n    exception_list_pointer = &current_exception_list;\n    \n    \n    FUN_10009db0(input_param);\n    \n    \n    exception_list_pointer = current_exception_list;\n    \n    \n    return input_param;\n}"}
{"Function Name": "FUN_1000bc20", "Address": "1000bc20", "Source Code": "void __thiscall FUN_1000bc20(void *objectPointer, size_t *inputParam)\n{\n    size_t *originalParamPointer;          \n    void *originalExceptionList;          \n    originalParamPointer = inputParam;       \n    originalExceptionList = currentExceptionList; \n    currentExceptionList = &originalExceptionList; \n    \n    if (*(size_t **)(*objectPointer + 4) < inputParam) {\n        inputParam = &specificDataAddress; \n        \n        FUN_1000bbb0(&inputParam, **objectPointer, (int)originalParamPointer);\n        originalParamPointer = inputParam; \n        \n        _memcpy(inputParam + 2, *objectPointer + 2, **objectPointer);\n        inputParam = *objectPointer; \n        *(size_t **)objectPointer = originalParamPointer; \n        \n        if (inputParam != &specificDataAddress) {\n            _free(inputParam);\n        }\n    }\n    currentExceptionList = originalExceptionList; \n    return; \n}"}
{"Function Name": "FUN_1000bcc0", "Address": "1000bcc0", "Source Code": "\\*\nuint ** __thiscall FUN_1000bcc0(void *this, void *inputData, uint requestedSize)\n{\n    uint dataSize; \n    uint *allocatedMemory; \n    void *originalExceptionList; \n    originalExceptionList = ExceptionList; \n    ExceptionList = &originalExceptionList; \n    dataSize = *(uint *)(*this + 4); \n    \n    if ((dataSize < requestedSize) || (requestedSize * 3 + 0x18 < dataSize)) {\n        allocatedMemory = &DAT_10035a58; \n        if (requestedSize != 0) { \n            allocatedMemory = (uint *)operator_new((requestedSize + 0xf >> 2) * 4); \n            *allocatedMemory = requestedSize; \n            *(undefined *)((int)allocatedMemory + requestedSize + 8) = 0; \n            allocatedMemory[1] = requestedSize; \n        }\n        _memcpy(allocatedMemory + 2, inputData, requestedSize); \n        uint *currentMemoryPointer = *this; \n        *(uint **)this = allocatedMemory; \n        if (currentMemoryPointer != &DAT_10035a58) { \n            _free(currentMemoryPointer); \n        }\n    } else {\n        _memmove((void *)(*this + 8), inputData, requestedSize); \n        **this = requestedSize; \n        *(undefined *)(*this + 8 + requestedSize) = 0; \n    }\n    ExceptionList = originalExceptionList; \n    return (uint **)this; \n}\n*\\ \n \nuint ** __thiscall FUN_1000bcc0(void *this, void *inputData, uint requestedSize)\n{\n    uint dataSize;\n    uint *allocatedMemory;\n    void *originalExceptionList;\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    dataSize = *(uint *)(*this + 4);\n    if ((dataSize < requestedSize) || (requestedSize * 3 + 0x18 < dataSize)) {\n        allocatedMemory = &DAT_10035a58;\n        if (requestedSize != 0) {\n            allocatedMemory = (uint *)operator_new((requestedSize + 0xf >> 2) * 4);\n            *allocatedMemory = requestedSize;\n            *(undefined *)((int)allocatedMemory + requestedSize + 8) = 0;\n            allocatedMemory[1] = requestedSize;\n        }\n        _memcpy(allocatedMemory + 2, inputData, requestedSize);\n        uint *currentMemoryPointer = *this;\n        *(uint **)this = allocatedMemory;\n        if (currentMemoryPointer != &DAT_10035a58) {\n            _free(currentMemoryPointer);\n        }\n    } else {\n        _memmove((void *)(*this + 8), inputData, requestedSize);\n        **this = requestedSize;\n        *(undefined *)(*this + 8 + requestedSize) = 0;\n    }\n    ExceptionList = originalExceptionList;\n    return (uint **)this;\n}"}
{"Function Name": "FUN_1000bdb0", "Address": "1000bdb0", "Source Code": "\\*\nuint ** __thiscall FUN_1000bdb0(void *context, void *source, size_t size)\n{\n    int *intPtr = *context; \n    uint newSize = *intPtr + size; \n    if ((uint)intPtr[1] < newSize) { \n        FUN_1000bc20(context, (size_t *)(intPtr[1] + newSize)); \n    }\n    _memmove((void *)(**context + 8 + (int)*context), source, size); \n    **context = newSize; \n    *(undefined *)(*context + 8 + newSize) = 0; \n    return (uint **)context; \n}\n*\\ \n \nuint ** __thiscall FUN_1000bdb0(void *context, void *source, size_t size)\n{\n    int *intPtr = *context;\n    uint newSize = *intPtr + size;\n    if ((uint)intPtr[1] < newSize) {\n        FUN_1000bc20(context, (size_t *)(intPtr[1] + newSize));\n    }\n    _memmove((void *)(**context + 8 + (int)*context), source, size);\n    **context = newSize;\n    *(undefined *)(*context + 8 + newSize) = 0;\n    return (uint **)context;\n}"}
{"Function Name": "FUN_1000be60", "Address": "1000be60", "Source Code": "undefined4 __fastcall FUN_1000be60(int input_param)\n{\n    \n    int *int_pointer = *(int **)(input_param + 0x18);\n    \n    \n    while (int_pointer != (int *)0x0) {\n        \n        if ((**(code **)(*int_pointer + 0x18))() != 0) {\n            \n            return (**(code **)(*int_pointer + 0x18))();\n        }\n        \n        int_pointer = (int *)int_pointer[10];\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_1000be90", "Address": "1000be90", "Source Code": "undefined4 __fastcall FUN_1000be90(int input_param)\n{\n    \n    int *current_node = *(int **)(input_param + 0x28);\n    \n    \n    while (current_node != (int *)0x0) {\n        \n        if ((**(code **)(*current_node + 0x18))() != 0) {\n            \n            return (**(code **)(*current_node + 0x18))();\n        }\n        \n        current_node = (int *)current_node[10];\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_1000bec0", "Address": "1000bec0", "Source Code": "undefined4 __fastcall FUN_1000bec0(int *input_pointer)\n{\n    undefined4 return_value; \n    if (input_pointer != (int *)0x0) { \n        do {\n            \n            if ((**(code **)(*input_pointer + 0x10))() != 0) {\n                \n                return (**(code **)(*input_pointer + 0x10))();\n            }\n            \n            input_pointer = (int *)input_pointer[4];\n        } while (input_pointer != (int *)0x0); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_1000bef0", "Address": "1000bef0", "Source Code": "void __thiscall FUN_1000bef0(void *objectInstance, int *functionPointer)\n{\n    char returnValue; \n    \n    returnValue = (**(code **)(*functionPointer + 4))(objectInstance, -(uint)(*(uint *)((int)objectInstance + 0x4c) != (int)objectInstance + 0x2cU) & *(uint *)((int)objectInstance + 0x4c));\n    \n    \n    if (returnValue != '\\0') {\n        int *currentPointer = *(int **)((int)objectInstance + 0x18); \n        \n        \n        while (currentPointer != (int *)0x0 && (returnValue = (**(code **)(*currentPointer + 0x40))(functionPointer), returnValue != '\\0')) {\n            currentPointer = (int *)currentPointer[10]; \n        }\n    }\n    \n    \n    (**(code **)(*functionPointer + 0xc))(objectInstance);\n    return; \n}"}
{"Function Name": "FUN_1000bf50", "Address": "1000bf50", "Source Code": "int __fastcall FUN_1000bf50(int input_param)\n{\n    \n    if (*(int **)(input_param + 0x18) != (int *)0x0) {\n        \n        int function_result = (**(code **)(**(int **)(input_param + 0x18) + 0x30))();\n        \n        \n        if (function_result != 0) {\n            \n            return *(int *)(function_result + 0x20) + 8;\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_1000bf70", "Address": "1000bf70", "Source Code": "void __thiscall FUN_1000bf70(void *object, FILE *file_pointer, undefined4 undefined_param)\n{\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        __wassert(L\"cfile\", L\".\\\\tinyxml.cpp\", 0x47b);\n    }\n    \n    for (int *current_node = *(int **)((int)object + 0x18); current_node != (int *)0x0; current_node = (int *)current_node[10]) {\n        \n        (**(code **)(*current_node + 4))(file_pointer, undefined_param);\n        \n        _fprintf(file_pointer, \"\\n\");\n    }\n}"}
{"Function Name": "FUN_1000bfd0", "Address": "1000bfd0", "Source Code": "void __thiscall FUN_1000bfd0(void *context, int *functionParams)\n{\n    \n    char resultChar = (**(code **)(*functionParams + 8))(context);\n    \n    \n    if (resultChar != '\\0') {\n        \n        int *intPointer = *(int **)((int)context + 0x18);\n        \n        \n        while (intPointer != (int *)0x0 && (resultChar = (**(code **)(*intPointer + 0x40))(functionParams), resultChar != '\\0')) {\n            \n            intPointer = (int *)intPointer[10];\n        }\n    }\n    \n    \n    (**(code **)(*functionParams + 0x10))(context);\n}"}
{"Function Name": "FUN_1000c020", "Address": "1000c020", "Source Code": "void __thiscall FUN_1000c020(void *object, FILE *file_pointer, int loop_count)\n{\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        __wassert(L\"cfile\", L\".\\\\tinyxml.cpp\", 0x513);\n    }\n    \n    \n    if (loop_count > 0) {\n        \n        while (loop_count--) {\n            \n            _fprintf(file_pointer, \"    \");\n        }\n    }\n    \n    \n    _fprintf(file_pointer, \"<!--%s-->\", *(int *)((int)object + 0x20) + 8);\n}"}
{"Function Name": "FUN_1000c080", "Address": "1000c080", "Source Code": "void FUN_1000c080(int *input_pointer)\n{\n    \n    \n    \n    (*(code **)(*input_pointer + 0x18))();\n}"}
{"Function Name": "FUN_1000c0f0", "Address": "1000c0f0", "Source Code": "void FUN_1000c0f0(int *input_pointer)\n{\n    \n    \n    \n    (*(code **)(*input_pointer + 0x1c))();\n}"}
{"Function Name": "FUN_1000c110", "Address": "1000c110", "Source Code": "void FUN_1000c110(int *input_pointer)\n{\n    \n    \n    \n    (*(code **)(*input_pointer + 0x20))();\n}"}
{"Function Name": "FUN_1000c130", "Address": "1000c130", "Source Code": "void __thiscall FUN_1000c130(void *object_reference, FILE *output_file, int space_count)\n{\n    \n    if (space_count > 0) {\n        \n        do {\n            _fprintf(output_file, \"    \"); \n        } while (--space_count > 0); \n    }\n    \n    _fprintf(output_file, \"<%s>\", *(int *)((int)object_reference + 0x20) + 8); \n}"}
{"Function Name": "FUN_1000c170", "Address": "1000c170", "Source Code": "void FUN_1000c170(int *input_pointer)\n{\n    \n    (*(code **)(*input_pointer + 0x14))();\n}"}
{"Function Name": "FUN_1000c190", "Address": "1000c190", "Source Code": "int __thiscall FUN_1000c190(void *this, byte *param_1)\n{\n    byte *currentBytePtr; \n    int comparisonResult; \n    void *currentPointer = *(void **)((int)this + 0x20); \n    \n    while (currentPointer != this) {\n        currentBytePtr = (byte *)(*(int *)((int)currentPointer + 0x14) + 8); \n        byte *inputBytePtr = param_1; \n        \n        while (true) {\n            byte currentByte = *currentBytePtr; \n            if (currentByte != *inputBytePtr) { \n                comparisonResult = (currentByte < *inputBytePtr) ? -1 : 1; \n                break; \n            }\n            if (currentByte == 0) { \n                comparisonResult = 0; \n                break; \n            }\n            currentByte = currentBytePtr[1]; \n            if (currentByte != inputBytePtr[1]) { \n                comparisonResult = (currentByte < inputBytePtr[1]) ? -1 : 1; \n                break; \n            }\n            currentBytePtr += 2; \n            inputBytePtr += 2; \n        }\n        if (comparisonResult == 0) { \n            return (int)currentPointer; \n        }\n        currentPointer = *(void **)((int)currentPointer + 0x20); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_1000c200", "Address": "1000c200", "Source Code": "void __fastcall FUN_1000c200(undefined4 *attributesArray)\n{\n    \n    *attributesArray = TiXmlAttribute::vftable;\n    \n    \n    attributesArray[1] = 0xffffffff;\n    \n    \n    attributesArray[2] = 0xffffffff;\n    \n    \n    attributesArray[3] = 0;\n    \n    \n    attributesArray[4] = 0;\n    \n    \n    attributesArray[5] = &dataAddress;\n    \n    \n    attributesArray[6] = &dataAddress;\n    \n    \n    attributesArray[7] = 0;\n    \n    \n    attributesArray[8] = 0;\n    \n    \n    return;\n}"}
{"Function Name": "FUN_1000c280", "Address": "1000c280", "Source Code": "void __fastcall FUN_1000c280(undefined4 *inputParams)\n{\n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    \n    if ((undefined4 *)inputParams[6] != &specificAddress) {\n        _free((undefined4 *)inputParams[6]); \n    }\n    \n    \n    if ((undefined4 *)inputParams[5] != &specificAddress) {\n        _free((undefined4 *)inputParams[5]); \n    }\n    \n    *inputParams = TiXmlBase::vftable; \n    currentExceptionList = previousExceptionList; \n    return; \n}"}
{"Function Name": "FUN_1000c4e0", "Address": "1000c4e0", "Source Code": "void __thiscall FUN_1000c4e0(void *object, undefined4 input_param)\n{\n    \n    *(undefined ***)object = TiXmlNode::vftable;\n    \n    *(undefined4 *)((int)object + 0x24) = 0;\n    \n    *(undefined4 *)((int)object + 0x20) = &data_address;\n    \n    *(undefined4 *)((int)object + 0x18) = 0;\n    \n    *(undefined4 *)((int)object + 0x14) = input_param;\n    \n    *(undefined4 *)((int)object + 0x10) = 0;\n    \n    *(undefined4 *)((int)object + 4) = 0xffffffff;\n    \n    *(undefined4 *)((int)object + 8) = 0xffffffff;\n    \n    return;\n}"}
{"Function Name": "FUN_1000c570", "Address": "1000c570", "Source Code": "void __fastcall FUN_1000c570(undefined4 *node_pointer) \n{\n    code **code_pointer; \n    uint modified_value; \n    modified_value = DAT_100345e0 ^ (uint)&stack0xffffffe8; \n    ExceptionList = ExceptionList; \n    *node_pointer = TiXmlNode::vftable; \n    undefined4 *current_element = (undefined4 *)node_pointer[6]; \n    while (current_element != (undefined4 *)0x0) { \n        code_pointer = (code **)*current_element; \n        current_element = (undefined4 *)current_element[10]; \n        (**code_pointer)(1, modified_value); \n    }\n    if ((undefined4 *)node_pointer[8] != &DAT_10035a58) { \n        _free((undefined4 *)node_pointer[8]); \n    }\n    *node_pointer = TiXmlBase::vftable; \n    return; \n}"}
{"Function Name": "FUN_1000c600", "Address": "1000c600", "Source Code": "int * __thiscall FUN_1000c600(int *parent_node, int *current_node) {\n    int **child_node_ptr; \n    int return_value; \n    int *current_child = current_node; \n    int second_return_value; \n    \n    if (current_node[4] != 0 && current_node[4] != parent_node) {\n        \n        __wassert(L\"node->parent == 0 || node->parent == this\", L\".\\\\tinyxml.cpp\", 0xbc);\n    }\n    \n    do {\n        \n        return_value = (**(code **)(*current_child + 0x10))();\n        if (return_value != 0) {\n            \n            return_value = (**(code **)(*current_child + 0x10))();\n            if (return_value != 0) goto LAB_1000c656; \n            break; \n        }\n        child_node_ptr = (int **)(current_child + 4); \n        current_child = *child_node_ptr; \n    } while (*child_node_ptr != 0); \n    \n    goto LAB_1000c6a4; \nLAB_1000c656:\n    \n    while (child_node_ptr = (int **)(current_child + 4), current_child = *child_node_ptr, *child_node_ptr != 0) {\n        \n        return_value = (**(code **)(*current_child + 0x10))();\n        if (return_value != 0) {\n            \n            return_value = (**(code **)(*current_child + 0x10))();\n            goto LAB_1000c66c; \n        }\n    }\n    \n    return_value = 0; \nLAB_1000c66c:\n    current_child = parent_node; \n    if (parent_node != 0) {\n        do {\n            \n            second_return_value = (**(code **)(*current_child + 0x10))();\n            if (second_return_value != 0) {\n                \n                second_return_value = (**(code **)(*current_child + 0x10))();\n                goto LAB_1000c688; \n            }\n            current_child = (int *)current_child[4]; \n        } while (current_child != 0); \n    }\n    \n    second_return_value = 0; \nLAB_1000c688:\n    \n    if (return_value != second_return_value) {\n        __wassert(L\"node->GetDocument() == 0 || node->GetDocument() == this->GetDocument()\", L\".\\\\tinyxml.cpp\", 0xbd);\n    }\nLAB_1000c6a4:\n    \n    if (current_node[5] != 0) {\n        current_node[4] = (int)parent_node; \n        current_node[9] = parent_node[7]; \n        current_node[10] = 0; \n        if (parent_node[7] == 0) {\n            \n            parent_node[6] = (int)current_node;\n            parent_node[7] = (int)current_node;\n            return current_node; \n        }\n        *(int **)(parent_node[7] + 0x28) = current_node; \n        parent_node[7] = (int)current_node; \n        return current_node; \n    }\n    \n    \n    (**(code **)*current_node)(1);\n    current_child = parent_node; \n    if (parent_node != 0) {\n        \n        while (return_value = (**(code **)(*current_child + 0x10))(), return_value == 0) {\n            child_node_ptr = (int **)(current_child + 4); \n            current_child = *child_node_ptr; \n            if (*child_node_ptr == 0) {\n                return 0; \n            }\n        }\n        \n        return_value = (**(code **)(*current_child + 0x10))();\n        if (return_value != 0) {\n            \n            FUN_1000e270((void *)FUN_1000bec0(parent_node), 0xf, 0, 0, 0);\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_1000c750", "Address": "1000c750", "Source Code": "void __fastcall FUN_1000c750(int input_param)\n{\n    code **function_pointer; \n    undefined4 *current_node = *(undefined4 **)(input_param + 0x18); \n    \n    while (current_node != (undefined4 *)0x0) { \n        function_pointer = (code **)*current_node; \n        current_node = (undefined4 *)current_node[10]; \n        (**function_pointer)(1); \n    }\n    \n    *(undefined4 *)(input_param + 0x18) = 0; \n    *(undefined4 *)(input_param + 0x1c) = 0; \n    \n    current_node = (undefined4 *)(input_param + 0x2c); \n    undefined4 *start_node = *(undefined4 **)(input_param + 0x4c); \n    \n    if ((start_node == current_node) || (start_node == (undefined4 *)0x0)) { \n        return; \n    }\n    \n    undefined4 *target_node = (undefined4 *)(-(uint)(start_node != current_node) & (uint)start_node); \n    \n    for (; start_node != current_node; start_node = (undefined4 *)start_node[8]) { \n        if (start_node == target_node) { \n            *(undefined4 *)(start_node[7] + 0x20) = start_node[8]; \n            *(undefined4 *)(start_node[8] + 0x1c) = start_node[7]; \n            start_node[8] = 0; \n            start_node[7] = 0; \n            goto LAB_1000c7c2; \n        }\n    }\n    \n    __wassert(L\"0\", L\".\\\\tinyxml.cpp\", 0x608); \nLAB_1000c7c2:\n    if (target_node != (undefined4 *)0x0) { \n        (**(code **)*target_node)(1); \n    }\n}"}
{"Function Name": "FUN_1000c7f0", "Address": "1000c7f0", "Source Code": "void __thiscall FUN_1000c7f0(void *this, FILE *filePointer, int indentationLevel)\n{\n    int integerValue; \n    int *childPointer; \n    \n    if (filePointer == (FILE *)0x0) {\n        \n        __wassert(L\"cfile\", L\".\\\\tinyxml.cpp\", 0x323);\n    }\n    \n    \n    if (indentationLevel > 0) {\n        do {\n            _fprintf(filePointer, \"    \"); \n        } while (--indentationLevel > 0); \n    }\n    \n    _fprintf(filePointer, \"<%s\", *(int *)((int)this + 0x20) + 8);\n    childPointer = *(int **)((int)this + 0x4c); \n    \n    \n    if (childPointer != (int *)((int)this + 0x2c)) {\n        do {\n            if (childPointer == (int *)0x0) break; \n            _fprintf(filePointer, \" \"); \n            \n            (**(code **)(*childPointer + 4))(filePointer, indentationLevel);\n            childPointer = (int *)childPointer[8]; \n        } while ((*(int *)childPointer[6] != 0) || (*(int *)childPointer[5] != 0)); \n    }\n    \n    childPointer = *(int **)((int)this + 0x18); \n    if (childPointer != (int *)0x0) {\n        _fprintf(filePointer, \">\"); \n        \n        if (childPointer == *(int **)((int)this + 0x1c) && (**(code **)(*childPointer + 0x2c))() != 0) {\n            \n            (**(code **)(**(int **)((int)this + 0x18) + 4))(filePointer, indentationLevel + 1);\n        } else {\n            do {\n                \n                if ((**(code **)(*childPointer + 0x2c))() == 0) {\n                    _fprintf(filePointer, \"\\n\");\n                }\n                \n                (**(code **)(*childPointer + 4))(filePointer, indentationLevel + 1);\n                childPointer = (int *)childPointer[10]; \n            } while (childPointer != (int *)0x0); \n        }\n        _fprintf(filePointer, \"\\n\"); \n        \n        \n        if (indentationLevel > 0) {\n            do {\n                _fprintf(filePointer, \"    \"); \n            } while (--indentationLevel > 0); \n        }\n    }\n    \n    \n    _fprintf(filePointer, \"</%s>\", *(int *)((int)this + 0x20) + 8);\n}"}
{"Function Name": "FUN_1000c980", "Address": "1000c980", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000c980(undefined4 *input_pointer)\n{\n    void *previous_exception_list; \n    previous_exception_list = ExceptionList; \n    ExceptionList = &previous_exception_list; \n    FUN_1000c4e0(input_pointer, 0); \n    *input_pointer = TiXmlDocument::vftable; \n    input_pointer[0xd] = &DAT_10035a58; \n    input_pointer[0x10] = 0xffffffff; \n    input_pointer[0xf] = 0xffffffff; \n    input_pointer[0xe] = 4; \n    *(undefined *)(input_pointer + 0x11) = 0; \n    *(undefined *)(input_pointer + 0xb) = 0; \n    input_pointer[0xc] = 0; \n    FUN_1000bcc0(input_pointer + 0xd, &PTR_1002bc68, 0); \n    input_pointer[0x10] = 0; \n    input_pointer[0xf] = 0; \n    ExceptionList = previous_exception_list; \n    return input_pointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000c980(undefined4 *input_pointer)\n{\nvoid *previous_exception_list;\nprevious_exception_list = ExceptionList;\nExceptionList = &previous_exception_list;\nFUN_1000c4e0(input_pointer, 0);\n*input_pointer = TiXmlDocument::vftable;\ninput_pointer[0xd] = &DAT_10035a58;\ninput_pointer[0x10] = 0xffffffff;\ninput_pointer[0xf] = 0xffffffff;\ninput_pointer[0xe] = 4;\n*(undefined *)(input_pointer + 0x11) = 0;\n*(undefined *)(input_pointer + 0xb) = 0;\ninput_pointer[0xc] = 0;\nFUN_1000bcc0(input_pointer + 0xd, &PTR_1002bc68, 0);\ninput_pointer[0x10] = 0;\ninput_pointer[0xf] = 0;\nExceptionList = previous_exception_list;\nreturn input_pointer;\n}"}
{"Function Name": "FUN_1000cad0", "Address": "1000cad0", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000cad0(void *param_1)\n{\n    undefined4 *allocatedMemoryPointer; \n    void *originalExceptionList; \n    originalExceptionList = ExceptionList; \n    ExceptionList = &originalExceptionList; \n    allocatedMemoryPointer = (undefined4 *)operator_new(0x48); \n    if (allocatedMemoryPointer != (undefined4 *)0x0) { \n        allocatedMemoryPointer = FUN_1000c980(allocatedMemoryPointer); \n    }\n    if (allocatedMemoryPointer == (undefined4 *)0x0) { \n        ExceptionList = originalExceptionList; \n        return (undefined4 *)0x0; \n    }\n    FUN_1000ca30(param_1, (int)allocatedMemoryPointer); \n    ExceptionList = originalExceptionList; \n    return allocatedMemoryPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000cad0(void *param_1)\n{\n    undefined4 *allocatedMemoryPointer;\n    void *originalExceptionList;\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    allocatedMemoryPointer = (undefined4 *)operator_new(0x48);\n    if (allocatedMemoryPointer != (undefined4 *)0x0) {\n        allocatedMemoryPointer = FUN_1000c980(allocatedMemoryPointer);\n    }\n    if (allocatedMemoryPointer == (undefined4 *)0x0) {\n        ExceptionList = originalExceptionList;\n        return (undefined4 *)0x0;\n    }\n    FUN_1000ca30(param_1, (int)allocatedMemoryPointer);\n    ExceptionList = originalExceptionList;\n    return allocatedMemoryPointer;\n}"}
{"Function Name": "FUN_1000cd20", "Address": "1000cd20", "Source Code": "void __thiscall FUN_1000cd20(void *this, FILE *inputFile, int count)\n{\n    FILE *filePointer = inputFile; \n    uint uVar1 = DAT_100345e0 ^ (uint)&stack0xffffffe8; \n    void *exceptionListBackup = ExceptionList; \n    ExceptionList = &exceptionListBackup; \n    if (inputFile == (FILE *)0x0) { \n        __wassert(L\"cfile\", L\".\\\\tinyxml.cpp\", 0x536); \n    }\n    if (*(char *)((int)this + 0x2c) != '\\0') { \n        _fprintf(filePointer, \"\\n\", uVar1); \n        if (count > 0) { \n            for (int loopCounter = count; loopCounter > 0; loopCounter--) { \n                _fprintf(filePointer, \"    \", uVar1); \n            }\n        }\n        _fprintf(filePointer, \"<![CDATA[%s]]>\\n\", *(int *)((int)this + 0x20) + 8); \n        ExceptionList = exceptionListBackup; \n        return; \n    }\n    inputFile = (FILE *)&DAT_10035a58; \n    FUN_1000c300((uint **)((int)this + 0x20), &inputFile); \n    _fprintf(filePointer, \"%s\", &inputFile->_base); \n    if (inputFile != (FILE *)&DAT_10035a58) { \n        _free(inputFile); \n    }\n    ExceptionList = exceptionListBackup; \n    return; \n}"}
{"Function Name": "FUN_1000ce50", "Address": "1000ce50", "Source Code": "void __thiscall FUN_1000ce50(void *context, FILE *output_file, undefined4 version_info, void *output_buffer)\n{\n    \n    if (output_file != (FILE *)0x0) {\n        \n        _fprintf(output_file, \"<?xml \");\n    }\n    \n    if (output_buffer != (void *)0x0) {\n        \n        FUN_1000bdb0(output_buffer, \"<?xml \", 6);\n    }\n    \n    if (**(int **)((int)context + 0x2c) != 0) {\n        \n        if (output_file != (FILE *)0x0) {\n            _fprintf(output_file, \"version=\\\"%s\\\" \", *(int **)((int)context + 0x2c) + 2);\n        }\n        \n        if (output_buffer != (void *)0x0) {\n            FUN_1000bdb0(output_buffer, \"version=\\\"\", 9);\n            FUN_1000bdb0(output_buffer, *(size_t **)((int)context + 0x2c) + 2, **(size_t **)((int)context + 0x2c));\n            FUN_1000bdb0(output_buffer, &standalone_data, 2);\n        }\n    }\n    \n    if (**(int **)((int)context + 0x30) != 0) {\n        \n        if (output_file != (FILE *)0x0) {\n            _fprintf(output_file, \"encoding=\\\"%s\\\" \", *(int **)((int)context + 0x30) + 2);\n        }\n        \n        if (output_buffer != (void *)0x0) {\n            FUN_1000bdb0(output_buffer, \"encoding=\\\"\", 10);\n            FUN_1000bdb0(output_buffer, *(size_t **)((int)context + 0x30) + 2, **(size_t **)((int)context + 0x30));\n            FUN_1000bdb0(output_buffer, &standalone_data, 2);\n        }\n    }\n    \n    if (**(int **)((int)context + 0x34) != 0) {\n        \n        if (output_file != (FILE *)0x0) {\n            _fprintf(output_file, \"standalone=\\\"%s\\\" \", *(int **)((int)context + 0x34) + 2);\n        }\n        \n        if (output_buffer != (void *)0x0) {\n            FUN_1000bdb0(output_buffer, \"standalone=\\\"\", 0xc);\n            FUN_1000bdb0(output_buffer, *(size_t **)((int)context + 0x34) + 2, **(size_t **)((int)context + 0x34));\n            FUN_1000bdb0(output_buffer, &standalone_data, 2);\n        }\n    }\n    \n    if (output_file != (FILE *)0x0) {\n        _fprintf(output_file, \"?>\");\n    }\n    \n    if (output_buffer != (void *)0x0) {\n        FUN_1000bdb0(output_buffer, &end_declaration_data, 2);\n    }\n}"}
{"Function Name": "FUN_1000d020", "Address": "1000d020", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000d020(undefined4 *input_pointer)\n{\n    void *previous_exception_list; \n    previous_exception_list = ExceptionList; \n    ExceptionList = &previous_exception_list; \n    FUN_1000c200(input_pointer); \n    input_pointer[8] = input_pointer; \n    input_pointer[7] = input_pointer; \n    ExceptionList = previous_exception_list; \n    return input_pointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000d020(undefined4 *input_pointer)\n{\nvoid *previous_exception_list;\nprevious_exception_list = ExceptionList;\nExceptionList = &previous_exception_list;\nFUN_1000c200(input_pointer);\ninput_pointer[8] = input_pointer;\ninput_pointer[7] = input_pointer;\nExceptionList = previous_exception_list;\nreturn input_pointer;\n}"}
{"Function Name": "FUN_1000d080", "Address": "1000d080", "Source Code": "void __fastcall FUN_1000d080(undefined4 *sentinel) \n{\n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    \n    if ((undefined4 *)sentinel[8] != sentinel) {\n        __wassert(L\"sentinel.next == &sentinel\",L\".\\\\tinyxml.cpp\",0x5e5); \n    }\n    \n    \n    if ((undefined4 *)sentinel[7] != sentinel) {\n        __wassert(L\"sentinel.prev == &sentinel\",L\".\\\\tinyxml.cpp\",0x5e6); \n    }\n    FUN_1000c280(sentinel); \n    currentExceptionList = previousExceptionList; \n    return; \n}"}
{"Function Name": "FUN_1000d160", "Address": "1000d160", "Source Code": "int __thiscall FUN_1000d160(void *this, byte *param_1)\n{\n    int returnValue; \n    undefined4 *allocatedMemory; \n    byte *bytePointer; \n    exceptionList = &exceptionList; \n    returnValue = FUN_1000c190(this, param_1); \n    if (returnValue == 0) { \n        allocatedMemory = (undefined4 *)operator_new(0x24); \n        returnValue = 0; \n        if (allocatedMemory != (undefined4 *)0x0) { \n            returnValue = FUN_1000c200(allocatedMemory); \n        }\n        FUN_1000d110(this, returnValue); \n        bytePointer = param_1; \n        while (*bytePointer != 0) { \n            bytePointer++; \n        }\n        FUN_1000bcc0((void *)(returnValue + 0x14), param_1, (int)bytePointer - (int)(param_1 + 1)); \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_1000d200", "Address": "1000d200", "Source Code": "size_t ** __thiscall FUN_1000d200(void *this, char *param_1)\n{\n    char *inputStringPtr = param_1; \n    while (*inputStringPtr != '\\0') { \n        inputStringPtr++; \n    }\n    int stringLength = (int)inputStringPtr - (int)(param_1 + 1); \n    if (stringLength == 0) { \n        *(undefined4 **)this = &DAT_10035a58; \n    } else {\n        longlong allocationSize = (ulonglong)(stringLength + 0xfU >> 2) * 4; \n        int *allocatedMemoryPtr = (int *)operator_new(-(uint)((int)((ulonglong)allocationSize >> 0x20) != 0) | (uint)allocationSize); \n        *(int **)this = allocatedMemoryPtr; \n        *allocatedMemoryPtr = stringLength; \n        *(undefined *)(*this + 8 + stringLength) = 0; \n        *(int *)(*this + 4) = stringLength; \n    }\n    _memcpy(*this + 2, param_1, **this); \n    return (size_t **)this; \n}"}
{"Function Name": "FUN_1000d2c0", "Address": "1000d2c0", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000d2c0(undefined4 *inputPointer)\n{\n    void *previousExceptionList; \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    FUN_1000c4e0(inputPointer, 2); \n    *inputPointer = TiXmlComment::vftable; \n    ExceptionList = previousExceptionList; \n    return inputPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000d2c0(undefined4 *inputPointer)\n{\nvoid *previousExceptionList;\npreviousExceptionList = ExceptionList;\nExceptionList = &previousExceptionList;\nFUN_1000c4e0(inputPointer, 2);\n*inputPointer = TiXmlComment::vftable;\nExceptionList = previousExceptionList;\nreturn inputPointer;\n}"}
{"Function Name": "FUN_1000d320", "Address": "1000d320", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d320(void *object, byte flag)\n{\n    void *current_exception_list = previous_exception_list; \n    previous_exception_list = &current_exception_list; \n    *(undefined ***)object = TiXmlComment::vftable; \n    call_function((undefined4 *)object); \n    if ((flag & 1) != 0) { \n        free_memory(object); \n    }\n    previous_exception_list = current_exception_list; \n    return (undefined4 *)object; \n}\n*\\ \n \nundefined4 * __thiscall FUN_1000d320(void *object, byte flag)\n{\n    void *current_exception_list = previous_exception_list;\n    previous_exception_list = &current_exception_list;\n    *(undefined ***)object = TiXmlComment::vftable;\n    call_function((undefined4 *)object);\n    if ((flag & 1) != 0) {\n        free_memory(object);\n    }\n    previous_exception_list = current_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_1000d380", "Address": "1000d380", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d380(void *object, char *inputString)\n{\n    char *currentChar;\n    \n    ExceptionList = &ExceptionList;\n    \n    FUN_1000c4e0(object, 4);\n    \n    *(undefined ***)object = TiXmlText::vftable;\n    \n    currentChar = inputString;\n    \n    while (*currentChar != '\\0') {\n        currentChar++; \n    }\n    \n    FUN_1000bcc0((void *)((int)object + 0x20), inputString, (int)currentChar - (int)(inputString + 1));\n    \n    *(undefined *)((int)object + 0x2c) = 0;\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_1000d380(void *object, char *inputString)\n{\n    char *currentChar;\n    ExceptionList = &ExceptionList;\n    FUN_1000c4e0(object, 4);\n    *(undefined ***)object = TiXmlText::vftable;\n    currentChar = inputString;\n    while (*currentChar != '\\0') {\n        currentChar++;\n    }\n    FUN_1000bcc0((void *)((int)object + 0x20), inputString, (int)currentChar - (int)(inputString + 1));\n    *(undefined *)((int)object + 0x2c) = 0;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_1000d400", "Address": "1000d400", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d400(void *object, byte flag)\n{\n    void *current_exception_list; \n    \n    current_exception_list = original_exception_list; \n    original_exception_list = &current_exception_list; \n    *(undefined ***)object = TiXmlText::vftable; \n    call_function((undefined4 *)object); \n    \n    if ((flag & 1) != 0) { \n        free_memory(object); \n    }\n    \n    original_exception_list = current_exception_list; \n    return (undefined4 *)object; \n}\n*\\ \n \nundefined4 * __thiscall FUN_1000d400(void *object, byte flag)\n{\n    void *current_exception_list;\n    \n    current_exception_list = original_exception_list;\n    original_exception_list = &current_exception_list;\n    *(undefined ***)object = TiXmlText::vftable;\n    call_function((undefined4 *)object);\n    if ((flag & 1) != 0) {\n        free_memory(object);\n    }\n    original_exception_list = current_exception_list;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_1000d460", "Address": "1000d460", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000d460(undefined4 *inputPointer)\n{\n    void *previousExceptionList; \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    FUN_1000c4e0(inputPointer, 5); \n    *inputPointer = TiXmlDeclaration::vftable; \n    inputPointer[0xb] = &DAT_10035a58; \n    inputPointer[0xc] = &DAT_10035a58; \n    inputPointer[0xd] = &DAT_10035a58; \n    ExceptionList = previousExceptionList; \n    return inputPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000d460(undefined4 *inputPointer)\n{\nvoid *previousExceptionList;\npreviousExceptionList = ExceptionList;\nExceptionList = &previousExceptionList;\nFUN_1000c4e0(inputPointer, 5);\n*inputPointer = TiXmlDeclaration::vftable;\ninputPointer[0xb] = &DAT_10035a58;\ninputPointer[0xc] = &DAT_10035a58;\ninputPointer[0xd] = &DAT_10035a58;\nExceptionList = previousExceptionList;\nreturn inputPointer;\n}"}
{"Function Name": "FUN_1000d4d0", "Address": "1000d4d0", "Source Code": "void __fastcall FUN_1000d4d0(undefined4 *arguments) \n{\n    void *currentExceptionList; \n    currentExceptionList = exceptionListPointer; \n    exceptionListPointer = &currentExceptionList; \n    *arguments = TiXmlDeclaration::vftable; \n    \n    if ((undefined4 *)arguments[0xd] != &specificDataAddress) {\n        _free((undefined4 *)arguments[0xd]); \n    }\n    \n    \n    if ((undefined4 *)arguments[0xc] != &specificDataAddress) {\n        _free((undefined4 *)arguments[0xc]); \n    }\n    \n    \n    if ((undefined4 *)arguments[0xb] != &specificDataAddress) {\n        _free((undefined4 *)arguments[0xb]); \n    }\n    FUN_1000c570(arguments); \n    exceptionListPointer = currentExceptionList; \n    return; \n}"}
{"Function Name": "FUN_1000d590", "Address": "1000d590", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000d590(undefined4 *inputPointer)\n{\n    void *currentExceptionList; \n    currentExceptionList = ExceptionList; \n    ExceptionList = &currentExceptionList; \n    FUN_1000c4e0(inputPointer, 3); \n    *inputPointer = TiXmlUnknown::vftable; \n    ExceptionList = currentExceptionList; \n    return inputPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000d590(undefined4 *inputPointer)\n{\n    void *currentExceptionList;\n    currentExceptionList = ExceptionList;\n    ExceptionList = &currentExceptionList;\n    FUN_1000c4e0(inputPointer, 3);\n    *inputPointer = TiXmlUnknown::vftable;\n    ExceptionList = currentExceptionList;\n    return inputPointer;\n}"}
{"Function Name": "FUN_1000d5f0", "Address": "1000d5f0", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d5f0(void *object_pointer, byte flags)\n{\n    void *current_exception_list = ExceptionList; \n    ExceptionList = &current_exception_list; \n    *(undefined ***)object_pointer = TiXmlUnknown::vftable; \n    FUN_1000c570((undefined4 *)object_pointer); \n    if ((flags & 1) != 0) { \n        _free(object_pointer); \n    }\n    ExceptionList = current_exception_list; \n    return (undefined4 *)object_pointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_1000d5f0(void *object_pointer, byte flags)\n{\n    void *current_exception_list = ExceptionList;\n    ExceptionList = &current_exception_list;\n    *(undefined ***)object_pointer = TiXmlUnknown::vftable;\n    FUN_1000c570((undefined4 *)object_pointer);\n    if ((flags & 1) != 0) {\n        _free(object_pointer);\n    }\n    ExceptionList = current_exception_list;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FUN_1000d650", "Address": "1000d650", "Source Code": "void __fastcall FUN_1000d650(undefined4 *document_params) \n{\n    void *previous_exception_list; \n    previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    *document_params = TiXmlDocument::vftable; \n    if ((undefined4 *)document_params[0xd] != &specific_address) { \n        free_memory((undefined4 *)document_params[0xd]); \n    }\n    another_function(document_params); \n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_1000d700", "Address": "1000d700", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000d700(void *this, char *inputString)\n{\n    char currentChar; \n    char *inputStringPtr; \n    exceptionList = &exceptionList; \n    FUN_1000c4e0(this, 1); \n    *(undefined ***)this = TiXmlElement::vftable; \n    FUN_1000d020((undefined4 *)((int)this + 0x2c)); \n    *(undefined4 *)((int)this + 0x1c) = 0; \n    *(undefined4 *)((int)this + 0x18) = 0; \n    inputStringPtr = inputString; \n    do {\n        currentChar = *inputStringPtr; \n        inputStringPtr++; \n    } while (currentChar != '\\0'); \n    FUN_1000bcc0((void *)((int)this + 0x20), inputString, (int)inputStringPtr - (int)(inputString + 1)); \n    return (undefined4 *)this; \n}\n*\\ \n \nundefined4 * __thiscall FUN_1000d700(void *this, char *inputString)\n{\n    char currentChar;\n    char *inputStringPtr;\n    exceptionList = &exceptionList;\n    FUN_1000c4e0(this, 1);\n    *(undefined ***)this = TiXmlElement::vftable;\n    FUN_1000d020((undefined4 *)((int)this + 0x2c));\n    *(undefined4 *)((int)this + 0x1c) = 0;\n    *(undefined4 *)((int)this + 0x18) = 0;\n    inputStringPtr = inputString;\n    do {\n        currentChar = *inputStringPtr;\n        inputStringPtr++;\n    } while (currentChar != '\\0');\n    FUN_1000bcc0((void *)((int)this + 0x20), inputString, (int)inputStringPtr - (int)(inputString + 1));\n    return (undefined4 *)this;\n}"}
{"Function Name": "FUN_1000d7a0", "Address": "1000d7a0", "Source Code": "void __fastcall FUN_1000d7a0(undefined4 *element_pointer)\n{\n    void *current_exception_list = ExceptionList; \n    ExceptionList = &current_exception_list; \n    *element_pointer = TiXmlElement::vftable; \n    FUN_1000c750((int)element_pointer); \n    FUN_1000d080(element_pointer + 0xb); \n    FUN_1000c570(element_pointer); \n    ExceptionList = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_1000d8e0", "Address": "1000d8e0", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000d8e0(void *param_1)\n{\n    void *allocatedObject; \n    undefined4 *resultPointer; \n    void *previousExceptionList; \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    allocatedObject = operator_new(0x50); \n    if (allocatedObject == (void *)0x0) { \n        resultPointer = (undefined4 *)0x0; \n    }\n    else {\n        \n        resultPointer = FUN_1000d700(allocatedObject, (char *)(*(int *)((int)param_1 + 0x20) + 8));\n    }\n    if (resultPointer == (undefined4 *)0x0) { \n        ExceptionList = previousExceptionList; \n        return (undefined4 *)0x0; \n    }\n    \n    FUN_1000d810(param_1, (int)resultPointer);\n    ExceptionList = previousExceptionList; \n    return resultPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000d8e0(void *param_1)\n{\n    void *allocatedObject;\n    undefined4 *resultPointer;\n    void *previousExceptionList;\n    previousExceptionList = ExceptionList;\n    ExceptionList = &previousExceptionList;\n    allocatedObject = operator_new(0x50);\n    if (allocatedObject == (void *)0x0) {\n        resultPointer = (undefined4 *)0x0;\n    }\n    else {\n        resultPointer = FUN_1000d700(allocatedObject, (char *)(*(int *)((int)param_1 + 0x20) + 8));\n    }\n    if (resultPointer == (undefined4 *)0x0) {\n        ExceptionList = previousExceptionList;\n        return (undefined4 *)0x0;\n    }\n    FUN_1000d810(param_1, (int)resultPointer);\n    ExceptionList = previousExceptionList;\n    return resultPointer;\n}"}
{"Function Name": "FUN_1000d970", "Address": "1000d970", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000d970(int param_1)\n{\n    char currentChar; \n    undefined4 *allocatedMemoryPtr; \n    char *stringTraversalPtr; \n    char *stringStartPtr; \n    void *originalExceptionList; \n    originalExceptionList = ExceptionList; \n    ExceptionList = &originalExceptionList; \n    allocatedMemoryPtr = (undefined4 *)operator_new(0x2c); \n    if (allocatedMemoryPtr == (undefined4 *)0x0) { \n        ExceptionList = originalExceptionList; \n        return (undefined4 *)0x0; \n    }\n    allocatedMemoryPtr = FUN_1000d2c0(allocatedMemoryPtr); \n    if (allocatedMemoryPtr == (undefined4 *)0x0) { \n        ExceptionList = originalExceptionList; \n        return (undefined4 *)0x0; \n    }\n    stringStartPtr = (char *)(*(int *)(param_1 + 0x20) + 8); \n    stringTraversalPtr = stringStartPtr; \n    do {\n        currentChar = *stringTraversalPtr; \n        stringTraversalPtr = stringTraversalPtr + 1; \n    } while (currentChar != '\\0'); \n    FUN_1000bcc0(allocatedMemoryPtr + 8, stringStartPtr, (int)stringTraversalPtr - (*(int *)(param_1 + 0x20) + 9)); \n    allocatedMemoryPtr[3] = *(undefined4 *)(param_1 + 0xc); \n    allocatedMemoryPtr[1] = *(undefined4 *)(param_1 + 4); \n    allocatedMemoryPtr[2] = *(undefined4 *)(param_1 + 8); \n    ExceptionList = originalExceptionList; \n    return allocatedMemoryPtr; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000d970(int param_1)\n{\n    char currentChar;\n    undefined4 *allocatedMemoryPtr;\n    char *stringTraversalPtr;\n    char *stringStartPtr;\n    void *originalExceptionList;\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    allocatedMemoryPtr = (undefined4 *)operator_new(0x2c);\n    if (allocatedMemoryPtr == (undefined4 *)0x0) {\n        ExceptionList = originalExceptionList;\n        return (undefined4 *)0x0;\n    }\n    allocatedMemoryPtr = FUN_1000d2c0(allocatedMemoryPtr);\n    if (allocatedMemoryPtr == (undefined4 *)0x0) {\n        ExceptionList = originalExceptionList;\n        return (undefined4 *)0x0;\n    }\n    stringStartPtr = (char *)(*(int *)(param_1 + 0x20) + 8);\n    stringTraversalPtr = stringStartPtr;\n    do {\n        currentChar = *stringTraversalPtr;\n        stringTraversalPtr = stringTraversalPtr + 1;\n    } while (currentChar != '\\0');\n    FUN_1000bcc0(allocatedMemoryPtr + 8, stringStartPtr, (int)stringTraversalPtr - (*(int *)(param_1 + 0x20) + 9));\n    allocatedMemoryPtr[3] = *(undefined4 *)(param_1 + 0xc);\n    allocatedMemoryPtr[1] = *(undefined4 *)(param_1 + 4);\n    allocatedMemoryPtr[2] = *(undefined4 *)(param_1 + 8);\n    ExceptionList = originalExceptionList;\n    return allocatedMemoryPtr;\n}"}
{"Function Name": "FUN_1000da30", "Address": "1000da30", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000da30(void *inputParameter)\n{\n    undefined4 *resultPointer; \n    void *previousExceptionList; \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    void *allocatedMemory = operator_new(0x30); \n    \n    if (allocatedMemory == (void *)0x0) { \n        resultPointer = (undefined4 *)0x0; \n    } else {\n        resultPointer = FUN_1000d380(allocatedMemory, (char *)&PTR_1002bc68); \n    }\n    if (resultPointer == (undefined4 *)0x0) { \n        ExceptionList = previousExceptionList; \n        return (undefined4 *)0x0; \n    }\n    \n    FUN_1000c0a0(inputParameter, (int)resultPointer); \n    ExceptionList = previousExceptionList; \n    return resultPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000da30(void *inputParameter)\n{\n    undefined4 *resultPointer;\n    void *previousExceptionList;\n    previousExceptionList = ExceptionList;\n    ExceptionList = &previousExceptionList;\n    void *allocatedMemory = operator_new(0x30);\n    \n    if (allocatedMemory == (void *)0x0) {\n        resultPointer = (undefined4 *)0x0;\n    } else {\n        resultPointer = FUN_1000d380(allocatedMemory, (char *)&PTR_1002bc68);\n    }\n    if (resultPointer == (undefined4 *)0x0) {\n        ExceptionList = previousExceptionList;\n        return (undefined4 *)0x0;\n    }\n    \n    FUN_1000c0a0(inputParameter, (int)resultPointer);\n    ExceptionList = previousExceptionList;\n    return resultPointer;\n}"}
{"Function Name": "FUN_1000dac0", "Address": "1000dac0", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000dac0(void *param_1)\n{\n    undefined4 *allocatedMemoryPointer; \n    void *currentExceptionList;      \n    currentExceptionList = ExceptionList; \n    ExceptionList = &currentExceptionList; \n    allocatedMemoryPointer = (undefined4 *)operator_new(0x38); \n    \n    if (allocatedMemoryPointer == (undefined4 *)0x0) { \n        ExceptionList = currentExceptionList; \n        return (undefined4 *)0x0; \n    }\n    \n    allocatedMemoryPointer = FUN_1000d460(allocatedMemoryPointer); \n    FUN_1000cfa0(param_1, (int)allocatedMemoryPointer); \n    ExceptionList = currentExceptionList; \n    return allocatedMemoryPointer; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000dac0(void *param_1)\n{\n    undefined4 *allocatedMemoryPointer;\n    void *currentExceptionList;\n    currentExceptionList = ExceptionList;\n    ExceptionList = &currentExceptionList;\n    allocatedMemoryPointer = (undefined4 *)operator_new(0x38);\n    \n    if (allocatedMemoryPointer == (undefined4 *)0x0) {\n        ExceptionList = currentExceptionList;\n        return (undefined4 *)0x0;\n    }\n    \n    allocatedMemoryPointer = FUN_1000d460(allocatedMemoryPointer);\n    FUN_1000cfa0(param_1, (int)allocatedMemoryPointer);\n    ExceptionList = currentExceptionList;\n    return allocatedMemoryPointer;\n}"}
{"Function Name": "FUN_1000db50", "Address": "1000db50", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000db50(int param_1)\n{\n    char currentChar; \n    undefined4 *allocatedMemoryPtr; \n    char *stringIterator; \n    char *stringStartPtr; \n    void *originalExceptionList; \n    originalExceptionList = ExceptionList; \n    ExceptionList = &originalExceptionList; \n    allocatedMemoryPtr = (undefined4 *)operator_new(0x2c); \n    if (allocatedMemoryPtr == (undefined4 *)0x0) { \n        ExceptionList = originalExceptionList; \n        return (undefined4 *)0x0; \n    }\n    allocatedMemoryPtr = FUN_1000d590(allocatedMemoryPtr); \n    if (allocatedMemoryPtr == (undefined4 *)0x0) { \n        ExceptionList = originalExceptionList; \n        return (undefined4 *)0x0; \n    }\n    stringStartPtr = (char *)(*(int *)(param_1 + 0x20) + 8); \n    stringIterator = stringStartPtr; \n    do {\n        currentChar = *stringIterator; \n        stringIterator = stringIterator + 1; \n    } while (currentChar != '\\0'); \n    FUN_1000bcc0(allocatedMemoryPtr + 8, stringStartPtr, (int)stringIterator - (*(int *)(param_1 + 0x20) + 9)); \n    allocatedMemoryPtr[3] = *(undefined4 *)(param_1 + 0xc); \n    allocatedMemoryPtr[1] = *(undefined4 *)(param_1 + 4); \n    allocatedMemoryPtr[2] = *(undefined4 *)(param_1 + 8); \n    ExceptionList = originalExceptionList; \n    return allocatedMemoryPtr; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000db50(int param_1)\n{\n    char currentChar;\n    undefined4 *allocatedMemoryPtr;\n    char *stringIterator;\n    char *stringStartPtr;\n    void *originalExceptionList;\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    allocatedMemoryPtr = (undefined4 *)operator_new(0x2c);\n    if (allocatedMemoryPtr == (undefined4 *)0x0) {\n        ExceptionList = originalExceptionList;\n        return (undefined4 *)0x0;\n    }\n    allocatedMemoryPtr = FUN_1000d590(allocatedMemoryPtr);\n    if (allocatedMemoryPtr == (undefined4 *)0x0) {\n        ExceptionList = originalExceptionList;\n        return (undefined4 *)0x0;\n    }\n    stringStartPtr = (char *)(*(int *)(param_1 + 0x20) + 8);\n    stringIterator = stringStartPtr;\n    do {\n        currentChar = *stringIterator;\n        stringIterator = stringIterator + 1;\n    } while (currentChar != '\\0');\n    FUN_1000bcc0(allocatedMemoryPtr + 8, stringStartPtr, (int)stringIterator - (*(int *)(param_1 + 0x20) + 9));\n    allocatedMemoryPtr[3] = *(undefined4 *)(param_1 + 0xc);\n    allocatedMemoryPtr[1] = *(undefined4 *)(param_1 + 4);\n    allocatedMemoryPtr[2] = *(undefined4 *)(param_1 + 8);\n    ExceptionList = originalExceptionList;\n    return allocatedMemoryPtr;\n}"}
{"Function Name": "FUN_1000e300", "Address": "1000e300", "Source Code": "\\*\nbyte * __thiscall FUN_1000e300(void *context, byte *inputBuffer, int *outputBuffer, int dataSize)\n{\n    \n    int resultCode = FUN_1000bec0((int *)context);\n    \n    \n    byte *processedBuffer = FUN_1000e020(inputBuffer, dataSize);\n    \n    \n    if (outputBuffer != (int *)0x0) {\n        \n        FUN_1000dd80(outputBuffer, processedBuffer, dataSize);\n        \n        \n        *(int *)((int)context + 4) = *outputBuffer;\n        *(int *)((int)context + 8) = outputBuffer[1];\n    }\n    \n    \n    if ((processedBuffer == (byte *)0x0) || (*processedBuffer == 0) || (*processedBuffer != 0x3c)) {\n        \n        if ((resultCode != 0) && (*(char *)(resultCode + 0x2c) == '\\0')) {\n            \n            *(undefined *)(resultCode + 0x2c) = 1;\n            *(undefined4 *)(resultCode + 0x30) = 9;\n            \n            \n            char *pcVar7 = PTR_s_Error_parsing_Unknown__100344cc;\n            while (*pcVar7 != '\\0') pcVar7++;\n            \n            \n            FUN_1000bcc0((void *)(resultCode + 0x34), PTR_s_Error_parsing_Unknown__100344cc,\n                         (int)pcVar7 - (int)(PTR_s_Error_parsing_Unknown__100344cc + 1));\n            \n            \n            *(undefined4 *)(resultCode + 0x40) = 0xffffffff;\n            *(undefined4 *)(resultCode + 0x3c) = 0xffffffff;\n        }\n        \n        return (byte *)0x0;\n    }\n    \n    \n    FUN_1000bcc0((void *)((int)context + 0x20), &PTR_1002bc68, 0);\n    \n    \n    while (true) {\n        \n        byte *nextBytePtr = processedBuffer + 1;\n        \n        \n        if (nextBytePtr == (byte *)0x0) {\n            \n            if ((resultCode != 0) && (*(char *)(resultCode + 0x2c) == '\\0')) {\n                \n                *(undefined *)(resultCode + 0x2c) = 1;\n                *(undefined4 *)(resultCode + 0x30) = 9;\n                \n                \n                char *pcVar7 = PTR_s_Error_parsing_Unknown__100344cc;\n                while (*pcVar7 != '\\0') pcVar7++;\n                \n                \n                FUN_1000bcc0((void *)(resultCode + 0x34), PTR_s_Error_parsing_Unknown__100344cc,\n                             (int)pcVar7 - (int)(PTR_s_Error_parsing_Unknown__100344cc + 1));\n                \n                \n                *(undefined4 *)(resultCode + 0x40) = 0xffffffff;\n                *(undefined4 *)(resultCode + 0x3c) = 0xffffffff;\n            }\n            \n            return (byte *)0x0;\n        }\n        \n        \n        byte currentByte = *nextBytePtr;\n        \n        \n        if (currentByte == 0) break;\n        \n        \n        if (currentByte == 0x3e) return processedBuffer + 2;\n        \n        \n        uint tempData = (uint)dataSize >> 8;\n        dataSize = CONCAT31((int3)tempData, currentByte);\n        \n        \n        FUN_1000bdb0((void *)((int)context + 0x20), &dataSize, 1);\n        \n        \n        processedBuffer = nextBytePtr;\n    }\n    \n    \n    return processedBuffer;\n}\n*\\ \n \nbyte * __thiscall FUN_1000e300(void *context, byte *inputBuffer, int *outputBuffer, int dataSize)\n{\n    int resultCode = FUN_1000bec0((int *)context);\n    byte *processedBuffer = FUN_1000e020(inputBuffer, dataSize);\n    \n    if (outputBuffer != (int *)0x0) {\n        FUN_1000dd80(outputBuffer, processedBuffer, dataSize);\n        *(int *)((int)context + 4) = *outputBuffer;\n        *(int *)((int)context + 8) = outputBuffer[1];\n    }\n    \n    if ((processedBuffer == (byte *)0x0) || (*processedBuffer == 0) || (*processedBuffer != 0x3c)) {\n        if ((resultCode != 0) && (*(char *)(resultCode + 0x2c) == '\\0')) {\n            *(undefined *)(resultCode + 0x2c) = 1;\n            *(undefined4 *)(resultCode + 0x30) = 9;\n            char *pcVar7 = PTR_s_Error_parsing_Unknown__100344cc;\n            while (*pcVar7 != '\\0') pcVar7++;\n            FUN_1000bcc0((void *)(resultCode + 0x34), PTR_s_Error_parsing_Unknown__100344cc,\n                         (int)pcVar7 - (int)(PTR_s_Error_parsing_Unknown__100344cc + 1));\n            *(undefined4 *)(resultCode + 0x40) = 0xffffffff;\n            *(undefined4 *)(resultCode + 0x3c) = 0xffffffff;\n        }\n        return (byte *)0x0;\n    }\n    \n    FUN_1000bcc0((void *)((int)context + 0x20), &PTR_1002bc68, 0);\n    \n    while (true) {\n        byte *nextBytePtr = processedBuffer + 1;\n        if (nextBytePtr == (byte *)0x0) {\n            if ((resultCode != 0) && (*(char *)(resultCode + 0x2c) == '\\0')) {\n                *(undefined *)(resultCode + 0x2c) = 1;\n                *(undefined4 *)(resultCode + 0x30) = 9;\n                char *pcVar7 = PTR_s_Error_parsing_Unknown__100344cc;\n                while (*pcVar7 != '\\0') pcVar7++;\n                FUN_1000bcc0((void *)(resultCode + 0x34), PTR_s_Error_parsing_Unknown__100344cc,\n                             (int)pcVar7 - (int)(PTR_s_Error_parsing_Unknown__100344cc + 1));\n                *(undefined4 *)(resultCode + 0x40) = 0xffffffff;\n                *(undefined4 *)(resultCode + 0x3c) = 0xffffffff;\n            }\n            return (byte *)0x0;\n        }\n        \n        byte currentByte = *nextBytePtr;\n        if (currentByte == 0) break;\n        if (currentByte == 0x3e) return processedBuffer + 2;\n        \n        uint tempData = (uint)dataSize >> 8;\n        dataSize = CONCAT31((int3)tempData, currentByte);\n        FUN_1000bdb0((void *)((int)context + 0x20), &dataSize, 1);\n        processedBuffer = nextBytePtr;\n    }\n    \n    return processedBuffer;\n}"}
{"Function Name": "FUN_1000e460", "Address": "1000e460", "Source Code": "\\*\nbyte * __thiscall FUN_1000e460(void *this, byte *param_1, int *param_2, int param_3)\n{\n    int resultValue; \n    byte *processedData; \n    undefined4 checkResult; \n    char *errorMessagePtr; \n    resultValue = FUN_1000bec0((int *)this); \n    FUN_1000bcc0((void *)((int)this + 0x20), &PTR_1002bc68, 0); \n    processedData = FUN_1000e020(param_1, param_3); \n    if (param_2 != (int *)0x0) { \n        FUN_1000dd80(param_2, processedData, param_3); \n        *(int *)((int)this + 4) = *param_2; \n        *(int *)((int)this + 8) = param_2[1]; \n    }\n    \n    checkResult = FUN_1000e180((char *)processedData, \"<!--\", '\\0', param_3); \n    if ((char)checkResult == '\\0') { \n        if ((resultValue != 0) && (*(char *)(resultValue + 0x2c) == '\\0')) { \n            *(undefined *)(resultValue + 0x2c) = 1; \n            *(undefined4 *)(resultValue + 0x30) = 10; \n            errorMessagePtr = PTR_s_Error_parsing_Comment__100344d0; \n            while (*errorMessagePtr != '\\0') { \n                errorMessagePtr++; \n            }\n            FUN_1000bcc0((void *)(resultValue + 0x34), PTR_s_Error_parsing_Comment__100344d0, (int)errorMessagePtr - (int)(PTR_s_Error_parsing_Comment__100344d0 + 1)); \n            *(undefined4 *)(resultValue + 0x40) = 0xffffffff; \n            *(undefined4 *)(resultValue + 0x3c) = 0xffffffff; \n            if (param_2 != (int *)0x0) { \n                FUN_1000dd80(param_2, processedData, param_3); \n                *(int *)(resultValue + 0x3c) = *param_2; \n                *(int *)(resultValue + 0x40) = param_2[1]; \n            }\n        }\n        return (byte *)0x0; \n    }\n    while (*processedData != 0) { \n        checkResult = FUN_1000e180((char *)processedData, \"-->\", '\\0', param_3); \n        if ((char)checkResult != '\\0') { \n            if (*processedData == 0) { \n                return processedData; \n            }\n            errorMessagePtr = \"-->\"; \n            while (*errorMessagePtr != '\\0') { \n                errorMessagePtr++; \n            }\n            return processedData + (int)(errorMessagePtr + -0x1002c768); \n        }\n        FUN_1000bdb0((void *)((int)this + 0x20), processedData, 1); \n        processedData++; \n        if (processedData == (byte *)0x0) { \n            return (byte *)0x0; \n        }\n    }\n    return processedData; \n}\n*\\ \n \nbyte * __thiscall FUN_1000e460(void *this, byte *param_1, int *param_2, int param_3)\n{\n    int resultValue;\n    byte *processedData;\n    undefined4 checkResult;\n    char *errorMessagePtr;\n    resultValue = FUN_1000bec0((int *)this);\n    FUN_1000bcc0((void *)((int)this + 0x20), &PTR_1002bc68, 0);\n    processedData = FUN_1000e020(param_1, param_3);\n    \n    if (param_2 != (int *)0x0) {\n        FUN_1000dd80(param_2, processedData, param_3);\n        *(int *)((int)this + 4) = *param_2;\n        *(int *)((int)this + 8) = param_2[1];\n    }\n    \n    checkResult = FUN_1000e180((char *)processedData, \"<!--\", '\\0', param_3);\n    if ((char)checkResult == '\\0') {\n        if ((resultValue != 0) && (*(char *)(resultValue + 0x2c) == '\\0')) {\n            *(undefined *)(resultValue + 0x2c) = 1;\n            *(undefined4 *)(resultValue + 0x30) = 10;\n            errorMessagePtr = PTR_s_Error_parsing_Comment__100344d0;\n            while (*errorMessagePtr != '\\0') {\n                errorMessagePtr++;\n            }\n            FUN_1000bcc0((void *)(resultValue + 0x34), PTR_s_Error_parsing_Comment__100344d0, (int)errorMessagePtr - (int)(PTR_s_Error_parsing_Comment__100344d0 + 1));\n            *(undefined4 *)(resultValue + 0x40) = 0xffffffff;\n            *(undefined4 *)(resultValue + 0x3c) = 0xffffffff;\n            if (param_2 != (int *)0x0) {\n                FUN_1000dd80(param_2, processedData, param_3);\n                *(int *)(resultValue + 0x3c) = *param_2;\n                *(int *)(resultValue + 0x40) = param_2[1];\n            }\n        }\n        return (byte *)0x0;\n    }\n    while (*processedData != 0) {\n        checkResult = FUN_1000e180((char *)processedData, \"-->\", '\\0', param_3);\n        if ((char)checkResult != '\\0') {\n            if (*processedData == 0) {\n                return processedData;\n            }\n            errorMessagePtr = \"-->\";\n            while (*errorMessagePtr != '\\0') {\n                errorMessagePtr++;\n            }\n            return processedData + (int)(errorMessagePtr + -0x1002c768);\n        }\n        FUN_1000bdb0((void *)((int)this + 0x20), processedData, 1);\n        processedData++;\n        if (processedData == (byte *)0x0) {\n            return (byte *)0x0;\n        }\n    }\n    return processedData;\n}"}
{"Function Name": "FUN_1000e5c0", "Address": "1000e5c0", "Source Code": "undefined4 __fastcall FUN_1000e5c0(int input_param) \n{\n    byte byte_value; \n    uint counter = 0; \n    int *int_array_pointer = *(int **)(input_param + 0x20); \n    if (*int_array_pointer != 0) { \n        do {\n            \n            if (**(uint **)(input_param + 0x20) <= counter) {\n                __wassert(L\"index < length()\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinystr.h\", 0x9c);\n            }\n            \n            byte_value = *(byte *)(*(int *)(input_param + 0x20) + 8 + counter);\n            \n            if (!(_isspace((uint)byte_value) || byte_value == 10 || byte_value == 0xd)) {\n                return 0; \n            }\n            counter++; \n        } while (counter < **(uint **)(input_param + 0x20)); \n    }\n    \n    return CONCAT31((int3)((uint)int_array_pointer >> 8), 1);\n}"}
{"Function Name": "FUN_1000e630", "Address": "1000e630", "Source Code": "\\*\nundefined4 * __thiscall\nFUN_1000e630(void *this, int param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4)\n{\n    \n    if (param_1 == 0) {\n        __wassert(L\"start\", L\".\\\\tinyxmlparser.cpp\", 0xb7);\n    }\n    \n    \n    *(int *)((int)this + 8) = param_1;\n    \n    \n    *(undefined4 *)((int)this + 0xc) = param_2;\n    \n    \n    *(undefined4 *)this = param_3;\n    \n    \n    *(undefined4 *)((int)this + 4) = param_4;\n    \n    \n    return (undefined4 *)this;\n}\n*\\ \n \nundefined4 * __thiscall\nFUN_1000e630(void *this, int param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4)\n{\n    if (param_1 == 0) {\n        __wassert(L\"start\", L\".\\\\tinyxmlparser.cpp\", 0xb7);\n    }\n    *(int *)((int)this + 8) = param_1;\n    *(undefined4 *)((int)this + 0xc) = param_2;\n    *(undefined4 *)this = param_3;\n    *(undefined4 *)((int)this + 4) = param_4;\n    return (undefined4 *)this;\n}"}
{"Function Name": "FUN_1000e680", "Address": "1000e680", "Source Code": "char * __cdecl FUN_1000e680(char *inputString,char *outputChar,int *successFlag,int conditionFlag)\n{\n    char currentChar; \n    char *charPointer; \n    int index; \n    uint convertedValue; \n    index = 0; \n    *successFlag = 0; \n    currentChar = inputString[1]; \n    if ((currentChar != '\\0') && (currentChar == '#')) { \n        if (inputString[2] != '\\0') { \n            convertedValue = 0; \n            index = 1; \n            if (inputString[2] == 'x') { \n                if (((inputString[3] != '\\0') && (charPointer = _strchr(inputString + 3,0x3b), charPointer != (char *)0x0)) &&\n                    (*charPointer != '\\0')) { \n                    int length = (int)charPointer - (int)inputString; \n                    currentChar = charPointer[-1]; \n                    while (currentChar != 'x') { \n                        if ((currentChar < '0') || ('9' < currentChar)) { \n                            if ((currentChar < 'a') || ('f' < currentChar)) { \n                                if (currentChar < 'A') {\n                                    return (char *)0x0; \n                                }\n                                if ('F' < currentChar) {\n                                    return (char *)0x0; \n                                }\n                                convertedValue = convertedValue + (currentChar - 'A' - 10) * index; \n                            }\n                            else {\n                                convertedValue = convertedValue + (currentChar - 'a' - 10) * index; \n                            }\n                        }\n                        else {\n                            convertedValue = convertedValue + (currentChar - '0') * index; \n                        }\n                        index = index << 4; \n                        currentChar = charPointer[-2]; \n                        charPointer = charPointer + -1; \n                    }\n                    if (conditionFlag != 1) { \n                        *outputChar = (char)convertedValue; \n                        *successFlag = 1; \n                        return inputString + length + 1; \n                    }\n                    FUN_1000dc60(convertedValue,(int)outputChar,successFlag); \n                    return inputString + length + 1; \n                }\n            }\n            else { \n                charPointer = _strchr(inputString + 2,0x3b); \n                if ((charPointer != (char *)0x0) && (*charPointer != '\\0')) { \n                    int length = (int)charPointer - (int)inputString; \n                    currentChar = charPointer[-1]; \n                    while (currentChar != '#') { \n                        if (currentChar < '0') {\n                            return (char *)0x0; \n                        }\n                        if ('9' < currentChar) {\n                            return (char *)0x0; \n                        }\n                        convertedValue = convertedValue + (currentChar - '0') * index; \n                        index = index * 10; \n                        currentChar = charPointer[-2]; \n                        charPointer = charPointer + -1; \n                    }\n                    if (conditionFlag != 1) { \n                        *outputChar = (char)convertedValue; \n                        *successFlag = 1; \n                        return inputString + length + 1; \n                    }\n                    FUN_1000dc60(convertedValue,(int)outputChar,successFlag); \n                    return inputString + length + 1; \n                }\n            }\n        }\n        return (char *)0x0; \n    }\n    do {\n        int length = _strncmp(*(&dataPointer + index * 3),inputString,(size_t)(*(&dataPointer + index * 3 + 1))); \n        if (length == 0) { \n            charPointer = (&dataPointer)[index * 3] + 1; \n            do {\n                currentChar = *(&dataPointer)[index * 3]; \n            } while (currentChar != '\\0'); \n            *outputChar = (&outputData)[index * 0xc]; \n            *successFlag = 1; \n            return inputString + (&nextPosition)[index * 3]; \n        }\n        index++; \n    } while ((int)(&dataPointer + index * 3) < 0x10034524); \n    *outputChar = *inputString; \n    return inputString + 1; \n}"}
{"Function Name": "FUN_1000e920", "Address": "1000e920", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000e920(void *this, byte *param_1, int param_2)\n{\n    byte *bytePointer; // Pointer to a byte, used to store the result of FUN_1000e020\n    undefined4 result; // Variable to store the result of FUN_1000e180 calls\n    undefined4 *allocatedMemoryPointer; // Pointer to the allocated memory for the return value\n    void *memoryPointer; // Pointer for memory allocation\n    int secondCharacterCheck; // Variable to store the result of FUN_1000dd60\n    void *originalExceptionList; // Local variable to store the original ExceptionList\n\n    originalExceptionList = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &originalExceptionList; // Update ExceptionList to point to local_c\n    bytePointer = FUN_1000e020(param_1, param_2); // Call FUN_1000e020 with parameters\n\n    // Check if pbVar1 is null or does not start with '<'\n    if (bytePointer == (byte *)0x0 || *bytePointer == 0 || *bytePointer != 0x3c) {\n        ExceptionList = originalExceptionList; // Restore the original ExceptionList\n        return (undefined4 *)0x0; // Return null if the checks fail\n    }\n\n    // Check for XML declaration \"<?xml\"\n    result = FUN_1000e180((char *)bytePointer, \"<?xml\", '\\x01', param_2);\n    if ((char)result == '\\0') {\n        // Check for comment \"<!--\"\n        result = FUN_1000e180((char *)bytePointer, \"<!--\", '\\0', param_2);\n        if ((char)result == '\\0') {\n            // Check for CDATA section \"<![CDATA[\"\n            result = FUN_1000e180((char *)bytePointer, \"<![CDATA[\", '\\0', param_2);\n            if ((char)result != '\\0') {\n                memoryPointer = operator_new(0x30); // Allocate memory\n                if (memoryPointer != (void *)0x0) {\n                    allocatedMemoryPointer = FUN_1000d380(memoryPointer, (char *)&PTR_1002bc68); // Initialize allocated memory\n                    *(undefined *)(allocatedMemoryPointer + 0xb) = 1; // Set a specific field in the structure\n                    goto LAB_1000eb11; // Jump to the cleanup and return section\n                }\n                return (undefined4 *)0x0; // Return null if memory allocation fails\n            }\n            // Check for processing instruction \"<!\"\n            result = FUN_1000e180((char *)bytePointer, \"<!\", '\\0', param_2);\n            if ((char)result == '\\0') {\n                secondCharacterCheck = FUN_1000dd60(bytePointer[1]); // Check the second character after '<'\n                if (secondCharacterCheck == 0 && bytePointer[1] != 0x5f) {\n                    allocatedMemoryPointer = (undefined4 *)operator_new(0x2c); // Allocate memory for a specific structure\n                    if (allocatedMemoryPointer != (undefined4 *)0x0) {\n                        allocatedMemoryPointer = FUN_1000d590(allocatedMemoryPointer); // Initialize the allocated memory\n                        goto LAB_1000eb11; // Jump to the cleanup and return section\n                    }\n                } else {\n                    memoryPointer = operator_new(0x50); // Allocate memory for a different structure\n                    if (memoryPointer != (void *)0x0) {\n                        allocatedMemoryPointer = FUN_1000d700(memoryPointer, (char *)&PTR_1002bc68); // Initialize the allocated memory\n                        goto LAB_1000eb11; // Jump to the cleanup and return section\n                    }\n                }\n            } else {\n                allocatedMemoryPointer = (undefined4 *)operator_new(0x2c); // Allocate memory for a specific structure\n                if (allocatedMemoryPointer != (undefined4 *)0x0) {\n                    allocatedMemoryPointer = FUN_1000d590(allocatedMemoryPointer); // Initialize the allocated memory\n                    goto LAB_1000eb11; // Jump to the cleanup and return section\n                }\n            }\n        } else {\n            allocatedMemoryPointer = (undefined4 *)operator_new(0x2c); // Allocate memory for a specific structure\n            if (allocatedMemoryPointer != (undefined4 *)0x0) {\n                allocatedMemoryPointer = FUN_1000d2c0(allocatedMemoryPointer); // Initialize the allocated memory\n                goto LAB_1000eb11; // Jump to the cleanup and return section\n            }\n        }\n    } else {\n        allocatedMemoryPointer = (undefined4 *)operator_new(0x38); // Allocate memory for a specific structure\n        if (allocatedMemoryPointer != (undefined4 *)0x0) {\n            allocatedMemoryPointer = FUN_1000d460(allocatedMemoryPointer); // Initialize the allocated memory\n            goto LAB_1000eb11; // Jump to the cleanup and return section\n        }\n    }\n    allocatedMemoryPointer = (undefined4 *)0x0; // Set puVar3 to null if no valid structure was created\nLAB_1000eb11:\n    ExceptionList = originalExceptionList; // Restore the original ExceptionList\n    if (allocatedMemoryPointer == (undefined4 *)0x0) {\n        return (undefined4 *)0x0; // Return null if puVar3 is null\n    }\n    allocatedMemoryPointer[4] = this; // Store 'this' pointer in the allocated structure\n    return allocatedMemoryPointer; // Return the pointer to the allocated structure\n}\n*\\ \n \n\nundefined4 * __thiscall FUN_1000e920(void *this, byte *param_1, int param_2)\n{\n    byte *bytePointer;\n    undefined4 result;\n    undefined4 *allocatedMemoryPointer;\n    void *memoryPointer;\n    int secondCharacterCheck;\n    void *originalExceptionList;\n\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    bytePointer = FUN_1000e020(param_1, param_2);\n    if (bytePointer == (byte *)0x0 || *bytePointer == 0 || *bytePointer != 0x3c) {\n        ExceptionList = originalExceptionList;\n        return (undefined4 *)0x0;\n    }\n    result = FUN_1000e180((char *)bytePointer, \"<?xml\", '\\x01', param_2);\n    if ((char)result == '\\0') {\n        result = FUN_1000e180((char *)bytePointer, \"<!--\", '\\0', param_2);\n        if ((char)result == '\\0') {\n            result = FUN_1000e180((char *)bytePointer, \"<![CDATA[\", '\\0', param_2);\n            if ((char)result != '\\0') {\n                memoryPointer = operator_new(0x30);\n                if (memoryPointer != (void *)0x0) {\n                    allocatedMemoryPointer = FUN_1000d380(memoryPointer, (char *)&PTR_1002bc68);\n                    *(undefined *)(allocatedMemoryPointer + 0xb) = 1;\n                    goto LAB_1000eb11;\n                }\n                return (undefined4 *)0x0;\n            }\n            result = FUN_1000e180((char *)bytePointer, \"<!\", '\\0', param_2);\n            if ((char)result == '\\0') {\n                secondCharacterCheck = FUN_1000dd60(bytePointer[1]);\n                if (secondCharacterCheck == 0 && bytePointer[1] != 0x5f) {\n                    allocatedMemoryPointer = (undefined4 *)operator_new(0x2c);\n                    if (allocatedMemoryPointer != (undefined4 *)0x0) {\n                        allocatedMemoryPointer = FUN_1000d590(allocatedMemoryPointer);\n                        goto LAB_1000eb11;\n                    }\n                } else {\n                    memoryPointer = operator_new(0x50);\n                    if (memoryPointer != (void *)0x0) {\n                        allocatedMemoryPointer = FUN_1000d700(memoryPointer, (char *)&PTR_1002bc68);\n                        goto LAB_1000eb11;\n                    }\n                }\n            } else {\n                allocatedMemoryPointer = (undefined4 *)operator_new(0x2c);\n                if (allocatedMemoryPointer != (undefined4 *)0x0) {\n                    allocatedMemoryPointer = FUN_1000d590(allocatedMemoryPointer);\n                    goto LAB_1000eb11;\n                }\n            }\n        } else {\n            allocatedMemoryPointer = (undefined4 *)operator_new(0x2c);\n            if (allocatedMemoryPointer != (undefined4 *)0x0) {\n                allocatedMemoryPointer = FUN_1000d2c0(allocatedMemoryPointer);\n                goto LAB_1000eb11;\n            }\n        }\n    } else {\n        allocatedMemoryPointer = (undefined4 *)operator_new(0x38);\n        if (allocatedMemoryPointer != (undefined4 *)0x0) {\n            allocatedMemoryPointer = FUN_1000d460(allocatedMemoryPointer);\n            goto LAB_1000eb11;\n        }\n    }\n    allocatedMemoryPointer = (undefined4 *)0x0;\nLAB_1000eb11:\n    ExceptionList = originalExceptionList;\n    if (allocatedMemoryPointer == (undefined4 *)0x0) {\n        return (undefined4 *)0x0;\n    }\n    allocatedMemoryPointer[4] = this;\n    return allocatedMemoryPointer;\n}\n"}
{"Function Name": "FUN_1000ece0", "Address": "1000ece0", "Source Code": "\\*\nbyte * __cdecl FUN_1000ece0(byte *input_bytes, byte *output_bytes, int *length, int condition)\n{\n    int value;\n    \n    if (input_bytes == (byte *)0x0) {\n        \n        __wassert(L\"p\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinyxml.h\", 0x149);\n    }\n    \n    \n    if (condition == 1) {\n        \n        value = *(int *)(&DAT_1002ca50 + (uint)*input_bytes * 4);\n        *length = value;\n        \n        if ((value < 0) || (4 < value)) {\n            __wassert(L\"*length >= 0 && *length < 5\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinyxml.h\", 0x14d);\n        }\n        \n        if (*length != 1) {\n            \n            if (*length == 0) {\n                \n                return (byte *)0x0;\n            }\n            \n            for (int value = 0; *input_bytes != 0 && *length > value; value++) {\n                output_bytes[value] = *input_bytes++;\n            }\n            \n            return input_bytes + *length;\n        }\n    } else {\n        \n        *length = 1;\n    }\n    \n    if (*input_bytes == 0x26) {\n        \n        return (byte *)FUN_1000e680((char *)input_bytes, (char *)output_bytes, length, condition);\n    }\n    \n    \n    *output_bytes = *input_bytes;\n    \n    return input_bytes + 1;\n}\n*\\ \n \nbyte * __cdecl FUN_1000ece0(byte *input_bytes, byte *output_bytes, int *length, int condition)\n{\n    int value;\n    if (input_bytes == (byte *)0x0) {\n        __wassert(L\"p\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinyxml.h\", 0x149);\n    }\n    if (condition == 1) {\n        value = *(int *)(&DAT_1002ca50 + (uint)*input_bytes * 4);\n        *length = value;\n        if ((value < 0) || (4 < value)) {\n            __wassert(L\"*length >= 0 && *length < 5\", L\"c:\\\\users\\\\theone\\\\gitproject\\\\nativemodule\\\\tinyxml.h\", 0x14d);\n        }\n        if (*length != 1) {\n            if (*length == 0) {\n                return (byte *)0x0;\n            }\n            for (int value = 0; *input_bytes != 0 && *length > value; value++) {\n                output_bytes[value] = *input_bytes++;\n            }\n            return input_bytes + *length;\n        }\n    } else {\n        *length = 1;\n    }\n    if (*input_bytes == 0x26) {\n        return (byte *)FUN_1000e680((char *)input_bytes, (char *)output_bytes, length, condition);\n    }\n    *output_bytes = *input_bytes;\n    return input_bytes + 1;\n}"}
{"Function Name": "FUN_1000f200", "Address": "1000f200", "Source Code": "byte * __thiscall FUN_1000f200(void *this,byte *param_1,int *param_2,int *param_3)\n{\nbyte bVar1;\nchar cVar2;\nsize_t *psVar3;\ncode *pcVar4;\nint *piVar5;\nbyte *pbVar6;\nvoid *this_00;\nbyte *pbVar7;\nundefined4 *puVar8;\nint *piVar9;\nint iVar10;\nundefined4 uVar11;\nchar *pcVar12;\nvoid *local_c;\nundefined *puStack_8;\nundefined4 local_4;\npiVar5 = param_3;\nlocal_4 = 0xffffffff;\npuStack_8 = &LAB_10028e53;\nlocal_c = ExceptionList;\nExceptionList = &local_c;\npbVar6 = FUN_1000e020(param_1,(int)param_3);\nthis_00 = (void *)FUN_1000bec0((int *)this);\nif ((pbVar6 == (byte *)0x0) || (*pbVar6 == 0)) {\nif ((this_00 != (void *)0x0) && (*(char *)((int)this_00 + 0x2c) == '\\0')) {\n*(undefined *)((int)this_00 + 0x2c) = 1;\n*(undefined4 *)((int)this_00 + 0x30) = 3;\npcVar12 = PTR_s_Error_parsing_Element__100344b4;\ndo {\ncVar2 = *pcVar12;\npcVar12 = pcVar12 + 1;\n} while (cVar2 != '\\0');\nFUN_1000bcc0((void *)((int)this_00 + 0x34),PTR_s_Error_parsing_Element__100344b4,\n(int)pcVar12 - (int)(PTR_s_Error_parsing_Element__100344b4 + 1));\n*(undefined4 *)((int)this_00 + 0x40) = 0xffffffff;\n*(undefined4 *)((int)this_00 + 0x3c) = 0xffffffff;\n}\n}\nelse {\nif (param_2 != (int *)0x0) {\nFUN_1000dd80(param_2,pbVar6,(int)piVar5);\n*(int *)((int)this + 4) = *param_2;\n*(int *)((int)this + 8) = param_2[1];\n}\nif (*pbVar6 == 0x3c) {\npbVar7 = FUN_1000e020(pbVar6 + 1,(int)piVar5);\npbVar6 = FUN_1000e0d0(pbVar7,(size_t **)((int)this + 0x20));\nif ((pbVar6 == (byte *)0x0) || (*pbVar6 == 0)) {\nif (this_00 != (void *)0x0) {\nFUN_1000e270(this_00,4,pbVar7,param_2,(int)piVar5);\n}\n}\nelse {\nFUN_1000d200(&param_3,\"</\");\nlocal_4 = 0;\npsVar3 = *(size_t **)((int)this + 0x20);\nFUN_1000bdb0(&param_3,psVar3 + 2,*psVar3);\nwhile( true ) {\nif (*pbVar6 == 0) {\nlocal_4 = 0xffffffff;\nif (param_3 == &DAT_10035a58) {\nExceptionList = local_c;\nreturn pbVar6;\n}\n_free(param_3);\nExceptionList = local_c;\nreturn pbVar6;\n}\npbVar7 = FUN_1000e020(pbVar6,(int)piVar5);\nif ((pbVar7 == (byte *)0x0) || (bVar1 = *pbVar7, bVar1 == 0)) break;\nif (bVar1 == 0x2f) {\npbVar6 = pbVar7 + 1;\nif (*pbVar6 == 0x3e) {\npbVar6 = pbVar7 + 2;\nLAB_1000f3f1:\nlocal_4 = 0xffffffff;\nif (param_3 == &DAT_10035a58) {\nExceptionList = local_c;\nreturn pbVar6;\n}\n_free(param_3);\nExceptionList = local_c;\nreturn pbVar6;\n}\nif (this_00 != (void *)0x0) {\niVar10 = 7;\ngoto LAB_1000f3c2;\n}\ngoto LAB_1000f3c9;\n}\nif (bVar1 == 0x3e) {\npbVar6 = (byte *)FUN_1000eb50(pbVar7 + 1,param_2,piVar5);\nif (((pbVar6 == (byte *)0x0) || (*pbVar6 == 0)) ||\n(uVar11 = FUN_1000e180((char *)pbVar6,(char *)(param_3 + 2),'\\0',(int)piVar5),\n(char)uVar11 == '\\0')) {\nif (this_00 != (void *)0x0) {\niVar10 = 8;\nLAB_1000f3c2:\nFUN_1000e270(this_00,iVar10,pbVar6,param_2,(int)piVar5);\n}\n}\nelse {\npbVar6 = FUN_1000e020(pbVar6 + *param_3,(int)piVar5);\nif (((pbVar6 != (byte *)0x0) && (*pbVar6 != 0)) && (*pbVar6 == 0x3e)) {\npbVar6 = pbVar6 + 1;\ngoto LAB_1000f3f1;\n}\nif (this_00 != (void *)0x0) {\niVar10 = 8;\ngoto LAB_1000f3c2;\n}\n}\ngoto LAB_1000f3c9;\n}\npuVar8 = (undefined4 *)operator_new(0x24);\nlocal_4._0_1_ = 1;\nif (puVar8 == (undefined4 *)0x0) {\npiVar9 = (int *)0x0;\n}\nelse {\npiVar9 = (int *)FUN_1000c200(puVar8);\n}\nlocal_4 = (uint)local_4._1_3_ << 8;\nif (piVar9 == (int *)0x0) goto LAB_1000f3c9;\npcVar4 = *(code **)(*piVar9 + 8);\npiVar9[4] = (int)this_00;\npbVar6 = (byte *)(*pcVar4)(pbVar7,param_2,piVar5);\nif ((pbVar6 == (byte *)0x0) || (*pbVar6 == 0)) {\nif (this_00 != (void *)0x0) {\nFUN_1000e270(this_00,3,pbVar7,param_2,(int)piVar5);\n}\n(**(code **)*piVar9)(1);\ngoto LAB_1000f3c9;\n}\niVar10 = FUN_1000c190((void *)((int)this + 0x2c),(byte *)(piVar9[5] + 8));\nif (iVar10 != 0) {\nif (this_00 != (void *)0x0) {\nFUN_1000e270(this_00,3,pbVar7,param_2,(int)piVar5);\n}\n(**(code **)*piVar9)(1);\ngoto LAB_1000f3c9;\n}\nFUN_1000d110((void *)((int)this + 0x2c),(int)piVar9);\n}\nif (this_00 != (void *)0x0) {\niVar10 = 6;\ngoto LAB_1000f3c2;\n}\nLAB_1000f3c9:\nlocal_4 = 0xffffffff;\nif (param_3 != &DAT_10035a58) {\n_free(param_3);\n}\n}\n}\nelse if (this_00 != (void *)0x0) {\nFUN_1000e270(this_00,3,pbVar6,param_2,(int)piVar5);\n}\n}\nExceptionList = local_c;\nreturn (byte *)0x0;\n}\nLocal Variable: local_4 : undefined4\nLocal Variable: local_c : undefined4\nLocal Variable: local_10 : undefined4"}
{"Function Name": "FUN_1000f730", "Address": "1000f730", "Source Code": "\\*\nbyte * __thiscall FUN_1000f730(void *context, byte *input_data, int *int_array, int data_length)\n{\n    void *adjusted_context; // Pointer to the adjusted 'this' context\n    int *int_array_pointer; // Pointer to the integer array passed as param_2\n    int temp_var; // Temporary variable for integer operations\n    int result_var; // Variable to store the result of FUN_1000bec0\n    undefined4 function_result; // Variable to store the result of FUN_1000e180\n    byte *result_pointer; // Pointer to the resulting byte array\n    char *cdata_tag_pointer; // Pointer for string manipulation\n    char *string_pointer; // Another pointer for string manipulation\n    void *original_exception_list; // Local variable to store the current ExceptionList\n\n    original_exception_list = ExceptionList; // Save the current ExceptionList\n    ExceptionList = &original_exception_list; // Set ExceptionList to point to local_c\n    adjusted_context = (void *)((int)context + 0x20); // Adjust 'this' pointer\n    FUN_1000bcc0(adjusted_context, &PTR_1002bc68, 0); // Call FUN_1000bcc0 with adjusted 'this'\n    result_var = FUN_1000bec0((int *)context); // Call FUN_1000bec0 and store the result\n    int_array_pointer = int_array; // Store the pointer to param_2\n\n    if (int_array != (int *)0x0) { // Check if param_2 is not null\n        FUN_1000dd80(int_array, input_data, data_length); // Call FUN_1000dd80 with param_2, param_1, and param_3\n        *(int *)((int)context + 4) = *int_array_pointer; // Store the first integer from this_01\n        *(int *)((int)context + 8) = int_array_pointer[1]; // Store the second integer from this_01\n    }\n\n    if ((*(char *)((int)context + 0x2c) == '\\0') && // Check if a specific flag is not set\n        (function_result = FUN_1000e180((char *)input_data, \"<![CDATA[\", '\\0', data_length), (char)function_result == '\\0')) { // Check for CDATA section\n        result_pointer = FUN_1000edb0(input_data, adjusted_context, 1, \"<\", 0, data_length); // Call FUN_1000edb0 to process the input\n        if ((result_pointer != (byte *)0x0) && (*result_pointer != 0)) { // Check if the result is valid\n            ExceptionList = original_exception_list; // Restore the original ExceptionList\n            return result_pointer + -1; // Return the processed result\n        }\n    } else {\n        *(undefined *)((int)context + 0x2c) = 1; // Set the flag indicating CDATA processing has started\n        function_result = FUN_1000e180((char *)input_data, \"<![CDATA[\", '\\0', data_length); // Check for CDATA section again\n        if ((char)function_result != '\\0') { // If CDATA section is found\n            cdata_tag_pointer = \"<![CDATA[\"; // Pointer to the CDATA opening tag\n            while (*cdata_tag_pointer != '\\0') { // Find the length of the CDATA tag\n                cdata_tag_pointer++;\n            }\n            result_pointer = input_data + (int)(cdata_tag_pointer - 0x1002c75c); // Adjust pointer to the start of the data\n            while (((result_pointer != (byte *)0x0 && (*result_pointer != 0)) && // While there is data to process\n                (function_result = FUN_1000e180((char *)result_pointer, \"]]>\", '\\0', data_length), (char)function_result == '\\0'))) { // Check for CDATA end tag\n                data_length = CONCAT31(data_length._1_3_, *result_pointer); // Concatenate the current byte to param_3\n                FUN_1000bdb0(adjusted_context, &data_length, 1); // Call FUN_1000bdb0 to process the byte\n                result_pointer++; // Move to the next byte\n            }\n            int_array = &DAT_10035a58; // Set param_2 to a specific data location\n            result_pointer = FUN_1000edb0(result_pointer, &int_array, 0, \"]]>\", 0, data_length); // Call FUN_1000edb0 to finalize processing\n            if (int_array == &DAT_10035a58) { // Check if param_2 is unchanged\n                ExceptionList = original_exception_list; // Restore the original ExceptionList\n                return result_pointer; // Return the processed result\n            }\n            _free(int_array); // Free the allocated memory for param_2\n            ExceptionList = original_exception_list; // Restore the original ExceptionList\n            return result_pointer; // Return the processed result\n        }\n    }\n\n    if ((result_var != 0) && (*(char *)(result_var + 0x2c) == '\\0')) { // Check if iVar3 is valid and the flag is not set\n        *(undefined *)(result_var + 0x2c) = 1; // Set the flag indicating an error has occurred\n        *(undefined4 *)(result_var + 0x30) = 0xe; // Set an error code\n        cdata_tag_pointer = PTR_s_Error_parsing_CDATA__100344e0; // Pointer to the error message\n        while (*cdata_tag_pointer != '\\0') { // Find the length of the error message\n            cdata_tag_pointer++;\n        }\n        FUN_1000bcc0((void *)(result_var + 0x34), PTR_s_Error_parsing_CDATA__100344e0, // Call FUN_1000bcc0 to log the error\n                     (int)cdata_tag_pointer - (int)(PTR_s_Error_parsing_CDATA__100344e0 + 1));\n        *(undefined4 *)(result_var + 0x40) = 0xffffffff; // Set error status\n        *(undefined4 *)(result_var + 0x3c) = 0xffffffff; // Set error status\n        if ((input_data != (byte *)0x0) && (int_array_pointer != (int *)0x0)) { // Check if param_1 and this_01 are valid\n            FUN_1000dd80(int_array_pointer, input_data, data_length); // Call FUN_1000dd80 to process the input\n            *(int *)(result_var + 0x3c) = *int_array_pointer; // Store the first integer from this_01\n            *(int *)(result_var + 0x40) = int_array_pointer[1]; // Store the second integer from this_01\n        }\n    }\n    ExceptionList = original_exception_list; // Restore the original ExceptionList\n    return (byte *)0x0; // Return null indicating failure\n}\n*\\ \n \n\nbyte * __thiscall FUN_1000f730(void *context, byte *input_data, int *int_array, int data_length)\n{\n    void *adjusted_context;\n    int *int_array_pointer;\n    int temp_var;\n    int result_var;\n    undefined4 function_result;\n    byte *result_pointer;\n    char *cdata_tag_pointer;\n    char *string_pointer;\n    void *original_exception_list;\n\n    original_exception_list = ExceptionList;\n    ExceptionList = &original_exception_list;\n    adjusted_context = (void *)((int)context + 0x20);\n    FUN_1000bcc0(adjusted_context, &PTR_1002bc68, 0);\n    result_var = FUN_1000bec0((int *)context);\n    int_array_pointer = int_array;\n\n    if (int_array != (int *)0x0) {\n        FUN_1000dd80(int_array, input_data, data_length);\n        *(int *)((int)context + 4) = *int_array_pointer;\n        *(int *)((int)context + 8) = int_array_pointer[1];\n    }\n\n    if ((*(char *)((int)context + 0x2c) == '\\0') &&\n        (function_result = FUN_1000e180((char *)input_data, \"<![CDATA[\", '\\0', data_length), (char)function_result == '\\0')) {\n        result_pointer = FUN_1000edb0(input_data, adjusted_context, 1, \"<\", 0, data_length);\n        if ((result_pointer != (byte *)0x0) && (*result_pointer != 0)) {\n            ExceptionList = original_exception_list;\n            return result_pointer + -1;\n        }\n    } else {\n        *(undefined *)((int)context + 0x2c) = 1;\n        function_result = FUN_1000e180((char *)input_data, \"<![CDATA[\", '\\0', data_length);\n        if ((char)function_result != '\\0') {\n            cdata_tag_pointer = \"<![CDATA[\";\n            while (*cdata_tag_pointer != '\\0') {\n                cdata_tag_pointer++;\n            }\n            result_pointer = input_data + (int)(cdata_tag_pointer - 0x1002c75c);\n            while (((result_pointer != (byte *)0x0 && (*result_pointer != 0)) &&\n                (function_result = FUN_1000e180((char *)result_pointer, \"]]>\", '\\0', data_length), (char)function_result == '\\0'))) {\n                data_length = CONCAT31(data_length._1_3_, *result_pointer);\n                FUN_1000bdb0(adjusted_context, &data_length, 1);\n                result_pointer++;\n            }\n            int_array = &DAT_10035a58;\n            result_pointer = FUN_1000edb0(result_pointer, &int_array, 0, \"]]>\", 0, data_length);\n            if (int_array == &DAT_10035a58) {\n                ExceptionList = original_exception_list;\n                return result_pointer;\n            }\n            _free(int_array);\n            ExceptionList = original_exception_list;\n            return result_pointer;\n        }\n    }\n\n    if ((result_var != 0) && (*(char *)(result_var + 0x2c) == '\\0')) {\n        *(undefined *)(result_var + 0x2c) = 1;\n        *(undefined4 *)(result_var + 0x30) = 0xe;\n        cdata_tag_pointer = PTR_s_Error_parsing_CDATA__100344e0;\n        while (*cdata_tag_pointer != '\\0') {\n            cdata_tag_pointer++;\n        }\n        FUN_1000bcc0((void *)(result_var + 0x34), PTR_s_Error_parsing_CDATA__100344e0,\n                     (int)cdata_tag_pointer - (int)(PTR_s_Error_parsing_CDATA__100344e0 + 1));\n        *(undefined4 *)(result_var + 0x40) = 0xffffffff;\n        *(undefined4 *)(result_var + 0x3c) = 0xffffffff;\n        if ((input_data != (byte *)0x0) && (int_array_pointer != (int *)0x0)) {\n            FUN_1000dd80(int_array_pointer, input_data, data_length);\n            *(int *)(result_var + 0x3c) = *int_array_pointer;\n            *(int *)(result_var + 0x40) = int_array_pointer[1];\n        }\n    }\n    ExceptionList = original_exception_list;\n    return (byte *)0x0;\n}\n"}
{"Function Name": "FUN_1000fd88", "Address": "1000fd88", "Source Code": "undefined4 __fastcall FUN_1000fd88(undefined4 input_value)\n{\n    \n    if (InterlockedIncrement((LONG *)&atomic_counter) == 0) {\n        \n        LPCRITICAL_SECTION current_section = (LPCRITICAL_SECTION)&critical_section_start;\n        \n        do {\n            \n            process_critical_section(current_section);\n            \n            current_section++;\n        } while ((int)current_section < 0x10035ac8); \n    }\n    \n    return input_value;\n}"}
{"Function Name": "__Deletegloballocale", "Address": "1000fe28", "Source Code": "void __cdecl __Deletegloballocale(uint *input_pointer)\n{\n    \n    if (*input_pointer != 0) {\n        \n        undefined4 *function_pointer = (undefined4 *)FUN_10001890(*input_pointer);\n        \n        \n        if (function_pointer != (undefined4 *)0x0) {\n            \n            (**(code **)*function_pointer)(1);\n        }\n    }\n}"}
{"Function Name": "_Atexit", "Address": "100103c6", "Source Code": "void __cdecl _Atexit(_func_void *exit_function)\n{\n    \n    if (exit_function_counter == 0) {\n        \n        abort_program();\n    }\n    \n    \n    exit_function_counter--;\n    \n    \n    *(_func_void **)(exit_function_counter * 4 + 0x10035b58) = exit_function;\n}"}
{"Function Name": "FUN_10010400", "Address": "10010400", "Source Code": "void FUN_10010400(void) \n{\n    while (counter < 10) { \n        if (*(int *)(counter * 4 + 0x10035b58) != 0) { \n            (**(code **)(counter * 4 + 0x10035b54))(); \n        }\n        counter++; \n    }\n}"}
{"Function Name": "__time64", "Address": "1001040b", "Source Code": "__time64_t __cdecl __time64(__time64_t *_Time) \n{\n    __time64_t currentTime; \n    _FILETIME fileTimeStruct; \n    GetSystemTimeAsFileTime(&fileTimeStruct); \n    currentTime = __aulldiv(fileTimeStruct.dwLowDateTime + 0x2ac18000, \n                      fileTimeStruct.dwHighDateTime + 0xfe624e21 + (uint)(0xd53e7fff < fileTimeStruct.dwLowDateTime), \n                      10000000, \n                      0); \n    if (_Time) { \n        *_Time = currentTime; \n    }\n    return currentTime; \n}"}
{"Function Name": "_free", "Address": "100104b6", "Source Code": "void __cdecl _free(void *memoryPointer) \n{\n    uint *resultPointer; \n    BOOL isHeapFreeSuccessful; \n    int *errnoAddress; \n    DWORD lastErrorCode; \n    if (memoryPointer != (void *)0x0) { \n        if (DAT_100377f4 == 3) { \n            __lock(4); \n            resultPointer = (uint *)thunk_FUN_10016ae8((void *)0x4, (int)memoryPointer); \n            if (resultPointer != (uint *)0x0) { \n                ___sbh_free_block(resultPointer, (int)memoryPointer); \n            }\n            FUN_10010d15(); \n            if (resultPointer != (uint *)0x0) { \n                return; \n            }\n        }\n        isHeapFreeSuccessful = HeapFree(DAT_10036228, 0, memoryPointer); \n        if (isHeapFreeSuccessful == 0) { \n            errnoAddress = __errno(); \n            lastErrorCode = GetLastError(); \n            *errnoAddress = __get_errno_from_oserr(lastErrorCode); \n        }\n    }\n}"}
{"Function Name": "_UnwindNestedFrames", "Address": "100104f2", "Source Code": "void _UnwindNestedFrames(EHRegistrationNode *registration_node, EHExceptionRecord *exception_record)\n{\n    \n    RtlUnwind(registration_node, (PVOID)0x1001051b, (PEXCEPTION_RECORD)exception_record, (PVOID)0x0);\n    \n    \n    *(uint *)(exception_record + 4) &= 0xfffffffd;\n    \n    \n    *(void **)exception_list = exception_list;\n    \n    \n    exception_list = exception_list;\n}"}
{"Function Name": "FID_conflict:___CxxFrameHandler3", "Address": "10010544", "Source Code": "undefined4 __cdecl\nFID_conflict____CxxFrameHandler3\n(int *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4)\n{\n    \n    return ___InternalCxxFrameHandler(param_1, param_2, param_3, param_4, 0, (EHRegistrationNode *)0x0, '\\0');\n}"}
{"Function Name": "TranslatorGuardHandler", "Address": "1001067f", "Source Code": "_EXCEPTION_DISPOSITION __cdecl\nTranslatorGuardHandler\n(EHExceptionRecord *param_1, TranslatorGuardRN *param_2, void *param_3, void *param_4)\n{\n    \n    ___security_check_cookie_4(*(uint *)(param_2 + 8) ^ (uint)param_2);\n    \n    \n    if ((*(uint *)(param_1 + 4) & 0x66) != 0) {\n        \n        *(undefined4 *)(param_2 + 0x24) = 1;\n        return 1; \n    }\n    \n    \n    ___InternalCxxFrameHandler\n    ((int *)param_1, *(EHRegistrationNode **)(param_2 + 0x10), (_CONTEXT *)param_3, (void *)0x0,\n    *(_s_FuncInfo **)(param_2 + 0xc), *(int *)(param_2 + 0x14),\n    *(EHRegistrationNode **)(param_2 + 0x18), '\\x01');\n    \n    \n    if (*(int *)(param_2 + 0x24) == 0) {\n        _UnwindNestedFrames((EHRegistrationNode *)param_2, param_1);\n    }\n    \n    \n    return _CallSETranslator((EHExceptionRecord *)0x123, (EHRegistrationNode *)0x0, (void *)0x0,\n    (void *)0x0, (_s_FuncInfo *)0x0, 0, (EHRegistrationNode *)0x0)();\n}"}
{"Function Name": "_GetRangeOfTrysToCheck", "Address": "1001071c", "Source Code": "\\*\n_s_TryBlockMapEntry * __cdecl\n_GetRangeOfTrysToCheck(_s_FuncInfo *param_1, int param_2, int param_3, uint *param_4, uint *param_5)\n{\n    \n    TryBlockMapEntry *pTVar1 = param_1->pTryBlockMap;\n    \n    \n    uint uVar5 = param_1->nTryBlocks;\n    \n    \n    uint uVar3 = uVar5;\n    \n    while (uVar5 != 0xffffffff && param_2 >= 0) {\n        \n        uVar5--;\n        \n        \n        if ((pTVar1[uVar5].tryHigh < param_3 && param_3 <= pTVar1[uVar5].catchHigh) || uVar5 == 0xffffffff) {\n            \n            param_2--;\n        }\n    }\n    \n    \n    uVar5++;\n    \n    \n    *param_4 = uVar5;\n    \n    \n    *param_5 = uVar3;\n    \n    if (param_1->nTryBlocks < uVar3 || uVar3 < uVar5) {\n        _inconsistency(); \n    }\n    \n    \n    return pTVar1 + uVar5;\n}\n*\\ \n \n_s_TryBlockMapEntry * __cdecl\n_GetRangeOfTrysToCheck(_s_FuncInfo *param_1, int param_2, int param_3, uint *param_4, uint *param_5)\n{\n    TryBlockMapEntry *pTVar1 = param_1->pTryBlockMap;\n    uint uVar5 = param_1->nTryBlocks;\n    uint uVar3 = uVar5;\n    while (uVar5 != 0xffffffff && param_2 >= 0) {\n        uVar5--;\n        if ((pTVar1[uVar5].tryHigh < param_3 && param_3 <= pTVar1[uVar5].catchHigh) || uVar5 == 0xffffffff) {\n            param_2--;\n        }\n    }\n    uVar5++;\n    *param_4 = uVar5;\n    *param_5 = uVar3;\n    if (param_1->nTryBlocks < uVar3 || uVar3 < uVar5) {\n        _inconsistency();\n    }\n    return pTVar1 + uVar5;\n}"}
{"Function Name": "__CreateFrameInfo", "Address": "1001078f", "Source Code": "\\*\nundefined4 * __cdecl __CreateFrameInfo(undefined4 *frameInfoPtr, undefined4 frameInfoValue)\n{\n    *frameInfoPtr = frameInfoValue; \n    _ptiddata threadLocalData = __getptd(); \n    frameInfoPtr[1] = threadLocalData->_pFrameInfoChain; \n    threadLocalData->_pFrameInfoChain = frameInfoPtr; \n    return frameInfoPtr; \n}\n*\\ \n \nundefined4 * __cdecl __CreateFrameInfo(undefined4 *frameInfoPtr, undefined4 frameInfoValue)\n{\n    *frameInfoPtr = frameInfoValue;\n    _ptiddata threadLocalData = __getptd();\n    frameInfoPtr[1] = threadLocalData->_pFrameInfoChain;\n    threadLocalData->_pFrameInfoChain = frameInfoPtr;\n    return frameInfoPtr;\n}"}
{"Function Name": "__IsExceptionObjectToBeDestroyed", "Address": "100107b7", "Source Code": "undefined4 __cdecl __IsExceptionObjectToBeDestroyed(int exceptionId)\n{\n    \n    int *framePointer = (int *)__getptd()->_pFrameInfoChain;\n    \n    while (framePointer != (int *)0x0) {\n        \n        if (*framePointer == exceptionId) \n            return 0; \n        \n        \n        framePointer = (int *)framePointer[1];\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "_rand", "Address": "10010921", "Source Code": "int __cdecl generate_random_number(void) \n{\n    _ptiddata thread_local_data = __getptd(); \n    thread_local_data->_holdrand = thread_local_data->_holdrand * 0x343fd + 0x269ec3; \n    return thread_local_data->_holdrand >> 0x10 & 0x7fff; \n}"}
{"Function Name": "FUN_10010a35", "Address": "10010a35", "Source Code": "\\*\nundefined4 * __fastcall FUN_10010a35(undefined4 *exception_ptr, undefined unused_param_1, undefined unused_param_2)\n{\n    \n    std::exception::exception((exception *)exception_ptr, (char **)&unused_param_2);\n    \n    \n    *exception_ptr = std::bad_cast::vftable;\n    \n    \n    return exception_ptr;\n}\n*\\ \n \nundefined4 * __fastcall FUN_10010a35(undefined4 *exception_ptr, undefined unused_param_1, undefined unused_param_2)\n{\n    std::exception::exception((exception *)exception_ptr, (char **)&unused_param_2);\n    *exception_ptr = std::bad_cast::vftable;\n    return exception_ptr;\n}"}
{"Function Name": "_memcpy_s", "Address": "10010aaf", "Source Code": "errno_t __cdecl _memcpy_s(void *destination, rsize_t destinationSize, void *source, rsize_t maxCount)\n{\n    errno_t errorCode; \n    int *errnoPointer;   \n    \n    if (maxCount == 0) {\n        return 0; \n    }\n    \n    \n    if (destination == (void *)0x0) {\n        errnoPointer = __errno(); \n        errorCode = 0x16; \n        *errnoPointer = 0x16; \n        return errorCode; \n    }\n    \n    \n    if (source != (void *)0x0 && maxCount <= destinationSize) {\n        _memcpy(destination, source, maxCount); \n        return 0; \n    }\n    \n    \n    _memset(destination, 0, destinationSize);\n    \n    \n    if (source == (void *)0x0) {\n        errnoPointer = __errno(); \n        errorCode = 0x16; \n        *errnoPointer = 0x16; \n        return errorCode; \n    }\n    \n    \n    if (maxCount > destinationSize) {\n        errnoPointer = __errno(); \n        errorCode = 0x22; \n        *errnoPointer = 0x22; \n        return errorCode; \n    }\n    \n    \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    return errorCode; \n}"}
{"Function Name": "_memchr", "Address": "10010b30", "Source Code": "void * __cdecl _memchr(void *buffer, int value, size_t maxCount)\n{\n    uint maskedValue; \n    char currentChar; \n    if (maxCount != 0) { \n        maskedValue = value & 0xff; \n        while (maxCount != 0) { \n            currentChar = *buffer; \n            buffer = (void *)((char *)buffer + 1); \n            if (currentChar == (char)value) { \n                return (char *)((char *)buffer - 1); \n            }\n            maxCount--; \n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "_memmove_s", "Address": "10010bdd", "Source Code": "errno_t __cdecl _memmove_s(void *destination, rsize_t destinationSize, void *source, rsize_t maxCount)\n{\n    errno_t errorCode; \n    if (maxCount == 0) { \n        return 0; \n    }\n    if (destination == (void *)0x0 || source == (void *)0x0) { \n        *(__errno()) = 0x16; \n        return 0x16; \n    }\n    if (maxCount <= destinationSize) { \n        _memmove(destination, source, maxCount); \n        return 0; \n    }\n    *(__errno()) = 0x22; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return 0x22; \n}"}
{"Function Name": "_memset", "Address": "10010c40", "Source Code": "void * __cdecl _memset(void *destination, int value, size_t size)\n{\n    uint maskedValue; \n    uint *destinationPtr; \n    if (size == 0) { \n        return destination; \n    }\n    maskedValue = value & 0xff; \n    if (((char)value == '\\0') && (0xff < size) && (DAT_100377fc != 0)) { \n        return __VEC_memzero((undefined (*) [16])destination, value, size); \n    }\n    destinationPtr = (uint *)destination; \n    if (size > 3) { \n        size_t originalSize = size; \n        uint chunkCount = -(int)destination & 3; \n        if (chunkCount != 0) { \n            originalSize -= chunkCount; \n            do {\n                *(char *)destinationPtr = (char)value; \n                destinationPtr = (uint *)((int)destinationPtr + 1); \n                chunkCount--; \n            } while (chunkCount != 0); \n        }\n        maskedValue *= 0x1010101; \n        chunkCount = originalSize >> 2; \n        while (chunkCount--) { \n            *destinationPtr++ = maskedValue; \n        }\n        if ((originalSize & 3) == 0) { \n            return destination; \n        }\n    }\n    while (size--) { \n        *(char *)destinationPtr = (char)maskedValue; \n        destinationPtr = (uint *)((int)destinationPtr + 1); \n    }\n    return destination; \n}"}
{"Function Name": "_free", "Address": "10010cba", "Source Code": "void __cdecl _free(void *memoryPointer) \n{\n    uint *memoryBlockPtr; \n    BOOL isHeapFreeSuccessful; \n    int *errnoPtr; \n    DWORD lastErrorCode; \n    if (memoryPointer != (void *)0x0) { \n        if (DAT_100377f4 == 3) { \n            __lock(4); \n            memoryBlockPtr = (uint *)thunk_FUN_10016ae8((void *)0x4, (int)memoryPointer); \n            if (memoryBlockPtr != (uint *)0x0) { \n                ___sbh_free_block(memoryBlockPtr, (int)memoryPointer); \n            }\n            FUN_10010d15(); \n            if (memoryBlockPtr != (uint *)0x0) { \n                return; \n            }\n        }\n        isHeapFreeSuccessful = HeapFree(DAT_10036228, 0, memoryPointer); \n        if (isHeapFreeSuccessful == 0) { \n            errnoPtr = __errno(); \n            lastErrorCode = GetLastError(); \n            *errnoPtr = __get_errno_from_oserr(lastErrorCode); \n        }\n    }\n}"}
{"Function Name": "_free", "Address": "10010cbf", "Source Code": "void __cdecl _free(void *memoryPointer) \n{\n    uint *memoryBlock; \n    BOOL isHeapFreeSuccessful; \n    int *errnoAddress; \n    DWORD lastErrorCode; \n    if (memoryPointer != (void *)0x0) { \n        if (DAT_100377f4 == 3) { \n            __lock(4); \n            memoryBlock = (uint *)thunk_FUN_10016ae8((void *)0x4, (int)memoryPointer); \n            if (memoryBlock != (uint *)0x0) { \n                ___sbh_free_block(memoryBlock, (int)memoryPointer); \n            }\n            FUN_10010d15(); \n            if (memoryBlock != (uint *)0x0) { \n                return; \n            }\n        }\n        isHeapFreeSuccessful = HeapFree(DAT_10036228, 0, memoryPointer); \n        if (isHeapFreeSuccessful == 0) { \n            errnoAddress = __errno(); \n            lastErrorCode = GetLastError(); \n            *errnoAddress = __get_errno_from_oserr(lastErrorCode); \n        }\n    }\n    return; \n}"}
{"Function Name": "__difftime64", "Address": "10010d4d", "Source Code": "double __cdecl __difftime64(__time64_t startTime, __time64_t endTime)\n{\n    \n    if (endTime > -1 && startTime > -1) {\n        \n        return (double)(startTime - endTime);\n    }\n    \n    *__errno() = 0x16;\n    \n    return 0.0;\n}"}
{"Function Name": "__localtime64", "Address": "100110b4", "Source Code": "\\*\ntm * __cdecl __localtime64(__time64_t *timePointer)\n{\n    \n    tm *timeStruct = ___getgmtimebuf();\n    \n    \n    if (timeStruct == (tm *)0x0) {\n        \n        return (tm *)0x0;\n    }\n    \n    \n    \n    return (tm *)(~-(uint)(__localtime64_s(timeStruct, timePointer) != 0) & (uint)timeStruct);\n}\n*\\ \n \ntm * __cdecl __localtime64(__time64_t *timePointer)\n{\n    tm *timeStruct = ___getgmtimebuf();\n    if (timeStruct == (tm *)0x0) {\n        return (tm *)0x0;\n    }\n    return (tm *)(~-(uint)(__localtime64_s(timeStruct, timePointer) != 0) & (uint)timeStruct);\n}"}
{"Function Name": "__ArrayUnwind", "Address": "1001125c", "Source Code": "void __ArrayUnwind(void *array, uint size, int count, _func_void_void_ptr *callback)\n{\n    \n    while (count-- > 0) {\n        \n        (*callback)(NULL);\n    }\n    \n    return;\n}"}
{"Function Name": "`eh_vector_destructor_iterator'", "Address": "100112ba", "Source Code": "void _eh_vector_destructor_iterator_\n(void *param_1, uint param_2, int param_3, _func_void_void_ptr *param_4)\n{\n    \n    while (param_3-- > 0) {\n        \n        (*param_4)(NULL);\n    }\n    \n    FUN_10011305();\n    return; \n}"}
{"Function Name": "FUN_10011305", "Address": "10011305", "Source Code": "void FUN_10011305(void)\n{\n    \n    if (*(int *)(base_pointer + -0x1c) == 0) {\n        \n        array_unwind(*(void **)(base_pointer + 8), \n                      *(uint *)(base_pointer + 0xc), \n                      *(int *)(base_pointer + 0x10), \n                      *(_func_void_void_ptr **)(base_pointer + 0x14)); \n    }\n}"}
{"Function Name": "_atol", "Address": "10011398", "Source Code": "long __cdecl _atol(char *inputString) \n{\n    return stringToLong(inputString, (char **)0x0, 10); \n}"}
{"Function Name": "_atol", "Address": "100113a9", "Source Code": "long __cdecl _atol(char *inputString) \n{\n    \n    \n    return stringToLong(inputString, (char **)0x0, 10);\n}"}
{"Function Name": "`eh_vector_constructor_iterator'", "Address": "100113ae", "Source Code": "void _eh_vector_constructor_iterator_\n(void *param_1, uint param_2, int param_3, _func_void_void_ptr *param_4)\n{\n    \n    for (int local_20 = 0; local_20 < param_3; local_20++) {\n        \n        (*param_4)(NULL);\n    }\n    \n    FUN_100113fb();\n    return; \n}"}
{"Function Name": "FUN_100113fb", "Address": "100113fb", "Source Code": "void FUN_100113fb(void)\n{\n    \n    if (*(int *)(base_pointer + -0x20) == 0) {\n        \n        array_unwind_function(*(void **)(base_pointer + 8), \n                      *(uint *)(base_pointer + 0xc), \n                      *(int *)(base_pointer + -0x1c), \n                      *(_func_void_void_ptr **)(base_pointer + 0x18)); \n    }\n}"}
{"Function Name": "__onexit_nolock", "Address": "10011413", "Source Code": "undefined4 __cdecl __onexit_nolock(undefined4 inputValue)\n{\n    \n    undefined4 *memoryAddress = (undefined4 *)__decode_pointer(DAT_100377cc);\n    \n    undefined4 *endAddress = (undefined4 *)__decode_pointer(DAT_100377c8);\n    \n    \n    if (memoryAddress <= endAddress) {\n        \n        uint memoryBlockSize = ((int)endAddress - (int)memoryAddress) + 4;\n        \n        \n        if (3 < memoryBlockSize) {\n            \n            size_t currentSize = __msize(memoryAddress);\n            \n            if (currentSize < memoryBlockSize) {\n                \n                size_t newSize = (currentSize < 0x800) ? currentSize : 0x800;\n                \n                \n                if ((newSize + currentSize < currentSize) || \n                    (__realloc_crt(memoryAddress, newSize + currentSize) == (void *)0x0)) {\n                    \n                    if (currentSize + 0x10 < currentSize) {\n                        return 0; \n                    }\n                    \n                    if (__realloc_crt(memoryAddress, currentSize + 0x10) == (void *)0x0) {\n                        return 0; \n                    }\n                }\n                \n                endAddress = (undefined4 *)((int)endAddress + ((int)endAddress - (int)memoryAddress >> 2) * 4);\n                \n                DAT_100377cc = __encode_pointer((int)nextAvailableSlot);\n            }\n            \n            *endAddress = inputValue;\n            \n            DAT_100377c8 = __encode_pointer((int)(endAddress + 1));\n            return inputValue; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "_atexit", "Address": "1001152b", "Source Code": "int __cdecl _atexit(_func_4879 *function_pointer) \n{\n    \n    return on_exit_handler((_onexit_t)function_pointer) != (_onexit_t)0x0 ? 0 : -1; \n}"}
{"Function Name": "_memcpy", "Address": "10011540", "Source Code": "void * __cdecl _memcpy(void *_Dst,void *_Src,size_t _Size)\n{\nundefined4 *puVar1;\nuint uVar2;\nuint uVar3;\nundefined4 *puVar4;\nif ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {\npuVar1 = (undefined4 *)((_Size - 4) + (int)_Src);\npuVar4 = (undefined4 *)((_Size - 4) + (int)_Dst);\nif (((uint)puVar4 & 3) == 0) {\nuVar2 = _Size >> 2;\nuVar3 = _Size & 3;\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011723_caseD_2;\ncase 3:\ngoto switchD_10011723_caseD_3;\n}\ngoto switchD_10011723_caseD_1;\n}\n}\nelse {\nswitch(_Size) {\ncase 0:\ngoto switchD_10011723_caseD_0;\ncase 1:\ngoto switchD_10011723_caseD_1;\ncase 2:\ngoto switchD_10011723_caseD_2;\ncase 3:\ngoto switchD_10011723_caseD_3;\ndefault:\nuVar2 = _Size - ((uint)puVar4 & 3);\nswitch((uint)puVar4 & 3) {\ncase 1:\nuVar3 = uVar2 & 3;\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\npuVar1 = (undefined4 *)((int)puVar1 + -1);\nuVar2 = uVar2 >> 2;\npuVar4 = (undefined4 *)((int)puVar4 - 1);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011723_caseD_2;\ncase 3:\ngoto switchD_10011723_caseD_3;\n}\ngoto switchD_10011723_caseD_1;\n}\nbreak;\ncase 2:\nuVar3 = uVar2 & 3;\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\npuVar1 = (undefined4 *)((int)puVar1 + -2);\npuVar4 = (undefined4 *)((int)puVar4 - 2);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011723_caseD_2;\ncase 3:\ngoto switchD_10011723_caseD_3;\n}\ngoto switchD_10011723_caseD_1;\n}\nbreak;\ncase 3:\nuVar3 = uVar2 & 3;\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);\npuVar1 = (undefined4 *)((int)puVar1 + -3);\npuVar4 = (undefined4 *)((int)puVar4 - 3);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011723_caseD_2;\ncase 3:\ngoto switchD_10011723_caseD_3;\n}\ngoto switchD_10011723_caseD_1;\n}\n}\n}\n}\nswitch(uVar2) {\ncase 7:\npuVar4[7 - uVar2] = puVar1[7 - uVar2];\ncase 6:\npuVar4[6 - uVar2] = puVar1[6 - uVar2];\ncase 5:\npuVar4[5 - uVar2] = puVar1[5 - uVar2];\ncase 4:\npuVar4[4 - uVar2] = puVar1[4 - uVar2];\ncase 3:\npuVar4[3 - uVar2] = puVar1[3 - uVar2];\ncase 2:\npuVar4[2 - uVar2] = puVar1[2 - uVar2];\ncase 1:\npuVar4[1 - uVar2] = puVar1[1 - uVar2];\npuVar1 = puVar1 + -uVar2;\npuVar4 = puVar4 + -uVar2;\n}\nswitch(uVar3) {\ncase 1:\nswitchD_10011723_caseD_1:\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\nreturn _Dst;\ncase 2:\nswitchD_10011723_caseD_2:\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\nreturn _Dst;\ncase 3:\nswitchD_10011723_caseD_3:\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\n*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);\nreturn _Dst;\n}\nswitchD_10011723_caseD_0:\nreturn _Dst;\n}\nif (((0xff < _Size) && (DAT_100377fc != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {\npuVar1 = __VEC_memcpy((undefined4 *)_Dst,(undefined4 *)_Src,_Size);\nreturn puVar1;\n}\npuVar1 = (undefined4 *)_Dst;\nif (((uint)_Dst & 3) == 0) {\nuVar2 = _Size >> 2;\nuVar3 = _Size & 3;\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001159c_caseD_2;\ncase 3:\ngoto switchD_1001159c_caseD_3;\n}\ngoto switchD_1001159c_caseD_1;\n}\n}\nelse {\nswitch(_Size) {\ncase 0:\ngoto switchD_1001159c_caseD_0;\ncase 1:\ngoto switchD_1001159c_caseD_1;\ncase 2:\ngoto switchD_1001159c_caseD_2;\ncase 3:\ngoto switchD_1001159c_caseD_3;\ndefault:\nuVar2 = (_Size - 4) + ((uint)_Dst & 3);\nswitch((uint)_Dst & 3) {\ncase 1:\nuVar3 = uVar2 & 3;\n*(undefined *)_Dst = *_Src;\n*(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);\n_Src = (void *)((int)_Src + 3);\npuVar1 = (undefined4 *)((int)_Dst + 3);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001159c_caseD_2;\ncase 3:\ngoto switchD_1001159c_caseD_3;\n}\ngoto switchD_1001159c_caseD_1;\n}\nbreak;\ncase 2:\nuVar3 = uVar2 & 3;\n*(undefined *)_Dst = *_Src;\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);\n_Src = (void *)((int)_Src + 2);\npuVar1 = (undefined4 *)((int)_Dst + 2);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001159c_caseD_2;\ncase 3:\ngoto switchD_1001159c_caseD_3;\n}\ngoto switchD_1001159c_caseD_1;\n}\nbreak;\ncase 3:\nuVar3 = uVar2 & 3;\n*(undefined *)_Dst = *_Src;\n_Src = (void *)((int)_Src + 1);\nuVar2 = uVar2 >> 2;\npuVar1 = (undefined4 *)((int)_Dst + 1);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001159c_caseD_2;\ncase 3:\ngoto switchD_1001159c_caseD_3;\n}\ngoto switchD_1001159c_caseD_1;\n}\n}\n}\n}\nswitch(uVar2) {\ncase 7:\npuVar1[uVar2 - 7] = *(undefined4 *)((int)_Src + (uVar2 - 7) * 4);\ncase 6:\npuVar1[uVar2 - 6] = *(undefined4 *)((int)_Src + (uVar2 - 6) * 4);\ncase 5:\npuVar1[uVar2 - 5] = *(undefined4 *)((int)_Src + (uVar2 - 5) * 4);\ncase 4:\npuVar1[uVar2 - 4] = *(undefined4 *)((int)_Src + (uVar2 - 4) * 4);\ncase 3:\npuVar1[uVar2 - 3] = *(undefined4 *)((int)_Src + (uVar2 - 3) * 4);\ncase 2:\npuVar1[uVar2 - 2] = *(undefined4 *)((int)_Src + (uVar2 - 2) * 4);\ncase 1:\npuVar1[uVar2 - 1] = *(undefined4 *)((int)_Src + (uVar2 - 1) * 4);\n_Src = (void *)((int)_Src + uVar2 * 4);\npuVar1 = puVar1 + uVar2;\n}\nswitch(uVar3) {\ncase 1:\nswitchD_1001159c_caseD_1:\n*(undefined *)puVar1 = *_Src;\nreturn _Dst;\ncase 2:\nswitchD_1001159c_caseD_2:\n*(undefined *)puVar1 = *_Src;\n*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);\nreturn _Dst;\ncase 3:\nswitchD_1001159c_caseD_3:\n*(undefined *)puVar1 = *_Src;\n*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);\n*(undefined *)((int)puVar1 + 2) = *(undefined *)((int)_Src + 2);\nreturn _Dst;\n}\nswitchD_1001159c_caseD_0:\nreturn _Dst;\n}"}
{"Function Name": "_memmove", "Address": "100118b0", "Source Code": "void * __cdecl _memmove(void *_Dst,void *_Src,size_t _Size)\n{\nundefined4 *puVar1;\nuint uVar2;\nuint uVar3;\nundefined4 *puVar4;\nif ((_Src < _Dst) && (_Dst < (void *)(_Size + (int)_Src))) {\npuVar1 = (undefined4 *)((_Size - 4) + (int)_Src);\npuVar4 = (undefined4 *)((_Size - 4) + (int)_Dst);\nif (((uint)puVar4 & 3) == 0) {\nuVar2 = _Size >> 2;\nuVar3 = _Size & 3;\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011a93_caseD_2;\ncase 3:\ngoto switchD_10011a93_caseD_3;\n}\ngoto switchD_10011a93_caseD_1;\n}\n}\nelse {\nswitch(_Size) {\ncase 0:\ngoto switchD_10011a93_caseD_0;\ncase 1:\ngoto switchD_10011a93_caseD_1;\ncase 2:\ngoto switchD_10011a93_caseD_2;\ncase 3:\ngoto switchD_10011a93_caseD_3;\ndefault:\nuVar2 = _Size - ((uint)puVar4 & 3);\nswitch((uint)puVar4 & 3) {\ncase 1:\nuVar3 = uVar2 & 3;\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\npuVar1 = (undefined4 *)((int)puVar1 + -1);\nuVar2 = uVar2 >> 2;\npuVar4 = (undefined4 *)((int)puVar4 - 1);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011a93_caseD_2;\ncase 3:\ngoto switchD_10011a93_caseD_3;\n}\ngoto switchD_10011a93_caseD_1;\n}\nbreak;\ncase 2:\nuVar3 = uVar2 & 3;\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\npuVar1 = (undefined4 *)((int)puVar1 + -2);\npuVar4 = (undefined4 *)((int)puVar4 - 2);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011a93_caseD_2;\ncase 3:\ngoto switchD_10011a93_caseD_3;\n}\ngoto switchD_10011a93_caseD_1;\n}\nbreak;\ncase 3:\nuVar3 = uVar2 & 3;\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);\npuVar1 = (undefined4 *)((int)puVar1 + -3);\npuVar4 = (undefined4 *)((int)puVar4 - 3);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar4 = *puVar1;\npuVar1 = puVar1 + -1;\npuVar4 = puVar4 + -1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_10011a93_caseD_2;\ncase 3:\ngoto switchD_10011a93_caseD_3;\n}\ngoto switchD_10011a93_caseD_1;\n}\n}\n}\n}\nswitch(uVar2) {\ncase 7:\npuVar4[7 - uVar2] = puVar1[7 - uVar2];\ncase 6:\npuVar4[6 - uVar2] = puVar1[6 - uVar2];\ncase 5:\npuVar4[5 - uVar2] = puVar1[5 - uVar2];\ncase 4:\npuVar4[4 - uVar2] = puVar1[4 - uVar2];\ncase 3:\npuVar4[3 - uVar2] = puVar1[3 - uVar2];\ncase 2:\npuVar4[2 - uVar2] = puVar1[2 - uVar2];\ncase 1:\npuVar4[1 - uVar2] = puVar1[1 - uVar2];\npuVar1 = puVar1 + -uVar2;\npuVar4 = puVar4 + -uVar2;\n}\nswitch(uVar3) {\ncase 1:\nswitchD_10011a93_caseD_1:\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\nreturn _Dst;\ncase 2:\nswitchD_10011a93_caseD_2:\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\nreturn _Dst;\ncase 3:\nswitchD_10011a93_caseD_3:\n*(undefined *)((int)puVar4 + 3) = *(undefined *)((int)puVar1 + 3);\n*(undefined *)((int)puVar4 + 2) = *(undefined *)((int)puVar1 + 2);\n*(undefined *)((int)puVar4 + 1) = *(undefined *)((int)puVar1 + 1);\nreturn _Dst;\n}\nswitchD_10011a93_caseD_0:\nreturn _Dst;\n}\nif (((0xff < _Size) && (DAT_100377fc != 0)) && (((uint)_Dst & 0xf) == ((uint)_Src & 0xf))) {\npuVar1 = __VEC_memcpy((undefined4 *)_Dst,(undefined4 *)_Src,_Size);\nreturn puVar1;\n}\npuVar1 = (undefined4 *)_Dst;\nif (((uint)_Dst & 3) == 0) {\nuVar2 = _Size >> 2;\nuVar3 = _Size & 3;\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001190c_caseD_2;\ncase 3:\ngoto switchD_1001190c_caseD_3;\n}\ngoto switchD_1001190c_caseD_1;\n}\n}\nelse {\nswitch(_Size) {\ncase 0:\ngoto switchD_1001190c_caseD_0;\ncase 1:\ngoto switchD_1001190c_caseD_1;\ncase 2:\ngoto switchD_1001190c_caseD_2;\ncase 3:\ngoto switchD_1001190c_caseD_3;\ndefault:\nuVar2 = (_Size - 4) + ((uint)_Dst & 3);\nswitch((uint)_Dst & 3) {\ncase 1:\nuVar3 = uVar2 & 3;\n*(undefined *)_Dst = *_Src;\n*(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)_Dst + 2) = *(undefined *)((int)_Src + 2);\n_Src = (void *)((int)_Src + 3);\npuVar1 = (undefined4 *)((int)_Dst + 3);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001190c_caseD_2;\ncase 3:\ngoto switchD_1001190c_caseD_3;\n}\ngoto switchD_1001190c_caseD_1;\n}\nbreak;\ncase 2:\nuVar3 = uVar2 & 3;\n*(undefined *)_Dst = *_Src;\nuVar2 = uVar2 >> 2;\n*(undefined *)((int)_Dst + 1) = *(undefined *)((int)_Src + 1);\n_Src = (void *)((int)_Src + 2);\npuVar1 = (undefined4 *)((int)_Dst + 2);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001190c_caseD_2;\ncase 3:\ngoto switchD_1001190c_caseD_3;\n}\ngoto switchD_1001190c_caseD_1;\n}\nbreak;\ncase 3:\nuVar3 = uVar2 & 3;\n*(undefined *)_Dst = *_Src;\n_Src = (void *)((int)_Src + 1);\nuVar2 = uVar2 >> 2;\npuVar1 = (undefined4 *)((int)_Dst + 1);\nif (7 < uVar2) {\nfor (; uVar2 != 0; uVar2 = uVar2 - 1) {\n*puVar1 = *_Src;\n_Src = (undefined4 *)((int)_Src + 4);\npuVar1 = puVar1 + 1;\n}\nswitch(uVar3) {\ncase 0:\nreturn _Dst;\ncase 2:\ngoto switchD_1001190c_caseD_2;\ncase 3:\ngoto switchD_1001190c_caseD_3;\n}\ngoto switchD_1001190c_caseD_1;\n}\n}\n}\n}\nswitch(uVar2) {\ncase 7:\npuVar1[uVar2 - 7] = *(undefined4 *)((int)_Src + (uVar2 - 7) * 4);\ncase 6:\npuVar1[uVar2 - 6] = *(undefined4 *)((int)_Src + (uVar2 - 6) * 4);\ncase 5:\npuVar1[uVar2 - 5] = *(undefined4 *)((int)_Src + (uVar2 - 5) * 4);\ncase 4:\npuVar1[uVar2 - 4] = *(undefined4 *)((int)_Src + (uVar2 - 4) * 4);\ncase 3:\npuVar1[uVar2 - 3] = *(undefined4 *)((int)_Src + (uVar2 - 3) * 4);\ncase 2:\npuVar1[uVar2 - 2] = *(undefined4 *)((int)_Src + (uVar2 - 2) * 4);\ncase 1:\npuVar1[uVar2 - 1] = *(undefined4 *)((int)_Src + (uVar2 - 1) * 4);\n_Src = (void *)((int)_Src + uVar2 * 4);\npuVar1 = puVar1 + uVar2;\n}\nswitch(uVar3) {\ncase 1:\nswitchD_1001190c_caseD_1:\n*(undefined *)puVar1 = *_Src;\nreturn _Dst;\ncase 2:\nswitchD_1001190c_caseD_2:\n*(undefined *)puVar1 = *_Src;\n*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);\nreturn _Dst;\ncase 3:\nswitchD_1001190c_caseD_3:\n*(undefined *)puVar1 = *_Src;\n*(undefined *)((int)puVar1 + 1) = *(undefined *)((int)_Src + 1);\n*(undefined *)((int)puVar1 + 2) = *(undefined *)((int)_Src + 2);\nreturn _Dst;\n}\nswitchD_1001190c_caseD_0:\nreturn _Dst;\n}"}
{"Function Name": "__wassert", "Address": "10011c31", "Source Code": "void __cdecl __wassert(wchar_t *_Message,wchar_t *_File,uint _Line)\n{\nwchar_t wVar1;\ncode *pcVar2;\nerrno_t eVar3;\nint iVar4;\nDWORD DVar5;\nuint uVar6;\nwchar_t *pwVar7;\nBOOL BVar8;\nundefined **ppuVar9;\nsize_t sVar10;\nWCHAR *_Dst;\nwchar_t awStackY_6ae [11];\nundefined4 uStackY_698;\nwchar_t *pwVar11;\nchar *_Buf;\nuint *lpNumberOfCharsWritten;\nint iVar12;\nLPVOID lpReserved;\nuint local_670;\nint local_66c;\nwchar_t *local_668;\nuint local_664;\nwchar_t *local_660;\nuchar local_65c [16];\nWCHAR local_64c [44];\nundefined local_5f4 [432];\nushort local_444;\nwchar_t local_440 [270];\nuchar local_224 [450];\nundefined auStack_62 [86];\nundefined local_c;\nuint local_8;\n\nlocal_8 = DAT_100345e0 ^ (uint)local_5f4;\nlocal_660 = _File;\nlocal_668 = _Message;\nlocal_66c = 0;\n__get_osplatform(&local_66c);\nif (local_66c != 1) {\niVar4 = __set_error_mode(3);\nif ((iVar4 == 1) || ((iVar4 = __set_error_mode(3), iVar4 == 0 && (DAT_10035bb0 == 1)))) {\nlocal_668 = (wchar_t *)GetStdHandle(0xfffffff4);\nif ((local_668 != (wchar_t *)0xffffffff) && (local_668 != (wchar_t *)0x0)) {\nuStackY_698 = 0x100123cc;\niVar4 = _swprintf(local_440,(wchar_t *)0x21c);\nif ((-1 < iVar4) && (DVar5 = GetFileType(local_668), DVar5 == 2)) {\nlpReserved = (LPVOID)0x0;\nlpNumberOfCharsWritten = &local_670;\nDVar5 = FUN_1001ae9e(local_440);\nBVar8 = WriteConsoleW(local_668,local_440,DVar5,lpNumberOfCharsWritten,lpReserved);\nif (BVar8 != 0) {\n\n_abort();\n}\n}\n}\nppuVar9 = FUN_1001a6b8();\nif ((*(ushort *)(ppuVar9 + 0x13) & 0x10c) == 0) {\nsVar10 = 0;\niVar4 = 4;\n_Buf = (char *)0x0;\nppuVar9 = FUN_1001a6b8();\n_setvbuf((FILE *)(ppuVar9 + 0x10),_Buf,iVar4,sVar10);\n}\npwVar11 = u_Assertion_failed___s__file__s__l_10034600;\nppuVar9 = FUN_1001a6b8();\n_fwprintf((FILE *)(ppuVar9 + 0x10),pwVar11);\nppuVar9 = FUN_1001a6b8();\nuStackY_698 = 0x10012456;\n_fflush((FILE *)(ppuVar9 + 0x10));\nLAB_10012459:\n\n_abort();\n}\neVar3 = _wcscpy_s(local_440,0x21c,L\"Assertion failed!\");\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034658);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,L\"Program: \");\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\nlocal_444 = 0;\nDVar5 = GetModuleFileNameW((HMODULE)0x0,local_64c,0x104);\nif ((DVar5 == 0) && (eVar3 = _wcscpy_s(local_64c,0x105,L\"<program name unknown>\"), eVar3 != 0))\n{\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n_Dst = local_64c;\niVar4 = FUN_1001ae9e(_Dst);\nif (0x3c < iVar4 + 0xbU) {\niVar4 = FUN_1001ae9e(_Dst);\n_Dst = awStackY_6ae + iVar4;\neVar3 = _wcsncpy_s(_Dst,0x105 - ((int)_Dst - (int)local_64c >> 1),(wchar_t *)PTR_DAT_10034650,\n3);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n}\neVar3 = _wcscat_s(local_440,0x21c,_Dst);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034654);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,L\"File: \");\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\niVar4 = FUN_1001ae9e(local_660);\npwVar11 = local_660;\nif (0x3c < iVar4 + 8U) {\nuVar6 = FUN_1001ae9e(local_660);\npwVar11 = local_660;\nwVar1 = local_660[uVar6 - 1];\nlocal_664 = 1;\nif (wVar1 != L'\\\\') {\npwVar7 = local_660 + (uVar6 - 1);\ndo {\nif ((wVar1 == L'/') || (uVar6 <= local_664)) break;\nlocal_664 = local_664 + 1;\npwVar7 = pwVar7 + -1;\nwVar1 = *pwVar7;\n} while (wVar1 != L'\\\\');\n}\nlocal_670 = uVar6 - local_664;\nif ((local_670 < 0x24) || (0x10 < local_664)) {\nif (local_670 < 0x23) {\nlocal_664 = local_664 >> 1;\neVar3 = _wcsncat_s(local_440,0x21c,local_660,0x31 - local_664);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034650);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\npwVar11 = local_660 + (uVar6 - local_664);\n}\nelse {\neVar3 = _wcsncat_s(local_440,0x21c,local_660,0x20);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034650);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcsncat_s(local_440,0x21c,local_660 + local_670,7);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034650);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\npwVar11 = local_660 + (uVar6 - 7);\n}\n}\nelse {\neVar3 = _wcsncat_s(local_440,0x21c,local_660,0x31 - local_664);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034650);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\npwVar11 = pwVar11 + local_670;\n}\n}\neVar3 = _wcscat_s(local_440,0x21c,pwVar11);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034654);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,L\"Line: \");\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\niVar12 = 10;\niVar4 = FUN_1001ae9e(local_440);\nsVar10 = 0x21c - iVar4;\niVar4 = FUN_1001ae9e(local_440);\neVar3 = __itow_s(_Line,local_440 + iVar4,sVar10,iVar12);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034658);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,L\"Expression: \");\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\niVar4 = FUN_1001ae9e(local_668);\niVar12 = FUN_1001ae9e(local_440);\npwVar11 = local_668;\nif (0x21c < (uint)(iVar4 + 0xb0 + iVar12)) {\niVar4 = FUN_1001ae9e(local_440);\neVar3 = _wcsncat_s(local_440,0x21c,local_668,0x169 - iVar4);\npwVar11 = (wchar_t *)PTR_DAT_10034650;\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n}\neVar3 = _wcscat_s(local_440,0x21c,pwVar11);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034658);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,\nL\"For information on how your program can cause an assertion\\nfailure, see the Visual C++ documentation on asserts\"\n);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,(wchar_t *)PTR_DAT_10034658);\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar3 = _wcscat_s(local_440,0x21c,\nL\"(Press Retry to debug the application - JIT must be enabled)\");\nif (eVar3 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\niVar4 = ___crtMessageBoxW(local_440,L\"Microsoft Visual C++ Runtime Library\",0x12012);\nif (iVar4 == 3) {\n_raise(0x16);\n\n__exit(3);\n}\nif (iVar4 == 4) {\npcVar2 = (code *)swi(3);\n(*pcVar2)();\nreturn;\n}\nif (iVar4 != 5) goto LAB_10012459;\ngoto LAB_1001245e;\n}\nif ((_Message == (wchar_t *)0x0) || (*_Message == L'\\0')) {\nlocal_65c[0] = '\\0';\n}\nelse {\neVar3 = _wcstombs_s((size_t *)0x0,(char *)local_65c,0x21c,_Message,0xffffffff);\nif ((eVar3 != 0) && ((eVar3 == 0x16 || (eVar3 == 0x22)))) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\nif (eVar3 == 0x50) {\nlocal_444 = local_444 & 0xff00;\niVar4 = _strcat_s((char *)local_65c,0x21c,\"...\");\n}\nelse {\nif (eVar3 == 0) goto LAB_10011cfe;\niVar4 = _strcpy_s((char *)local_65c,0x21c,\"Expression cannot be displayed on Win9x\");\n}\nif (iVar4 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n}\nLAB_10011cfe:\nif ((local_660 == (wchar_t *)0x0) || (*local_660 == L'\\0')) {\nlocal_224[0] = '\\0';\n}\nelse {\neVar3 = _wcstombs_s((size_t *)0x0,(char *)local_224,0x21c,local_660,0xffffffff);\nif ((eVar3 != 0) && ((eVar3 == 0x16 || (eVar3 == 0x22)))) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\nif (eVar3 == 0x50) {\nlocal_c = 0;\niVar4 = _strcat_s((char *)local_224,0x21c,\"...\");\n}\nelse {\nif (eVar3 == 0) goto LAB_10011d89;\niVar4 = _strcpy_s((char *)local_65c,0x21c,\"Filename cannot be displayed on Win9x\");\n}\nif (iVar4 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n}\nLAB_10011d89:\n__assert(local_65c,local_224,_Line);\nLAB_1001245e:\n___security_check_cookie_4(local_8 ^ (uint)local_5f4);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_c : undefined1\nLocal Variable: local_224 : undefined1\nLocal Variable: local_440 : undefined1\nLocal Variable: local_444 : undefined2\nLocal Variable: local_5f4 : undefined1\nLocal Variable: local_64c : undefined1\nLocal Variable: local_65c : undefined1\nLocal Variable: local_660 : undefined4\nLocal Variable: local_664 : undefined4\nLocal Variable: local_668 : undefined4\nLocal Variable: local_66c : undefined4\nLocal Variable: local_670 : undefined4"}
{"Function Name": "_fprintf", "Address": "10012476", "Source Code": "int __cdecl _fprintf(FILE *filePointer, char *formatString, ...) {\n    int fileDescriptor; \n    uint fileNumber; \n    \n    if ((filePointer == (FILE *)0x0) || (formatString == (char *)0x0)) {\n        *__errno() = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return -1; \n    }\n    __lock_file(filePointer); \n    \n    if ((*(byte *)&filePointer->_flag & 0x40) == 0) {\n        fileDescriptor = __fileno(filePointer); \n        if (fileDescriptor == -1 || fileDescriptor == -2) {\n            return -1; \n        }\n        fileNumber = __fileno(filePointer); \n        \n        if ((*(undefined *)((fileNumber & 0x1f) * 0x28 + (&DAT_100366a0)[fileDescriptor >> 5] + 0x24) & 0x7f) == 0) {\n            return -1; \n        }\n    }\n    fileDescriptor = __stbuf(filePointer); \n    int outputResult = __output_l(filePointer, formatString, (_locale_t)0x0, &stack0x0000000c); \n    __ftbuf(fileDescriptor, filePointer); \n    FUN_100125bb(); \n    return outputResult; \n}"}
{"Function Name": "__vsnprintf_s_l", "Address": "10012711", "Source Code": "int __cdecl\n__vsnprintf_s_l(char *_DstBuf, size_t _DstSize, size_t _MaxCount, char *_Format, _locale_t _Locale, va_list _ArgList)\n{\n    int *piVar2; \n    int iVar3;   \n    \n    if (_Format == (char *)0x0) {\n        piVar2 = __errno(); \n        *piVar2 = 0x16;     \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return -1; \n    }\n    \n    if (_MaxCount == 0) {\n        \n        if (_DstBuf == (char *)0x0 && _DstSize == 0) {\n            return 0; \n        }\n    } else if (_DstBuf != (char *)0x0) { \n        if (_DstSize != 0) { \n            piVar2 = __errno(); \n            \n            if (_MaxCount < _DstSize) {\n                \n                iVar3 = __vsnprintf_helper(&DAT_1001ccf5, _DstBuf, _MaxCount + 1, (int)_Format, _Locale, _ArgList);\n                \n                if (iVar3 == -2) {\n                    if (*piVar2 != 0x22) { \n                        return -1; \n                    }\n                    return -1; \n                }\n                return iVar3; \n            }\n            \n            iVar3 = __vsnprintf_helper(&DAT_1001ccf5, _DstBuf, _DstSize, (int)_Format, _Locale, _ArgList);\n            _DstBuf[_DstSize - 1] = '\\0'; \n            if (iVar3 != -2) {\n                return -1; \n            }\n        }\n    }\n    \n    \n    piVar2 = __errno(); \n    *piVar2 = 0x16;     \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return -1; \n}"}
{"Function Name": "__isalpha_l", "Address": "10012923", "Source Code": "int __cdecl __isalpha_l(int character, _locale_t locale)\n{\n    uint result; \n    localeinfo_struct localeInfo; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n    \n    \n    if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n        \n        result = *(ushort *)(localeInfo.locinfo[1].lc_category[0].locale + character * 2) & 0x103;\n    } else {\n        \n        result = __isctype_l(character, 0x103, &localeInfo);\n    }\n    \n    return result; \n}"}
{"Function Name": "_isalpha", "Address": "10012977", "Source Code": "int __cdecl _isalpha(int character)\n{\n    \n    if (is_global_zero == 0) {\n        \n        \n        return *(ushort *)(pointer_to_alpha_data + character * 2) & 0x103;\n    }\n    \n    return locale_specific_isalpha(character, (_locale_t)0x0);\n}"}
{"Function Name": "__isupper_l", "Address": "100129a2", "Source Code": "int __cdecl __isupper_l(int character, _locale_t locale)\n{\n    uint isUppercase; \n    localeinfo_struct localeInfo; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n    \n    \n    if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n        \n        isUppercase = (byte)localeInfo.locinfo[1].lc_category[0].locale[character * 2] & 1;\n    } else {\n        \n        isUppercase = __isctype_l(character, 1, &localeInfo);\n    }\n    \n    return isUppercase; \n}"}
{"Function Name": "_isupper", "Address": "100129f1", "Source Code": "int __cdecl _isupper(int character)\n{\n    \n    if (globalFlag == 0) {\n        \n        return (byte)charArray[character * 2] & 1;\n    }\n    \n    return localeIsUpper(character, (_locale_t)0x0);\n}"}
{"Function Name": "__islower_l", "Address": "10012a1a", "Source Code": "int __cdecl __islower_l(int character, _locale_t locale)\n{\n    uint isLowercase; \n    localeinfo_struct localeInfo; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n    \n    \n    if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n        \n        isLowercase = (byte)localeInfo.locinfo[1].lc_category[0].locale[character * 2] & 2;\n    } else {\n        \n        isLowercase = __isctype_l(character, 2, &localeInfo);\n    }\n    \n    return isLowercase; \n}"}
{"Function Name": "_islower", "Address": "10012a69", "Source Code": "int __cdecl _islower(int character)\n{\n    \n    if (is_global_zero == 0) {\n        \n        return (byte)lowercase_check_table[character * 2] & 2;\n    }\n    \n    return locale_specific_islower(character, (_locale_t)0x0);\n}"}
{"Function Name": "__isdigit_l", "Address": "10012a92", "Source Code": "int __cdecl __isdigit_l(int character, _locale_t locale) \n{\n    uint digitCheckResult; \n    localeinfo_struct localeInfo; \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale); \n    \n    if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n        \n        digitCheckResult = (byte)localeInfo.locinfo[1].lc_category[0].locale[character * 2] & 4;\n    } else {\n        \n        digitCheckResult = __isctype_l(character, 4, &localeInfo);\n    }\n    \n    return digitCheckResult; \n}"}
{"Function Name": "_isdigit", "Address": "10012ae1", "Source Code": "int __cdecl _isdigit(int character)\n{\n    \n    if (is_global_zero == 0) {\n        \n        return (byte)digit_lookup_table[character * 2] & 4;\n    }\n    \n    return locale_specific_isdigit(character, (_locale_t)0x0);\n}"}
{"Function Name": "__isspace_l", "Address": "10012b0a", "Source Code": "int __cdecl __isspace_l(int character, _locale_t locale)\n{\n    uint spaceCheckResult; \n    localeinfo_struct localeInfo; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n    \n    \n    if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n        \n        spaceCheckResult = (byte)localeInfo.locinfo[1].lc_category[0].locale[character * 2] & 8;\n    } else {\n        \n        spaceCheckResult = __isctype_l(character, 8, &localeInfo);\n    }\n    \n    return spaceCheckResult; \n}"}
{"Function Name": "_isspace", "Address": "10012b59", "Source Code": "int __cdecl _isspace(int character)\n{\n    \n    if (isGlobalVariableZero == 0) {\n        \n        return (byte)whitespaceCheckArray[character * 2] & 8;\n    }\n    \n    return localeSpecificIsSpaceFunction(character, (_locale_t)0x0);\n}"}
{"Function Name": "__isalnum_l", "Address": "10012b82", "Source Code": "int __cdecl __isalnum_l(int character, _locale_t locale)\n{\n    uint result; \n    localeinfo_struct localeInfo; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n    \n    \n    if ((int)(localeInfo.locinfo)->locale_name[3] < 2) {\n        \n        result = *(ushort *)(localeInfo.locinfo[1].lc_category[0].locale + character * 2) & 0x107;\n    } else {\n        \n        result = __isctype_l(character, 0x107, &localeInfo);\n    }\n    \n    return result; \n}"}
{"Function Name": "_isalnum", "Address": "10012bd6", "Source Code": "int __cdecl _isalnum(int character) \n{\n    if (condition_check == 0) { \n        return *(ushort *)(lookup_table + character * 2) & 0x107; \n    }\n    return locale_specific_check(character, (_locale_t)0x0); \n}"}
{"Function Name": "_strncmp", "Address": "10012d3f", "Source Code": "int __cdecl _strncmp(char *firstString, char *secondString, size_t maxCount)\n{\n    byte *firstStringPtr = (byte *)firstString; \n    byte *secondStringPtr = (byte *)secondString; \n    uint firstCharValue, secondCharValue; \n    uint byteCounter = 0; \n    if (maxCount != 0) { \n        if (maxCount > 3 && maxCount != 4) { \n            do {\n                \n                if ((*firstStringPtr == 0) || (*firstStringPtr != *secondStringPtr)) { \n                    firstCharValue = (uint)*firstStringPtr; \n                    secondCharValue = (uint)*secondStringPtr; \n                    return firstCharValue - secondCharValue; \n                }\n                if ((firstStringPtr[1] == 0) || (firstStringPtr[1] != secondStringPtr[1])) { \n                    firstCharValue = (uint)firstStringPtr[1]; \n                    secondCharValue = (uint)secondStringPtr[1]; \n                    return firstCharValue - secondCharValue; \n                }\n                if ((firstStringPtr[2] == 0) || (firstStringPtr[2] != secondStringPtr[2])) { \n                    firstCharValue = (uint)firstStringPtr[2]; \n                    secondCharValue = (uint)secondStringPtr[2]; \n                    return firstCharValue - secondCharValue; \n                }\n                if ((firstStringPtr[3] == 0) || (firstStringPtr[3] != secondStringPtr[3])) { \n                    firstCharValue = (uint)firstStringPtr[3]; \n                    secondCharValue = (uint)secondStringPtr[3]; \n                    return firstCharValue - secondCharValue; \n                }\n                byteCounter += 4; \n                firstStringPtr += 4; \n                secondStringPtr += 4; \n            } while (byteCounter < maxCount - 4); \n        }\n        for (; byteCounter < maxCount; byteCounter++) { \n            if ((*firstStringPtr == 0) || (*firstStringPtr != *secondStringPtr)) { \n                firstCharValue = (uint)(byte)*firstStringPtr; \n                secondCharValue = (uint)(byte)*secondStringPtr; \n                return firstCharValue - secondCharValue; \n            }\n            firstStringPtr++; \n            secondStringPtr++; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "_strchr", "Address": "10012e10", "Source Code": "char * __cdecl _strchr(char *inputString, int targetChar) \n{\n    uint alignmentMask; \n    uint *unusedPointer; \n    alignmentMask = (uint)inputString & 3; \n    while (alignmentMask != 0) { \n        if (*inputString == (char)targetChar) { \n            return inputString; \n        }\n        if (*inputString == '\\0') { \n            return 0; \n        }\n        alignmentMask = (uint)(uint *)((int)inputString + 1) & 3; \n        inputString = (char *)(uint *)((int)inputString + 1); \n    }\n    while (true) { \n        alignmentMask = *(uint *)inputString; \n        if (((alignmentMask ^ 0xffffffff ^ alignmentMask + 0x7efefeff) & 0x81010100) != 0) break; \n        inputString += 4; \n        if ((alignmentMask ^ CONCAT22(CONCAT11((char)targetChar, (char)targetChar), CONCAT11((char)targetChar, (char)targetChar)) & 0x81010100) != 0) { \n            if ((alignmentMask + 0x7efefeff & 0x80000000) == 0) { \n                return 0; \n            }\n        }\n    }\n    if ((char)alignmentMask == (char)targetChar) { \n        return inputString; \n    }\n    if ((char)alignmentMask == '\\0') { \n        return 0; \n    }\n    if ((char)(alignmentMask >> 8) == (char)targetChar) { \n        return (char *)((int)inputString + 1); \n    }\n    if ((char)(alignmentMask >> 8) == '\\0') { \n        return 0; \n    }\n    if ((char)(alignmentMask >> 0x10) == (char)targetChar) { \n        return (char *)((int)inputString + 2); \n    }\n    if ((char)(alignmentMask >> 0x10) == '\\0') { \n        return 0; \n    }\n    if ((char)(alignmentMask >> 0x18) == (char)targetChar) { \n        return (char *)((int)inputString + 3); \n    }\n    return 0; \n}"}
{"Function Name": "__CRT_INIT@12", "Address": "10012ece", "Source Code": "undefined4 __CRT_INIT_12(undefined4 inputParam, int initRequestType, int fullTermination)\n{\n    HANDLE processHeapHandle; \n    LPOSVERSIONINFOA osVersionInfo; \n    BOOL isVersionRetrieved; \n    int initReturnValue; \n    _ptiddata threadLocalData; \n    code *functionPointer; \n    uint buildNumber; \n    DWORD platformId, majorVersion, minorVersion, unusedVar; \n    SIZE_T memorySize; \n    _ptiddata allocatedThreadLocalData; \n    if (initRequestType == 1) { \n        memorySize = 0x94; \n        processHeapHandle = GetProcessHeap(); \n        osVersionInfo = (LPOSVERSIONINFOA)HeapAlloc(processHeapHandle, 0, memorySize); \n        if (osVersionInfo != (LPOSVERSIONINFOA)0x0) { \n            osVersionInfo->dwOSVersionInfoSize = 0x94; \n            isVersionRetrieved = GetVersionExA(osVersionInfo); \n            if (isVersionRetrieved == 0) { \n                HeapFree(processHeapHandle, 0, osVersionInfo); \n            } else {\n                platformId = osVersionInfo->dwPlatformId; \n                majorVersion = osVersionInfo->dwMajorVersion; \n                minorVersion = osVersionInfo->dwMinorVersion; \n                buildNumber = osVersionInfo->dwBuildNumber & 0x7fff; \n                HeapFree(processHeapHandle, 0, osVersionInfo); \n                if (platformId != 2) { \n                    buildNumber |= 0x8000; \n                }\n                _DAT_10036454 = majorVersion * 0x100 + minorVersion; \n                DAT_1003644c = platformId; \n                _DAT_10036450 = buildNumber; \n                DAT_10036458 = majorVersion; \n                _DAT_1003645c = minorVersion; \n                initReturnValue = __heap_init(); \n                if (initReturnValue != 0) { \n                    initReturnValue = __mtinit(); \n                    if (initReturnValue != 0) { \n                        __RTC_Initialize(); \n                        DAT_10037800 = GetCommandLineA(); \n                        DAT_10035ba4 = ___crtGetEnvironmentStringsA(); \n                        initReturnValue = __ioinit(); \n                        if (initReturnValue >= 0) { \n                            initReturnValue = __setargv(); \n                            if (initReturnValue >= 0 && (initReturnValue = __setenvp(), initReturnValue >= 0) && (initReturnValue = __cinit(0), initReturnValue == 0)) {\n                                DAT_10035ba0++; \n                                return 1; \n                            }\n                            __ioterm(); \n                        }\n                        __mtterm(); \n                    }\n                    __heap_term(); \n                }\n            }\n        }\n    } else if (initRequestType == 0) { \n        if (DAT_10035ba0 > 0) { \n            DAT_10035ba0--; \n            if (DAT_10036488 == 0) { \n                __cexit(); \n            }\n            if (fullTermination == 0) { \n                __ioterm(); \n                __mtterm(); \n                __heap_term(); \n            }\n            return 1; \n        }\n    } else if (initRequestType == 2) { \n        ___set_flsgetvalue(); \n        threadLocalData = (_ptiddata)__calloc_crt(1, 0x214); \n        if (threadLocalData != (_ptiddata)0x0) { \n            initializationValue = DAT_10034748; \n            allocatedThreadLocalData = threadLocalData; \n            functionPointer = (code *)__decode_pointer(DAT_10035ee4); \n            initReturnValue = (*functionPointer)(initializationValue, allocatedThreadLocalData); \n            if (initReturnValue != 0) { \n                __initptd(threadLocalData, (pthreadlocinfo)0x0); \n                threadLocalData->_thandle = 0xffffffff; \n                threadLocalData->_tid = GetCurrentThreadId(); \n                return 1; \n            }\n            _free(threadLocalData); \n        }\n    } else if (initRequestType == 3) { \n        __freeptd((_ptiddata)0x0); \n    }\n    return 0; \n}"}
{"Function Name": "entry", "Address": "1001319d", "Source Code": "void entry(undefined4 inputValue, int isSecurityCheck, int startupParam)\n{\n    \n    if (isSecurityCheck == 1) {\n        \n        ___security_init_cookie();\n    }\n    \n    ___DllMainCRTStartup(startupParam, isSecurityCheck, inputValue);\n}"}
{"Function Name": "___crtLCMapStringA", "Address": "1001357b", "Source Code": "int __cdecl\n___crtLCMapStringA(_locale_t _Plocinfo, LPCWSTR _LocaleName, DWORD _DwMapFlag, LPCSTR _LpSrcStr,\nint _CchSrc, LPSTR _LpDestStr, int _CchDest, int _Code_page, BOOL _BError)\n{\n    int iVar1; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffec, _Plocinfo);\n    \n    \n    iVar1 = __crtLCMapStringA_stat\n    ((localeinfo_struct *)_LocaleName, _DwMapFlag, (ulong)_LpSrcStr, (char *)_CchSrc,\n    (int)_LpDestStr, (char *)_CchDest, _Code_page, _BError, in_stack_ffffffec);\n    \n    \n    return iVar1;\n}"}
{"Function Name": "__malloc_crt", "Address": "100139c8", "Source Code": "void * __cdecl __malloc_crt(size_t size) \n{\n    void *allocatedMemoryPtr; \n    uint waitTime = 0; \n    while (true) { \n        allocatedMemoryPtr = _malloc(size); \n        if (allocatedMemoryPtr != (void *)0x0) { \n            return allocatedMemoryPtr; \n        }\n        if (conditionFlag == 0) break; \n        Sleep(waitTime); \n        waitTime += 1000; \n        if (conditionFlag < waitTime) { \n            waitTime = 0xffffffff; \n        }\n        if (waitTime == 0xffffffff) { \n            return (void *)0x0; \n        }\n    }\n    return (void *)0x0; \n}"}
{"Function Name": "__realloc_crt", "Address": "10013a50", "Source Code": "void * __cdecl __realloc_crt(void *ptr, size_t newSize)\n{\n    void *resultPtr; \n    uint elapsedTime = 0; \n    do {\n        resultPtr = _realloc(ptr, newSize); \n        if (resultPtr != (void *)0x0) { \n            return resultPtr; \n        }\n        if (newSize == 0 || timeout == 0) { \n            return (void *)0x0; \n        }\n        Sleep(elapsedTime); \n        elapsedTime += 1000; \n    } while (elapsedTime < timeout); \n    \n    return (void *)0x0; \n}"}
{"Function Name": "__recalloc_crt", "Address": "10013a9b", "Source Code": "void * __cdecl __recalloc_crt(void *pointer, size_t num_elements, size_t element_size)\n{\n    void *reallocated_memory; \n    uint elapsed_time = 0; \n    do {\n        reallocated_memory = __recalloc(pointer, num_elements, element_size); \n        if (reallocated_memory != (void *)0x0) { \n            return reallocated_memory; \n        }\n        if (element_size == 0 || timeout_duration == 0) { \n            return (void *)0x0; \n        }\n        Sleep(elapsed_time); \n        elapsed_time += 1000; \n    } while (elapsed_time < timeout_duration); \n    \n    return (void *)0x0; \n}"}
{"Function Name": "_strlen", "Address": "10013af0", "Source Code": "size_t __cdecl _strlen(char *inputString) \n{\n    uint alignmentOffset; \n    uint *stringPointer; \n    alignmentOffset = (uint)inputString & 3; \n    stringPointer = (uint *)inputString; \n    while (alignmentOffset != 0) { \n        if (*((char *)stringPointer++) == '\\0') { \n            return (size_t)(stringPointer - (uint *)inputString - 1); \n        }\n        alignmentOffset = (uint)stringPointer & 3; \n    }\n    do { \n        uint fourByteChunk = *stringPointer; \n        if ((char)fourByteChunk == '\\0') { \n            return (size_t)(stringPointer - (uint *)inputString); \n        }\n        if ((char)(fourByteChunk >> 8) == '\\0') { \n            return (size_t)(stringPointer - (uint *)inputString + 1); \n        }\n        if ((fourByteChunk & 0xff0000) == 0) { \n            return (size_t)(stringPointer - (uint *)inputString + 2); \n        }\n    } while ((fourByteChunk & 0xff000000) != 0); \n    return (size_t)(stringPointer - (uint *)inputString - 1); \n}"}
{"Function Name": "__EH_prolog3", "Address": "10013b7b", "Source Code": "void __cdecl __EH_prolog3(int input_value)\n{\n    \n    int negated_value = -input_value;\n    \n    \n    uint stack_values[5];\n    \n    *(undefined4 *)((int)stack_values + negated_value + 0x10) = register_EBX;\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value + 0xc) = register_ESI;\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value + 8) = register_EDI;\n    \n    \n    *(uint *)((int)stack_values + negated_value + 4) = constant_value ^ (uint)&input_value;\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value) = return_address;\n    \n    \n    exception_list = (undefined *)0;\n    \n    \n    return;\n}"}
{"Function Name": "__EH_prolog3_catch", "Address": "10013bae", "Source Code": "void __cdecl __EH_prolog3_catch(int input_param)\n{\n    int negated_param = -input_param; \n    uint local_vars[5]; \n    \n    *(undefined4 *)((int)local_vars + negated_param + 0x10) = register_EBX;\n    \n    *(undefined4 *)((int)local_vars + negated_param + 0xc) = register_ESI;\n    \n    *(undefined4 *)((int)local_vars + negated_param + 8) = register_EDI;\n    \n    *(uint *)((int)local_vars + negated_param + 4) = constant_value ^ (uint)&input_param;\n    \n    *(undefined4 *)((int)local_vars + negated_param) = return_address;\n    exception_list = (undefined *)0; \n    return; \n}"}
{"Function Name": "__EH_epilog3", "Address": "10013be4", "Source Code": "void __EH_epilog3(void)\n{\n    undefined4 *stack_frame_pointer; \n    exception_list = (void *)stack_frame_pointer[-3]; \n    *stack_frame_pointer = stack_frame_pointer[-1]; \n}"}
{"Function Name": "___freetlocinfo", "Address": "10013bf8", "Source Code": "void __cdecl ___freetlocinfo(void *inputParam)\n{\n    int *intPointer; \n    undefined **undefinedPointerArray; \n    int **intPointerArray; \n    \n    if (((*(undefined ***)((int)inputParam + 0xbc) != (undefined **)0x0) && \n        (*(undefined ***)((int)inputParam + 0xbc) != &PTR_DAT_10035640)) && \n        (*(int **)((int)inputParam + 0xb0) != (int *)0x0) && \n        (**(int **)((int)inputParam + 0xb0) == 0)) { \n        \n        intPointer = *(int **)((int)inputParam + 0xb8); \n        if ((intPointer != (int *)0x0) && (*intPointer == 0)) { \n            _free(intPointer); \n            ___free_lconv_mon(*(int *)((int)inputParam + 0xbc)); \n        }\n        \n        intPointer = *(int **)((int)inputParam + 0xb4); \n        if ((intPointer != (int *)0x0) && (*intPointer == 0)) { \n            _free(intPointer); \n            ___free_lconv_num(*(void ***)((int)inputParam + 0xbc)); \n        }\n        \n        _free(*(void **)((int)inputParam + 0xb0)); \n        _free(*(void **)((int)inputParam + 0xbc)); \n    }\n    \n    \n    if ((*(int **)((int)inputParam + 0xc0) != (int *)0x0) && (**(int **)((int)inputParam + 0xc0) == 0)) {\n        _free((void *)(*(int *)((int)inputParam + 0xc4) - 0xfe)); \n        _free((void *)(*(int *)((int)inputParam + 0xcc) - 0x80)); \n        _free((void *)(*(int *)((int)inputParam + 0xd0) - 0x80)); \n        _free(*(void **)((int)inputParam + 0xc0)); \n    }\n    \n    undefinedPointerArray = *(undefined ***)(void **)((int)inputParam + 0xd4); \n    \n    if ((undefinedPointerArray != &PTR_DAT_10035580) && (undefinedPointerArray[0x2d] == (undefined *)0x0)) {\n        ___free_lc_time(undefinedPointerArray); \n        _free(*(void **)((int)inputParam + 0xd4)); \n    }\n    \n    intPointerArray = (int **)((int)inputParam + 0x50); \n    for (int loopCounter = 6; loopCounter > 0; loopCounter--) { \n        \n        if ((intPointerArray[-2] != (int *)&DAT_10035408) && (intPointer = *intPointerArray, intPointer != (int *)0x0) && (*intPointer == 0)) {\n            _free(intPointer); \n        }\n        \n        if ((intPointerArray[-1] != (int *)0x0) && (intPointer = intPointerArray[1], intPointer != (int *)0x0) && (*intPointer == 0)) {\n            _free(intPointer); \n        }\n        intPointerArray += 4; \n    }\n    \n    _free(inputParam); \n}"}
{"Function Name": "___addlocaleref", "Address": "10013d38", "Source Code": "void __cdecl ___addlocaleref(LONG *localRefParam)\n{\n    \n    LONG **longPtrArray = (LONG **)(localRefParam + 0x14);\n    \n    \n    InterlockedIncrement(localRefParam);\n    \n    \n    for (int index = 0; index < 4; index++) {\n        \n        if ((LONG *)localRefParam[0x2c + index] != (LONG *)0x0) {\n            \n            InterlockedIncrement((LONG *)localRefParam[0x2c + index]);\n        }\n    }\n    \n    for (int index = 0; index < 6; index++) {\n        \n        if ((longPtrArray[-2] != (LONG *)&DAT_10035408) && (*longPtrArray != (LONG *)0x0)) {\n            \n            InterlockedIncrement(*longPtrArray);\n        }\n        \n        if ((longPtrArray[-1] != (LONG *)0x0) && (longPtrArray[1] != (LONG *)0x0)) {\n            \n            InterlockedIncrement(longPtrArray[1]);\n        }\n        \n        longPtrArray += 4;\n    }\n    \n    \n    InterlockedIncrement((LONG *)(localRefParam[0x35] + 0xb4));\n}"}
{"Function Name": "___removelocaleref", "Address": "10013dbe", "Source Code": "\\*\nLONG * __cdecl ___removelocaleref(LONG *inputPointer)\n{\n    \n    if (inputPointer != (LONG *)0x0) {\n        \n        InterlockedDecrement(inputPointer);\n        \n        \n        if ((LONG *)inputPointer[0x2c] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x2c]);\n        }\n        \n        \n        if ((LONG *)inputPointer[0x2d] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x2d]);\n        }\n        \n        \n        if ((LONG *)inputPointer[0x2e] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x2e]);\n        }\n        \n        \n        if ((LONG *)inputPointer[0x30] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x30]);\n        }\n        \n        \n        LONG **longPointerArray = (LONG **)(inputPointer + 0x14);\n        \n        \n        for (int index = 0; index < 6; index++) {\n            \n            if ((longPointerArray[-2] != (LONG *)&DAT_10035408) && (*longPointerArray != (LONG *)0x0)) {\n                \n                InterlockedDecrement(*longPointerArray);\n            }\n            \n            if ((longPointerArray[-1] != (LONG *)0x0) && (longPointerArray[1] != (LONG *)0x0)) {\n                \n                InterlockedDecrement(longPointerArray[1]);\n            }\n            \n            longPointerArray += 4;\n        }\n        \n        \n        InterlockedDecrement((LONG *)(inputPointer[0x35] + 0xb4));\n    }\n    \n    \n    return inputPointer;\n}\n*\\ \n \nLONG * __cdecl ___removelocaleref(LONG *inputPointer)\n{\n    if (inputPointer != (LONG *)0x0) {\n        InterlockedDecrement(inputPointer);\n        if ((LONG *)inputPointer[0x2c] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x2c]);\n        }\n        if ((LONG *)inputPointer[0x2d] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x2d]);\n        }\n        if ((LONG *)inputPointer[0x2e] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x2e]);\n        }\n        if ((LONG *)inputPointer[0x30] != (LONG *)0x0) {\n            InterlockedDecrement((LONG *)inputPointer[0x30]);\n        }\n        LONG **longPointerArray = (LONG **)(inputPointer + 0x14);\n        for (int index = 0; index < 6; index++) {\n            if ((longPointerArray[-2] != (LONG *)&DAT_10035408) && (*longPointerArray != (LONG *)0x0)) {\n                InterlockedDecrement(*longPointerArray);\n            }\n            if ((longPointerArray[-1] != (LONG *)0x0) && (longPointerArray[1] != (LONG *)0x0)) {\n                InterlockedDecrement(longPointerArray[1]);\n            }\n            longPointerArray += 4;\n        }\n        InterlockedDecrement((LONG *)(inputPointer[0x35] + 0xb4));\n    }\n    return inputPointer;\n}"}
{"Function Name": "__copytlocinfo_nolock", "Address": "10013e4a", "Source Code": "void __fastcall __copytlocinfo_nolock(LONG *sourceArray)\n{\n    LONG *destinationArray; \n    \n    if (sourceArray != (LONG *)0x0 && destinationArray != (LONG *)0x0 && destinationArray != sourceArray) {\n        \n        for (int counter = 0x36; counter != 0; counter--) {\n            *destinationArray = *sourceArray; \n            sourceArray++;          \n            destinationArray++;          \n        }\n        *destinationArray = 0; \n        ___addlocaleref(destinationArray); \n    }\n    return; \n}"}
{"Function Name": "__updatetlocinfoEx_nolock", "Address": "10013e6e", "Source Code": "LONG * __updatetlocinfoEx_nolock(void)\n{\n    LONG *longPointer;          \n    LONG **inputPointer;         \n    LONG *ediPointer;      \n    \n    if (ediPointer != (LONG *)0x0 && inputPointer != (LONG **)0x0) {\n        longPointer = *inputPointer; \n        \n        if (longPointer != ediPointer) {\n            *inputPointer = ediPointer; \n            ___addlocaleref(ediPointer); \n            \n            if (longPointer != (LONG *)0x0) {\n                ___removelocaleref(longPointer); \n                \n                if (*longPointer == 0 && longPointer != (LONG *)&DAT_10035410) {\n                    ___freetlocinfo(longPointer); \n                }\n            }\n        }\n        return ediPointer; \n    }\n    return (LONG *)0x0; \n}"}
{"Function Name": "_sync_legacy_variables_lk", "Address": "10013f22", "Source Code": "void _sync_legacy_variables_lk(void)\n{\n    \n    dataValue1 = *(undefined4 *)(PTR_DAT_100354e8 + 4);\n    \n    \n    dataValue2 = *(undefined4 *)(PTR_DAT_100354e8 + 8);\n    \n    \n    dataValue3 = *(undefined4 *)(PTR_DAT_100354e8 + 0xa8);\n    \n    \n    ptrValue1 = *(undefined **)(PTR_DAT_100354e8 + 0xd4);\n    \n    \n    ptrValue2 = *(undefined **)(PTR_DAT_100354e8 + 0xbc);\n    \n    \n    ptrData = *(undefined **)(PTR_DAT_100354e8 + 200);\n    \n    \n    dataValue4 = *(undefined4 *)(PTR_DAT_100354e8 + 0xac);\n}"}
{"Function Name": "__strcats", "Address": "10013f75", "Source Code": "void __cdecl __strcats(char *destination, rsize_t size_limit, char *source)\n{\n    errno_t error_code; \n    \n    if (0 < (int)source) {\n        do {\n            \n            error_code = _strcat_s(destination, size_limit, source);\n            \n            if (error_code != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n            }\n            source++; \n        } while (*(source - 1) != 0); \n    }\n    return; \n}"}
{"Function Name": "___lc_strtolc", "Address": "10013fb3", "Source Code": "undefined4 __cdecl ___lc_strtolc(char *param_1, char *param_2)\n{\n    char currentChar; \n    errno_t errorCode; \n    uint maxCharCount; \n    char *inputString = param_2; \n    _memset(param_1, 0, 0x90); \n    if (*param_2 != '\\0') { \n        if ((*param_2 != '.') || (param_2[1] == '\\0')) { \n            maxCharCount = _strcspn(inputString, \"_.,\"); \n            while (true) { \n                if (maxCharCount == 0) { \n                    return 0xffffffff; \n                }\n                currentChar = inputString[maxCharCount]; \n                char *destinationBuffer; \n                rsize_t destinationSize; \n                if (param_2 == (char *)0x0) { \n                    if (0x3f < maxCharCount || currentChar == '.') { \n                        return 0xffffffff; \n                    }\n                    destinationSize = 0x40; \n                    destinationBuffer = param_1; \n                } else if (param_2 == (char *)0x1) { \n                    if (0x3f < maxCharCount || currentChar == '_') { \n                        return 0xffffffff; \n                    }\n                    destinationSize = 0x40; \n                    destinationBuffer = param_1 + 0x40; \n                } else { \n                    if (param_2 != (char *)0x2) { \n                        return 0xffffffff; \n                    }\n                    if (0xf < maxCharCount || (currentChar != '\\0' && currentChar != ',')) { \n                        return 0xffffffff; \n                    }\n                    destinationSize = 0x10; \n                    destinationBuffer = param_1 + 0x80; \n                }\n                errorCode = _strncpy_s(destinationBuffer, destinationSize, inputString, maxCharCount); \n                if (errorCode != 0) { \n                    __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n                }\n                if (currentChar == ',') break; \n                if (currentChar == '\\0') { \n                    return 0; \n                }\n                param_2++; \n                inputString += maxCharCount + 1; \n                maxCharCount = _strcspn(inputString, \"_.,\"); \n            }\n            return 0; \n        }\n        errorCode = _strncpy_s(param_1 + 0x80, 0x10, param_2 + 1, 0xf); \n        if (errorCode != 0) { \n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        }\n        param_1[0x8f] = '\\0'; \n    }\n    return 0; \n}"}
{"Function Name": "___lc_lctostr", "Address": "100140dc", "Source Code": "void __cdecl ___lc_lctostr(char *destination, rsize_t size_limit, char *source)\n{\n    \n    if (_strcpy_s(destination, size_limit, source) != 0) {\n        \n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    \n    \n    if (source[0x40] != '\\0') {\n        \n        __strcats(destination, size_limit, (char *)0x2);\n    }\n    \n    \n    if (source[0x80] != '\\0') {\n        \n        __strcats(destination, size_limit, (char *)0x2);\n    }\n}"}
{"Function Name": "_setlocale", "Address": "10014950", "Source Code": "char * __cdecl _setlocale(int category, char *locale)\n{\n    _ptiddata threadData; \n    LONG *localeData; \n    char *returnLocale = (char *)0x0; \n    if ((uint)category < 6) { \n        threadData = __getptd(); \n        ___updatetlocinfo(); \n        threadData->_ownlocale |= 0x10; \n        localeData = (LONG *)__calloc_crt(0xd8, 1); \n        if (localeData != (LONG *)0x0) { \n            __lock(0xc); \n            __copytlocinfo_nolock(&threadData->ptlocinfo->refcount); \n            FUN_10014a7e(); \n            returnLocale = (char *)__setlocale_nolock((undefined **)locale, (int)localeData, category); \n            if (returnLocale == (char *)0x0) { \n                ___removelocaleref(localeData); \n                ___freetlocinfo(localeData); \n            } else {\n                if (locale != (char *)0x0) { \n                    if (_strcmp(locale, &defaultLocale) != 0) { \n                        localeChangeFlag = 1; \n                    }\n                }\n                __lock(0xc); \n                __updatetlocinfoEx_nolock(); \n                ___removelocaleref(localeData); \n                if (((*(byte *)&threadData->_ownlocale & 2) == 0) && (((byte)localeFlags & 1) == 0)) { \n                    __updatetlocinfoEx_nolock(); \n                    _memcpy(&dataDestination, dataPointer + 0xc, 0x18); \n                    _sync_legacy_variables_lk(); \n                }\n                FUN_10014a8a(); \n            }\n        }\n        FUN_10014abb(); \n    } else {\n        *__errno() = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    return returnLocale; \n}"}
{"Function Name": "__aulldiv", "Address": "10014be0", "Source Code": "undefined8 __aulldiv(uint numerator, uint dividend, uint param_3, uint divisor)\n{\n    ulonglong result; \n    longlong intermediateProduct;  \n    uint quotient;      \n    int integerPart;       \n    uint halvedParam4;      \n    uint shiftedParam2;      \n    uint shiftedParam1;      \n    \n    if (divisor == 0) {\n        quotient = dividend / param_3; \n        \n        integerPart = (int)(((ulonglong)dividend % (ulonglong)param_3 << 0x20 | (ulonglong)numerator) / (ulonglong)param_3);\n    } else {\n        shiftedParam2 = dividend; \n        shiftedParam1 = numerator; \n        do {\n            halvedParam4 = divisor >> 1; \n            \n            shiftedParam1 = shiftedParam1 >> 1 | (uint)((divisor & 1) != 0) << 0x1f;\n            shiftedParam2 = shiftedParam2 >> 1; \n            \n            quotient = quotient >> 1 | (uint)((dividend & 1) != 0) << 0x1f;\n            divisor = halvedParam4; \n            dividend = shiftedParam2; \n        } while (halvedParam4 != 0); \n        result = CONCAT44(shiftedParam2, quotient) / (ulonglong)shiftedParam1; \n        integerPart = (int)result; \n        intermediateProduct = (ulonglong)param_3 * (result & 0xffffffff); \n        quotient = (uint)((ulonglong)intermediateProduct >> 0x20); \n        divisor = quotient + integerPart * divisor; \n        \n        if (CARRY4(quotient, integerPart * divisor) || (dividend < divisor) || (dividend <= divisor && (numerator < (uint)intermediateProduct))) {\n            integerPart = integerPart - 1; \n        }\n        quotient = 0; \n    }\n    return CONCAT44(quotient, integerPart); \n}"}
{"Function Name": "_strcmp", "Address": "10014cc0", "Source Code": "int __cdecl _strcmp(char *str1, char *str2)\n{\n    byte currentByte; \n    bool comparisonResult; \n    \n    if (((uint)str1 & 3) != 0) {\n        \n        if (((uint)str1 & 1) != 0) {\n            currentByte = *str1++; \n            comparisonResult = currentByte < (byte)*str2; \n            if (currentByte != *str2++) goto LAB_10014d04; \n            if (currentByte == 0) return 0; \n            if (((uint)str1 & 2) == 0) goto LAB_10014cd0; \n        }\n        currentByte = *(undefined2 *)str1; \n        str1 += 2; \n        if (currentByte != *str2) goto LAB_10014d04; \n        if (currentByte == 0) return 0; \n        currentByte = (byte)((ushort)currentByte >> 8); \n        if (currentByte != ((byte *)str2)[1]) goto LAB_10014d04; \n        if (currentByte == 0) return 0; \n        str2 += 2; \n    }\nLAB_10014cd0:\n    while (true) {\n        uint fourByteValue = *(uint *)str1; \n        currentByte = (byte)fourByteValue; \n        comparisonResult = currentByte < (byte)*str2; \n        if (currentByte != *str2) break; \n        if (currentByte == 0) return 0; \n        currentByte = (byte)((uint)fourByteValue >> 8); \n        if (currentByte != ((byte *)str2)[1]) break; \n        if (currentByte == 0) return 0; \n        currentByte = (byte)((uint)fourByteValue >> 16); \n        if (currentByte != ((byte *)str2)[2]) break; \n        if (currentByte == 0) return 0; \n        currentByte = (byte)((uint)fourByteValue >> 24); \n        if (currentByte != ((byte *)str2)[3]) break; \n        str2 += 4; \n        str1 += 4; \n    }\nLAB_10014d04:\n    return (uint)comparisonResult * -2 + 1; \n}"}
{"Function Name": "__NMSG_WRITE", "Address": "10014d48", "Source Code": "void __cdecl __NMSG_WRITE(int errorCode)\n{\n    int errorMode; \n    DWORD moduleFileNameResult; \n    size_t stringLength; \n    HANDLE stdErrorHandle; \n    uint errorIndex; \n    errorIndex = 0; \n    do {\n        \n        if (errorCode == (&DAT_10034690)[errorIndex * 2]) break;\n        errorIndex++; \n    } while (errorIndex < 0x17); \n    if (errorIndex < 0x17) { \n        errorMode = __set_error_mode(3); \n        \n        if ((errorMode == 1) || (errorMode == 0 && (DAT_10035bb0 == 1))) {\n            stdErrorHandle = GetStdHandle(0xfffffff4); \n            \n            if (stdErrorHandle != (HANDLE)0x0 && stdErrorHandle != (HANDLE)0xffffffff) {\n                char **errorMessagePointer = (char **)(errorIndex * 8 + 0x10034694); \n                stringLength = _strlen(*errorMessagePointer); \n                DWORD bytesWritten; \n                WriteFile(stdErrorHandle, *errorMessagePointer, stringLength, &bytesWritten, NULL); \n            }\n        }\n    } else if (errorCode != 0xfc) { \n        errno_t copyError = _strcpy_s(&DAT_10035bc8, 0x314, \"Runtime Error!\\n\\nProgram: \"); \n        \n        if (copyError != 0) {\n            __invoke_watson(NULL, NULL, NULL, 0, 0); \n        }\n        DAT_10035ce5 = 0; \n        moduleFileNameResult = GetModuleFileNameA((HMODULE)0x0, &DAT_10035be1, 0x104); \n        \n        if (moduleFileNameResult == 0 && (copyError = _strcpy_s(&DAT_10035be1, 0x2fb, \"<program name unknown>\"), copyError != 0)) {\n            __invoke_watson(NULL, NULL, NULL, 0, 0); \n        }\n        stringLength = _strlen(&DAT_10035be1); \n        \n        if (0x3c < stringLength + 1) {\n            char *truncatedDestination = (char *)((int)&DAT_10035ba4 + stringLength + 2); \n            copyError = _strncpy_s(truncatedDestination, (int)&DAT_10035edc - (int)truncatedDestination, \"...\", 3); \n            \n            if (copyError != 0) {\n                __invoke_watson(NULL, NULL, NULL, 0, 0); \n            }\n        }\n        copyError = _strcat_s(&DAT_10035bc8, 0x314, \"\\n\\n\"); \n        \n        if (copyError != 0) {\n            __invoke_watson(NULL, NULL, NULL, 0, 0); \n        }\n        copyError = _strcat_s(&DAT_10035bc8, 0x314, *(char **)(errorIndex * 8 + 0x10034694)); \n        \n        if (copyError != 0) {\n            __invoke_watson(NULL, NULL, NULL, 0, 0); \n        }\n        ___crtMessageBoxA(&DAT_10035bc8, \"Microsoft Visual C++ Runtime Library\", 0x12010); \n    }\n    return; \n}"}
{"Function Name": "__mtterm", "Address": "10015023", "Source Code": "void __cdecl __mtterm(void)\n{\n    \n    if (global_variable_1 != -1) {\n        \n        (*((code *)__decode_pointer(function_pointer)))(global_variable_1);\n        \n        global_variable_1 = -1;\n    }\n    \n    \n    if (global_variable_2 != 0xffffffff) {\n        \n        TlsFree(global_variable_2);\n        \n        global_variable_2 = 0xffffffff;\n    }\n    \n    \n    __mtdeletelocks();\n}"}
{"Function Name": "__freefls@4", "Address": "100151af", "Source Code": "void __freefls_4(void *input_param)\n{\n    LONG *long_pointer; \n    \n    if (input_param != (void *)0x0) {\n        \n        for (int current_offset = 0x24; current_offset <= 0x48; current_offset += 0x8) {\n            void **current_pointer = *(void ***)((int)input_param + current_offset); \n            \n            if (current_pointer != (void *)0x0) {\n                _free(current_pointer);\n            }\n        }\n        \n        if (*(undefined **)((int)input_param + 0x5c) != &DAT_100354f8) {\n            _free(*(undefined **)((int)input_param + 0x5c)); \n        }\n        __lock(0xd); \n        long_pointer = *(LONG **)((int)input_param + 0x68); \n        \n        if (long_pointer != (LONG *)0x0) {\n            \n            if (InterlockedDecrement(long_pointer) == 0 && long_pointer != (LONG *)&DAT_10034ee0) {\n                _free(long_pointer);\n            }\n        }\n        FUN_100152bb(); \n        __lock(0xc); \n        long_pointer = *(LONG **)((int)input_param + 0x6c); \n        \n        if (long_pointer != (LONG *)0x0) {\n            ___removelocaleref(long_pointer);\n            \n            if (long_pointer != (LONG *)PTR_DAT_100354e8 && long_pointer != (LONG *)&DAT_10035410 && *long_pointer == 0) {\n                ___freetlocinfo(long_pointer); \n            }\n        }\n        FUN_100152c7(); \n        _free(input_param); \n    }\n    return; \n}"}
{"Function Name": "__freeptd", "Address": "100152d0", "Source Code": "void __cdecl __freeptd(_ptiddata threadData)\n{\n    code *functionPointer; \n    int threadId;    \n    \n    if (threadDataId != -1) {\n        \n        if ((threadData == (_ptiddata)0x0) && (TlsGetValue(tlsValue) != (LPVOID)0x0)) {\n            threadId = threadDataId; \n            functionPointer = (code *)TlsGetValue(tlsValue); \n            threadData = (_ptiddata)(*functionPointer)(threadId); \n        }\n        threadId = threadDataId; \n        functionPointer = (code *)__decode_pointer(pointerData); \n        (*functionPointer)(threadId, 0); \n        __freefls_4(threadData); \n    }\n    \n    if (tlsValue != 0xffffffff) {\n        TlsSetValue(tlsValue, (LPVOID)0x0); \n    }\n    return; \n}"}
{"Function Name": "___DestructExceptionObject", "Address": "10015814", "Source Code": "void __cdecl ___DestructExceptionObject(int *exceptionObject)\n{\n    undefined *jumpTable; \n    \n    if (exceptionObject != (int *)0x0 && *exceptionObject == -0x1f928c9d && exceptionObject[7] != 0) {\n        \n        jumpTable = *(undefined **)(exceptionObject[7] + 4);\n        \n        \n        if (jumpTable != (undefined *)0x0) {\n            FID_conflict__CallMemberFunction1(exceptionObject[6], jumpTable);\n        }\n    }\n    return; \n}"}
{"Function Name": "___AdjustPointer", "Address": "10015868", "Source Code": "int __cdecl ___AdjustPointer(int base_value, int *pointer_array)\n{\n    \n    int adjusted_value = *pointer_array + base_value;\n    \n    \n    if (-1 < pointer_array[1]) {\n        \n        adjusted_value += *(int *)(*(int *)(pointer_array[1] + base_value) + pointer_array[2]) + pointer_array[1];\n    }\n    \n    \n    return adjusted_value;\n}"}
{"Function Name": "CallCatchBlock", "Address": "1001594f", "Source Code": "void * __cdecl\nCallCatchBlock(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3,\n_s_FuncInfo *param_4, void *param_5, int param_6, ulong param_7)\n{\n    _ptiddata p_Var1; \n    void *local_20;   \n    p_Var1 = __getptd(); \n    p_Var1->_curexception = param_1; \n    p_Var1->_curcontext = param_3; \n    local_20 = _CallCatchBlock2(param_2, param_4, NULL, (int)param_5, param_6); \n    FUN_10015a75(); \n    return local_20; \n}"}
{"Function Name": "___BuildCatchObjectHelper", "Address": "10015aeb", "Source Code": "char __cdecl ___BuildCatchObjectHelper(int input_param, int *output_param, uint *flags, byte *data_buffer)\n{\n    int validation_result; \n    void *memory_pointer; \n    size_t memory_size; \n    \n    if (((flags[1] == 0) || (*(char *)(flags[1] + 8) == '\\0')) || ((flags[2] == 0 && ((*flags & 0x80000000) == 0)))) {\n        return '\\0'; \n    }\n    \n    \n    if (-1 < (int)*flags) {\n        output_param = (int *)(flags[2] + 0xc + (int)output_param);\n    }\n    \n    \n    memory_pointer = *(void **)(input_param + 0x18);\n    \n    \n    if ((*flags & 8) == 0) {\n        \n        if ((*data_buffer & 1) == 0) {\n            \n            if (*(int *)(data_buffer + 0x18) == 0) {\n                \n                validation_result = _ValidateRead(memory_pointer, 1);\n                \n                if ((validation_result != 0) && (validation_result = _ValidateRead(output_param, 1), validation_result != 0)) {\n                    memory_size = *(size_t *)(data_buffer + 0x14); \n                    \n                    _memmove(output_param, (void *)___AdjustPointer(*(int *)(input_param + 0x18), (int *)(data_buffer + 8)), memory_size);\n                    return '\\0'; \n                }\n            } else {\n                \n                validation_result = _ValidateRead(memory_pointer, 1);\n                \n                if ((validation_result != 0) && (validation_result = _ValidateRead(output_param, 1), validation_result != 0) && (validation_result = _ValidateRead(*(void **)(data_buffer + 0x18), 0), validation_result != 0)) {\n                    return ((*data_buffer & 4) != 0) + '\\x01'; \n                }\n            }\n        } else {\n            \n            validation_result = _ValidateRead(memory_pointer, 1);\n            \n            if ((validation_result != 0) && (validation_result = _ValidateRead(output_param, 1), validation_result != 0)) {\n                \n                _memmove(output_param, memory_pointer, *(size_t *)(data_buffer + 0x14));\n                \n                if (*(int *)(data_buffer + 0x14) != 4) {\n                    return '\\0'; \n                }\n                \n                if (*output_param == 0) {\n                    return '\\0'; \n                }\n                goto LAB_10015b70; \n            }\n        }\n    } else {\n        \n        validation_result = _ValidateRead(memory_pointer, 1);\n        \n        if ((validation_result != 0) && (validation_result = _ValidateRead(output_param, 1), validation_result != 0)) {\n            *output_param = *(int *)(input_param + 0x18); \nLAB_10015b70:\n            *output_param = ___AdjustPointer(*(int *)(input_param + 0x18), (int *)(data_buffer + 8)); \n            return '\\0'; \n        }\n    }\n    _inconsistency(); \n    return '\\0'; \n}"}
{"Function Name": "FindHandlerForForeignException", "Address": "10015d67", "Source Code": "void __cdecl\nFindHandlerForForeignException\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, int param_6, int param_7, EHRegistrationNode *param_8)\n{\n    TypeDescriptor *pTVar1; \n    _ptiddata p_Var2; \n    int iVar4; \n    _s_TryBlockMapEntry *p_Var5; \n    uint uVar6; \n    uint local_8; \n    \n    if (*(int *)param_1 != -0x7ffffffd) {\n        p_Var2 = __getptd(); \n        uVar6 = 0; \n        \n        if (p_Var2->_translator != (void *)0x0) {\n            \n            if (p_Var2->_translator != __encoded_null() && *(int *)param_1 != -0x1fbcb0b3 &&\n                (iVar4 = _CallSETranslator(param_1, param_2, param_3, param_4, param_5, param_7, param_8), iVar4 != 0)) {\n                return; \n            }\n        }\n        \n        if (param_5->nTryBlocks == 0) {\n            _inconsistency(); \n        }\n        \n        p_Var5 = _GetRangeOfTrysToCheck(param_5, param_7, param_6, &local_8, (uint *)&stack0xfffffff4);\n        \n        if (local_8 < uVar6) {\n            do {\n                \n                if ((p_Var5->tryLow <= param_6) && (param_6 <= p_Var5->tryHigh)) {\n                    pTVar1 = p_Var5->pHandlerArray[p_Var5->nCatches - 1].pType; \n                    \n                    if (((pTVar1 == (TypeDescriptor *)0x0) || (*(char *)&pTVar1[1].pVFTable == '\\0')) &&\n                        ((*(byte *)&p_Var5->pHandlerArray[p_Var5->nCatches - 1].adjectives & 0x40) == 0)) {\n                        \n                        CatchIt(param_1, (EHRegistrationNode *)param_3, (_CONTEXT *)param_4, param_5,\n                                (_s_FuncInfo *)0x0, (_s_HandlerType *)param_7, (_s_CatchableType *)param_8);\n                    }\n                }\n                local_8++; \n                p_Var5++; \n            } while (local_8 < uVar6); \n        }\n    }\n    return; \n}"}
{"Function Name": "___InternalCxxFrameHandler", "Address": "100161c7", "Source Code": "undefined4 __cdecl\n___InternalCxxFrameHandler\n(int *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, int param_6, EHRegistrationNode *param_7, uchar param_8)\n{\n    ptiddata p_Var1 = __getptd(); \n    undefined4 uVar2; \n    \n    if ((((*(int *)((p_Var1->_setloc_data)._cacheout + 0x27) != 0) || (*param_1 == -0x1f928c9d)) ||\n        (*param_1 == -0x7fffffda)) ||\n        (((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522 ||\n        ((*(byte *)&param_5->EHFlags & 1) == 0)))) {\n        \n        \n        if ((*(byte *)(param_1 + 1) & 0x66) == 0) {\n            \n            if ((param_5->nTryBlocks != 0) ||\n                ((0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff) &&\n                (param_5->pESTypeList != (ESTypeList *)0x0)))) {\n                \n                \n                if ((*param_1 == -0x1f928c9d) &&\n                    (((2 < (uint)param_1[4] && (0x19930522 < (uint)param_1[5])) &&\n                    (*(code **)(param_1[7] + 8) != (code *)0x0)))) {\n                    \n                    \n                    uVar2 = (**(code **)(param_1[7] + 8))\n                    (param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8);\n                    return uVar2; \n                }\n                \n                FindHandler((EHExceptionRecord *)param_1, param_2, param_3, param_4, param_5, param_8, param_6, param_7);\n            }\n        } else if ((param_5->maxState != 0) && (param_6 == 0)) {\n            \n            ___FrameUnwindToState((int)param_2, param_4, (int)param_5, -1);\n        }\n    }\n    return 1; \n}"}
{"Function Name": "__CallSettingFrame@12", "Address": "10016340", "Source Code": "void __CallSettingFrame_12(undefined4 input_param_1, undefined4 input_param_2, int status_code)\n{\n    code *function_pointer; \n    function_pointer = (code *)__NLG_Notify1(status_code); \n    (*function_pointer)(); \n    if (status_code == 0x100) { \n        status_code = 2; \n    }\n    __NLG_Notify1(status_code); \n}"}
{"Function Name": "___report_gsfailure", "Address": "1001638c", "Source Code": "void __cdecl ___report_gsfailure(void)\n{\n    HANDLE currentProcessHandle; \n    UINT exitCode;  \n    \n    globalFlags =\n        (uint)(in_NT & 1) * 0x4000 | \n        (uint)SBORROW4((int)&stack0xfffffffc, 0x328) * 0x800 | \n        (uint)(in_IF & 1) * 0x200 | \n        (uint)(in_TF & 1) * 0x100 | \n        (uint)((int)&local_32c < 0) * 0x80 | \n        (uint)(&stack0x00000000 == (undefined *)0x32c) * 0x40 | \n        (uint)(in_AF & 1) * 0x10 | \n        (uint)((POPCOUNT((uint)&local_32c & 0xff) & 1U) == 0) * 4 | \n        (uint)(&stack0xfffffffc < (undefined *)0x328) | \n        (uint)(in_ID & 1) * 0x200000 | \n        (uint)(in_VIP & 1) * 0x100000 | \n        (uint)(in_VIF & 1) * 0x80000 | \n        (uint)(in_AC & 1) * 0x40000; \n    \n    specificValue1 = 0x10001; \n    errorExitCode = 0xc0000409; \n    statusFlag = 1; \n    returnAddress = unaff_retaddr; \n    GSsegmentValue = in_GS; \n    FSsegmentValue = in_FS; \n    ESsegmentValue = in_ES; \n    DSsegmentValue = in_DS; \n    EDIregisterValue = unaff_EDI; \n    ESIregisterValue = unaff_ESI; \n    EBXregisterValue = unaff_EBX; \n    EDXregisterValue = in_EDX; \n    ECXregisterValue = in_ECX; \n    EAXregisterValue = in_EAX; \n    EBPregisterValue = unaff_EBP; \n    returnAddressAgain = unaff_retaddr; \n    CSsegmentValue = in_CS; \n    SSsegmentValue = in_SS; \n    \n    \n    if (IsDebuggerPresent() == 0) {\n        FUN_10018eea(); \n    }\n    \n    exitCode = 0xc0000409; \n    currentProcessHandle = GetCurrentProcess(); \n    TerminateProcess(currentProcessHandle, exitCode); \n    return; \n}"}
{"Function Name": "_V6_HeapAlloc", "Address": "10016490", "Source Code": "int * __cdecl _V6_HeapAlloc(uint *input_param)\n{\n    \n    if (input_param <= threshold_value) {\n        \n        acquire_lock(4);\n        \n        return allocate_memory_block(input_param);\n    }\n    \n    return (int *)0x0;\n}"}
{"Function Name": "_malloc", "Address": "100164df", "Source Code": "void * __cdecl _malloc(size_t requested_size) \n{\n    int *error_code_pointer; \n    size_t adjusted_size; \n    \n    if (0xffffffe0 < requested_size) {\n        __callnewh(requested_size); \n        error_code_pointer = __errno(); \n        *error_code_pointer = 0xc; \n        return (void *)0x0; \n    }\n    \n    if (heap_handle == (HANDLE)0x0) {\n        __FF_MSGBANNER(); \n        __NMSG_WRITE(0x1e); \n        ___crtExitProcess(0xff); \n    }\n    \n    if (allocation_condition == 1) {\n        adjusted_size = (requested_size == 0) ? 1 : requested_size; \n    } else if (allocation_condition == 3) {\n        error_code_pointer = _V6_HeapAlloc((uint *)requested_size); \n        if (error_code_pointer != (int *)0x0) {\n            return error_code_pointer; \n        }\n        adjusted_size = (requested_size == 0) ? 1 : requested_size + 0xf & 0xfffffff0; \n    } else {\n        adjusted_size = (requested_size == 0) ? 1 : requested_size + 0xf & 0xfffffff0; \n    }\n    \n    error_code_pointer = (int *)HeapAlloc(heap_handle, 0, adjusted_size);\n    if (error_code_pointer != (int *)0x0) {\n        return error_code_pointer; \n    }\n    \n    if (error_handling_flag == 0) {\n        error_code_pointer = __errno(); \n        *error_code_pointer = 0xc; \n        return (void *)0x0; \n    }\n    \n    if (__callnewh(requested_size) == 0) {\n        error_code_pointer = __errno(); \n        *error_code_pointer = 0xc; \n        return (void *)0x0; \n    }\n}"}
{"Function Name": "_strcpy_s", "Address": "100165ce", "Source Code": "errno_t __cdecl _strcpy_s(char *destination, rsize_t sizeInBytes, char *source)\n{\n    char currentChar; \n    int *errnoPointer; \n    char *destinationPointer = destination; \n    \n    if ((destination != (char *)0x0) && (sizeInBytes != 0)) {\n        \n        if (source != (char *)0x0) {\n            do {\n                currentChar = *source; \n                *destinationPointer = currentChar; \n                source++; \n                if (currentChar == '\\0') break; \n                sizeInBytes--; \n                destinationPointer++; \n            } while (sizeInBytes != 0); \n            \n            if (sizeInBytes != 0) {\n                *destination = '\\0'; \n                return 0; \n            }\n        }\n        *destination = '\\0'; \n    }\n    errnoPointer = __errno(); \n    \n    *errnoPointer = (destination == (char *)0x0) ? 0x16 : 0x22; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return *errnoPointer; \n}"}
{"Function Name": "_fastzero_I", "Address": "100166b2", "Source Code": "void __cdecl _fastzero_I(undefined (*blocks)[16], uint iteration_count)\n{\n    \n    uint remaining_iterations = iteration_count >> 7; \n    \n    \n    do {\n        \n        for (int block_index = 0; block_index < 8; block_index++) {\n            blocks[block_index] = (undefined[16])0x0; \n        }\n        \n        \n        blocks += 8; \n        \n        \n        remaining_iterations--;\n    } while (remaining_iterations != 0); \n}"}
{"Function Name": "__VEC_memzero", "Address": "10016709", "Source Code": "undefined (*) [16] __cdecl __VEC_memzero(undefined (*data) [16], undefined4 size, uint length)\n{\n    \n    uint signBit = (int)data >> 0x1f;\n    \n    \n    int alignmentOffset = (((uint)data ^ signBit) - signBit & 0xf ^ signBit) - signBit;\n    \n    if (alignmentOffset == 0) {\n        \n        signBit = length & 0x7f;\n        \n        \n        if (length != signBit) {\n            _fastzero_I(data, length - signBit);\n        }\n        \n        \n        if (signBit != 0) {\n            \n            undefined *endPointer = (undefined *)((int)data + (length - signBit));\n            \n            \n            for (; signBit != 0; signBit--) {\n                *endPointer++ = 0;\n            }\n        }\n    } else {\n        \n        alignmentOffset = 0x10 - alignmentOffset;\n        \n        \n        undefined (*zeroPointer)[16] = data;\n        \n        \n        for (int bytesToZero = alignmentOffset; bytesToZero != 0; bytesToZero--) {\n            (*zeroPointer)[0] = 0;\n            zeroPointer++;\n        }\n        \n        \n        __VEC_memzero((undefined (*) [16])((int)data + alignmentOffset), 0, length - alignmentOffset);\n    }\n    \n    \n    return data;\n}"}
{"Function Name": "__mtdeletelocks", "Address": "1001691e", "Source Code": "void __cdecl __mtdeletelocks(void)\n{\n    LPCRITICAL_SECTION criticalSectionPointer; \n    LPCRITICAL_SECTION *criticalSectionArray = (LPCRITICAL_SECTION *)&DAT_100348f8; \n    do {\n        criticalSectionPointer = *criticalSectionArray; \n        \n        if (criticalSectionPointer != (LPCRITICAL_SECTION)0x0 && criticalSectionArray[1] != (LPCRITICAL_SECTION)0x1) {\n            DeleteCriticalSection(criticalSectionPointer); \n            _free(criticalSectionPointer); \n            *criticalSectionArray = (LPCRITICAL_SECTION)0x0; \n        }\n        criticalSectionArray += 2; \n    } while ((int)criticalSectionArray < 0x10034a18); \n    criticalSectionArray = (LPCRITICAL_SECTION *)&DAT_100348f8; \n    do {\n        \n        if (*criticalSectionArray != (LPCRITICAL_SECTION)0x0 && criticalSectionArray[1] == (LPCRITICAL_SECTION)0x1) {\n            DeleteCriticalSection(*criticalSectionArray); \n        }\n        criticalSectionArray += 2; \n    } while ((int)criticalSectionArray < 0x10034a18); \n}"}
{"Function Name": "FUN_10016973", "Address": "10016973", "Source Code": "void __cdecl FUN_10016973(int index)\n{\n    \n    LeaveCriticalSection((LPCRITICAL_SECTION)(&criticalSections)[index]);\n}"}
{"Function Name": "FUN_10016ae8", "Address": "10016ae8", "Source Code": "void __thiscall FUN_10016ae8(void *objectReference, int inputParam)\n{\n    void *currentPointer = objectReference; \n    \n    for (; (currentPointer < objectReference && (0xfffff < (uint)(inputParam - *(int *)((int)currentPointer + 0xc))));\n         currentPointer = (void *)((int)currentPointer + 0x14)) {\n        \n    }\n}"}
{"Function Name": "___sbh_free_block", "Address": "10016aef", "Source Code": "void __cdecl ___sbh_free_block(uint *param_1,int param_2)\n{\nint *piVar1;\nchar *pcVar2;\nuint *puVar3;\nint *piVar4;\nchar cVar5;\nuint uVar6;\nuint uVar7;\nbyte bVar8;\nuint uVar9;\nuint *puVar10;\nuint *puVar11;\nuint *puVar12;\nuint uVar13;\nuint uVar14;\nuint local_8;\nuVar6 = param_1[4];\npuVar12 = (uint *)(param_2 + -4);\nuVar14 = param_2 - param_1[3] >> 0xf;\npiVar4 = (int *)(uVar14 * 0x204 + 0x144 + uVar6);\nlocal_8 = *puVar12 - 1;\nif ((local_8 & 1) == 0) {\npuVar10 = (uint *)(local_8 + (int)puVar12);\nuVar13 = *puVar10;\nuVar7 = *(uint *)(param_2 + -8);\nif ((uVar13 & 1) == 0) {\nuVar9 = ((int)uVar13 >> 4) - 1;\nif (0x3f < uVar9) {\nuVar9 = 0x3f;\n}\nif (puVar10[1] == puVar10[2]) {\nif (uVar9 < 0x20) {\npcVar2 = (char *)(uVar9 + 4 + uVar6);\nuVar9 = ~(0x80000000U >> ((byte)uVar9 & 0x1f));\npuVar11 = (uint *)(uVar6 + 0x44 + uVar14 * 4);\n*puVar11 = *puVar11 & uVar9;\n*pcVar2 = *pcVar2 + -1;\nif (*pcVar2 == '\\0') {\n*param_1 = *param_1 & uVar9;\n}\n}\nelse {\npcVar2 = (char *)(uVar9 + 4 + uVar6);\nuVar9 = ~(0x80000000U >> ((byte)uVar9 - 0x20 & 0x1f));\npuVar11 = (uint *)(uVar6 + 0xc4 + uVar14 * 4);\n*puVar11 = *puVar11 & uVar9;\n*pcVar2 = *pcVar2 + -1;\nif (*pcVar2 == '\\0') {\nparam_1[1] = param_1[1] & uVar9;\n}\n}\n}\nlocal_8 = local_8 + uVar13;\n*(uint *)(puVar10[2] + 4) = puVar10[1];\n*(uint *)(puVar10[1] + 8) = puVar10[2];\n}\npuVar10 = (uint *)(((int)local_8 >> 4) - 1);\nif ((uint *)0x3f < puVar10) {\npuVar10 = (uint *)0x3f;\n}\npuVar11 = param_1;\nif ((uVar7 & 1) == 0) {\npuVar12 = (uint *)((int)puVar12 - uVar7);\npuVar11 = (uint *)(((int)uVar7 >> 4) - 1);\nif ((uint *)0x3f < puVar11) {\npuVar11 = (uint *)0x3f;\n}\nlocal_8 = local_8 + uVar7;\npuVar10 = (uint *)(((int)local_8 >> 4) - 1);\nif ((uint *)0x3f < puVar10) {\npuVar10 = (uint *)0x3f;\n}\nif (puVar11 != puVar10) {\nif (puVar12[1] == puVar12[2]) {\nif (puVar11 < (uint *)0x20) {\nuVar13 = ~(0x80000000U >> ((byte)puVar11 & 0x1f));\npuVar3 = (uint *)(uVar6 + 0x44 + uVar14 * 4);\n*puVar3 = *puVar3 & uVar13;\npcVar2 = (char *)((int)puVar11 + uVar6 + 4);\n*pcVar2 = *pcVar2 + -1;\nif (*pcVar2 == '\\0') {\n*param_1 = *param_1 & uVar13;\n}\n}\nelse {\nuVar13 = ~(0x80000000U >> ((byte)puVar11 - 0x20 & 0x1f));\npuVar3 = (uint *)(uVar6 + 0xc4 + uVar14 * 4);\n*puVar3 = *puVar3 & uVar13;\npcVar2 = (char *)((int)puVar11 + uVar6 + 4);\n*pcVar2 = *pcVar2 + -1;\nif (*pcVar2 == '\\0') {\nparam_1[1] = param_1[1] & uVar13;\n}\n}\n}\n*(uint *)(puVar12[2] + 4) = puVar12[1];\n*(uint *)(puVar12[1] + 8) = puVar12[2];\n}\n}\nif (((uVar7 & 1) != 0) || (puVar11 != puVar10)) {\npiVar1 = piVar4 + (int)puVar10 * 2;\nuVar13 = piVar1[1];\npuVar12[2] = (uint)piVar1;\npuVar12[1] = uVar13;\npiVar1[1] = (int)puVar12;\n*(uint **)(puVar12[1] + 8) = puVar12;\nif (puVar12[1] == puVar12[2]) {\ncVar5 = *(char *)((int)puVar10 + uVar6 + 4);\n*(char *)((int)puVar10 + uVar6 + 4) = cVar5 + '\\x01';\nbVar8 = (byte)puVar10;\nif (puVar10 < (uint *)0x20) {\nif (cVar5 == '\\0') {\n*param_1 = *param_1 | 0x80000000U >> (bVar8 & 0x1f);\n}\npuVar10 = (uint *)(uVar6 + 0x44 + uVar14 * 4);\n*puVar10 = *puVar10 | 0x80000000U >> (bVar8 & 0x1f);\n}\nelse {\nif (cVar5 == '\\0') {\nparam_1[1] = param_1[1] | 0x80000000U >> (bVar8 - 0x20 & 0x1f);\n}\npuVar10 = (uint *)(uVar6 + 0xc4 + uVar14 * 4);\n*puVar10 = *puVar10 | 0x80000000U >> (bVar8 - 0x20 & 0x1f);\n}\n}\n}\n*puVar12 = local_8;\n*(uint *)((local_8 - 4) + (int)puVar12) = local_8;\n*piVar4 = *piVar4 + -1;\nif (*piVar4 == 0) {\nif (DAT_10036380 != (uint *)0x0) {\nVirtualFree((LPVOID)(DAT_100377f0 * 0x8000 + DAT_10036380[3]),0x8000,0x4000);\nDAT_10036380[2] = DAT_10036380[2] | 0x80000000U >> ((byte)DAT_100377f0 & 0x1f);\n*(undefined4 *)(DAT_10036380[4] + 0xc4 + DAT_100377f0 * 4) = 0;\n*(char *)(DAT_10036380[4] + 0x43) = *(char *)(DAT_10036380[4] + 0x43) + -1;\nif (*(char *)(DAT_10036380[4] + 0x43) == '\\0') {\nDAT_10036380[1] = DAT_10036380[1] & 0xfffffffe;\n}\nif (DAT_10036380[2] == 0xffffffff) {\nVirtualFree((LPVOID)DAT_10036380[3],0,0x8000);\nHeapFree(DAT_10036228,0,(LPVOID)DAT_10036380[4]);\n_memmove(DAT_10036380,DAT_10036380 + 5,\n(DAT_100377dc * 0x14 - (int)DAT_10036380) + -0x14 + DAT_100377e0);\nDAT_100377dc = DAT_100377dc + -1;\nif (DAT_10036380 < param_1) {\nparam_1 = param_1 + -5;\n}\nDAT_100377e8 = DAT_100377e0;\n}\n}\nDAT_10036380 = param_1;\nDAT_100377f0 = uVar14;\n}\n}\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_c : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4"}
{"Function Name": "___sbh_alloc_new_region", "Address": "10016e03", "Source Code": "undefined4 * ___sbh_alloc_new_region(void)\n{\n    undefined4 *newRegionPtr; \n    \n    if (currentAllocationCount == allocationLimit) {\n        \n        if ((heapPointer = HeapReAlloc(heapHandle, 0, heapPointer, (allocationLimit + 0x10) * 0x14)) == (LPVOID)0x0) {\n            return (undefined4 *)0x0; \n        }\n        allocationLimit += 0x10; \n    }\n    \n    \n    newRegionPtr = (undefined4 *)(currentAllocationCount * 0x14 + (int)heapPointer);\n    \n    \n    if ((newRegionPtr[4] = HeapAlloc(heapHandle, 8, 0x41c4)) != (LPVOID)0x0) {\n        \n        if ((newRegionPtr[3] = VirtualAlloc((LPVOID)0x0, 0x100000, 0x2000, 4)) != (LPVOID)0x0) {\n            newRegionPtr[2] = 0xffffffff; \n            *newRegionPtr = 0; \n            newRegionPtr[1] = 0; \n            currentAllocationCount++; \n            *(undefined4 *)newRegionPtr[4] = 0xffffffff; \n            return newRegionPtr; \n        }\n        \n        HeapFree(heapHandle, 0, (LPVOID)newRegionPtr[4]);\n    }\n    \n    return (undefined4 *)0x0; \n}"}
{"Function Name": "___sbh_alloc_new_group", "Address": "10016eb3", "Source Code": "int __cdecl ___sbh_alloc_new_group(int group_structure)\n{\n    \n    int offset_value = *(int *)(group_structure + 0x10);\n    int group_count = 0;\n    \n    for (int calculated_size = *(int *)(group_structure + 8); -1 < calculated_size; calculated_size *= 2) {\n        group_count++;\n    }\n    \n    int calculated_size = group_count * 0x204 + 0x144 + offset_value;\n    int current_group_address = calculated_size;\n    \n    for (int loop_counter = 0x3f; loop_counter != 0; loop_counter--) {\n        *(int *)(current_group_address + 8) = current_group_address;  \n        *(int *)(current_group_address + 4) = current_group_address;  \n        current_group_address += 8;                   \n    }\n    \n    LPVOID allocation_address = (LPVOID)(group_count * 0x8000 + *(int *)(group_structure + 0xc));\n    \n    LPVOID allocated_memory = VirtualAlloc(allocation_address, 0x8000, 0x1000, 4);\n    \n    \n    if (allocated_memory == (LPVOID)0x0) {\n        return -1; \n    } else {\n        \n        if (allocation_address <= (LPVOID)((int)allocation_address + 0x7000U)) {\n            int *group_entry_pointer = (int *)((int)allocation_address + 0x10);\n            \n            for (int loop_counter = ((uint)((int)(LPVOID)((int)allocation_address + 0x7000U) - (int)allocation_address) >> 0xc) + 1; loop_counter != 0; loop_counter--) {\n                group_entry_pointer[-2] = -1;          \n                group_entry_pointer[0x3fb] = -1;       \n                *group_entry_pointer = (int)(group_entry_pointer + 0x3ff); \n                group_entry_pointer[-1] = 0xff0;       \n                group_entry_pointer[1] = (int)(group_entry_pointer + -0x401); \n                group_entry_pointer[0x3fa] = 0xff0;    \n                group_entry_pointer += 0x400;          \n            }\n        }\n        \n        *(int *)(calculated_size + 0x1fc) = (int)allocation_address + 0xc; \n        *(int *)((int)allocation_address + 0x14) = calculated_size + 0x1f8; \n        *(int *)(calculated_size + 0x200) = (int)allocation_address + 0x700c; \n        *(int *)((int)allocation_address + 0x7010) = calculated_size + 0x1f8; \n        *(undefined4 *)(offset_value + 0x44 + group_count * 4) = 0; \n        *(undefined4 *)(offset_value + 0xc4 + group_count * 4) = 1; \n        \n        char group_increment = *(char *)(offset_value + 0x43);\n        *(char *)(offset_value + 0x43) = group_increment + '\\x01'; \n        \n        if (group_increment == '\\0') {\n            *(uint *)(group_structure + 4) |= 1; \n        }\n        \n        *(uint *)(group_structure + 8) &= ~(0x80000000U >> ((byte)group_count & 0x1f));\n    }\n    return group_count; \n}"}
{"Function Name": "__SEH_prolog4", "Address": "1001757c", "Source Code": "void __cdecl __SEH_prolog4(undefined4 input_param_1, int input_param_2)\n{\n    int negated_param_2; \n    uint stack_values[5]; \n    undefined exception_list[8]; \n    negated_param_2 = -input_param_2; \n    *(undefined4 *)((int)stack_values + negated_param_2 + 0x10) = saved_EBX; \n    *(undefined4 *)((int)stack_values + negated_param_2 + 0xc) = saved_ESI; \n    *(undefined4 *)((int)stack_values + negated_param_2 + 8) = saved_EDI; \n    *(uint *)((int)stack_values + negated_param_2 + 4) = data_value ^ (uint)&input_param_2; \n    *(undefined4 *)((int)stack_values + negated_param_2) = saved_return_address; \n    exception_list_pointer = exception_list; \n    return; \n}"}
{"Function Name": "__SEH_epilog4", "Address": "100175c1", "Source Code": "void __SEH_epilog4(void)\n{\n    undefined4 *base_pointer; \n    exception_list = (void *)base_pointer[-4]; \n    *base_pointer = base_pointer[-1]; \n}"}
{"Function Name": "__except_handler4", "Address": "100175e0", "Source Code": "undefined4 __cdecl __except_handler4(int *param_1, PVOID param_2, undefined4 param_3)\n{\n    int offsetValue; \n    uint tempUnsignedValue; \n    bool isFilterCalled = false; \n    int *securityPointer; \n    undefined4 returnValue = 1; \n    uint currentIndex; \n    \n    securityPointer = (int *)(*(uint *)((int)param_2 + 8) ^ DAT_100345e0);\n    offsetValue = (int)param_2 + 0x10; \n    \n    if (*securityPointer != -2) {\n        \n        ___security_check_cookie_4(securityPointer[1] + offsetValue ^ *(uint *)(*securityPointer + offsetValue));\n    }\n    \n    ___security_check_cookie_4(securityPointer[3] + offsetValue ^ *(uint *)(securityPointer[2] + offsetValue));\n    \n    if ((*(byte *)(param_1 + 1) & 0x66) == 0) {\n        \n        *(int ***)((int)param_2 + -4) = &param_1;\n        currentIndex = *(uint *)((int)param_2 + 0xc); \n        \n        \n        if (currentIndex == 0xfffffffe) {\n            return 1; \n        }\n        \n        \n        do {\n            tempUnsignedValue = securityPointer[currentIndex * 3 + 4]; \n            \n            if ((undefined *)securityPointer[currentIndex * 3 + 5] != (undefined *)0x0) {\n                int filterReturnValue = __EH4_CallFilterFunc_8((undefined *)securityPointer[currentIndex * 3 + 5]); \n                isFilterCalled = true; \n                \n                if (filterReturnValue < 0) {\n                    returnValue = 0; \n                    goto LAB_1001768b; \n                }\n                if (0 < filterReturnValue) {\n                    \n                    if (((*param_1 == -0x1f928c9d) &&\n                        (PTR____DestructExceptionObject_1002e30c != (undefined *)0x0)) &&\n                        __IsNonwritableInCurrentImage((PBYTE)&PTR____DestructExceptionObject_1002e30c)) {\n                        (*(code *)PTR____DestructExceptionObject_1002e30c)(param_1, 1); \n                    }\n                    __EH4_GlobalUnwind_4(param_2); \n                    \n                    if (*(uint *)((int)param_2 + 0xc) != currentIndex) {\n                        __EH4_LocalUnwind_16((int)param_2, currentIndex, offsetValue, &DAT_100345e0); \n                    }\n                    *(uint *)((int)param_2 + 0xc) = tempUnsignedValue; \n                    \n                    if (*securityPointer != -2) {\n                        ___security_check_cookie_4(securityPointer[1] + offsetValue ^ *(uint *)(*securityPointer + offsetValue));\n                    }\n                    ___security_check_cookie_4(securityPointer[3] + offsetValue ^ *(uint *)(securityPointer[2] + offsetValue));\n                    return __EH4_TransferToHandler_8((undefined *)(securityPointer + currentIndex * 3 + 4)[2]); \n                }\n            }\n            currentIndex = tempUnsignedValue; \n        } while (tempUnsignedValue != 0xfffffffe); \n        \n        \n        if (!isFilterCalled) {\n            return 1;\n        }\n    } else {\n        \n        if (*(int *)((int)param_2 + 0xc) == -2) {\n            return 1; \n        }\n        __EH4_LocalUnwind_16((int)param_2, 0xfffffffe, offsetValue, &DAT_100345e0); \n    }\nLAB_1001768b:\n    \n    if (*securityPointer != -2) {\n        ___security_check_cookie_4(securityPointer[1] + offsetValue ^ *(uint *)(*securityPointer + offsetValue));\n    }\n    ___security_check_cookie_4(securityPointer[3] + offsetValue ^ *(uint *)(securityPointer[2] + offsetValue));\n    return returnValue; \n}"}
{"Function Name": "__fassign_l", "Address": "1001787d", "Source Code": "void __cdecl __fassign_l(int statusFlag, char *outputLocation, char *numberString, _locale_t localeParam)\n{\n    \n    if (statusFlag == 0) {\n        \n        FID_conflict___atoflt_l((float *)&statusFlag, numberString, localeParam);\n        \n        *(int *)outputLocation = statusFlag;\n    } else {\n        \n        FID_conflict___atoflt_l((float *)outputLocation, numberString, localeParam);\n        \n        *(float *)outputLocation = *(float *)outputLocation;\n    }\n    \n    return;\n}"}
{"Function Name": "__shift", "Address": "100178d4", "Source Code": "void __shift(void)\n{\n    char *inputDataPointer;          \n    int offsetLength;        \n    if (offsetLength != 0) { \n        \n        \n        _memmove(inputDataPointer + offsetLength, inputDataPointer, _strlen(inputDataPointer) + 1);\n    }\n}"}
{"Function Name": "__cftoe2_l", "Address": "1001790d", "Source Code": "int __cdecl\n__cftoe2_l(uint param_1, int param_2, int param_3, int *param_4, char param_5, localeinfo_struct *param_6)\n{\n    int *piVar1; \n    errno_t eVar2; \n    char *_Dst; \n    int iVar4; \n    int iVar5; \n    int local_14[2]; \n    char local_8; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14, param_6);\n    \n    \n    if (param_1 == 0) {\n        piVar1 = __errno(); \n        iVar4 = 0x16; \n    } else {\n        \n        iVar4 = param_2 < 1 ? 0 : param_2;\n        \n        \n        if (iVar4 + 9U < param_1) {\n            \n            if (param_5 != '\\0') {\n                __shift();\n            }\n            undefined *puVar3 = (undefined *)0x0; \n            \n            if (*param_4 == 0x2d) {\n                puVar3 = (undefined *)0x2d; \n            }\n            \n            if (0 < param_2) {\n                puVar3++;\n                *puVar3 = *(undefined *)**(undefined4 **)(local_14[0] + 0xbc);\n            }\n            \n            _Dst = puVar3 + (uint)(param_5 == '\\0') + param_2;\n            \n            undefined *puVar6 = (param_1 == 0xffffffff) ? (undefined *)0xffffffff : (undefined *)((int)puVar3 + (param_1 - (int)_Dst));\n            \n            eVar2 = _strcpy_s(_Dst, (rsize_t)puVar6, \"e+000\");\n            \n            if (eVar2 != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            }\n            \n            if (param_3 != 0) {\n                *_Dst = 'E';\n            }\n            \n            if (*(char *)param_4[3] != '0') {\n                iVar4 = param_4[1] - 1; \n                if (iVar4 < 0) {\n                    iVar4 = -iVar4; \n                    _Dst[1] = '-'; \n                }\n                \n                if (iVar4 > 99) {\n                    _Dst[2] += (char)(iVar4 / 100); \n                    iVar4 %= 100; \n                }\n                \n                if (iVar4 > 9) {\n                    _Dst[3] += (char)(iVar4 / 10);\n                }\n                \n                _Dst[4] += (char)(iVar4 % 10);\n            }\n            \n            if ((DAT_10036674 & 1) != 0 && _Dst[2] == '0') {\n                _memmove(_Dst + 2, _Dst + 3, 3); \n            }\n            \n            if (local_8 == '\\0') {\n                return (int)puVar6;\n            }\n            *(uint *)(local_c + 0x70) &= 0xfffffffd; \n            return (int)puVar6; \n        }\n        piVar1 = __errno(); \n        iVar4 = 0x22; \n    }\n    iVar5 = 0; \n    *piVar1 = iVar4; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    \n    if (local_8 != '\\0') {\n        *(uint *)(local_c + 0x70) &= 0xfffffffd;\n    }\n    return iVar5; \n}"}
{"Function Name": "__cftoe", "Address": "10017b48", "Source Code": "errno_t __cdecl __cftoe(double *valuePointer, char *buffer, size_t bufferSize, int decimalPlaces, int capitalization)\n{\n    \n    return __cftoe_l(valuePointer, buffer, bufferSize, decimalPlaces, capitalization, (localeinfo_struct *)0x0);\n}"}
{"Function Name": "__cftof2_l", "Address": "10017ed7", "Source Code": "undefined4 __thiscall\n__cftof2_l(void *this, int param_1, size_t param_2, char param_3, localeinfo_struct *param_4)\n{\n    int iVar1; \n    int *in_EAX; \n    undefined *puVar3; \n    undefined4 uVar4; \n    int local_14[2]; \n    iVar1 = in_EAX[1]; \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_14, param_4); \n    if ((this == (void *)0x0) || (param_1 == 0)) { \n        int *piVar2 = __errno(); \n        uVar4 = 0x16; \n        *piVar2 = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    } else {\n        if ((param_3 != '\\0') && (iVar1 - 1U == param_2)) { \n            puVar3 = (undefined *)((uint)(*in_EAX == 0x2d) + (iVar1 - 1U) + (int)this); \n            *puVar3 = 0x30; \n            puVar3[1] = 0; \n        }\n        if (*in_EAX == 0x2d) { \n            *(undefined *)this = 0x2d; \n            this = (void *)((int)this + 1); \n        }\n        if (in_EAX[1] < 1) { \n            __shift(); \n            *(undefined *)this = 0x30; \n            puVar3 = (undefined *)((int)this + 1); \n        } else {\n            puVar3 = (undefined *)((int)this + in_EAX[1]); \n        }\n        if (0 < (int)param_2) { \n            __shift(); \n            *puVar3 = *(undefined *)**(undefined4 **)(local_14[0] + 0xbc); \n            iVar1 = in_EAX[1]; \n            if (iVar1 < 0) { \n                if ((param_3 != '\\0') || (SBORROW4(param_2, -iVar1) == (int)(param_2 + iVar1) < 0)) { \n                    param_2 = -iVar1; \n                }\n                __shift(); \n                _memset(puVar3 + 1, 0x30, param_2); \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "__cfltcvt", "Address": "10018203", "Source Code": "errno_t __cdecl\n__cfltcvt(double *arg, char *buffer, size_t sizeInBytes, int format, int precision, int caps)\n{\n    \n    return __cfltcvt_l(arg, buffer, sizeInBytes, format, precision, caps, (_locale_t)0x0);\n}"}
{"Function Name": "__setdefaultprecision", "Address": "10018243", "Source Code": "void setDefaultPrecision(void)\n{\n    \n    if (setControlFP((uint *)0x0, 0x10000, 0x30000) != 0) {\n        \n        invokeErrorHandler((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n}"}
{"Function Name": "__ms_p5_mp_test_fdiv", "Address": "100182a8", "Source Code": "void __ms_p5_mp_test_fdiv(void)\n{\n    \n    HMODULE kernel32Module = GetModuleHandleA(\"KERNEL32\");\n    \n    \n    if (kernel32Module != NULL) {\n        \n        FARPROC isProcessorFeaturePresentFunc = GetProcAddress(kernel32Module, \"IsProcessorFeaturePresent\");\n        \n        \n        if (isProcessorFeaturePresentFunc != NULL) {\n            \n            (*isProcessorFeaturePresentFunc)(0);\n            return; \n        }\n    }\n    \n    \n    __ms_p5_test_fdiv();\n}"}
{"Function Name": "__tzset_nolock", "Address": "100182d1", "Source Code": "void __tzset_nolock(void)\n{\nchar cVar1;\nchar cVar2;\nint iVar3;\nLPSTR *ppCVar4;\nerrno_t eVar5;\nUINT CodePage;\nchar *_Str1;\nint iVar6;\nsize_t sVar7;\nDWORD DVar8;\nint *piVar9;\nlong lVar10;\nchar *pcVar11;\nint local_34;\nint local_30;\nint local_2c;\nint local_28;\nLPSTR *local_24;\nint local_20 [5];\nundefined4 uStack_c;\nundefined *local_8;\nlocal_8 = &DAT_10032d58;\nuStack_c = 0x100182dd;\nlocal_30 = 0;\nlocal_20[0] = 0;\nlocal_28 = 0;\nlocal_2c = 0;\nlocal_24 = (LPSTR *)0x0;\n__lock(7);\nlocal_8 = (undefined *)0x0;\nlocal_24 = FUN_10018d2d();\neVar5 = __get_timezone(local_20);\nif (eVar5 != 0) {\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar5 = __get_daylight(&local_28);\nif (eVar5 != 0) {\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\neVar5 = __get_dstbias(&local_2c);\nif (eVar5 != 0) {\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\nCodePage = ____lc_codepage_func();\nDAT_10036434 = 0;\nDAT_10034a4c = 0xffffffff;\nDAT_10034a40 = 0xffffffff;\n_Str1 = __getenv_helper_nolock(\"TZ\");\nif ((_Str1 == (char *)0x0) || (*_Str1 == '\\0')) {\nif (DAT_10036438 != (char *)0x0) {\n_free(DAT_10036438);\nDAT_10036438 = (char *)0x0;\n}\nDVar8 = GetTimeZoneInformation((LPTIME_ZONE_INFORMATION)&DAT_10036388);\nif (DVar8 != 0xffffffff) {\nDAT_10036434 = 1;\nlocal_20[0] = DAT_10036388 * 0x3c;\nif (DAT_100363ce != 0) {\nlocal_20[0] = local_20[0] + DAT_100363dc * 0x3c;\n}\nif ((DAT_10036422 == 0) || (DAT_10036430 == 0)) {\nlocal_28 = 0;\nlocal_2c = 0;\n}\nelse {\nlocal_28 = 1;\nlocal_2c = (DAT_10036430 - DAT_100363dc) * 0x3c;\n}\niVar6 = WideCharToMultiByte(CodePage,0,(LPCWSTR)&DAT_1003638c,-1,*local_24,0x3f,(LPCSTR)0x0,\n&local_34);\nif ((iVar6 == 0) || (local_34 != 0)) {\n**local_24 = '\\0';\n}\nelse {\n(*local_24)[0x3f] = '\\0';\n}\niVar6 = WideCharToMultiByte(CodePage,0,(LPCWSTR)&DAT_100363e0,-1,local_24[1],0x3f,(LPCSTR)0x0,\n&local_34);\nif ((iVar6 == 0) || (local_34 != 0)) {\n*local_24[1] = '\\0';\n}\nelse {\nlocal_24[1][0x3f] = '\\0';\n}\n}\n}\nelse {\nif (DAT_10036438 != (char *)0x0) {\niVar6 = _strcmp(_Str1,DAT_10036438);\nif (iVar6 == 0) goto LAB_100184ed;\nif (DAT_10036438 != (char *)0x0) {\n_free(DAT_10036438);\n}\n}\nsVar7 = _strlen(_Str1);\nDAT_10036438 = (char *)__malloc_crt(sVar7 + 1);\nif (DAT_10036438 != (char *)0x0) {\npcVar11 = _Str1;\nsVar7 = _strlen(_Str1);\neVar5 = _strcpy_s(DAT_10036438,sVar7 + 1,pcVar11);\nif (eVar5 != 0) {\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\ngoto LAB_100184f4;\n}\n}\nLAB_100184ed:\nlocal_30 = 1;\nLAB_100184f4:\niVar6 = local_20[0];\npiVar9 = FUN_10018d27();\niVar3 = local_28;\n*piVar9 = iVar6;\npiVar9 = FUN_10018d1b();\niVar6 = local_2c;\n*piVar9 = iVar3;\npiVar9 = FUN_10018d21();\n*piVar9 = iVar6;\nlocal_8 = (undefined *)0xfffffffe;\nFUN_10018580();\nppCVar4 = local_24;\nif (local_30 == 0) {\neVar5 = _strncpy_s(*local_24,0x40,_Str1,3);\nif (eVar5 != 0) {\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\npcVar11 = _Str1 + 3;\ncVar2 = *pcVar11;\nif (cVar2 == '-') {\npcVar11 = _Str1 + 4;\n}\nlVar10 = _atol(pcVar11);\nlocal_20[0] = lVar10 * 0xe10;\nfor (; (cVar1 = *pcVar11, cVar1 == '+' || (('/' < cVar1 && (cVar1 < ':'))));\npcVar11 = pcVar11 + 1) {\n}\nif (*pcVar11 == ':') {\npcVar11 = pcVar11 + 1;\nlVar10 = _atol(pcVar11);\nlocal_20[0] = local_20[0] + lVar10 * 0x3c;\nfor (; ('/' < *pcVar11 && (*pcVar11 < ':')); pcVar11 = pcVar11 + 1) {\n}\nif (*pcVar11 == ':') {\npcVar11 = pcVar11 + 1;\nlVar10 = _atol(pcVar11);\nlocal_20[0] = local_20[0] + lVar10;\nfor (; ('/' < *pcVar11 && (*pcVar11 < ':')); pcVar11 = pcVar11 + 1) {\n}\n}\n}\nif (cVar2 == '-') {\nlocal_20[0] = -local_20[0];\n}\nlocal_28 = (int)*pcVar11;\nif (local_28 == 0) {\n*ppCVar4[1] = '\\0';\n}\nelse {\neVar5 = _strncpy_s(ppCVar4[1],0x40,pcVar11,3);\nif (eVar5 != 0) {\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n}\niVar6 = local_20[0];\npiVar9 = FUN_10018d27();\n*piVar9 = iVar6;\n}\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_20 : undefined4\nLocal Variable: local_24 : undefined4\nLocal Variable: local_28 : undefined4\nLocal Variable: local_2c : undefined4\nLocal Variable: local_30 : undefined4\nLocal Variable: local_34 : undefined4\nLocal Variable: local_38 : undefined4\nLocal Variable: local_3c : undefined4\nLocal Variable: local_40 : undefined4"}
{"Function Name": "__isindst_nolock", "Address": "10018805", "Source Code": "bool __isindst_nolock(void)\n{\n    int *timeData; \n    uint specificValue; \n    int retrievedValue; \n    int calculatedTime; \n    \n    if (__get_daylight(&(int){0}) != 0) {\n        \n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    \n    if (!*(int *)0) {\n        return false; \n    }\n    specificValue = timeData[5]; \n    \n    if ((specificValue != DAT_10034a40) && (specificValue != DAT_10034a4c)) {\n        \n        if (DAT_10036434 == 0) {\n            _cvtdate((void *)0x2, 1, 1, specificValue, 1, 0, 0, 0, 0, 0);\n            _cvtdate((void *)0x2, 0, 1, specificValue, 5, 0, 0, 0, 0, 0);\n        } else {\n            \n            uint conditionValue1 = (uint)(DAT_10036420 == 0 ? DAT_10036424 : 0);\n            uint conditionValue2 = (uint)(DAT_10036420 == 0 ? 0 : DAT_10036426);\n            uint conditionValue3 = (uint)(DAT_10036420 == 0 ? 0 : DAT_10036426);\n            \n            _cvtdate((void *)(uint)DAT_10036428, 1, (uint)(DAT_10036420 == 0), specificValue, conditionValue2, conditionValue1, conditionValue3, (uint)DAT_1003642a, (uint)DAT_1003642c, (uint)DAT_1003642e);\n            \n            conditionValue1 = (uint)(DAT_100363cc == 0 ? DAT_100363d0 : 0);\n            conditionValue2 = (uint)(DAT_100363cc == 0 ? 0 : DAT_100363d2);\n            \n            _cvtdate((void *)(uint)DAT_100363d4, 0, (uint)(DAT_100363cc == 0), specificValue, conditionValue2, conditionValue1, conditionValue3, (uint)DAT_100363d6, (uint)DAT_100363d8, (uint)DAT_100363da);\n        }\n    }\n    retrievedValue = timeData[7]; \n    \n    if (DAT_10034a44 < DAT_10034a50) {\n        \n        if ((retrievedValue < DAT_10034a44) || (DAT_10034a50 < retrievedValue)) {\n            return false; \n        }\n        return (DAT_10034a44 < retrievedValue) && (retrievedValue < DAT_10034a50); \n    } else {\n        \n        if (retrievedValue < DAT_10034a50 || DAT_10034a44 < retrievedValue) {\n            return true; \n        }\n        \n        return (DAT_10034a50 < retrievedValue) && (retrievedValue < DAT_10034a44) ? false : true;\n    }\n    \n    calculatedTime = ((timeData[2] * 0x3c + timeData[1]) * 0x3c + *timeData) * 1000;\n    \n    return (retrievedValue == DAT_10034a44) ? (DAT_10034a48 <= calculatedTime) : (calculatedTime < DAT_10034a54);\n}"}
{"Function Name": "__get_daylight", "Address": "10018c7f", "Source Code": "errno_t __cdecl __get_daylight(int *daylightPointer)\n{\n    \n    if (daylightPointer == (int *)0x0) {\n        \n        *getErrorNumber() = 0x16;\n        \n        handleInvalidParameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        \n        return 0x16;\n    }\n    \n    *daylightPointer = daylightSavingTime;\n    \n    return 0;\n}"}
{"Function Name": "__get_dstbias", "Address": "10018cb3", "Source Code": "errno_t __cdecl __get_dstbias(long *daylightSavingsBias)\n{\n    \n    if (daylightSavingsBias == (long *)0x0) {\n        \n        *__errno() = 0x16;\n        \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        \n        return 0x16;\n    }\n    \n    *daylightSavingsBias = DAT_10034a60;\n    \n    return 0;\n}"}
{"Function Name": "__get_timezone", "Address": "10018ce7", "Source Code": "errno_t __cdecl __get_timezone(long *timezone_ptr)\n{\n    \n    if (timezone_ptr == (long *)0x0) {\n        \n        *get_errno() = 0x16;\n        \n        handle_invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        \n        return 0x16;\n    }\n    \n    *timezone_ptr = timezone_value;\n    \n    return 0;\n}"}
{"Function Name": "__alldiv", "Address": "10018d40", "Source Code": "undefined8 __alldiv(uint dividend, uint divisor, uint multiplicand, uint adjustment) {\n    ulonglong intermediate_result; \n    longlong product_adjustment; \n    uint quotient = dividend; \n    uint shifted_multiplicand = multiplicand; \n    uint shifted_divisor = divisor; \n    uint shift_counter = adjustment; \n    int final_quotient; \n    bool is_negative = (int)divisor < 0; \n    \n    if (is_negative) {\n        is_negative = dividend != 0; \n        dividend = -dividend; \n        divisor = -(uint)is_negative - divisor; \n    }\n    \n    \n    if ((int)adjustment < 0) {\n        is_negative = multiplicand != 0; \n        multiplicand = -multiplicand; \n        adjustment = -(uint)is_negative - adjustment; \n    }\n    \n    \n    if (adjustment == 0) {\n        quotient = divisor / multiplicand; \n        final_quotient = (int)(((ulonglong)divisor % (ulonglong)multiplicand << 0x20 | (ulonglong)dividend) / (ulonglong)multiplicand); \n    } else {\n        \n        do {\n            shift_counter >>= 1; \n            shifted_multiplicand = shifted_multiplicand >> 1 | (uint)((shift_counter & 1) != 0) << 0x1f; \n            shifted_divisor >>= 1; \n            quotient = quotient >> 1 | (uint)((shifted_divisor & 1) != 0) << 0x1f; \n        } while (shift_counter != 0); \n        \n        intermediate_result = CONCAT44(shifted_divisor, quotient) / (ulonglong)shifted_multiplicand; \n        final_quotient = (int)intermediate_result; \n        product_adjustment = (ulonglong)multiplicand * (intermediate_result & 0xffffffff); \n        quotient = (uint)((ulonglong)product_adjustment >> 0x20); \n        shifted_multiplicand = quotient + final_quotient * adjustment; \n        \n        \n        if (CARRY4(quotient, final_quotient * adjustment) || (divisor < shifted_multiplicand) || (divisor <= shifted_multiplicand && (dividend < (uint)product_adjustment))) {\n            final_quotient--; \n        }\n        quotient = 0; \n    }\n    \n    \n    if (is_negative) {\n        final_quotient = -final_quotient; \n        quotient = -(uint)(final_quotient != 0) - quotient; \n    }\n    \n    return CONCAT44(quotient, final_quotient); \n}"}
{"Function Name": "__allrem", "Address": "10018df0", "Source Code": "undefined8 __allrem(uint input1, uint input2, uint input3, uint input4)\n{\n    ulonglong intermediateResult; \n    longlong longResult;  \n    uint result1, result2, shiftedResult1, shiftedResult2, shiftedResult3, shiftedResult4; \n    bool isNonZero1, isNegative2; \n    isNegative2 = (int)input2 < 0; \n    if (isNegative2) {\n        isNonZero1 = input1 != 0; \n        input1 = -input1; \n        input2 = -(uint)isNonZero1 - input2; \n    }\n    if ((int)input4 < 0) { \n        isNegative2 = input3 != 0; \n        input3 = -input3; \n        input4 = -(uint)isNegative2 - input4; \n    }\n    result1 = input1; \n    result2 = input3; \n    shiftedResult2 = input2; \n    shiftedResult3 = input4; \n    if (input4 == 0) { \n        return CONCAT44((uint)(((ulonglong)input2 % (ulonglong)input3 << 0x20 | (ulonglong)input1) % (ulonglong)input3), 0); \n    } else {\n        do {\n            shiftedResult4 = shiftedResult3 >> 1; \n            result2 = result2 >> 1 | (uint)((shiftedResult3 & 1) != 0) << 0x1f; \n            shiftedResult1 = shiftedResult2 >> 1; \n            result1 = result1 >> 1 | (uint)((shiftedResult2 & 1) != 0) << 0x1f; \n            shiftedResult2 = shiftedResult1; \n            shiftedResult3 = shiftedResult4; \n        } while (shiftedResult4 != 0); \n        \n        intermediateResult = CONCAT44(shiftedResult1, result1) / (ulonglong)result2; \n        result1 = (int)intermediateResult * input4; \n        longResult = (intermediateResult & 0xffffffff) * (ulonglong)input3; \n        shiftedResult2 = (uint)((ulonglong)longResult >> 0x20); \n        result2 = (uint)longResult; \n        shiftedResult3 = shiftedResult2 + result1; \n        if (CARRY4(shiftedResult2, result1) || (input2 < shiftedResult3) || ((input2 <= shiftedResult3) && (input1 < result2))) { \n            result2 -= input3; \n            shiftedResult3 -= input4 + (uint)(result2 < input1); \n        }\n        \n        return CONCAT44(shiftedResult3 - input2 - (uint)(result2 < input1), result2 - input1); \n    }\n}"}
{"Function Name": "___getgmtimebuf", "Address": "10018ea2", "Source Code": "___getgmtimebuf(void) \n{\n    _ptiddata threadLocalData; \n    int *errorPointer; \n    tm *timeStructPointer; \n    threadLocalData = __getptd_noexit(); \n    if (threadLocalData == (_ptiddata)0x0) { \n        errorPointer = __errno(); \n        *errorPointer = 0xc; \n        return (tm *)0x0; \n    }\n    if (threadLocalData->_gmtimebuf == (void *)0x0) { \n        threadLocalData->_gmtimebuf = __malloc_crt(0x24); \n        if (threadLocalData->_gmtimebuf == (void *)0x0) { \n            errorPointer = __errno(); \n            *errorPointer = 0xc; \n            return (tm *)0x0; \n        }\n    }\n    return (tm *)threadLocalData->_gmtimebuf; \n}"}
{"Function Name": "__CxxUnhandledExceptionFilter", "Address": "10018ef2", "Source Code": "long __CxxUnhandledExceptionFilter(_EXCEPTION_POINTERS *exceptionPointers)\n{\n    \n    PEXCEPTION_RECORD exceptionRecord = exceptionPointers->ExceptionRecord;\n    ULONG_PTR exceptionInfoValue;\n    \n    \n    if ((exceptionRecord->ExceptionCode == 0xe06d7363) && \n        (exceptionRecord->NumberParameters == 3) && \n        \n        ((exceptionInfoValue = exceptionRecord->ExceptionInformation[0], \n        exceptionInfoValue == 0x19930520 || \n        (exceptionInfoValue == 0x19930521 || \n        (exceptionInfoValue == 0x19930522 || \n        exceptionInfoValue == 0x1994000))))) ) {\n        \n        terminate();\n    }\n    \n    \n    \n    if (globalVariable1 != '\\0' && \n        (code *decodedFunctionPointer = (code *)__decode_pointer(globalVariable2), \n        decodedFunctionPointer != (code *)0x0) && \n        \n        _ValidateRead(decodedFunctionPointer, unreferencedESI)) {\n        \n        return (*decodedFunctionPointer)(exceptionPointers);\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "__flsbuf", "Address": "10018fa3", "Source Code": "int __cdecl __flsbuf(int character, FILE *filePointer)\n{\n    FILE *localFilePointer = filePointer; \n    uint fileFlag = localFilePointer->_flag; \n    \n    if ((fileFlag & 0x82) == 0) {\n        *__errno() = 9; \n        localFilePointer->_flag |= 0x20; \n        return -1; \n    }\n    \n    if ((fileFlag & 0x40) != 0) {\n        *__errno() = 0x22; \n        localFilePointer->_flag |= 0x20; \n        return -1; \n    }\n    \n    if ((fileFlag & 1) != 0) {\n        localFilePointer->_cnt = 0; \n        \n        if ((fileFlag & 0x10) == 0) {\n            localFilePointer->_flag |= 0x20; \n            return -1; \n        }\n        localFilePointer->_ptr = localFilePointer->_base; \n        localFilePointer->_flag &= 0xfffffffe; \n    }\n    \n    localFilePointer->_flag = fileFlag & 0xffffffef | 2;\n    localFilePointer->_cnt = 0; \n    uint writeResult = 0; \n    \n    if (((fileFlag & 0x10c) == 0) &&\n        (FUN_1001a6b8() != (undefined **)(localFilePointer + 8) &&\n        FUN_1001a6b8() != (undefined **)(localFilePointer + 0x10) ||\n        __isatty((int)filePointer) == 0)) {\n        __getbuf(localFilePointer); \n    }\n    \n    if ((*(ushort *)&localFilePointer->_flag & 0x108) == 0) {\n        writeResult = __write((int)filePointer, &character, 1); \n    } else {\n        char *bufferBase = localFilePointer->_base; \n        char *currentPointer = localFilePointer->_ptr; \n        localFilePointer->_ptr = bufferBase + 1; \n        fileFlag = (int)currentPointer - (int)bufferBase; \n        localFilePointer->_cnt = localFilePointer->_bufsiz - 1; \n        \n        if ((int)fileFlag < 1) {\n            undefined *seekablePointer = (undefined *)(((uint)filePointer & 0x1f) * 0x28 + (&DAT_100366a0)[(int)filePointer >> 5]);\n            \n            if (((seekablePointer[4] & 0x20) != 0) &&\n                __lseeki64((int)filePointer, 0x200000000, 0) == -1) {\n                localFilePointer->_flag |= 0x20; \n                return -1; \n            }\n        } else {\n            writeResult = __write((int)filePointer, bufferBase, fileFlag); \n        }\n        *localFilePointer->_base = (char)character; \n    }\n    \n    if (writeResult == fileFlag) {\n        return character & 0xff; \n    }\n    localFilePointer->_flag |= 0x20; \n    return -1; \n}"}
{"Function Name": "_strtol", "Address": "10019d10", "Source Code": "long __cdecl _strtol(char *inputString, char **endPointer, int base)\n{\n    \n    return strtoxl(\n        (conditionFlag == 0) ? &pointerValue : (undefined **)0x0, \n        inputString,                       \n        endPointer,                    \n        base,                     \n        0                           \n    );\n}"}
{"Function Name": "FUN_10019e00", "Address": "10019e00", "Source Code": "void __cdecl FUN_10019e00(undefined4 exitCode)\n{\n    \n    HMODULE moduleHandle = GetModuleHandleA(\"mscoree.dll\");\n    \n    \n    if (moduleHandle != (HMODULE)0x0) {\n        \n        FARPROC exitProcessFunction = GetProcAddress(moduleHandle, \"CorExitProcess\");\n        \n        \n        if (exitProcessFunction != (FARPROC)0x0) {\n            \n            (*exitProcessFunction)(exitCode);\n        }\n    }\n}"}
{"Function Name": "___crtExitProcess", "Address": "10019e26", "Source Code": "void __cdecl ___crtExitProcess(int exitCode) \n{\n    FUN_10019e00(exitCode); \n    ExitProcess(exitCode);   \n}"}
{"Function Name": "__initterm", "Address": "10019e4d", "Source Code": "void __cdecl __initterm(undefined **function_array)\n{\n    code **current_function_pointer = function_array; \n    while (current_function_pointer-- > (code **)0x0) { \n        if (*current_function_pointer != (code *)0x0) { \n            (**current_function_pointer)(); \n        }\n    }\n}"}
{"Function Name": "__initterm_e", "Address": "10019e65", "Source Code": "void __cdecl __initterm_e(undefined **function_ptr_start, undefined **function_ptr_end)\n{\n    \n    while (function_ptr_start < function_ptr_end) {\n        \n        if ((code *)*function_ptr_start != (code *)0x0) {\n            \n            if ((*(code *)*function_ptr_start)() != 0) {\n                \n                return;\n            }\n        }\n        \n        function_ptr_start++;\n    }\n}"}
{"Function Name": "__get_osplatform", "Address": "10019e85", "Source Code": "undefined4 __cdecl __get_osplatform(int *output_param)\n{\n    \n    if ((output_param != (int *)0x0) && (os_platform_value != 0)) {\n        \n        *output_param = os_platform_value;\n        \n        return 0;\n    }\n    \n    error_array()[0] = 0x16;\n    \n    invalid_param_handler((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    \n    return 0x16;\n}"}
{"Function Name": "__get_winmajor", "Address": "10019ebc", "Source Code": "undefined4 __cdecl __get_winmajor(undefined4 *input_param)\n{\n    \n    if (input_param != (undefined4 *)0x0 && global_var_check != 0) {\n        \n        *input_param = global_var_value;\n        \n        return 0;\n    }\n    \n    *error_number() = 0x16;\n    \n    invalid_param_handler((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    \n    return 0x16;\n}"}
{"Function Name": "__init_pointers", "Address": "1001a078", "Source Code": "void __cdecl initializePointers(void)\n{\n    \n    undefined4 encodedNullValue = getEncodedNull();\n    \n    \n    initializeFunction1(encodedNullValue);\n    initializeFunction2(encodedNullValue);\n    initializeFunction3(encodedNullValue);\n    initializeFunction4(encodedNullValue);\n    initializeFunction5(encodedNullValue);\n    \n    \n    initializeMiscWindowsSignal(encodedNullValue);\n    \n    \n    performAdditionalInitialization();\n    \n    \n    initializeExceptionHandlingHooks();\n    \n    \n    exitFunctionPointer = (undefined *)encodePointer(0x1001a058);\n}"}
{"Function Name": "FUN_1001a0c4", "Address": "1001a0c4", "Source Code": "void __cdecl FUN_1001a0c4(undefined4 *destination, undefined4 *source, uint num_iterations)\n{\n    \n    uint iteration_count = num_iterations >> 7;\n    \n    do {\n        \n        for (int index = 0; index < 32; index++) {\n            destination[index] = source[index];\n        }\n        \n        source += 0x20;\n        destination += 0x20;\n        \n        iteration_count--;\n    } while (iteration_count != 0); \n}"}
{"Function Name": "__VEC_memcpy", "Address": "1001a14b", "Source Code": "\\*\nundefined4 * __cdecl __VEC_memcpy(undefined4 *dest_ptr, undefined4 *src_ptr, uint byte_count)\n{\n    \n    uint sign_bit_src = (int)src_ptr >> 0x1f;\n    sign_bit_src = (((uint)src_ptr ^ sign_bit_src) - sign_bit_src & 0xf ^ sign_bit_src) - sign_bit_src;\n    \n    uint sign_bit_dest = (int)dest_ptr >> 0x1f;\n    sign_bit_dest = (((uint)dest_ptr ^ sign_bit_dest) - sign_bit_dest & 0xf ^ sign_bit_dest) - sign_bit_dest;\n    \n    if ((sign_bit_src | sign_bit_dest) == 0) {\n        \n        sign_bit_src = byte_count & 0x7f;\n        \n        if (byte_count != sign_bit_src) {\n            FUN_1001a0c4(dest_ptr, src_ptr, byte_count - sign_bit_src);\n        }\n        \n        if (sign_bit_src != 0) {\n            undefined *puVar5 = (undefined *)((int)src_ptr + (byte_count - sign_bit_src));\n            undefined *puVar7 = (undefined *)((int)dest_ptr + (byte_count - sign_bit_src));\n            for (; sign_bit_src != 0; sign_bit_src--) {\n                *puVar7++ = *puVar5++; \n            }\n        }\n    } \n    \n    else if (sign_bit_src == sign_bit_dest) {\n        int bytes_to_copy = 0x10 - sign_bit_src; \n        for (int remaining_bytes = bytes_to_copy; remaining_bytes != 0; remaining_bytes--) {\n            *(undefined *)dest_ptr++ = *(undefined *)src_ptr++; \n        }\n        __VEC_memcpy(dest_ptr, src_ptr, byte_count - bytes_to_copy); \n    } \n    \n    else {\n        \n        for (sign_bit_src = byte_count >> 2; sign_bit_src != 0; sign_bit_src--) {\n            *dest_ptr++ = *src_ptr++;\n        }\n        \n        for (sign_bit_src = byte_count & 3; sign_bit_src != 0; sign_bit_src--) {\n            *(undefined *)dest_ptr++ = *(undefined *)src_ptr++;\n        }\n    }\n    return dest_ptr; \n}\n*\\ \n \nundefined4 * __cdecl __VEC_memcpy(undefined4 *dest_ptr, undefined4 *src_ptr, uint byte_count)\n{\n    uint sign_bit_src = (int)src_ptr >> 0x1f;\n    sign_bit_src = (((uint)src_ptr ^ sign_bit_src) - sign_bit_src & 0xf ^ sign_bit_src) - sign_bit_src;\n    uint sign_bit_dest = (int)dest_ptr >> 0x1f;\n    sign_bit_dest = (((uint)dest_ptr ^ sign_bit_dest) - sign_bit_dest & 0xf ^ sign_bit_dest) - sign_bit_dest;\n    if ((sign_bit_src | sign_bit_dest) == 0) {\n        sign_bit_src = byte_count & 0x7f;\n        if (byte_count != sign_bit_src) {\n            FUN_1001a0c4(dest_ptr, src_ptr, byte_count - sign_bit_src);\n        }\n        if (sign_bit_src != 0) {\n            undefined *puVar5 = (undefined *)((int)src_ptr + (byte_count - sign_bit_src));\n            undefined *puVar7 = (undefined *)((int)dest_ptr + (byte_count - sign_bit_src));\n            for (; sign_bit_src != 0; sign_bit_src--) {\n                *puVar7++ = *puVar5++;\n            }\n        }\n    } else if (sign_bit_src == sign_bit_dest) {\n        int bytes_to_copy = 0x10 - sign_bit_src;\n        for (int remaining_bytes = bytes_to_copy; remaining_bytes != 0; remaining_bytes--) {\n            *(undefined *)dest_ptr++ = *(undefined *)src_ptr++;\n        }\n        __VEC_memcpy(dest_ptr, src_ptr, byte_count - bytes_to_copy);\n    } else {\n        for (sign_bit_src = byte_count >> 2; sign_bit_src != 0; sign_bit_src--) {\n            *dest_ptr++ = *src_ptr++;\n        }\n        for (sign_bit_src = byte_count & 3; sign_bit_src != 0; sign_bit_src--) {\n            *(undefined *)dest_ptr++ = *(undefined *)src_ptr++;\n        }\n    }\n    return dest_ptr;\n}"}
{"Function Name": "__fflush_nolock", "Address": "1001a3ae", "Source Code": "int __cdecl flush_without_lock(FILE *file_pointer)\n{\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        return _flsall(0);\n    }\n    \n    if (flush_stream(file_pointer) != 0) {\n        \n        return -1;\n    }\n    \n    if ((file_pointer->_flag & 0x4000) != 0) {\n        \n        return -(commit_changes(get_file_number(file_pointer)) != 0);\n    }\n    \n    return 0;\n}"}
{"Function Name": "_flsall", "Address": "1001a3f0", "Source Code": "int __cdecl _flsall(int flush_mode) \n{\n    void **file_stream_ptr; \n    FILE *file_pointer; \n    int flush_result; \n    int stream_index; \n    int successful_flush_count = 0; \n    __lock(1); \n    for (stream_index = 0; stream_index < DAT_100377c0; stream_index++) { \n        file_stream_ptr = (void **)(DAT_100367a0 + stream_index * 4); \n        if ((*file_stream_ptr != (void *)0x0) && (*(byte *)((int)(*file_stream_ptr) + 0xc) & 0x83) != 0) { \n            __lock_file2(stream_index, *file_stream_ptr); \n            file_pointer = *(FILE **)(DAT_100367a0 + stream_index * 4); \n            if ((file_pointer->_flag & 0x83U) != 0) { \n                if (flush_mode == 1) { \n                    flush_result = __fflush_nolock(file_pointer); \n                    if (flush_result != -1) { \n                        successful_flush_count++; \n                    }\n                } else if (flush_mode == 0 && ((file_pointer->_flag & 2U) != 0)) { \n                    flush_result = __fflush_nolock(file_pointer); \n                    if (flush_result == -1) { \n                        return -1; \n                    }\n                }\n            }\n            FUN_1001a492(); \n        }\n    }\n    FUN_1001a4c1(); \n    return (flush_mode != 1) ? -1 : successful_flush_count; \n}"}
{"Function Name": "_fflush", "Address": "1001a4ca", "Source Code": "int __cdecl _fflush(FILE *file_pointer)\n{\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        return _flsall(0);\n    } else {\n        \n        __lock_file(file_pointer);\n        \n        int flush_result = __fflush_nolock(file_pointer);\n        \n        FUN_1001a513();\n        \n        return flush_result;\n    }\n}"}
{"Function Name": "_setvbuf", "Address": "1001a5ba", "Source Code": "int __cdecl _setvbuf(FILE *file_pointer, char *user_buffer, int mode, size_t requested_size)\n{\n    uint updated_flag; \n    uint adjusted_size; \n    \n    if (file_pointer == (FILE *)0x0) goto LAB_1001a5d9;\n    \n    if (mode == 4) {\n        if ((mode == 0) || (mode == 0x40)) goto LAB_1001a613;\n    } else {\n        \n        if (mode != 0 && mode != 0x40) goto LAB_1001a5d9;\n    }\nLAB_1001a613:\n    \n    if (0x7ffffffd < requested_size - 2) {\nLAB_1001a5d9:\n        int *errno_pointer = __errno(); \n        *errno_pointer = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return -1; \n    }\n    adjusted_size = requested_size & 0xfffffffe; \n    __lock_file(file_pointer); \n    __flush(file_pointer); \n    __freebuf(file_pointer); \n    file_pointer->_flag = file_pointer->_flag & 0xffffc2f3; \n    \n    if ((mode & 4U) == 0) {\n        if (user_buffer != (char *)0x0) { \n            updated_flag = file_pointer->_flag | 0x500; \n        } else { \n            user_buffer = (char *)__malloc_crt(adjusted_size); \n            if ((int *)user_buffer == (int *)0x0) { \n                _DAT_10036490 = _DAT_10036490 + 1; \n                return -1; \n            }\n            file_pointer->_flag = file_pointer->_flag | 0x408; \n        }\n    } else { \n        updated_flag = file_pointer->_flag | 4; \n        user_buffer = (char *)&file_pointer->_charbuf; \n        adjusted_size = 2; \n    }\n    \n    file_pointer->_flag = updated_flag; \n    file_pointer->_bufsiz = adjusted_size; \n    file_pointer->_base = user_buffer; \n    file_pointer->_ptr = user_buffer; \n    file_pointer->_cnt = 0; \n    FUN_1001a6ae(); \n    return 0; \n}"}
{"Function Name": "__lock_file", "Address": "1001a78f", "Source Code": "void __cdecl __lock_file(FILE *filePointer) \n{\n    \n    if (((FILE *)0x10034aff < filePointer) && (filePointer < (FILE *)0x10034d61)) {\n        \n        lockFile(((int)(filePointer + -0x801a58) >> 5) + 0x10);\n    } else {\n        \n        enterCriticalSection((LPCRITICAL_SECTION)(filePointer + 1));\n    }\n}"}
{"Function Name": "__unlock_file", "Address": "1001a7e1", "Source Code": "void __cdecl __unlock_file(FILE *filePointer) \n{\n    \n    if (((FILE *)0x10034aff < filePointer) && (filePointer < (FILE *)0x10034d61)) {\n        \n        calculateFunction(((int)(filePointer + -0x801a58) >> 5) + 0x10);\n    } else {\n        \n        exitCriticalSection((LPCRITICAL_SECTION)(filePointer + 1));\n    }\n}"}
{"Function Name": "__initp_misc_winsig", "Address": "1001a833", "Source Code": "void __cdecl __initp_misc_winsig(undefined4 input_value)\n{\n    \n    global_var_1 = input_value;\n    \n    \n    global_var_2 = input_value;\n    \n    \n    global_var_3 = input_value;\n    \n    \n    global_var_4 = input_value;\n}"}
{"Function Name": "_raise", "Address": "1001a88d", "Source Code": "int __cdecl _raise(int signalNumber) \n{\n    uint lookupResult; \n    int *errnoPointer; \n    int functionPointerAddress; \n    code *functionToCall; \n    code **functionPointerTable; \n    _ptiddata threadLocalData; \n    void *previousExceptionInfoPointers; \n    int previousExceptionCode; \n    threadLocalData = (_ptiddata)0x0; \n    if (signalNumber < 0xc) { \n        if (signalNumber != 0xb) { \n            if (signalNumber == 2) { \n                functionPointerTable = (code **)&DAT_10036494; \n                functionPointerAddress = DAT_10036494; \n                goto LAB_1001a942; \n            }\n            if (signalNumber != 4) { \n                if (signalNumber == 6) goto LAB_1001a920; \n                if (signalNumber != 8) goto LAB_1001a904; \n            }\n        }\n        threadLocalData = __getptd_noexit(); \n        if (threadLocalData == (_ptiddata)0x0) { \n            return -1; \n        }\n        lookupResult = _siglookup(0, signalNumber, (uint)threadLocalData->_pxcptacttab); \n        functionPointerTable = (code **)(lookupResult + 8); \n        functionToCall = *functionPointerTable; \n    } else {\n        if (signalNumber == 0xf) { \n            functionPointerTable = (code **)&DAT_100364a0; \n            functionPointerAddress = DAT_100364a0; \n        } else if (signalNumber == 0x15) { \n            functionPointerTable = (code **)&DAT_10036498; \n            functionPointerAddress = DAT_10036498; \n        } else {\n            if (signalNumber != 0x16) { \n                LAB_1001a904: \n                errnoPointer = __errno(); \n                *errnoPointer = 0x16; \n                __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n                return -1; \n            }\n            LAB_1001a920: \n            functionPointerTable = (code **)&DAT_1003649c; \n            functionPointerAddress = DAT_1003649c; \n        }\n    }\nLAB_1001a942: \n    functionToCall = (code *)__decode_pointer(functionPointerAddress); \n    if (functionToCall == (code *)0x1) { \n        return 0; \n    }\n    if (functionToCall == (code *)0x0) { \n        __exit(3); \n    }\n    if (((signalNumber == 8) || (signalNumber == 0xb)) || (signalNumber == 4)) { \n        previousExceptionInfoPointers = threadLocalData->_tpxcptinfoptrs; \n        threadLocalData->_tpxcptinfoptrs = (void *)0x0; \n        if (signalNumber == 8) { \n            previousExceptionCode = threadLocalData->_tfpecode; \n            threadLocalData->_tfpecode = 0x8c; \n        }\n    }\n    pcVar6 = (code *)__encoded_null(); \n    *functionPointerTable = pcVar6; \n    FUN_1001aa01(); \n    if (signalNumber == 8) { \n        (*functionToCall)(8, threadLocalData->_tfpecode); \n    } else {\n        (*functionToCall)(signalNumber); \n        if ((signalNumber != 0xb) && (signalNumber != 4)) { \n            return 0; \n        }\n    }\n    threadLocalData->_tpxcptinfoptrs = previousExceptionInfoPointers; \n    if (signalNumber == 8) { \n        threadLocalData->_tfpecode = previousExceptionCode; \n    }\n    return 0; \n}"}
{"Function Name": "_xtow_s@20", "Address": "1001abdb", "Source Code": "int _xtow_s_20(uint number, uint buffer_size, uint base, int is_negative)\n{\n    short *output_buffer; \n    int *errno_pointer; \n    short *current_output; \n    short converted_char; \n    int error_code; \n    uint char_count; \n    \n    if (output_buffer == (short *)0x0) {\n        errno_pointer = __errno(); \n        *errno_pointer = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return 0x16; \n    }\n    \n    if (buffer_size == 0) {\n        errno_pointer = __errno(); \n        error_code = 0x16; \n    } else {\n        *output_buffer = 0; \n        \n        if ((is_negative != 0) + 1 < buffer_size) {\n            \n            if (0x22 < base - 2) goto LAB_1001ac0d; \n            current_output = output_buffer; \n            \n            if (is_negative != 0) {\n                number = -number; \n                *output_buffer = 0x2d; \n                current_output++; \n            }\n            char_count = (uint)(is_negative != 0); \n            do {\n                converted_char = (short)(number % base); \n                \n                converted_char = (number % base < 10) ? converted_char + 0x30 : converted_char + 0x57;\n                *current_output++ = converted_char; \n                char_count++; \n            } while ((number /= base) != 0 && char_count < buffer_size); \n            \n            \n            if (char_count < buffer_size) {\n                current_output[char_count] = 0; \n                short *last_written_char = current_output - 1; \n                current_output -= char_count; \n                \n                while (current_output < last_written_char) {\n                    converted_char = *last_written_char; \n                    *last_written_char-- = *current_output; \n                    *current_output++ = converted_char; \n                }\n                return 0; \n            }\n            *output_buffer = 0; \n        }\n        errno_pointer = __errno(); \n        error_code = 0x22; \n    }\n    *errno_pointer = error_code; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return error_code; \n}"}
{"Function Name": "_wcsncat_s", "Address": "1001acf4", "Source Code": "errno_t __cdecl _wcsncat_s(wchar_t *destination, rsize_t destinationSize, wchar_t *source, rsize_t maxCount)\n{\n    wchar_t *destinationPtr; \n    errno_t errorCode;   \n    rsize_t remainingSpace; \n    \n    if (maxCount == 0) {\n        \n        if (destination == (wchar_t *)0x0) {\n            \n            if (destinationSize == 0) {\n                return 0;\n            }\n        } else {\n            \n            if (destinationSize != 0) {\n                \n                if (source != (wchar_t *)0x0) {\n                    remainingSpace = destinationSize; \n                    destinationPtr = destination; \n                    \n                    while (remainingSpace != 0 && *destinationPtr != L'\\0') {\n                        destinationPtr++; \n                        remainingSpace--; \n                    }\n                    \n                    if (remainingSpace != 0) {\n                        \n                        if (maxCount == 0xffffffff) {\n                            \n                            while (1) {\n                                *destinationPtr = *source; \n                                if (*source == L'\\0') break; \n                                destinationPtr++; \n                                source++; \n                                remainingSpace--; \n                            }\n                        } else {\n                            \n                            while (maxCount != 0) {\n                                *destinationPtr = *source; \n                                if (*source == L'\\0') break; \n                                destinationPtr++; \n                                source++; \n                                remainingSpace--; \n                                maxCount--; \n                            }\n                            \n                            if (maxCount == 0) {\n                                *destinationPtr = L'\\0';\n                            }\n                        }\n                    }\n                    \n                    if (remainingSpace != 0) {\n                        return 0; \n                    }\n                    \n                    if (maxCount == 0xffffffff) {\n                        destination[destinationSize - 1] = L'\\0'; \n                        return 0x50; \n                    }\n                    *destination = L'\\0'; \n                    errorCode = 0x22; \n                    goto LAB_1001ad28; \n                }\n            }\n        }\n    } else if (destination != (wchar_t *)0x0) {\n        goto LAB_1001ad17; \n    }\n    errorCode = 0x16; \nLAB_1001ad28:\n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return errorCode; \n}"}
{"Function Name": "_wcsncpy_s", "Address": "1001add5", "Source Code": "errno_t __cdecl _wcsncpy_s(wchar_t *destinationBuffer, rsize_t destinationSize, wchar_t *sourceBuffer, rsize_t maxCount)\n{\n    wchar_t currentChar; \n    rsize_t remainingSize; \n    \n    if (maxCount == 0) {\n        \n        if (destinationBuffer == (wchar_t *)0x0 && destinationSize == 0) {\n            return 0; \n        }\n    } else {\n        \n        if (destinationSize != 0) {\n            \n            if (maxCount == 0) {\n                *destinationBuffer = L'\\0'; \n                return 0; \n            }\n            \n            if (sourceBuffer != (wchar_t *)0x0) {\n                wchar_t *destinationPtr = destinationBuffer; \n                remainingSize = destinationSize; \n                \n                if (maxCount == 0xffffffff) {\n                    do {\n                        currentChar = *sourceBuffer; \n                        *destinationPtr++ = currentChar; \n                        sourceBuffer++; \n                        if (currentChar == L'\\0') break; \n                        remainingSize--; \n                    } while (remainingSize != 0); \n                } else {\n                    \n                    do {\n                        currentChar = *sourceBuffer; \n                        *destinationPtr++ = currentChar; \n                        sourceBuffer++; \n                        if (currentChar == L'\\0' || --remainingSize == 0) break; \n                        maxCount--; \n                    } while (maxCount != 0); \n                    \n                    if (maxCount == 0) {\n                        *destinationPtr = L'\\0'; \n                    }\n                }\n                \n                if (remainingSize != 0) {\n                    return 0; \n                }\n                \n                if (maxCount == 0xffffffff) {\n                    destinationBuffer[destinationSize - 1] = L'\\0'; \n                    return 0x50; \n                }\n                *destinationBuffer = L'\\0'; \n                goto error; \n            }\n            *destinationBuffer = L'\\0'; \n        }\n    }\nerror:\n    int *errnoPtr = __errno(); \n    \n    *errnoPtr = (destinationBuffer == (wchar_t *)0x0) ? 0x16 : 0x22; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return *errnoPtr; \n}"}
{"Function Name": "_wcscat_s", "Address": "1001aeb4", "Source Code": "errno_t __cdecl _wcscat_s(wchar_t *destination, rsize_t size_in_words, wchar_t *source)\n{\n    wchar_t *dest_ptr; \n    errno_t error_code;   \n    \n    if ((destination != (wchar_t *)0x0) && (size_in_words != 0)) {\n        dest_ptr = destination; \n        \n        if (source != (wchar_t *)0x0) {\n            \n            while (size_in_words != 0 && *dest_ptr != L'\\0') {\n                dest_ptr++;      \n                size_in_words--; \n            }\n            \n            if (size_in_words != 0) {\n                \n                while (size_in_words != 0) {\n                    *dest_ptr = *source; \n                    if (*source == L'\\0') { \n                        break; \n                    }\n                    dest_ptr++;      \n                    source++;       \n                    size_in_words--; \n                }\n                \n                if (size_in_words != 0) {\n                    *dest_ptr = L'\\0'; \n                    return 0; \n                }\n            }\n        }\n    }\n    *destination = L'\\0'; \n    __errno()[0] = 0x16; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return 0x16; \n}"}
{"Function Name": "_wcscpy_s", "Address": "1001af2e", "Source Code": "errno_t __cdecl _wcscpy_s(wchar_t *destination, rsize_t sizeInWords, wchar_t *source)\n{\n    wchar_t *destinationPtr = destination; \n    errno_t errorCode; \n    \n    if ((destination != (wchar_t *)0x0) && (sizeInWords != 0)) {\n        \n        if (source != (wchar_t *)0x0) {\n            \n            while (sizeInWords != 0) {\n                wchar_t currentChar = *source; \n                *destinationPtr = currentChar; \n                source++; \n                \n                if (currentChar == L'\\0') {\n                    return 0; \n                }\n                sizeInWords--; \n                destinationPtr++; \n            }\n        }\n        *destination = L'\\0'; \n    }\n    *destination = L'\\0'; \n    errorCode = 0x16; \n    *__errno() = errorCode; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return errorCode; \n}"}
{"Function Name": "__set_error_mode", "Address": "1001af9a", "Source Code": "int __cdecl __set_error_mode(int mode)\n{\n    int previousErrorMode; \n    \n    if (mode >= 0 && mode < 3) {\n        previousErrorMode = currentErrorMode; \n        currentErrorMode = mode; \n        return previousErrorMode; \n    }\n    \n    if (mode == 3) {\n        return currentErrorMode; \n    }\n    \n    \n    *errorNumber() = 0x16; \n    \n    handleInvalidParameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    return -1; \n}"}
{"Function Name": "_strcat_s", "Address": "1001b63c", "Source Code": "errno_t __cdecl _strcat_s(char *destination, rsize_t availableSize, char *source)\n{\n    char *destinationPtr; \n    \n    if ((destination != (char *)0x0) && (availableSize != 0)) {\n        destinationPtr = destination; \n        \n        if (source != (char *)0x0) {\n            \n            while (availableSize != 0 && *destinationPtr != '\\0') {\n                destinationPtr++; \n                availableSize--; \n            }\n            \n            while (availableSize != 0) {\n                *destinationPtr = *source; \n                \n                if (*source == '\\0') {\n                    *destination = '\\0'; \n                    return 0; \n                }\n                destinationPtr++; \n                source++; \n                availableSize--; \n            }\n            *destination = '\\0'; \n            return 0; \n        }\n    }\n    *destination = '\\0'; \n    __errno()[0] = 0x16; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return 0x16; \n}"}
{"Function Name": "__wcstombs_s_l", "Address": "1001b8f3", "Source Code": "errno_t __cdecl\n__wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, wchar_t *_Src,\nsize_t _MaxCountInBytes, _locale_t _Locale)\n{\n    uint uVar1; \n    int iVar2;  \n    size_t sVar4; \n    \n    if (_DstSizeInBytes == 0) {\n        \n        if (_Dst != (char *)0x0) {\n            *_Dst = '\\0';\n        }\n        \n        if (_PtNumOfCharConverted != (size_t *)0x0) {\n            *_PtNumOfCharConverted = 0;\n        }\n        \n        uVar1 = _MaxCountInBytes ? 0 : _MaxCountInBytes;\n        \n        iVar2 = __wcstombs_l_helper(_Dst, _Src, uVar1, _Locale);\n        \n        if (iVar2 == -1) {\n            \n            if (_Dst != (char *)0x0) {\n                *_Dst = '\\0';\n            }\n            \n            return *__errno();\n        }\n        \n        sVar4 = iVar2 + 1;\n        \n        if (_Dst != (char *)0x0) {\n            \n            if (sVar4 != 0 && _MaxCountInBytes != 0xffffffff) {\n                *_Dst = '\\0'; \n                return 0x22; \n            }\n            \n            _Dst[sVar4 - 1] = '\\0';\n        }\n        \n        if (_PtNumOfCharConverted != (size_t *)0x0) {\n            *_PtNumOfCharConverted = sVar4;\n        }\n    } else {\n        \n        *__errno() = 0x16;\n        \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    return 0; \n}"}
{"Function Name": "_wcstombs_s", "Address": "1001b9a4", "Source Code": "errno_t __cdecl\n_wcstombs_s(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, wchar_t *_Src, size_t _MaxCountInBytes)\n{\n    \n    \n    \n    return __wcstombs_s_l(_PtNumOfCharConverted, _Dst, _DstSizeInBytes, _Src, _MaxCountInBytes, (_locale_t)0x0);\n}"}
{"Function Name": "__local_unwind4", "Address": "1001b9c4", "Source Code": "void __cdecl __local_unwind4(uint *input_pointer, int offset, uint limit_value)\n{\n    undefined4 *next_value_pointer; \n    uint current_value; \n    void *saved_exception_list; \n    saved_exception_list = current_exception_list; \n    current_exception_list = &saved_exception_list; \n    while (true) { \n        current_value = *(uint *)(offset + 0xc); \n        if ((current_value == 0xfffffffe) || ((limit_value != 0xfffffffe && (current_value <= limit_value)))) break; \n        next_value_pointer = (undefined4 *)((*(uint *)(offset + 8) ^ *input_pointer) + 0x10 + current_value * 0xc); \n        *(undefined4 *)(offset + 0xc) = *next_value_pointer; \n        if (next_value_pointer[1] == 0) { \n            __NLG_Notify(0x101); \n            FUN_10021750(); \n        }\n    }\n    current_exception_list = saved_exception_list; \n    return; \n}"}
{"Function Name": "@_EH4_CallFilterFunc@8", "Address": "1001bab6", "Source Code": "void __fastcall __EH4_CallFilterFunc_8(undefined *function_pointer)\n{\n    \n    ((void (*)())function_pointer)();\n}"}
{"Function Name": "@_EH4_TransferToHandler@8", "Address": "1001bacd", "Source Code": "void __fastcall __EH4_TransferToHandler_8(undefined *jumpTable)\n{\n    \n    __NLG_Notify(1);\n    \n    \n    (*(code *)jumpTable)();\n}"}
{"Function Name": "@_EH4_GlobalUnwind@4", "Address": "1001bae6", "Source Code": "void __fastcall __EH4_GlobalUnwind_4(PVOID context_pointer)\n{\n    \n    \n    \n    \n    \n    RtlUnwind(context_pointer, (PVOID)0x1001bafb, NULL, NULL);\n}"}
{"Function Name": "@_EH4_LocalUnwind@16", "Address": "1001bb00", "Source Code": "void __fastcall __EH4_LocalUnwind_16(int input_value, uint flag, uint *pointer_to_data)\n{\n    \n    __local_unwind4(pointer_to_data, input_value, flag);\n}"}
{"Function Name": "__fileno", "Address": "1001bb17", "Source Code": "int __cdecl __fileno(FILE *filePointer) \n{\n    if (filePointer == (FILE *)0x0) { \n        *errorNumber() = 0x16; \n        handleInvalidParameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return -1; \n    }\n    return filePointer->_file; \n}"}
{"Function Name": "__ioterm", "Address": "1001bd84", "Source Code": "void __cdecl __ioterm(void)\n{\n    \n    void **pointerToPointer = (void **)&DAT_100366a0;\n    \n    do {\n        \n        void *currentPointer = *pointerToPointer;\n        \n        \n        if (currentPointer != (void *)0x0) {\n            \n            for (; currentPointer < (void *)((int)currentPointer + 0x500); currentPointer = (void *)((int)currentPointer + 0x28)) {\n                \n                if (*(int *)((int)currentPointer + 8) != 0) {\n                    \n                    DeleteCriticalSection((LPCRITICAL_SECTION)((int)currentPointer + 0xc));\n                }\n            }\n            \n            _free(*pointerToPointer);\n            \n            *pointerToPointer = (void *)0x0;\n        }\n        \n        pointerToPointer++;\n    } while ((int)pointerToPointer < 0x100367a0); \n}"}
{"Function Name": "__stbuf", "Address": "1001bdd0", "Source Code": "int __cdecl __stbuf(FILE *filePointer)\n{\n    int fileDescriptor; \n    char *allocatedMemoryPointer; \n    fileDescriptor = __fileno(filePointer); \n    if (__isatty(fileDescriptor) == 0) { \n        return 0; \n    }\n    \n    \n    if (filePointer == (FILE *)(FUN_1001a6b8() + 8)) {\n        fileDescriptor = 0; \n    } else if (filePointer != (FILE *)(FUN_1001a6b8() + 0x10)) {\n        return 0; \n    } else {\n        fileDescriptor = 1; \n    }\n    globalCounter++; \n    if ((*(ushort *)&filePointer->_flag & 0x10c) != 0) { \n        return 0; \n    }\n    char **bufferPointer = (char **)(&DAT_100364bc + fileDescriptor); \n    if (*bufferPointer == (char *)0x0) { \n        allocatedMemoryPointer = (char *)__malloc_crt(0x1000); \n        *bufferPointer = allocatedMemoryPointer; \n        if (allocatedMemoryPointer == (char *)0x0) { \n            filePointer->_base = (char *)&filePointer->_charbuf; \n            filePointer->_ptr = (char *)&filePointer->_charbuf; \n            filePointer->_bufsiz = 2; \n            filePointer->_cnt = 2; \n            goto LAB_1001be54; \n        }\n    }\n    \n    allocatedMemoryPointer = *bufferPointer; \n    filePointer->_base = allocatedMemoryPointer; \n    filePointer->_ptr = allocatedMemoryPointer; \n    filePointer->_bufsiz = 0x1000; \n    filePointer->_cnt = 0x1000; \nLAB_1001be54:\n    filePointer->_flag = filePointer->_flag | 0x1102; \n    return 1; \n}"}
{"Function Name": "setSBUpLow", "Address": "1001bf19", "Source Code": "void __cdecl setSBUpLow(threadmbcinfostruct *param_1)\n{\n    byte *bytePointer; \n    char *charPointer; \n    BOOL isCPInfoRetrieved; \n    uint loopCounter; \n    CHAR mappedCharacter; \n    char tempCharacter; \n    BYTE *leadBytePointer; \n    int contextPointer; \n    _cpinfo codePageInfo; \n    WORD stringTypeInfo[52]; \n    CHAR characterMapping[256]; \n    CHAR mappedCharacters1[256]; \n    CHAR mappedCharacters2[256]; \n    uint securityCookie; \n    securityCookie = DAT_100345e0 ^ (uint)local_4a0; \n    isCPInfoRetrieved = GetCPInfo(*(UINT *)(contextPointer + 4), &codePageInfo); \n    if (isCPInfoRetrieved == 0) { \n        loopCounter = 0; \n        do {\n            charPointer = (char *)(contextPointer + 0x11d + loopCounter); \n            if (charPointer + (-0x61 - (contextPointer + 0x11d)) + 0x20 < (char *)0x1a) { \n                bytePointer = (byte *)(contextPointer + 0x1d + loopCounter); \n                *bytePointer |= 0x10; \n                tempCharacter = (char)loopCounter + ' '; \n            } else {\n                if (charPointer + (-0x61 - (contextPointer + 0x11d)) < (char *)0x1a) { \n                    bytePointer = (byte *)(contextPointer + 0x1d + loopCounter); \n                    *bytePointer |= 0x20; \n                    tempCharacter = (char)loopCounter - 0x20; \n                } else {\n                    *charPointer = '\\0'; \n                    continue; \n                }\n            }\n            *charPointer = tempCharacter; \n            loopCounter++; \n        } while (loopCounter < 0x100); \n    } else {\n        loopCounter = 0; \n        do {\n            characterMapping[loopCounter] = (CHAR)loopCounter; \n            loopCounter++; \n        } while (loopCounter < 0x100); \n        characterMapping[0] = ' '; \n        if (codePageInfo.LeadByte[0] != 0) { \n            leadBytePointer = codePageInfo.LeadByte + 1; \n            do {\n                loopCounter = (uint)codePageInfo.LeadByte[0]; \n                if (loopCounter <= *leadBytePointer) { \n                    _memset(characterMapping + loopCounter, 0x20, (*leadBytePointer - loopCounter) + 1); \n                }\n                codePageInfo.LeadByte[0] = leadBytePointer[1]; \n                leadBytePointer += 2; \n            } while (codePageInfo.LeadByte[0] != 0); \n        }\n        ___crtGetStringTypeA((_locale_t)0x0, 1, characterMapping, 0x100, stringTypeInfo, *(int *)(contextPointer + 4), *(BOOL *)(contextPointer + 0xc)); \n        ___crtLCMapStringA((_locale_t)0x0, *(LPCWSTR *)(contextPointer + 0xc), 0x100, characterMapping, 0x100, mappedCharacters1, 0x100, *(int *)(contextPointer + 4), 0); \n        ___crtLCMapStringA((_locale_t)0x0, *(LPCWSTR *)(contextPointer + 0xc), 0x200, characterMapping, 0x100, mappedCharacters2, 0x100, *(int *)(contextPointer + 4), 0); \n        loopCounter = 0; \n        do {\n            if ((stringTypeInfo[loopCounter] & 1) == 0) { \n                if ((stringTypeInfo[loopCounter] & 2) != 0) { \n                    bytePointer = (byte *)(contextPointer + 0x1d + loopCounter); \n                    *bytePointer |= 0x20; \n                    mappedCharacter = mappedCharacters2[loopCounter]; \n                } else {\n                    *(undefined *)(contextPointer + 0x11d + loopCounter) = 0; \n                    loopCounter++; \n                    continue; \n                }\n            } else {\n                bytePointer = (byte *)(contextPointer + 0x1d + loopCounter); \n                *bytePointer |= 0x10; \n                mappedCharacter = mappedCharacters1[loopCounter]; \n            }\n            *(CHAR *)(contextPointer + 0x11d + loopCounter) = mappedCharacter; \n            loopCounter++; \n        } while (loopCounter < 0x100); \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)local_4a0); \n    return; \n}"}
{"Function Name": "__isctype_l", "Address": "1001c524", "Source Code": "int __cdecl __isctype_l(int character, int type, _locale_t locale)\n{\n    int leadByteCheckResult; \n    BOOL stringTypeCheckResult; \n    CHAR characterRepresentation; \n    localeinfo_struct localeInfo; \n    ushort characterTypeInfo[2]; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n    \n    \n    if (character + 1U < 0x101) {\n        \n        characterTypeInfo[0] = *(ushort *)(localeInfo.locinfo[1].lc_category[0].locale + character * 2);\n    } else {\n        \n        leadByteCheckResult = __isleadbyte_l(character >> 8 & 0xff, &localeInfo);\n        characterRepresentation = (CHAR)character; \n        \n        \n        if (leadByteCheckResult == 0) {\n            leadByteCheckResult = 1; \n        } else {\n            character._0_1_ = (CHAR)((uint)character >> 8); \n            leadByteCheckResult = 2; \n        }\n        \n        \n        stringTypeCheckResult = ___crtGetStringTypeA(&localeInfo, 1, &characterRepresentation, leadByteCheckResult, characterTypeInfo, (localeInfo.locinfo)->lc_codepage, (BOOL)(localeInfo.locinfo)->lc_category[0].wlocale);\n        \n        \n        if (stringTypeCheckResult == 0) {\n            return 0; \n        }\n    }\n    \n    \n    return (uint)characterTypeInfo[0] & type;\n}"}
{"Function Name": "_write_char", "Address": "1001cc9e", "Source Code": "void __fastcall _write_char(FILE *file_ptr)\n{\n    byte char_to_write; \n    uint return_value; \n    \n    if (((*(byte *)&file_ptr->_flag & 0x40) == 0) || (file_ptr->_base != (char *)0x0)) {\n        file_ptr->_cnt--; \n        if (file_ptr->_cnt < 0) { \n            return_value = __flsbuf((int)(char)char_to_write, file_ptr); \n        } else {\n            *file_ptr->_ptr++ = char_to_write; \n            return_value = (uint)char_to_write; \n        }\n        if (return_value == 0xffffffff) { \n            return; \n        }\n    }\n    return; \n}"}
{"Function Name": "_write_multi_char", "Address": "1001ccd1", "Source Code": "void __cdecl _write_multi_char(undefined4 file_descriptor, int char_count, FILE *file_pointer)\n{\n    \n    if (char_count < 1) {\n        return; \n    }\n    do {\n        char_count--; \n        _write_char(file_pointer); \n    } while (*((int *)0) != -1); \n}"}
{"Function Name": "__freebuf", "Address": "1001d806", "Source Code": "void __cdecl __freebuf(FILE *filePtr) \n{\n    \n    if (((filePtr->_flag & 0x83U) != 0) && ((filePtr->_flag & 8U) != 0)) {\n        _free(filePtr->_base); \n        filePtr->_flag &= 0xfffffbf7; \n        filePtr->_ptr = NULL; \n        filePtr->_base = NULL; \n        filePtr->_cnt = 0; \n    }\n}"}
{"Function Name": "__isleadbyte_l", "Address": "1001d832", "Source Code": "int __cdecl __isleadbyte_l(int characterCode, _locale_t localeData)\n{\n    ushort leadByteCheckResult; \n    int localeInfo[2]; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)localeInfo, localeData);\n    \n    \n    leadByteCheckResult = *(ushort *)(*(int *)(localeInfo[0] + 200) + (characterCode & 0xffU) * 2);\n    \n    \n    return leadByteCheckResult & 0x8000;\n}"}
{"Function Name": "_parse_cmdline", "Address": "1001d951", "Source Code": "void __fastcall\n_parse_cmdline(undefined4 param_1, byte *param_2, byte **param_3, byte *param_4, int *param_5)\n{\n    int *unaff_EDI = param_5; \n    *unaff_EDI = 0; \n    *param_5 = 1; \n    if (param_3 != (byte **)0x0) { \n        *param_3 = param_4; \n        param_3++; \n    }\n    bool bVar2 = false; \n    byte *pbVar5 = param_4; \n    byte bVar6; \n    do {\n        if (*param_2 == 0x22) { \n            bVar2 = !bVar2; \n            bVar6 = 0x22; \n        } else {\n            (*unaff_EDI)++; \n            if (pbVar5 != (byte *)0x0) { \n                *pbVar5 = *param_2; \n                pbVar5++; \n            }\n            bVar6 = *param_2; \n            param_2++; \n            if (__ismbblead((uint)bVar6)) { \n                (*unaff_EDI)++; \n                if (pbVar5 != (byte *)0x0) { \n                    *pbVar5 = *(param_2 + 1); \n                    pbVar5++; \n                }\n                param_2 += 2; \n            }\n        }\n    } while (bVar2 || (bVar6 != 0x20 && bVar6 != 9)); \n    if (pbVar5 != (byte *)0x0) { \n        pbVar5[-1] = 0; \n    }\n    while (*param_2 != 0) { \n        while (*param_2 == 0x20 || *param_2 == 9) { \n            param_2++; \n        }\n        if (*param_2 == 0) break; \n        if (param_3 != (byte **)0x0) { \n            *param_3 = pbVar5; \n            param_3++; \n        }\n        (*param_5)++; \n        while (true) { \n            bool bVar1 = true; \n            uint uVar4 = 0; \n            while (*param_2 == 0x5c) { \n                uVar4++; \n                param_2++; \n            }\n            if (*param_2 == 0x22) { \n                if ((uVar4 & 1) == 0 && (!bVar2 || *(param_2 + 1) != 0x22)) { \n                    bVar1 = false; \n                    bVar2 = !bVar2; \n                }\n                uVar4 >>= 1; \n            }\n            while (uVar4 != 0) { \n                if (pbVar5 != (byte *)0x0) { \n                    *pbVar5 = 0x5c; \n                    pbVar5++; \n                }\n                (*unaff_EDI)++; \n                uVar4--; \n            }\n            bVar6 = *param_2; \n            if (bVar6 == 0 || (!bVar2 && (bVar6 == 0x20 || bVar6 == 9))) break; \n            if (bVar1) { \n                if (pbVar5 == (byte *)0x0) { \n                    if (__ismbblead((int)(char)bVar6) ) { \n                        param_2++; \n                        (*unaff_EDI)++; \n                    }\n                } else {\n                    if (__ismbblead((int)(char)bVar6)) { \n                        *pbVar5 = *param_2; \n                        param_2++; \n                        (*unaff_EDI)++; \n                        pbVar5++; \n                    }\n                    *pbVar5 = *param_2; \n                    pbVar5++; \n                }\n                (*unaff_EDI)++; \n            }\n            param_2++; \n        }\n    }\n    if (pbVar5 != (byte *)0x0) { \n        *pbVar5 = 0; \n    }\n    (*unaff_EDI)++; \n    if (param_3 != (byte **)0x0) { \n        *param_3 = (byte *)0x0; \n    }\n    (*param_5)++; \n    return; \n}"}
{"Function Name": "___crtGetEnvironmentStringsA", "Address": "1001dba2", "Source Code": "LPVOID __cdecl ___crtGetEnvironmentStringsA(void)\n{\n    WCHAR *wideCharEnvStr = (LPWCH)0x0; \n    DWORD errorCode; \n    LPCH envStringsSrc; \n    void *envStringsDst; \n    LPSTR multiByteEnvStr = (LPSTR)0x0; \n    if (DAT_10036608 == 0) { \n        wideCharEnvStr = GetEnvironmentStringsW(); \n        if (wideCharEnvStr != (LPWCH)0x0) { \n            DAT_10036608 = 1; \n            goto LAB_1001dbf4; \n        }\n        errorCode = GetLastError(); \n        if (errorCode == 0x78) { \n            DAT_10036608 = 2; \n        }\n    }\n    if (DAT_10036608 != 1) { \n        if ((DAT_10036608 != 2) && (DAT_10036608 != 0)) { \n            return (LPVOID)0x0; \n        }\n        envStringsSrc = GetEnvironmentStrings(); \n        if (envStringsSrc == (LPCH)0x0) { \n            return (LPVOID)0x0; \n        }\n        char *pcVar7 = envStringsSrc; \n        while (*pcVar7 != '\\0') { \n            while (*pcVar7 != '\\0') { \n                pcVar7++; \n            }\n            pcVar7 += 2; \n        }\n        envStringsDst = __malloc_crt((size_t)(pcVar7 + (1 - (int)envStringsSrc))); \n        if (envStringsDst == (void *)0x0) { \n            FreeEnvironmentStringsA(envStringsSrc); \n            return (LPVOID)0x0; \n        }\n        _memcpy(envStringsDst, envStringsSrc, (size_t)(pcVar7 + (1 - (int)envStringsSrc))); \n        FreeEnvironmentStringsA(envStringsSrc); \n        return envStringsDst; \n    }\nLAB_1001dbf4:\n    if ((wideCharEnvStr == (LPWCH)0x0) && \n        (wideCharEnvStr = GetEnvironmentStringsW(), wideCharEnvStr == (LPWCH)0x0)) { \n        return (LPVOID)0x0; \n    }\n    WCHAR *wideCharPtr = wideCharEnvStr; \n    while (*wideCharPtr != L'\\0') { \n        while (*wideCharPtr != L'\\0') { \n            wideCharPtr++; \n        }\n        wideCharPtr += 2; \n    }\n    int wideCharCount = ((int)wideCharPtr - (int)wideCharEnvStr >> 1) + 1; \n    size_t multiByteSize = WideCharToMultiByte(0, 0, wideCharEnvStr, wideCharCount, (LPSTR)0x0, 0, (LPCSTR)0x0, (LPBOOL)0x0); \n    \n    if (multiByteSize != 0 && (multiByteEnvStr = (LPSTR)__malloc_crt(multiByteSize), multiByteEnvStr != (LPSTR)0x0) && \n        (WideCharToMultiByte(0, 0, wideCharEnvStr, wideCharCount, multiByteEnvStr, multiByteSize, (LPCSTR)0x0, (LPBOOL)0x0) == 0)) { \n        _free(multiByteEnvStr); \n        multiByteEnvStr = (LPSTR)0x0; \n    }\n    FreeEnvironmentStringsW(wideCharEnvStr); \n    return multiByteEnvStr; \n}"}
{"Function Name": "__RTC_Initialize", "Address": "1001dcd7", "Source Code": "void initializeRTC(void)\n{\n    \n}"}
{"Function Name": "__XcptFilter", "Address": "1001dd20", "Source Code": "int __cdecl __XcptFilter(ulong exception_number, _EXCEPTION_POINTERS *exception_pointer)\n{\n    ulong *action_table_pointer; \n    code *exception_handler;  \n    void *previous_exception_pointers;  \n    ulong current_exception_number;   \n    _ptiddata thread_local_data = __getptd_noexit(); \n    int return_value = -1; \n    \n    if (thread_local_data == (_ptiddata)0x0) {\n        return_value = UnhandledExceptionFilter(exception_pointer); \n    } else {\n        action_table_pointer = (ulong *)thread_local_data->_pxcptacttab; \n        ulong *search_pointer = action_table_pointer; \n        \n        while (search_pointer < action_table_pointer + DAT_1003557c * 3) {\n            if (*search_pointer == exception_number) break; \n            search_pointer += 3; \n        }\n        \n        if (search_pointer >= action_table_pointer + DAT_1003557c * 3 || *search_pointer != exception_number) {\n            search_pointer = (ulong *)0x0; \n        }\n        \n        if (search_pointer == (ulong *)0x0 || (exception_handler = (code *)search_pointer[2], exception_handler == (code *)0x0)) {\n            return_value = UnhandledExceptionFilter(exception_pointer); \n        } else if (exception_handler == (code *)0x5) {\n            search_pointer[2] = 0; \n            return_value = 1; \n        } else {\n            previous_exception_pointers = thread_local_data->_tpxcptinfoptrs; \n            thread_local_data->_tpxcptinfoptrs = exception_pointer; \n            \n            if (search_pointer[1] == 8) {\n                \n                if (DAT_10035570 < DAT_10035574 + DAT_10035570) {\n                    for (int entry_index = DAT_10035570 * 0xc; entry_index < DAT_10035574 + DAT_10035570 * 0xc; entry_index += 0xc) {\n                        *(undefined4 *)(entry_index + 8 + (int)thread_local_data->_pxcptacttab) = 0; \n                    }\n                }\n            }\n            current_exception_number = *search_pointer; \n            int temp_tfe_code = thread_local_data->_tfpecode; \n            \n            switch (current_exception_number) {\n                case 0xc000008e: thread_local_data->_tfpecode = 0x83; break; \n                case 0xc0000090: thread_local_data->_tfpecode = 0x81; break; \n                case 0xc0000091: thread_local_data->_tfpecode = 0x84; break; \n                case 0xc0000093: thread_local_data->_tfpecode = 0x85; break; \n                case 0xc000008d: thread_local_data->_tfpecode = 0x82; break; \n                case 0xc000008f: thread_local_data->_tfpecode = 0x86; break; \n                case 0xc0000092: thread_local_data->_tfpecode = 0x8a; break; \n            }\n            \n            (*exception_handler)(search_pointer[1] == 8 ? 8 : search_pointer[1], thread_local_data->_tfpecode);\n            thread_local_data->_tfpecode = temp_tfe_code; \n            thread_local_data->_tpxcptinfoptrs = previous_exception_pointers; \n        }\n    }\n    return return_value; \n}"}
{"Function Name": "___security_init_cookie", "Address": "1001deb0", "Source Code": "void __cdecl ___security_init_cookie(void)\n{\n    DWORD processId, threadId, tickCount; \n    uint xorResult; \n    LARGE_INTEGER performanceCounter; \n    _FILETIME systemTime = {0}; \n    \n    if ((DAT_100345e0 == 0xbb40e64e) || ((DAT_100345e0 & 0xffff0000) == 0)) {\n        GetSystemTimeAsFileTime(&systemTime); \n        xorResult = systemTime.dwHighDateTime ^ systemTime.dwLowDateTime; \n        processId = GetCurrentProcessId(); \n        threadId = GetCurrentThreadId(); \n        tickCount = GetTickCount(); \n        QueryPerformanceCounter(&performanceCounter); \n        \n        DAT_100345e0 = xorResult ^ processId ^ threadId ^ tickCount ^ performanceCounter.s.HighPart ^ performanceCounter.s.LowPart;\n        \n        \n        if (DAT_100345e0 == 0xbb40e64e) {\n            DAT_100345e0 = 0xbb40e64f; \n        } else if ((DAT_100345e0 & 0xffff0000) == 0) {\n            \n            DAT_100345e0 |= DAT_100345e0 << 0x10;\n        }\n    }\n    \n    DAT_100345e4 = ~DAT_100345e0;\n}"}
{"Function Name": "___convertcp", "Address": "1001df8b", "Source Code": "void __cdecl\n___convertcp(UINT param_1, UINT param_2, char *param_3, uint *param_4, LPSTR param_5, int param_6)\n{\n    uint cbMultiByte = *param_4; \n    BOOL BVar2; \n    size_t sVar3; \n    undefined4 *local_20 = (undefined4 *)0x0; \n    _cpinfo local_1c; \n    uint uVar6; \n    if (param_1 == param_2) goto LAB_1001e12b; \n    BVar2 = GetCPInfo(param_1, &local_1c); \n    \n    if ((((BVar2 == 0) || (local_1c.MaxCharSize != 1)) ||\n        (BVar2 = GetCPInfo(param_2, &local_1c), BVar2 == 0)) || (local_1c.MaxCharSize != 1)) {\n        \n        uVar6 = MultiByteToWideChar(param_1, 1, param_3, cbMultiByte, (LPWSTR)0x0, 0);\n        if (uVar6 == 0) goto LAB_1001e12b; \n    } else {\n        \n        uVar6 = cbMultiByte == 0xffffffff ? _strlen(param_3) + 1 : cbMultiByte;\n        \n        if (uVar6 == 0 || (int)uVar6 < 0 || (0x7ffffff0 < uVar6)) {\n            local_20 = (undefined4 *)0x0; \n        } else {\n            uint _Size = uVar6 * 2 + 8; \n            if (_Size < 0x401) {\n                local_20 = (undefined4 *)&stack0xffffffbc; \n            } else {\n                local_20 = (undefined4 *)_malloc(_Size); \n                if (local_20 != (undefined4 *)0x0) {\n                    *local_20 = 0xdddd; \n                }\n            }\n        }\n    }\n    if (local_20 != (undefined4 *)0x0) { \n        _memset(local_20, 0, uVar6 * 2); \n        \n        if (MultiByteToWideChar(param_1, 1, param_3, cbMultiByte, (LPWSTR)local_20, uVar6) != 0) {\n            if (param_5 == (LPSTR)0x0) { \n                \n                if (WideCharToMultiByte(param_2, 0, (LPCWSTR)local_20, uVar6, (LPSTR)0x0, 0, (LPCSTR)0x0, (LPBOOL)0x0) != 0) {\n                    LPSTR lpMultiByteStr = (LPSTR)__calloc_crt(1, uVar6); \n                    if (lpMultiByteStr != (LPSTR)0x0) {\n                        \n                        uVar6 = WideCharToMultiByte(param_2, 0, (LPCWSTR)local_20, uVar6, lpMultiByteStr, uVar6, (LPCSTR)0x0, (LPBOOL)0x0);\n                        if (uVar6 == 0) {\n                            _free(lpMultiByteStr); \n                        } else if (cbMultiByte != 0xffffffff) {\n                            *param_4 = uVar6; \n                        }\n                    }\n                }\n            } else {\n                \n                WideCharToMultiByte(param_2, 0, (LPCWSTR)local_20, uVar6, param_5, param_6, (LPCSTR)0x0, (LPBOOL)0x0);\n            }\n        }\n        __freea(local_20); \n    }\nLAB_1001e12b:\n    return; \n}"}
{"Function Name": "__alloca_probe_16", "Address": "1001e140", "Source Code": "uint allocate_memory_probe(undefined1 input_param)\n{\n    \n    \n    return eax_value + (4 - eax_value & 0xf) | \n           \n           -(uint)check_overflow(eax_value, (4 - eax_value & 0xf));\n}"}
{"Function Name": "__alloca_probe_8", "Address": "1001e156", "Source Code": "uint __alloca_probe_8(undefined1 alignment_param)\n{\n    \n    \n    \n    \n    \n    return input_value + (4 - input_value & 7) | -(uint)CARRY4(input_value, (4 - input_value & 7));\n}"}
{"Function Name": "__crtGetStringTypeA_stat", "Address": "1001e16c", "Source Code": "int __cdecl\n__crtGetStringTypeA_stat\n(localeinfo_struct *param_1, ulong param_2, char *param_3, int param_4, ushort *param_5,\nint param_6, int param_7, int param_8)\n{\n    uint _Size; \n    BOOL BVar1; \n    DWORD DVar2; \n    uint cchWideChar; \n    undefined4 *lpWideCharStr; \n    int iVar4; \n    ushort *puVar5; \n    void *_Memory; \n    \n    if (DAT_1003660c == 0) {\n        \n        BVar1 = GetStringTypeW(1, L\"\", 1, (LPWORD)0);\n        if (BVar1 == 0) { \n            DVar2 = GetLastError(); \n            if (DVar2 == 0x78) { \n                DAT_1003660c = 2; \n            }\n            goto LAB_1001e1c5; \n        }\n        DAT_1003660c = 1; \n    }\n    else {\n    LAB_1001e1c5:\n        \n        if ((DAT_1003660c == 2) || (DAT_1003660c == 0)) {\n            \n            if (param_6 == 0) {\n                param_6 = *(int *)(*in_ECX + 0x14);\n            }\n            \n            if (param_5 == (ushort *)0x0) {\n                param_5 = *(ushort **)(*in_ECX + 4);\n            }\n            \n            puVar5 = (ushort *)___ansicp(param_6);\n            \n            if ((puVar5 != (ushort *)0xffffffff) &&\n                ((puVar5 == param_5 ||\n                (_Memory = (void *)___convertcp((UINT)param_5, (UINT)puVar5, (char *)param_2,\n                (uint *)&param_3, (LPSTR)0x0, 0), param_2 = (ulong)_Memory,\n                _Memory != (void *)0x0)) &&\n                (GetStringTypeA(param_6, (DWORD)param_1, (LPCSTR)param_2, (int)param_3, (LPWORD)param_4),\n                _Memory != (void *)0x0)))) {\n                _free(_Memory); \n            }\n            goto LAB_1001e312; \n        }\n        \n        if (DAT_1003660c != 1) goto LAB_1001e312;\n    }\n    \n    if (param_5 == (ushort *)0x0) {\n        param_5 = *(ushort **)(*in_ECX + 4);\n    }\n    \n    cchWideChar = MultiByteToWideChar((UINT)param_5, (uint)(param_7 != 0) * 8 + 1, (LPCSTR)param_2,\n                                      (int)param_3, (LPWSTR)0x0, 0);\n    \n    if (cchWideChar == 0) goto LAB_1001e312;\n    lpWideCharStr = (undefined4 *)0x0; \n    \n    if ((0 < (int)cchWideChar) && (cchWideChar < 0x7ffffff1)) {\n        _Size = cchWideChar * 2 + 8; \n        \n        if (_Size < 0x401) {\n            lpWideCharStr = (undefined4 *)&stack0xffffffe8;\n        }\n        else {\n            \n            lpWideCharStr = (undefined4 *)_malloc(_Size);\n            if (lpWideCharStr != (undefined4 *)0x0) {\n                *lpWideCharStr = 0xdddd; \n            }\n        }\n    }\n    \n    if (lpWideCharStr != (undefined4 *)0x0) {\n        _memset(lpWideCharStr, 0, cchWideChar * 2); \n        \n        iVar4 = MultiByteToWideChar((UINT)param_5, 1, (LPCSTR)param_2, (int)param_3, (LPWSTR)lpWideCharStr,\n                                     cchWideChar);\n        if (iVar4 != 0) { \n            GetStringTypeW((DWORD)param_1, (LPCWSTR)lpWideCharStr, iVar4, (LPWORD)param_4); \n        }\n        __freea(lpWideCharStr); \n    }\nLAB_1001e312:\n    \n    return ___security_check_cookie_4(DAT_100345e0 ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "___crtGetStringTypeA", "Address": "1001e324", "Source Code": "BOOL __cdecl\n___crtGetStringTypeA\n(_locale_t _Plocinfo, DWORD _DWInfoType, LPCSTR _LpSrcStr, int _CchSrc, LPWORD _LpCharType,\n int _Code_page, BOOL _BError)\n{\n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffec, _Plocinfo);\n    \n    \n    int iVar1 = __crtGetStringTypeA_stat\n        ((localeinfo_struct *)_DWInfoType, (ulong)_LpSrcStr, (char *)_CchSrc,\n        (int)_LpCharType, (ushort *)_Code_page, _BError);\n    \n    \n    if (*(char *)0x8 != '\\0') {\n        \n        *(uint *)(local_c + 0x70) &= 0xfffffffd;\n    }\n    \n    \n    return iVar1;\n}"}
{"Function Name": "__calloc_impl", "Address": "1001e364", "Source Code": "int * __cdecl __calloc_impl(uint num_elements, uint element_size, undefined4 *error_code)\n{\n    int *allocated_memory_ptr; \n    uint total_bytes; \n    \n    if ((num_elements == 0) || (element_size <= 0xffffffe0 / num_elements)) {\n        total_bytes = num_elements * element_size; \n        if (total_bytes == 0) {\n            total_bytes = 1; \n        }\n        do {\n            allocated_memory_ptr = (int *)0x0; \n            \n            if (total_bytes < (uint *)0xffffffe1) {\n                \n                if ((DAT_100377f4 == 3) &&\n                    (total_bytes = (uint)((int)total_bytes + 0xfU & 0xfffffff0), num_elements * element_size <= DAT_100377e4)) {\n                    __lock(4); \n                    allocated_memory_ptr = ___sbh_alloc_block(num_elements * element_size); \n                    FUN_1001e460(); \n                    \n                    if (allocated_memory_ptr != (int *)0x0) {\n                        _memset(allocated_memory_ptr, 0, (size_t)(num_elements * element_size)); \n                        return allocated_memory_ptr; \n                    }\n                }\n            }\n            \n            allocated_memory_ptr = (int *)HeapAlloc(DAT_10036228, 8, (SIZE_T)total_bytes);\n            \n            if (allocated_memory_ptr != (int *)0x0) {\n                return allocated_memory_ptr; \n            }\n            \n            if (DAT_1003666c == 0) {\n                if (error_code == (undefined4 *)0x0) {\n                    return (int *)0x0; \n                }\n                *error_code = 0xc; \n                return (int *)0x0; \n            }\n        } while (__callnewh((size_t)total_bytes) != 0); \n        \n        if (error_code != (undefined4 *)0x0) {\n            *error_code = 0xc; \n        }\n    } else {\n        \n        allocated_memory_ptr = __errno(); \n        *allocated_memory_ptr = 0xc; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    return (int *)0x0; \n}"}
{"Function Name": "_realloc", "Address": "1001e482", "Source Code": "void * __cdecl _realloc(void *memoryPointer, size_t newSize)\n{\n    void *newMemoryPointer; \n    uint *sizeInfoPointer; \n    int *allocatedBlockPointer; \n    \n    if (memoryPointer == (void *)0x0) {\n        return _malloc(newSize);\n    }\n    \n    if (newSize == 0) {\n        _free(memoryPointer);\n        return (void *)0x0;\n    }\n    \n    if (DAT_100377f4 == 3) {\n        allocatedBlockPointer = (int *)0x0; \n        \n        if ((uint *)0xffffffe0 < newSize) goto LAB_1001e65b;\n        newMemoryPointer = (void *)0x4; \n        __lock(4); \n        uint *blockInfoPointer = (uint *)thunk_FUN_10016ae8(newMemoryPointer, (int)memoryPointer); \n        \n        if (blockInfoPointer != (uint *)0x0) {\n            \n            if (newSize <= DAT_100377e4) {\n                \n                if (___sbh_resize_block(blockInfoPointer, (int)memoryPointer, newSize) == 0) {\n                    \n                    allocatedBlockPointer = ___sbh_alloc_block((uint *)newSize);\n                    if (allocatedBlockPointer != (int *)0x0) {\n                        sizeInfoPointer = (uint *)(*(int *)((int)memoryPointer + -4) - 1); \n                        \n                        if (newSize <= sizeInfoPointer) {\n                            sizeInfoPointer = (uint *)newSize;\n                        }\n                        _memcpy(allocatedBlockPointer, memoryPointer, (size_t)sizeInfoPointer); \n                        blockInfoPointer = (uint *)thunk_FUN_10016ae8(currentBlock, (int)memoryPointer); \n                        ___sbh_free_block(blockInfoPointer, (int)memoryPointer); \n                    }\n                }\n            } else {\n                allocatedBlockPointer = (int *)memoryPointer; \n            }\n        }\n        \n        if (allocatedBlockPointer == (int *)0x0) {\n            \n            if ((uint *)newSize == (uint *)0x0) {\n                newSize = 1;\n            }\n            \n            newSize = newSize + 0xf & 0xfffffff0;\n            allocatedBlockPointer = (int *)HeapAlloc(DAT_10036228, 0, newSize); \n            if (allocatedBlockPointer != (int *)0x0) {\n                sizeInfoPointer = (uint *)(*(int *)((int)memoryPointer + -4) - 1); \n                \n                if (newSize <= sizeInfoPointer) {\n                    sizeInfoPointer = (uint *)newSize;\n                }\n                _memcpy(allocatedBlockPointer, memoryPointer, (size_t)sizeInfoPointer); \n                ___sbh_free_block(blockInfoPointer, (int)memoryPointer); \n            }\n        }\n    }\n    FUN_1001e5c6(); \n    \n    if (blockInfoPointer == (uint *)0x0) {\n        \n        if ((uint *)newSize == (uint *)0x0) {\n            newSize = 1;\n        }\n        \n        newSize = newSize + 0xf & 0xfffffff0;\n        allocatedBlockPointer = (int *)HeapReAlloc(DAT_10036228, 0, memoryPointer, newSize); \n    }\n    \n    if (allocatedBlockPointer != (int *)0x0) {\n        return allocatedBlockPointer; \n    }\n    \n    if (DAT_1003666c == 0) {\n        int *errorPointer = __errno(); \n        \n        if (blockInfoPointer != (uint *)0x0) {\n            *errorPointer = 0xc; \n            return (void *)0x0; \n        }\n        goto LAB_1001e688; \n    }\n    int allocationHandler = __callnewh(newSize); \n    \n    while (allocationHandler != 0) {\n        int *errorPointer = __errno(); \n        if (blockInfoPointer != (uint *)0x0) goto LAB_1001e667; \n    }\n    LAB_1001e688: \n    DWORD lastError = GetLastError(); \n    int allocationHandler = __get_errno_from_oserr(lastError); \n    *errorPointer = allocationHandler; \n    return (void *)0x0; \nLAB_1001e65b: \n    __callnewh(newSize); \nLAB_1001e667: \n    int *errorPointer = __errno(); \n    *errorPointer = 0xc; \n    return (void *)0x0; \n}"}
{"Function Name": "__recalloc", "Address": "1001e69d", "Source Code": "void * __cdecl __recalloc(void *memoryPointer, size_t elementCount, size_t elementSize)\n{\n    void *reallocatedMemoryPointer; \n    \n    if ((elementCount != 0) && (0xffffffe0 / elementCount < elementSize)) {\n        *__errno() = 0xc; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return (void *)0x0; \n    }\n    \n    \n    reallocatedMemoryPointer = _realloc(memoryPointer, elementCount * elementSize);\n    return reallocatedMemoryPointer; \n}"}
{"Function Name": "___init_time", "Address": "1001ec8d", "Source Code": "int __cdecl ___init_time(threadlocinfo *localeInfo)\n{\n    undefined **allocatedMemory; \n    uint localeTimeResult; \n    int **referenceCountPtr; \n    \n    if (localeInfo->lc_category[1].locale == (char *)0x0) {\n        allocatedMemory = &PTR_DAT_10035580; \n    }\n    else {\n        \n        allocatedMemory = (undefined **)__calloc_crt(1, 0xb8);\n        if (allocatedMemory == (undefined **)0x0) {\n            return 1; \n        }\n        localeTimeResult = __get_lc_time(); \n        if (localeTimeResult != 0) {\n            ___free_lc_time(allocatedMemory); \n            _free(allocatedMemory); \n            return 1; \n        }\n        allocatedMemory[0x2d] = (undefined *)0x1; \n    }\n    referenceCountPtr = &localeInfo[1].lc_category[0].wrefcount; \n    \n    if (*(undefined **) *referenceCountPtr != &PTR_DAT_10035580) {\n        InterlockedDecrement((LONG *)(*(undefined **) *referenceCountPtr + 0x2d)); \n    }\n    *referenceCountPtr = (int *)allocatedMemory; \n    return 0; \n}"}
{"Function Name": "___free_lconv_num", "Address": "1001ed00", "Source Code": "void __cdecl ___free_lconv_num(void **memoryPointers)\n{\n    \n    if (memoryPointers != (void **)0x0) {\n        \n        if ((undefined *)*memoryPointers != firstPointer) {\n            \n            _free(*memoryPointers);\n        }\n        \n        if ((undefined *)memoryPointers[1] != secondPointer) {\n            \n            _free(memoryPointers[1]);\n        }\n        \n        if ((undefined *)memoryPointers[2] != thirdPointer) {\n            \n            _free(memoryPointers[2]);\n        }\n    }\n}"}
{"Function Name": "___free_lconv_mon", "Address": "1001ef08", "Source Code": "void __cdecl ___free_lconv_mon(int memoryBlock)\n{\n    \n    if (memoryBlock != 0) {\n        \n        for (int currentOffset = 0xc; currentOffset <= 0x24; currentOffset += 4) {\n            \n            if (*(undefined **)(memoryBlock + currentOffset) != *(undefined **)(0x1003564c + (currentOffset - 0xc))) {\n                \n                _free(*(undefined **)(memoryBlock + currentOffset));\n            }\n        }\n    }\n}"}
{"Function Name": "___init_monetary", "Address": "1001ef91", "Source Code": "int __cdecl ___init_monetary(threadlocinfo *_LocInfo)\n{\nchar *pcVar1;\nchar cVar2;\nuint uVar3;\nuint uVar4;\nuint uVar5;\nuint uVar6;\nuint uVar7;\nuint uVar8;\nuint uVar9;\nuint uVar10;\nuint uVar11;\nuint uVar12;\nuint uVar13;\nuint uVar14;\nuint uVar15;\nuint uVar16;\nuint uVar17;\nchar *pcVar18;\nuint *puVar19;\nLONG LVar20;\nint iVar21;\nundefined **_Memory;\nLPCWSTR _LocaleName;\nchar *pcVar22;\nundefined **ppuVar23;\nundefined **ppuVar24;\nlocaleinfo_struct local_14;\nundefined4 *local_c;\nundefined4 *local_8;\nlocal_8 = (undefined4 *)0x0;\nlocal_14.locinfo = _LocInfo;\nlocal_14.mbcinfo = (pthreadmbcinfo)0x0;\nif ((_LocInfo->lc_category[0].refcount == (int *)0x0) &&\n(_LocInfo->lc_category[0].wrefcount == (int *)0x0)) {\nlocal_8 = (undefined4 *)0x0;\nlocal_c = (undefined4 *)0x0;\n_Memory = &PTR_DAT_10035640;\nLAB_1001f1f8:\nif ((LONG *)_LocInfo[1].refcount != (LONG *)0x0) {\nInterlockedDecrement((LONG *)_LocInfo[1].refcount);\n}\nif (((LONG *)_LocInfo->locale_name[4] != (LONG *)0x0) &&\n(LVar20 = InterlockedDecrement((LONG *)_LocInfo->locale_name[4]), LVar20 == 0)) {\n_free((void *)_LocInfo[1].lc_codepage);\n_free(_LocInfo->locale_name[4]);\n}\n_LocInfo[1].refcount = (int)local_8;\n_LocInfo->locale_name[4] = (wchar_t *)local_c;\n_LocInfo[1].lc_codepage = (uint)_Memory;\niVar21 = 0;\n}\nelse {\n_Memory = (undefined **)__calloc_crt(1,0x30);\nif (_Memory != (undefined **)0x0) {\nlocal_c = (undefined4 *)__malloc_crt(4);\nif (local_c == (undefined4 *)0x0) {\n_free(_Memory);\n}\nelse {\n*local_c = 0;\nif (_LocInfo->lc_category[0].refcount == (int *)0x0) {\nppuVar23 = &PTR_DAT_10035640;\nppuVar24 = _Memory;\nfor (iVar21 = 0xc; iVar21 != 0; iVar21 = iVar21 + -1) {\n*ppuVar24 = *ppuVar23;\nppuVar23 = ppuVar23 + 1;\nppuVar24 = ppuVar24 + 1;\n}\nLAB_1001f1c3:\npuVar19 = &_LocInfo[1].lc_codepage;\n*_Memory = *(undefined **)*puVar19;\n_Memory[1] = *(undefined **)(*puVar19 + 4);\n_Memory[2] = *(undefined **)(*puVar19 + 8);\n*local_c = 1;\nif (local_8 != (undefined4 *)0x0) {\n*local_8 = 1;\n}\ngoto LAB_1001f1f8;\n}\nlocal_8 = (undefined4 *)__malloc_crt(4);\nif (local_8 == (undefined4 *)0x0) {\n_free(_Memory);\n_free(local_c);\n}\nelse {\n*local_8 = 0;\n_LocaleName = (LPCWSTR)(uint)*(ushort *)&_LocInfo->lc_category[2].refcount;\nuVar3 = ___getlocaleinfo(&local_14,1,_LocaleName,0x15,_Memory + 3);\nuVar4 = ___getlocaleinfo(&local_14,1,_LocaleName,0x14,_Memory + 4);\nuVar5 = ___getlocaleinfo(&local_14,1,_LocaleName,0x16,_Memory + 5);\nuVar6 = ___getlocaleinfo(&local_14,1,_LocaleName,0x17,_Memory + 6);\nuVar7 = ___getlocaleinfo(&local_14,1,_LocaleName,0x18,_Memory + 7);\nuVar8 = ___getlocaleinfo(&local_14,1,_LocaleName,0x50,_Memory + 8);\nuVar9 = ___getlocaleinfo(&local_14,1,_LocaleName,0x51,_Memory + 9);\nuVar10 = ___getlocaleinfo(&local_14,0,_LocaleName,0x1a,_Memory + 10);\nuVar11 = ___getlocaleinfo(&local_14,0,_LocaleName,0x19,(void *)((int)_Memory + 0x29));\nuVar12 = ___getlocaleinfo(&local_14,0,_LocaleName,0x54,(void *)((int)_Memory + 0x2a));\nuVar13 = ___getlocaleinfo(&local_14,0,_LocaleName,0x55,(void *)((int)_Memory + 0x2b));\nuVar14 = ___getlocaleinfo(&local_14,0,_LocaleName,0x56,_Memory + 0xb);\nuVar15 = ___getlocaleinfo(&local_14,0,_LocaleName,0x57,(void *)((int)_Memory + 0x2d));\nuVar16 = ___getlocaleinfo(&local_14,0,_LocaleName,0x52,(void *)((int)_Memory + 0x2e));\nuVar17 = ___getlocaleinfo(&local_14,0,_LocaleName,0x53,(void *)((int)_Memory + 0x2f));\nif ((uVar17 | uVar3 | uVar4 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 |\nuVar12 | uVar13 | uVar14 | uVar15 | uVar16) == 0) {\npcVar18 = _Memory[7];\nwhile (*pcVar18 != '\\0') {\ncVar2 = *pcVar18;\nif ((cVar2 < '0') || ('9' < cVar2)) {\npcVar22 = pcVar18;\nif (cVar2 != ';') goto LAB_1001f198;\ndo {\npcVar1 = pcVar22 + 1;\n*pcVar22 = *pcVar1;\npcVar22 = pcVar1;\n} while (*pcVar1 != '\\0');\n}\nelse {\n*pcVar18 = cVar2 + -0x30;\nLAB_1001f198:\npcVar18 = pcVar18 + 1;\n}\n}\ngoto LAB_1001f1c3;\n}\n___free_lconv_mon((int)_Memory);\n_free(_Memory);\n_free(local_c);\n_free(local_8);\n}\n}\n}\niVar21 = 1;\n}\nreturn iVar21;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_c : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4"}
{"Function Name": "_strcspn", "Address": "1001f260", "Source Code": "size_t __cdecl _strcspn(char *inputString, char *controlString)\n{\n    byte currentChar; \n    size_t segmentLength; \n    byte *bitmapPointer; \n    byte characterBitmap[32] = {0}; \n    \n    while ((currentChar = *controlString++) != 0) {\n        bitmapPointer = characterBitmap + (currentChar >> 3); \n        *bitmapPointer |= (1 << (currentChar & 7)); \n    }\n    \n    segmentLength = 0; \n    \n    while ((currentChar = *inputString++) != 0) {\n        \n        if (characterBitmap[currentChar >> 3] & (1 << (currentChar & 7))) {\n            return segmentLength; \n        }\n        segmentLength++; \n    }\n    return segmentLength; \n}"}
{"Function Name": "_strncpy_s", "Address": "1001f2a6", "Source Code": "errno_t __cdecl _strncpy_s(char *destination, rsize_t sizeInBytes, char *source, rsize_t maxCount)\n{\n    char currentChar; \n    rsize_t remainingSize; \n    \n    if (maxCount == 0) {\n        \n        if (destination == (char *)0x0 && sizeInBytes == 0) {\n            return 0;\n        }\n    } else if (destination != (char *)0x0) { \n        if (sizeInBytes != 0) { \n            \n            if (maxCount == 0) {\n                *destination = '\\0';\n                return 0;\n            }\n            \n            if (source != (char *)0x0) {\n                remainingSize = sizeInBytes; \n                do {\n                    currentChar = *source; \n                    *destination = currentChar; \n                    destination++; \n                    source++; \n                    if (currentChar == '\\0') break; \n                    remainingSize--; \n                    if (maxCount != 0xffffffff) maxCount--; \n                } while (remainingSize != 0 && maxCount != 0); \n                if (maxCount == 0) { \n                    *destination = '\\0'; \n                }\n            }\n            if (remainingSize != 0) { \n                return 0; \n            }\n            if (maxCount == 0xffffffff) { \n                destination[sizeInBytes - 1] = '\\0'; \n                return 0x50; \n            }\n            *destination = '\\0'; \n            __errno()[0] = 0x22; \n            goto LAB_1001f2db; \n        }\n    }\n    __errno()[0] = 0x16; \nLAB_1001f2db:\n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return 0x16; \n}"}
{"Function Name": "_TranslateName", "Address": "1001f359", "Source Code": "bool __cdecl _TranslateName(int base_address, int upper_bound, char **input_name)\n{\n    int lower_bound_index = 0; \n    int comparison_result = 1; \n    if (upper_bound >= 0) { \n        do {\n            if (comparison_result == 0) break; \n            int middle_index = (upper_bound + lower_bound_index) / 2; \n            char **middle_name_pointer = (char **)(base_address + middle_index * 8); \n            comparison_result = __stricmp(*input_name, *middle_name_pointer); \n            if (comparison_result == 0) { \n                *input_name = (char *)(middle_name_pointer + 1); \n            } else if (comparison_result < 0) { \n                upper_bound = middle_index - 1; \n            } else { \n                lower_bound_index = middle_index + 1; \n            }\n        } while (lower_bound_index <= upper_bound); \n    }\n    return comparison_result == 0; \n}"}
{"Function Name": "___get_qualified_locale", "Address": "1001f8d3", "Source Code": "BOOL __cdecl ___get_qualified_locale(LPLC_STRINGS inputStrings, UINT *outputCodePage, LPLC_STRINGS outputStrings)\n{\n    wchar_t *countryStringPtr; \n    _ptiddata threadLocalData; \n    size_t countryStringLength; \n    LCID localeId; \n    uint codePageValue; \n    BOOL isValid; \n    errno_t errorStatus; \n    int returnValue; \n    threadLocalData = __getptd(); \n    if (inputStrings == (LPLC_STRINGS)0x0) { \n        threadLocalData->_setloc_data.iLocState |= 0x104; \n        localeId = GetUserDefaultLCID(); \n        threadLocalData->_setloc_data._cachecp = localeId; \n        *(LCID *)(threadLocalData->_setloc_data)._cachein = localeId; \n    } else {\n        countryStringPtr = inputStrings->szLanguage + 0x20; \n        threadLocalData->_setloc_data.pchLanguage = inputStrings->szLanguage; \n        threadLocalData->_setloc_data.pchCountry = countryStringPtr; \n        if (countryStringPtr != (wchar_t *)0x0 && *(char *)countryStringPtr != '\\0') { \n            _TranslateName(0x1002ee80, 0x16, (char **)&threadLocalData->_setloc_data.pchCountry); \n        }\n        threadLocalData->_setloc_data.iLocState = 0; \n        if (threadLocalData->_setloc_data.pchLanguage == (wchar_t *)0x0 || *(char *)threadLocalData->_setloc_data.pchLanguage == '\\0') { \n            if (countryStringPtr == (wchar_t *)0x0 || *(char *)countryStringPtr == '\\0') { \n                threadLocalData->_setloc_data.iLocState = 0x104; \n                localeId = GetUserDefaultLCID(); \n                threadLocalData->_setloc_data._cachecp = localeId; \n                *(LCID *)(threadLocalData->_setloc_data)._cachein = localeId; \n            } else {\n                countryStringLength = _strlen((char *)countryStringPtr); \n                threadLocalData->_setloc_data.bAbbrevCountry = (uint)(countryStringLength == 3); \n                EnumSystemLocalesA(_CountryEnumProc_4, 1); \n                if ((*(byte *)&threadLocalData->_setloc_data.iLocState & 4) == 0) { \n                    threadLocalData->_setloc_data.iLocState = 0; \n                }\n            }\n        } else {\n            if (threadLocalData->_setloc_data.pchCountry == (wchar_t *)0x0 || *(char *)threadLocalData->_setloc_data.pchCountry == '\\0') { \n                _GetLcidFromLanguage(); \n            } else {\n                _GetLcidFromLangCountry(); \n            }\n            if (threadLocalData->_setloc_data.iLocState == 0) { \n                return 0; \n            }\n            if (_TranslateName(0x1002ec78, 0x40, (char **)&threadLocalData->_setloc_data) != 0) { \n                if (threadLocalData->_setloc_data.pchCountry == (wchar_t *)0x0 || *(char *)threadLocalData->_setloc_data.pchCountry == '\\0') { \n                    _GetLcidFromLanguage(); \n                } else {\n                    _GetLcidFromLangCountry(); \n                }\n            }\n        }\n    }\n    if (threadLocalData->_setloc_data.iLocState == 0) { \n        return 0; \n    }\n    codePageValue = _ProcessCodePage((CHAR *)(-(uint)(inputStrings != (LPLC_STRINGS)0x0) & (uint)inputStrings->szCountry)); \n    if (((codePageValue == 0) || (codePageValue == 65000)) || (codePageValue == 0xfde9) || \n        ((isValid = IsValidCodePage(codePageValue & 0xffff), isValid == 0) || \n        (isValid = IsValidLocale(threadLocalData->_setloc_data._cachecp, 1), isValid == 0))) ) { \n        return 0; \n    }\n    if (outputCodePage != (UINT *)0x0) { \n        *(undefined2 *)outputCodePage = *(undefined2 *)&threadLocalData->_setloc_data._cachecp; \n        *(wchar_t *)((int)outputCodePage + 2) = threadLocalData->_setloc_data._cachein[0]; \n        *(short *)(outputCodePage + 1) = (short)codePageValue; \n    }\n    if (outputStrings != (LPLC_STRINGS)0x0) { \n        if (*(short *)outputCodePage == 0x814) { \n            errorStatus = _strcpy_s((char *)outputStrings, 0x40, \"Norwegian-Nynorsk\"); \n            if (errorStatus != 0) { \n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            }\n        } else {\n            returnValue = GetLocaleInfoA(threadLocalData->_setloc_data._cachecp, 0x1001, (LPSTR)outputStrings, 0x40); \n            if (returnValue == 0) { \n                return 0; \n            }\n        }\n        returnValue = GetLocaleInfoA(*(LCID *)(threadLocalData->_setloc_data)._cachein, 0x1002, (LPSTR)(outputStrings->szLanguage + 0x20), 0x40); \n        if (returnValue == 0) { \n            return 0; \n        }\n        __itoa_s(codePageValue, (char *)outputStrings->szCountry, 0x10, 10); \n    }\n    return 1; \n}"}
{"Function Name": "_memcmp", "Address": "1001fab6", "Source Code": "int __cdecl _memcmp(void *_Buf1,void *_Buf2,size_t _Size)\n{\nint iVar1;\nuint uVar2;\nuint uVar3;\n\nif (_Size == 0) {\nreturn 0;\n}\nif (_Size == 1) {\n\nuVar2 = (uint)*_Buf1;\n\nuVar3 = (uint)*_Buf2;\nLAB_1002100d:\nif (uVar2 == uVar3) {\nreturn 0;\n}\nreturn (uint)(0 < (int)(uVar2 - uVar3)) * 2 + -1;\n}\nif (_Size == 2) {\n\nuVar2 = (uint)*_Buf1;\n\nuVar3 = (uint)*_Buf2;\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf1 + 1);\nuVar3 = (uint)*(byte *)((int)_Buf2 + 1);\ngoto LAB_1002100d;\n}\nif (_Size == 3) {\n\nuVar2 = (uint)*_Buf1;\n\nuVar3 = (uint)*_Buf2;\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf1 + 1);\nuVar3 = (uint)*(byte *)((int)_Buf2 + 1);\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf1 + 2);\nuVar3 = (uint)*(byte *)((int)_Buf2 + 2);\ngoto LAB_1002100d;\n}\nif (_Size == 4) {\n\nuVar2 = (uint)*_Buf1;\n\nuVar3 = (uint)*_Buf2;\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf1 + 1);\nuVar3 = (uint)*(byte *)((int)_Buf2 + 1);\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf1 + 2);\nuVar3 = (uint)*(byte *)((int)_Buf2 + 2);\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf1 + 3);\nuVar3 = (uint)*(byte *)((int)_Buf2 + 3);\ngoto LAB_1002100d;\n}\nfor (; 0x1f < _Size; _Size = _Size - 0x20) {\n\n\nif (*_Buf1 == *_Buf2) {\niVar1 = 0;\n}\nelse {\n\nuVar3 = (uint)*_Buf1;\n\nuVar2 = (uint)*_Buf2;\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 1);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 1);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 2);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 2);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 3) - (uint)*(byte *)((int)_Buf2 + 3);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 4) == *(int *)((int)_Buf2 + 4)) {\niVar1 = 0;\n}\nelse {\nuVar3 = (uint)*(byte *)((int)_Buf1 + 4);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 4);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 5);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 5);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 6);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 6);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 7) - (uint)*(byte *)((int)_Buf2 + 7);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 8) == *(int *)((int)_Buf2 + 8)) {\niVar1 = 0;\n}\nelse {\nuVar3 = (uint)*(byte *)((int)_Buf1 + 8);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 8);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 9);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 9);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 10);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 10);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 0xb) - (uint)*(byte *)((int)_Buf2 + 0xb);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 0xc) == *(int *)((int)_Buf2 + 0xc)) {\niVar1 = 0;\n}\nelse {\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0xc);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0xc);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0xd);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0xd);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0xe);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0xe);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 0xf) - (uint)*(byte *)((int)_Buf2 + 0xf);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 0x10) == *(int *)((int)_Buf2 + 0x10)) {\niVar1 = 0;\n}\nelse {\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x10);\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x10);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x11);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x11);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x12);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x12);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 0x13) - (uint)*(byte *)((int)_Buf2 + 0x13);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 0x14) == *(int *)((int)_Buf2 + 0x14)) {\niVar1 = 0;\n}\nelse {\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x14);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x14);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x15);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x15);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x16);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x16);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 0x17) - (uint)*(byte *)((int)_Buf2 + 0x17);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 0x18) == *(int *)((int)_Buf2 + 0x18)) {\niVar1 = 0;\n}\nelse {\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x18);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x18);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x19);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x19);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x1a);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x1a);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 0x1b) - (uint)*(byte *)((int)_Buf2 + 0x1b);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nif (*(int *)((int)_Buf1 + 0x1c) == *(int *)((int)_Buf2 + 0x1c)) {\niVar1 = 0;\n}\nelse {\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x1c);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x1c);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x1d);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x1d);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + 0x1e);\nuVar2 = (uint)*(byte *)((int)_Buf2 + 0x1e);\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + 0x1f) - (uint)*(byte *)((int)_Buf2 + 0x1f);\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\n_Buf1 = (void *)((int)_Buf1 + 0x20);\n_Buf2 = (void *)((int)_Buf2 + 0x20);\n}\nswitch(_Size) {\ndefault:\ngoto switchD_1001ff7b_caseD_0;\ncase 1:\ngoto switchD_1001ff7b_caseD_1;\ncase 2:\ngoto switchD_1001ff7b_caseD_2;\ncase 3:\ngoto switchD_1001ff7b_caseD_3;\ncase 4:\ngoto switchD_1001ff7b_caseD_4;\ncase 5:\ngoto switchD_1001ff7b_caseD_5;\ncase 6:\ngoto switchD_1001ff7b_caseD_6;\ncase 7:\ngoto switchD_1001ff7b_caseD_7;\ncase 8:\ngoto switchD_1001ff7b_caseD_8;\ncase 9:\ngoto switchD_1001ff7b_caseD_9;\ncase 10:\ngoto switchD_1001ff7b_caseD_a;\ncase 0xb:\ngoto switchD_1001ff7b_caseD_b;\ncase 0xc:\ngoto switchD_1001ff7b_caseD_c;\ncase 0xd:\ngoto switchD_1001ff7b_caseD_d;\ncase 0xe:\ngoto switchD_1001ff7b_caseD_e;\ncase 0xf:\ngoto switchD_1001ff7b_caseD_f;\ncase 0x10:\ngoto switchD_1001ff7b_caseD_10;\ncase 0x11:\ngoto switchD_1001ff7b_caseD_11;\ncase 0x12:\ngoto switchD_1001ff7b_caseD_12;\ncase 0x13:\ngoto switchD_1001ff7b_caseD_13;\ncase 0x14:\ngoto switchD_1001ff7b_caseD_14;\ncase 0x15:\ngoto switchD_1001ff7b_caseD_15;\ncase 0x16:\ngoto switchD_1001ff7b_caseD_16;\ncase 0x17:\ngoto switchD_1001ff7b_caseD_17;\ncase 0x18:\ngoto switchD_1001ff7b_caseD_18;\ncase 0x1a:\ngoto switchD_1001ff7b_caseD_1a;\ncase 0x1b:\ngoto switchD_1001ff7b_caseD_1b;\ncase 0x1c:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x1c));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x1c))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x19));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_18:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x18));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x18))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x15));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_14:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x14));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x14))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x11));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_10:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x10));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x10))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xd));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_c:\nif (*(int *)((int)_Buf1 + (_Size - 0xc)) == *(int *)((int)_Buf2 + (_Size - 0xc))) {\niVar1 = 0;\n}\nelse {\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 9)) - (uint)*(byte *)((int)_Buf2 + (_Size - 9));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_8:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 8));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 8))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 5)) - (uint)*(byte *)((int)_Buf2 + (_Size - 5));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 == 0) {\nswitchD_1001ff7b_caseD_4:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 4));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 4))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));\nif ((uVar2 == uVar3) ||\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 == 0)) {\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));\nif ((uVar3 == uVar2) ||\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 == 0)) {\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 2));\nif (((uVar3 == uVar2) ||\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 == 0))\n&& (iVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 1)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 1)), iVar1 != 0)) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\n}\n}\nif (iVar1 == 0) {\nswitchD_1001ff7b_caseD_0:\niVar1 = 0;\n}\n}\nreturn iVar1;\ncase 0x1d:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x1d));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x1d))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\ncase 0x19:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x19));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x19))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x16));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_15:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x15));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x15))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x12));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_11:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x11));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x11))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xe));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_d:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0xd));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0xd))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 10));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_9:\nif (*(int *)((int)_Buf1 + (_Size - 9)) == *(int *)((int)_Buf2 + (_Size - 9))) {\niVar1 = 0;\n}\nelse {\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 6)) - (uint)*(byte *)((int)_Buf2 + (_Size - 6));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_5:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 5));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 5))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 2)) - (uint)*(byte *)((int)_Buf2 + (_Size - 2));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_1:\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 1));\nuVar2 = (uint)*(byte *)((int)_Buf1 + (_Size - 1));\nif (uVar2 == uVar3) {\nreturn 0;\n}\nreturn (uint)(0 < (int)(uVar2 - uVar3)) * 2 + -1;\ncase 0x1e:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x1e));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x1e))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_1a:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x1a));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x1a))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x17));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_16:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x16));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x16))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x13));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_12:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x12));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x12))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xf));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_e:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0xe));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0xe))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xc));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xb));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_a:\nif (*(int *)((int)_Buf1 + (_Size - 10)) == *(int *)((int)_Buf2 + (_Size - 10))) {\niVar1 = 0;\n}\nelse {\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 8));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 7)) - (uint)*(byte *)((int)_Buf2 + (_Size - 7));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_6:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 6));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 6))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 4));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 3)) - (uint)*(byte *)((int)_Buf2 + (_Size - 3));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_2:\nif (*(short *)((int)_Buf1 + (_Size - 2)) != *(short *)((int)_Buf2 + (_Size - 2))) {\nLAB_10020b61:\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 2));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\ngoto switchD_1001ff7b_caseD_1;\n}\ngoto switchD_1001ff7b_caseD_0;\ncase 0x1f:\nif (*(int *)((int)_Buf1 + (_Size - 0x1f)) == *(int *)((int)_Buf2 + (_Size - 0x1f))) {\niVar1 = 0;\n}\nelse {\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1f));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1f));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1e));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_1b:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x1b));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x1b))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x18));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_17:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x17));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x17))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x14));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_13:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0x13));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0x13))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x10));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_f:\nif (*(int *)((int)_Buf1 + (_Size - 0xf)) == *(int *)((int)_Buf2 + (_Size - 0xf))) {\niVar1 = 0;\n}\nelse {\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xf));\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xc));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_b:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 0xb));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 0xb))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 10));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 9));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 8)) - (uint)*(byte *)((int)_Buf2 + (_Size - 8));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_7:\nuVar2 = *(uint *)((int)_Buf1 + (_Size - 7));\nif (uVar2 == *(uint *)((int)_Buf2 + (_Size - 7))) {\niVar1 = 0;\n}\nelse {\nuVar2 = uVar2 & 0xff;\nuVar3 = (uint)*(byte *)((int)_Buf2 + (_Size - 7));\nif ((uVar2 != uVar3) &&\n(iVar1 = (uint)(uVar2 != uVar3 && -1 < (int)(uVar2 - uVar3)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 6));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 5));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\niVar1 = (uint)*(byte *)((int)_Buf1 + (_Size - 4)) - (uint)*(byte *)((int)_Buf2 + (_Size - 4));\nif (iVar1 != 0) {\niVar1 = (uint)(0 < iVar1) * 2 + -1;\n}\n}\nif (iVar1 != 0) {\nreturn iVar1;\n}\nswitchD_1001ff7b_caseD_3:\nuVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3));\nuVar2 = (uint)*(byte *)((int)_Buf2 + (_Size - 3));\nif ((uVar3 != uVar2) &&\n(iVar1 = (uint)(uVar3 != uVar2 && -1 < (int)(uVar3 - uVar2)) * 2 + -1, iVar1 != 0)) {\nreturn iVar1;\n}\ngoto LAB_10020b61;\n}\n}"}
{"Function Name": "_strpbrk", "Address": "10021140", "Source Code": "char * __cdecl _strpbrk(char *inputString, char *controlString)\n{\n    byte currentChar; \n    byte *unusedPointer; \n    byte charPresenceBits[32] = {0}; \n    while (true) {\n        currentChar = *controlString; \n        if (currentChar == 0) break; \n        controlString++; \n        charPresenceBits[currentChar >> 3] |= 1 << (currentChar & 7); \n    }\n    \n    while (true) {\n        currentChar = *inputString; \n        if (currentChar == 0) return NULL; \n        inputString++; \n        if (charPresenceBits[currentChar >> 3] & (1 << (currentChar & 7))) { \n            return (char *)(inputString - 1); \n        }\n    }\n}"}
{"Function Name": "__crtGetLocaleInfoW_stat", "Address": "1002131e", "Source Code": "int __cdecl\n__crtGetLocaleInfoW_stat\n(localeinfo_struct *param_1, ulong param_2, ulong param_3, wchar_t *param_4, int param_5, int param_6)\n{\n    uint uVar1; \n    int iVar2; \n    DWORD DVar3; \n    uint cchData; \n    undefined4 *lpLCData; \n    uVar1 = DAT_100345e0 ^ (uint)&stack0xfffffffc; \n    if (DAT_10036664 == 0) { \n        iVar2 = GetLocaleInfoW(0, 1, (LPWSTR)0x0, 0); \n        if (iVar2 == 0) { \n            DVar3 = GetLastError(); \n            if (DVar3 == 0x78) { \n                DAT_10036664 = 2; \n            }\n            goto LAB_10021370; \n        }\n        DAT_10036664 = 1; \n    }\nLAB_10021370:\n    if (DAT_10036664 != 1) { \n        if ((DAT_10036664 == 2) || (DAT_10036664 == 0)) { \n            if (param_6 == 0) { \n                param_6 = param_1->locinfo->lc_codepage; \n            }\n            cchData = GetLocaleInfoA(param_2, param_3, (LPSTR)0x0, 0); \n            if (cchData != 0) { \n                if (((int)cchData < 1) || (0xffffffe0 / cchData == 0)) { \n                    lpLCData = (undefined4 *)0x0; \n                } else if (cchData + 8 < 0x401) { \n                    lpLCData = (undefined4 *)&stack0xfffffff0; \n                } else {\n                    lpLCData = (undefined4 *)_malloc(cchData + 8); \n                    if (lpLCData != (undefined4 *)0x0) { \n                        *lpLCData = 0xdddd; \n                        lpLCData = lpLCData + 2; \n                    }\n                }\n                if (lpLCData != (undefined4 *)0x0) { \n                    iVar2 = GetLocaleInfoA(param_2, param_3, (LPSTR)lpLCData, cchData); \n                    if (iVar2 != 0) { \n                        if (param_5 == 0) { \n                            param_4 = (LPWSTR)0x0; \n                        }\n                        MultiByteToWideChar(param_6, 1, (LPCSTR)lpLCData, -1, param_4, param_5); \n                    }\n                    __freea(lpLCData); \n                }\n            }\n        }\n    }\n    GetLocaleInfoW(param_2, param_3, param_4, param_5); \nLAB_10021447:\n    iVar2 = ___security_check_cookie_4(uVar1 ^ (uint)&stack0xfffffffc); \n    return iVar2; \n}"}
{"Function Name": "___crtGetLocaleInfoW", "Address": "10021459", "Source Code": "void __cdecl\n___crtGetLocaleInfoW\n(localeinfo_struct *param_1, ulong param_2, ulong param_3, wchar_t *param_4, int param_5, int param_6)\n{\n    localeinfo_struct local_14; \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14, param_1); \n    __crtGetLocaleInfoW_stat(&local_14, param_2, param_3, param_4, param_5, param_6); \n    if (*(char *)&local_14 != '\\0') { \n        *(uint *)((char *)&local_14 + 0x70) &= 0xfffffffd; \n    }\n    return; \n}"}
{"Function Name": "__crtGetLocaleInfoA_stat", "Address": "10021494", "Source Code": "int __cdecl\n__crtGetLocaleInfoA_stat\n(localeinfo_struct *param_1, ulong param_2, ulong param_3, char *param_4, int param_5, int param_6)\n{\n    uint uVar1; \n    int iVar2; \n    DWORD DVar3; \n    uint cchData; \n    undefined4 *lpLCData; \n    uVar1 = DAT_100345e0 ^ (uint)&stack0xfffffffc; \n    if (DAT_10036668 == 0) { \n        iVar2 = GetLocaleInfoW(0, 1, (LPWSTR)0x0, 0); \n        if (iVar2 == 0) { \n            DVar3 = GetLastError(); \n            if (DVar3 == 0x78) { \n                DAT_10036668 = 2; \n            }\n            goto LAB_100214e6; \n        }\n        DAT_10036668 = 1; \n    }\n    else {\n    LAB_100214e6: \n        if ((DAT_10036668 == 2) || (DAT_10036668 == 0)) { \n            GetLocaleInfoA(param_2, param_3, param_4, param_5); \n            goto LAB_100215bf; \n        }\n        if (DAT_10036668 != 1) goto LAB_100215bf; \n    }\n    if (param_6 == 0) { \n        param_6 = param_1->locinfo->lc_codepage; \n    }\n    cchData = GetLocaleInfoW(param_2, param_3, (LPWSTR)0x0, 0); \n    if (cchData != 0) { \n        if (cchData < 1 || 0xffffffe0 / cchData < 2) { \n            lpLCData = (undefined4 *)0x0; \n        }\n        else {\n            uint _Size = cchData * 2 + 8; \n            if (_Size < 0x401) { \n                lpLCData = (undefined4 *)&stack0xfffffff0; \n            }\n            else {\n                lpLCData = (undefined4 *)_malloc(_Size); \n                if (lpLCData != (undefined4 *)0x0) { \n                    *lpLCData = 0xdddd; \n                    lpLCData += 2; \n                }\n            }\n        }\n    }\n    if (lpLCData != (undefined4 *)0x0) { \n        iVar2 = GetLocaleInfoW(param_2, param_3, (LPWSTR)lpLCData, cchData); \n        if (iVar2 != 0) { \n            if (param_5 == 0) { \n                param_4 = (LPSTR)0x0; \n            }\n            WideCharToMultiByte(param_6, 0, (LPCWSTR)lpLCData, -1, param_4, param_5, (LPCSTR)0x0, (LPBOOL)0x0); \n        }\n        __freea(lpLCData); \n    }\nLAB_100215bf: \n    iVar2 = ___security_check_cookie_4(uVar1 ^ (uint)&stack0xfffffffc); \n    return iVar2; \n}"}
{"Function Name": "___crtGetLocaleInfoA", "Address": "100215d1", "Source Code": "int __cdecl\n___crtGetLocaleInfoA\n(_locale_t _Plocinfo, LPCWSTR _LocaleName, LCTYPE _LCType, LPSTR _LpLCData, int _CchData)\n{\n    localeinfo_struct local_14; \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_14, _Plocinfo); \n    return __crtGetLocaleInfoA_stat(&local_14, (ulong)_LocaleName, _LCType, _LpLCData, _CchData, 0); \n}"}
{"Function Name": "__global_unwind2", "Address": "1002161c", "Source Code": "void __cdecl __global_unwind2(PVOID target_frame)\n{\n    \n    \n    \n    \n    \n    RtlUnwind(target_frame, (PVOID)0x10021634, NULL, NULL);\n}"}
{"Function Name": "__local_unwind2", "Address": "10021681", "Source Code": "void __cdecl __local_unwind2(int context_ptr, uint max_value)\n{\n    uint current_value;                \n    void *original_exception_list;           \n    original_exception_list = exception_list_pointer; \n    exception_list_pointer = &original_exception_list; \n    while (true) {            \n        current_value = *(uint *)(context_ptr + 0xc); \n        if ((current_value == 0xffffffff) || ((max_value != 0xffffffff && (current_value <= max_value)))) break; \n        *(undefined4 *)(context_ptr + 0xc) = *(undefined4 *)(*(int *)(context_ptr + 8) + current_value * 0xc); \n        if (*(int *)(*(int *)(context_ptr + 8) + 4 + current_value * 0xc) == 0) { \n            __NLG_Notify(0x101); \n            FUN_10021750(); \n        }\n    }\n    exception_list_pointer = original_exception_list; \n    return; \n}"}
{"Function Name": "__NLG_Notify", "Address": "10021731", "Source Code": "void __NLG_Notify(ulong inputParameter)\n{\n    \n    globalValue1 = inputParameter;\n    \n    globalValue2 = eaxRegister;\n    \n    globalValue3 = ebpRegister;\n}"}
{"Function Name": "___crtInitCritSecAndSpinCount", "Address": "1002182a", "Source Code": "int __cdecl ___crtInitCritSecAndSpinCount(undefined4 inputParam1, undefined4 inputParam2)\n{\n    code *functionPointer; \n    int returnValue; \n    HMODULE moduleHandle; \n    int osPlatformInfo[5] = {0}; \n    \n    functionPointer = (code *)__decode_pointer(DAT_10036670);\n    \n    if (functionPointer != (FARPROC)0x0) goto LAB_100218a0;\n    \n    returnValue = __get_osplatform(osPlatformInfo);\n    \n    if (returnValue != 0) {\n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    \n    if (osPlatformInfo[0] == 1) {\n        functionPointer = ___crtInitCritSecNoSpinCount_8; \n    } else {\n        \n        moduleHandle = GetModuleHandleA(\"kernel32.dll\");\n        \n        if (moduleHandle == (HMODULE)0x0) goto LAB_1002188f;\n        \n        functionPointer = GetProcAddress(moduleHandle, \"InitializeCriticalSectionAndSpinCount\");\n        \n        if (functionPointer == (FARPROC)0x0) goto LAB_1002188f;\n    }\n    \n    DAT_10036670 = __encode_pointer((int)functionPointer);\nLAB_100218a0:\n    \n    returnValue = (*functionPointer)(inputParam1, inputParam2);\n    return returnValue; \n}"}
{"Function Name": "__FindPESection", "Address": "10021920", "Source Code": "PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE imageBase, DWORD_PTR relativeVirtualAddress)\n{\n    \n    int peHeaderOffset = *(int *)(imageBase + 0x3c);\n    \n    \n    PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)(imageBase + *(ushort *)(imageBase + peHeaderOffset + 0x14) + 0x18 + peHeaderOffset);\n    \n    \n    ushort numberOfSections = *(ushort *)(imageBase + peHeaderOffset + 6);\n    \n    for (uint sectionIndex = 0; sectionIndex < numberOfSections; sectionIndex++, sectionHeader++) {\n        \n        if (sectionHeader->VirtualAddress <= relativeVirtualAddress && relativeVirtualAddress < (sectionHeader->Misc).PhysicalAddress + sectionHeader->VirtualAddress) {\n            \n            return sectionHeader;\n        }\n    }\n    \n    \n    return (PIMAGE_SECTION_HEADER)0x0;\n}"}
{"Function Name": "__IsNonwritableInCurrentImage", "Address": "10021962", "Source Code": "BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE targetAddress)\n{\n    PIMAGE_SECTION_HEADER sectionHeader; \n    PBYTE imageBase; \n    \n    if (__ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_10000000) &&\n        (sectionHeader = __FindPESection(imageBase, (int)targetAddress - (int)imageBase), \n        sectionHeader != (PIMAGE_SECTION_HEADER)0x0)) { \n        return ~(sectionHeader->Characteristics >> 0x1f) & 1; \n    }\n    return 0; \n}"}
{"Function Name": "_strrchr", "Address": "100219d0", "Source Code": "char * __cdecl _strrchr(char *inputString, int targetChar) \n{\n    char *currentCharPtr = inputString; \n    char *resultPtr = (char *)0x0; \n    while (*currentCharPtr != '\\0') { \n        currentCharPtr++; \n    }\n    while (currentCharPtr != inputString) { \n        currentCharPtr--; \n        if ((char)targetChar == *currentCharPtr) { \n            return currentCharPtr; \n        }\n    }\n    \n    return (char *)0x0; \n}"}
{"Function Name": "__fptostr", "Address": "10021b49", "Source Code": "errno_t __cdecl __fptostr(char *buffer, size_t bufferSize, int digitCount, STRFLT floatPointStruct)\n{\n    char *bufferPtr; \n    char *mantissaPtr; \n    errno_t errorCode; \n    mantissaPtr = floatPointStruct->mantissa; \n    if ((buffer == (char *)0x0) || (bufferSize == 0)) { \n        *(__errno()) = 0x16; \n        return 0x16; \n    }\n    *buffer = '\\0'; \n    if (digitCount < 1) { \n        digitCount = 0; \n    }\n    if (digitCount + 1U < bufferSize) { \n        *buffer = '0'; \n        bufferPtr = buffer + 1; \n        if (0 < digitCount) { \n            do {\n                char currentChar = *mantissaPtr ? *mantissaPtr++ : '0'; \n                *bufferPtr++ = currentChar; \n                digitCount--; \n            } while (0 < digitCount); \n        }\n        *bufferPtr = '\\0'; \n        if ((-1 < digitCount) && ('4' < *mantissaPtr)) { \n            while (*--bufferPtr == '9') { \n                *bufferPtr = '0'; \n            }\n            (*bufferPtr)++; \n        }\n        if (*buffer == '1') { \n            floatPointStruct->decpt++; \n        } else {\n            _memmove(buffer, buffer + 1, _strlen(buffer + 1) + 1); \n        }\n        return 0; \n    }\n    \n    *(__errno()) = 0x22; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return 0x22; \n}"}
{"Function Name": "__alldvrm", "Address": "10021d50", "Source Code": "undefined8 __alldvrm(uint dividend, uint divisor, uint adjustedDividend, uint adjustedDivisor)\n{\n    ulonglong intermediateResult; \n    longlong longCalculation;  \n    uint result;      \n    int integerQuotient;       \n    uint adjustedDivisor;      \n    uint adjustedDividend;      \n    uint intermediateCalculation;      \n    uint halvedParam4;      \n    bool conditionFlag;     \n    char signFlag;     \n    signFlag = (int)divisor < 0; \n    if (signFlag) {\n        conditionFlag = dividend != 0; \n        dividend = -dividend;    \n        divisor = -(uint)conditionFlag - divisor; \n    }\n    if ((int)adjustedDivisor < 0) {\n        signFlag++; \n        conditionFlag = adjustedDividend != 0; \n        adjustedDividend = -adjustedDividend;    \n        adjustedDivisor = -(uint)conditionFlag - adjustedDivisor; \n    }\n    result = dividend; \n    adjustedDivisor = adjustedDividend; \n    adjustedDividend = divisor; \n    if (adjustedDivisor == 0) { \n        result = divisor / adjustedDividend; \n        integerQuotient = (int)(((ulonglong)divisor % (ulonglong)adjustedDividend << 0x20 | (ulonglong)dividend) / (ulonglong)adjustedDividend); \n    } else {\n        do {\n            halvedParam4 = adjustedDivisor >> 1; \n            adjustedDivisor = adjustedDivisor >> 1 | (uint)((adjustedDivisor & 1) != 0) << 0x1f; \n            intermediateCalculation = adjustedDividend >> 1; \n            result = result >> 1 | (uint)((adjustedDividend & 1) != 0) << 0x1f; \n            adjustedDividend = intermediateCalculation; \n            adjustedDivisor = halvedParam4; \n        } while (halvedParam4 != 0); \n        intermediateResult = CONCAT44(intermediateCalculation, result) / (ulonglong)adjustedDivisor; \n        integerQuotient = (int)intermediateResult; \n        longCalculation = (ulonglong)adjustedDividend * (intermediateResult & 0xffffffff); \n        result = (uint)((ulonglong)longCalculation >> 0x20); \n        adjustedDivisor = result + integerQuotient * adjustedDivisor; \n        \n        if (CARRY4(result, integerQuotient * adjustedDivisor) || (divisor < adjustedDivisor) || (divisor <= adjustedDivisor && (dividend < (uint)longCalculation))) {\n            integerQuotient--; \n        }\n    }\n    if (signFlag) { \n        conditionFlag = integerQuotient != 0; \n        integerQuotient = -integerQuotient; \n        result = -(uint)conditionFlag; \n    }\n    return CONCAT44(result, integerQuotient); \n}"}
{"Function Name": "__aullshr", "Address": "10021e30", "Source Code": "ulonglong __fastcall __aullshr(byte shift_amount, uint value)\n{\n    \n    if (shift_amount > 0x3f) {\n        return 0; \n    }\n    \n    \n    if (shift_amount < 0x20) {\n        \n        return CONCAT44(value >> (shift_amount & 0x1f), \n                        value << (0x20 - (shift_amount & 0x1f)) >> (shift_amount & 0x1f));\n    }\n    \n    \n    return (ulonglong)(value >> (shift_amount & 0x1f));\n}"}
{"Function Name": "__controlfp_s", "Address": "10021e58", "Source Code": "errno_t __cdecl __controlfp_s(uint *current_state, uint new_value, uint mask)\n{\n    uint masked_value; \n    errno_t error_code; \n    masked_value = mask & 0xfff7ffff; \n    if ((new_value & masked_value & 0xfcf0fce0) == 0) { \n        if (current_state == (uint *)0x0) { \n            __control87(new_value, masked_value); \n        } else {\n            *current_state = __control87(new_value, masked_value); \n        }\n        error_code = 0; \n    } else {\n        if (current_state != (uint *)0x0) { \n            *current_state = __control87(0, 0); \n        }\n        *(__errno()) = 0x16; \n        error_code = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    return error_code; \n}"}
{"Function Name": "__allmul", "Address": "10021f50", "Source Code": "longlong __allmul(uint multiplicand1, uint multiplicand2, uint multiplier, uint additionalMultiplier)\n{\n    \n    if ((additionalMultiplier | multiplicand2) == 0) {\n        \n        return (ulonglong)multiplicand1 * (ulonglong)multiplier;\n    }\n    \n    return CONCAT44(\n        \n        \n        (int)((ulonglong)multiplicand1 * (ulonglong)multiplier >> 0x20) + multiplicand2 * multiplier + multiplicand1 * additionalMultiplier,\n        \n        \n        (int)((ulonglong)multiplicand1 * (ulonglong)multiplier)\n    );\n}"}
{"Function Name": "__lseeki64_nolock", "Address": "10021f84", "Source Code": "longlong __cdecl __lseeki64_nolock(int fileHandle, longlong offset, int origin)\n{\n    HANDLE fileHandle; \n    DWORD setPointerResult;  \n    DWORD lastErrorCode;  \n    LONG longOffset = (LONG)offset; \n    fileHandle = (HANDLE)__get_osfhandle(fileHandle); \n    if (fileHandle == (HANDLE)0xffffffff) { \n        *__errno() = 9; \n        return CONCAT44(-1, 0xffffffff); \n    } \n    setPointerResult = SetFilePointer(fileHandle, longOffset, NULL, origin); \n    if (setPointerResult == 0xffffffff) { \n        lastErrorCode = GetLastError(); \n        if (lastErrorCode != 0) { \n            __dosmaperr(lastErrorCode); \n            return CONCAT44(-1, 0xffffffff); \n        }\n    }\n    \n    byte *fileStructurePointer = (byte *)((&DAT_100366a0)[fileHandle >> 5] + 4 + (fileHandle & 0x1fU) * 0x28); \n    *fileStructurePointer &= 0xfd; \n    return CONCAT44(longOffset, setPointerResult); \n}"}
{"Function Name": "__lseeki64", "Address": "10022007", "Source Code": "longlong __cdecl __lseeki64(int file_handle, longlong offset, int origin)\n{\n    ulong *dos_error_pointer; \n    int *errno_pointer;   \n    int calculated_index;     \n    undefined8 return_value; \n    \n    if (file_handle == -2) {\n        dos_error_pointer = ___doserrno(); \n        *dos_error_pointer = 0;            \n        errno_pointer = __errno();     \n        *errno_pointer = 9;            \n    } else {\n        \n        if ((-1 < file_handle) && ((uint)file_handle < DAT_1003668c)) {\n            calculated_index = (file_handle & 0x1fU) * 0x28; \n            \n            if ((*(byte *)((&DAT_100366a0)[file_handle >> 5] + 4 + calculated_index) & 1) == 0) {\n                dos_error_pointer = ___doserrno(); \n                *dos_error_pointer = 0;            \n                errno_pointer = __errno();     \n                *errno_pointer = 9;            \n                __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n                return_value = -1;         \n            } else {\n                ___lock_fhandle(file_handle); \n                \n                if ((*(byte *)((&DAT_100366a0)[file_handle >> 5] + 4 + calculated_index) & 1) == 0) {\n                    errno_pointer = __errno();     \n                    *errno_pointer = 9;            \n                    dos_error_pointer = ___doserrno(); \n                    *dos_error_pointer = 0;            \n                    return_value = -1;         \n                } else {\n                    return_value = __lseeki64_nolock(file_handle, offset, origin); \n                }\n                FUN_10022116(); \n            }\n            goto LAB_10022110; \n        }\n        dos_error_pointer = ___doserrno(); \n        *dos_error_pointer = 0;            \n        errno_pointer = __errno();     \n        *errno_pointer = 9;            \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    return_value = -1; \nLAB_10022110:\n    return CONCAT44(return_value._4_4_, (undefined4)return_value); \n}"}
{"Function Name": "__write", "Address": "100226e6", "Source Code": "int __cdecl __write(int file_handle, void *buffer, uint max_char_count)\n{\n    ulong *dos_error_pointer; \n    int *errno_pointer;   \n    int temp_storage;  \n    \n    if (file_handle == -2) {\n        dos_error_pointer = ___doserrno(); \n        *dos_error_pointer = 0;            \n        errno_pointer = __errno();     \n        *errno_pointer = 9;            \n    } \n    \n    else if ((-1 < file_handle) && ((uint)file_handle < DAT_1003668c)) {\n        \n        if ((*(byte *)((&DAT_100366a0)[file_handle >> 5] + 4 + ((file_handle & 0x1fU) * 0x28)) & 1) != 0) {\n            ___lock_fhandle(file_handle); \n            \n            if ((*(byte *)((&DAT_100366a0)[file_handle >> 5] + 4 + ((file_handle & 0x1fU) * 0x28)) & 1) == 0) {\n                errno_pointer = __errno(); \n                *errno_pointer = 9;        \n                dos_error_pointer = ___doserrno(); \n                *dos_error_pointer = 0;        \n                return -1;          \n            }\n            return __write_nolock(file_handle, buffer, max_char_count); \n        }\n    }\n    dos_error_pointer = ___doserrno(); \n    *dos_error_pointer = 0;            \n    errno_pointer = __errno();     \n    *errno_pointer = 9;            \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return -1;              \n}"}
{"Function Name": "__wctomb_s_l", "Address": "1002287a", "Source Code": "errno_t __cdecl\n__wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)\n{\n    size_t _Size = _SizeInBytes; \n    char *lpMultiByteStr = _MbCh; \n    int iVar1 = 0; \n    int *piVar2; \n    DWORD DVar3; \n    char local_8; \n    \n    if (lpMultiByteStr == (char *)0x0 && _SizeInBytes != 0) {\n        \n        if (_SizeConverted != (int *)0x0) {\n            *_SizeConverted = 0;\n        }\n        return 0; \n    }\n    \n    if (_SizeConverted != (int *)0x0) {\n        *_SizeConverted = -1;\n    }\n    \n    \n    if (0x7fffffff < _SizeInBytes) {\n        piVar2 = __errno(); \n        *piVar2 = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return 0x16; \n    }\n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)0, _Locale);\n    \n    \n    if (*(int *)(0 + 0x14) == 0) {\n        \n        if ((ushort)_WCh < 0x100) {\n            \n            if (lpMultiByteStr != (char *)0x0 && _Size != 0) {\n                *lpMultiByteStr = (char)_WCh; \n            }\n            \n            if (_SizeConverted != (int *)0x0) {\n                *_SizeConverted = 1;\n            }\n            \n            if (local_8 != '\\0') {\n                *(uint *)(0 + 0x70) &= 0xfffffffd; \n            }\n            return 0; \n        }\n        \n        if (lpMultiByteStr != (char *)0x0 && _Size != 0) {\n            _memset(lpMultiByteStr, 0, _Size); \n        }\n    } else {\n        _MbCh = (char *)0x0; \n        \n        iVar1 = WideCharToMultiByte(*(UINT *)(0 + 4), 0, &_WCh, 1, lpMultiByteStr, _Size, (LPCSTR)0x0, (LPBOOL)&_MbCh);\n        \n        if (iVar1 == 0) {\n            DVar3 = GetLastError(); \n            \n            if (DVar3 == 0x7a) {\n                \n                if (lpMultiByteStr != (char *)0x0 && _Size != 0) {\n                    _memset(lpMultiByteStr, 0, _Size);\n                }\n                piVar2 = __errno(); \n                *piVar2 = 0x22; \n                __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n                \n                if (local_8 == '\\0') {\n                    return 0x22; \n                }\n                *(uint *)(0 + 0x70) &= 0xfffffffd; \n                return 0x22; \n            }\n        } else if (_MbCh == (char *)0x0) {\n            \n            if (_SizeConverted != (int *)0x0) {\n                *_SizeConverted = iVar1; \n            }\n            return 0; \n        }\n    }\n    piVar2 = __errno(); \n    *piVar2 = 0x2a; \n    \n    if (local_8 != '\\0') {\n        *(uint *)(0 + 0x70) &= 0xfffffffd; \n    }\n    return iVar1; \n}"}
{"Function Name": "__aulldvrm", "Address": "10022a00", "Source Code": "undefined8 __aulldvrm(uint input1, uint input2, uint input3, uint input4)\n{\n    ulonglong intermediateResult; \n    longlong multiplicationResult;  \n    uint quotient;      \n    int integerPart;       \n    uint loopCounter;      \n    uint shiftedInput2;      \n    uint shiftedInput4;      \n    \n    if (input4 == 0) {\n        \n        quotient = input2 / input3;\n        \n        integerPart = (int)(((ulonglong)input2 % (ulonglong)input3 << 0x20 | (ulonglong)input1) / (ulonglong)input3);\n    } else {\n        \n        shiftedInput2 = input2;\n        shiftedInput4 = input4;\n        \n        do {\n            loopCounter = shiftedInput4 >> 1; \n            \n            shiftedInput2 = shiftedInput2 >> 1 | (uint)((shiftedInput4 & 1) != 0) << 0x1f;\n            shiftedInput4 = loopCounter; \n        } while (loopCounter != 0); \n        \n        intermediateResult = CONCAT44(shiftedInput2 >> 1, quotient) / (ulonglong)(input3 >> 1);\n        integerPart = (int)intermediateResult; \n        multiplicationResult = (ulonglong)input3 * (intermediateResult & 0xffffffff); \n        quotient = (uint)((ulonglong)multiplicationResult >> 0x20); \n        shiftedInput4 = quotient + integerPart * input4; \n        \n        if (CARRY4(quotient, integerPart * input4) || (input2 < shiftedInput4) || ((input2 <= shiftedInput4 && (input1 < (uint)multiplicationResult)))) {\n            integerPart = integerPart - 1; \n        }\n        quotient = 0; \n    }\n    return CONCAT44(quotient, integerPart); \n}"}
{"Function Name": "_write_char", "Address": "10022a9f", "Source Code": "void __cdecl _write_char(wchar_t character)\n{\n    wint_t writeResult; \n    FILE *outputStream; \n    \n    if (((*(byte *)&outputStream->_flag & 0x40) == 0) || (outputStream->_base != (char *)0x0)) {\n        \n        writeResult = __fputwc_nolock(character, outputStream);\n        \n        if (writeResult == 0xffff) {\n            return; \n        }\n    }\n    \n    *charCount = *charCount + 1;\n}"}
{"Function Name": "_write_multi_char", "Address": "10022ac4", "Source Code": "void __cdecl _write_multi_char(wchar_t character, int count)\n{\n    \n    while (count > 0) {\n        \n        _write_char(character);\n        \n        count--;\n    }\n}"}
{"Function Name": "__commit", "Address": "1002344c", "Source Code": "int __cdecl __commit(int file_handle)\n{\n    int *errno_pointer; \n    HANDLE file_handle_os; \n    DWORD last_error_code; \n    \n    if (file_handle == -2) {\n        errno_pointer = __errno(); \n        *errno_pointer = 9; \n    } else {\n        \n        if ((-1 < file_handle) && ((uint)file_handle < DAT_1003668c)) {\n            \n            if ((*(byte *)(0x28 * (file_handle & 0x1fU) + 4 + (&DAT_100366a0)[file_handle >> 5]) & 1) != 0) {\n                ___lock_fhandle(file_handle); \n                \n                if ((*(byte *)(0x28 * (file_handle & 0x1fU) + 4 + (&DAT_100366a0)[file_handle >> 5]) & 1) != 0) {\n                    file_handle_os = (HANDLE)__get_osfhandle(file_handle); \n                    \n                    if (FlushFileBuffers(file_handle_os) == 0) {\n                        last_error_code = GetLastError(); \n                        ulong *dos_error_pointer = ___doserrno(); \n                        *dos_error_pointer = last_error_code; \n                    } else {\n                        last_error_code = 0; \n                    }\n                    goto LAB_1002350e; \n                }\n            }\n        }\n        errno_pointer = __errno(); \n        *errno_pointer = 9; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    return -1; \nLAB_1002350e:\n    FUN_10023523(); \n    return last_error_code; \n}"}
{"Function Name": "_xtoa_s@20", "Address": "100235cc", "Source Code": "int convert_to_string _xtoa_s_20(void *this, uint base, uint value, int is_negative)\n{\n    ulonglong division_result; \n    char *current_char_ptr; \n    int *error_ptr; \n    char *temp_char_ptr; \n    char current_char; \n    char *next_char_ptr; \n    int error_code; \n    uint char_count; \n    \n    if (this == (void *)0x0) {\n        error_ptr = __errno(); \n        *error_ptr = 0x16; \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        return 0x16; \n    }\n    \n    if (base == 0) {\n        error_ptr = __errno(); \n        error_code = 0x16; \n    } else {\n        *(undefined *)this = 0; \n        \n        if ((is_negative != 0) + 1 < base) {\n            \n            if (0x22 < value - 2) goto LAB_100235fe; \n            next_char_ptr = (char *)this; \n            \n            if (is_negative != 0) {\n                *(undefined *)this = 0x2d; \n                next_char_ptr = (char *)((int)this + 1); \n            }\n            char_count = (uint)(is_negative != 0); \n            current_char_ptr = next_char_ptr; \n            \n            do {\n                temp_char_ptr = current_char_ptr; \n                division_result = (ulonglong)-in_EAX; \n                in_EAX = in_EAX / value; \n                current_char = (char)(division_result % (ulonglong)value); \n                \n                current_char = (uint)(division_result % (ulonglong)value) < 10 ? current_char + '0' : current_char + 'W';\n                *temp_char_ptr = current_char; \n                char_count++; \n            } while ((in_EAX != 0) && (current_char_ptr = temp_char_ptr + 1, char_count < base)); \n            \n            if (char_count < base) {\n                temp_char_ptr[1] = '\\0'; \n                \n                do {\n                    current_char = *temp_char_ptr; \n                    *temp_char_ptr = *next_char_ptr; \n                    temp_char_ptr--; \n                    *next_char_ptr = current_char; \n                    next_char_ptr++; \n                } while (next_char_ptr < temp_char_ptr); \n                return 0; \n            }\n            *(undefined *)this = 0; \n        }\n        error_ptr = __errno(); \n        error_code = 0x22; \n    }\n    *error_ptr = error_code; \n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return error_code; \n}"}
{"Function Name": "__mbtowc_l", "Address": "100238b9", "Source Code": "int __cdecl __mbtowc_l(wchar_t *destinationWideChar, char *sourceChar, size_t sourceSizeInBytes, _locale_t locale)\n{\n    int conversionResult; \n    localeinfo_struct localeInfo; \n    \n    if ((sourceChar != (char *)0x0) && (sourceSizeInBytes != 0)) {\n        \n        if (*sourceChar != '\\0') {\n            \n            _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, locale);\n            \n            if ((localeInfo.locinfo)->lc_category[0].wlocale != (wchar_t *)0x0) {\n                \n                conversionResult = __isleadbyte_l((uint)(byte)*sourceChar, &localeInfo);\n                if (conversionResult == 0) {\n                    \n                    conversionResult = MultiByteToWideChar((localeInfo.locinfo)->lc_codepage, 9, sourceChar, 1, destinationWideChar, (uint)(destinationWideChar != (wchar_t *)0x0));\n                    \n                    if (conversionResult != 0) {\n                        return 1;\n                    }\n                } else {\n                    wchar_t *localeNameLength = (localeInfo.locinfo)->locale_name[3]; \n                    \n                    if ((((1 < (int)localeNameLength) && ((int)localeNameLength <= (int)sourceSizeInBytes)) &&\n                        (conversionResult = MultiByteToWideChar((localeInfo.locinfo)->lc_codepage, 9, sourceChar, (int)localeNameLength, destinationWideChar, (uint)(destinationWideChar != (wchar_t *)0x0)), conversionResult != 0)) ||\n                        (((localeInfo.locinfo)->locale_name[3] <= sourceSizeInBytes && (sourceChar[1] != '\\0')))) {\n                        return (int)localeNameLength; \n                    }\n                }\n                int *errnoPointer = __errno(); \n                *errnoPointer = 0x2a; \n                return -1; \n            }\n            \n            if (destinationWideChar != (wchar_t *)0x0) {\n                *destinationWideChar = (ushort)(byte)*sourceChar;\n            }\n            return 1; \n        }\n        \n        if (destinationWideChar != (wchar_t *)0x0) {\n            *destinationWideChar = L'\\0';\n        }\n    }\n    return 0; \n}"}
{"Function Name": "x_ismbbtype_l", "Address": "10024633", "Source Code": "int __cdecl x_ismbbtype_l(localeinfo_struct *locale_info, uint byte_index, int mask_value, int comparison_byte)\n{\n    uint result_value; \n    int locale_data; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&locale_data, locale_info);\n    \n    \n    if ((*(byte *)(locale_data + 0x1d + (byte_index & 0xff)) & (byte)comparison_byte) == 0) {\n        \n        if (mask_value == 0) {\n            result_value = 0;\n        } else {\n            \n            result_value = (uint)*(ushort *)(*(int *)(locale_data + 200) + (byte_index & 0xff) * 2) & mask_value;\n        }\n        \n        if (result_value == 0) goto LAB_10024675;\n    }\n    \n    \n    result_value = 1;\n    \nLAB_10024675: \n    return result_value; \n}"}
{"Function Name": "__alloca_probe", "Address": "100246b0", "Source Code": "void __alloca_probe(void)\n{\n    undefined4 *pointerToUndefined4; \n    undefined4 returnAddress; \n    undefined stackAllocation[4]; \n    \n    pointerToUndefined4 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX));\n    \n    \n    for (undefined4 *loopPointer = (undefined4 *)((uint)stackAllocation & 0xfffff000); pointerToUndefined4 < loopPointer; loopPointer -= 0x400) {\n        \n    }\n    \n    \n    *pointerToUndefined4 = returnAddress;\n}"}
{"Function Name": "___ascii_stricmp", "Address": "100246db", "Source Code": "int __cdecl ___ascii_stricmp(char *str1, char *str2)\n{\n    uint asciiChar1, asciiChar2; \n    do {\n        asciiChar1 = (uint)(byte)*str1++; \n        if (asciiChar1 >= 0x41 && asciiChar1 <= 0x5A) { \n            asciiChar1 += 0x20; \n        }\n        asciiChar2 = (uint)(byte)*str2++; \n        if (asciiChar2 >= 0x41 && asciiChar2 <= 0x5A) { \n            asciiChar2 += 0x20; \n        }\n    } while (asciiChar1 != 0 && asciiChar1 == asciiChar2); \n    \n    return asciiChar1 - asciiChar2; \n}"}
{"Function Name": "__stricmp", "Address": "100247e3", "Source Code": "int __cdecl __stricmp(char *string1, char *string2)\n{\n    int intermediateResult; \n    \n    if (globalFlag == 0) {\n        \n        if (string1 != (char *)0x0 && string2 != (char *)0x0) {\n            \n            return ___ascii_stricmp(string1, string2);\n        }\n        \n        *__errno() = 0x16;\n        \n        __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        \n        return 0x7fffffff;\n    } else {\n        \n        return __stricmp_l(string1, string2, (_locale_t)0x0);\n    }\n}"}
{"Function Name": "__strnicmp_l", "Address": "10024833", "Source Code": "int __cdecl __strnicmp_l(char *str1, char *str2, size_t max_count, _locale_t locale)\n{\n    int comparison_result; \n    localeinfo_struct locale_info; \n    if (max_count == 0) { \n        comparison_result = 0; \n    } else {\n        _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&locale_info, locale); \n        if ((str1 == (char *)0x0) || (str2 == (char *)0x0)) { \n            int *errno_ptr = __errno(); \n            *errno_ptr = 0x16; \n            __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            comparison_result = 0x7fffffff; \n        } else if (max_count < 0x80000000) { \n            if ((locale_info.locinfo)->lc_category[0].wlocale == (wchar_t *)0x0) { \n                comparison_result = ___ascii_strnicmp(str1, str2, max_count); \n            } else {\n                do {\n                    int lowercase_char_str1 = __tolower_l((uint)(byte)*str1, &locale_info); \n                    str1++; \n                    int lowercase_char_str2 = __tolower_l((uint)(byte)*str2, &locale_info); \n                    str2++; \n                    max_count--; \n                    if ((max_count == 0) || (lowercase_char_str1 == 0)) break; \n                    comparison_result = lowercase_char_str1 - lowercase_char_str2; \n                } while (comparison_result == 0); \n            }\n        } else {\n            int *errno_ptr = __errno(); \n            *errno_ptr = 0x16; \n            __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            comparison_result = 0x7fffffff; \n        }\n    }\n    return comparison_result; \n}"}
{"Function Name": "__strnicmp", "Address": "10024923", "Source Code": "int __cdecl __strnicmp(char *string1, char *string2, size_t maxCount)\n{\n    int comparisonResult; \n    \n    if (globalFlag == 0) {\n        \n        if (string1 != NULL && string2 != NULL && maxCount < 0x80000000) {\n            \n            comparisonResult = ___ascii_strnicmp(string1, string2, maxCount);\n            return comparisonResult; \n        }\n        \n        *(__errno()) = 0x16;\n        \n        __invalid_parameter(NULL, NULL, NULL, 0, 0);\n        comparisonResult = 0x7fffffff; \n    } else {\n        \n        comparisonResult = __strnicmp_l(string1, string2, maxCount, (locale_t)0x0);\n    }\n    return comparisonResult; \n}"}
{"Function Name": "___wtomb_environ", "Address": "1002577b", "Source Code": "int __cdecl ___wtomb_environ(void)\n{\n    LPCWSTR wideCharString; \n    size_t byteCount; \n    LPCWSTR *wideCharArrayPtr; \n    LPSTR multiByteString; \n    multiByteString = (LPSTR)0x0; \n    wideCharArrayPtr = DAT_10036474; \n    while (true) { \n        wideCharString = *wideCharArrayPtr; \n        if (wideCharString == (LPCWSTR)0x0) { \n            return 0; \n        }\n        byteCount = WideCharToMultiByte(0, 0, wideCharString, -1, (LPSTR)0x0, 0, (LPCSTR)0x0, (LPBOOL)0x0); \n        if ((byteCount == 0) || (multiByteString = (LPSTR)__calloc_crt(byteCount, 1), multiByteString == (LPSTR)0x0)) break; \n        if (WideCharToMultiByte(0, 0, wideCharString, -1, multiByteString, byteCount, (LPCSTR)0x0, (LPBOOL)0x0) == 0) { \n            _free(multiByteString); \n            return -1; \n        }\n        if (___crtsetenv(&multiByteString, 0) < 0 && multiByteString != (LPSTR)0x0) { \n            _free(multiByteString); \n            multiByteString = (LPSTR)0x0; \n        }\n        wideCharArrayPtr++; \n    }\n    return -1; \n}"}
{"Function Name": "__putwch_nolock", "Address": "10025810", "Source Code": "wint_t __cdecl __putwch_nolock(wchar_t wideChar) \n{\n    wint_t returnValue; \n    BOOL writeResult; \n    DWORD charsWrittenOrError; \n    CHAR multiByteBuffer[8]; \n    uint securityCookie; \n    securityCookie = DAT_100345e0 ^ (uint)&stack0xfffffffc; \n    if (DAT_100359f0 != 0) { \n        if (DAT_10035a20 == (HANDLE)0xfffffffe) { \n            ___initconout(); \n        }\n        if (DAT_10035a20 == (HANDLE)0xffffffff) goto LAB_100258b9; \n        writeResult = WriteConsoleW(DAT_10035a20, &wideChar, 1, &charsWrittenOrError, (LPVOID)0x0); \n        if (writeResult != 0) { \n            DAT_100359f0 = 1; \n            goto LAB_100258b9; \n        }\n        if ((DAT_100359f0 != 2) || (charsWrittenOrError = GetLastError(), charsWrittenOrError != 0x78)) goto LAB_100258b9; \n        DAT_100359f0 = 0; \n    }\n    charsWrittenOrError = WideCharToMultiByte(GetConsoleOutputCP(), 0, &wideChar, 1, multiByteBuffer, 5, (LPCSTR)0x0, (LPBOOL)0x0); \n    if (DAT_10035a20 != (HANDLE)0xffffffff) { \n        WriteConsoleA(DAT_10035a20, multiByteBuffer, charsWrittenOrError, &charsWrittenOrError, (LPVOID)0x0); \n    }\nLAB_100258b9: \n    returnValue = ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return returnValue; \n}"}
{"Function Name": "__fputwc_nolock", "Address": "100258d2", "Source Code": "wint_t __cdecl __fputwc_nolock(wchar_t wideChar, FILE *fileStream)\n{\n    wint_t returnValue; \n    uint fileDescriptor; \n    undefined *filePointer; \n    errno_t errorCode; \n    char highByte; \n    int fileDesc; \n    char unusedBuffer[8]; \n    int unusedVar; \n    \n    if ((*(byte *)&fileStream->_flag & 0x40) == 0) {\n        fileDesc = __fileno(fileStream); \n        \n        if (fileDesc == -1 || fileDesc == -2) {\n            filePointer = &DAT_10034eb8; \n        } else {\n            fileDescriptor = __fileno(fileStream); \n            \n            filePointer = (undefined *)((fileDescriptor & 0x1f) * 0x28 + (&DAT_100366a0)[fileDesc >> 5]);\n        }\n        \n        if ((filePointer[0x24] & 0x7f) != 2) {\n            fileDesc = __fileno(fileStream); \n            \n            if (fileDesc == -1 || fileDesc == -2) {\n                filePointer = &DAT_10034eb8; \n            } else {\n                fileDescriptor = __fileno(fileStream); \n                \n                filePointer = (undefined *)((fileDescriptor & 0x1f) * 0x28 + (&DAT_100366a0)[fileDesc >> 5]);\n            }\n            \n            if ((filePointer[0x24] & 0x7f) == 1) {\n                fileStream->_cnt--; \n                \n                if (fileStream->_cnt < 0) {\n                    fileDescriptor = __flsbuf((int)(char)wideChar, fileStream); \n                } else {\n                    *fileStream->_ptr = (char)wideChar; \n                    fileDescriptor = (uint)(byte)*fileStream->_ptr; \n                    fileStream->_ptr++; \n                }\n                \n                if (fileDescriptor != 0xffffffff) {\n                    fileStream->_cnt--; \n                    highByte = (char)((ushort)wideChar >> 8); \n                    \n                    if (fileStream->_cnt < 0) {\n                        __flsbuf((int)highByte, fileStream); \n                    } else {\n                        *fileStream->_ptr = highByte; \n                        fileStream->_ptr++; \n                    }\n                }\n                goto LAB_10025aa1; \n            }\n        }\n    }\n    \n    fileStream->_cnt -= 2; \n    \n    if (fileStream->_cnt < 0) {\n        __flswbuf((uint)(ushort)wideChar, fileStream); \n    } else {\n        *(wchar_t *)fileStream->_ptr = wideChar; \n        fileStream->_ptr += 2; \n    }\nLAB_10025aa1:\n    returnValue = ___security_check_cookie_4((uint)&stack0xfffffffc); \n    return returnValue; \n}"}
{"Function Name": "___ascii_strnicmp", "Address": "10025f50", "Source Code": "int __cdecl ___ascii_strnicmp(char *str1, char *str2, size_t maxCount)\n{\n    byte currentChar1; \n    char currentChar2; \n    if (maxCount != 0) { \n        do {\n            currentChar1 = *str1; \n            currentChar2 = *str2; \n            if (currentChar1 == 0 || currentChar2 == 0) break; \n            str1++; \n            str2++; \n            if (currentChar1 >= 'A' && currentChar1 <= 'Z') { \n                currentChar1 += 0x20; \n            }\n            if (currentChar2 >= 'A' && currentChar2 <= 'Z') { \n                currentChar2 += 0x20; \n            }\n            if (currentChar1 != currentChar2) { \n                return (currentChar1 < currentChar2) ? -1 : 1; \n            }\n            maxCount--; \n        } while (maxCount != 0); \n    }\n    return 0; \n}"}
{"Function Name": "___crtCompareStringA", "Address": "100263ac", "Source Code": "int __cdecl\n___crtCompareStringA\n(_locale_t _Plocinfo, LPCWSTR _LocaleName, DWORD _DwCmpFlags, LPCSTR _LpString1,\n int _CchCount1, LPCSTR _LpString2, int _CchCount2, int _Code_page)\n{\n    int iVar1; \n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&stack0xffffffec, _Plocinfo);\n    \n    \n    iVar1 = __crtCompareStringA_stat\n        ((localeinfo_struct *)_LocaleName, _DwCmpFlags, _CchCount1, _LpString2, _CchCount2,\n        (char *)_Code_page, 0, 0);\n    \n    \n    return iVar1;\n}"}
{"Function Name": "_copy_environ", "Address": "10026531", "Source Code": "char ** _copy_environ(void)\n{\n    char **copiedEnvVars = (char **)0x0; \n    char **originalEnvVars; \n    \n    if (originalEnvVars != (char **)0x0) {\n        char **tempEnvPtr = originalEnvVars; \n        \n        while (*tempEnvPtr != (char *)0x0) {\n            tempEnvPtr++; \n            copiedEnvVars = (char **)((int)copiedEnvVars + 1); \n        }\n        \n        copiedEnvVars = (char **)__calloc_crt((int)copiedEnvVars + 1, 4);\n        \n        if (copiedEnvVars == (char **)0x0) {\n            __amsg_exit(9); \n        }\n        tempEnvPtr = copiedEnvVars; \n        \n        while (*originalEnvVars != (char *)0x0) {\n            *tempEnvPtr = __strdup(*originalEnvVars); \n            tempEnvPtr++; \n            originalEnvVars++; \n        }\n        *tempEnvPtr = (char *)0x0; \n    }\n    return copiedEnvVars; \n}"}
{"Function Name": "___crtsetenv", "Address": "1002658e", "Source Code": "int __cdecl ___crtsetenv(char **optionPointer,int _Primary)\n{\n    uchar *envVarString; \n    uchar *equalSignPos; \n    int *errnoPointer; \n    uint existingVarCount; \n    char **envVarArray; \n    size_t stringSize; \n    char *destinationString; \n    errno_t errorStatus; \n    BOOL setVarResult; \n    bool isVarEmpty; \n    \n    if (optionPointer == (char **)0x0) {\n        errnoPointer = __errno(); \n        *errnoPointer = 0x16; \n        __invalid_parameter((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0); \n        return -1; \n    }\n    \n    envVarString = (uchar *)*optionPointer; \n    \n    if ((envVarString == (uchar *)0x0) || (equalSignPos = __mbschr(envVarString,0x3d), equalSignPos == (uchar *)0x0) || (envVarString == equalSignPos)) {\n        errnoPointer = __errno(); \n        *errnoPointer = 0x16; \n        return -1; \n    }\n    \n    isVarEmpty = equalSignPos[1] == '\\0'; \n    \n    \n    if (globalEnvVarArray == initializedEnvVarCount) {\n        globalEnvVarArray = _copy_environ(); \n    }\n    \n    \n    if (globalEnvVarArray == (char **)0x0) {\n        \n        if ((_Primary == 0) || (secondaryArray == (undefined4 *)0x0)) {\n            if (isVarEmpty) {\n                return 0; \n            }\n            \n            globalEnvVarArray = (char **)__malloc_crt(4);\n            if (globalEnvVarArray == (char **)0x0) {\n                return -1; \n            }\n            *globalEnvVarArray = (char *)0x0; \n            \n            if (secondaryArray == (undefined4 *)0x0) {\n                secondaryArray = (undefined4 *)__malloc_crt(4); \n                if (secondaryArray == (undefined4 *)0x0) {\n                    return -1; \n                }\n                *secondaryArray = 0; \n            }\n        } else {\n            \n            if (___wtomb_environ() != 0) {\n                errnoPointer = __errno(); \n                *errnoPointer = 0x16; \n                return -1; \n            }\n        }\n    }\n    \n    envVarArray = globalEnvVarArray; \n    \n    if (globalEnvVarArray == (char **)0x0) {\n        return -1; \n    }\n    \n    existingVarCount = _findenv(envVarString); \n    \n    if (((int)existingVarCount < 0) || (*envVarArray == (char *)0x0)) {\n        if (isVarEmpty) {\n            _free(envVarString); \n            *optionPointer = (char *)0x0; \n            return 0; \n        }\n        \n        if ((int)existingVarCount < 0) {\n            existingVarCount = -existingVarCount;\n        }\n        uint newArraySize = existingVarCount + 2; \n        \n        if ((int)newArraySize < (int)existingVarCount || 0x3ffffffe < newArraySize) {\n            return -1; \n        }\n        \n        envVarArray = (char **)__recalloc_crt(globalEnvVarArray, 4, newArraySize);\n        if (envVarArray == (char **)0x0) {\n            return -1; \n        }\n        envVarArray[existingVarCount] = (char *)envVarString; \n        (envVarArray + existingVarCount)[1] = (char *)0x0; \n        *optionPointer = (char *)0x0; \n    } else {\n        uchar **existingVarLocation = (uchar **)(envVarArray + existingVarCount); \n        _free(*existingVarLocation); \n        if (!isVarEmpty) {\n            *existingVarLocation = envVarString; \n            *optionPointer = (char *)0x0; \n            goto LAB_1002672d; \n        }\n        \n        while (*existingVarLocation != (uchar *)0x0) {\n            *existingVarLocation = existingVarLocation[1]; \n            existingVarCount++; \n            existingVarLocation = (uchar **)(envVarArray + existingVarCount); \n        }\n        \n        if (0x3ffffffe < existingVarCount || (envVarArray = (char **)__recalloc_crt(globalEnvVarArray, existingVarCount, 4), envVarArray == (char **)0x0)) {\n            goto LAB_1002672d; \n        }\n    }\n    globalEnvVarArray = envVarArray; \nLAB_1002672d:\n    \n    if (_Primary != 0) {\n        stringSize = _strlen((char *)envVarString); \n        destinationString = (char *)__calloc_crt(stringSize + 2, 1); \n        if (destinationString != (char *)0x0) {\n            errorStatus = _strcpy_s(destinationString, stringSize + 2, (char *)envVarString); \n            if (errorStatus != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            }\n            equalSignPos[(int)destinationString - (int)envVarString] = '\\0'; \n            setVarResult = SetEnvironmentVariableA(destinationString, (LPCSTR)(~-(uint)isVarEmpty & (uint)(equalSignPos + ((int)destinationString - (int)envVarString) + 1))); \n            if (setVarResult == 0) {\n                errnoPointer = __errno(); \n                *errnoPointer = 0x2a; \n            }\n            _free(destinationString); \n        }\n    }\n    \n    if (isVarEmpty) {\n        _free(envVarString); \n    }\n    return returnValue; \n}"}
{"Function Name": "___initconout", "Address": "100267d5", "Source Code": "void __cdecl initializeConsoleOutput(void) \n{\n    \n    createFileHandle(\"CONOUT$\", 0x40000000, 3, NULL, 3, 0, NULL);\n}"}
{"Function Name": "__flswbuf", "Address": "10026821", "Source Code": "int __cdecl __flswbuf(int character, FILE *fileStream)\n{\n    uint fileHandle = __fileno(fileStream); \n    uint fileFlags = fileStream->_flag; \n    int *errorPointer; \n    \n    if ((fileFlags & 0x82) == 0) {\n        errorPointer = __errno(); \n        *errorPointer = 9; \n        fileStream->_flag |= 0x20; \n        return 0xffff; \n    }\n    \n    \n    if ((fileFlags & 0x40) != 0) {\n        errorPointer = __errno(); \n        *errorPointer = 0x22; \n        fileStream->_flag |= 0x20; \n        return 0xffff; \n    }\n    \n    \n    if (fileFlags & 1) {\n        fileStream->_cnt = 0; \n        \n        if (!(fileFlags & 0x10)) {\n            fileStream->_flag |= 0x20; \n            return 0xffff; \n        }\n        fileStream->_ptr = fileStream->_base; \n        fileStream->_flag &= 0xfffffffe; \n    }\n    \n    fileStream->_cnt = 0; \n    fileStream->_flag = (fileFlags & 0xffffffef) | 2; \n    \n    if (((fileFlags & 0x10c) == 0) && \n        (FUN_1001a6b8() != (undefined **)(fileStream + 8) && \n        FUN_1001a6b8() != (undefined **)(fileStream + 0x10) || \n        __isatty(fileHandle) == 0)) {\n        __getbuf(fileStream); \n    }\n    \n    if ((*(ushort *)&fileStream->_flag & 0x108) == 0) {\n        undefined4 writeResult = CONCAT22(0, (short)character); \n        writeResult = __write(fileHandle, &writeResult, 2); \n    } else {\n        char *bufferBase = fileStream->_base; \n        char *currentPointer = fileStream->_ptr; \n        fileStream->_ptr = bufferBase + 2; \n        uint maxCharCount = (int)currentPointer - (int)bufferBase; \n        fileStream->_cnt = fileStream->_bufsiz - 2; \n        \n        if ((int)maxCharCount < 1) {\n            undefined *seekablePointer = (fileHandle == 0xffffffff || fileHandle == 0xfffffffe) ? &DAT_10034eb8 : \n                (undefined *)((fileHandle & 0x1f) * 0x28 + (&DAT_100366a0)[(int)fileHandle >> 5]);\n            \n            if ((seekablePointer[4] & 0x20) != 0 && __lseeki64(fileHandle, 0x200000000, 0) == -1) {\n                fileStream->_flag |= 0x20; \n                return 0xffff; \n            }\n        } else {\n            undefined4 writeResult = __write(fileHandle, bufferBase, maxCharCount); \n        }\n        *(short *)fileStream->_base = (short)character; \n    }\n    \n    if (writeResult == maxCharCount) {\n        return character & 0xffff; \n    }\n    fileStream->_flag |= 0x20; \n    return 0xffff; \n}"}
{"Function Name": "_strncat_s", "Address": "10026991", "Source Code": "errno_t __cdecl _strncat_s(char *destinationBuffer, rsize_t destinationSize, char *sourceString, rsize_t maxCopyCount)\n{\n    char *destinationPtr; \n    rsize_t remainingSize; \n    \n    if (maxCopyCount == 0) {\n        \n        if (destinationBuffer == (char *)0x0 && destinationSize == 0) {\n            return 0;\n        }\n    } else {\n        \n        if (destinationBuffer != (char *)0x0) {\n            destinationPtr = destinationBuffer; \n            remainingSize = destinationSize; \n            \n            while (remainingSize != 0 && *destinationPtr != '\\0') {\n                destinationPtr++; \n                remainingSize--; \n            }\n            \n            if (remainingSize != 0) {\n                \n                if (maxCopyCount == 0xffffffff) {\n                    \n                    while (remainingSize != 0) {\n                        *destinationPtr = *sourceString; \n                        if (*sourceString == '\\0') break; \n                        destinationPtr++; \n                        sourceString++; \n                        remainingSize--; \n                    }\n                } else if (maxCopyCount != 0) {\n                    \n                    while (maxCopyCount != 0 && remainingSize != 0) {\n                        *destinationPtr = *sourceString; \n                        if (*sourceString == '\\0') break; \n                        destinationPtr++; \n                        sourceString++; \n                        remainingSize--; \n                        maxCopyCount--; \n                    }\n                }\n                \n                if (maxCopyCount == 0) {\n                    *destinationPtr = '\\0';\n                }\n            }\n            \n            if (remainingSize != 0) {\n                return 0; \n            }\n            \n            if (maxCopyCount == 0xffffffff) {\n                destinationBuffer[destinationSize - 1] = '\\0'; \n                return 0x50; \n            }\n            *destinationBuffer = '\\0'; \n            __errno()[0] = 0x22; \n            goto LAB_100269c8; \n        }\n    }\n    __errno()[0] = 0x16; \nLAB_100269c8:\n    __invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    return 0x16; \n}"}
{"Function Name": "__strdup", "Address": "10026a53", "Source Code": "char * __cdecl __strdup(char *sourceString) \n{\n    char *duplicatedString; \n    size_t sourceLength; \n    if (sourceString == (char *)0x0) { \n        return (char *)0x0; \n    }\n    sourceLength = _strlen(sourceString); \n    duplicatedString = (char *)_malloc(sourceLength + 1); \n    if (duplicatedString == (char *)0x0) { \n        return (char *)0x0; \n    }\n    if (_strcpy_s(duplicatedString, sourceLength + 1, sourceString) != 0) { \n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    return duplicatedString; \n}"}
{"Function Name": "Unwind@10027a20", "Address": "10027a20", "Source Code": "void unwindFunction(void) \n{\n    anotherFunction(); \n}"}
{"Function Name": "Unwind@10027d50", "Address": "10027d50", "Source Code": "void unwindFunction(void) \n{\n    callFunction(); \n}"}
{"Function Name": "KERNEL32.DLL::RtlUnwind", "Address": "10026b70", "Source Code": "void RtlUnwind(PVOID framePointer, PVOID instructionPointer, PEXCEPTION_RECORD exceptionInfo, PVOID returnVal)\n{\n    \n    RtlUnwind(framePointer, instructionPointer, exceptionInfo, returnVal);\n}"}
{"Function Name": "FUN_10001700", "Address": "10001700", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_1001deaa", "Address": "1001deaa", "Source Code": "undefined4 myFunction(void)\n{\n    \n    return 1;\n}"}
{"Function Name": "FUN_10021753", "Address": "10021753", "Source Code": "undefined4 function_return_one(void)\n{\n    \n    return 1;\n}"}
{"Function Name": "FUN_10001b70", "Address": "10001b70", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_100020d0", "Address": "100020d0", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return -1;\n}"}
{"Function Name": "FUN_1001dd1f", "Address": "1001dd1f", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "FUN_100020e0", "Address": "100020e0", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return -1;\n}"}
{"Function Name": "Catch@1000869d", "Address": "1000869d", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x10008689;\n}"}
{"Function Name": "FUN_1000c560", "Address": "1000c560", "Source Code": "undefined4 myFunction(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_10002120", "Address": "10002120", "Source Code": "void executeFunction(void) {\n    \n}"}
